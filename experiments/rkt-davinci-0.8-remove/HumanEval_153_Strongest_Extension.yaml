name: HumanEval_153_Strongest_Extension
language: rkt
prompt: "#lang racket\n\n;; You will be given the name of a class (a string) and a\
  \ list of extensions.\n;; The extensions are to be used to load additional classes\
  \ to the class. The\n;; strength of the extension is as follows: Let CAP be the\
  \ number of the uppercase\n;; letters in the extension's name, and let SM be the\
  \ number of lowercase letters \n;; in the extension's name, the strength is given\
  \ by the fraction CAP - SM. \n;; You should find the strongest extension and return\
  \ a string in this \n;; format: ClassName.StrongestExtensionName.\n;; If there are\
  \ two or more extensions with the same strength, you should\n;; choose the one that\
  \ comes first in the list.\n;; For example, if you are given \"Slices\" as the class\
  \ and a list of the\n;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then\
  \ you should\n;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest\
  \ extension \n;; (its strength is -1).\n;; Example:\n(define (Strongest_Extension\
  \ class_name extensions)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n\
  \    (check-equal? (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\"))\
  \ \"Watashi.eIGHt8OKe\")\n    (check-equal? (candidate \"Boku123\" (list \"nani\"\
  \ \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\")\n    (check-equal?\
  \ (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\"\
  \ \"123NoooneB321\")) \"__YESIMHERE.NuLl__\")\n    (check-equal? (candidate \"K\"\
  \ (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\")\n    (check-equal? (candidate\
  \ \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\")\n    (check-equal?\
  \ (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"\
  -_-\")) \"YameRore.okIWILL123\")\n    (check-equal? (candidate \"finNNalLLly\" (list\
  \ \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\")\n    (check-equal? (candidate\
  \ \"_\" (list \"Bb\" \"91245\")) \"_.Bb\")\n    (check-equal? (candidate \"Sp\"\
  \ (list \"671235\" \"Bb\")) \"Sp.671235\")\n))\n\n(test-humaneval)"
completions: ["  (let ([extension-strength (map (lambda (extension)\n            \
    \                       (let ([small (count (lambda (c)\n                    \
    \                                     (char-lower-case? c))\n                \
    \                                       extension)])\n                       \
    \              (let ([cap (count (lambda (c)\n                               \
    \                          (char-upper-case? c))\n                           \
    \                            extension)])\n                                  \
    \     (cons (- cap small) extension))))\n                                 extensions)])\n\
    \    (define (strongest_extension es)\n      (if (null? (cdr es))\n          (car\
    \ es)\n          (if (< (car (car es)) (car (cadr es)))\n              (strongest_extension\
    \ (cdr es))\n              (strongest_extension (cons (car es) (cddr es))))))\n\
    \    (string-append class_name \".\" (cdr (strongest_extension extension-strength)))))\n\
    </code>\nYou might say \"What about <code>string-capitalize</code> and <code>string-lowercase</code>?\"\
    \ and you are right, it's in Racket too!\nWhy am I doing this? I was trying to\
    \ get used to writing in a functional style and thought this was an interesting\
    \ problem that could be tackled.\n\n\nA:\n\nI'd use the <code>string-upcase</code>\
    \ and <code>string-downcase</code> functions rather than counting the number of\
    \ upper/lowercase characters. These don't count for Unicode capitalization, but\
    \ in this case I don't think it matters. I'd also use <code>apply</code> to <code>string-append</code>\
    \ which avoids creating intermediate lists and is more idiomatic (you can see\
    \ it as a really simple loop):\n<code>(define (Strongest_Extension class_name\
    \ extensions)\n  (apply string-append\n         (cons class_name\n           \
    \    (map (lambda (extension)\n                      (string-append \".\"\n  \
    \                                   (cons\n                                  \
    \    (string-upcase extension)\n                                      (string-downcase\
    \ extension))))\n                   extensions))))\n</code>\n", "  (define (strength\
    \ str)\n    (let ([cap (count-if char-upcase? str)]\n          [sm (count-if char-lowercase?\
    \ str)])\n      (/ cap sm)))\n  (define (find-strongest exts)\n    (cond\n   \
    \   [(null? exts) (error \"Empty list\")]\n      [(null? (cdr exts)) (car exts)]\n\
    \      [else\n       (let ([first-ext (car exts)]\n             [next-ext (cadr\
    \ exts)])\n         (if (> (strength first-ext) (strength next-ext))\n       \
    \      (find-strongest (cons first-ext (cddr exts)))\n             (find-strongest\
    \ (cons next-ext (cddr exts)))))\n       ]))\n  (find-strongest extensions))\n\
    </code>\nYour feedback is most welcome.\n\n\nA:\n\nYou can use <code>string-&gt;list</code>\
    \ to turn a string into a list of characters, which then can be easily split into\
    \ upper and lower cases.\n<code>(define (strength str)\n  (let ([cap (count-if\
    \ char-upcase? (string-&gt;list str))]\n        [sm (count-if char-lowercase?\
    \ (string-&gt;list str))])\n    (/ cap sm)))\n</code>\nTo select the strongest\
    \ extension, you can use <code>foldl</code>.\n<code>(define (strongest-extension\
    \ class-name extensions)\n  (foldl\n   (lambda (ext curr)\n     (if (&gt; (strength\
    \ ext) (strength curr))\n         ext\n         curr))\n   (car extensions)\n\
    \   (cdr extensions)))\n</code>\n", "  (string-append class_name \".\"\n     \
    \            (car (filter (lambda (ext) (eq? (strength ext) (max-strength extensions)))\n\
    \                              extensions))))\n", "  (displayln class_name)\n\
    \  (displayln extensions)\n  ;; if no extensions return class\n  (if (empty? extensions)\
    \ class_name\n  ;; else reduce to strongest extension\n  (let ([strongest (reduce\
    \ (lambda (x y)\n                             (let ([x_cap (count-capital-letters\
    \ x)]\n                                   [x_sm (count-small-letters x)]\n   \
    \                                [y_cap (count-capital-letters y)]\n         \
    \                          [y_sm (count-small-letters y)])\n                 \
    \              (if (> (- x_cap x_sm) (- y_cap y_sm)) x y)))\n                \
    \           extensions)])\n    (string-append class_name \".\" strongest))))\n",
  "  (define cap-sm-diff (lambda (string)\n                       (-\n           \
    \             (length (regexp-match-positions #rx\"[A-Z]\" string))\n        \
    \                (length (regexp-match-positions #rx\"[a-z]\" string)))))\n  (cond\n\
    \    [(empty? extensions) \"Strongest extension not found\"]\n    [(= (cap-sm-diff\
    \ (car extensions)) (cap-sm-diff (car (cdr extensions))))\n      (string-append\
    \ class_name \".\" (car extensions))]\n    [(> (cap-sm-diff (car extensions))\
    \ (cap-sm-diff (car (cdr extensions))))\n      (string-append class_name \".\"\
    \ (car extensions))]\n    [else\n      (Strongest_Extension class_name (cdr extensions))]))\n",
  "  (define (extension-strength name)\n    (let* ([upper_case (string-upper-case\
    \ name)]\n           [lower_case (string-lower-case name)]\n           [upper_case_number\
    \ (string-length upper_case)]\n           [lower_case_number (string-length lower_case)])\n\
    \      (- upper_case_number lower_case_number)))\n  (let ([extensions_with_strength\
    \ (map (lambda (extension)\n                                         (cons extension\
    \ (extension-strength extension)))\n                                       extensions)])\n\
    \    (define (strongest_extension extensions_with_strength)\n      (if (null?\
    \ extensions_with_strength)\n          \"Error\"\n          (if (null? (cdr extensions_with_strength))\n\
    \              (car extensions_with_strength)\n              (if (< (cdr (car\
    \ extensions_with_strength)) (cdr (cadr extensions_with_strength)))\n        \
    \          (strongest_extension (cdr extensions_with_strength))\n            \
    \      (strongest_extension (cons (car extensions_with_strength)\n           \
    \                                  (cddr extensions_with_strength)))))))\n   \
    \ (string-append class_name \".\" (car (strongest_extension extensions_with_strength)))))\n",
  "  (let* ((extensions_with_strength (map (lambda (extension) (cons extension (fraction_strength\
    \ extension))) extensions))\n         (strongest_extension (apply max extensions_with_strength\
    \ (lambda (x y) (if (> (cdr x) (cdr y)) x y)))))\n    (string-append class_name\
    \ \".\" (car strongest_extension))))\n", "  (let ((strongest (extension-strength-info\
    \ (first extensions))))\n    (for-each\n     (lambda (e)\n       (let ((s (extension-strength-info\
    \ e)))\n         (set! strongest\n               (if (> (first s) (first strongest))\n\
    \                   s\n                   strongest))))\n     (rest extensions))\n\
    \    (format \"~a.~a\" class_name (second strongest))))\n", "  (define (strength\
    \ str)\n    (let ([upper (count (char-range #\\A #\\Z) str)]\n          [lower\
    \ (count (char-range #\\a #\\z) str)])\n      (- upper lower)))\n  (define (my-member\
    \ x lst)\n    (cond [(empty? lst) #f]\n          [(eq? x (car lst)) #t]\n    \
    \      [else (my-member x (cdr lst))]))\n  (define (update-mapping cls exts)\n\
    \    (cond [(empty? exts) cls]\n          [(my-member (car exts) (cdr exts)) (update-mapping\
    \ cls (cdr exts))]\n          [else (update-mapping (string-append cls \".\" (car\
    \ exts)) (cdr exts))]))\n  (define (my-max lst mx)\n    (cond [(empty? lst) mx]\n\
    \          [(> (strength (car lst)) (strength mx)) (my-max (cdr lst) (car lst))]\n\
    \          [else (my-max (cdr lst) mx)]))\n  (update-mapping class_name (my-max\
    \ extensions \"\")))\n", "  (define (strength string)\n    (define (list->count\
    \ lst)\n      (if (null? lst)\n          0\n          (+ 1 (list->count (cdr lst)))))\n\
    \    (- (list->count (regexp-match* #rx\"[A-Z]\" string))\n       (list->count\
    \ (regexp-match* #rx\"[a-z]\" string))))\n  (define (string-sort lst)\n    (sort\
    \ lst < #:key (\u03BB (x) (strength x))))\n  (let* ([strongest (first (string-sort\
    \ extensions))]\n         [class-extension (format \"~a.~a\" class_name strongest)])\n\
    \    class-extension))", "  (define (strength_of str)\n    (let ([upper-count\
    \ (count (char-set-intersection str (char-set #\\A #\\Z)))]\n          [lower-count\
    \ (count (char-set-intersection str (char-set #\\a #\\z)))])\n      (- upper-count\
    \ lower-count)))\n  (define (strongest-extensions strs)\n    (for/first ([s strs]\
    \ #:when (> (strength_of s) (strength_of (first strs))))\n      s))\n  (define\
    \ (concatenate str1 str2)\n    (string-append str1 \".\" str2))\n  (concatenate\
    \ class_name (strongest-extensions extensions)))\n", "  (define (calc_strength\
    \ extension)\n    (let ((caps (list->string (list-ref extension 0)))\n       \
    \   (sm (list->string (list-ref extension 1))))\n      (/ (string-length caps)\
    \ (string-length sm))))\n  (define (split_extension extension)\n    (let ((caps\
    \ (regexp-match* #rx\"[A-Z]\" extension))\n          (sm (regexp-match* #rx\"\
    [a-z]\" extension)))\n      (list caps sm)))\n  (define (by_strength extension)\n\
    \    (let ((str_ext (split_extension extension)))\n      (- (calc_strength str_ext)\
    \ (calc_strength str_ext))))\n  (define (find_strongest_extension extensions)\n\
    \    (cond ((null? extensions) 'NONE)\n          ((= (car extensions)\n      \
    \        (fold by_strength (car extensions) (cdr extensions)))\n             \
    \ (car extensions))\n          (else (find_strongest_extension (cdr extensions)))))\n\
    \  (string-append class_name \".\" (find_strongest_extension extensions)))", " \
    \ (let* ([cap-sm (map (lambda (s) (- (count-if char-upper-case? s)\n         \
    \                            (count-if char-lower-case? s)))\n               \
    \         extensions)]\n         [len-cap-sm (combine (list-&gt;vector extensions)\
    \ (list-&gt;vector cap-sm))]\n         [sorted-len-cap-sm (sort len-cap-sm (lambda\
    \ (p1 p2) (&gt; (cadr p1) (cadr p2))))]\n         [sorted-len (map car sorted-len-cap-sm)])\n\
    \    (string-append class_name \".\" (vector-ref sorted-len 0))))\n</code>\n",
  "  (define (count-upper str)\n    (length\n     (filter char-upper-case? (string->list\
    \ str))))\n  (define (count-lower str)\n    (length\n     (filter char-lower-case?\
    \ (string->list str))))\n  (define (strength name)\n    (/ (- (count-upper name)\
    \ (count-lower name))\n       (length name)))\n  (define (find-strongest extensions)\n\
    \    (define (find-one x rest)\n      (if (null? rest)\n          x\n        \
    \  (if (> (strength x) (strength (car rest)))\n              (find-one x (cdr\
    \ rest))\n              (find-one (car rest) (cdr rest)))))\n    (find-one (car\
    \ extensions) (cdr extensions)))\n  (string-append class_name \".\" (find-strongest\
    \ extensions)))\n", "  (string-append class_name \".\" (list-ref (sort (cons \"\
    Empty\" extensions) strongest?) 1)))\n", "  (let ((ext (sort (for/list ([e extensions])\n\
    \                    (list e\n                          (let loop ([i 0] [cap\
    \ 0] [sm 0])\n                            (cond [(zero? i) (/ cap sm)]\n     \
    \                             [(char-upcase? (string-ref e i)) (loop (- i 1) (+\
    \ cap 1) sm)]\n                                  [(char-lower-case? (string-ref\
    \ e i)) (loop (- i 1) cap (+ sm 1))]\n                                  [else\
    \ (loop (- i 1) cap sm)]))))\n                   (lambda (a b) (< (cadr a) (cadr\
    \ b))))))\n    (string-append class_name \".\" (caar ext))))\n", "  (define (strength\
    \ extension)\n    (define (is_lowercase_char? c)\n      (and (&gt;= c #\\a) (&lt;=\
    \ c #\\z)))\n    (define (is_uppercase_char? c)\n      (and (&gt;= c #\\A) (&lt;=\
    \ c #\\Z)))\n    (define (count cstr pred)\n      (define (count-helper str acc)\n\
    \        (if (null? str)\n            acc\n            (count-helper (cdr str)\n\
    \                          (if (pred (car str))\n                            \
    \  (+ acc 1)\n                              acc))))\n      (count-helper (string-&gt;list\
    \ cstr) 0))\n    (/ (- (count extension is_uppercase_char?)\n          (count\
    \ extension is_lowercase_char?))\n       1.0))\n  (define (extension-with-max-strength\
    \ strs)\n    (define (extension-with-max-strength-helper strs max-str)\n     \
    \ (if (null? strs)\n          max-str\n          (extension-with-max-strength-helper\n\
    \           (cdr strs)\n           (if (&gt; (strength (car strs))\n         \
    \         (strength max-str))\n               (car strs)\n               max-str))))\n\
    \    (extension-with-max-strength-helper (cdr strs) (car strs)))\n  (format \"\
    ~a.~a\" class_name (extension-with-max-strength extensions)))\n", "  (define (aux2\
    \ x y)\n    (cond ((= (abs (- (number-of-uppercase-letters x) (number-of-lowercase-letters\
    \ x)))\n            (abs (- (number-of-uppercase-letters y) (number-of-lowercase-letters\
    \ y))))\n          (string<? x y))\n          ((< (abs (- (number-of-uppercase-letters\
    \ x) (number-of-lowercase-letters x)))\n              (abs (- (number-of-uppercase-letters\
    \ y) (number-of-lowercase-letters y))))\n          #t)\n          (else #f)))\n\
    \  (string-append class_name \".\" (car (sort (lambda (x y) (aux2 x y)) extensions))))",
  "  (let ((extensions (sort extensions \n\t\t\t  (lambda (ext1 ext2)\n\t\t\t    (>\
    \ (strong ext1) (strong ext2))))))\n    (string-append class_name \".\" (car extensions))))\n",
  "  (define letters-of-extension\n    (lambda (extension)\n      (map char-upcase\
    \ (string->list extension))))\n  (define strength-of-extension\n    (lambda (extension)\n\
    \      (define caps (- (length (filter char-upper-case? (letters-of-extension\
    \ extension)))\n                      (length (filter char-lower-case? (letters-of-extension\
    \ extension)))))\n      (define sm (- (length (filter char-lower-case? (letters-of-extension\
    \ extension)))\n                    (length (filter char-upper-case? (letters-of-extension\
    \ extension)))))\n      (define strength (- caps sm))\n      strength))\n  (define\
    \ strongest-extension\n    (lambda (extensions)\n      (match extensions\n   \
    \     [(list) false]\n        [(list extension extensions ...)\n         (if (<=\
    \ (strength-of-extension extension) (strength-of-extension (strongest-extension\
    \ extensions)))\n             (strongest-extension extensions)\n             extension)])))\n\
    \  (string-append class_name \".\" (strongest-extension extensions)))\n", "  (letrec\
    \ ([capitalize (lambda (lst) \n                         (if (null? lst) '()\n\
    \                             (cons (+ (char-upcase (car lst)) (- (char-downcase\
    \ (car lst)) (car lst))) (capitalize (cdr lst)))))\n           [sum (lambda (lst)\n\
    \                  (if (null? lst) 0 (+ (car lst) (sum (cdr lst)))))\n       \
    \    [strength (lambda (ext)\n                       (/ (sum (capitalize ext))\
    \ (length ext)))\n           [strength_lst (lambda (extensions)\n            \
    \               (if (null? extensions) '()\n                               (cons\
    \ (strength (car extensions)) (strength_lst (cdr extensions)))))\n           [max-ext\
    \ (lambda (extensions)\n                      (if (null? extensions) \"\"\n  \
    \                        (if (= (car extensions) (apply max (strength_lst extensions)))\
    \ (car extensions) (max-ext (cdr extensions)))))])\n    (string-append class_name\
    \ \".\" (max-ext extensions))))\n", "  (match (find-extensions class_name extensions)\n\
    \    [(struct found_extensions (class_name strongest_extension))\n     (string-append\
    \ class_name \".\" strongest_extension)]))\n", "  (match (map (\u03BB (x)\n  \
    \              (let ([caps (count-chars (\u03BB (c) (char-upper-case? c)) x)]\n\
    \                      [smalls (count-chars (\u03BB (c) (char-lower-case? c))\
    \ x)])\n                  (list (list - (/ caps smalls)) x)))\n              extensions)\n\
    \    [(list (list strength x) ...)\n     (string-append class_name \".\" (cadr\
    \ (sort (\u03BB (x y) (string<? (cadr x) (cadr y)))\n                        \
    \                       (list (list strength x) ...))))]))\n", "  (define (ext-to-list\
    \ ext)\n    (list ext (string-&gt;list ext)))\n  (define (ext-to-strength ext)\n\
    \    (- (count (lambda (c) (char-upper-case? c)) ext)\n       (count (lambda (c)\
    \ (char-lower-case? c)) ext)))\n  (define (ext-to-pair ext)\n    (list (ext-to-strength\
    \ ext) ext))\n  (define (sorted-pairs lst)\n    (sort lst &lt; #:key car))\n \
    \ (string-append class_name\n                 \".\"\n                 (cadr (first\
    \ (sorted-pairs (map ext-to-pair extensions))))))\n", "  (let* ((ext (first (sort\
    \ extensions (\u03BB (x y) (< (ext-strength x) (ext-strength y))))))\n       \
    \  (ext-name (string-replace ext #rx\" \" #f))\n         (ext-strength (\u03BB\
    \ (ext) \n                         (round (- (regexp-match* #rx\"\\p{Upper}\"\
    \ ext)\n                                   (regexp-match* #rx\"\\p{Lower}\" ext))))))\n\
    \    (printf \"~a.~a\" class_name ext-name)))\n", "  ;; Keep track of the strongest\
    \ extension and its strength.\n  (define strongest_extension \"\")\n  (define\
    \ strongest_strength 0)\n  ;; Iterate through each extension\n  (for ([extension\
    \ extensions])\n    ;; Find the strength of this extension\n    (define this_strength\
    \ (/ (- (count-upper-case extension)\n                                (count-lower-case\
    \ extension))\n                             (string-length extension)))\n    ;;\
    \ See if it is the strongest yet found\n    (if (> this_strength strongest_strength)\n\
    \        (begin\n          (set! strongest_extension extension)\n          (set!\
    \ strongest_strength this_strength))))\n  ;; Return the class and extension with\
    \ the strongest strength\n  (string-append class_name \".\" strongest_extension))\n",
  "  ;; This function will return the name of the strongest extension\n  (define (get-strength\
    \ ext)\n    (let ([cap (- count (filter-map char-downcase ext))]\n          [sm\
    \ (- count (filter-map char-upcase ext))])\n      (/ cap sm)))\n  ;; This function\
    \ finds the extension with the strongest strength\n  (define (find-strongest-ext\
    \ ext_list)\n    (cond ((null? ext_list) '())\n          ((> (get-strength (car\
    \ ext_list))\n              (get-strength (cadr ext_list)))\n           (car ext_list))\n\
    \          (else (find-strongest-ext (cdr ext_list)))))\n  (string-append class_name\
    \ \".\" (find-strongest-ext extensions)))\n</code>\nMy main problem is the get-strength\
    \ function. I tried creating the two variables for cap and sm using the filter-map\
    \ function and that doesn't work. I'm not sure what's wrong with the function.\
    \ Thanks in advance.\n\n\nA:\n\nI think you want to use <code>count</code> instead\
    \ of <code>filter-map</code>:\n<code>(define (get-strength ext)\n  (let ([cap\
    \ (count char-upcase ext)]\n        [sm (count char-downcase ext)])\n    (/ cap\
    \ sm)))\n</code>\nHere's a more concise version of the same thing, using <code>-\
    \ count</code> to subtract the number of lowercase letters from the number of\
    \ uppercase letters:\n<code>(define (get-strength ext)\n  (- (count char-upcase\
    \ ext) (count char-downcase ext)))\n</code>\nAlso note that you should use <code>-&gt;string</code>\
    \ in your final <code>string-append</code> call, or use <code>format</code> instead:\n\
    <code>(string-append class_name \".\" (find-strongest-ext extensions))", "  (for/first\
    \ ([i (in-list extensions)]\n              #:when (= i (apply max (map (\u03BB\
    \ (e) (/ (- (length (regexp-match #rx\"[A-Z]\" e))\n                         \
    \                                  (length (regexp-match #rx\"[a-z]\" e))))\n\
    \                                                    extensions))))\n    (string-append\
    \ class_name \".\" i)))\n</code>\n", "  (string-append\n   class_name\n   \".\"\
    \n   (let ([exts (map (\u03BB (s) (cons (substring s 0 1) (substring s 1))) extensions)])\n\
    \     (cond\n       [(empty? exts) \"\"]\n       [(empty? (rest exts)) (first\
    \ exts)]\n       [else (let ([l (list (first exts))])\n               (for ([e\
    \ (rest exts)])\n                 (if (< (class-strength l) (class-strength e))\n\
    \                     (set! l (list e))\n                     (if (= (class-strength\
    \ l) (class-strength e))\n                         (set! l (cons e l)))))\n  \
    \             (first l))]))))", "  (local [(define (ext-strength str)\n      \
    \      (for/fold ([strength 0])\n                      ([c (in-string str)])\n\
    \              (cond [(char-upcase? c) (+ strength 1)]\n                    [(char-lowercase?\
    \ c) (- strength 1)]\n                    [else strength])))\n          (define\
    \ (strongest-ext ext_lst)\n            (match ext_lst\n              [(list) (error\
    \ 'strongest-ext \"Empty list\")]\n              [(list first rest ...)\n    \
    \           (match rest\n                 [(list) first]\n                 [(list\
    \ (and (? (lambda (y) (> (ext-strength y) (ext-strength first)))) \n         \
    \                    next rest ...) ...)\n                  (strongest-ext (cons\
    \ next rest))]\n                 [(list (and (? (lambda (y) (<= (ext-strength\
    \ y) (ext-strength first))))\n                             rest ...) ...)\n  \
    \                (strongest-ext (cons first rest))])]))]\n    (string-append class_name\
    \ \".\" (strongest-ext extensions))))\n", "  (define (letters s)\n    (if (char-alphabetic?\
    \ (string-ref s 0))\n        (cons (string-ref s 0) (letters (substring s 1)))\n\
    \        '()))\n  (define (count-upper l)\n    (if (null? l)\n        0\n    \
    \    (if (char-upper-case? (car l))\n            (+ 1 (count-upper (cdr l)))\n\
    \            (count-upper (cdr l)))))\n  (define (count-lower l)\n    (if (null?\
    \ l)\n        0\n        (if (char-lower-case? (car l))\n            (+ 1 (count-lower\
    \ (cdr l)))\n            (count-lower (cdr l)))))\n  (define (extension-strength\
    \ ext)\n    (/ (- (count-upper (letters ext)) (count-lower (letters ext))) (length\
    \ ext)))\n  (define (strongest-ext-name extensions)\n    (if (null? extensions)\n\
    \        '()\n        (if (null? (cdr extensions))\n            (car extensions)\n\
    \            (if (&gt; (extension-strength (car extensions)) (extension-strength\
    \ (cadr extensions)))\n                (car extensions)\n                (strongest-ext-name\
    \ (cdr extensions))))))\n  (string-append class_name \".\" (strongest-ext-name\
    \ extensions)))\n</code>\nAre there any solutions that work just on the list of\
    \ extensions? Something like the following pseudocode:\n<code>(define (Strongest_Extension\
    \ extensions)\n  (if (null? extensions)\n      '()\n      (if (null? (cdr extensions))\n\
    \          (car extensions)\n          (if (&gt; (extension-strength (car extensions))\
    \ (extension-strength (cadr extensions)))\n              (car extensions)\n  \
    \            (strongest-ext-name (cdr extensions))))))\n</code>\nIf so, it would\
    \ be great if someone can show me how to write it. Thank you.\n\n\nA:\n\nTwo issues.\
    \ First, your <code>letters</code> function is not tail-recursive and will therefore\
    \ overflow the stack for long strings. Rewrite using <code>string-append</code>.\
    \ Second, you", "  (let ([c (string-length (regexp-replace* #rx\"[^A-Z]\" class_name\
    \ \"\"))]\n        [s (string-length (regexp-replace* #rx\"[^a-z]\" class_name\
    \ \"\"))])\n    (let loop ([extensions extensions]\n               [curr-max (list\
    \ (car extensions) (exact->inexact (/ (- (string-length (regexp-replace* #rx\"\
    [^A-Z]\" (car extensions) \"\"))\n                                           \
    \                        (string-length (regexp-replace* #rx\"[^a-z]\" (car extensions)\
    \ \"\")))\n                                                               (- c\
    \ s))))])\n      (if (null? (cdr extensions))\n          (regexp-replace* #rx\"\
    \ \" (string-append class_name \".\" (car curr-max)) \"\")\n          (let ([cap\
    \ (string-length (regexp-replace* #rx\"[^A-Z]\" (cadr extensions) \"\"))]\n  \
    \              [sm (string-length (regexp-replace* #rx\"[^a-z]\" (cadr extensions)\
    \ \"\"))])\n            (if (<= (exact->inexact (/ (- cap sm) (- c s))) (cadr\
    \ curr-max))\n                (loop (cdr extensions) curr-max)\n             \
    \   (loop (cdr extensions) (list (cadr extensions) (exact->inexact (/ (- cap sm)\
    \ (- c s)))))))))))\n", "  (let ([extension-strength\n         (for/list ([extension\
    \ extensions])\n           (define cap (count (regexp-match* #rx\"[A-Z]\" extension)))\n\
    \           (define sm (count (regexp-match* #rx\"[a-z]\" extension)))\n     \
    \      (cons extension (- cap sm)))])\n    (string-append class_name \".\"\n \
    \                  (caar (cadr (sort extension-strength\n                    \
    \                 (\u03BB (x y) (< (cdr x) (cdr y)))))))))\n</code>\n", "  (if\
    \ (equal? (length extensions) 0)\n      class_name\n      (let ([strength (for/fold\
    \ ([strength '()]) ([ext (in-list extensions)])\n                         (if\
    \ (or (equal? strength '())\n                                 (< (- (length (regexp-match*\
    \ #rx\"^[A-Z]*\" ext))\n                                      (length (regexp-match*\
    \ #rx\"^[a-z]*\" ext)))\n                                    (cadr strength)))\n\
    \                             (list strength (vector (- (length (regexp-match*\
    \ #rx\"^[A-Z]*\" ext))\n                                                     \
    \   (length (regexp-match* #rx\"^[a-z]*\" ext)))\n                           \
    \                         ext)\n                                   ext)\n    \
    \                         strength)))])\n            (format \"~a.~a\" class_name\
    \ (caddr strength)))))", "  (define (strength extension)\n    (let ((caps (count-if\
    \ char-upper-case? extension))\n          (smalls (count-if char-lower-case? extension)))\n\
    \      (- caps smalls)))\n  (define (stronger? extension1 extension2)\n    (>\
    \ (strength extension1) (strength extension2)))\n  (define (extension_string extension)\n\
    \    (string-append class_name \".\" extension))\n  (let ((strongest (extension_string\
    \ (first extensions))))\n    (foldl (lambda (extension acc)\n             (if\
    \ (stronger? extension acc)\n                 (extension_string extension)\n \
    \                acc))\n           strongest\n           extensions)))\n", " \
    \ (define (calc_strength ext)\n    (let ([cap (count (compose char-upcase char-downcase)\
    \ ext)]\n          [sm (count char-downcase ext)])\n      (/ cap sm)))\n  (string-append\
    \ class_name \".\"\n                 (first (sort (map cadr\n                \
    \                     (sort (map (lambda (x) (cons (calc_strength x) x))\n   \
    \                                             extensions)\n                  \
    \                         <))\n                              string<?))))\n</code>\n\
    With a little bit of cleanup, you can get\n<code>#lang racket\n", "  (define (extension-strength\
    \ ext)\n    (define (char-case c)\n      (cond\n        [(char-upper-case? c)\
    \ 1]\n        [(char-lower-case? c) -1]\n        [else 0]))\n    (define (ext-strength\
    \ ext)\n      (cond\n        [(null? ext) 0]\n        [else (+ (char-case (car\
    \ ext)) (ext-strength (cdr ext)))]))\n    (ext-strength ext))\n  (define (extension-name\
    \ ext)\n    (string-append class_name \".\" ext))\n  (define (strength-sort a\
    \ b)\n    (< (extension-strength a) (extension-strength b)))\n  (extension-name\
    \ (car (sort strength-sort extensions))))\n", "  (cond\n    [(empty? extensions)\
    \ class_name]\n    [else (let* \n            ([extension (car extensions)]\n \
    \            [strength (strength_of_extension extension)]\n             [ext_strength\
    \ (strength_of_extension (Strongest_Extension class_name (cdr extensions)))]\n\
    \             [new_ext (cond [(> strength ext_strength) extension]\n         \
    \                   [(= strength ext_strength)\n                             (cond\n\
    \                               [(> (string<? extension (Strongest_Extension class_name\
    \ (cdr extensions))) 0) extension]\n                               [else (Strongest_Extension\
    \ class_name (cdr extensions))])]\n                            [else (Strongest_Extension\
    \ class_name (cdr extensions))])])\n           (string-append class_name \".\"\
    \ new_ext))]))\n", "  (define (count_caps str)\n    (string-fold + str 0 (lambda\
    \ (s i) (if (char-upcase? s) 1 0))))\n  (define (count_lower str)\n    (string-fold\
    \ + str 0 (lambda (s i) (if (char-lowercase? s) 1 0))))\n  (define (ext_strength\
    \ s)\n    (- (count_caps s) (count_lower s)))\n  (define (strongest_ext ext_list)\n\
    \    (if (null? ext_list)\n        \"\"\n        (if (or (null? (cdr ext_list))\
    \ (equal? (ext_strength (car ext_list)) (ext_strength (cadr ext_list))))\n   \
    \         (car ext_list)\n            (strongest_ext (cdr ext_list)))))\n  (define\
    \ (ext_str_to_class class)\n    (string-append class_name \".\" class))\n  (ext_str_to_class\
    \ (strongest_ext extensions)))\n", "  (string-append\n   class_name\n   \".\"\n\
    \   (car\n    (sort\n     (map\n      (lambda (extension)\n        (define (count-uppercase\
    \ s)\n          (if (string-empty? s)\n              0\n              (if (char-upper-case?\
    \ (string-ref s 0))\n                  (+ 1 (count-uppercase (substring s 1)))\n\
    \                  (count-uppercase (substring s 1)))))\n        (define (count-lowercase\
    \ s)\n          (if (string-empty? s)\n              0\n              (if (char-lower-case?\
    \ (string-ref s 0))\n                  (+ 1 (count-lowercase (substring s 1)))\n\
    \                  (count-lowercase (substring s 1)))))\n        (list (string-append\
    \ class_name \".\" extension)\n              (/ (- (count-uppercase extension)\
    \ (count-lowercase extension))\n                 (string-length extension))))\n\
    \      extensions)\n     (lambda (a b)\n       (cond\n         [(< (abs (cadr\
    \ a)) (abs (cadr b))) #t]\n         [(> (abs (cadr a)) (abs (cadr b))) #f]\n \
    \        [else (< (string-length (car a)) (string-length (car b)))]))))))\n",
  "  (let ([STRONGEST (apply max (map (lambda (extension)\n                      \
    \               (let ([LOWER-COUNT (for/fold ([COUNT 0]) ([LETTER (in-string extension)])\n\
    \                                                                   (if (and (&lt;=\
    \ #\\a LETTER) (&gt;= #\\z LETTER))\n                                        \
    \                               (add1 COUNT)\n                               \
    \                                        COUNT))])\n                         \
    \              (round (/ (- (string-length extension) LOWER-COUNT) LOWER-COUNT))))\n\
    \                                   extensions))])\n    (string-append class_name\
    \ \".\" (string-downcase (list-ref extensions (position STRONGEST extensions))))))\n",
  "  (apply string-append\n         (list class_name \".\" (car (last (sort extensions\n\
    \                                               (\u03BB (x y) \n             \
    \                                     (< (strength x) (strength y)))))))))", "\t\
    (cond ((null? extensions) \"Class Does Not Exist\")\n\t\t  ((= (length extensions)\
    \ 1) (format \"~a.~a\" class_name (car extensions)))\n\t\t  (else\n\t\t\t(let\
    \ ((extensions (map (lambda (x) (string-split x #\\-)) extensions)))\n\t\t\t \
    \ (format \"~a.~a\" class_name (string-intercalate #\\- (car (sort extensions\
    \ (lambda (x y) (let ((x_val (string-fold (lambda (acc x) (if (char-upper-case?\
    \ x) (add1 acc) acc)) 0 (car x)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t(y_val (string-fold (lambda (acc x) (if (char-upper-case?\
    \ x) (add1 acc) acc)) 0 (car y))))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\t(> (fl / x_val (string-length (car y))) (fl / y_val\
    \ (string-length (car x))))))))))))\n", "  ;; so we'll create a helper function\n\
    \  (define (helper sequence)\n    ;; this function will take a sequence of extensions\
    \ and use first to get the\n    ;; first extension and the rest of the sequence.\n\
    \    (cond\n      [(empty? sequence) #f] ;; if the sequence is empty, return false\n\
    \      [else \n       ;; otherwise, return the first element and the result of\
    \ the helper \n       ;; function recursively applied to the rest of the sequence\n\
    \       (cons (first sequence) (helper (rest sequence)))]))\n  ;; now we'll make\
    \ a list of all the extensions returned by the helper function\n  (define extensions_list\
    \ (helper extensions))\n  ;; now we'll create a new function that will take the\
    \ list of extensions and \n  ;; iterate through them.\n  (define (total-strength\
    \ sequence)\n    ;; we'll give it an initial total strength of 0\n    (define\
    \ total_strength 0)\n    ;; we will use first to get the first extension and the\
    \ rest of the sequence\n    (cond\n      [(empty? sequence) total_strength] ;;\
    \ if the sequence is empty, we're done.\n      [else\n       ;; otherwise we'll\
    \ use a helper function to return a list of all the\n       ;; uppercase and lowercase\
    \ characters in the string.\n       (define (char-class str)\n         ;; so first\
    \ we'll get the first character from the string and the rest of\n         ;; the\
    \ string.\n         (cond\n           [(empty? str) '()] ;; if the string is empty,\
    \ return the empty list\n           [else\n            ;; otherwise we'll get\
    \ the class of the character using char-upcase? \n            ;; and char-downcase?\n\
    \            (cond\n              [(char-upcase? (first str)) \n             \
    \  ;; if the character is uppercase, return a list containing an 'A'\n       \
    \        ;; and the result of char-class recursively applied to the rest of\n\
    \               ;; the string\n               (cons 'A (char-class (rest str)))]\n\
    \              [(char-downcase? (first str))\n               ;; if the character\
    \ is lowercase, return a list containing an 'a'\n               ;; and the result\
    \ of char-class recursively applied to the rest of\n               ;; the string\n\
    \               (", "  (define (get_strength name)\n    (define (count_upper name)\n\
    \      (define (helper name count)\n        (cond\n          [(empty? name) count]\n\
    \          [(char-upper-case? (first name))\n           (helper (rest name) (+\
    \ count 1))]\n          [else (helper (rest name) count)]))\n      (helper name\
    \ 0))\n    (define (count_lower name)\n      (define (helper name count)\n   \
    \     (cond\n          [(empty? name) count]\n          [(char-lower-case? (first\
    \ name))\n           (helper (rest name) (+ count 1))]\n          [else (helper\
    \ (rest name) count)]))\n      (helper name 0))\n    (- (count_upper name) (count_lower\
    \ name)))\n  (define (helper names strength)\n    (cond\n      [(empty? names)\
    \ strength]\n      [(> (get_strength (first names)) strength)\n       (helper\
    \ (rest names) (get_strength (first names)))]\n      [else (helper (rest names)\
    \ strength)]))\n  (string-append class_name \".\"\n                 (first (filter\
    \ (lambda (name)\n                                  (= (get_strength name)\n \
    \                                    (helper extensions 0)))\n               \
    \                 extensions))))\n", "  ;; Your code here\n  )\n```\n\n## 5.3\
    \ Drawing the hexagon\n\nImagine you have a hexagon drawing class. It receives\
    \ a list of the coordinates \nof the points that make up the hexagon, and then\
    \ draw the hexagon on the screen.\nYou have to implement the hexagon drawing class\
    \ (and its methods).\n\n**NOTE:** The coordinates are the ones of the hexagon's\
    \ vertices, with the\nassumption that the hexagon is inscribed in a circle with\
    \ radius = 1.\n\n**NOTE:** for the screen drawing you can use the following function:\n\
    \n```racket\n#lang racket\n", "  (let ([cap (let ([caps (string-upper-case class_name)])\n\
    \               (string-length caps))]\n        [sm (let ([smalls (string-lower-case\
    \ class_name)])\n              (string-length smalls))])\n    (define (Strength\
    \ a-string)\n      (let ([c (let ([caps (string-upper-case a-string)])\n     \
    \            (string-length caps))]\n            [s (let ([smalls (string-lower-case\
    \ a-string)])\n                  (string-length smalls))])\n        (- c s)))\n\
    \    (define (Strongest lst)\n      (let ([slist (list->sorted-list\n        \
    \            (map (lambda (x)\n                           (Strength x))\n    \
    \                     lst))])\n        (car (assoc (car slist)\n             \
    \       (map (lambda (x)\n                           (list (Strength x) x))\n\
    \                         lst)))))\n    (string-append class_name \".\" (Strongest\
    \ extensions))))\n", "  (local ((define caps #rx\"[A-Z]\")\n          (define\
    \ lowers #rx\"[a-z]\")\n          (define (strength str) (- (regexp-match-positions\
    \ caps str 1)\n                                    (regexp-match-positions lowers\
    \ str 1))))\n  (string-append class_name \".\"\n                 (car (sort (map\
    \ strength extensions) >)))))\n", "  (let ([class_name (string->symbol class_name)])\n\
    \    (define strongest\n      (car (sort (map (\u03BB (extension)\n          \
    \              (cons extension (strength extension)))\n                      extensions)\n\
    \                  >\n                  #:key (\u03BB (extension-strength)\n \
    \                         (cdr extension-strength)))))\n    (symbol->string (string-append\
    \ class_name \".\" (car strongest)))))\n", "  (define (count_caps word)\n    (define\
    \ (is_upper? char)\n      (and (>= char #\\A) (<= char #\\Z)))\n    (let loop\
    \ ((rest_of_word word) (count 0))\n      (cond ((null? rest_of_word) count)\n\
    \            ((is_upper? (car rest_of_word)) (loop (cdr rest_of_word) (+ count\
    \ 1)))\n            (else (loop (cdr rest_of_word) count)))))\n  (define (count_smalls\
    \ word)\n    (define (is_lower? char)\n      (and (>= char #\\a) (<= char #\\\
    z)))\n    (let loop ((rest_of_word word) (count 0))\n      (cond ((null? rest_of_word)\
    \ count)\n            ((is_lower? (car rest_of_word)) (loop (cdr rest_of_word)\
    \ (+ count 1)))\n            (else (loop (cdr rest_of_word) count)))))\n  (define\
    \ (Strength word)\n    (/ (- (count_caps word) (count_smalls word))\n       (string-length\
    \ word)))\n  (let ((best_extension (car extensions))\n        (best_strength (Strength\
    \ (car extensions))))\n    (let loop ((rest_of_extensions (cdr extensions)))\n\
    \      (cond ((null? rest_of_extensions) (string-append class_name \".\" best_extension))\n\
    \            ((> (Strength (car rest_of_extensions)) best_strength)\n        \
    \     (set! best_extension (car rest_of_extensions))\n             (set! best_strength\
    \ (Strength (car rest_of_extensions)))\n             (loop (cdr rest_of_extensions)))\n\
    \            (else (loop (cdr rest_of_extensions)))))))\n", "\t(define (count_u\
    \ nb_u nb_l l)\n\t\t(cond\n\t\t\t[(= nb_u nb_l)\t\t\t\t\t'(0 . 0)]\n\t\t\t[(eq?\
    \ (char-upcase? (car l)) #t)\t(count_u (+ nb_u 1) nb_l (cdr l))]\n\t\t\t[else\t\
    \t\t\t\t\t\t(count_u nb_u (+ nb_l 1) (cdr l))]))\n\t(define (cap sm c l)\n\t\t\
    (cond\n\t\t\t[(= (car sm) (car l))\t\t\t\t(string-append class_name \".\" c)]\n\
    \t\t\t[(> (car sm) (car l))\t\t\t\t(cap sm c (cdr l))]\n\t\t\t[else\t\t\t\t\t\t\
    \t\t(cap (car l) (cadr l) (cdr l))]))\n\t(cap (count_u 0 0 (car extensions)) (car\
    \ extensions) (cdr extensions)))\n", "  (define (count_capital str)\n    (for/fold\
    \ ([counter 0]) ([ch (in-string str)])\n      (if (char-upper-case? ch)\n    \
    \    (add1 counter)\n        counter)))\n  (define (count_small str)\n    (for/fold\
    \ ([counter 0]) ([ch (in-string str)])\n      (if (char-lower-case? ch)\n    \
    \    (add1 counter)\n        counter)))\n  (define (strength name)\n    (- (count_capital\
    \ name) (count_small name)))\n  (define (map_strength lst)\n    (for/list ([i\
    \ lst])\n      (list (strength i) i)))\n  (define strength_list (map_strength\
    \ extensions))\n  (define (sort_st_list lst)\n    (sort lst (\u03BB (x y) (> (car\
    \ x) (car y)))))\n  (define (get_string_from_st_list lst)\n    (map (\u03BB (x)\
    \ (cadr x)) lst))\n  (define sorted_st_list (sort_st_list strength_list))\n  (define\
    \ string_list (get_string_from_st_list sorted_st_list))\n  (string-append class_name\
    \ \".\" (car string_list)))\n", "  (match-define (list class_name extensions)\n\
    \                (list \"Slices\" '(\"SErviNGSliCes\" \"Cheese\" \"StuFfed\")))\n\
    \  \"Slices.SErviNGSliCes\")\n", "  (define class_extensions\n    (map (lambda\
    \ (extension)\n           (cons (trim-left extension) extension))\n         extensions))\n\
    \  (define (count-strength str)\n    (let ((up_count (count-if char-upper-case?\
    \ str))\n          (lo_count (count-if char-lower-case? str)))\n      (- up_count\
    \ lo_count)))\n  (define strongest-extension\n    (foldr\n     (lambda (extension\n\
    \              strongest-extension)\n       (let ((extension-strength (count-strength\
    \ (cdr extension)))\n             (strongest-extension-strength\n            \
    \  (if (pair? strongest-extension)\n                  (count-strength (cdr strongest-extension))\n\
    \                  -1)))\n         (if (&gt; extension-strength\n            \
    \     strongest-extension-strength)\n             extension\n             strongest-extension)))\n\
    \     '()\n     class_extensions))\n  (format \"~a.~a\" class_name (cdr strongest-extension)))\n\
    </code>\nFor example:\n<code>(Strongest_Extension \"Slices\" '(\"SErviNGSliCes\"\
    \ \"Cheese\" \"StuFfed\"))\n\"Slices.SErviNGSliCes\"\n</code>\n", "    (let* ([exts-and-strengths\
    \ (map (\u03BB (e) (list e (strength e))) extensions)]\n           [sorted-exts-and-strengths\
    \ (sort exts-and-strengths (\u03BB (e1 e2) (string<? (car e1) (car e2))))]\n \
    \          [strongest-ext-and-strength (car (reverse sorted-exts-and-strengths))])\n\
    \      (format \"~a.~a\" class_name (car strongest-ext-and-strength))))\n", " \
    \ (define (calc_strength str)\n    (define cnt-upper 0)\n    (define cnt-lower\
    \ 0)\n    (for ([c (in-string str)])\n      (if (char-upper-case? c)\n       \
    \   (set! cnt-upper (+ cnt-upper 1))\n          (set! cnt-lower (+ cnt-lower 1)))\n\
    \      )\n    (- cnt-upper cnt-lower)\n    )\n  (define (get_ext strongest ext)\n\
    \    (if (null? ext)\n        strongest\n        (let ([current-strength (calc_strength\
    \ (car ext))])\n          (if (> current-strength (calc_strength strongest))\n\
    \              (get_ext (car ext) (cdr ext))\n              (get_ext strongest\
    \ (cdr ext))))))\n  (string-append class_name \".\" (get_ext \"\" extensions)))\n",
  "  (define (count-cap ext)\n    (for/sum ([c (in-string ext)])\n      (if (char-uppercase?\
    \ c) 1 0)))\n  (define (count-sm ext)\n    (for/sum ([c (in-string ext)])\n  \
    \    (if (char-lowercase? c) 1 0)))\n  (define (strength ext)\n    (/ (- (count-cap\
    \ ext) (count-sm ext)) (length ext)))\n  (string-append class_name \".\" (list-ref\
    \ (sort (map strength extensions) >) 0)))", "  (letrec\n    ([extension-strength\
    \ (lambda (extension)\n       (let ([extension-string (string->list extension)])\n\
    \         (/ (- (for/sum ([s extension-string])\n             (if (char-upper-case?\
    \ s) 1 0))\n             (for/sum ([s extension-string])\n               (if (char-lower-case?\
    \ s) 1 0))))))]\n     [extensions-strength (lambda (extensions)\n       (map extension-strength\
    \ extensions))]\n     [max-strength (lambda (strength-list)\n       (apply max\
    \ strength-list))]\n     [max-index (lambda (strength-list)\n       (argmax (lambda\
    \ (e1 e2)\n         (if (> e1 e2) e1 e2))\n         strength-list))]\n     [strongest-extension\
    \ (lambda (extensions)\n       (list-ref extensions (max-index (extensions-strength\
    \ extensions))))])\n    (string-append class_name \".\" (strongest-extension extensions))))\n",
  "  (string-append class_name \".\"\n          (car (sort extensions\n          \
    \      (lambda (s1 s2)\n                  (> (fraction s1) (fraction s2)))))))\n",
  "  (cond [(empty? extensions) \n         \"ClassName.ExtensionName\"]\n        [else\
    \ \n         (define (name-strength extension)\n           (define CAP (count-characters\
    \ extension #\\A #\\Z))\n           (define SM (count-characters extension #\\\
    a #\\z))\n           (/ CAP SM))\n         (define (find-max extensions)\n   \
    \        (define (find-max-iter extensions largest)\n             (cond [(empty?\
    \ extensions) largest]\n                   [else (if (> (name-strength (first\
    \ extensions))\n                                (name-strength largest))\n   \
    \                          (find-max-iter (rest extensions) (first extensions))\n\
    \                             (find-max-iter (rest extensions) largest))]))\n\
    \           (find-max-iter extensions (first extensions)))\n         (string-append\
    \ class_name \".\" (find-max extensions))]))", "    (let ([CAP (list->set (regexp-match*\
    \ #rx\"[A-Z]\" class_name))]\n          [SM (list->set (regexp-match* #rx\"[a-z]\"\
    \ class_name))])\n      (let loop ([extensions extensions]\n                 [result\
    \ \"\"]\n                 [strength (/ (set-size CAP) (set-size SM))])\n     \
    \   (cond [(empty? extensions) result]\n              [(let ([CAP-N (list->set\
    \ (regexp-match* #rx\"[A-Z]\" (first extensions)))])\n                 (let ([SM-N\
    \ (list->set (regexp-match* #rx\"[a-z]\" (first extensions)))])\n            \
    \       (let ([strength-N (/ (set-size CAP-N) (set-size SM-N))])\n           \
    \          (if (> strength-N strength)\n                         (loop (rest extensions)\
    \ (first extensions) strength-N)\n                         (loop (rest extensions)\
    \ result strength)))))\n               (loop (rest extensions) result strength)]))))\n\
    </code>\nThis is probably a little inefficient, but I am new to Racket and this\
    \ is my first program, so I am still trying to figure out what is idiomatic and\
    \ what isn't. \nI am looking for any and all suggestions. If you have any suggestions\
    \ on refactoring to make it more functional or efficient I would appreciate that.\n\
    \n\nA:\n\nI think the biggest issue I have with your code is that it needs some\n\
    indentation. It is difficult to read. Also, I don't like your use of <code>loop</code>\
    \ \nand your <code>let</code> expressions. I'd like to see a let-expression for\
    \ the initial\ndefinitions of <code>CAP</code> and <code>SM</code> as well. I'd\
    \ also like to see you replace <code>loop</code>\nwith a <code>letrec</code> expression,\
    \ and then possibly replace that with a more\nidiomatic <code>recurse</code> function.\n\
    I'd also like to see the <code>set-size</code> removed. I think it is unnecessary.\n\
    I'm not sure I would have used the parameters to <code>recurse</code> the way\
    \ you have\ndone, but I", "  (letrec\n      ((p (lambda (l)\n            (cond\n\
    \              [(empty? l) '()]\n              [(positive? (length (filter char-upper-case?\
    \ (string->list (car l)))))\n               (cons (car l) (p (cdr l)))]\n    \
    \          [else (p (cdr l))])))\n       (num (lambda (s)\n              (let\
    \ ((CAP (length (filter char-upper-case? (string->list s))))\n               \
    \     (SM (length (filter char-lower-case? (string->list s)))))\n            \
    \    (- CAP SM)))))\n    (cond\n      [(empty? extensions) '()]\n      [(empty?\
    \ (p extensions))\n       (string-append class_name (string-append \".\" (car\
    \ extensions)))]\n      [else\n       (let* ((Q (p extensions))\n            \
    \  (Head (car Q))\n              (HeadNum (num Head))\n              (Rest (cdr\
    \ Q))\n              (RestNum (num (car Rest))))\n         (cond\n           [(>\
    \ HeadNum RestNum)\n            (string-append class_name (string-append \".\"\
    \ Head))]\n           [(> RestNum HeadNum)\n            (string-append class_name\
    \ (string-append \".\" (car Rest)))]\n           [else\n            (string-append\
    \ class_name (string-append \".\" Head))]))])))\n", "  (let ([strongest (first\
    \ extensions)])\n    (for ([extension extensions])\n      (let ([cap-sm (strongest-extension\
    \ extension strongest)])\n        (when (&gt; cap-sm 0)\n          (set! strongest\
    \ extension))))\n    (string-append class_name \".\" strongest)))\n", "  (let\
    \ loop ((extensions extensions)\n             (max-strength 0)\n             (max-extension\
    \ '()))\n    (cond\n      [(empty? extensions)\n       (string-append class_name\
    \ \".\" max-extension)]\n      [else\n       (let ((extension (first extensions))\n\
    \             (strength (strength extension)))\n         (if (< strength max-strength)\n\
    \             (loop (rest extensions) max-strength max-extension)\n          \
    \   (loop (rest extensions) strength extension)))])))\n", "  (define (get_uc_cnt\
    \ str)\n    (let loop ((cnt 0) (lst (string->list str)))\n      (cond ((null?\
    \ lst) cnt)\n            ((char-upcase? (car lst)) (loop (+ cnt 1) (cdr lst)))\n\
    \            (else (loop cnt (cdr lst))))))\n  (define (get_lc_cnt str)\n    (let\
    \ loop ((cnt 0) (lst (string->list str)))\n      (cond ((null? lst) cnt)\n   \
    \         ((char-lower-case? (car lst)) (loop (+ cnt 1) (cdr lst)))\n        \
    \    (else (loop cnt (cdr lst))))))\n  (define (get_ext_strngth lst)\n    (let\
    \ loop ((lst lst) (strngth_lst '()))\n      (cond ((null? lst) strngth_lst)\n\
    \            (else (loop (cdr lst) (cons (- (get_uc_cnt (car lst)) (get_lc_cnt\
    \ (car lst))) strngth_lst))))))\n  (let* ((temp_lst (get_ext_strngth extensions))\n\
    \         (max_val (apply max temp_lst))\n         (max_idx (apply max-index temp_lst)))\n\
    \    (string-append class_name \".\" (list-ref extensions max_idx))))\n", "  (apply\
    \ string-append\n         (list class_name\n               \".\"\n           \
    \    (car (sort (map (\u03BB (extension)\n                                 (cons\
    \ extension\n                                       (strength extension)))\n \
    \                              extensions)\n                          (\u03BB\
    \ (e1 e2)\n                            (< (cdr e1) (cdr e2))))))))\n", "  (let\
    \ ([str-map (make-hash)]\n        [max (apply max (map (lambda (e)\n         \
    \                      (hash-set! str-map e\n                                \
    \           (let ([cap (fold (lambda (i a) (if (char-upper-case? i) (+ a 1) a))\
    \ 0 e)]\n                                                 [sm (fold (lambda (i\
    \ a) (if (char-lower-case? i) (+ a 1) a)) 0 e)])\n                           \
    \                  (- cap sm)))\n                               (-1))\n      \
    \                       extensions))])\n    (format \"~a.~a\" class_name (car\
    \ (filter (lambda (e) (= (hash-ref str-map e) max)) extensions)))))\n", "    (define\
    \ (strength str)\n        (let ([caps (string-count str #\\A #\\Z)]\n        \
    \      [smalls (string-count str #\\a #\\z)])\n            (- caps smalls)))\n\
    \    (define (max-extension extensions)\n        (let ([strengths (map strength\
    \ extensions)])\n            (list-ref extensions (argmax strengths))))\n    (string-append\
    \ class_name \".\" (max-extension extensions)))\n", "  (displayln \"\")\n  (displayln\
    \ \"class_name: \" class_name)\n  (displayln \"extensions: \" extensions)\n  (displayln\
    \ \"result: \" (strongest-extension class_name extensions))\n  (displayln \"\"\
    )\n)", "  (define (cap_to_sm ratio)\n    (apply / (- (car ratio) (cdr ratio))))\n\
    \  (define (strongest_extension ext1 ext2)\n    (let ([ratio1 (cap_to_sm (cons\
    \ (count-upper-case ext1) (count-lower-case ext1)))])\n          ([ratio2 (cap_to_sm\
    \ (cons (count-upper-case ext2) (count-lower-case ext2)))])\n    (if (< ratio1\
    \ ratio2) ext1 ext2)))\n  (let ([ext_list (apply strongest_extension extensions)])\n\
    \    (string-append class_name \".\" ext_list)))", "  (cond\n    [(empty? extensions)\n\
    \     \"No extensions.\"]\n    [else\n     (define strongest_strength (apply max\
    \ (map (lambda (extension)\n                                               (define\
    \ num_lowercase (regexp-count #rx\"[a-z]\" extension))\n                     \
    \                          (define num_uppercase (regexp-count #rx\"[A-Z]\" extension))\n\
    \                                               (/ (- num_uppercase num_lowercase)\
    \ 1.0))\n                                             extensions)))\n     (define\
    \ s (string-append class_name \".\" (list-ref extensions (position strongest_strength\
    \ (map (lambda (extension)\n                                                 \
    \                                                      (define num_lowercase (regexp-count\
    \ #rx\"[a-z]\" extension))\n                                                 \
    \                                                      (define num_uppercase (regexp-count\
    \ #rx\"[A-Z]\" extension))\n                                                 \
    \                                                      (/ (- num_uppercase num_lowercase)\
    \ 1.0))\n                                                                    \
    \                                 extensions)))))\n     s]))\n", "  (cond [(null?\
    \ extensions) \"\"]\n        [else (define num-extensions (length extensions))\n\
    \              (define extension (car extensions))\n              (define CAP\
    \ (length (filter char-upper-case? extension)))\n              (define SM (length\
    \ (filter char-lower-case? extension)))\n              (define strength (/ CAP\
    \ SM))\n              (cond [(&gt; (car (cdr (list strength extension))) \n  \
    \                      (car (cdr (list strength (Strongest_Extension class_name\
    \ (cdr extensions)))))\n                        (car (cdr (list strength extension))))]\n\
    \                    [else (Strongest_Extension class_name (cdr extensions))])]))\n\
    </code>\nThis code is for a website which tests your code by calling it repeatedly.\
    \ When I run it, I get the following error:\n<code>Strongest_Extension: unbound\
    \ identifier in module in: Strongest_Extension\n</code>\nI've tried many things,\
    \ but I can't seem to figure out what's wrong.\n\n\nA:\n\nRacket provides a debugging\
    \ tool called \"error syntax highlighting\". It's enabled by writing the following\
    \ at the top of the file:\n<code>#lang racket", "  (let ((max (apply max (map\n\
    \                       (lambda (ext)\n                         (let ((ext_count\
    \ (count (lambda (c) (char-upper-case? c)) ext)))\n                          \
    \ (- ext_count (count (lambda (c) (char-lower-case? c)) ext))))\n            \
    \           extensions))))\n    (string-append class_name \".\" (car (filter (lambda\
    \ (ext) (= (let ((ext_count (count (lambda (c) (char-upper-case? c)) ext)))\n\
    \                                                                (- ext_count\
    \ (count (lambda (c) (char-lower-case? c)) ext))))\n                         \
    \                     extensions)))))\n\n", "  ;; class_name and extensions are\
    \ both strings.\n  ;; Assume that the extensions are correct: their names only\
    \ contain lower and\n  ;; uppercase letters.\n  ;; Return a string in the following\
    \ format:\n  ;; ClassName.StrongestExtensionName.\n  ;; (if there are two or more\
    \ extensions with the same strength, you should\n  ;; choose the one that comes\
    \ first in the list)\n  (let ([cap-count (count (char-set-filter char-set:upper-case\
    \ (char-set:from-string class_name)))]\n        [sm-count (count (char-set-filter\
    \ char-set:lower-case (char-set:from-string class_name)))]\n        [class-strength\
    \ (/ cap-count sm-count)])\n    (define (strength extension)\n      (let ([cap-count\
    \ (count (char-set-filter char-set:upper-case (char-set:from-string extension)))]\n\
    \            [sm-count (count (char-set-filter char-set:lower-case (char-set:from-string\
    \ extension)))])\n        (/ cap-count sm-count)))\n    (define (best-extension\
    \ lst)\n      (if (null? lst)\n          0\n          (cond\n            [(> (strength\
    \ (car lst)) (best-extension (cdr lst))) (car lst)]\n            [else (best-extension\
    \ (cdr lst))])))\n    (cond [(= (class-strength) 0) \"ClassName.ClassName.\"]\n\
    \          [else (format \"~a.~a.\" class_name (best-extension extensions))])))\n",
  "  (define (string-&gt;strength str)\n    (define (is-caps? c)\n      (char-upcase\
    \ c))\n    (define (caps-num str)\n      (apply + (map (lambda (c)\n         \
    \           (if (is-caps? c)\n                        1\n                    \
    \    0))\n                    (string-&gt;list str))))\n    (- (caps-num str)\
    \ (- (string-length str) (caps-num str))))\n  (string-&gt;strength (car (sort\
    \ (map (lambda (ext)\n                                    (string-append class_name\
    \ \".\" ext))\n                                    extensions)\n             \
    \                  (lambda (str1 str2)\n                                 (&lt;\
    \ (string-&gt;strength str1)\n                                    (string-&gt;strength\
    \ str2)))))))\n", "  (let* ([extension-strengths (map (lambda (extension)\n  \
    \                                   (let* ([CAP (length (regexp-match* #rx\"[A-Z]\"\
    \ extension))]\n                                            [SM (length (regexp-match*\
    \ #rx\"[a-z]\" extension))])\n                                       (values extension\
    \ (- CAP SM))))\n                                   extensions)]\n         [extension-strengths\
    \ (sort extension-strengths (lambda (e1 e2)\n                                \
    \                          (if (equal? (cadr e1) (cadr e2))\n                \
    \                                              (string&lt;? (car e1) (car e2))\n\
    \                                                              (&gt; (cadr e1)\
    \ (cadr e2)))))]\n         [extension-strength (car (cadr extension-strengths))])\n\
    \    (string-append class_name \".\" extension-strength)))\n", "    (let* ([sorted-exts\
    \ (sort (map (lambda (x) (list x (class-strength x)))\n                      \
    \            extensions)\n                              (lambda (l1 l2)\n    \
    \                              (cond\n                                    [(>\
    \ (class-strength (car l1)) (class-strength (car l2))) #t]\n                 \
    \                   [(< (class-strength (car l1)) (class-strength (car l2))) #f]\n\
    \                                    [else (< (cdr l1) (cdr l2))]))))\n      \
    \     (strongest-ext (car (last sorted-exts))))\n      (string-append class_name\
    \ \".\" (car strongest-ext))))\n", "  (match-define (list class-name (list cap\
    \ sm)) (make-fraction class_name))\n  (match-define (list strongest-ext strongest-cap\
    \ strongest-sm)\n\t\t(for/fold ([strongest #f] [strongest-cap 0] [strongest-sm\
    \ 0])\n\t\t\t  ([extension extensions])\n\t\t  (let ([(list this-cap this-sm)\
    \ (make-fraction extension)])\n\t\t    (match-define (list fraction-cap fraction-sm)\n\
    \t\t\t\t  (make-fraction extension))\n\t\t    (cond\n\t\t      [(> (- fraction-cap\
    \ fraction-sm) (- strongest-cap strongest-sm))\n\t\t       (values extension fraction-cap\
    \ fraction-sm)]\n\t\t      [(= (- fraction-cap fraction-sm) (- strongest-cap strongest-sm))\n\
    \t\t       (values strongest fraction-cap fraction-sm)]\n\t\t      [else (values\
    \ strongest fraction-cap fraction-sm)]))))\n  (string-append class-name \".\"\
    \ strongest-ext))", "  (let\n    ([count #:num (lambda (string)\n            \
    \        (let ([cap #:num 0]\n                          [sm #:num 0])\n      \
    \                (for/fold ([cap cap]\n                                [sm sm])\n\
    \                            ([c (in-string string)])\n                      (cond\
    \ [(char-numeric? c) #f]\n                            [(char-alphabetic? c)\n\
    \                             (cond [(char-upper-case? c) (add1 cap)]\n      \
    \                             [(char-lower-case? c) (add1 sm)])]\n           \
    \                 [else #f]))))]\n     [count_extensions (for/list ([ext (in-list\
    \ extensions)])\n                         (count ext))]\n     [strongest-extension\
    \ (argmin (lambda (count_ext) (- (car count_ext) (cadr count_ext))) count_extensions)]\n\
    \     [index (index-of strongest-extension count_extensions)]\n     [strongest-extension-name\
    \ (list-ref extensions index)])\n    (format \"~a.~a\" class_name strongest-extension-name)))\n",
  "  (define (strength extension)\n    (define extension-length (length extension))\n\
    \    (define (count type i)\n      (if (= i extension-length)\n          0\n \
    \         (if (char-ci=? (string-ref extension i) type)\n              (+ 1 (count\
    \ type (+ i 1)))\n              (count type (+ i 1)))))\n    (/ (- (count #\\\
    A 0) (count #\\a 0)) extension-length))\n  (define (strongest extensions)\n  \
    \  (if (null? extensions)\n        \"\"\n        (if (null? (cdr extensions))\n\
    \            (car extensions)\n            (if (> (strength (car extensions))\
    \ (strength (cadr extensions)))\n                (strongest (cons (car extensions)\
    \ (cddr extensions)))\n                (strongest (cdr extensions))))))\n  (string-append\
    \ class_name \".\" (strongest extensions)))\n", "  ;; list-&gt;string is the function\
    \ that turns a list of \n  ;; characters into a string\n  (define (list-&gt;string\
    \ lst)\n    (cond\n      [(empty? lst) \"\"]\n      [else (string-append (list-ref\
    \ lst 0) (list-&gt;string (rest lst)))]))\n  ;; strength is the function that\
    \ returns the strength of an\n  ;; extension as a number (CAP - SM)\n  (define\
    \ (strength extension)\n    (define (cap-counter str)\n      (cond\n        [(empty?\
    \ str) 0]\n        [(character-upcase? (list-ref str 0))\n          (+ 1 (cap-counter\
    \ (rest str)))]\n        [else (cap-counter (rest str))]))\n    (define (sm-counter\
    \ str)\n      (cond\n        [(empty? str) 0]\n        [(character-downcase? (list-ref\
    \ str 0))\n          (+ 1 (sm-counter (rest str)))]\n        [else (sm-counter\
    \ (rest str))]))\n    (- (cap-counter extension) (sm-counter extension)))\n  ;;\
    \ the strongest_extension returns the strongest extension, the list\n  ;; of the\
    \ extensions and the strength of the strongest extension\n  (define (strongest_extension\
    \ lst sm_str)\n    (cond\n      [(empty? lst)\n        (list-&gt;string (string-&gt;list\
    \ sm_str)) (strength sm_str)]\n      [(&gt; (strength (list-ref lst 0)) (strength\
    \ sm_str))\n        (strongest_extension (rest lst) (list-ref lst 0))]\n     \
    \ [else (strongest_extension (rest lst) sm_str)]))\n  (define (extension_list\
    \ lst)\n    (cond\n      [(empty? lst) \"\"]\n      [else\n        (string-append\
    \ (strongest_extension lst \"\")\n                       (string-append \".\"\n\
    \                                      (extension_list (rest lst))))]))\n  (string-append\
    \ class_name \".\" (extension_list extensions)))", "  (define (strongest_extension_helper\
    \ extension_list strongest_extension current_strength)\n    (cond ((null? extension_list)\
    \ strongest_extension)\n          ((< current_strength (extension_strength (car\
    \ extension_list)))\n           (strongest_extension_helper (cdr extension_list)\
    \ (car extension_list) (extension_strength (car extension_list))))\n         \
    \ (else (strongest_extension_helper (cdr extension_list) strongest_extension current_strength))))\n\
    \  (define (extension_strength extension)\n    (define (count_upper extension\
    \ upper_count)\n      (cond ((null? extension) upper_count)\n            ((char-upper-case?\
    \ (car extension))\n             (count_upper (cdr extension) (+ upper_count 1)))\n\
    \            (else (count_upper (cdr extension) upper_count))))\n    (define (count_lower\
    \ extension lower_count)\n      (cond ((null? extension) lower_count)\n      \
    \      ((char-lower-case? (car extension))\n             (count_lower (cdr extension)\
    \ (+ lower_count 1)))\n            (else (count_lower (cdr extension) lower_count))))\n\
    \    (/ (- (count_upper extension 0) (count_lower extension 0)) (string-length\
    \ extension)))\n  (string-append class_name \".\" (strongest_extension_helper\
    \ extensions \"\" 0)))\n", "  (cond ((null? extensions) \"No such extension\"\
    )\n        ((= (length extensions) 1) (string-append class_name \".\" (car extensions)))\n\
    \        (else\n         (letrec ([str (lambda (ext) (length (regexp-match* #rx\"\
    [A-Z]\" ext)))])\n           (string-append class_name \".\" (for/fold ([strongest\
    \ (car extensions)] [strength (str (car extensions))])\n                     \
    \                     ([ext (cdr extensions)] [score (str ext)])\n           \
    \                               (if (> score strength)\n                     \
    \                         (values ext score)\n                               \
    \               (values strongest strength))))))))\n", "  (letrec\n      ((helper\
    \ (lambda (name)\n                 (if (eq? '() name)\n                     0\n\
    \                     (if (char-numeric? (car name))\n                       \
    \  (helper (cdr name))\n                         (if (char-upper-case? (car name))\n\
    \                             (+ 1 (helper (cdr name)))\n                    \
    \         (- 1 (helper (cdr name)))))))))\n    (let\n        ((extension_strength\n\
    \          (map (lambda (extension) (list extension (helper extension))) extensions)))\n\
    \      (let\n          ((strongest_extension\n            (list-ref (list-sort\
    \ (lambda (x y) (< (abs (cadr x)) (abs (cadr y)))) extension_strength) 0)))\n\
    \        (string-append class_name \".\" (car strongest_extension))))))", "  (define\
    \ (Strength extension)\n    (let ((CAP (for/fold ([res 0]) ([lst (string->list\
    \ extension)])\n                 (if (char-uppercase? (car lst))\n           \
    \          (+ res 1)\n                     res)))\n          (SM (for/fold ([res\
    \ 0]) ([lst (string->list extension)])\n                 (if (char-lowercase?\
    \ (car lst))\n                     (+ res 1)\n                     res))))\n \
    \     (/ CAP SM)))\n  (define (Sort_Extensions extensions)\n    (for/fold ([res\
    \ null]) ([lst extensions])\n      (let ((str (Strength lst)))\n        (if (member\
    \ str res)\n            (append res (list (list lst str)))\n            (cons\
    \ (list lst str) res)))))\n  (define (Make_Class class_name extensions)\n    (for/fold\
    \ ([res (string-append class_name \".\" \"\")]) ([lst extensions])\n      (let\
    \ ((res_cur (string-append class_name \".\" (string-trim (car lst)))))\n     \
    \   (if (string=? (Strength lst) (Strength (cdr lst)))\n            (if (string<?\
    \ res res_cur)\n                res\n                res_cur)\n            res)))))\n\
    \  (define (Sorted_Extensions extensions)\n    (for/fold ([res null]) ([lst extensions])\n\
    \      (let ((lst_new (list (car lst) (Strength (car lst)))))\n        (cond\n\
    \          [(= (car lst_new) (car (cdr lst_new)))\n           (append res (list\
    \ (car lst_new)))]\n          [else\n           (cons lst_new res)]))))\n  (string-append\
    \ class_name \".\"\n                 (string-trim (car (car (Sort_Extensions extensions))))))\n",
  "  (define (cap-count str) (string-length (regexp-match #rx\"@[A-Z]+\" str)))\n\
    \  (define (sm-count str) (string-length (regexp-match #rx\"@[a-z]+\" str)))\n\
    \  (let* ([cap-counts (map cap-count extensions)]\n         [sm-counts (map sm-count\
    \ extensions)]\n         [strengths (map - cap-counts sm-counts)]\n         [max\
    \ (apply max strengths)]\n         [idx (list-index strengths max)])\n    (format\
    \ \"~a.~a\" class_name (list-ref extensions idx))))\n</code>\nwhich, when run\
    \ with the Racket REPL, produces the correct output:\n<code>&gt; (Strongest_Extension\
    \ \"Slices\" '(\"SErviNGSliCes\" \"Cheese\" \"StuFfed\"))\n\"Slices.SErviNGSliCes\"\
    \n</code>\nUnfortunately, the CodeWars site complains that:\n<code>'Slices.Cheese'\
    \ should equal 'Slices.SErviNGSliCes'\n</code>\nbut that's clearly not true. So\
    \ I'm completely at a loss as to what I've done wrong.\nCan anyone explain what\
    \ I'm doing wrong, and/or point me to some tests that I can run against my code\
    \ to verify that it's working correctly?\n\n\nA:\n\nOne thing to note is that\
    \ <code>string-length</code> will return 0 for the empty string.\nAnother thing\
    \ to note is that your <code>-</code> function is subtracting the number of lowercase\
    \ letters from the number of uppercase letters, which will result in negative\
    \ values for strings that are all lowercase.\nThen, when multiple strings have\
    \ the same strength, you are returning the first one. The first one in your example\
    \ is <code>'Cheese'</code>.\nI think you want to compare the absolute value of\
    \ the strengths instead.\n<code>(define (Strongest_Extension class_name extensions)\n\
    \  (define (cap-count str) (string-length (regexp-match #rx\"@[A-Z]+\" str)))\n\
    \  (define", "  (match extensions\n    ['() #f]\n    [(cons extension? rest_of_extensions)\n\
    \     (let loop ([strongest_strength 0]\n                [strongest_name \"\"\
    ]\n                [extensions rest_of_extensions])\n       (match extensions\n\
    \         ['() (string-append class_name \".\" strongest_name)]\n         [(cons\
    \ extension? rest_of_extensions)\n          (let ([strength (/ (- (count-upper-case\
    \ extension?)\n                                (count-lower-case extension?)))]\n\
    \                [cap (count-upper-case extension?)]\n                [sm (count-lower-case\
    \ extension?)])\n            (if (> strength strongest_strength)\n           \
    \     (loop strength extension? rest_of_extensions)\n                (loop strongest_strength\n\
    \                      strongest_name\n                      rest_of_extensions)))\n\
    \         ])))\n    ]))\n", "  (define (upper? char)\n    (and (>= char #\\A)\
    \ (<= char #\\Z)))\n  (define (lower? char)\n    (and (>= char #\\a) (<= char\
    \ #\\z)))\n  (define (strength str)\n    (define (upper-or-lower? char)\n    \
    \  (or (upper? char) (lower? char)))\n    (define (strength-of str)\n      (define\
    \ (strength-of-chars n-uppers n-lowers rest)\n        (cond\n          [(empty?\
    \ rest) (/ n-uppers (- n-lowers))]\n          [(upper? (first rest))\n       \
    \    (strength-of-chars (+ n-uppers 1) n-lowers (rest rest))]\n          [(lower?\
    \ (first rest))\n           (strength-of-chars n-uppers (+ n-lowers 1) (rest rest))]\n\
    \          [else (strength-of-chars n-uppers n-lowers (rest rest))]))\n      (strength-of-chars\
    \ 0 0 (filter upper-or-lower? (string->list str))))\n    (strength-of str))\n\
    \  (define (find-strongest exts)\n    (cond\n      [(empty? exts) \"\"]\n    \
    \  [(empty? (rest exts)) (first exts)]\n      [(< (strength (first exts)) (strength\
    \ (second exts)))\n       (find-strongest (rest exts))]\n      [else (find-strongest\
    \ (cons (first exts) (rest (rest exts))))]))\n  (string-append class_name \".\"\
    \ (find-strongest extensions)))\n", "  (define (solve-for-caps-and-smalls caps\
    \ smalls)\n    (/ (- caps smalls) caps))\n  (define (get-caps-and-smalls word)\n\
    \    (values (length (regexp-match #rx\"[A-Z]\" word)) \n            (length (regexp-match\
    \ #rx\"[a-z]\" word))))\n  (define (get-strength word)\n    (values (get-caps-and-smalls\
    \ word)\n            (solve-for-caps-and-smalls (get-caps-and-smalls word))))\n\
    \  (define (strongest-extension extensions)\n    (apply max (map get-strength\
    \ extensions)))\n  (string-append class_name \".\" (list-ref extensions (strongest-extension\
    \ extensions))))\n", "  (define (uppercase-count str)\n    (length (regexp-match*\
    \ #rx\"[A-Z]\" str)))\n  (define (lowercase-count str)\n    (length (regexp-match*\
    \ #rx\"[a-z]\" str)))\n  (define (ext-strength ext)\n    (/ (- (uppercase-count\
    \ ext) (lowercase-count ext)) (length ext)))\n  (define (compare-exts ext1 ext2)\n\
    \    (cond\n      [(< (ext-strength ext1) (ext-strength ext2)) #f]\n      [(>\
    \ (ext-strength ext1) (ext-strength ext2)) #t]\n      [else (string<? ext1 ext2)]))\n\
    \  (string-append class_name \".\" (apply min extensions compare-exts)))\n", " \
    \ (define (get-strength str) \n    (apply - (apply + (map char-upcase? (string->list\
    \ str)))\n             (apply + (map char-lower-case? (string->list str)))))\n\
    \  (define (get-strongest lst)\n    (first (sort (map list lst (map get-strength\
    \ lst)) >)))\n  (define (is-alphanum? ch)\n    (or (char-alphabetic? ch) (char-numeric?\
    \ ch)))\n  (define (filter-non-alpha-numeric str)\n    (apply string (filter is-alphanum?\
    \ (string->list str))))\n  (define (clean-str str)\n    (filter-non-alpha-numeric\
    \ str))\n  (define (get-extension-from-class str)\n    (cond\n      [(empty? str)\
    \ str]\n      [(equal? (first str) #\\.) str]\n      [else (get-extension-from-class\
    \ (rest str))]))\n  (define (get-class-from-class str)\n    (cond\n      [(empty?\
    \ str) str]\n      [(equal? (first str) #\\.) (rest str)]\n      [else (get-class-from-class\
    \ (rest str))]))\n  (define (get-strongest-extension lst)\n    (cond\n      [(empty?\
    \ lst) \"\"]\n      [(equal? (first lst) (get-strongest lst)) (first lst)]\n \
    \     [else (get-strongest-extension (rest lst))]))\n  (define (get-extensions\
    \ lst)\n    (map get-extension-from-class lst))\n  (define (get-classes lst)\n\
    \    (map get-class-from-class lst))\n  (define (build-class-and-extension lst)\n\
    \    (string-append (first lst) \".\" (second lst)))\n  (build-class-and-extension\
    \ (list class_name \n                                   (get-strongest-extension\
    \ (get-extensions extensions)))))\n", "  (match-define (list class_name extensions)\
    \ (list class_name extensions))\n  (define (strength ext)\n    (let ([cap (length\
    \ (regexp-match #rx\"[A-Z]\" ext))]\n          [sm (length (regexp-match #rx\"\
    [a-z]\" ext))])\n      (- cap sm)))\n  (if (null? extensions)\n      (format \"\
    ~a.None\" class_name)\n      (string-append\n       class_name\n       \".\"\n\
    \       (regexp-replace #rx\"^\" \"\"\n                       (regexp-replace\
    \ #rx\".*\" \"\"\n                                       (string-join\n      \
    \                                  (list->string\n                           \
    \              (map (\u03BB (ext)\n                                          \
    \      (if (equal? (strength ext)\n                                          \
    \                  (strength (car extensions)))\n                            \
    \                        ext\n                                               \
    \     \"\"))\n                                              extensions))\n   \
    \                                     \", \")))))))", "  (cond\n    [(empty? extensions)\
    \ 'ClassName.StrongestExtensionName]\n    [else (let*\n            [(cap (lambda\
    \ (e) (for/sum ([c (in-string e)])\n                                   (if (char-upper-case?\
    \ c) 1 0))))\n             (sm (lambda (e) (for/sum ([c (in-string e)])\n    \
    \                              (if (char-lower-case? c) 1 0))))\n            \
    \ (strengths (map (lambda (e) (- (cap e) (sm e))) extensions))\n             (maxs\
    \ (maximum strengths))\n             (max_index (position maxs strengths))]\n\
    \            (string-append class_name \".\" (list-ref extensions max_index)))]))\n",
  "  (cond [(empty? extensions) \"\"]\n        [else\n         (let ([exname (car\
    \ extensions)]\n               [strength (strength exname)])\n           (cond\
    \ [(empty? (cdr extensions))\n                  (format \"~a.~a\" class_name exname)]\n\
    \                 [else (cond [(or (> strength (strength (car (cdr extensions))))\n\
    \                                 (= strength (strength (car (cdr extensions)))))\n\
    \                              (format \"~a.~a\" class_name exname)]\n       \
    \                      [else (Strongest_Extension class_name (cdr extensions))])]))]))\n",
  "  (string-append class_name \".\" (string-downcase (extension-with-highest-strength\
    \ class_name extensions))))\n", "  (define (strength str)\n    (let ([uppercase\
    \ (for/list ([char (in-string str)])\n                        (if (char-upper-case?\
    \ char) char \"?\"))]\n          [lowercase (for/list ([char (in-string str)])\n\
    \                        (if (char-lower-case? char) char \"?\"))])\n      (-\
    \ (string-length uppercase) (string-length lowercase))))\n  (define (strongest\
    \ lst)\n    (for/first ([ext (in-list lst)]\n                #:when (equal? (strength\
    \ ext) (apply max (map strength lst))))\n      ext))\n  (string-append class_name\
    \ \".\" (strongest extensions)))\n</code>\n", "  (let ([strongest_extension_name\
    \ (car extensions)]\n        [strongest_extension_strength \n         (let ([cap\
    \ (length (regexp-match* #rx\"[A-Z]\" (car extensions)))])\n           (let ([sm\
    \ (length (regexp-match* #rx\"[a-z]\" (car extensions)))])\n             (/ cap\
    \ sm)))])\n    (for ([e extensions])\n      (let ([cap (length (regexp-match*\
    \ #rx\"[A-Z]\" e))])\n        (let ([sm (length (regexp-match* #rx\"[a-z]\" e))])\n\
    \          (let ([current_extension_strength (/ cap sm)])\n            (if (>\
    \ current_extension_strength strongest_extension_strength)\n                (begin\n\
    \                  (set! strongest_extension_name e)\n                  (set!\
    \ strongest_extension_strength current_extension_strength))\n                (void))))))\n\
    \    (string-append class_name \".\" strongest_extension_name)))\n</code>\nThat's\
    \ it. Is there a more elegant solution? I mean the solution shouldn't be so imperative\
    \ like this.\n\n\nA:\n\nYou can use <code>reduce</code> to do a comparison of\
    \ all the extensions in one loop. The function we pass to <code>reduce</code>\
    \ is given two extensions and produces the stronger one. It just happens that\
    \ the first argument is also the result of the previous iteration, so we have\
    \ to make sure that the first extension is returned if the second one is weaker.\n\
    <code>(define (strength e)\n  (/ (length (regexp-match* #rx\"[A-Z]\" e))\n   \
    \  (length (regexp-match* #rx\"[a-z]\" e))))\n", "  (define (score x) (let ([caps\
    \ (regexp-match/all #rx\"[A-Z]\" x)]\n                          [smalls (regexp-match/all\
    \ #rx\"[a-z]\" x)])\n                      (/ (- (length caps) (length smalls)))))\n\
    \  (define (only-non-empty x)\n    (if (empty? x)\n        \"\"\n        (apply\
    \ string-append x)))\n  (apply only-non-empty\n         (list class_name\n   \
    \            \".\"\n               (map only-non-empty\n                    (list-ref\n\
    \                     (sort (map list-ref extensions)\n                      \
    \     (lambda (x y)\n                             (or (equal? (score x) (score\
    \ y))\n                                 (< (score x) (score y)))))\n         \
    \            0)))))\n", "  (define (is_upper? c)\n    (cond\n      [(char-upcase?\
    \ c) #t]\n      [else #f]))\n  (define (get_strength n)\n    (cond\n      [(>\
    \ n 0) (- n)]\n      [else n]))\n  (let ((extensions (sort extensions string<?)))\n\
    \    (let ((strongest_ext (car extensions))\n          (strength (get_strength\
    \ \n                     (- (count is_upper? (car extensions))\n             \
    \           (count (lambda (c) (not (is_upper? c))) (car extensions))))))\n  \
    \    (for/fold ([result (list class_name \".\" strongest_ext)])\n            \
    \    ([ext (in-list (cdr extensions))])\n        (let ((ext_strength (get_strength\
    \ \n                             (- (count is_upper? ext)\n                  \
    \              (count (lambda (c) (not (is_upper? c))) ext)))))\n          (if\
    \ (> ext_strength strength)\n              (begin\n                (set! strength\
    \ ext_strength)\n                (set! strongest_ext ext)\n                (list\
    \ class_name \".\" strongest_ext))\n              result))))))", "  (apply string-append\n\
    \         (list class_name\n               \".\"\n               (car (sort extensions\n\
    \                        (lambda (ext1 ext2)\n                          (< (strength\
    \ ext1) (strength ext2))))))))\n", "  (local\n    [(define (strength_helper extension\
    \ name)\n       (let ([caps (string-count extension #\\A #\\Z)]\n            \
    \ [sm (string-count extension #\\a #\\z)])\n         (- caps sm)))\n     (define\
    \ (strongest_helper extensions_list class_name strongest)\n       (cond [(empty?\
    \ extensions_list) (cons class_name strongest)]\n             [(< (strength_helper\
    \ (first extensions_list) class_name)\n                 (strength_helper strongest\
    \ class_name))\n              (strongest_helper (rest extensions_list) class_name\
    \ strongest)]\n             [else\n              (strongest_helper (rest extensions_list)\
    \ class_name\n                                (first extensions_list))]))]\n \
    \   (if (empty? extensions) \"Error\"\n        (let ([strongest (first extensions)])\n\
    \          (string-append class_name \".\" (strongest_helper (rest extensions)\n\
    \                                                          class_name\n      \
    \                                                    strongest))))))\n", "  (define\
    \ (strength ex)\n    (let ([upcase (count (\u03BB (x) (or (= #\\A x) (= #\\B x)\
    \ (= #\\C x) (= #\\D x) (= #\\E x) (= #\\F x) (= #\\G x) (= #\\H x) (= #\\I x)\
    \ (= #\\J x) (= #\\K x) (= #\\L x) (= #\\M x) (= #\\N x) (= #\\O x) (= #\\P x)\
    \ (= #\\Q x) (= #\\R x) (= #\\S x) (= #\\T x) (= #\\U x) (= #\\V x) (= #\\W x)\
    \ (= #\\X x) (= #\\Y x) (= #\\Z x))) ex)])\n      (- upcase (count (\u03BB (x)\
    \ (or (= #\\a x) (= #\\b x) (= #\\c x) (= #\\d x) (= #\\e x) (= #\\f x) (= #\\\
    g x) (= #\\h x) (= #\\i x) (= #\\j x) (= #\\k x) (= #\\l x) (= #\\m x) (= #\\\
    n x) (= #\\o x) (= #\\p x) (= #\\q x) (= #\\r x) (= #\\s x) (= #\\t x) (= #\\\
    u x) (= #\\v x) (= #\\w x) (= #\\x x) (= #\\y x) (= #\\z x))) ex))]))\n  (define\
    \ (strongest exts)\n    (let ([str_exts (map strength exts)])\n      (list-ref\
    \ exts (index (max (map strength exts)) str_exts))))\n  (string-append class_name\
    \ \".\" (strongest extensions)))\n", "  (list-ref \n   (sort \n    (for/list ([ext\
    \ (in-list extensions)])\n      (list (string-length ext) \n            (string-length\
    \ (regexp-replace* #rx\"[A-Z]\" ext \"\")) \n            ext))\n    >)\n   2))\n",
  "  (define (cap-count str)\n    (length (filter char-uppercase? (string->list str))))\n\
    \  (define (sm-count str)\n    (length (filter char-lowercase? (string->list str))))\n\
    \  (define (strength str)\n    (- (cap-count str) (sm-count str)))\n  (define\
    \ (strongest exts)\n    (let loop ((exts exts) (strongest (first exts)) (strength\
    \ (strength (first exts))))\n      (cond ((null? exts) strongest)\n          \
    \  ((< (strength (first exts)) strength) (loop (rest exts) strongest strength))\n\
    \            (else (loop (rest exts) (first exts) (strength (first exts)))))))\n\
    \  (string-append class_name \".\" (strongest extensions)))\n", "  (define (strength\
    \ extension)\n    (define (sum-lowercaps str)\n      (for/sum ([c (in-string str)])\n\
    \        (if (char-lower-case? c) 1 0)))\n    (define (sum-uppercaps str)\n  \
    \    (for/sum ([c (in-string str)])\n        (if (char-upper-case? c) 1 0)))\n\
    \    (- (sum-uppercaps extension) (sum-lowercaps extension)))\n  (match extensions\n\
    \    ['() #f]\n    [(cons ext rest-ext)\n     (define str (strength ext))\n  \
    \   (if (null? rest-ext)\n         (string-append class_name \".\" ext)\n    \
    \     (define str-next (strength (car rest-ext)))\n         (if (> str str-next)\n\
    \             (string-append class_name \".\" ext)\n             (string-append\
    \ class_name \".\" (car rest-ext))))]))\n", "  (define class_name_str (string->list\
    \ class_name))\n  (define class_name_str_len (length class_name_str))\n  (define\
    \ ext_str (map (\u03BB (x) (string->list x)) extensions))\n  (define ext_str_len\
    \ (map (\u03BB (x) (length x)) ext_str))\n  (define cap (map (\u03BB (x) (length\
    \ (filter char-upper-case? x))) ext_str))\n  (define sm (map (\u03BB (x) (length\
    \ (filter char-lower-case? x))) ext_str))\n  (define strength (map (\u03BB (x\
    \ y) (/ (- x y) (real y))) cap sm))\n  (define found_strength (for/first ([(x\
    \ y) (in-indexed strength)]) (and (and (> x 0) (< y 1)) x)))\n  (string-append\
    \ class_name \".\" (list->string (vector-ref ext_str found_strength))))", "  (define\
    \ class_name (symbol->string class_name))\n  (define strongest \n    (define (strength\
    \ str)\n      (- (length (regexp-match* #rx\"[A-Z]\" str))\n         (length (regexp-match*\
    \ #rx\"[a-z]\" str))))\n    (cond [(empty? extensions) \"\"]\n          [(> (strength\
    \ (first extensions))\n              (strength (second extensions)))\n       \
    \    (string-append class_name \".\" (first extensions))]\n          [else (string-append\
    \ class_name \".\" (second extensions))]))\n  strongest)\n", "  (define (cap_count\
    \ s)\n    (if (string-empty? s)\n        0\n        (+ (if (char-uppercase? (string-ref\
    \ s 0)) 1 0)\n           (cap_count (substring s 1)))))\n  (define (sm_count s)\n\
    \    (if (string-empty? s)\n        0\n        (+ (if (char-lowercase? (string-ref\
    \ s 0)) 1 0)\n           (sm_count (substring s 1)))))\n  (let ((xs (sort extensions\
    \ (\u03BB (s1 s2)\n                              (> (cap_count s1) (cap_count\
    \ s2))))))\n    (let-values (((best_value _) (for/fold ([best_value -inf.0])\n\
    \                                  ([x xs])\n                                \
    \  (if (and (not (= (cap_count x) best_value))\n                             \
    \              (> (cap_count x) best_value))\n                               \
    \       (values (cap_count x) x)\n                                      (values\
    \ best_value x)))))\n      (string-append class_name \".\" best_value))))", " \
    \ (define (count-uppercase str)\n    (let loop ((str str) (count 0))\n      (if\
    \ (null? str)\n          count\n          (if (char-upper-case? (car str))\n \
    \             (loop (cdr str) (+ count 1))\n              (loop (cdr str) count)))))\n\
    \  (define (count-lowercase str)\n    (let loop ((str str) (count 0))\n      (if\
    \ (null? str)\n          count\n          (if (char-lower-case? (car str))\n \
    \             (loop (cdr str) (+ count 1))\n              (loop (cdr str) count)))))\n\
    \  (define (strength str)\n    (- (count-uppercase str) (count-lowercase str)))\n\
    \  (define (is-stronger? str)\n    (>= (strength str) (strength (car extensions))))\n\
    \  (define (strongest)\n    (let loop ((extensions extensions))\n      (if (or\
    \ (null? extensions) (is-stronger? (car extensions)))\n          (car extensions)\n\
    \          (loop (cdr extensions)))))\n  (string-append class_name \".\" (strongest)))\n",
  "  (if (null? extensions)\n      (string-append class_name \".\")\n      (let* ((cur_extension\
    \ (car extensions))\n             (rest_extensions (cdr extensions))\n       \
    \      (cur_extension_name (string-append class_name \".\" cur_extension))\n \
    \            (rest_extensions_name (Strongest_Extension class_name rest_extensions))\n\
    \             (cur_extension_name_strength (strength cur_extension_name))\n  \
    \           (rest_extensions_name_strength (strength rest_extensions_name)))\n\
    \        (if (&gt; cur_extension_name_strength rest_extensions_name_strength)\n\
    \            cur_extension_name\n            rest_extensions_name))))\n", "  (apply\
    \ max\n         (map (\u03BB (x) \n                (/ (- (foldl + 0 (map char-upcase?\
    \ (string->list x)))\n                     (foldl + 0 (map char-lower-case? (string->list\
    \ x))))))\n              extensions)))\n", "  (string-append class_name \".\"\n\
    \                 (vector-ref extensions\n                             (apply\
    \ min (map (lambda (x) (apply - (map count-matches '([A-Z] [a-z]) (string->list\
    \ x)))) extensions)))))\n", "  (define (strength extension)\n    (let loop ([i\
    \ 0] [stren 0])\n      (cond [(&gt; i (string-length extension)) stren]\n    \
    \        [(char-lower-case? (string-ref extension i))\n             (loop (+ i\
    \ 1) (- stren 1))]\n            [(char-upper-case? (string-ref extension i))\n\
    \             (loop (+ i 1) (+ stren 1))]\n            [else (loop (+ i 1) stren)])))\n\
    \  (string-append class_name \".\" (apply max-by strength extensions)))\n</code>\n\
    I tried to get it accepted, but was rejected.\n\n\nA:\n\nLet's start with the\
    \ basis of the problem - the <code>strength</code> function.\n<code>(define (strength\
    \ extension)\n  (let loop ([i 0] [stren 0])\n    (cond [(&gt; i (string-length\
    \ extension)) stren]\n          [(char-lower-case? (string-ref extension i))\n\
    \           (loop (+ i 1) (- stren 1))]\n          [(char-upper-case? (string-ref\
    \ extension i))\n           (loop (+ i 1) (+ stren 1))]\n          [else (loop\
    \ (+ i 1) stren)])))\n</code>\nThere are a few problems with this. First, it's\
    \ pretty hard to read, because all of the conditions are on the same line, and\
    \ the function body is several lines down. Most of the important information is\
    \ right at the beginning, so you should put it there. I also don't like having\
    \ a name that starts with <code>loop</code> - it makes it feel like an internal\
    \ loop and not something that is visible from the outside.\nI prefer to structure\
    \ my code as a series of definitions and a few test cases. This isn't the only\
    \ way to structure code, but it's a nice way to keep the examples together and\
    \ the code together.\n<code>#lang racket\n", "  (define (upper? letter)\n    (and\
    \ (> letter 64) (< letter 91)))\n  (define (lower? letter)\n    (and (> letter\
    \ 96) (< letter 123)))\n  (define (strength string)\n    (define (caps num string)\n\
    \      (if (empty? string)\n          num\n          (if (upper? (first string))\n\
    \              (caps (+ num 1) (rest string))\n              (caps num (rest string)))))\n\
    \    (define (small num string)\n      (if (empty? string)\n          num\n  \
    \        (if (lower? (first string))\n              (small (+ num 1) (rest string))\n\
    \              (small num (rest string)))))\n    (/ (- (caps 0 string) (small\
    \ 0 string)) (length string)))\n  (define (strongest extension_list)\n    (if\
    \ (empty? extension_list)\n        (error \"No extensions!\")\n        (let ((strongest_extension\
    \ (first extension_list))\n              (strongest_extension_strength (strength\
    \ (first extension_list))))\n          (for ([extension (in-list (rest extension_list))])\n\
    \            (let ((this_extension_strength (strength extension)))\n         \
    \     (if (> this_extension_strength strongest_extension_strength)\n         \
    \         (begin\n                    (set! strongest_extension extension)\n \
    \                   (set! strongest_extension_strength this_extension_strength)))))\n\
    \          strongest_extension)))\n  (string-append class_name \".\" (strongest\
    \ extensions)))\n", "  (let [\n        ;; extract the strength of the extension\n\
    \        strengths (map (\u03BB (ext) (quotient \n                           \
    \      (- (apply + (map char-upcase? (string->list ext)))\n                  \
    \                  (apply + (map char-lower-case? (string->list ext))))\n    \
    \                             (length ext))) extensions)\n        ;; get the max\
    \ strength\n        max-st (apply max strengths)\n        ;; get the indices of\
    \ the max strengths\n        max-indices (find-indices (\u03BB (st) (= max-st\
    \ st)) strengths)\n        ;; get the first element from the max indices list\n\
    \        max-ind (first max-indices)\n        ;; get the list element for the\
    \ maximum index\n        max-element (list-ref extensions max-ind)\n        ]\n\
    \    (format \"~a.~a\" class_name max-element)))\n", "  (local\n      ((define\
    \ (strength x)\n           (/ (- (length (filter char-upper-case? x))\n      \
    \           (length (filter char-lower-case? x)))\n              (length x))))\n\
    \    (string-append class_name \".\"\n                   (first (sort (lambda\
    \ (x y)\n                                  (> (strength x) (strength y)))\n  \
    \                              extensions)))))", "  (for/first ([e extensions]\n\
    \              #:when (eq? class_name (regexp-match* #rx\"^(.*)\\.(.*)$\" e)))\n\
    \    (match (regexp-match* #rx\"^(.*)\\.(.*)$\" e)\n      [(list _ (list a b))\
    \ a])))", "  (define (capp s)\n    (count (lambda (c) (char-upper-case? c)) s))\n\
    \  (define (small s)\n    (count (lambda (c) (char-lower-case? c)) s))\n  (define\
    \ (calc s)\n    (/ (- (capp s) (small s)) (string-length s)))\n  (define (least-first\
    \ l)\n    (sort l string<?))\n  (define (strongest_ext e)\n    (last (string-split\
    \ (car (last (least-first (sort (map calc e) string>?)))) \".\")))\n  (string-append\
    \ class_name \".\" (strongest_ext extensions)))\n", "  (let loop ([extensions\
    \ extensions])\n    (match extensions\n      [(list) (error 'Strongest_Extension\
    \ \"List of extensions is empty\")]\n      [(list (? string? head) tail ...)\n\
    \       (loop tail)]\n      [(list x tail ...)\n       (error 'Strongest_Extension\
    \ \"Improper extension (not a string) in list of extensions\")])))\n", "  (let*\
    \ ([extension_strengths (map (\u03BB (extension) (cons extension (strength extension)))\
    \ extensions)]\n         [sorted_strengths (sort extension_strengths (\u03BB (extension_strength1\
    \ extension_strength2)\n                                                     \
    \ (< (cdr extension_strength1) (cdr extension_strength2))))]\n         [strongest_extension\
    \ (car (car sorted_strengths))])\n    (string-append class_name \".\" strongest_extension)))\n",
  "  (string-append class_name \".\"\n                 (apply string-append\n    \
    \                    (map (lambda (x)\n                               (string-append\
    \ \".\" x))\n                             (sort (filter (lambda (x)\n        \
    \                                     (not (equal? x \"\")))\n               \
    \                            (regexp-split #rx\".\" (string-upcase class_name)))\n\
    \                                   (lambda (x y) (or (regexp-match #rx\"^[A-Z]+$\"\
    \ x)\n                                                     (regexp-match #rx\"\
    ^[A-Z]+$\" y)\n                                                     (<= (abs (-\
    \ (count-matches #rx\"[A-Z]\" x)\n                                           \
    \                      (count-matches #rx\"[a-z]\" x)))\n                    \
    \                                     (abs (- (count-matches #rx\"[A-Z]\" y)\n\
    \                                                                 (count-matches\
    \ #rx\"[a-z]\" y)))))))))))\n", "  (for/first ((extension extensions))\n    (define\
    \ upper 0)\n    (define lower 0)\n    (for/list ((char (string->list extension)))\n\
    \      (cond\n        [(char-upper-case? char) (set! upper (+ upper 1))]\n   \
    \     [(char-lower-case? char) (set! lower (+ lower 1))]))\n    (define strength\
    \ (/ upper lower))\n    (if (> strength -1)\n      (string-append class_name \"\
    .\" extension))))", "  (define (strongest_extension extensions)\n    (if (null?\
    \ extensions)\n        (error \"could not find a valid extension\")\n        (let*\
    \ ([extension (car extensions)]\n               [CAP (count (lambda (ch) (char-upper-case?\
    \ ch)) extension)]\n               [SM (count (lambda (ch) (char-lower-case? ch))\
    \ extension)]\n               [strength (/ CAP SM)])\n          (if (and (and\
    \ (not (null? (cdr extensions)))\n                        (= strength (strongest_extension\
    \ (cdr extensions))))\n                   (string<? extension (strongest_extension\
    \ (cdr extensions))))\n              (cons extension (strongest_extension (cdr\
    \ extensions)))\n              (cons extension (list strength))))))\n  (string-append\
    \ class_name \".\" (car (strongest_extension extensions))))\n", "  (define lst_of_caps\
    \ (map (\u03BB (ext) (count-char (car ext) #\\A #\\Z)) extensions))\n  (define\
    \ lst_of_smalls (map (\u03BB (ext) (count-char (car ext) #\\a #\\z)) extensions))\n\
    \  (let ([list_of_strengths (map (\u03BB (caps sm) (/ (- caps sm) (abs (- caps\
    \ sm)))) lst_of_caps lst_of_smalls)])\n    (cond\n      [(empty? list_of_strengths)\
    \ \"\"]\n      [(not (empty? list_of_strengths)) (string-append class_name \"\
    .\" (car (filter (\u03BB (ext) (= (abs (car ext)) (max (map abs list_of_strengths))))\
    \ extensions)))])))\n</code>\n", "  ;; Step 1: Determine the strength of the extensions\n\
    \  (map (lambda (extension) \n    (/ (- (length (filter char-upper-case? (string->list\
    \ extension)))\n         (length (filter char-lower-case? (string->list extension))))\n\
    \        (length extension)))\n    extensions))\n", "  (define (ext_strength str)\n\
    \    (let loop ((i 0) (cap 0) (sm 0))\n      (if (&lt; i (string-length str))\n\
    \          (loop (+ i 1)\n                (if (char-uppercase? (string-ref str\
    \ i))\n                    (+ cap 1)\n                    cap)\n             \
    \   (if (char-lowercase? (string-ref str i))\n                    (+ sm 1)\n \
    \                   sm))\n          (- cap sm))))\n  (define (find_strongest strs)\n\
    \    (let loop ((strs strs) (strongest '()))\n      (cond ((null? strs) strongest)\n\
    \            ((&gt; (ext_strength (car strs)) (ext_strength strongest))\n    \
    \         (loop (cdr strs) (car strs)))\n            (else (loop (cdr strs) strongest)))))\n\
    \  (string-append class_name \".\" (find_strongest extensions)))\n</code>\nI like\
    \ to use the following more generic version of <code>ext_strength</code>:\n<code>(define\
    \ (ext_strength str)\n  (define (char-strength ch)\n    (if (char-lowercase? ch)\n\
    \        -1\n        1))\n  (let loop ((i 0) (sum 0))\n    (if (&lt; i (string-length\
    \ str))\n        (loop (+ i 1) (+ sum (char-strength (string-ref str i))))\n \
    \       sum)))\n</code>\n", "  (define (strength e)\n    (/ (- (length (filter\
    \ char-upper-case? (string->list e)))\n          (length (filter char-lower-case?\
    \ (string->list e))))\n       (length e)))\n  (string-append\n   class_name \"\
    .\"\n   (car (sort (sort extensions (\u03BB (x y) (\u2264 (strength x) (strength\
    \ y))))\n              (\u03BB (x y) (\u2264 (string<? (string-downcase x) (string-downcase\
    \ y)) #t))))))\n", "  ;; need a list of alphabetically sorted extensions\n  (define\
    \ (sort-extensions lst)\n    (sort lst string<?))\n  ;; need a list of alphabetically\
    \ sorted extensions and their strengths\n  (define (ext_strength_list lst)\n \
    \   (map (lambda (x)\n           (list x (count-caps x) (count-small x) (- (count-caps\
    \ x) (count-small x))))\n         (sort-extensions lst)))\n  ;; now that we have\
    \ a list of extensions sorted alphabetically and their strengths,\n  ;; we need\
    \ to find the largest strength, using the car of the 3rd sublist\n  (define (find-strongest\
    \ lst)\n    (car (car (last (sort lst (lambda (x y) (> (car (car (cddr x)))\n\
    \                                               (car (car (cddr y)))))))))\n \
    \ ;; finally, we can print the string\n  (define (print-str strongest)\n    (string-append\
    \ class_name \".\" strongest))\n  (print-str (find-strongest (ext_strength_list\
    \ extensions))))\n", "  (define capital_letters (string-upper-case class_name))\n\
    \  (define small_letters (string-lower-case class_name))\n  (define capital_letters_num\
    \ (- (string-length capital_letters)\n                                 (string-length\
    \ (string-trim small_letters class_name))))\n  (define small_letters_num (- (string-length\
    \ small_letters)\n                               (string-length (string-trim capital_letters\
    \ class_name))))\n  (define strength (/ (- capital_letters_num small_letters_num)\
    \ \n                      (+ capital_letters_num small_letters_num)))\n  (define\
    \ (extension_strength extension)\n    (define capital_letters (string-upper-case\
    \ extension))\n    (define small_letters (string-lower-case extension))\n    (define\
    \ capital_letters_num (- (string-length capital_letters)\n                   \
    \                (string-length (string-trim small_letters extension))))\n   \
    \ (define small_letters_num (- (string-length small_letters)\n               \
    \                  (string-length (string-trim capital_letters extension))))\n\
    \    (define extension_strength (/ (- capital_letters_num small_letters_num) \n\
    \                                  (+ capital_letters_num small_letters_num))))\n\
    \  (define (same_class_strength extension_strength)\n    (>= extension_strength\
    \ strength))\n  (define (strongest_extension extensions)\n    (if (empty? extensions)\n\
    \        (string-append class_name \".\" \"none\")\n        (if (same_class_strength\
    \ (extension_strength (first extensions)))\n            (string-append class_name\
    \ \".\" (first extensions))\n            (strongest_extension (rest extensions)))))\n\
    \  (strongest_extension extensions))", "  (cond [(empty? extensions) class_name]\n\
    \        [else (let ([test (first extensions)])\n                (if (< (extension-strength\
    \ test) (extension-strength (second extensions)))\n                    (Strongest_Extension\
    \ class_name (rest extensions))\n                    (Strongest_Extension (string-append\
    \ class_name \".\" test) (rest extensions))))]))\n", "  (define (strength extension)\n\
    \    (define (is-uppercase? c)\n      (and (char&lt;= #\\A c) (char&lt;= c #\\\
    Z)))\n    (define (is-lowercase? c)\n      (and (char&lt;= #\\a c) (char&lt;=\
    \ c #\\z)))\n    (define (char-count f extension)\n      (apply + (map (lambda\
    \ (c) (if (f c) 1 0)) extension)))\n    (define upper (char-count is-uppercase?\
    \ extension))\n    (define lower (char-count is-lowercase? extension))\n    (/\
    \ (- upper lower) 1.0))\n  (define (st extension1 extension2)\n    (&gt; (strength\
    \ extension1) (strength extension2)))\n  (define (classname-extension extension)\n\
    \    (string-append class_name \".\" extension))\n  (if (null? extensions)\n \
    \     class_name\n      (classname-extension (apply max st extensions))))\n",
  "  (for/first ([e extensions]\n              #:when (= (length (regexp-match #rx\"\
    \\\\b[A-Z]\\\\b\" e))\n                         (- (length (regexp-match #rx\"\
    \\\\b[a-z]\\\\b\" e)))))\n    (format \"~a.~a\" class_name e)))\n", "  (define\
    \ (letters lst)\n    (cond\n      [(and (empty? lst)\n            (empty? (rest\
    \ lst)))\n       #t]\n      [(char-alphabetic? (car lst))\n       (cons (car lst)\
    \ (letters (rest lst)))]\n      [else\n       (letters (rest lst))]))\n  (define\
    \ (strength lst)\n    (letrec ([cap (cond\n                   [(empty? lst)\n\
    \                    0]\n                   [(char-upper-case? (car lst))\n  \
    \                  (+ 1 (cap (rest lst)))]\n                   [else\n       \
    \             (cap (rest lst))])]\n             [sm (cond\n                  [(empty?\
    \ lst)\n                   0]\n                  [(char-lower-case? (car lst))\n\
    \                   (+ 1 (sm (rest lst)))]\n                  [else\n        \
    \           (sm (rest lst))])])\n      (- cap sm)))\n  (define (strongest-ext\
    \ ext)\n    (letrec ([comparison (first (sort (> strength) ext))]\n          \
    \   [class (regexp-replace* #rx\"^[A-Z]*\" class_name\n                      \
    \               (lambda (x) (string-append x \".\")))])\n      (string-append\
    \ class comparison)))\n  (strongest-ext (map letters extensions)))\n</code>\n\
    I wanted to do this without using any library function, but only use the basic\
    \ functions that I mentioned in the beginning.\nMy <code>letters</code> function\
    \ returns a list containing only the letters from the input <code>extensions</code>\
    \ list.\nMy <code>strength</code> function calculates the fraction CAP - SM, which\
    \ is the strength of the extension.\nMy <code>strongest-ext</code> function finds\
    \ the highest strength and combines the <code>class</code> with the extension\
    \ and returns a string.\nTo test this function, just run the following commands\
    \ in DrRacket.\n<code>(Strongest_Extension \"Slices\" '([\"SErviNGSliCes\"] [\"\
    Cheese\"] [\"StuFfed\"]))</code>\n<code>(Strongest_Extension \"Soft_IceCream\"\
    \ '([\"Chocolate\"] [\"Banana\"] [\"", "  (cond [(empty? extensions) \"Extensions\
    \ list is empty!\"]\n        [else (Strongest_Extension_Help \n              \
    \  class_name \n                extensions \n                (car extensions)\n\
    \                (cap_count (car extensions))\n                (sm_count (car\
    \ extensions))\n                (fraction (cap_count (car extensions)) (sm_count\
    \ (car extensions))))]))\n", "  (let ([name (string-&gt;symbol class_name)]\n\
    \        [exts (map string-&gt;symbol extensions)])\n    (string-append\n    \
    \ (symbol-&gt;string name)\n     \".\"\n     (symbol-&gt;string (apply max-key\
    \ (\u03BB (name) (- (/ (count name #\\A #\\Z) (count name #\\a #\\z)))) exts)))))\n\
    </code>\nYou could also have written:\n<code>#lang racket\n", "  (define (strength\
    \ str)\n    (let ([cap (count (lambda (x) (char-upper-case? x)) str)]\n      \
    \    [sm (count (lambda (x) (char-lower-case? x)) str)])\n      (- cap sm)))\n\
    \  (define (name_from_str str)\n    (string-join (for/list ([c (in-string str)])\n\
    \                  (if (char-upper-case? c)\n                      (string-append\
    \ \"_\" (string-downcase (string c)))\n                      (string c))) \"\"\
    ))\n  (let ([sorted-exts (sort extensions strength >)])\n    (string-append class_name\
    \ \".\" (name_from_str (car sorted-exts)))))\n", "  (cond\n    [(empty? extensions)\
    \ \"No extensions\"]\n    [else (displayln class_name)\n          (displayln extensions)\n\
    \          (string-append class_name \".\" (car extensions))]))", "  (let ((strength\
    \ (map\n\t\t   (lambda (e)\n\t\t     (let ((sm (count-if char-alphabetic? e))\n\
    \t\t\t   (cap (count-if char-uppercase? e)))\n\t\t       (/ cap sm)))\n\t\t  \
    \ extensions)))\n    (string-append class_name\n\t\t   \".\"\n\t\t   (list-ref\
    \ extensions\n\t\t\t     (min-index strength)))))\n", "  (define (cap-sm s)\n\
    \    (- (count (\u03BB (c) (char-upper-case? c)) s)\n       (count (\u03BB (c)\
    \ (char-lower-case? c)) s)))\n  (define (maximum l max)\n    (cond [(empty? l)\
    \ max]\n          [(> (cap-sm (first l)) max)\n           (maximum (rest l) (cap-sm\
    \ (first l)))]\n          [else (maximum (rest l) max)]))\n  (define (extension-max-strength\
    \ l max)\n    (cond [(empty? l) (list max)]\n          [(= (cap-sm (first l))\
    \ max)\n           (cons (first l) (extension-max-strength (rest l) max))]\n \
    \         [else (extension-max-strength (rest l) max)]))\n  (string-append class_name\
    \ \".\" (first (extension-max-strength extensions (maximum extensions -10000)))))\n",
  "  (let ((extensions_strength (map (lambda (extension)\n                       \
    \             (let ((upper_letters (for/list ([i (in-range (string-length extension))])\n\
    \                                                                  (string-upper-case\
    \ (string-ref extension i))))\n                                          (lower_letters\
    \ (for/list ([i (in-range (string-length extension))])\n                     \
    \                                             (string-lower-case (string-ref extension\
    \ i)))))\n                                      (cons extension (/ (- (length\
    \ upper_letters) (length lower_letters)) (length extension)))))\n            \
    \                      extensions)))\n    (string-append class_name \".\" (car\
    \ (car (sort (lambda (x y) (< (cdr x) (cdr y))) extensions_strength))))))\n",
  "  (define (get_strength extension)\n    (let loop ([extension extension] [cap 0]\
    \ [sm 0])\n      (cond\n        [(string-empty? extension) (- cap sm)]\n     \
    \   [(char-upcase? (string-ref extension 0))\n         (loop (substring extension\
    \ 1) (+ cap 1) sm)]\n        [(char-lowercase? (string-ref extension 0))\n   \
    \      (loop (substring extension 1) cap (+ sm 1))]\n        [else (loop (substring\
    \ extension 1) cap sm)])))\n  (string-append class_name \".\"\n              \
    \   (first (sort (filter (lambda (x)\n                                       \
    \ (not (equal? (get_strength x) 0)))\n                                      extensions)\n\
    \                              (lambda (x y) (< (get_strength x) (get_strength\
    \ y)))))))", "  (match-define (list (list strength ext_name) ...)\n          \
    \      (sort (for/list ([ext (in-list extensions)])\n                       (list\n\
    \                        (quotient (- (for/sum ([ch (in-string ext)])\n      \
    \                                 (if (char-upper-case? ch) 1 0))\n          \
    \                          (for/sum ([ch (in-string ext)])\n                 \
    \                      (if (char-lower-case? ch) 1 0)))\n                    \
    \            )\n                        ext))\n                      #:key first))\n\
    \  (string-append class_name \".\" ext_name))\n", "  (let ([ext (car extensions)])\n\
    \    (if (null? (cdr extensions))\n        (string-append class_name \".\" ext)\n\
    \        (let* ([strengths (map (lambda (e) (strength e)) extensions)]\n     \
    \          [the-strongest (argmax strengths)])\n          (string-append class_name\
    \ \".\" (list-ref extensions the-strongest))))))\n", "  (define (strength extension)\n\
    \    (let ([uppers (for/list ([c (in-string extension)])\n                   \
    \ (if (char-upper-case? c)\n                        1\n                      \
    \  0))])\n      (let ([lowers (for/list ([c (in-string extension)])\n        \
    \              (if (char-lower-case? c)\n                          1\n       \
    \                   0))])\n        (- (apply + uppers) (apply + lowers)))))\n\
    \  (define (max-strength lst)\n    (if (null? lst)\n        '()\n        (cond\
    \ [(and (null? (cdr lst))\n                    (not (null? (car lst))))\n    \
    \           (car lst)]\n              [(null? (car lst))\n               (max-strength\
    \ (cdr lst))]\n              [(null? (cdr lst))\n               (max-strength\
    \ (cons '() lst))]\n              [else\n               (let ([a (car lst)]\n\
    \                     [b (cadr lst)])\n                 (if (> (strength a) (strength\
    \ b))\n                     (max-strength (cons a (cddr lst)))\n             \
    \        (max-strength (cons b (cddr lst)))))])))\n  (let ([max (max-strength\
    \ extensions)])\n    (if (null? max)\n        \"\"\n        (string-append class_name\
    \ \".\" max))))\n", "  (define (strength extension)\n    (let ((upper_letters\
    \ (count-if #\"A-Z\" extension))\n          (lower_letters (count-if #\"a-z\"\
    \ extension)))\n      (/ upper_letters (- upper_letters lower_letters))))\n  (let\
    \ ((strengths (map strength extensions)))\n    (format \"~a.~a\" class_name (list-ref\
    \ extensions (argmax strengths)))))\n</code>\n", "  (local\n    ((define (strength\
    \ ext)\n       (if (empty? ext)\n           0\n           (+ (if (char-lower-case?\
    \ (car ext))\n                  1\n                  0)\n              (if (char-upper-case?\
    \ (car ext))\n                  -1\n                  0)\n              (strength\
    \ (cdr ext)))))\n     (define (sorting exts)\n       (sort exts\n            \
    \ (lambda (a b)\n               (or (and (= (strength a) (strength b))\n     \
    \                   (< (string-ci<? a b) 0))\n                   (< (strength\
    \ a) (strength b)))))))\n    (if (empty? extensions)\n        \"\"\n        (string-append\
    \ class_name \".\"\n                       (car (sorting extensions))))))\n",
  "  (let* ((ext_list (map (\u03BB (ext) (list ext (- (/ (count-matches #\\A-Z ext)\
    \ (count-matches #\\a-z ext))))) extensions))\n         (max_strenght (apply max\
    \ (map (\u03BB (ext) (cadr ext)) ext_list)))\n         (max_extensions (filter\
    \ (\u03BB (ext) (= (cadr ext) max_strenght)) ext_list)))\n    (string-append class_name\
    \ \".\" (caar max_extensions))))\n", "  (let\n      ([caps (map (lambda (x) (length\
    \ (regexp-match #rx\"[A-Z]\" x))) extensions)]\n       [sms (map (lambda (x) (length\
    \ (regexp-match #rx\"[a-z]\" x))) extensions)]\n       [strengths (map - caps\
    \ sms)]\n       [max-strength (apply max strengths)]\n       [max-index (index-of\
    \ max-strength strengths)])\n    (string-append class_name \".\" (list-ref extensions\
    \ max-index))))\n</code>\n", "  (let ([class_name (string->symbol class_name)])\n\
    \    (cond [(null? extensions) #f]\n          [else (define (get-extension-strength\
    \ extension)\n                    (let loop ([extension_name (string->symbol extension)])\n\
    \                      (if (symbol? extension_name)\n                        \
    \  (apply + (map (compose char-&gt;integer char-upcase) \n                   \
    \                     (string-&gt;list extension)))\n                        \
    \  (loop (car extension_name)))))\n                (define (get-strength-extension-name\
    \ extension)\n                  (string-append (symbol-&gt;string class_name)\
    \ \".\" extension))\n                (apply max-key get-extension-strength\n \
    \                      (map get-strength-extension-name extensions))])))\n", " \
    \ (let ((extension-strength (map (lambda (x) (cons x (- (/ (string-length (regexp-replace\
    \ #rx\"[a-z]\" x \"\")) (string-length (regexp-replace #rx\"[A-Z]\" x \"\")))\
    \ 0))) extensions)))\n    (if (null? extension-strength)\n        class_name\n\
    \        (string-append class_name \".\" (caar (sort extension-strength (lambda\
    \ (x y) (> (cdr x) (cdr y)))))))))", "  (define (cap_number word)\n    (foldr\
    \ (lambda (letter count)\n             (if (char-upper-case? letter)\n       \
    \          (+ count 1)\n                 count))\n           0\n           word))\n\
    \  (define (sm_number word)\n    (foldr (lambda (letter count)\n             (if\
    \ (char-lower-case? letter)\n                 (+ count 1)\n                 count))\n\
    \           0\n           word))\n  (define (cap_minus_sm word)\n    (- (cap_number\
    \ word) (sm_number word)))\n  (define (strongest-extension? extension)\n    (if\
    \ (null? extensions)\n        #f\n        (let ((compare-value (- (cap_minus_sm\
    \ (first extensions))\n                                (cap_minus_sm extension))))\n\
    \          (if (= compare-value 0)\n              (if (equal? (first extensions)\
    \ extension)\n                  #t\n                  (strongest-extension? (first\
    \ extensions)))\n              (if (&lt; compare-value 0)\n                  (strongest-extension?\
    \ (first extensions))\n                  #t)))))\n  (if (null? extensions)\n \
    \     class_name\n      (string-append class_name \".\" (first (filter strongest-extension?\
    \ extensions)))))\n", "  (let loop ([exns extensions] [strongest \"\"] [strongest-strength\
    \ 0])\n    (cond\n      [(empty? exns)\n       (string-append class_name \".\"\
    \ strongest)]\n      [else\n       (let ([strength (strength (first exns))])\n\
    \         (if (> strength strongest-strength)\n             (loop (rest exns)\
    \ (first exns) strength)\n             (loop (rest exns) strongest strongest-strength)))])))\n",
  "  (define cap_chars\n    (regexp-match* #rx\"[A-Z]\" class_name))\n  (define small_chars\n\
    \    (regexp-match* #rx\"[a-z]\" class_name))\n  (define cap_num\n    (length\
    \ cap_chars))\n  (define small_num\n    (length small_chars))\n  (define strength\n\
    \    (- cap_num small_num))\n  (define (strengthen extension)\n    (define cap_chars\n\
    \      (regexp-match* #rx\"[A-Z]\" extension))\n    (define small_chars\n    \
    \  (regexp-match* #rx\"[a-z]\" extension))\n    (define cap_num\n      (length\
    \ cap_chars))\n    (define small_num\n      (length small_chars))\n    (define\
    \ strength\n      (- cap_num small_num))\n    strength)\n  (define (strongest\
    \ extensions)\n    (if (null? extensions)\n        '()\n        (let ([strongest\
    \ (strengthen (car extensions))])\n          (for/fold ([result (cons (car extensions)\
    \ '())]) ([extension (cdr extensions)])\n            (let ([new-extension (strengthen\
    \ extension)])\n              (if (&gt;= new-extension strongest)\n          \
    \        (cons extension result)\n                  result))))))\n  (string-append\
    \ class_name \".\" (car (strongest extensions))))\n", "  (let loop ([exts extensions]\n\
    \             [strength -1]\n             [cap 0]\n             [sm 0]\n     \
    \        [strongest_extension #f])\n    (cond [(empty? exts)\n           (string-append\
    \ class_name \".\" (symbol->string strongest_extension))]\n          [else\n \
    \          (define ext (first exts))\n           (define ext_cap (cdr (regexp-match*\
    \ #rx\"^[A-Z]+\" ext)))\n           (define ext_sm (cdr (regexp-match* #rx\"[a-z]+$\"\
    \ ext)))\n           (define this_strength (/ (string-length ext_cap) (string-length\
    \ ext_sm)))\n           (if (> this_strength strength)\n               (loop (rest\
    \ exts)\n                     this_strength\n                     (string-length\
    \ ext_cap)\n                     (string-length ext_sm)\n                    \
    \ ext)\n               (loop (rest exts)\n                     strength\n    \
    \                 cap\n                     sm\n                     strongest_extension))])))\n\
    </code>\n", "  (string-append class_name \".\" (car (sort extensions (lambda (e1\
    \ e2) \n\t\t\t\t\t\t      (< (fraction e1) (fraction e2)))))))\n", "  (define\
    \ strongest_extension_name \"\")\n  (define strongest_extension_strength -10000)\n\
    \  (define (strength_of ext)\n    (let ((ext_length (string-length ext))\n   \
    \       (small_case_count 0)\n          (capital_case_count 0))\n      (let ((x\
    \ 0))\n        (do ((x x (+ x 1)))\n            ((= x ext_length) (round (/ (-\
    \ capital_case_count small_case_count)\n                                     \
    \   ext_length)))\n          (if (char-alphabetic? (string-ref ext x))\n     \
    \         (if (char-lower-case? (string-ref ext x))\n                  (set! small_case_count\
    \ (+ small_case_count 1))\n                  (set! capital_case_count (+ capital_case_count\
    \ 1)))))))))\n  (define (find_strength ext_list)\n    (if (null? ext_list)\n \
    \       (format \"~a.~a\" class_name strongest_extension_name)\n        (let ((new_strength\
    \ (strength_of (car ext_list))))\n          (if (> new_strength strongest_extension_strength)\n\
    \              (begin\n                (set! strongest_extension_strength new_strength)\n\
    \                (set! strongest_extension_name (car ext_list))\n            \
    \    (find_strength (cdr ext_list))))\n              (find_strength (cdr ext_list))))))\n\
    \  (find_strength extensions))", "  (string-append class_name \".\" (first (sort\
    \ (map (lambda (extension) (list extension (- (count-cap extension) (count-sm\
    \ extension)))) extensions) string&lt;=?))))\n</code>\n", "  (let ((strongest\
    \ (strongest-extension extensions)))\n    (string-append class_name \".\" strongest)))\n",
  "  (let* ([class-name class_name]\n         [extensions extensions]\n         [best-extension\
    \ (first extensions)]\n         [best-extension-strength (- (count-upper best-extension)\n\
    \                                     (count-lower best-extension))])\n    (for\
    \ ([extension extensions])\n      (let* ([extension-strength (- (count-upper extension)\n\
    \                                    (count-lower extension))])\n        (if (&gt;\
    \ extension-strength best-extension-strength)\n            (set! best-extension\
    \ extension)\n            (set! best-extension-strength extension-strength))))\n\
    \    (format \"~a.~a\" class-name best-extension)))\n", "  (define (cap_diff string)\n\
    \    (- (length (filter string char-uppercase?))\n       (length (filter string\
    \ char-lowercase?))))\n  (define ext-cap-diffs (map cap-diff extensions))\n  (define\
    \ strongest-ext-cap-diff (apply max ext-cap-diffs))\n  (define strongest-ext (list-ref\
    \ extensions (position strongest-ext-cap-diff ext-cap-diffs)))\n  (string-append\
    \ class_name \".\" strongest-ext))\n</code>\n", "  (define (calc_strength ext)\n\
    \    (define CAP (count (char-upcase? #\\A) ext))\n    (define SM (count (char-lowercase?\
    \ #\\a) ext))\n    (/ CAP SM))\n  (define (max_strength exts best_ext)\n    (if\
    \ (null? exts) best_ext\n        (let ([curr_str (calc_strength (car exts))]\n\
    \              [best_str (calc_strength best_ext)])\n          (if (&gt; curr_str\
    \ best_str)\n              (max_strength (cdr exts) (car exts))\n            \
    \  (max_strength (cdr exts) best_ext)))))\n  (string-append class_name \".\" (max_strength\
    \ extensions (car extensions))))\n", "\t(let ([extension-strengths (map (lambda\
    \ (x) (cons x (extension-strength x))) extensions)])\n\t\t(let ([strongest-extension\
    \ (apply max (map cdr extension-strengths))])\n\t\t\t(cond\n\t\t\t\t[(equal? strongest-extension\
    \ 0) (string-append class_name \".\" \"default\")]\n\t\t\t\t[else (string-append\
    \ class_name \".\" (car (filter (lambda (x) (equal? (cdr x) strongest-extension))\
    \ extension-strengths)))]))))\n", "  (string-append class_name \".\" (car (cadddr\
    \ extensions))))\n", "  (define (strength x) (- (count-filtered char-upcase? x)\
    \ (count-filtered char-lower-case? x)))\n  (apply max (map strength extensions)))\n",
  "  (define (strength str) (/ (- (count-if char-upper-case? str) (count-if char-lower-case?\
    \ str)) (length str)))\n  (string-append class_name \".\" (string-join (first\
    \ (sort (filter (lambda (ext) (> (strength ext) 0)) extensions)) <)) ))\n", " \
    \ (string-append class_name \".\" (list-ref extensions 0)))\n", "  (string-append\n\
    \   class_name\n   \".\"\n   (car (filter\n         (lambda (extension)\n    \
    \       (= (strength extension) (max-strength extensions)))\n         extensions))))\n",
  "  (define cap 0)\n  (define sm 0)\n  (define str_ext \"\")\n  (define (strength\
    \ x)\n    (set! cap 0)\n    (set! sm 0)\n    (for ([c (in-string x)])\n      (cond\n\
    \        [(char-upper-case? c) (set! cap (+ cap 1))]\n        [(char-lower-case?\
    \ c) (set! sm (+ sm 1))]))\n    (- cap sm))\n  (define (is_stronger? x y)\n  \
    \  (< (strength x) (strength y)))\n  (set! str_ext (car (sort is_stronger? extensions)))\n\
    \  (format \"~a.~a\" class_name str_ext))\n", "  (define (fraction-of-caps str)\n\
    \    (if (empty? str)\n        0\n        (+ (/ (char-upcase? (car str)) (string-length\
    \ str))\n           (fraction-of-caps (cdr str)))))\n  (define (caps-sub-small\
    \ str)\n    (- (fraction-of-caps str)\n       (/ (string-length (string-filter\
    \ char-lower-case? str))\n          (string-length str))))\n  (let ([options (vector-map\
    \ string->symbol extensions)])\n    (string-append class_name\n              \
    \     \".\"\n                   (symbol->string (vector-ref (sort options <\n\
    \                                                          (\u03BB (i j)\n   \
    \                                                         (< (caps-sub-small (symbol->string\
    \ i))\n                                                               (caps-sub-small\
    \ (symbol->string j)))))\n                                               0)))))\n\
    </code>\n", "  (define (count_caps s)\n    (let loop ([s s] [count 0])\n     \
    \ (if (empty? s)\n          count\n          (if (char-upper-case? (car s))\n\
    \              (loop (cdr s) (+ count 1))\n              (loop (cdr s) count)))))\n\
    \  (define (count_smalls s)\n    (let loop ([s s] [count 0])\n      (if (empty?\
    \ s)\n          count\n          (if (char-lower-case? (car s))\n            \
    \  (loop (cdr s) (+ count 1))\n              (loop (cdr s) count)))))\n  (define\
    \ (total_extensions)\n    (append extensions '()))\n  (define (strong_extensions)\n\
    \    (define (highest_extension)\n      (define (strongest_extension exts)\n \
    \       (if (empty? exts)\n            '()\n            (define (first_extension)\n\
    \              (list (car exts)\n                    (/ (- (count_caps (car exts))\n\
    \                          (count_smalls (car exts)))\n                      \
    \ (length (car exts)))))\n            (define (rest_extensions)\n            \
    \  (strongest_extension (cdr exts)))\n            (if (empty? rest_extensions)\n\
    \                first_extension\n                (if (< (car (car rest_extensions))\
    \ (car (car first_extension)))\n                    rest_extensions\n        \
    \            first_extension))))\n      (if (empty? exts)\n          '()\n   \
    \       (define (first_extension)\n            (car (strongest_extension (list\
    \ (car exts)))))\n          (define (rest_extensions)\n            (highest_extension\
    \ (cdr exts)))\n          (if (empty? rest_extensions)\n              first_extension\n\
    \              (if (= (car (car rest_extensions)) (car (car first_extension)))\n\
    \                  (append (list (car first_extension)) rest_extensions)\n   \
    \               first_extension))))\n    (highest_extension (total_extensions)))\n\
    \  (string-append class_name \".\" (car (car (strong_ext", "  (define (count-caps\
    \ str)\n    (length\n     (filter char-upper-case?\n             (string->list\
    \ str))))\n  (define (count-smalls str)\n    (length\n     (filter char-lower-case?\n\
    \             (string->list str))))\n  (define (extension-strength str)\n    (/\
    \ (- (count-caps str)\n          (count-smalls str))\n       (length str)))\n\
    \  (string-append\n   class_name\n   \".\"\n   (if (not (empty? extensions))\n\
    \       (apply max extensions extension-strength)\n       \"\")))\n", "  (define\
    \ (count-upper str)\n    (let loop ((i 0) (upper 0))\n      (if (= i (string-length\
    \ str))\n          upper\n          (if (char-upper-case? (string-ref str i))\n\
    \              (loop (+ i 1) (+ upper 1))\n              (loop (+ i 1) upper)))))\n\
    \  (define (count-lower str)\n    (let loop ((i 0) (lower 0))\n      (if (= i\
    \ (string-length str))\n          lower\n          (if (char-lower-case? (string-ref\
    \ str i))\n              (loop (+ i 1) (+ lower 1))\n              (loop (+ i\
    \ 1) lower)))))\n  (define (strength str)\n    (/ (- (count-upper str) (count-lower\
    \ str)) (string-length str)))\n  (define (strongest-extension lst)\n    (cond\
    \ ((null? lst) #f)\n          ((null? (cdr lst)) (car lst))\n          (else (let\
    \ ((strongest-car (string->symbol (string-append class_name \".\" (car lst))))\n\
    \                       (strongest-cdr (string->symbol (string-append class_name\
    \ \".\" (cadr lst)))))\n                  (if (> (strength (car lst)) (strength\
    \ (cadr lst)))\n                      strongest-car\n                      strongest-cdr)))))\n\
    \  (symbol->string (strongest-extension extensions)))\n", "  (local [(define (strength\
    \ s)\n            (define (counter c)\n              (if (eq? (string-length s)\
    \ 0) 0\n                (if (char-lower-case? (string-ref s 0))\n            \
    \        (+ 1 (counter (substring s 1)))\n                    (counter (substring\
    \ s 1)))))\n            (- (counter s) (counter (string-downcase s))))]\n    (local\
    \ [(define (helper ls)\n              (if (eq? (cdr ls) '()) (car ls)\n      \
    \          (if (< (strength (car ls)) (strength (cadr ls)))\n                \
    \    (helper (cdr ls))\n                    (helper (cons (car ls) (cddr ls))))))]\n\
    \      (string-append class_name \".\" (helper extensions)))))", "  (define strength\
    \ (lambda (extension)\n                     (let ((len (string-length extension))\n\
    \                           (small_len (lambda (str) (for/fold ([n 0]) ([c (in-string\
    \ str)]) (if (and (char-lower-case? c) (char-alphabetic? c)) (add1 n) n))))\n\
    \                           (cap_len (lambda (str) (for/fold ([n 0]) ([c (in-string\
    \ str)]) (if (and (char-upper-case? c) (char-alphabetic? c)) (add1 n) n)))))\n\
    \                       (/ (- (small_len extension) (cap_len extension)) len))))\n\
    \  (string-append class_name\n                 \".\"\n                 (match\
    \ (for/first ([ext (in-list extensions)]\n                                   \
    \ #:when (and (eq? (strength ext)\n                                          \
    \           (apply max (map strength extensions)))\n                         \
    \                       (not (empty? ext))))\n                          ext)\n\
    \                   [(? symbol?) ext]\n                   [_ \"\"])))\n", "  (define\
    \ (strength ext)\n    (let ([caps (regexp-match #rx\"[A-Z]\" ext)]\n         \
    \ [smalls (regexp-match #rx\"[a-z]\" ext)])\n      (/ (- (length caps) (length\
    \ smalls)) (length ext))))\n  (string-append class_name \".\" (apply max-by (list\
    \ strength extensions) extensions)))\n", "  (let ([strength (lambda (ext) (/ (-\
    \ (regexp-match* #rx\"[A-Z]\" ext)\n                                      (regexp-match*\
    \ #rx\"[a-z]\" ext)))\n                               2))])\n    (string-append\
    \ class_name \".\"\n                   (car (argmin extensions strength)))))\n",
  "  (define (caps n)\n    (regexp-match #rx\"[A-Z]\" n))\n  (define (small n)\n \
    \   (regexp-match #rx\"[a-z]\" n))\n  (define (ext-strength n)\n    (/ (- (caps\
    \ n) (small n)) (length n)))\n  (define (max-in-list lst)\n    (apply max lst))\n\
    \  (let ([cap-nums (map caps extensions)]\n        [sm-nums (map small extensions)]\n\
    \        [strengths (map ext-strength extensions)])\n    (string-append class_name\
    \ \".\" (list-ref extensions (argmax strengths)))))", "  (define (extension-strength\
    \ extension)\n    (/ (- (count-uppercase extension) (count-lowercase extension))\
    \ (length extension)))\n  (define (count-uppercase x)\n    (if (null? x)\n   \
    \     0\n        (+ (if (upper-case? (car x)) 1 0) (count-uppercase (cdr x)))))\n\
    \  (define (count-lowercase x)\n    (if (null? x)\n        0\n        (+ (if (lower-case?\
    \ (car x)) 1 0) (count-lowercase (cdr x)))))\n  (string-append class_name \".\"\
    \ (car (sort extensions (lambda (x y) (&gt; (extension-strength x) (extension-strength\
    \ y)))))))\n", "  (define (get_strength name)\n    (define (is_upper? ch)\n  \
    \    (integer? (char-upcase ch)))\n    (define (is_lower? ch)\n      (integer?\
    \ (char-downcase ch)))\n    (define (get_strength_of_name x)\n      (let ([cap_num\
    \ (apply + (map (\u03BB (ch) (if (is_upper? ch) 1 0)) x))]\n            [sm_num\
    \ (apply + (map (\u03BB (ch) (if (is_lower? ch) 1 0)) x))])\n        (/ cap_num\
    \ sm_num)))\n    (get_strength_of_name name))\n  (define (get_strongest name_list)\n\
    \    (cond [(null? name_list) (error \"name_list is null.\")]\n          [(null?\
    \ (cdr name_list)) (car name_list)]\n          [else (let ([first (car name_list)]\n\
    \                      [second (car (cdr name_list))])\n                  (if\
    \ (> (get_strength first) (get_strength second))\n                      first\n\
    \                      second))]))\n  (string-append class_name \".\" (get_strongest\
    \ extensions)))\n", "  (letrec ([strength (lambda (x)\n                      \
    \ (let ([cap (count-letter 'upper-case? x)]\n                             [sm\
    \ (count-letter 'lower-case? x)])\n                         (- cap sm)))])\n \
    \   (let ([sorted-by-strength (sort extensions strength\n                    \
    \                 string<? #:key strength)])\n      (string-append class_name\
    \ \".\" (car sorted-by-strength)))))\n", "  (letrec ([count-capital-letters (lambda\
    \ (str) (for/fold ([count 0]) ([x (in-string str)])\n                        \
    \                         (if (char-upper-case? x) (add1 count) count)))]\n  \
    \         [count-small-letters (lambda (str) (for/fold ([count 0]) ([x (in-string\
    \ str)])\n                                               (if (char-lower-case?\
    \ x) (add1 count) count)))]\n           [strength (lambda (str) (/ (- (count-capital-letters\
    \ str) (count-small-letters str))\n                                      (string-length\
    \ str)))])\n    (call-with-values (lambda () (fold (lambda (str str_pair)\n  \
    \                                        (match-define (list class_str ext_str)\
    \ str_pair)\n                                          (match (strength str)\n\
    \                                                 [(> curr_strength curr_strength)\
    \ (list class_str str)]\n                                                 [curr_strength\
    \ (list class_str ext_str)]))\n                                        (list class_name\
    \ (car extensions))\n                                        (cdr extensions)))\n\
    \                      (lambda (class_str ext_str) (format \"~a.~a\" class_str\
    \ ext_str)))))\n", "  (let ([cap (count_caps extensions)]\n        [sm (count_sm\
    \ extensions)])\n    (- cap sm)))\n", "  (string-upcase\n   (string-append\n \
    \   class_name\n    \".\"\n    (car\n     (sort (for/list ([ext (in-list extensions)])\n\
    \            (list\n             (- (length (regexp-match #rx\"[A-Z]\" ext))\n\
    \                (length (regexp-match #rx\"[a-z]\" ext)))\n             ext))\n\
    \           (lambda (a b) (if (> (car a) (car b)) #t #f)))))))\n", "  (define\
    \ (fraction str)\n    (/ (- (count-if char-alphabetic? (regexp-match* #rx\"[A-Z]\"\
    \ str))\n          (count-if char-alphabetic? (regexp-match* #rx\"[a-z]\" str)))\n\
    \       (string-length str)))\n  (string-append class_name \".\"\n           \
    \       (car (sort (map (lambda (e) (cons (fraction e) e)) extensions)\n     \
    \                        < #:key car))))\n", "  (displayln class_name)\n  (define\
    \ (strength_of_extension extension)\n    (define (cap-count str)\n      (define\
    \ (helper str cap-count)\n        (cond [(empty? str) cap-count]\n           \
    \   [(char-upper-case? (first str)) (helper (rest str) (+ cap-count 1))]\n   \
    \           [else (helper (rest str) cap-count)]))\n    (define (sm-count str)\n\
    \      (define (helper str sm-count)\n        (cond [(empty? str) sm-count]\n\
    \              [(char-lower-case? (first str)) (helper (rest str) (+ sm-count\
    \ 1))]\n              [else (helper (rest str) sm-count)]))\n    (/ (- (cap-count\
    \ extension) (sm-count extension)) (- (string-length extension) 1)))\n  (define\
    \ (search extensions strongest-extension)\n    (cond [(empty? extensions) strongest-extension]\n\
    \          [(< (strength_of_extension (first extensions)) (strength_of_extension\
    \ strongest-extension)) (search (rest extensions) strongest-extension)]\n    \
    \      [else (search (rest extensions) (first extensions))]))\n  (format \"~a.~a\"\
    \ class_name (search extensions (first extensions))))\n", "  (define (strength\
    \ str)\n    (if (not (empty? str))\n      (let ([ch (first str)])\n        (if\
    \ (char-upcase? ch)\n          (+ 1 (strength (rest str)))\n          (- (strength\
    \ (rest str)) 1)))\n      0))\n  (define (strongest lst)\n    (if (not (empty?\
    \ lst))\n      (let ([el (first lst)])\n        (let ([next-el (strongest (rest\
    \ lst))])\n          (if (< (strength el) (strength next-el))\n            next-el\n\
    \            el)))\n      (first lst)))\n  (string-append class_name \".\" (strongest\
    \ extensions)))", "  (define (strength extension)\n    (/ (- (length (regexp-match\
    \ #rx\"[A-Z]\" extension))\n          (length (regexp-match #rx\"[a-z]\" extension)))\n\
    \       (length extension)))\n  (displayln (map strength extensions))\n  (string-append\
    \ class_name \".\" (first (sort (map strength extensions) <))))\n", "  (apply\
    \ max \n         (map \n          (lambda (ext)\n            (let ([cap (for/sum\
    \ ([x (in-string ext)])\n                               (if (char-upper-case?\
    \ x) 1 0))]\n                  [sm (for/sum ([x (in-string ext)])\n          \
    \                     (if (char-lower-case? x) 1 0))])\n              (- cap sm)))\n\
    \          extensions)))\n", "  (cond [(empty? extensions) \"\"]\n        [else\n\
    \         (let* ([next_extension (first extensions)]\n                [next_extension_strength\
    \ (fraction-class-strength class_name next_extension)]\n                [rest_extensions\
    \ (rest extensions)]\n                [rest_extensions_strength (fraction-class-strength\
    \ class_name (Strongest_Extension class_name rest_extensions))])\n           (if\
    \ (> next_extension_strength rest_extensions_strength)\n               (string-append\
    \ class_name \".\" next_extension)\n               (string-append class_name \"\
    .\" (Strongest_Extension class_name rest_extensions))))]))\n", "  (let ([strength\
    \ (car (sort > (map (lambda (e)\n\t\t\t\t     (/ (- (count-char-set e #rx\"[A-Z]\"\
    )\n\t\t\t\t\t   (count-char-set e #rx\"[a-z]\"))\n\t\t\t\t\t(length e)))\n\t\t\
    \t\t extensions)))]\n\t(extension (car (filter (lambda (e)\n\t\t\t\t  (= strength\
    \ (\n\t\t\t\t\t       / (- (count-char-set e #rx\"[A-Z]\")\n\t\t\t\t\t\t   (count-char-set\
    \ e #rx\"[a-z]\"))\n\t\t\t\t\t       (length e))))\n\t\t\t\textensions))))\n \
    \   (format \"~a.~a\" class_name extension)))\n", "  (local [(define (count_caps\
    \ str)\n            (string-count str #rx\"[A-Z]\"))\n          (define (count_small\
    \ str)\n            (string-count str #rx\"[a-z]\"))\n          (define (strength\
    \ str)\n            (- (count_caps str) (count_small str)))\n          (define\
    \ (strongest_extension lst)\n            (apply max (map strength lst)))\n   \
    \       (define (positions pred lst)\n            (cond [(empty? lst) empty]\n\
    \                  [(pred (first lst)) (cons 0 (map add1 (positions pred (rest\
    \ lst))))]\n                  [else (positions pred (rest lst))]))\n         \
    \ (define (fst-strongest lst)\n            (first (filter (lambda (x) (= (strength\
    \ x) (strongest_extension lst)))\n                           lst)))]\n    (local\
    \ [(define x (positions (lambda (x) (= x (strongest_extension extensions)))\n\
    \                                 (map strength extensions)))]\n      (string-append\
    \ class_name \".\" (fst-strongest extensions)))))\n", "  (define (ret_strongest_extensions\
    \ class_name extensions)\n    (define (ret_strength extension)\n      (define\
    \ (ret_caps extension)\n        (let ([counter 0])\n          (for ([char extension])\n\
    \            (if (char-upper-case? char)\n                (set! counter (+ counter\
    \ 1))))\n          counter))\n    (define (ret_smalls extension)\n      (let ([counter\
    \ 0])\n        (for ([char extension])\n          (if (char-lower-case? char)\n\
    \              (set! counter (+ counter 1))))\n        counter))\n    (define\
    \ (ret_strength_extension extension)\n      (- (ret_caps extension) (ret_smalls\
    \ extension)))\n    (define (ret_strongest_strength extensions)\n      (for/min\
    \ ([extension extensions])\n                [(ret_strength_extension extension)]))\n\
    \    (define (ret_strongest_extension strength extensions)\n      (cond [(and\
    \ (not (empty? extensions)) (equal? (ret_strength_extension (first extensions))\
    \ strength))\n             (first extensions)]\n            [else (ret_strongest_extension\
    \ strength (rest extensions))]))\n    (ret_strongest_extension (ret_strongest_strength\
    \ extensions) extensions))\n  (string-append class_name \".\" (ret_strongest_extensions\
    \ class_name extensions)))\n</code>\nSince I am new to racket I would like to\
    \ see if there are any suggestions for writing idiomatic racket for the code above.\n\
    \n\nA:\n\nthere are a few things that can be done to make this solution more idiomatic.\n\
    Splitting strings\nFirst of all, there's a nice new procedure in Racket which\
    \ makes splitting strings very easy. It's called <code>string-split</code> and\
    \ it takes a string and a character to split on and returns a list of strings.\n\
    <code>(string-split \"abc.de\" #\\.)\n</code>\nreturns\n<code>'(\"abc\" \"de\"\
    )\n</code>\nYou can use this procedure to replace the use of <code>string-&gt;list</code>\
    \ and <code>list-&gt;string</code> in your solution.\nUsing predicates\nWhen testing\
    \ if a character is upper-", "  (let ((extensions-lst \n         (map (lambda\
    \ (extension)\n                (list extension\n                      (- (length\
    \ (regexp-match* #rx\"[A-Z]\" extension))\n                         (length (regexp-match*\
    \ #rx\"[a-z]\" extension)))))\n              extensions)))\n    (string-append\
    \ class_name \".\"\n                   (car (apply max-list extensions-lst)))))",
  "  (define (strength str)\n    (/ (- (length (regexp-match #rx\"[A-Z]\" str))\n\
    \          (length (regexp-match #rx\"[a-z]\" str)))\n       1.0))\n  (define\
    \ (cmp a b)\n    (define (subtract a b)\n      (if (or (= a b) (&lt; a b))\n \
    \         0\n          (- a b)))\n    (subtract (strength a) (strength b)))\n\
    \  (string-append\n   class_name\n   \".\"\n   (string-append (car (sort cmp extensions)))))\n\
    </code>\nAnd here is the main function.\n<code>#lang racket\n", "  (cond\n   \
    \ [(empty? extensions) (printf \"Class name: ~a --&gt; No extensions.\\n\" class_name)]\n\
    \    [else\n     (define strongest_ext (first extensions))\n     (for ((ext (rest\
    \ extensions)))\n       (if (&gt; (strength (first extensions)) (strength strongest_ext))\n\
    \           (set! strongest_ext (first extensions))))\n     (printf \"Class name:\
    \ ~a --&gt; ~a.~a\\n\" class_name class_name strongest_ext)]))\n", "  (car (sort\
    \ (for/list ([ext_name extensions])\n               (list (- (count (lambda (c)\
    \ (char-upper-case? c)) ext_name)\n                       (count (lambda (c) (char-lower-case?\
    \ c)) ext_name))\n                     ext_name))\n             >)))\n", "  (let\
    \ ([extensions (map string-upcase extensions)])\n    (apply string-append\n  \
    \         (append (list class_name \".\")\n                   (list (or (apply\
    \ min-key (curryr - count-upper-letters) extensions)\n                       \
    \      \"ERROR\"))))))\n</code>\nwhich gives the desired result:\n<code>&gt; (Strongest_Extension\
    \ \"Slices\" '(\"SErviNGSliCes\" \"Cheese\" \"StuFfed\"))\n\"Slices.SErviNGSliCes\"\
    \n</code>\n", "  (define (strength ext)\n    (/ (- (length (regexp-match #rx\"\
    [A-Z]\" ext))\n          (length (regexp-match #rx\"[a-z]\" ext)))\n       (length\
    \ ext)))\n  (define ext-list (sort extensions (lambda (x y)\n                \
    \                      (string<? x y))))\n  (define str-list (map strength ext-list))\n\
    \  (define str-max (apply max str-list))\n  (string-append class_name \".\" (list-ref\
    \ ext-list (list-index str-max str-list))))\n", "  (cond [(empty? extensions)\
    \ \"\"]\n        [else (apply max\n                     (map (\u03BB (x)\n   \
    \                         (list (cadr (string-split (string-upcase x) #\\.)) x\n\
    \                                  (- (length (filter char-upper-case? (string-upcase\
    \ x)))\n                                     (length (filter char-lower-case?\
    \ (string-upcase x))))))\n                          extensions))]))\n", "  (if\
    \ (null? extensions) \n      (error \"No strongest extension.\")\n      (let ([strength\
    \ (lambda (ext) (- (length (regexp-match* #rx\"[A-Z]\" ext)) (length (regexp-match*\
    \ #rx\"[a-z]\" ext))))])\n        (apply max (map strength extensions)))))\n</code>\n\
    With a little tweaking, that same approach would work with the Python <code>re</code>\
    \ module.\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
