name: HumanEval_89_encrypt
language: rkt
prompt: "#lang racket\n\n;; Create a function encrypt that takes a string as an argument\
  \ and\n;; returns a string encrypted with the alphabet being rotated. \n;; The alphabet\
  \ should be rotated in a manner such that the letters \n;; shift down by two multiplied\
  \ to two places.\n;; For example:\n(define (encrypt s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n\
  \    (check-equal? (candidate \"hi\") \"lm\")\n    (check-equal? (candidate \"asdfghjkl\"\
  ) \"ewhjklnop\")\n    (check-equal? (candidate \"gf\") \"kj\")\n    (check-equal?\
  \ (candidate \"et\") \"ix\")\n    (check-equal? (candidate \"faewfawefaewg\") \"\
  jeiajeaijeiak\")\n    (check-equal? (candidate \"hellomyfriend\") \"lippsqcjvmirh\"\
  )\n    (check-equal? (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  ) \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\n    (check-equal? (candidate\
  \ \"a\") \"e\")\n))\n\n(test-humaneval)"
completions: ["  (let ([keylist (list \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"\
    h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"\
    u\" \"v\" \"w\" \"x\" \"y\" \"z\")])\n    (let ([keylist-concat (append keylist\
    \ keylist)])\n      (letrec ([helper (lambda (ls s i)\n                      \
    \    (if (= i (string-length s))\n                              (list->string\
    \ ls)\n                              (helper (append ls (list (string-ref s i)))\
    \ s (+ i 1))))])\n        (helper '() s 0)))))\n", "  (list->string\n   (map\n\
    \    (lambda (c)\n      (integer->char (if (= (char->integer c) 90)\n        \
    \                 65\n                         (if (= (char->integer c) 122)\n\
    \                             97\n                             (+ (char->integer\
    \ c) 2)))))\n    (string->list s))))", "  (letrec ([encrypt2 s]\n           [encrypt1\
    \ (string-translate encrypt2\n                                       (lambda (c)\n\
    \                                         (if (or (char=? c #\\a)\n          \
    \                                       (char=? c #\\A))\n                   \
    \                          #\\c\n                                            \
    \ (if (or (char=? c #\\b)\n                                                  \
    \   (char=? c #\\B))\n                                                 #\\d\n\
    \                                                 (if (or (char=? c #\\c)\n  \
    \                                                       (char=? c #\\C))\n   \
    \                                                  #\\e\n                    \
    \                                 (if (or (char=? c #\\d)\n                  \
    \                                           (char=? c #\\D))\n               \
    \                                          #\\f\n                            \
    \                             (if (or (char=? c #\\e)\n                      \
    \                                           (char=? c #\\E))\n               \
    \                                              #\\g\n                        \
    \                                     (if (or (char=? c #\\f)\n              \
    \                                                       (char=? c #\\F))\n   \
    \                                                              #\\h\n        \
    \                                                         (if (or (char=? c #\\\
    g)\n                                                                         (char=?\
    \ c #\\G))\n                                                                 \
    \    #\\i\n                                                                  \
    \   (if (or (char=? c #\\h)\n                                                \
    \                             (char=? c #\\H))\n                             \
    \                                            #\\j\n                          \
    \                                               (if (or (char=? c #\\i)\n    \
    \                                                                            \
    \ (char=? c #\\I))\n                                                         \
    \                    #\\k\n                                                  \
    \                           (if (or (char=? c #\\j)\n                        \
    \                                                             (char=? c #\\J))\n\
    \                                                                            \
    \     #\\l\n                                                                 \
    \                (if (or (char=? c #\\k)\n                                   \
    \                                                      (char=? c #\\K))\n    \
    \                                                                            \
    \     #\\m\n                                                                 \
    \                    (if (or (char=? c #\\l)\n                               \
    \                                                              (char=? c #\\L))\n\
    \                                                                            \
    \             #\\n", "  (let loop ([s s] [s2 \"\"])\n    (cond\n      [(empty?\
    \ s) s2]\n      [else (loop (rest s)\n                  (string-append s2 (string\
    \ (rotate (first s) (- (* 2 2))))))])))\n", "  (let loop ((ls (string->list s))\
    \ (res '()))\n    (cond ((null? ls) (list->string (reverse res)))\n          (else\
    \ (let* ((l (car ls)) (e (encrypt-char l)))\n                  (loop (cdr ls)\
    \ (cons e res)))))))", "  (string-append\n   (substring s (- (string-length s)\
    \ (modulo (string-length s) 2)))\n   (substring s 0 (- (string-length s) (modulo\
    \ (string-length s) 2)))))\n", "  (if (string=? s \"\") \n      \"\"\n      (let\
    \ ([c (string-ref s 0)])\n        (string-append (char-downcase (cond [(char-alphabetic?\
    \ c) (+ c (* 2 2))]\n                                            [else c]))\n\
    \                      (encrypt (substring s 1))))))\n</code>\n", "  (let* ([char-list\
    \ (string->list s)]\n         [char-list2 (map (lambda (c)\n                 \
    \           (if (char-alphabetic? c)\n                                (let* ([let-lst\
    \ (string->list \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")]\n                           \
    \            [let-len (length let-lst)]\n                                    \
    \   [i (char-&gt;integer c)]\n                                       [i2 (- (+\
    \ i (* 2 2)) i (modulo i let-len))])\n                                  (integer-&gt;char\
    \ i2))\n                                c))\n                          char-list)])\n\
    \    (list-&gt;string char-list2)))\n", "  (let ([n (string-length s)])\n    (if\
    \ (zero? n)\n        s\n        (string-append (string-append (substring s 0 (-\
    \ n 1))\n                                      (substring s (- n 1) n))\n    \
    \                  (encrypt (substring s 0 (- n 1)))))))\n", "  (for/list ([i\
    \ (in-range (string-length s))])\n    (add1 (+ (string-ref s i) (* 2 2)))\n  \
    \  ))\n", "  (apply string (map (lambda (c)\n                       (if (char-numeric?\
    \ c)\n                           (number->string (char-&gt;integer c))\n     \
    \                      (number-&gt;string (+ (char-&gt;integer c) (* 2 2)))))\n\
    \                     (string-&gt;list s))))\n", "  (define (rotate s)\n    (apply\
    \ string\n           (map (lambda (x)\n                  (if (and (>= x #\\a)\n\
    \                           (<= x #\\z))\n                      (+ x (* 2 2))\n\
    \                      x))\n                (string->list s))))\n  (define (shift\
    \ s)\n    (define (get-char-at-index s i)\n      (let ([c (string-ref s i)])\n\
    \        (if (and (>= c #\\a)\n                 (<= c #\\z))\n            (- c\
    \ (* 2 2))\n            c)))\n    (define (insert-char-at-index s i c)\n     \
    \ (substring s 0 i)\n      (substring s (+ i 1) (string-length s)))\n    (define\
    \ (range i n)\n      (if (>= i n)\n          empty\n          (cons i (range (+\
    \ i 1) n))))\n    (let loop ([i 0]\n               [s s])\n      (cond [(>= i\
    \ (string-length s))\n             s]\n            [else\n             (let ([c\
    \ (get-char-at-index s i)])\n               (loop (+ i 1)\n                  \
    \   (insert-char-at-index s i c)))])))\n  (shift (rotate s)))\n", "  (for/list\
    \ ([i (in-list s)])\n    (cond [(char=? i #\\a) #\\c]\n          [(char=? i #\\\
    b) #\\d]\n          [(char=? i #\\c) #\\e]\n          [(char=? i #\\d) #\\f]\n\
    \          [(char=? i #\\e) #\\g]\n          [(char=? i #\\f) #\\h]\n        \
    \  [(char=? i #\\g) #\\i]\n          [(char=? i #\\h) #\\j]\n          [(char=?\
    \ i #\\i) #\\k]\n          [(char=? i #\\j) #\\l]\n          [(char=? i #\\k)\
    \ #\\m]\n          [(char=? i #\\l) #\\n]\n          [(char=? i #\\m) #\\o]\n\
    \          [(char=? i #\\n) #\\p]\n          [(char=? i #\\o) #\\q]\n        \
    \  [(char=? i #\\p) #\\r]\n          [(char=? i #\\q) #\\s]\n          [(char=?\
    \ i #\\r) #\\t]\n          [(char=? i #\\s) #\\u]\n          [(char=? i #\\t)\
    \ #\\v]\n          [(char=? i #\\u) #\\w]\n          [(char=? i #\\v) #\\x]\n\
    \          [(char=? i #\\w) #\\y]\n          [(char=? i #\\x) #\\z]\n        \
    \  [(char=? i #\\y) #\\a]\n          [(char=? i #\\z) #\\b]\n          [else i])))\n",
  "  (string-&gt;list s))\n", "  (for/list ([c (in-string s)])\n    (if (char-alphabetic?\
    \ c)\n        (char-upcase (+ c (* 2 (- (char-downcase c) #\\a))))\n        c)))\n",
  "  (for/list ([c (in-string s)])\n    (cond\n      [(char=? c #\\a) #\\c]\n    \
    \  [(char=? c #\\b) #\\d]\n      [(char=? c #\\c) #\\e]\n      [(char=? c #\\\
    d) #\\f]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\f) #\\h]\n      [(char=?\
    \ c #\\g) #\\i]\n      [(char=? c #\\h) #\\j]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\j) #\\l]\n      [(char=? c #\\k) #\\m]\n      [(char=? c\
    \ #\\l) #\\n]\n      [(char=? c #\\m) #\\o]\n      [(char=? c #\\n) #\\p]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\p) #\\r]\n      [(char=? c #\\\
    q) #\\s]\n      [(char=? c #\\r) #\\t]\n      [(char=? c #\\s) #\\u]\n      [(char=?\
    \ c #\\t) #\\v]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\v) #\\x]\n\
    \      [(char=? c #\\w) #\\y]\n      [(char=? c #\\x) #\\z]\n      [(char=? c\
    \ #\\y) #\\a]\n      [(char=? c #\\z) #\\b]\n      [(char=? c #\\ ) #\\ )]\n \
    \     [else c])))\n", "  (define (letter-code c)\n    (if (char-numeric? c)\n\
    \        c\n        (char-downcase c)))\n  (map (lambda (c)\n         (define\
    \ (shift n)\n           (modulo (- n) 26))\n         (define n (+ 2 (* 2 (letter-code\
    \ c))))\n         (if (char-numeric? c)\n             c\n             (char-upcase\
    \ (integer->char (shift n)))))\n       s))\n", "  (let* ([chars (string->list\
    \ s)]\n         [new-chars (map (\u03BB (ch)\n                           (char-downcase\
    \ ch))\n                         chars)])\n    (map (\u03BB (ch)\n           (if\
    \ (not (char-alphabetic? ch))\n               ch\n               (let* ([offset\
    \ (- ch #\\a)]\n                      [new-offset (if (odd? offset)\n        \
    \                              (+ offset 9)\n                                \
    \      (+ offset 7))]\n                      [new-char (+ new-offset #\\a)])\n\
    \                 new-char)))\n         new-chars)))\n", "  (cond ((empty? s)\
    \ \"\")\n        (else\n         (string-append (string (encrypt-char (first s)))\n\
    \                        (encrypt (rest s))))))\n", "  (string-append (substring\
    \ s 2) (substring s 0 2)))\n", "  (define (translated ch)\n    (if (char-alphabetic?\
    \ ch)\n        (let* ([x (char-&gt;integer ch)]\n               [y (if (and (&lt;=\
    \ 65 x) (&lt;= x 90))\n                      (+ (- x 65) (* 2 2))\n          \
    \            (+ (- x 97) (* 2 2)))])\n          (integer-&gt;char (if (&lt; y\
    \ 26) (+ y 65) (+ y -26))))\n        ch))\n  (string-map translated s))\n", " \
    \ (do ((i 0 (+ i 1))\n       (n (string-length s) (- n 1))\n       (new \"\" (string-append\
    \ new (string-downcase (string-ref s n)))))\n      ((= i n) new)))", "  (map (lambda\
    \ (x)\n         (displayln x)\n         (if (member x '(#\\A #\\B #\\C #\\D #\\\
    E #\\F #\\G))\n             (list-ref '(\"cdefghi\" \"klmnopq\" \"stuvwxy\" \"\
    zab\")\n                       (modulo (add1 (position x (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    ))) 3))\n             (if (member x '(#\\H #\\I #\\J #\\K #\\L #\\M #\\N))\n \
    \                (list-ref '(\"i\" \"rs\" \"z\" \"cdefgh\")\n                \
    \           (modulo (add1 (position x (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    ))) 4))\n                 (if (member x '(#\\O #\\P #\\Q #\\R #\\S #\\T #\\U))\n\
    \                     (list-ref '(\"r\" \"zabcdefgh\" \"jklmnopq\" \"stuvwxy\"\
    )\n                               (modulo (add1 (position x (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    ))) 4))\n                     (if (member x '(#\\V #\\W #\\X #\\Y #\\Z))\n   \
    \                      (list-ref '(\"jklmnopq\" \"stuvwxy\" \"zabcdefgh\" \"i\"\
    )\n                                   (modulo (add1 (position x (string->list\
    \ \"abcdefghijklmnopqrstuvwxyz\"))) 4))\n                         (list-ref '(\"\
    opqrstuvwxyz\" \"abcdefghijklmn\")\n                                   (modulo\
    \ (add1 (position x (string->list \"abcdefghijklmnopqrstuvwxyz\"))) 2)))))))\n\
    \  (string->list s)))", "  (for/list ([c (in-string s)])\n    (regexp-replace\
    \ #rx\"[abcdefghijklmnopqrstuvwxyz]\" c\n                    (\u03BB (s)\n   \
    \                   (regexp-replace-all #rx\"[abcdefghijklmnopqrstuvwxyz]\" s\n\
    \                                          #\"..\")))\n    ))\n", "  (string-append\n\
    \   (apply string-append\n          (map (lambda (c)\n                 (string-append\n\
    \                  (alphabet-position c)\n                  (alphabet-position\
    \ (+ c 2))))\n               (string->list s)))))\n", "  (string-map (lambda (c)\n\
    \                (integer->char (+ c (* 2 2))))\n              s))", "  (for/fold\
    \ ([encrypted \"\"] #:result encrypted)\n    ([c (in-string s)])\n    (if (char-alphabetic?\
    \ c)\n        (string-append encrypted (char-downcase (if (&gt; (char-&gt;integer\
    \ c) 122)\n                                                   (integer-&gt;char\
    \ (- (char-&gt;integer c) 26))\n                                             \
    \      c)))\n        (string-append encrypted (char-&gt;string c)))))\n", "  (if\
    \ (string=? s \"\")\n      \"\"\n      (string-append\n       (char-&gt;string\
    \ (caar (string-&gt;list (number-&gt;string (+ 2 (* 2 (char-&gt;integer (string-ref\
    \ s 0))))))))\n       (encrypt (substring s 1)))))\n", "  (define (shift-helper\
    \ s num)\n    (cond\n      [(string=? s \"\") \"\"]\n      [(char=? (string-ref\
    \ s 0) #\\space)\n       (string-append \" \" (shift-helper (substring s 1) num))]\n\
    \      [else\n       (string-append\n        (string-append\n         (string-append\n\
    \          (string-append\n           (string-append\n            (string-append\n\
    \             (string-append\n              (string-append\n               (string-append\n\
    \                (string-append\n                 (string-append\n           \
    \       (string-append\n                   (string-append\n                  \
    \  (string-append\n                     (string-append\n                     \
    \ (string-append\n                       (string-append\n                    \
    \    (string-append\n                         (string-append\n               \
    \           (string-append\n                           (string-append\n      \
    \                      (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string", "    (map (lambda (x) \n         \
    \  (if x\n               (if (or (= x #\\A) (= x #\\a))\n                   (char-downcase\
    \ (char+ x (string->number \"24\")))\n                   (if (or (= x #\\Z) (=\
    \ x #\\z))\n                       (char-downcase (char+ x (string->number \"\
    -24\")))\n                       (char+ x (string->number \"2\"))))\n        \
    \       x))\n         s))\n", "  (for/list ([c (in-string s)])\n    (char-downcase\
    \ c)))", "  (define (add-to-char n c)\n    (integer->char (+ (char->integer c)\
    \ n)))\n  (define (rot-char n c)\n    (if (&lt; n (+ (char->integer c) n))\n \
    \       (add-to-char n c)\n        (add-to-char (- n 26) c)))\n  (string-&gt;list\
    \ s))", "  (define (encrypt-char c)\n    (define (in-range? n)\n      (and (<=\
    \ n 126)\n           (>= n 32)))\n    (define (encrypt-char' n)\n      (define\
    \ new-n (+ n (* 2 2)))\n      (if (in-range? new-n)\n          new-n\n       \
    \   (encrypt-char' (- new-n 95))))\n    (integer->char (encrypt-char' (char->integer\
    \ c))))\n  (string-map encrypt-char s))\n", "  (for/list ([c (in-string s)])\n\
    \            (let* ([i (string-index c \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")]\n    \
    \               [c (if i (string-ref \"CDEFGHIJKLMNOPQRSTUVWXYZAB\" i) c)])\n\
    \              c)))\n", "  (cond\n    [(empty? s) '()]\n    [else\n     (cons\
    \ (rotate (first s))\n           (encrypt (rest s)))]))\n", "  (string-append\
    \ (string-append (substring s 0 1)\n                                (string-append\
    \ (substring s 2 2)\n                                               (substring\
    \ s 4 2)))\n                 (string-append (substring s 6 1)\n              \
    \                  (string-append (substring s 8 2)\n                        \
    \                       (substring s 10 2)))))", "  (string-append (string-map\n\
    \                  (lambda (ch)\n                    (integer->char (+ (char->integer\
    \ ch) 4)))\n                  s)\n                 \"ab\"))\n", "  (for/fold ([r\
    \ \"\" ])\n            ([i (in-range (string-length s))])\n            (string-append\
    \ r (rotate (string-ref s i) 2))))\n", "  (let* ([alphabet (string-&gt;list \"\
    abcdefghijklmnopqrstuvwxyz\")]\n         [rotated-alphabet (rotate alphabet 2)])\n\
    \    (apply string (map (lambda (c) (list-ref rotated-alphabet \n            \
    \                                 (list-position alphabet c)))\n             \
    \          (string-&gt;list s)))))\n", "  (cond [(empty? s) s]\n        [else\
    \ (string-append (build-alphabet (alphabet-position (first s)))\n            \
    \                 (encrypt (rest s)))]))\n", "  (define (rotate-by b s)\n    (define\
    \ (rotate-char c)\n      (if (and (&lt;= #\\a c) (&lt;= c #\\z))\n          (+\
    \ c (modulo (- b) 26))\n          c))\n    (string-&gt;list (map rotate-char (string-&gt;list\
    \ s))))\n  (define (rotate-by-2 s)\n    (rotate-by (* 2 2) s))\n  (string-&gt;list\
    \ (map rotate-by-2 (string-&gt;list s))))\n", "  (local [(define (rotated)\n \
    \           (append (take (drop alphabet 2) (- (length alphabet) 2))\n       \
    \             (take alphabet 2)))\n          (define (shift-down n x)\n      \
    \      (if (= n 0) x\n                (let ([first (list-ref alphabet 0)])\n \
    \                 (append (take (drop alphabet 1) (- (length alphabet) 1))\n \
    \                         (list first)))))]\n    (map (\u03BB (c) (if (in-range\
    \ (char-&gt;integer c) 97 123)\n                    (integer-&gt;char (char-&gt;integer\
    \ c)\n                                    (rotated) (shift-down 1 (rotated)))\n\
    \                    c))\n         s)))\n", "  (define (shift-char s)\n    (if\
    \ (equal? s 'A) 'C\n      (if (equal? s 'B) 'D\n        (if (equal? s 'C) 'E\n\
    \          (if (equal? s 'D) 'F\n            (if (equal? s 'E) 'G\n          \
    \    (if (equal? s 'F) 'H\n                (if (equal? s 'G) 'I\n            \
    \      (if (equal? s 'H) 'J\n                    (if (equal? s 'I) 'K\n      \
    \                (if (equal? s 'J) 'L\n                        (if (equal? s 'K)\
    \ 'M\n                          (if (equal? s 'L) 'N\n                       \
    \     (if (equal? s 'M) 'O\n                              (if (equal? s 'N) 'P\n\
    \                                (if (equal? s 'O) 'Q\n                      \
    \            (if (equal? s 'P) 'R\n                                    (if (equal?\
    \ s 'Q) 'S\n                                      (if (equal? s 'R) 'T\n     \
    \                                   (if (equal? s 'S) 'U\n                   \
    \                       (if (equal? s 'T) 'V\n                               \
    \             (if (equal? s 'U) 'W\n                                         \
    \     (if (equal? s 'V) 'X\n                                                (if\
    \ (equal? s 'W) 'Y\n                                                  (if (equal?\
    \ s 'X) 'Z\n                                                    (if (equal? s\
    \ 'Y) 'A\n                                                      (if (equal? s\
    \ 'Z) 'B\n                                                        s\n        \
    \                                                )))))))))))))))))))))))))))))))\n\
    \    (define (shift-word word-list)\n      (cond [(empty? word-list) empty]\n\
    \            [else (cons (shift-char (first word-list))\n                    \
    \    (shift-word (rest word-list)))]))\n    (shift-word (string->list s)))", " \
    \ (define (rename-rotate s s-rotate s-number)\n    (define (rename-rotate-iter\
    \ s-new s-rotate s-number)\n      (cond ((string=? s-new \"\") s-rotate)\n   \
    \         ((char=? (string-ref s-new 0) (string-ref s-number 0))\n           \
    \  (string-append s-rotate (string-ref s-number 2)))\n            ((char=? (string-ref\
    \ s-new 0) (string-ref s-number 1))\n             (string-append s-rotate (string-ref\
    \ s-number 3)))\n            ((char=? (string-ref s-new 0) (string-ref s-number\
    \ 2))\n             (string-append s-rotate (string-ref s-number 4)))\n      \
    \      ((char=? (string-ref s-new 0) (string-ref s-number 3))\n             (string-append\
    \ s-rotate (string-ref s-number 5)))\n            ((char=? (string-ref s-new 0)\
    \ (string-ref s-number 4))\n             (string-append s-rotate (string-ref s-number\
    \ 6)))\n            ((char=? (string-ref s-new 0) (string-ref s-number 5))\n \
    \            (string-append s-rotate (string-ref s-number 7)))\n            ((char=?\
    \ (string-ref s-new 0) (string-ref s-number 6))\n             (string-append s-rotate\
    \ (string-ref s-number 8)))\n            ((char=? (string-ref s-new 0) (string-ref\
    \ s-number 7))\n             (string-append s-rotate (string-ref s-number 9)))\n\
    \            ((char=? (string-ref s-new 0) (string-ref s-number 8))\n        \
    \     (string-append s-rotate (string-ref s-number 10)))\n            ((char=?\
    \ (string-ref s-new 0) (string-ref s-number 9))\n             (string-append s-rotate\
    \ (string-ref s-number 11)))\n            ((char=? (string-ref s-new 0) (string-ref\
    \ s-number", "  (define (shift c)\n    (let ([r (- (char-downcase c) (char-downcase\
    \ #\\a))])\n      (char-upcase (+ r (* 2 2) (char-downcase #\\a)))))\n  (for/fold\
    \ ([s \"\"]) ([c (in-string s)])\n    (string-append s (if (char-alphabetic? c)\
    \ (string (shift c)) (string c)))))\n", "  (map (lambda (ch)\n         (integer->char\
    \ (+ (char->integer ch) 2)))\n       s))", "  (build-string (string-length s)\n\
    \                (lambda (i)\n                  (let ((c (string-ref s i)))\n\
    \                    (if (char-alphabetic? c)\n                        (let* ((cs\
    \ (string->list (string (char-downcase c))))\n                               (ps\
    \ (map char->integer cs))\n                               (ps-shifted (map (lambda\
    \ (x) (+ x (* 2 2))) ps))\n                               (ps-wrapped (map (lambda\
    \ (x) (modulo x 26)) ps-shifted))\n                               (cs-wrapped\
    \ (map integer->char ps-wrapped)))\n                          (string-ref (list->string\
    \ cs-wrapped) 0))\n                        c)))))\n</code>\nWhat is a better way\
    \ to write this function? Is there a simpler way to achieve the same thing?\n\n\
    \nA:\n\nThe actual encryption is easy:\n<code>(define (encrypt s)\n  (define alphabet\
    \ \"abcdefghijklmnopqrstuvwxyz\")\n  (define alphabet-length (string-length alphabet))\n\
    \  (define (search-char c)\n    (string-index alphabet (char-downcase c)))\n \
    \ (define (to-char n)\n    (string-ref alphabet n))\n  (define (encrypt-char c)\n\
    \    (let ((n (+ (search-char c) (* 2 2))))\n      (to-char (modulo n alphabet-length))))\n\
    \  (build-string (string-length s)\n                (lambda (i)\n            \
    \      (let ((c (string-ref s i)))\n                    (if (char-alphabetic?\
    \ c)\n                        (encrypt-char c)\n                        c)))))\n\
    </code>\nThe first two lines are just constants, the next two are helper functions\
    \ that can probably be replaced by ones from the standard library, the next two\
    \ are just to make the code more readable, and the actual encryption happens in\
    \ the <code>encrypt-char</code> function.\n", "  (define (helper s index)\n  \
    \  (cond ((equal? index (string-length s)) s)\n          ((char-numeric? (string-ref\
    \ s index))\n           (helper s (+ index 1)))\n          (else\n           (string-set!\
    \ s index (rotate-char (string-ref s index) (* 2 2)))\n           (helper s (+\
    \ index 1)))))\n  (helper s 0))\n", "  (define (rotate-two c)\n    (let ((alphabet\
    \ \"abcdefghijklmnopqrstuvwxyz\")\n          (alphabet (string-append alphabet\
    \ alphabet)))\n    (string-ref alphabet (+ (string-index alphabet c) 2))))\n \
    \ (map (\u03BB (c) (rotate-two c)) s))\n", "  (define alphabet '(\"a\" \"b\" \"\
    c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"\
    p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"))\n  (define encrypted-string\
    \ \"\")\n  (for ([i (in-list s)])\n    (define letter-index (find i alphabet))\n\
    \    (define encrypted-letter (list-ref alphabet (+ letter-index (- 2 2))))\n\
    \    (set! encrypted-string (string-append encrypted-string encrypted-letter)))\n\
    \  encrypted-string)\n", "  (map (lambda (c)\n         (if (char-alphabetic? c)\n\
    \             (if (char-numeric? (char-downcase c))\n                 (integer->char\
    \ (+ (char-numeric? (char-downcase c)) (modulo (char-numeric? (char-downcase c))\
    \ 8)))\n                 (integer->char (+ (char-numeric? (char-downcase c)) (modulo\
    \ (char-numeric? (char-downcase c)) 8))))\n             c))\n       (string->list\
    \ s)))", "  (string-join\n   (map (\u03BB (c)\n           (let ([d (integer->char\
    \ (+ c 2))])\n             (if (char-alphabetic? d)\n                 d\n    \
    \             (integer->char (- d 26)))))\n        (string->list s))))\n", " \
    \ (map (lambda (x)\n         (let ([c (string-&gt;char x)])\n           (if (char-&gt;integer\
    \ c)\n               (if (&gt; c #\\M)\n                   (integer-&gt;char (-\
    \ c 2))\n                   (integer-&gt;char (+ c 12)))\n               c)))\
    \ s))\n", "  (for/fold ([out \"\"]) ([c (in-string s)])\n    (string-append out\n\
    \                   (cond [(char=? c #\\a) #\\c]\n                         [(char=?\
    \ c #\\b) #\\d]\n                         [(char=? c #\\c) #\\e]\n           \
    \              [(char=? c #\\d) #\\f]\n                         [(char=? c #\\\
    e) #\\g]\n                         [(char=? c #\\f) #\\h]\n                  \
    \       [(char=? c #\\g) #\\i]\n                         [(char=? c #\\h) #\\\
    j]\n                         [(char=? c #\\i) #\\k]\n                        \
    \ [(char=? c #\\j) #\\l]\n                         [(char=? c #\\k) #\\m]\n  \
    \                       [(char=? c #\\l) #\\n]\n                         [(char=?\
    \ c #\\m) #\\o]\n                         [(char=? c #\\n) #\\p]\n           \
    \              [(char=? c #\\o) #\\q]\n                         [(char=? c #\\\
    p) #\\r]\n                         [(char=? c #\\q) #\\s]\n                  \
    \       [(char=? c #\\r) #\\t]\n                         [(char=? c #\\s) #\\\
    u]\n                         [(char=? c #\\t) #\\v]\n                        \
    \ [(char=? c #\\u) #\\w]\n                         [(char=? c #\\v) #\\x]\n  \
    \                       [(char=? c #\\w) #\\y]\n                         [(char=?\
    \ c #\\x) #\\z]\n                         [(char=? c #\\y) #\\a]\n           \
    \              [(char=? c #\\z) #\\b]\n                         [else c]))))\n",
  "  (letrec ([alphabet '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\\
    l #\\m\n                       #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\\
    w #\\x #\\y #\\z)]\n           [rotated (reverse (append (reverse (take alphabet\
    \ 8))\n                                     (drop alphabet 8)))]\n           [rotator\
    \ (lambda (alphabet)\n                      (lambda (char)\n                 \
    \       (let ([i (index char alphabet)])\n                          (if i\n  \
    \                            (list-ref rotated i)\n                          \
    \    char))))])\n    (let ([trans (rotator alphabet)])\n      (string-join (map\
    \ trans (string->list s))))))\n```\n\n```", "  (define (helper str current-char)\n\
    \    (cond\n      ((eq? current-char '\\n) (string-append str current-char))\n\
    \      ((eq? current-char '\\0) str)\n      (else (helper (string-append str \n\
    \t\t\t\t   (string-upcase (rotate-char current-char)))\n\t\t    (string-ref s\
    \ (+ 1 (string-length str)))))))\n  (helper \"\" (string-ref s 0)))\n", "  (for/list\
    \ ([c (in-string s)])\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\b) #\\d]\n      [(char=? c #\\c) #\\e]\n      [(char=? c #\\d) #\\f]\n\
    \      [(char=? c #\\e) #\\g]\n      [(char=? c #\\f) #\\h]\n      [(char=? c\
    \ #\\g) #\\i]\n      [(char=? c #\\h) #\\j]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\j) #\\l]\n      [(char=? c #\\k) #\\m]\n      [(char=? c #\\\
    l) #\\n]\n      [(char=? c #\\m) #\\o]\n      [(char=? c #\\n) #\\p]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\p) #\\r]\n      [(char=? c #\\q) #\\s]\n\
    \      [(char=? c #\\r) #\\t]\n      [(char=? c #\\s) #\\u]\n      [(char=? c\
    \ #\\t) #\\v]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\v) #\\x]\n  \
    \    [(char=? c #\\w) #\\y]\n      [(char=? c #\\x) #\\z]\n      [(char=? c #\\\
    y) #\\a]\n      [(char=? c #\\z) #\\b]\n      [else c])))\n", "  (define (rotate\
    \ n)\n    (cond\n      [(= n 0) #\"a\"]\n      [(= n 1) #\"b\"]\n      [(= n 2)\
    \ #\"c\"]\n      [(= n 3) #\"d\"]\n      [(= n 4) #\"e\"]\n      [(= n 5) #\"\
    f\"]\n      [(= n 6) #\"g\"]\n      [(= n 7) #\"h\"]\n      [(= n 8) #\"i\"]\n\
    \      [(= n 9) #\"j\"]\n      [(= n 10) #\"k\"]\n      [(= n 11) #\"l\"]\n  \
    \    [(= n 12) #\"m\"]\n      [(= n 13) #\"n\"]\n      [(= n 14) #\"o\"]\n   \
    \   [(= n 15) #\"p\"]\n      [(= n 16) #\"q\"]\n      [(= n 17) #\"r\"]\n    \
    \  [(= n 18) #\"s\"]\n      [(= n 19) #\"t\"]\n      [(= n 20) #\"u\"]\n     \
    \ [(= n 21) #\"v\"]\n      [(= n 22) #\"w\"]\n      [(= n 23) #\"x\"]\n      [(=\
    \ n 24) #\"y\"]\n      [(= n 25) #\"z\"]\n      [else (rotate (modulo n 25))]))\n\
    \  (if (empty? s)\n      \"\"\n      (rotate (string-&gt;number (string-&gt;symbol\
    \ (first s))) (encrypt (rest s)))))\n</code>\nI would like to know where I can\
    \ find the documentation for the functions such as string->number and how I am\
    \ able to chain them together.\n\n\nA:\n\nYou can find the documentation in the\
    \ next links:\n\nhttps://docs.racket-lang.org/reference/Character_.html\nhttps://docs.racket-lang.org/reference/strings.html\n\
    \nRacket has some special syntax for manipulating strings and characters, there\
    \ are many functions that are defined in Racket to be used as prefix notation,\
    \ this notation is as follows:\n<code>(string-&gt;number (string-&gt;symbol (first\
    \ s)))\n</code>\nThis notation is equivalent to", "  (string-append\n   (list-ref\
    \ (list-ref (list #\\a #\\c #\\e #\\g #\\i #\\k #\\m #\\o #\\q #\\s #\\u #\\w\
    \ #\\y) (char->integer #\\a)) 0)\n   (list-ref (list-ref (list #\\b #\\d #\\f\
    \ #\\h #\\j #\\l #\\n #\\p #\\r #\\t #\\v #\\x #\\z) (char->integer #\\b)) 0)\n\
    \   (list-ref (list-ref (list #\\c #\\e #\\g #\\i #\\k #\\m #\\o #\\q #\\s #\\\
    u #\\w #\\y #\\a) (char->integer #\\c)) 0)\n   (list-ref (list-ref (list #\\d\
    \ #\\f #\\h #\\j #\\l #\\n #\\p #\\r #\\t #\\v #\\x #\\z #\\b) (char->integer\
    \ #\\d)) 0)\n   (list-ref (list-ref (list #\\e #\\g #\\i #\\k #\\m #\\o #\\q #\\\
    s #\\u #\\w #\\y #\\a #\\c) (char->integer #\\e)) 0)\n   (list-ref (list-ref (list\
    \ #\\f #\\h #\\j #\\l #\\n #\\p #\\r #\\t #\\v #\\x #\\z #\\b #\\d) (char->integer\
    \ #\\f)) 0)\n   (list-ref (list-ref (list #\\g #\\i #\\k #\\m #\\o #\\q #\\s #\\\
    u #\\w #\\y #\\a #\\c #\\e) (char->integer #\\g)) 0)\n   (list-ref (list-ref (list\
    \ #\\h #\\j #\\l #\\n #\\p #\\r #\\t #\\v #\\x #\\z #\\b #\\d #\\f) (char->integer\
    \ #\\h)) 0)\n   (list-ref (list-ref", "  (define (double-shift i)\n    (if (&lt;\
    \ i 26)\n        (+ i (* 2 2))\n        (- (+ i (* 2 2)) 26)))\n  (map (lambda\
    \ (c)\n         (if (char-numeric? c)\n             c\n             (integer-&gt;char\
    \ (double-shift (char-&gt;integer c)))))\n       (string-&gt;list s)))\n</code>\n\
    To verify the function, we can run the following tests:\n<code>&gt; (encrypt \"\
    Hello\")", "  (let ((letters (string->list s)))\n    (map (lambda (letter)\n \
    \          (if (not (char-alphabetic? letter))\n               letter\n      \
    \         (let ((alphabet \"abcdefghijklmnopqrstuvwxyz\"))\n                 (list-ref\
    \ alphabet \n                           (modulo (+ (string-index letter alphabet)\n\
    \                                      (* 2 2))\n                            \
    \       (string-length alphabet))))))\n         letters)))\n", "  (define (move-left\
    \ n xs)\n    (append (rest (drop n xs)) (take n xs)))\n  (define alph '(a b c\
    \ d e f g h i j k l m n o p q r s t u v w x y z))\n  (cond\n    [(empty? s) empty]\n\
    \    [else (string-append\n           (cons (alph-&gt;letter\n               \
    \    (move-left (alph-&gt;posn (letter-&gt;alph (car s))) alph))\n           \
    \      (encrypt (rest s))))]))\n</code>\nThe above code works perfectly well.\n\
    However, I have been trying to write the encrypt function with <code>map</code>\
    \ instead of a recursive function.\nI wrote the following code:\n<code>#lang racket\n",
  "  (let\n    ([x (string->list s)]\n     [y (map (lambda (z) (+ z (* 2 2))) x)])\n\
    \    (list->string y)))", "  (let ([a (string->list s)])\n    (string-join (map\
    \ (\u03BB (c) (let* ([alphabet '(\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"\
    h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"\
    u\" \"v\" \"w\" \"x\" \"y\" \"z\")]\n                               [pos (list-index\
    \ alphabet c)])\n                           (cond [(= (modulo pos (length alphabet))\
    \ 0) \"b\"]\n                                 [(= (modulo pos (length alphabet))\
    \ 1) \"c\"]\n                                 [else (list-ref alphabet (+ pos\
    \ 2))])))\n              a))\n  )\n</code>\nHowever, I am receiving the following\
    \ error:\n<code>list-index: expects type &lt;list&gt; as 2nd argument, given:\
    \ '(\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"\
    m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"\
    z\"); other arguments were: \"a\"\n</code>\nThe error is occurring in the following\
    \ line:\n<code>[pos (list-index alphabet c)]\n</code>\nCan someone please help?\n\
    \n\nA:\n\nThe problem is that list-index needs a list, but you are passing a char\
    \ to it, this because your alphabet is a list of chars, not strings.\nYou can\
    \ fix this problem by just changing the alphabet to a list of strings:\n<code>(define\
    \ (encrypt s)\n  (let ([a (string-&gt;list s)])\n    (string-join (map (\u03BB\
    \ (c) (let* ([alphabet '(\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\"\
    \ \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"",
  "  (let ((a (string->list s)))\n    (list->string\n     (map (lambda (x)\n     \
    \       (if (string-contains \"aeiou\" x)\n                (string-ref \"cdefgh\"\
    \ (- x #\\a))\n                (string-ref \"abknqrstuvwxyz\" (- x #\\a))))\n\
    \          a))))\n", "  (define (swap l c1 c2)\n    (cond\n      [(char=? (car\
    \ l) c1) c2]\n      [(char=? (car l) c2) c1]\n      [else (car l)]))\n  (define\
    \ (change-alpha l)\n    (cond\n      [(= (length l) 0) '()]\n      [(= (length\
    \ l) 1) (cons (car l) '())]\n      [else (cons (swap l (car l) (cadr l))\n   \
    \                (change-alpha (cdr l)))]))\n  (define (rotate l)\n    (cond\n\
    \      [(= (length l) 0) '()]\n      [(= (length l) 1) (cons (car l) '())]\n \
    \     [else (cons (car (cdr l))\n                  (cons (car l)\n           \
    \             (rotate (cdr (cdr l)))))]))\n  (define (shift n l)\n    (cond\n\
    \      [(= n 0) l]\n      [else (shift (- n 1) (rotate l))]))\n  (define alphabet\
    \ (build-list 26 char->integer))\n  (define shifted-alpha (shift 4 alphabet))\n\
    \  (define changed-alpha (change-alpha shifted-alpha))\n  (cond\n    [(= (length\
    \ s) 0) \"\"]\n    [else (cons (list-ref changed-alpha\n                     \
    \     (list-index s char=?))\n                (encrypt (cdr s)))]))\n", "  (for/list\
    \ ([ch s])\n    (define base (char-&gt;integer #\\a))\n    (define offset (+ base\
    \ (* 2 2 (modulo (- (char-&gt;integer ch) base) 26))))\n    (integer-&gt;char\
    \ offset)))\n</code>\n", "  (define (cdr-rotate ls)\n    (cond\n      [(empty?\
    \ ls) empty]\n      [else (append (cdr ls) (list (car ls)))]))\n  (map (lambda\
    \ (c)\n         (if (char-alphabetic? c)\n             (integer->char (+ (char-&gt;integer\
    \ c) (* 2 2)))\n             c))\n       s))\n", "  (let ([s (string-upcase s)])\n\
    \    (string-map (lambda (c)\n                  (define (shift-letter c)\n   \
    \                 (define (rotate-number n)\n                      (if (&lt; n\
    \ 26)\n                          (+ n (* 2 2))\n                          (modulo\
    \ (- n 26) 26)))\n                    (define (char-&gt;number c)\n          \
    \            (char-&gt;integer c))\n                    (define (number-&gt;char\
    \ n)\n                      (integer-&gt;char n))\n                    (number-&gt;char\n\
    \                     (rotate-number\n                      (char-&gt;number c))))\n\
    \                  (if (char-alphabetic? c)\n                      (shift-letter\
    \ c)\n                      c))\n                s)))\n", "  (for/list ([c (in-string\
    \ s)])\n    (if (char-numeric? c)\n        c\n        (let* ([d (char-&gt;integer\
    \ c)]\n               [d (if (&lt; d 122) (+ d 4) (- d 22))])\n          (integer-&gt;char\
    \ d)))))\n</code>\nThe issue is that I get the following error:\n<code>function\
    \ application: expected a function after the open parenthesis, but received #&lt;syntax:eval:eval134:2&gt;\n\
    \  in: (function application #&lt;syntax:eval:eval134:2&gt;)\n</code>\nI've spent\
    \ the last hour trying to figure out what I've done wrong, but I am having a terrible\
    \ time figuring it out. Is there something obvious I am doing wrong?\n\n\nA:\n\
    \nThere is no need to use <code>for/list</code> here, you can just write it as\
    \ a regular <code>for</code> loop and return the accumulated string:\n<code>(define\
    \ (encrypt s)\n  (for ([c (in-string s)])\n    (cond [(char-numeric? c) c]\n \
    \         [else (let* ([d (char-&gt;integer c)]\n                       [d (if\
    \ (&lt; d 122) (+ d 4) (- d 22))])\n                  (integer-&gt;char d))])))\n\
    </code>\nIf you really want to use <code>for/list</code> you can, but you have\
    \ to change it to return a list of characters, because <code>for/list</code> always\
    \ returns a list, and then convert the list back to a string:\n<code>(define (encrypt\
    \ s)\n  (string-&gt;list\n   (for/list ([c (in-string s)])\n     (cond [(char-numeric?\
    \ c) c]\n           [else (let* ([d (char-&gt;integer c)]\n                  \
    \     [d (if (&lt; d 122) (+ d 4) (- d 22))])\n                  (integer-&gt;char\
    \ d))]))))\n</code>\n", "  (define (encrypt2 s)\n    (string-append (substring\
    \ s 1) (substring s 0 1)))\n  (if (equal? (string-length s) 1)\n      s\n    \
    \  (encrypt2 s)))\n</code>\n", "  (list->string (map (lambda (x)\n           \
    \            (cond\n                         ((and (<= #\\a x) (<= x #\\z)) (+\
    \ x (* 2 2)))\n                         ((and (<= #\\A x) (<= x #\\Z)) (+ x (*\
    \ 2 2)))\n                         (else x)))\n                     (string->list\
    \ s))))\n", "  (string-map (lambda (c)\n                (cond\n              \
    \    [(char=? c #\\A) #\\C]\n                  [(char=? c #\\B) #\\D]\n      \
    \            [(char=? c #\\C) #\\E]\n                  [(char=? c #\\D) #\\F]\n\
    \                  [(char=? c #\\E) #\\G]\n                  [(char=? c #\\F)\
    \ #\\H]\n                  [(char=? c #\\G) #\\I]\n                  [(char=?\
    \ c #\\H) #\\J]\n                  [(char=? c #\\I) #\\K]\n                  [(char=?\
    \ c #\\J) #\\L]\n                  [(char=? c #\\K) #\\M]\n                  [(char=?\
    \ c #\\L) #\\N]\n                  [(char=? c #\\M) #\\O]\n                  [(char=?\
    \ c #\\N) #\\P]\n                  [(char=? c #\\O) #\\Q]\n                  [(char=?\
    \ c #\\P) #\\R]\n                  [(char=? c #\\Q) #\\S]\n                  [(char=?\
    \ c #\\R) #\\T]\n                  [(char=? c #\\S) #\\U]\n                  [(char=?\
    \ c #\\T) #\\V]\n                  [(char=? c #\\U) #\\W]\n                  [(char=?\
    \ c #\\V) #\\X]\n                  [(char=? c #\\W) #\\Y]\n                  [(char=?\
    \ c #\\X) #\\Z]\n                  [(char=? c #\\Y) #\\A]\n                  [(char=?\
    \ c #\\Z) #\\B]\n                  [else c]))\n              s))\n", "   (for/fold\
    \ ([result null])\n       ([i (in-range (string-length s))])\n     (string-append\
    \ result\n                    (string\n                     (char-upcase\n   \
    \                   (if (is-letter (string-ref s i))\n                       \
    \   (+ 2 (* 2 (char->integer (string-ref s i))))\n                          (char->integer\
    \ (string-ref s i))))))))", "  (define (shift i)\n    (if (= i 0)\n        i\n\
    \        (+ (* 2 i) 2)))\n  (define (shiftLetter l)\n    (define ordL (char->integer\
    \ l))\n    (if (or (= ordL (char->integer #\\a))\n            (= ordL (char->integer\
    \ #\\A)))\n        (integer->char (+ ordL (shift (char->integer #\\z)) 1))\n \
    \       (integer->char (+ ordL (shift ordL)))))\n  (string-map shiftLetter s))\n",
  "  (define (helper s i)\n    (if (= i (string-length s))\n        '()\n        (cons\
    \ (char-downcase (string-ref s i))\n              (helper s (+ i 1)))))\n  (define\
    \ (helper2 s i)\n    (if (= i (string-length s))\n        '()\n        (cons (char-upcase\
    \ (string-ref s i))\n              (helper2 s (+ i 1)))))\n  (define (helper3\
    \ s i)\n    (if (= i (string-length s))\n        '()\n        (cons (char-upcase\
    \ (string-ref s i))\n              (helper3 s (+ i 1)))))\n  (define (helper4\
    \ s i)\n    (if (= i (string-length s))\n        '()\n        (cons (char-downcase\
    \ (string-ref s i))\n              (helper4 s (+ i 1)))))\n  (define (helper5\
    \ s i)\n    (if (= i (string-length s))\n        '()\n        (cons (char-downcase\
    \ (string-ref s i))\n              (helper5 s (+ i 1)))))\n  (define (helper6\
    \ s i)\n    (if (= i (string-length s))\n        '()\n        (cons (char-upcase\
    \ (string-ref s i))\n              (helper6 s (+ i 1)))))\n  (define (helper7\
    \ s i)\n    (if (= i (string-length s))\n        '()\n        (cons (char-upcase\
    \ (string-ref s i))\n              (helper7 s (+ i 1)))))\n  (define (helper8\
    \ s i)\n    (if (= i (string-length s))\n        '()\n        (cons (char-downcase\
    \ (string-ref s i))\n              (helper8 s (+ i 1)))))\n  (define (helper9\
    \ s i)\n    (if (= i (string-length s))\n        '()\n        (cons (char-downcase\
    \ (string-ref s i))\n              (helper9 s (+ i 1)))))\n  (define (helper10\
    \ s i)\n    (if (= i (string", "  (for/list ([c (in-string s)])\n    (cond\n \
    \     [(equal? c #\\A) #\\C]\n      [(equal? c #\\B) #\\D]\n      [(equal? c #\\\
    C) #\\E]\n      [(equal? c #\\D) #\\F]\n      [(equal? c #\\E) #\\G]\n      [(equal?\
    \ c #\\F) #\\H]\n      [(equal? c #\\G) #\\I]\n      [(equal? c #\\H) #\\J]\n\
    \      [(equal? c #\\I) #\\K]\n      [(equal? c #\\J) #\\L]\n      [(equal? c\
    \ #\\K) #\\M]\n      [(equal? c #\\L) #\\N]\n      [(equal? c #\\M) #\\O]\n  \
    \    [(equal? c #\\N) #\\P]\n      [(equal? c #\\O) #\\Q]\n      [(equal? c #\\\
    P) #\\R]\n      [(equal? c #\\Q) #\\S]\n      [(equal? c #\\R) #\\T]\n      [(equal?\
    \ c #\\S) #\\U]\n      [(equal? c #\\T) #\\V]\n      [(equal? c #\\U) #\\W]\n\
    \      [(equal? c #\\V) #\\X]\n      [(equal? c #\\W) #\\Y]\n      [(equal? c\
    \ #\\X) #\\Z]\n      [(equal? c #\\Y) #\\A]\n      [(equal? c #\\Z) #\\B]\n  \
    \    [else c])))\n", "  (string-&gt;list s))\n</code>\nI don't know how to tell\
    \ scheme to start from the second to last letter of the alphabet and go to the\
    \ next letter (such as from a to c) and then do the same for all the characters\
    \ in the list.\n\n\nA:\n\nI would recommend using the following procedure to shift\
    \ characters:\n<code>(define (shift s n)\n  (let ((c (string-&gt;char s)))\n \
    \   (if (char-alphabetic? c)\n        (if (char-downcase? c)\n            (char-&gt;string\
    \ (+ c n))\n            (string-upcase (char-&gt;string (+ c n))))\n        s)))\n\
    </code>\nThen, you could do:\n<code>(define (encrypt s)\n  (let ((chars (string-&gt;list\
    \ s)))\n    (list-&gt;string (map (lambda (c) (shift c 2)) chars))))\n</code>\n\
    This works because, in the ASCII character set, <code>'z' - 2 = 'x'</code>, and\
    \ <code>'x' + 2 = 'z'</code>. I guess that's what you mean by \"the next letter\"\
    , although you have to specify in which direction you want to shift.\n", "  (for/list\
    \ ([ch s])\n    (if (char-alphabetic? ch)\n      (if (char&lt;=? #\\a ch)\n  \
    \      (if (char&lt;=? ch #\\c)\n          (integer-&gt;char (+ (char-&gt;integer\
    \ ch) 22))\n          (integer-&gt;char (+ (char-&gt;integer ch) 2)))\n      \
    \  (if (char&lt;=? ch #\\y)\n          (integer-&gt;char (+ (char-&gt;integer\
    \ ch) 2))\n          (integer-&gt;char (+ (char-&gt;integer ch) 6))))\n      ch)))\n",
  "  (if (empty? s)\n      \"\"\n      (string-append (string-downcase (string-append\
    \ (string-ref s 0) (string-ref s 1)))\n                     (encrypt (substring\
    \ s 2)))))\n", "  (let ([shift 0])\n    (map (lambda (c)\n           (if (char=?\
    \ c #\\ )\n               c\n               (let ([x (char-&gt;integer c)])\n\
    \                 (define n (+ x (* 2 shift)))\n                 (set! shift (+\
    \ shift 2))\n                 (if (&gt; n 122)\n                     (integer-&gt;char\
    \ (+ n (- 97)))\n                     (integer-&gt;char n)))))\n         s)))\n\
    </code>\nI am trying to shift down the letter by two. So if the letter is \"a\"\
    \ then it becomes \"c\". If the letter is \"z\" then it becomes \"b\". The inputs\
    \ and outputs are as below.\n<code>(encrypt \"hello\") ; =&gt; \"jgnnq\"", " \
    \   (define (encrypt-inner s i)\n        (if (= i (string-length s))\n       \
    \     (substring s 0 i)\n            (string-append\n                (substring\
    \ s 0 i)\n                (string (char-downcase (char-rotate s i)))\n       \
    \         (encrypt-inner s (+ i 1)))))\n    (encrypt-inner s 0))\n", "  (string-append\
    \ (substring s 2) (substring s 0 2)))\n", "  (define (encode c)\n    (let ([lc\
    \ (char-downcase c)])\n      (if (char-alphabetic? lc)\n          (let ([lc (+\
    \ 2 (* 2 (char-downcase c)))])\n            (if (> lc 122)\n                (char-downcase\
    \ (- lc 26))\n                (char-downcase lc)))\n          c)))\n  (string-map\
    \ encode s))\n", "  (cond [(empty? s) empty]\n        [else (cons (second (member\
    \ (first s) (string->list \"abcdefghijklmnopqrstuvwxyz\")))\n                \
    \   (encrypt (rest s)))]))", "  (cond\n    [(empty? s) empty]\n    [else\n   \
    \  (cons (encrypt-char (first s))\n           (encrypt (rest s)))]))\n", "  (define\
    \ (shift alpha)\n    (cond ((empty? alpha) empty)\n          ((= (length alpha)\
    \ 2)\n           (append (rest alpha) (list (first alpha))))\n          (else\
    \ (append (shift (rest alpha))\n                       (list (first alpha))))))\n\
    \  (for/fold ([res empty])\n            ([elm s])\n    (define old-alpha\n   \
    \   (append (char-set->list (upper-case #\\a) (upper-case #\\z))\n           \
    \   (char-set->list (lower-case #\\a) (lower-case #\\z))))\n    (define new-alpha\
    \ (shift (shift old-alpha)))\n    (define (find alpha)\n      (cond ((empty? alpha)\
    \ empty)\n            ((char=? elm (first alpha)) (first new-alpha))\n       \
    \     (else (find (rest alpha))))))\n  (append res (list (find old-alpha))))\n\
    </code>\nI know that something is wrong in the final function <code>find</code>,\
    \ but I can't figure out what. And more important, is it possible to make this\
    \ program more elegant?\n\n\nA:\n\nHere's one way to use a named <code>let</code>\
    \ and a loop instead of <code>for/fold</code>:\n<code>(define (encrypt s)\n  (let\
    \ ([old-alpha (append (char-set-&gt;list (upper-case #\\a) (upper-case #\\z))\n\
    \                           (char-set-&gt;list (lower-case #\\a) (lower-case #\\\
    z)))])\n    (let loop ([s s] [res empty])\n      (if (empty? s)\n          res\n\
    \          (let ([old-alpha (append (rest (rest old-alpha))\n                \
    \                   (take old-alpha 2))])\n            (loop (rest s) (append\
    \ res (list (list-ref old-alpha\n                                            \
    \           (char-&gt;integer (first s)))))))))))\n</code>\nThe <code>let</code>\
    \ bindings are in scope for the whole function; the first <code>let</code> body\
    \ is actually the <code>encrypt</code> function body. The second <code>let</code",
  "  (let ((alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\")))\n    (string-join\n\
    \     (map (lambda (c)\n            (string-ref\n             alphabet\n     \
    \        (- (modulo (+ (string-ci-&gt;index (string c)) (* 2 2)) 26) 1)))\n  \
    \        (string-&gt;list s)))))\n</code>\n", "  (string-downcase s))\n", "  (define\
    \ (char-rotation ch)\n    (cond [(char=? ch #\\A) #\\C]\n          [(char=? ch\
    \ #\\B) #\\D]\n          [(char=? ch #\\C) #\\E]\n          [(char=? ch #\\D)\
    \ #\\F]\n          [(char=? ch #\\E) #\\G]\n          [(char=? ch #\\F) #\\H]\n\
    \          [(char=? ch #\\G) #\\I]\n          [(char=? ch #\\H) #\\J]\n      \
    \    [(char=? ch #\\I) #\\K]\n          [(char=? ch #\\J) #\\L]\n          [(char=?\
    \ ch #\\K) #\\M]\n          [(char=? ch #\\L) #\\N]\n          [(char=? ch #\\\
    M) #\\O]\n          [(char=? ch #\\N) #\\P]\n          [(char=? ch #\\O) #\\Q]\n\
    \          [(char=? ch #\\P) #\\R]\n          [(char=? ch #\\Q) #\\S]\n      \
    \    [(char=? ch #\\R) #\\T]\n          [(char=? ch #\\S) #\\U]\n          [(char=?\
    \ ch #\\T) #\\V]\n          [(char=? ch #\\U) #\\W]\n          [(char=? ch #\\\
    V) #\\X]\n          [(char=? ch #\\W) #\\Y]\n          [(char=? ch #\\X) #\\Z]\n\
    \          [(char=? ch #\\Y) #\\A]\n          [(char=? ch #\\Z) #\\B]\n      \
    \    [else (error \"Invalid character found\")]))\n  (string-map char-rotation\
    \ s))\n</code>\nBut, it returns:\n<code>&gt; (encrypt \"Hello\")\n\"Jgnnq\"\n\
    </code>\nI think it's because of the Unicode encoding as a char.\n\n\nA:\n\nYou\
    \ can use <code>char-&gt;integer</code> and <code>integer-&gt;char</code> to convert",
  '  (string-downcase s))', "  (string-map (lambda (char)\n              (if (char-alphabetic?\
    \ char)\n                  (if (char-downcase? char)\n                      (let\
    \ ([char-num (string-&gt;number (string char) 36)])\n                        (if\
    \ (and (&gt; char-num 10) (&lt; char-num 35))\n                            (number-&gt;string\
    \ (+ char-num 4) 36)\n                            (number-&gt;string (+ char-num\
    \ 2) 36)))\n                      (let ([char-num (string-&gt;number (string char)\
    \ 36)])\n                        (if (and (&gt; char-num 10) (&lt; char-num 35))\n\
    \                            (number-&gt;string (+ char-num 4) 36)\n         \
    \                   (number-&gt;string (+ char-num 2) 36)))))\n              \
    \  char))\n           s))", "  (define alphabet \"abcdefghijklmnopqrstuvwxyz\"\
    )\n  (define (shift l)\n    (if (empty? l) '()\n      (append (list (list-ref\
    \ alphabet (+ (string-length alphabet) (string-ref l 0) -2)))\n              (shift\
    \ (rest l)))))\n  (list->string (shift (string->list s))))\n", "  (cond\n    [(string=?\
    \ s \"\") s]\n    [else (string-append\n            (string (modulo (+ (string-ref\
    \ s 0) 26) 256))\n            (encrypt (substring s 1)))]))\n", "  (cond\n   \
    \ [(null? s) null]\n    [else (cons (get-item s (+ 2 (* 2 (first s))))\n     \
    \           (encrypt (rest s)))]))\n</code>\nThe get-item function should be an\
    \ equation list of each letter, eg\n<code>(define input '(a b c d e f g h i j\
    \ k l m n o p q r s t u v w x y z))\n</code>\nbut I don't know how to write this\
    \ into the equation. \nSo far I have \n<code>(define (get-item input item)", " \
    \ (for/list ([c (in-string s)])\n    (cond\n      [(char=? c #\\a) #\\c]\n   \
    \   [(char=? c #\\b) #\\d]\n      [(char=? c #\\c) #\\e]\n      [(char=? c #\\\
    d) #\\f]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\f) #\\h]\n      [(char=?\
    \ c #\\g) #\\i]\n      [(char=? c #\\h) #\\j]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\j) #\\l]\n      [(char=? c #\\k) #\\m]\n      [(char=? c\
    \ #\\l) #\\n]\n      [(char=? c #\\m) #\\o]\n      [(char=? c #\\n) #\\p]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\p) #\\r]\n      [(char=? c #\\\
    q) #\\s]\n      [(char=? c #\\r) #\\t]\n      [(char=? c #\\s) #\\u]\n      [(char=?\
    \ c #\\t) #\\v]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\v) #\\x]\n\
    \      [(char=? c #\\w) #\\y]\n      [(char=? c #\\x) #\\z]\n      [(char=? c\
    \ #\\y) #\\a]\n      [(char=? c #\\z) #\\b]\n      [else c])))", "  (string-copy\
    \ s))\n", "  (let ([m (make-string (string-length s))])\n    (for ([i (in-range\
    \ (string-length s))])\n      (string-set! m i (string-ref s (+ i (* 2 2)))))\n\
    \    m))", "  (map (lambda (c)\n\t (cond\n\t  ((or (char=? #\\a c) (char=? #\\\
    A c)) #\\c)\n\t  ((or (char=? #\\b c) (char=? #\\B c)) #\\d)\n\t  ((or (char=?\
    \ #\\c c) (char=? #\\C c)) #\\e)\n\t  ((or (char=? #\\d c) (char=? #\\D c)) #\\\
    f)\n\t  ((or (char=? #\\e c) (char=? #\\E c)) #\\g)\n\t  ((or (char=? #\\f c)\
    \ (char=? #\\F c)) #\\h)\n\t  ((or (char=? #\\g c) (char=? #\\G c)) #\\i)\n\t\
    \  ((or (char=? #\\h c) (char=? #\\H c)) #\\j)\n\t  ((or (char=? #\\i c) (char=?\
    \ #\\I c)) #\\k)\n\t  ((or (char=? #\\j c) (char=? #\\J c)) #\\l)\n\t  ((or (char=?\
    \ #\\k c) (char=? #\\K c)) #\\m)\n\t  ((or (char=? #\\l c) (char=? #\\L c)) #\\\
    n)\n\t  ((or (char=? #\\m c) (char=? #\\M c)) #\\o)\n\t  ((or (char=? #\\n c)\
    \ (char=? #\\N c)) #\\p)\n\t  ((or (char=? #\\o c) (char=? #\\O c)) #\\q)\n\t\
    \  ((or (char=? #\\p c) (char=? #\\P c)) #\\r)\n\t  ((or (char=? #\\q c) (char=?\
    \ #\\Q c)) #\\s)\n\t  ((or (char=? #\\r c) (char=? #\\R c)) #\\t)\n\t  ((or (char=?\
    \ #\\s c", "  (alphabet-cipher s))\n", "  (string-append\n   (string-append (substring\
    \ s 2) (substring s 0 2))\n   (string-append (substring s 4) (substring s 0 4))))",
  "  (define a (string->list \"abcdefghijklmnopqrstuvwxyz\"))\n  (define rot (-&gt;&gt;\
    \ (string-&gt;list s)\n                    (filter (\u03BB (x) (member x a)))\n\
    \                    (map (\u03BB (x) (list-ref a (modulo (+ (list-index x a)\
    \ 4) 26))))\n                    (string-join))\n  rot)\n</code>\nBut I get this\
    \ error:\n<code>list-index: expects argument of type &lt;list&gt;; given x\n</code>\n\
    What am I doing wrong?\n\n\nA:\n\nThe problem is in this line:\n<code>(define\
    \ a (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\"))\n</code>\nSince you're using\
    \ <code>string-&gt;list</code> the result is a list of characters, but <code>list-index</code>\
    \ expects a string as its second argument, so you should use this instead:\n<code>(define\
    \ a \"abcdefghijklmnopqrstuvwxyz\")\n</code>\n", "  (define (rotate lst)\n   \
    \ (cond\n      [(null? lst) '()]\n      [(= (length lst) 2) (append (rest lst)\
    \ (list (first lst)))]\n      [else (append (rotate (cdr lst)) (list (first lst)))]))\n\
    \  (define alphabet '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\\
    l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z))\n  (define\
    \ (search-replace x alpha rotated)\n    (cond\n      [(equal? x (first alpha))\
    \ (append (list (first rotated)) (search-replace x (rest alpha) (rest rotated)))]\n\
    \      [else (append (list x) (search-replace x (rest alpha) rotated))]))\n  (define\
    \ (iter xs alpha rotated)\n    (cond\n      [(null? xs) '()]\n      [else (append\
    \ (search-replace (first xs) alpha rotated) (iter (rest xs) alpha rotated))]))\n\
    \  (cond\n    [(string=? s \"\") \"\"]\n    [else (iter (string->list s) alphabet\
    \ (rotate alphabet))]))\n", "  (string-append \n   (string-upcase (substring s\
    \ 0 1))\n   (rot2 (string-downcase (substring s 1)))))\n", "  (for/list ([c (in-string\
    \ s)])\n     (let ((c (string-downcase c)))\n       (if (char-alphabetic? c)\n\
    \           (let ((n (char-&gt;integer c)))\n             (integer-&gt;char (modulo\
    \ (+ n (* 2 2)) 26)))\n           c))))\n", "  (map (lambda (char)\n         (let\
    \ ([char (string-upcase char)])\n           (cond\n             [(string=? char\
    \ \" \") \" \"]\n             [(string=? char \"A\") \"C\"]\n             [(string=?\
    \ char \"B\") \"D\"]\n             [(string=? char \"C\") \"E\"]\n           \
    \  [(string=? char \"D\") \"F\"]\n             [(string=? char \"E\") \"G\"]\n\
    \             [(string=? char \"F\") \"H\"]\n             [(string=? char \"G\"\
    ) \"I\"]\n             [(string=? char \"H\") \"J\"]\n             [(string=?\
    \ char \"I\") \"K\"]\n             [(string=? char \"J\") \"L\"]\n           \
    \  [(string=? char \"K\") \"M\"]\n             [(string=? char \"L\") \"N\"]\n\
    \             [(string=? char \"M\") \"O\"]\n             [(string=? char \"N\"\
    ) \"P\"]\n             [(string=? char \"O\") \"Q\"]\n             [(string=?\
    \ char \"P\") \"R\"]\n             [(string=? char \"Q\") \"S\"]\n           \
    \  [(string=? char \"R\") \"T\"]\n             [(string=? char \"S\") \"U\"]\n\
    \             [(string=? char \"T\") \"V\"]\n             [(string=? char \"U\"\
    ) \"W\"]\n             [(string=? char \"V\") \"X\"]\n             [(string=?\
    \ char \"W\") \"Y\"]\n             [(string=? char \"X\") \"Z\"]\n           \
    \  [(string=? char \"Y\") \"A\"]\n             [(string=? char \"Z\") \"B\"]\n\
    \             [(string-&gt;number char) char]\n             [else char])))\n \
    \      (string-&gt;list s)))\n</code>\nThis is the encrypt procedure.  When I\
    \ run this code, I get the following error:\n<code>string-&gt;number: contract\
    \ violation\n  expected: string?\n  given: #\\1\n  in: the 1st argument of\n \
    \     (-&gt; string? string?)\n  contract from: &lt;pkgs&gt;/racket/private/misc.rkt\n\
    \  blaming: &lt;pkgs&gt", "  (define (rotate cs)\n    (cond\n      [(empty? cs)\
    \ empty]\n      [(symbol=? (first cs) #\\z) (cons #\\b (rotate (rest cs)))]\n\
    \      [(symbol=? (first cs) #\\y) (cons #\\a (rotate (rest cs)))]\n      [else\
    \ (cons (first cs) (rotate (rest cs)))]))\n  (rotate (string->list s)))\n", " \
    \ (let ([s (string-&gt;list s)])\n    (list-&gt;string\n     (for/list ([c s])\n\
    \       (if (char-alphabetic? c)\n           (+ c (* 2 2))\n           c)))))\n\
    </code>\nThis gives me\n<code>&gt; (encrypt \"abcd\")\n\"cdcf\"\n</code>\nIs there\
    \ a better way to do this? \n\n\nA:\n\nUsing a list of encrypted characters makes\
    \ it easier to do encryption:\n<code>(define *encryptions*\n  (let ([alphabet\
    \ (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\")])\n    (for/list ([i (in-range\
    \ (length alphabet))])\n      (list-ref alphabet (+ i 2 2)))))\n", "  (define\
    \ (shift-down chr)\n    (integer->char (- (char->integer chr) 2)))\n  (define\
    \ (shift s)\n    (cond [(empty? s) empty]\n          [else (cons (shift-down (first\
    \ s))\n                      (shift (rest s)))]))\n  (define (shift-back chr)\n\
    \    (integer->char (+ (char->integer chr) 2)))\n  (define (shift-back s)\n  \
    \  (cond [(empty? s) empty]\n          [else (cons (shift-back (first s))\n  \
    \                    (shift-back (rest s)))]))\n  (shift-back (shift s)))\n",
  "  (for/list ([c (in-string s)])\n    (if (char-lower-case? c)\n      (modulo (+\
    \ (- c #\\a) 2) 26)\n      (+ c #\\a))))\n", "  (string-append \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \ \n                 \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n                 s))\n", "  (define (shifters ch)\n    (define base (string-&gt;char\
    \ \"a\"))\n    (define (sub1 ch)\n      (define new (+ (* 2 (- ch base)) 2))\n\
    \      (char-&gt;string (modulo new 26)))\n    (cond [(and (&gt;= ch (string-&gt;char\
    \ \"a\")) (&lt;= ch (string-&gt;char \"z\"))) (sub1 ch)]\n          [(and (&gt;=\
    \ ch (string-&gt;char \"A\")) (&lt;= ch (string-&gt;char \"Z\"))) (string-upcase\
    \ (sub1 (string-&gt;char (string-downcase (char-&gt;string ch)))))]\n        \
    \  [else (char-&gt;string ch)]))\n  (string-join (map shifters (string-&gt;list\
    \ s)) \"\"))\n", "  (let ([alphabet (list #\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\\
    h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\\
    x #\\y #\\z)])\n    (for/list ([c s])\n      (let ([idx (list-index alphabet c)]\n\
    \            [new-idx (modulo (+ idx (* 2 2)) (length alphabet))])\n        (list-ref\
    \ alphabet new-idx)))))\n</code>\nAnd I want to make a function decrypt, that\
    \ does the opposite. I'm not sure how to do this. Any help is appreciated!\n\n\
    \nA:\n\nJust do the same thing with the opposite direction. Instead of <code>+</code>\
    \ use <code>-</code> and instead of <code>new-idx</code> use <code>old-idx</code>\
    \ or something like that.\n", "  (string-map (lambda (c)\n                (if\
    \ (char-alphabetic? c)\n                    (let ([z (char-downcase c)])\n   \
    \                   (if (char=? z #\\z)\n                          #\\b\n    \
    \                      (if (char=? z #\\y)\n                              #\\\
    a\n                              (char-upcase (+ z 2)))))\n                c))\n\
    \              s))\n", "  (map (lambda (x)\n         (if (equal? (string-downcase\
    \ x) x)\n             (string-downcase (rotate-char (string->number x) 2))\n \
    \            (string-upcase (rotate-char (string->number x) 2))))\n       (string->list\
    \ s)))\n", "  (define alphabet '( #\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\\
    i #\\j #\\k #\\l #\\m\n                     #\\n #\\o #\\p #\\q #\\r #\\s #\\\
    t #\\u #\\v #\\w #\\x #\\y #\\z))\n  (define (is-in-alphabet n)\n    (cond ((empty?\
    \ alphabet) #f)\n          ((= n (first alphabet)) #t)\n          (else (is-in-alphabet\
    \ n (rest alphabet)))))\n  (define (char-position n)\n    (cond ((is-in-alphabet\
    \ n) (char-position n (rest alphabet)))\n          (else (list-ref alphabet n))))\n\
    \  (cond ((= (string-length s) 0) \"\")\n        ((is-in-alphabet (string-ref\
    \ s 0)) (cons (list-ref alphabet (+ (char-position (string-ref s 0)) 4)) (encrypt\
    \ (substring s 1))))\n        (else (cons (string-ref s 0) (encrypt (substring\
    \ s 1))))))", "  (define (convert-char c)\n    (integer->char (+ (char->integer\
    \ 'a)\n                      (% (+ (- (char->integer c)\n                    \
    \           (char->integer 'a))\n                            (if (char=? c 'z)\
    \ 2 0))\n                         26))))\n  (string-&gt;list (string-replace s\
    \ #rx\"[a-z]\" convert-char)))\n", "  (map string-upcase (map (lambda (x) (if\
    \ (or (equal? x #\\z) (equal? x #\\y))\n                                     \
    \      (if (equal? x #\\z)\n                                               #\\\
    a\n                                               #\\b)\n                    \
    \                       (char-upcase (+ x 4)))) s)))\n", "  (for/list ([ch (in-string\
    \ s)])\n    (let ([new (char (+ (char-downcase ch) 2))])\n      (if (or (&lt;=\
    \ (char-downcase ch) (char-downcase #\\y))\n              (&lt;= (char-downcase\
    \ ch) (char-downcase #\\z)))\n          new\n          #\\a))))\n", "  (for/list\
    \ ([c (in-string s)])\n    (define a (string-&gt;char (string-ref s c)))\n   \
    \ (if (string-contains? \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" (string a))\n        (string\
    \ (+ a (* 2 2)))\n        (string a))))\n</code>\nGives me a racket error:\n<code>#lang\
    \ racket", "  (define (rotate-char c n)\n    (cond [(char-alphabetic? c)\n   \
    \        (integer->char (+ (char-&gt;integer c) (* n 2)))]\n          [else c]))\n\
    \  (define (rotate c)\n    (if (char-alphabetic? c)\n        (rotate-char c 2)\n\
    \        c))\n  (string-&gt;list (list-&gt;string (map rotate (string-&gt;list\
    \ s)))))\n", "  (define alphabet \"abcdefghijklmnopqrstuvwxyz\")\n  (define new-alphabet\
    \ (rotate alphabet 2))\n  (map (lambda (c)\n         (if (char-alphabetic? c)\n\
    \             (list-ref new-alphabet (list-index (char-downcase c) alphabet))\n\
    \             c)) s))\n", "  (cond\n    [(empty? s) empty]\n    [else\n     (cons\
    \ (rotate (first s))\n           (encrypt (rest s)))]))\n", "  (string-replace\
    \ s \"a\" \"c\")\n  (string-replace s \"b\" \"d\")\n  (string-replace s \"c\"\
    \ \"e\")\n  (string-replace s \"d\" \"f\")\n  (string-replace s \"e\" \"g\")\n\
    \  (string-replace s \"f\" \"h\")\n  (string-replace s \"g\" \"i\")\n  (string-replace\
    \ s \"h\" \"j\")\n  (string-replace s \"i\" \"k\")\n  (string-replace s \"j\"\
    \ \"l\")\n  (string-replace s \"k\" \"m\")\n  (string-replace s \"l\" \"n\")\n\
    \  (string-replace s \"m\" \"o\")\n  (string-replace s \"n\" \"p\")\n  (string-replace\
    \ s \"o\" \"q\")\n  (string-replace s \"p\" \"r\")\n  (string-replace s \"q\"\
    \ \"s\")\n  (string-replace s \"r\" \"t\")\n  (string-replace s \"s\" \"u\")\n\
    \  (string-replace s \"t\" \"v\")\n  (string-replace s \"u\" \"w\")\n  (string-replace\
    \ s \"v\" \"x\")\n  (string-replace s \"w\" \"y\")\n  (string-replace s \"x\"\
    \ \"z\")\n  (string-replace s \"y\" \"a\")\n  (string-replace s \"z\" \"b\")\n\
    \  (string-replace s \"A\" \"C\")\n  (string-replace s \"B\" \"D\")\n  (string-replace\
    \ s \"C\" \"E\")\n  (string-replace s \"D\" \"F\")\n  (string-replace s \"E\"\
    \ \"G\")\n  (string-replace s \"F\" \"H\")\n  (string-replace s \"G\" \"I\")\n\
    \  (string-replace s \"H\" \"J\")\n  (string-replace s \"I\" \"K\")\n  (string-replace\
    \ s \"J\" \"L\")\n  (string-replace s \"K\" \"M\")\n  (string-replace s \"L\"\
    \ \"N\")\n  (string-replace s \"M\" \"O\")\n  (string-", "    (define (alphabet-position\
    \ s)\n        (string-ref s (- 1 (* s 2))))\n    (define (encrypt-char c)\n  \
    \      (cond\n         ((char=? c #\\a) #\\d)\n         ((char=? c #\\b) #\\e)\n\
    \         ((char=? c #\\c) #\\f)\n         ((char=? c #\\d) #\\g)\n         ((char=?\
    \ c #\\e) #\\h)\n         ((char=? c #\\f) #\\i)\n         ((char=? c #\\g) #\\\
    j)\n         ((char=? c #\\h) #\\k)\n         ((char=? c #\\i) #\\l)\n       \
    \  ((char=? c #\\j) #\\m)\n         ((char=? c #\\k) #\\n)\n         ((char=?\
    \ c #\\l) #\\o)\n         ((char=? c #\\m) #\\p)\n         ((char=? c #\\n) #\\\
    q)\n         ((char=? c #\\o) #\\r)\n         ((char=? c #\\p) #\\s)\n       \
    \  ((char=? c #\\q) #\\t)\n         ((char=? c #\\r) #\\u)\n         ((char=?\
    \ c #\\s) #\\v)\n         ((char=? c #\\t) #\\w)\n         ((char=? c #\\u) #\\\
    x)\n         ((char=? c #\\v) #\\y)\n         ((char=? c #\\w) #\\z)\n       \
    \  ((char=? c #\\x) #\\a)\n         ((char=? c #\\y) #\\b)\n         ((char=?\
    \ c #\\z) #\\c)\n         (else c)))\n    (string-join\n     (map encrypt-char\
    \ \n          (string->list s))\n     \"\"))", "  (define (rotate-char n c)\n\
    \    (if (null? c)\n        (list)\n        (cons (list-ref (list #\\a #\\b #\\\
    c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\\
    s #\\t #\\u #\\v #\\w #\\x #\\y #\\z)\n                        (+ n (string-ci-&gt;index\
    \ (string c))))\n              (rotate-char n (cdr c)))))\n  (list-&gt;string\
    \ (rotate-char (string-ci-&gt;index (string #\\a)) s)))\n</code>\nThe problem\
    \ is that if the string to be encrypted contains a lowercase letter, then it is\
    \ encrypted, but anything else is left alone. So, for example:\n<code>(encrypt\
    \ \"test\")\n</code>\nreturns vguv, as expected, but\n<code>(encrypt \"t3st\"\
    )\n</code>\nreturns v3uv and\n<code>(encrypt \"Test\")\n</code>\nreturns Vguv.\
    \ \nI've figured out what the problem is, namely that <code>string-ci-&gt;index</code>\
    \ only works on lowercase letters, but I'm not really sure how to work around\
    \ this. \nAny suggestions? \n\n\nA:\n\n<code>string-ci-&gt;index</code> only works\
    \ on lowercase characters because that's what the documentation says. You can't\
    \ make it work on uppercase characters by changing the code - if you read the\
    \ code, you'll see that it just returns <code>#f</code> for characters that aren't\
    \ lowercase.\nThe documentation for <code>string-ci-&gt;index</code> doesn't tell\
    \ you how to make it work on uppercase characters - it's just saying that you\
    \ can't. If you want it to work on uppercase characters, you'll have to add that\
    \ functionality. \n\nIf you look at the definition of <code>string-ci-&gt;index</code>,\
    \ you'll see that the Racket designers made it look like it works", "  (define\
    \ (helper str offset)\n    (if (empty? str)\n        \"\"\n        (string-append\
    \ (rotate-char (first str) offset) (helper (rest str) offset))))\n  (helper s\
    \ (- 2 (* 2 2))))\n", "  (for/list ([c (in-string s)])\n    (if (char-alphabetic?\
    \ c)\n        (let ([i (- (char-&gt;integer c) 64)])\n          (integer-&gt;char\
    \ (+ 65 (+ (- i 2) (* 2 2))))\n          )\n        c\n        )\n    )\n  )\n",
  "  (define base \"abcdefghijklmnopqrstuvwxyz\")\n  (define key (string-append (substring\
    \ base 2) (substring base 0 2)))\n  (define (exchange c)\n    (if (char-alphabetic?\
    \ c)\n        (string-ref key (string-index base (char-downcase c)))\n       \
    \ c))\n  (string-map exchange s))\n", "  (string-append (string-take s 2)\n  \
    \               (string-reverse (string-drop s 2))))\n", "  (map\n   (lambda (char)\n\
    \     (if (char&lt;=? #\\z char)\n         (if (char&lt;=? #\\y char)\n      \
    \       (- char 24)\n             (- char 23))\n         (if (char&lt;=? #\\Z\
    \ char)\n             (- char 23)\n             char)))\n   s))\n", "  (define\
    \ (helper s i)\n    (if (= i (string-length s))\n        \"\"\n        (let ([c\
    \ (string-ref s i)])\n          (cond [(char-alphabetic? c)\n                \
    \ (let ([new-char (+ c (* 2 2))])\n                   (cond [(and (>= new-char\
    \ #\\a) (<= new-char #\\z))\n                          (string-append (string\
    \ new-char)\n                                         (helper s (+ i 1)))]\n \
    \                        [(> new-char #\\z)\n                          (string-append\
    \ (string (- new-char 26))\n                                         (helper s\
    \ (+ i 1)))]\n                         [else (string-append (string new-char)\n\
    \                                              (helper s (+ i 1)))]))]\n     \
    \           [else (string-append (string c)\n                                \
    \     (helper s (+ i 1)))]))))\n  (helper s 0))\n", "  (string-map (lambda (c)\n\
    \                (if (is-letter c)\n                    (modulo (+ (alphabetic-index\
    \ c) (* 2 2))\n                            (- (alphabetic-index 'z)\n        \
    \                       (alphabetic-index 'a)))\n                    c))\n   \
    \           s))\n", "  (string-map (lambda (x) (list-ref (list-ref (string->list\
    \ '(\"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"\
    M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"\
    Z\")) (+ (* 2 2) (string-ci&gt;numeric x))) '(\"C\" \"D\" \"E\" \"F\" \"G\" \"\
    H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"\
    U\" \"V\" \"W\" \"X\" \"Y\" \"Z\" \"A\" \"B\"))) (string-&gt;list s)))\n", " \
    \ (for/list ([i (in-range (string-length s))])\n    (cond [(char=? (string-ref\
    \ s i) #\\a) #\\c]\n          [(char=? (string-ref s i) #\\b) #\\d]\n        \
    \  [(char=? (string-ref s i) #\\c) #\\e]\n          [(char=? (string-ref s i)\
    \ #\\d) #\\f]\n          [(char=? (string-ref s i) #\\e) #\\g]\n          [(char=?\
    \ (string-ref s i) #\\f) #\\h]\n          [(char=? (string-ref s i) #\\g) #\\\
    i]\n          [(char=? (string-ref s i) #\\h) #\\j]\n          [(char=? (string-ref\
    \ s i) #\\i) #\\k]\n          [(char=? (string-ref s i) #\\j) #\\l]\n        \
    \  [(char=? (string-ref s i) #\\k) #\\m]\n          [(char=? (string-ref s i)\
    \ #\\l) #\\n]\n          [(char=? (string-ref s i) #\\m) #\\o]\n          [(char=?\
    \ (string-ref s i) #\\n) #\\p]\n          [(char=? (string-ref s i) #\\o) #\\\
    q]\n          [(char=? (string-ref s i) #\\p) #\\r]\n          [(char=? (string-ref\
    \ s i) #\\q) #\\s]\n          [(char=? (string-ref s i) #\\r) #\\t]\n        \
    \  [(char=? (string-ref s i) #\\s) #\\u]\n          [(char=? (string-ref s i)\
    \ #\\t) #\\v]\n          [(char=? (string-ref s i) #\\u) #\\w]\n          [(char=?\
    \ (string-ref s i) #\\v) #\\x]\n          [(char=? (string-ref s i) #\\w) #\\\
    y]\n          [(char=? (string", "  (map (lambda (c) (rotate c 2 2)) s))\n", " \
    \ (cond [(empty? s) s]\n        [else (cond [(char=? (first s) #\\a)\n       \
    \              (cons #\\x (encrypt (rest s)))]\n                    [(char=? (first\
    \ s) #\\A)\n                     (cons #\\X (encrypt (rest s)))]\n           \
    \         [(char=? (first s) #\\b)\n                     (cons #\\y (encrypt (rest\
    \ s)))]\n                    [(char=? (first s) #\\B)\n                     (cons\
    \ #\\Y (encrypt (rest s)))]\n                    [(char=? (first s) #\\c)\n  \
    \                   (cons #\\z (encrypt (rest s)))]\n                    [(char=?\
    \ (first s) #\\C)\n                     (cons #\\Z (encrypt (rest s)))]\n    \
    \                [else (cons (+ (first s) 2) (encrypt (rest s)))])])\n", "  (map\
    \ (lambda (x)\n         (if (char-alphabetic? x)\n             (char-downcase\
    \ x)\n             x))\n       s))", "  (letrec ([alphabet (string-&gt;list \"\
    abcdefghijklmnopqrstuvwxyz\")]\n           [cypher-alphabet (list-reverse (list-ref\
    \ alphabet (* 2 2) 26))])\n    (string-&gt;list\n     (apply string-append\n \
    \           (map (curry list-ref cypher-alphabet)\n                 (map char-&gt;integer\
    \ (string-&gt;list s)))))))\n", "  (cond\n    [(empty? s) empty]\n    [else (string-append\
    \ (rotate-left s 2) (rotate-left s 4))]))\n", "  (define (helper i)\n    (cond\n\
    \      [(= i (string-length s))]\n      [else\n       (string-set! s i (mod (+\
    \ (string-ref s i) (- (string-ref s i) 1) (* 2 2)) 26))\n       (helper (+ i 1))]))\n\
    \  (helper 0)\n  s)\n", "  (local\n    [(define alphabet '(#\\a #\\b #\\c #\\\
    d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\\
    t #\\u #\\v #\\w #\\x #\\y #\\z))\n     (define encryptHelper \n       (lambda\
    \ (x)\n         (if (eq? x '())\n             '()\n             (cons ((lambda\
    \ (x) (cond [(eq? x #\\a) #\\c] [(eq? x #\\b) #\\d] [(eq? x #\\c) #\\e] [(eq?\
    \ x #\\d) #\\f] [(eq? x #\\e) #\\g] [(eq? x #\\f) #\\h] [(eq? x #\\g) #\\i] [(eq?\
    \ x #\\h) #\\j] [(eq? x #\\i) #\\k] [(eq? x #\\j) #\\l] [(eq? x #\\k) #\\m] [(eq?\
    \ x #\\l) #\\n] [(eq? x #\\m) #\\o] [(eq? x #\\n) #\\p] [(eq? x #\\o) #\\q] [(eq?\
    \ x #\\p) #\\r] [(eq? x #\\q) #\\s] [(eq? x #\\r) #\\t] [(eq? x #\\s) #\\u] [(eq?\
    \ x #\\t) #\\v] [(eq? x #\\u) #\\w] [(eq? x #\\v) #\\x] [(eq? x #\\w) #\\y] [(eq?\
    \ x #\\x) #\\z] [(eq? x #\\y) #\\a] [(eq? x #\\z) #\\b] [(eq? x #\\space) #\\\
    space] [else x])) (car x)) (encryptHelper (cdr x))))))]\n    (encryptHelper (string->list\
    \ s))))\n", "  (let ([shift-spaces 2])\n    (string-map (lambda (c) (char (+ c\
    \ (* shift-spaces 2)))) s)))\n", "  (foldr (lambda (c s)\n           (string-append\
    \ (c (modulo (- c 97) 2) \n                             (+ c 2))\n           \
    \             s)) \n         \"\" \n         (string->list s)))\n", "  (apply\
    \ string\n         (map char\n              (map add2\n                   (map\
    \ sub1\n                        (map char-&gt;integer\n                      \
    \       (string-&gt;list s)))))))\n", "  (map (lambda (x)\n         (cond\n  \
    \         [(char=? x #\\ ) x]\n           [(char=? x #\\z) #\\a]\n           [(char=?\
    \ x #\\Z) #\\A]\n           [else (char-downcase (+ 2 (char-upcase x)))]))\n \
    \      s))", "  (map symbol->string\n       (map (lambda (c)\n              (if\
    \ (alphabetic? c)\n                  (if (>= c #\\a)\n                      (+\
    \ c (* -2 2))\n                    (+ c (* -2 2) 26))\n                c))\n \
    \           (string->list s))))\n", "  (send-to-string\n   (for/fold ([str \"\"\
    ]\n              [alpha (string->list (build-list 26 add1))]\n              [alpha-1\
    \ (reverse alpha)])\n       ([c (in-string s)])\n     (cond [(char=? c #\\a)\n\
    \            (string-append str (list-ref alpha-1 25))]\n           [(char=? c\
    \ #\\A)\n            (string-append str (list-ref alpha-1 0))]\n           [(char=?\
    \ c #\\b)\n            (string-append str (list-ref alpha-1 24))]\n          \
    \ [(char=? c #\\B)\n            (string-append str (list-ref alpha-1 1))]\n  \
    \         [(char=? c #\\c)\n            (string-append str (list-ref alpha-1 23))]\n\
    \           [(char=? c #\\C)\n            (string-append str (list-ref alpha-1\
    \ 2))]\n           [(char=? c #\\d)\n            (string-append str (list-ref\
    \ alpha-1 22))]\n           [(char=? c #\\D)\n            (string-append str (list-ref\
    \ alpha-1 3))]\n           [(char=? c #\\e)\n            (string-append str (list-ref\
    \ alpha-1 21))]\n           [(char=? c #\\E)\n            (string-append str (list-ref\
    \ alpha-1 4))]\n           [(char=? c #\\f)\n            (string-append str (list-ref\
    \ alpha-1 20))]\n           [(char=? c #\\F)\n            (string-append str (list-ref\
    \ alpha-1 5))]\n           [(char=? c #\\g)\n            (string-append str (list-ref\
    \ alpha-1 19))]\n           [(char=? c #\\G)\n            (string-append str (list-ref\
    \ alpha-1 6))]\n           [(char=? c #\\h)\n            (string-append str (list-ref\
    \ alpha-1 18))]\n           [(char=? c #\\H)\n            (string-append str (list-ref\
    \ alpha-1 7))]\n           [(char=", "  (string-map\n   (lambda (c)\n     (if\
    \ (char-alpha? c)\n         (let* ((base-char (if (char-upper-case? c)\n     \
    \                          #\\A\n                               #\\a))\n     \
    \           (offset (- (char-downcase c) base-char)))\n           (char (+ base-char\
    \ (% (+ offset 4) 26))))\n         c))\n   s))\n", "  (let ([chars (string->list\
    \ s)])\n    (for/list ([c chars])\n      (let ([order (char-&gt;integer c)])\n\
    \        (integer-&gt;char (modulo (+ 2 (* 2 order)) 256))))))\n", "  (let ([s\
    \ (string-&gt;list s)])\n    (for/list ([i (in-list s)])\n      (character-&gt;integer\
    \ i))))\n", "  (define ALPHABET \"abcdefghijklmnopqrstuvwxyz\")\n  (define (pos\
    \ char)\n    (string-index ALPHABET char))\n  (define (char index)\n    (string-ref\
    \ ALPHABET index))\n  (define (mod len n)\n    (modulo n len))\n  (define (encrypt1\
    \ char)\n    (char (mod 26 (+ (pos char) 4))))\n  (string-map encrypt1 s))", " \
    \ (map\n   (lambda (x)\n     (if (or (char=? x #\\z) (char=? x #\\y))\n      \
    \   (number->char (+ 2 (- (char->integer x) 120)))\n         (number->char (+\
    \ 2 (char->integer x)))))\n   (string->list s)))\n", "  (map\n   (lambda (c)\n\
    \     (cond\n       ((char=? c #\\a) #\\c)\n       ((char=? c #\\b) #\\d)\n  \
    \     ((char=? c #\\c) #\\e)\n       ((char=? c #\\d) #\\f)\n       ((char=? c\
    \ #\\e) #\\g)\n       ((char=? c #\\f) #\\h)\n       ((char=? c #\\g) #\\i)\n\
    \       ((char=? c #\\h) #\\j)\n       ((char=? c #\\i) #\\k)\n       ((char=?\
    \ c #\\j) #\\l)\n       ((char=? c #\\k) #\\m)\n       ((char=? c #\\l) #\\n)\n\
    \       ((char=? c #\\m) #\\o)\n       ((char=? c #\\n) #\\p)\n       ((char=?\
    \ c #\\o) #\\q)\n       ((char=? c #\\p) #\\r)\n       ((char=? c #\\q) #\\s)\n\
    \       ((char=? c #\\r) #\\t)\n       ((char=? c #\\s) #\\u)\n       ((char=?\
    \ c #\\t) #\\v)\n       ((char=? c #\\u) #\\w)\n       ((char=? c #\\v) #\\x)\n\
    \       ((char=? c #\\w) #\\y)\n       ((char=? c #\\x) #\\z)\n       ((char=?\
    \ c #\\y) #\\a)\n       ((char=? c #\\z) #\\b)\n       (else c)))\n   (string->list\
    \ s)))\n", "  (string-copy (for/list ([i (in-range (string-length s))])\n    \
    \            (integer->char (+ (char-&gt;integer (string-ref s i)) (* 2 2))))))",
  "  (let ([l (string->list s)])\n    (map (lambda (x)\n           (let ([a (+ x (*\
    \ 2 2))])\n             (if (&gt; a 122) (- a 26) a)))\n         l)))\n</code>\n\
    When I type in <code>(encrypt \"abcd\")</code> the output is <code>'(99 103 107\
    \ 111)</code>. Does anyone know how to convert these numbers back to letters?\n\
    \n\nA:\n\nYou're almost there, you have a function that encrypts a letter. Now\
    \ you just need another function to decrypt the number back to a letter!\n<code>(define\
    \ (encrypt-letter a)\n  (let ([a (+ a (* 2 2))])\n    (if (&gt; a 122) (- a 26)\
    \ a)))\n", "  (string-&gt;list s))\n</code>\nAll I am given to work with is a\
    \ string input and I need to give back an encrypted string.\nThis is a little\
    \ more of an advanced question. But I have been asked to create a function called\
    \ encrypt that takes a string as an argument and returns a string encrypted with\
    \ the alphabet being rotated. The alphabet should be rotated in a manner such\
    \ that the letters shift down by two multiplied to two places. For example:\n\
    <code>(encrypt \"abc\") =&gt; \"ceg\"", "  (let ([str (string->list s)])\n   \
    \ (map (lambda (x) (rotate-letter x 2)) str)))\n", "  (string-join\n   (map (lambda\
    \ (c) (if (or (char=? c #\\z) (char=? c #\\y))\n                         (integer->char\
    \ (- (char->integer c) 24))\n                         (integer->char (+ (char->integer\
    \ c) 4))))\n        (string->list s))))\n", '  (apply string (map encrypt-char
    (string->list s))))', "  (cond ((null? s) '())\n        (else (cons\n        \
    \        (cond\n                 ((char=? (car s) #\\a) #\\c)\n              \
    \   ((char=? (car s) #\\b) #\\d)\n                 ((char=? (car s) #\\c) #\\\
    e)\n                 ((char=? (car s) #\\d) #\\f)\n                 ((char=? (car\
    \ s) #\\e) #\\g)\n                 ((char=? (car s) #\\f) #\\h)\n            \
    \     ((char=? (car s) #\\g) #\\i)\n                 ((char=? (car s) #\\h) #\\\
    j)\n                 ((char=? (car s) #\\i) #\\k)\n                 ((char=? (car\
    \ s) #\\j) #\\l)\n                 ((char=? (car s) #\\k) #\\m)\n            \
    \     ((char=? (car s) #\\l) #\\n)\n                 ((char=? (car s) #\\m) #\\\
    o)\n                 ((char=? (car s) #\\n) #\\p)\n                 ((char=? (car\
    \ s) #\\o) #\\q)\n                 ((char=? (car s) #\\p) #\\r)\n            \
    \     ((char=? (car s) #\\q) #\\s)\n                 ((char=? (car s) #\\r) #\\\
    t)\n                 ((char=? (car s) #\\s) #\\u)\n                 ((char=? (car\
    \ s) #\\t) #\\v)\n                 ((char=? (car s) #\\u) #\\w)\n            \
    \     ((char=? (car s) #\\v) #\\x)\n                 ((char=? (car s) #\\w) #\\\
    y)\n                 ((char=? (car s) #\\x) #\\z)\n                 ((char=? (car\
    \ s) #\\y) #\\a)\n                 ((char=? (car s) #\\z) #\\b)\n            \
    \     (else (car s)))\n                (encrypt (cdr s))))))\n</code>", "  (define\
    \ (helper s2 c)\n    (if (char=? c #\\z)\n        (if (char=? (string-ref s2 0)\
    \ #\\y)\n            (string-append s2 \"a\")\n            (string-append s2 \"\
    b\"))\n        (if (char=? c #\\y)\n            (string-append s2 \"z\")\n   \
    \         (string-append s2\n                           (string (char-downcase\
    \ (+ c 2)))))))\n  (string-fold (lambda (c s2) (helper s2 c)) \"\" s))\n", " \
    \ (for/list ([c (in-string s)])\n    (let ([y (string-ref (string-downcase s)\
    \ (- c 97))])\n      (if (= y 8)\n          (string-ref (string-downcase s) (-\
    \ y 2))\n        (string-ref (string-downcase s) (+ y 2))))))\n", "  (map (lambda\
    \ (c)\n         (modulo (- c 2) 26))\n       s))\n", "  (string-append (string-append\
    \ (substring s 2) (substring s 0 2)) \n                 (string-append (substring\
    \ s 4) (substring s 2 4))))", "  (define alphabet '(#\\a #\\b #\\c #\\d #\\e #\\\
    f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\\
    v #\\w #\\x #\\y #\\z))\n  (define (rotate-by-two xs) (append (cddr xs) (list\
    \ (car xs) (cadr xs))))\n  (define (find-char c)\n    (define (find-char-helper\
    \ c l)\n      (cond ((null? l) #f)\n            ((eq? c (car l)) l)\n        \
    \    (else (find-char-helper c (cdr l)))))\n    (find-char-helper c alphabet))\n\
    \  (define (is-capital? c)\n    (define (helper c l)\n      (cond ((null? l) #f)\n\
    \            ((eq? c (car l)) (cdr l))\n            (else (helper c (cdr l)))))\n\
    \    (helper c alphabet))\n  (define (shift-2 c)\n    (define (shift-2-helper\
    \ c l)\n      (cond ((null? l) #f)\n            ((eq? c (car l)) (rotate-by-two\
    \ l))\n            (else (shift-2-helper c (cdr l)))))\n    (shift-2-helper c\
    \ alphabet))\n  (define (case-letter? c)\n    (define (case-letter-helper c l1\
    \ l2)\n      (cond ((null? l1) #f)\n            ((eq? c (car l1)) (car l2))\n\
    \            (else (case-letter-helper c (cdr l1) (cdr l2)))))\n    (case-letter-helper\
    \ c alphabet (rotate-by-two alphabet)))\n  (define (shift c)\n    (define (shift-helper\
    \ c l)\n      (cond ((null? l) #f)\n            ((eq? c (car l)) (car (cdr l)))\n\
    \            (else (shift-", "  (for/list ([i (in-range (string-length s))])\n\
    \    (let* ([c (string-ref s i)]\n           [c (if (char-numeric? c) c\n    \
    \            (integer->char (+ (- (char->integer c) 96) 4)))])\n      c)))\n",
  "  (let loop ([s s] [result '()])\n    (cond [(empty? s) (reverse result)]\n   \
    \       [else (let-values ([(car cdr) (cons (char-downcase (car s)) (cdr s))])\n\
    \                   (loop cdr (cons (lookup-char car) result)))])))\n", "  (apply\
    \ string (map (\u03BB (c)\n                      (let* ([new-c (+ c (* 2 2))])\n\
    \                        (if (and (char-alphabetic? c) (> new-c #\\z))\n     \
    \                       (- new-c 26)\n                            new-c)))\n \
    \                   (string->list s))))\n", "  (define (encrypt-char c)\n    (cond\n\
    \      [(char=? c #\\A) (char-downcase #\\C)]\n      [(char=? c #\\B) (char-downcase\
    \ #\\D)]\n      [(char=? c #\\C) (char-downcase #\\E)]\n      [(char=? c #\\D)\
    \ (char-downcase #\\F)]\n      [(char=? c #\\E) (char-downcase #\\G)]\n      [(char=?\
    \ c #\\F) (char-downcase #\\H)]\n      [(char=? c #\\G) (char-downcase #\\I)]\n\
    \      [(char=? c #\\H) (char-downcase #\\J)]\n      [(char=? c #\\I) (char-downcase\
    \ #\\K)]\n      [(char=? c #\\J) (char-downcase #\\L)]\n      [(char=? c #\\K)\
    \ (char-downcase #\\M)]\n      [(char=? c #\\L) (char-downcase #\\N)]\n      [(char=?\
    \ c #\\M) (char-downcase #\\O)]\n      [(char=? c #\\N) (char-downcase #\\P)]\n\
    \      [(char=? c #\\O) (char-downcase #\\Q)]\n      [(char=? c #\\P) (char-downcase\
    \ #\\R)]\n      [(char=? c #\\Q) (char-downcase #\\S)]\n      [(char=? c #\\R)\
    \ (char-downcase #\\T)]\n      [(char=? c #\\S) (char-downcase #\\U)]\n      [(char=?\
    \ c #\\T) (char-downcase #\\V)]\n      [(char=? c #\\U) (char-downcase #\\W)]\n\
    \      [(char=? c #\\V) (char-downcase #\\X)]\n      [(char=? c #\\W) (char-downcase\
    \ #\\Y)]\n      [(char=? c #\\X) (char-downcase #\\Z)]\n      [(char=? c #\\Y)\
    \ (char-downcase #", "  (if (empty? s)\n      \"\"\n      (let ([x (char-downcase\
    \ (first s))])\n        (if (char-alphabetic? x)\n            (string-append (encrypt\
    \ (rest s))\n                           (if (char&lt;=? #\\g x)\n            \
    \                   (char-&gt;integer (char-upcase x))\n                     \
    \          (char-&gt;integer (char-upcase (char+ x 2)))))\n            (string-append\
    \ (encrypt (rest s))\n                           (char-&gt;string x))))))\n</code>\n\
    The way this is written, it doesn't care if the input is upper- or lower-case.\
    \ It's always going to output the result in uppercase.\nI'm not sure what you're\
    \ trying to do here:\n<code>(char-&gt;integer (char-upcase x))\n</code>\nYou're\
    \ taking the character and converting it to an integer. Then you're taking that\
    \ integer and converting it back to a character. But with this code, you're not\
    \ going to get the original character back. You're going to get some other character,\
    \ not the original character.\nIf you want to get the original character back,\
    \ you need to do this:\n<code>(char-&gt;integer (char-upcase (char-upcase x)))\n\
    </code>\nSo that should be the question: Why do you have to do that?\n\n<blockquote>\n\
    <p>For example:</p>\n<pre><code>&lt;code&gt;(encrypt \"The best of friends must\
    \ part\")\n&lt;/code&gt;</code></pre>\n<p>should return \"VJG CJTU GY CVYKPI FTQWR\"\
    </p>\n</blockquote>\nI'm not sure how that's supposed to work. I was expecting\n\
    <code>&gt; (encrypt \"The best of friends must part\")\n\"VJG CJTU GY CVYKPI FTQWR\"\
    \n</code>\nBut I'm getting\n<code>&gt; (encrypt \"The best of friends must part\"\
    )\n\"VJG CJTU GY CVYKPI FTQWR\"\n</code>\nNotice the", '  (map (lambda (x) (add2
    x 2 (* 2))) s))', "  (define (shift-char ch)\n    (if (char=? ch #\\z) #\\a\n\
    \        (if (char=? ch #\\y) #\\x\n            (char-downcase (char-upcase ch)))))\n\
    \  (for/fold ([result '()]) ([c (in-string s)])\n    (cons (shift-char c) result)))\n",
  "  (string-append \"s\" (string-upcase \"s\") (string-downcase \"s\")))\n", "  (for/list\
    \ ([x (in-string s)])\n    (cond\n      [(char=? x #\\a) #\\c]\n      [(char=?\
    \ x #\\b) #\\d]\n      [(char=? x #\\c) #\\e]\n      [(char=? x #\\d) #\\f]\n\
    \      [(char=? x #\\e) #\\g]\n      [(char=? x #\\f) #\\h]\n      [(char=? x\
    \ #\\g) #\\i]\n      [(char=? x #\\h) #\\j]\n      [(char=? x #\\i) #\\k]\n  \
    \    [(char=? x #\\j) #\\l]\n      [(char=? x #\\k) #\\m]\n      [(char=? x #\\\
    l) #\\n]\n      [(char=? x #\\m) #\\o]\n      [(char=? x #\\n) #\\p]\n      [(char=?\
    \ x #\\o) #\\q]\n      [(char=? x #\\p) #\\r]\n      [(char=? x #\\q) #\\s]\n\
    \      [(char=? x #\\r) #\\t]\n      [(char=? x #\\s) #\\u]\n      [(char=? x\
    \ #\\t) #\\v]\n      [(char=? x #\\u) #\\w]\n      [(char=? x #\\v) #\\x]\n  \
    \    [(char=? x #\\w) #\\y]\n      [(char=? x #\\x) #\\z]\n      [(char=? x #\\\
    y) #\\a]\n      [(char=? x #\\z) #\\b]\n      [else #\\ ])))\n</code>\n", '  (string-append
    (string-take s 2) (string-drop s 2)))', "  (let ((alphabet '(#\\a #\\b #\\c #\\\
    d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\\
    t #\\u #\\v #\\w #\\x #\\y #\\z)))\n    (map (lambda (x) (list-ref alphabet (+\
    \ x -2))) s)))\n", "  (string-append (substring s 2) (substring s 0 2)))\n", " \
    \  ;; define current char being operated on\n   (define (current c) (string-ref\
    \ s c))\n   ;; define helper function that makes the function\n   ;; that you're\
    \ going to recurse through for the char\n   (define (cond c)\n      (cond\n  \
    \       [(eq? c (string-length s)) (string)]\n         [else\n          (cond\n\
    \             [(eq? (current c) #\\a) (string #\\c (cond (+ c 1)))]\n        \
    \     [(eq? (current c) #\\b) (string #\\d (cond (+ c 1)))]\n             [(eq?\
    \ (current c) #\\c) (string #\\e (cond (+ c 1)))]\n             [(eq? (current\
    \ c) #\\d) (string #\\f (cond (+ c 1)))]\n             [(eq? (current c) #\\e)\
    \ (string #\\g (cond (+ c 1)))]\n             [(eq? (current c) #\\f) (string\
    \ #\\h (cond (+ c 1)))]\n             [(eq? (current c) #\\g) (string #\\i (cond\
    \ (+ c 1)))]\n             [(eq? (current c) #\\h) (string #\\j (cond (+ c 1)))]\n\
    \             [(eq? (current c) #\\i) (string #\\k (cond (+ c 1)))]\n        \
    \     [(eq? (current c) #\\j) (string #\\l (cond (+ c 1)))]\n             [(eq?\
    \ (current c) #\\k) (string #\\m (cond (+ c 1)))]\n             [(eq? (current\
    \ c) #\\l) (string #\\n (cond (+ c 1)))]\n             [(eq? (current c) #\\m)\
    \ (string #\\o (cond (+ c 1)))]\n             [(eq? (current c) #\\n) (string\
    \ #\\p (cond (+ c 1)))]\n             [(eq? (current c) #\\o) (string #\\q (cond\
    \ (+ c 1)))]\n             [(eq? (current c) #\\p) (string #\\r (cond (+ c 1)))]\n\
    \             [(eq? (current c) #\\q) (string #\\s (cond (+ c 1)))]\n        \
    \     [(eq", "  (define (shift n ch)\n    (integer->char (+ (- (char->integer\
    \ ch) 97) (* n 2))))\n  (let loop ([i (string-length s)] [acc '()])\n    (if (zero?\
    \ i)\n        (list->string (reverse acc))\n        (loop (- i 1) (cons (shift\
    \ i (string-ref s (- i 1))) acc)))))\n", "  (for/list ([c (in-string s)])\n  \
    \  (integer->char (modulo (+ (char->integer c)\n                             \
    \ (* 2 2))\n                           26))))", "  (list->string (map (lambda\
    \ (c)\n                       (modulo (+ c (* 2 2))\n                        \
    \       (subtract 'z 'a)))\n                     (string->list s))))\n</code>\n",
  "  (string-append (string-append (string-append (string-append (string-append\n\
    \                                                               (string-append\
    \ (string-append\n                                                           \
    \                   (string-append (string-append\n                          \
    \                                                                   (string-append\
    \ (string-append\n                                                           \
    \                                                 (string-append (string-append\n\
    \                                                                            \
    \                                               (string-append (string-append\n\
    \                                                                            \
    \                                                              (string-append\
    \ (string-append\n                                                           \
    \                                                                            \
    \                  (string-append (string-append\n                           \
    \                                                                            \
    \                                                                 (string-append\
    \ (string-append\n                                                           \
    \                                                                            \
    \                                                (string-append (string-append\n\
    \                                                                            \
    \                                                                            \
    \                                              (string-append (string-append\n\
    \                                                                            \
    \                                                                            \
    \                                                             (string-append (string-append\n\
    \                                                                            \
    \                                                                            \
    \                                                                            (string-append\
    \ (string-append\n                                                           \
    \                                                                            \
    \                                                                            \
    \                                (string-append (string-append\n             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                 (string-append (string-append\n                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                 (string-append (string-append\n                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                (string-append (string-append\n             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                              (string-append\
    \ (string-append\n                                                           \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                               (string-append (string-append\n              \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \               (string-append (string-append\n                              \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \              (string-append (string-append\n                               \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                            (string-append (string-append\n                 \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \               ", "  (for/list ([c (in-string s)])\n    (let* ([ascii (string-&gt;number\
    \ c)]\n           [rotated-ascii (modulo (+ ascii 10) 256)]\n           [new-c\
    \ (number-&gt;string rotated-ascii)])\n      new-c)))\n</code>\nThe above works\
    \ well on a string, such as <code>\"abc\"</code> but when I feed it a file it\
    \ treats the file as a string.\n<code>$ cat input.txt\nabc\n\n$ cat input.txt\
    \ | racket crypt.rkt\n\"abc\"\n</code>\nI tried using <code>call-with-input-file</code>\
    \ but I think I may have misunderstood it's use. I would like to feed the file's\
    \ contents (not the filename) to the <code>encrypt</code> function.\n<code>#lang\
    \ racket\n", "  (let ([n (string-length s)])\n    (let loop ([i 0] [l '()])\n\
    \      (if (= i n)\n          (string-join (reverse l))\n          (let ([curr\
    \ (string-ref s i)])\n            (cond\n              [(eq? curr #\\a) (loop\
    \ (+ i 1) (cons #\\c l))]\n              [(eq? curr #\\b) (loop (+ i 1) (cons\
    \ #\\d l))]\n              [(eq? curr #\\c) (loop (+ i 1) (cons #\\e l))]\n  \
    \            [(eq? curr #\\d) (loop (+ i 1) (cons #\\f l))]\n              [(eq?\
    \ curr #\\e) (loop (+ i 1) (cons #\\g l))]\n              [(eq? curr #\\f) (loop\
    \ (+ i 1) (cons #\\h l))]\n              [(eq? curr #\\g) (loop (+ i 1) (cons\
    \ #\\i l))]\n              [(eq? curr #\\h) (loop (+ i 1) (cons #\\j l))]\n  \
    \            [(eq? curr #\\i) (loop (+ i 1) (cons #\\k l))]\n              [(eq?\
    \ curr #\\j) (loop (+ i 1) (cons #\\l l))]\n              [(eq? curr #\\k) (loop\
    \ (+ i 1) (cons #\\m l))]\n              [(eq? curr #\\l) (loop (+ i 1) (cons\
    \ #\\n l))]\n              [(eq? curr #\\m) (loop (+ i 1) (cons #\\o l))]\n  \
    \            [(eq? curr #\\n) (loop (+ i 1) (cons #\\p l))]\n              [(eq?\
    \ curr #\\o) (loop (+ i 1) (cons #\\q l))]\n              [(eq? curr #\\p) (loop\
    \ (+ i 1) (cons #\\r l))]\n              [(eq? curr #\\q) (loop (+ i 1) (cons\
    \ #\\s l))]\n              [(eq? curr #\\r) (loop (+ i 1) (cons #\\t l", "  (string-map\n\
    \   (lambda (c) (rotate-letter c 2))\n   s))\n", "  (string-map\n   (lambda (c)\n\
    \     (cond\n       [(char=? c #\\a) #\\c]\n       [(char=? c #\\e) #\\g]\n  \
    \     [(char=? c #\\i) #\\k]\n       [(char=? c #\\o) #\\q]\n       [(char=? c\
    \ #\\u) #\\w]\n       [(char=? c #\\y) #\\a]\n       [(char=? c #\\A) #\\C]\n\
    \       [(char=? c #\\E) #\\G]\n       [(char=? c #\\I) #\\K]\n       [(char=?\
    \ c #\\O) #\\Q]\n       [(char=? c #\\U) #\\W]\n       [(char=? c #\\Y) #\\A]\n\
    \       [(char=? c #\\b) #\\d]\n       [(char=? c #\\f) #\\h]\n       [(char=?\
    \ c #\\j) #\\l]\n       [(char=? c #\\n) #\\r]\n       [(char=? c #\\p) #\\t]\n\
    \       [(char=? c #\\v) #\\x]\n       [(char=? c #\\z) #\\b]\n       [(char=?\
    \ c #\\B) #\\D]\n       [(char=? c #\\F) #\\H]\n       [(char=? c #\\J) #\\L]\n\
    \       [(char=? c #\\N) #\\R]\n       [(char=? c #\\P) #\\T]\n       [(char=?\
    \ c #\\V) #\\X]\n       [(char=? c #\\Z) #\\B]\n       [(char=? c #\\c) #\\e]\n\
    \       [(char=? c #\\g) #\\i]\n       [(char=? c #\\k) #\\m]\n       [(char=?\
    \ c #\\q) #\\s]\n       [(char=? c #\\w) #\\y]\n       [(char=? c #\\C) #\\E]\n\
    \       [(char=? c #\\G) #\\I]", "  (let* ([key 2]\n         [alphabet \"abcdefghijklmnopqrstuvwxyz\"\
    ]\n         [newAlphabet (str-replace alphabet key)]\n         [newString (make-string\
    \ (string-length s) #\\z)])\n    (for/fold ([i 0])\n              ([c (in-string\
    \ s)])\n      (let* ([newChar (string-ref newAlphabet (position (string-ci-&gt;symbol\
    \ c) alphabet))])\n        (string-set! newString i newChar)\n        (+ i 1)))))\n",
  "  (define (encrypt-aux s)\n    (if (empty? s)\n        \"\"\n        (let ((c (first\
    \ s)))\n          (if (= c #\\z)\n              (string-append (encrypt-aux (rest\
    \ s)) \"b\")\n              (if (= c #\\y)\n                  (string-append (encrypt-aux\
    \ (rest s)) \"a\")\n                  (string-append (encrypt-aux (rest s)) (string\
    \ (if (&gt;= c #\\a)\n                                                       \
    \             (+ c 2)\n                                                      \
    \              #\\a)))\n                  )\n              )\n          )\n  \
    \      )\n    )\n  (encrypt-aux (string-downcase s))\n  )\n", "  (map (lambda\
    \ (c) (if (char-alphabetic? c)\n                       (char-downcase\n      \
    \                  (string-ref \"cdefghijklmnopqrstuvwxyzab\"\n              \
    \                      (- (char-ci&gt;integer c) 2)))\n                      \
    \ c))\n       s))\n", "  (define (rotate i)\n    (let* ([l (string->list s)]\n\
    \           [c (string-ref s i)])\n      (if (and (&lt; i (- (string-length s)\
    \ 2))\n               (not (char=? c #\\[)))\n          (string-append (string\
    \ (char-&gt;integer c))\n                         (rotate (+ i 2)))\n        \
    \  (string (char-&gt;integer c)))))\n  (rotate 0))\n", "  (for/list ([c (in-string\
    \ s)])\n    (integer->char (+ c (* 2 2)))))\n", "  (define the-alphabet '(#\\\
    a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\\
    q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z))\n  (define (loop s i acc)\n \
    \   (cond\n      [(empty? s) (reverse acc)]\n      [(and (&lt;= 1 i) (&lt;= i\
    \ 26))\n       (loop (rest s) (+ i 1) (cons (list-ref the-alphabet (- i 2)) acc))]\n\
    \      [else (loop (rest s) (+ i 1) (cons (list-ref the-alphabet (+ i 2)) acc))]))\n\
    \  (list-&gt;string (loop s 1 '())))\n", '  (map sym->string (map rotate-by (map
    string->symbol (string->list s)))))', "  (for/list ([c (in-string s)])\n     \
    \       (cond [(alphabetic? c) (integer->char (+ (char->integer c) 4))]\n    \
    \              [else c])))\n", "  (string-append\n   (string-append\n    (string-append\
    \ (substring s 0 2) (substring s 4 6))\n    (string-append (substring s 2 4) (substring\
    \ s 6 8)))\n   (string-append\n    (string-append (substring s 8 10) (substring\
    \ s 12 14))\n    (string-append (substring s 10 12) (substring s 14 16)))))\n",
  "  (if (string=? s \"\")\n      \"\"\n      (string-append (list (expmod (char->integer\
    \ (string-ref s 0)) 2 2) )\n                     (encrypt (substring s 1)))))\n",
  "  (let ([plain-alphabet \"abcdefghijklmnopqrstuvwxyz\"]\n        [cipher-alphabet\
    \ \"cdefghijklmnopqrstuvwxyzab\"])\n    (apply string\n           (map (lambda\
    \ (x) (string-ref cipher-alphabet\n                                        (string-index\
    \ plain-alphabet x)))\n                (string->list s)))))\n", "  (define ascii-table\
    \ (build-list 128 identity))\n  (define (char-shifted c)\n    (let ([pos (char-ci-&gt;integer\
    \ c)])\n      (cond\n        [(or (= pos (char-ci-&gt;integer #\\z)) (= pos (char-ci-&gt;integer\
    \ #\\Z))) \n         (integer-&gt;char (char-ci-&gt;integer #\\b))]\n        [(or\
    \ (= pos (char-ci-&gt;integer #\\y)) (= pos (char-ci-&gt;integer #\\Y))) \n  \
    \       (integer-&gt;char (char-ci-&gt;integer #\\a))]\n        [else (let ([new-pos\
    \ (+ 2 pos)])\n                (integer-&gt;char new-pos))])))\n  (let loop ([str\
    \ s]\n             [accum #\"\"])\n    (if (empty? str)\n        accum\n     \
    \   (loop (rest str) (string-append accum (char-shifted (first str)))))))\n</code>\n\
    I want to know if there is a better way to write this function.\nThanks\n\n\n\
    A:\n\nFirst off, there's no need to build the entire ASCII table if all you want\
    \ is to be able to index into it. You can use <code>char-ci-&gt;integer</code>\
    \ directly. The following should be acceptable in the student languages (since\
    \ it uses only basic operations and recursion), but would be much clearer and\
    \ easier to reason about using some of the more advanced list operations.\n<code>(define\
    \ (encrypt str)\n  (let loop ([str str]\n             [accum '()])\n    (if (empty?\
    \ str)\n        (list-&gt;string (reverse accum))\n        (let* ([pos (char-ci-&gt;integer\
    \ (first str))]\n               [new-pos (cond\n                          [(&lt;\
    \ pos 65) pos] ; A\n                          [(&lt; pos 91) (+ pos 2)] ; B-Z\n\
    \                          [(&lt; pos 97) pos] ; a\n                         \
    \ [(&lt; pos 123) (+ pos 2)] ; b-z\n                          [else pos])]\n \
    \              [", "  (define (encrypt-rec s)\n    (if (= s \"\")\n      \"\"\n\
    \      (string-append (encrypt-char (string-ref s 0))\n                     (encrypt-rec\
    \ (substring s 1)))))\n  (define (encrypt-char c)\n    (char->string\n     (if\
    \ (= (string-ci=? c \"z\") #t)\n         (char->integer (string-ref \"y\" 0))\n\
    \         (if (= (string-ci=? c \"y\") #t)\n             (char->integer (string-ref\
    \ \"x\" 0))\n             (+ (char->integer c) 2)))))\n  (encrypt-rec s))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
