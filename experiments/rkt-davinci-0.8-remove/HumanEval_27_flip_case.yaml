name: HumanEval_27_flip_case
language: rkt
prompt: "#lang racket\n\n;; For a given string, flip lowercase characters to uppercase\
  \ and uppercase to lowercase.\n(define (flip_case string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"Hello!\"\
  ) \"hELLO!\")\n    (check-equal? (candidate \"These violent delights have violent\
  \ ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n))\n\n(test-humaneval)"
completions: ["  (string-map (lambda (c)\n\t\t(if (char-lower-case? c)\n\t\t    (char-upcase\
    \ c)\n\t\t    (char-downcase c)))\n\t      string))\n", "  (string-map (lambda\
    \ (char)\n                (case char\n                  [(a) #\\A]\n         \
    \         [(b) #\\B]\n                  [(c) #\\C]\n                  [(d) #\\\
    D]\n                  [(e) #\\E]\n                  [(f) #\\F]\n             \
    \     [(g) #\\G]\n                  [(h) #\\H]\n                  [(i) #\\I]\n\
    \                  [(j) #\\J]\n                  [(k) #\\K]\n                \
    \  [(l) #\\L]\n                  [(m) #\\M]\n                  [(n) #\\N]\n  \
    \                [(o) #\\O]\n                  [(p) #\\P]\n                  [(q)\
    \ #\\Q]\n                  [(r) #\\R]\n                  [(s) #\\S]\n        \
    \          [(t) #\\T]\n                  [(u) #\\U]\n                  [(v) #\\\
    V]\n                  [(w) #\\W]\n                  [(x) #\\X]\n             \
    \     [(y) #\\Y]\n                  [(z) #\\Z]\n                  [(A) #\\a]\n\
    \                  [(B) #\\b]\n                  [(C) #\\c]\n                \
    \  [(D) #\\d]\n                  [(E) #\\e]\n                  [(F) #\\f]\n  \
    \                [(G) #\\g]\n                  [(H) #\\h]\n                  [(I)\
    \ #\\i]\n                  [(J) #\\j]\n                  [(K) #\\k]\n        \
    \          [(L) #\\l]\n                  [(M) #\\m]\n                  [(N) #\\\
    n]\n                  [(O) #\\o]\n                  [(P) #\\p]\n             \
    \     [(Q) #\\q]\n                  [(R) #\\r]\n                  [(S) #\\s]\n\
    \                  [(T) #\\t]\n                  [(U) #\\u]\n                \
    \  [(V) #\\v]\n                  [(W) #\\w]\n                  [(X) #\\x]\n  \
    \                [(Y) #\\y]\n                  [(Z) #\\z]\n                  [else\
    \ char]))\n              string))\n", "  (map (lambda (character)\n         (cond\n\
    \           ((char-lower-case? character) (char-upcase character))\n         \
    \  ((char-upper-case? character) (char-downcase character))\n           (else\
    \ character)))\n       string))\n", "  (string-map\n   (\u03BB (c)\n     (if (char-alphabetic?\
    \ c)\n         (if (char-lower-case? c)\n             (char-upcase c)\n      \
    \       (char-downcase c))\n         c))\n   string))\n", "  (for/list ([char\
    \ (in-string string)])\n    (cond\n      [(char-lower-case? char) (char-upcase\
    \ char)]\n      [(char-upper-case? char) (char-downcase char)]\n      [else char])))\n",
  "  (string-map\n   (lambda (c)\n     (cond\n       [(char-lower-case? c) (char-upcase\
    \ c)]\n       [(char-upper-case? c) (char-downcase c)]\n       [else c]))\n  \
    \ string))\n", "  (string-map\n   (lambda (char)\n     (if (char-downcase? char)\n\
    \         (char-upcase char)\n         (char-downcase char)))\n   string))\n",
  "  (string-map char-upcase/downcase string))\n", "  (map (lambda (char)\n      \
    \   (if (char-upper-case? char)\n             (char-downcase char)\n         \
    \    (char-upcase char)))\n       string))\n", "  (string-map (lambda (char)\n\
    \                (if (char-alphabetic? char)\n                    (if (char-lower-case?\
    \ char)\n                        (char-upcase char)\n                        (char-downcase\
    \ char))\n                    char))\n              string))\n", "  (string-map\n\
    \   (lambda (c)\n     (if (char-lower-case? c)\n         (char-upcase c)\n   \
    \      (char-downcase c)))\n   string))\n", "  (string-map\n   (lambda (char)\n\
    \     (if (char-lower-case? char)\n         (char-upcase char)\n         (char-downcase\
    \ char)))\n   string))\n", "  (string-downcase string))\n", "  (for/list ([char\
    \ (in-string string)])\n    (if (char-lower-case? char)\n        (char-upcase\
    \ char)\n        (char-downcase char))))\n", "  (build-string (string-length string)\n\
    \    (lambda (i)\n      (let ((char (string-ref string i)))\n        (if (char-alphabetic?\
    \ char)\n            (if (char-upper-case? char)\n                (char-downcase\
    \ char)\n                (char-upcase char))\n            char)))))\n", "  (string-join\
    \ (map (lambda (ch) (if (char-alphabetic? ch)\n                              \
    \        (if (char-lower-case? ch)\n                                         \
    \ (char-upcase ch)\n                                          (char-downcase ch))\n\
    \                                      ch))\n                     (string->list\
    \ string))))\n", "  (string-join\n   (map\n    (lambda (c)\n      (if (char-lower-case?\
    \ c)\n          (char-upcase c)\n          (char-downcase c)))\n    (string->list\
    \ string))))\n", "  (for/list ([ch (in-string string)])\n    (if (char-lower-case?\
    \ ch)\n        (char-upcase ch)\n        (char-downcase ch))))\n</code>\nIt is\
    \ easy to use:\n<code>&gt; (flip_case \"aBcD\")\n'(\"AbCd\")\n</code>\nI want\
    \ to refactor it to a tail-recursive function. How do I do that?\n\n\nA:\n\nAs\
    \ @Soto said, the following does the trick:\n<code>#lang racket\n", "  (for/list\
    \ ([char (in-string string)])\n    (match char\n      [(or #\\a #\\b #\\c #\\\
    d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\\
    t #\\u #\\v #\\w #\\x #\\y #\\z) (string-upcase char)]\n      [(or #\\A #\\B #\\\
    C #\\D #\\E #\\F #\\G #\\H #\\I #\\J #\\K #\\L #\\M #\\N #\\O #\\P #\\Q #\\R #\\\
    S #\\T #\\U #\\V #\\W #\\X #\\Y #\\Z) (string-downcase char)]\n      [else char])))\n\
    </code>\nExpected output:\n<code>&gt; (flip_case \"Hello World!\")\n\"hELLO wORLD!\"\
    \n</code>\nProblem:\nYour example code uses the <code>string-upcase</code> and\
    \ <code>string-downcase</code> procedures to convert the characters.\n<code>;;\
    \ For a given string, flip lowercase characters to uppercase and uppercase to\
    \ lowercase.", "  (let loop ([string string]\n             [flipped \"\"])\n \
    \   (if (string-empty? string)\n        flipped\n        (if (char-lower-case?\
    \ (string-ref string 0))\n            (loop (substring string 1)\n           \
    \       (string-append flipped (string-upcase (string-ref string 0))))\n     \
    \       (loop (substring string 1)\n                  (string-append flipped (string-downcase\
    \ (string-ref string 0))))))))\n", "  (map char-upcase string))\n</code>\nFor\
    \ example,\n<code>&gt; (flip_case \"aBcD\")\n\"AbCd\"\n</code>\nI don't know how\
    \ to accomplish this in Racket. I tried to use the \"map\" function and the \"\
    char-upcase\" function, but it didn't do what I wanted. I realize that I could\
    \ do it by iterating over the string. I wonder if there is a simple and direct\
    \ way to do this in Racket without iterating over the string.\n\n\nA:\n\nYou can\
    \ pass <code>char-upcase</code> a <code>char</code> and it will return an <code>char</code>\
    \ if it is a lowercase <code>char</code>, otherwise it returns the same <code>char</code>.\
    \ So you can use it to do what you want like this:\n<code>(define (flip-case str)\n\
    \  (map (lambda (ch) (char-upcase ch)) str))\n</code>\nWith the <code>map</code>\
    \ function you apply a procedure to every element of a list, and return a list\
    \ with the result of every element. \n", "  (map (\u03BB (c)\n         (cond\n\
    \           [(char-lower-case? c) (char-upcase c)]\n           [(char-upper-case?\
    \ c) (char-downcase c)]\n           [else c]))\n       string))\n", "  (map (lambda\
    \ (c)\n         (if (char-alphabetic? c)\n             (if (char-lower-case? c)\n\
    \                 (char-upcase c)\n                 (char-downcase c))\n     \
    \        c))\n       string))\n</code>\n<code>#lang racket\n", "  (string-map\n\
    \   (lambda (ch)\n     (if (char-lower-case? ch)\n         (char-upcase ch)\n\
    \         (char-downcase ch)))\n   string))\n", "  (string-map (lambda (c) (if\
    \ (char-alphabetic? c)\n                              (if (char-lower-case? c)\n\
    \                                  (char-upcase c)\n                         \
    \         (char-downcase c))\n                              c))\n            \
    \  string))\n", "  (string-map #:char-downcase #:char-upcase string))\n", "  (string-map\n\
    \   (lambda (char)\n     (if (char-lower-case? char)\n         (char-upcase char)\n\
    \         (char-downcase char)))\n   string))\n</code>\nFor a given string, return\
    \ the number of lowercase characters.\n<code>#lang racket\n", "  (let loop ([in\
    \ string]\n             [out (make-string (string-length string))])\n    (if (null?\
    \ in)\n        out\n        (loop (cdr in)\n              (string-append (string-append\
    \ (substring out 0 (- (string-length out) 1))\n                              \
    \              (string-downcase (string-upcase (substring in 0 1))))\n       \
    \                      (substring out (- (string-length out) 1)))))))\n", "  (let\
    \ f ([string string] [acc \"\"])\n    (if (string-empty? string)\n        acc\n\
    \        (f (substring string 1)\n           (string-append acc\n            \
    \              (if (char-upcase? (string-ref string 0))\n                    \
    \          (string-downcase (string-ref string 0))\n                         \
    \     (string-upcase (string-ref string 0))))))))\n", "  (for/list ([c (in-string\
    \ string)])\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c))))\n", "  (apply string-append (map (lambda (char) (if (char-upper-case?\
    \ char) (char-downcase char) (char-upcase char))) (string->list string))))\n",
  "  (let ([length (string-length string)])\n    (for/list ([i (in-range length)])\n\
    \      (if (char-lower-case? (string-ref string i))\n          (char-upcase (string-ref\
    \ string i))\n          (char-downcase (string-ref string i))))))\n", "  (string-join\
    \ (map (lambda (c) (if (char-alphabetic? c)\n                                (if\
    \ (char-lower-case? c)\n                                    (char-upcase c)\n\
    \                                    (char-downcase c))\n                    \
    \            c))\n                    (string->list string))))\n", "  (letrec\
    \ ([iter (lambda (string)\n                  (cond\n                    [(empty?\
    \ string) '()]\n                    [(char-lower-case? (first string))\n     \
    \                (cons (char-upcase (first string)) (iter (rest string)))]\n \
    \                   [(char-upper-case? (first string))\n                     (cons\
    \ (char-downcase (first string)) (iter (rest string)))]\n                    [else\
    \ (cons (first string) (iter (rest string)))]))])\n    (iter string)))\n", " \
    \ (string-map (lambda (c) (if (char-lower-case? c) (char-upcase c) (char-downcase\
    \ c))) string))\n", "  (string-map\n   (lambda (x)\n     (if (char-lower-case?\
    \ x)\n         (char-upcase x)\n         (char-downcase x)))\n   string))\n",
  "  (string-map\n   (lambda (char)\n     (if (char-upper-case? char)\n         (char-downcase\
    \ char)\n         (char-upcase char)))\n   string))\n", "  (string-map (lambda\
    \ (char)\n                (if (char-ci=? char (char-upcase char))\n          \
    \          (char-downcase char)\n                    (char-upcase char)))\n  \
    \            string))\n", "  (string-replace string #rx\"[a-z]\" (lambda (m) (string-upcase\
    \ m)))\n  (string-replace string #rx\"[A-Z]\" (lambda (m) (string-downcase m))))\n\
    </code>\nHowever, <code>string-replace</code> doesn't seem to be a \"pure\" function.\
    \ After the first replacement, <code>string</code> is modified, so the second\
    \ replacement does nothing. How can I fix this?\n\n\nA:\n\n<code>string-replace</code>\
    \ is not a pure function. It mutates the string, so when the second <code>string-replace</code>\
    \ is performed, the string is different than when the first replacement was done.\n\
    You need to create a fresh string to be the argument to the second <code>string-replace</code>.\n\
    <code>(define (flip_case string)\n  (string-replace (string-replace string #rx\"\
    [a-z]\" (lambda (m) (string-upcase m)))\n                  #rx\"[A-Z]\" (lambda\
    \ (m) (string-downcase m))))\n</code>\nA better way to write <code>flip_case</code>\
    \ is like this, because it's a lot more readable and maintainable:\n<code>(define\
    \ (flip_case string)\n  (string-replace\n   (string-replace string #rx\"[a-z]\"\
    \ string-upcase)\n   #rx\"[A-Z]\" string-downcase))\n</code>\n", "  (cond\n  \
    \  [(empty? string) empty]\n    [(char-ci=? (first string) (first string))\n \
    \    (string-append (flip_case (rest string)) (string-downcase (string (first\
    \ string))))]\n    [else\n     (string-append (flip_case (rest string)) (string-upcase\
    \ (string (first string))))]))\n</code>\nThis works, but seems excessively cumbersome\
    \ and could easily be broken by a change in strings. In Python, I could do something\
    \ like this (though it would only handle ASCII characters):\n<code># Python 3\n\
    \ndef flip_case(string):\n    output = \"\"\n    for character in string:\n  \
    \      if character.islower():\n            output += character.upper()\n    \
    \    elif character.isupper():\n            output += character.lower()\n    \
    \    else:\n            output += character\n    return output\n</code>\nIs there\
    \ a concise way to do something like this in Racket? I suspect there must be,\
    \ but I can't find it.\n\n\nA:\n\nYou can do something like this:\n<code>(define\
    \ (flip-case s)\n  (string-map\n   (lambda (c)\n     (if (char-alphabetic? c)\n\
    \         (if (char-ci=? c c)\n             (char-downcase c)\n             (char-upcase\
    \ c))\n         c))\n   s))\n</code>\nwhich works as follows:\n<code>(flip-case\
    \ \"hello\")\n=&gt; \"HELLO\"\n", "  (define (flip c)\n    (if (char-ci=? c #\\\
    a) #\\A\n        (if (char-ci=? c #\\A) #\\a\n            c)))\n  (string-map\
    \ flip string))\n", "  (string-join\n   (map\n    (lambda (c)\n      (if (char-upcase?\
    \ c)\n          (char-downcase c)\n          (char-upcase c)))\n    (string->list\
    \ string))))\n", "  (map (\u03BB (c) (if (char-lower-case? c) (char-upcase c)\
    \ (char-downcase c)))\n       string))\n", "  (for/list ([char (in-string string)])\n\
    \    (cond [(char-lower-case? char) (char-upcase char)]\n          [(char-upper-case?\
    \ char) (char-downcase char)]\n          [else char])))\n</code>\n", "  (string-translate\
    \ string (string-map char-upcase string) (string-map char-downcase string)))\n",
  "  (let* ([characters (string->list string)]\n         [flipped (map (lambda (character)\n\
    \                         (if (char-alphabetic? character)\n                 \
    \            (if (char-lower-case? character)\n                              \
    \   (char-upcase character)\n                                 (char-downcase character))\n\
    \                             character))\n                       characters)])\n\
    \    (string-join flipped)))\n", "  (string-map\n   (lambda (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n",
  "  (regexp-replace* #rx\"[a-zA-Z]\" string\n                   (lambda (char)\n\
    \                     (string-upcase char))))\n", "  (string-map (lambda (char)\n\
    \                (if (char-lower-case? char)\n                    (char-upcase\
    \ char)\n                    (char-downcase char)))\n              string))\n",
  "  (let ([len (string-length string)])\n    (for/fold ([new_string \"\"]) ([i (in-range\
    \ len)])\n      (string-append new_string (if (char-alphabetic? (string-ref string\
    \ i))\n                                    (if (char-upper-case? (string-ref string\
    \ i))\n                                        (string-downcase (string-ref string\
    \ i))\n                                        (string-upcase (string-ref string\
    \ i)))\n                                    (string-ref string i))))))\n</code>\n\
    That seems overly complicated and verbose. I want to do something like this:\n\
    <code>#lang racket\n", "  (string-map\n   (\u03BB (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n",
  "  (map (\u03BB (c) (cond ((char-lower-case? c) (char-upcase c))\n             \
    \        ((char-upper-case? c) (char-downcase c))\n                     (else\
    \ c)))\n       string))\n", "  (map (curryr string-upcase string-downcase) string))\n\
    </code>\nThis is a little less efficient than your solution but it's more idiomatic.\
    \  You might want to read the documentation for <code>map</code> and <code>curryr</code>.\n\
    My favorite solution, however, uses pattern matching instead of higher-order functions:\n\
    <code>#lang racket\n", "  (string-map\n   (lambda (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n",
  "  (define (flip c)\n    (cond\n      ((char-upper-case? c) (char-downcase c))\n\
    \      ((char-lower-case? c) (char-upcase c))\n      (else c)))\n  (list->string\
    \ (map flip (string->list string))))\n", "  (regexp-replace* #rx\"[a-z]\" string\n\
    \      (lambda (m) (string-downcase (string-upcase (match:substring m 0))))))\n\
    </code>\nI'm familiar with Racket's <code>regexp-replace*</code> and <code>match</code>\
    \ functions, but I have no idea how to use it in this case. I thought maybe I\
    \ could use <code>string-upcase</code> or <code>string-downcase</code> in the\
    \ replacement string, but that didn't work.\nI know I could use a procedure to\
    \ check each character individually and create a string out of the flipped characters\
    \ but I want to learn about how to do it with a regular expression.\n\n\nA:\n\n\
    A simpler way is to use the <code>regexp-replace*</code> procedure as you intended,\
    \ and let the <code>replacement</code> procedure do both the upper/lowercase transformation\
    \ and return the original character:\n<code>(define (flip-case string)\n  (regexp-replace*\
    \ #rx\"[a-zA-Z]\" string\n                   (lambda (m)\n                   \
    \  (string-downcase\n                      (string-upcase (match:substring m 0))))))\n\
    </code>\n", "  (letrec ([flipper (lambda (x)\n                      (case (char-alphabetic?\
    \ x)\n                        [(#t) (if (char-lower-case? x)\n               \
    \                  (char-upcase x)\n                                 (char-downcase\
    \ x))]\n                        [(#f) x]))])\n    (string-&gt;list string)))\n\
    </code>\nI'm getting a weird error:\n<code>&gt; (flip_case \"abcd\")\nstdin::9:\
    \ char-alphabetic?: expects a character as its first argument, given: \"a\"\n\n\
    #&lt;syntax:stdin:9:2&gt;: application: not a procedure;\n expected a procedure\
    \ that can be applied to arguments\n  given: #&lt;procedure:...&gt;\n  arguments...:\n\
    \   #&lt;syntax:stdin:9:2&gt;\n</code>\nI'm still not sure how to debug this.\
    \ Any help would be appreciated.\n\n\nA:\n\nIn other languages, <code>char</code>\
    \ usually means a single character. In Racket, <code>char</code> is a string of\
    \ length one. You should be using <code>string-alphabetic?</code> instead of <code>char-alphabetic?</code>.\n",
  "  (regexp-replace* #rx\"[A-Z]\" string\n                   (lambda (k) (string-downcase\
    \ k))\n                   #:all)\n  (regexp-replace* #rx\"[a-z]\" string\n   \
    \                (lambda (k) (string-upcase k))\n                   #:all))\n",
  "  (for/list ([char (in-string string)])\n    (if (char-lower-case? char)\n    \
    \    (char-upcase char)\n        (char-downcase char))))\n", "  (string-map\n\
    \   (lambda (ch)\n     (if (char-lower-case? ch)\n         (char-upcase ch)\n\
    \         (char-downcase ch)))\n   string))\n", "  (string-map\n   (lambda (c)\n\
    \     (if (char-lower-case? c)\n         (char-upcase c)\n         (char-downcase\
    \ c)))\n   string))\n", "  (build-string (string-length string) (lambda (i)\n\
    \                                          (if (char-lower-case? (string-ref string\
    \ i))\n                                              (char-upcase (string-ref\
    \ string i))\n                                              (char-downcase (string-ref\
    \ string i))))))\n", "  (map\n   (lambda (char)\n     (cond\n       [(char-upper-case?\
    \ char) (char-downcase char)]\n       [(char-lower-case? char) (char-upcase char)]\n\
    \       [else char]))\n   string))\n", "  (define (flip-char character)\n    (if\
    \ (char-alphabetic? character)\n        (cond ((char-lower-case? character) (char-upcase\
    \ character))\n              ((char-upper-case? character) (char-downcase character)))\n\
    \        character))\n  (list->string (map flip-char (string->list string))))\n",
  "  (string-map (lambda (char)\n                (if (char-alphabetic? char)\n   \
    \                 (if (char-lower-case? char)\n                        (char-upcase\
    \ char)\n                        (char-downcase char))\n                    char))\n\
    \              string))\n", "  (string-map (lambda (c) (if (char-lower-case? c)\
    \ (char-upcase c) (char-downcase c))) string))\n", "  (string-join (map (\u03BB\
    \ (c) (if (char-alphabetic? c) (if (char-uppercase? c) (char-downcase c) (char-upcase\
    \ c)) c)) (string->list string))))\n", "  (string-map (lambda (ch)\n         \
    \       (if (char-lower-case? ch)\n                    (char-upcase ch)\n    \
    \                (char-downcase ch)))\n              string))\n", "  (string-map\n\
    \   (lambda (c)\n     (cond\n       [(char-upcase? c) (char-downcase c)]\n   \
    \    [(char-lowercase? c) (char-upcase c)]\n       [else c]))\n   string))\n</code>\n\
    I have a feeling that this could be made more concise, but I'm not sure how.\n\
    \n\nA:\n\nWell, I can't be certain what you're trying to do, but your function\
    \ will flip the case of every character in a string, even if it's already in the\
    \ other case, so the result will always be the same length as the input string.\n\
    This function is cleaner, and flips case just once:\n<code>(define (flip-case\
    \ string)\n  (let ([first-char (string-ref string 0)])\n    (string (if (char-lowercase?\
    \ first-char)\n                (char-upcase first-char)\n                (char-downcase\
    \ first-char))\n            (substring string 1))))\n</code>\n", "  (apply string-append\
    \ (map (\u03BB (c) (if (char-lower-case? c) (char-upcase c) (char-downcase c)))\
    \ string)))\n", "  (if (string=? string \"\")\n      \"\"\n      (if (char-alphabetic?\
    \ (string-ref string 0))\n          (if (char-upper-case? (string-ref string 0))\n\
    \              (string-append (string-upper-case (string-append (string-ref string\
    \ 0) \"\")) (flip_case (substring string 1)))\n              (string-append (string-lower-case\
    \ (string-append (string-ref string 0) \"\")) (flip_case (substring string 1))))\n\
    \          (string-append (string-append (string-ref string 0) \"\") (flip_case\
    \ (substring string 1))))))\n", "  (list->string (map (lambda (x)\n          \
    \             (cond ((char-alphabetic? x)\n                              (cond\
    \ ((char-lower-case? x)\n                                     (char-upcase x))\n\
    \                                    ((char-upper-case? x)\n                 \
    \                    (char-downcase x))))\n                             (else\
    \ x)))\n                     (string->list string))))\n", "  (string-map (lambda\
    \ (c) (if (char-lower-case? c) (char-upcase c) (char-downcase c))) string))\n",
  "  (string-map (lambda (c) (if (char-lower-case? c) (char-upcase c) (char-downcase\
    \ c))) string))\n", "  (map\n   (lambda (x)\n     (if (and (char-alphabetic? x)\n\
    \              (char-uppercase? x))\n         (char-downcase x)\n         (char-upcase\
    \ x)))\n   string))\n", "  (define (flip-case-iter indx result)\n    (if (= indx\
    \ (string-length string))\n        result\n        (if (char-alphabetic? (string-ref\
    \ string indx))\n            (flip-case-iter (+ indx 1)\n                    \
    \        (string-append result (if (char-lower-case? (string-ref string indx))\n\
    \                                                       (string-upcase (string-ref\
    \ string indx))\n                                                       (string-downcase\
    \ (string-ref string indx)))))\n            (flip-case-iter (+ indx 1)\n     \
    \                       (string-append result (string-ref string indx))))))\n\
    \  (flip-case-iter 0 \"\"))\n", "  (let* ([chars (string->list string)]\n    \
    \     [flipped (map\n                   (lambda (c)\n                     (cond\n\
    \                       [(char-upper-case? c) (char-downcase c)]\n           \
    \            [(char-lower-case? c) (char-upcase c)]\n                       [else\
    \ c]))\n                   chars)])\n    (list->string flipped)))\n```\n\n## Examples\n\
    \n```", "  (string-join (map string-upcase/downcase string)))\n", "  (string-map\
    \ char-upcase (string-map char-downcase string)))\n", "  (apply string-append\
    \ (map flip_case_helper (string->list string))))\n", "  (map (curry string-upcase)\
    \ string))\n", "  (define (flip-one char)\n    (if (char-lower-case? char)\n \
    \       (char-upcase char)\n        (char-downcase char)))\n  (string-map flip-one\
    \ string))\n</code>\nNow it works, but I want to use built-in functions as much\
    \ as possible. I could use the <code>char-&gt;integer</code> function to get the\
    \ Unicode representation of the character, then use <code>integer-&gt;char</code>\
    \ to convert it back. But this seems unnecessarily convoluted.\nIs there a better\
    \ way to do this?\n\n\nA:\n\nA nice solution is this one:\n<code>(define (flip-case\
    \ char)\n  (integer-&gt;char (+ char 32)))\n</code>\nIt works because the difference\
    \ between lowercase and uppercase characters is always 32.\n", "  (string-map\
    \ (\u03BB (char) (if (char-upcase? char) (char-downcase char) (char-upcase char)))\
    \ string))\n", "  (string-map (lambda (c) (if (char-ci=? c (char-upcase c)) (char-downcase\
    \ c) (char-upcase c))) string))\n", "  (string-map (lambda (x) (if (char-lower-case?\
    \ x) (char-upcase x) (char-downcase x))) string))\n</code>\n", "  (define (flip_char\
    \ char)\n    (cond ((char-lower-case? char) (char-upcase char))\n          ((char-upper-case?\
    \ char) (char-downcase char))\n          (else char)))\n  (string-map flip_char\
    \ string))\n</code>\nThis is my first time using Racket, so my code may not be\
    \ idiomatic.\n", "  (list->string (map (lambda (char)\n                      \
    \  (cond ((char-lower-case? char) (char-upcase char))\n                      \
    \        ((char-upper-case? char) (char-downcase char))\n                    \
    \          (else char)))\n                      (string->list string))))\n```\n\
    \n### Problem 5\n\nWrite a function, `(max-diff xs)`, that returns the maximum\
    \ difference between any two adjacent elements in the list `xs`. For instance,\
    \ `(max-diff '(1 3 -2 5 3))` should return `7`, because 5-3 is the maximum difference\
    \ between any two adjacent elements in the list. You can assume that `xs` has\
    \ at least two elements.\n\n```racket\n#lang racket\n", "  (string-map (lambda\
    \ (s)\n                (cond ((char-lower-case? s) (char-upcase s))\n        \
    \              ((char-upper-case? s) (char-downcase s))\n                    \
    \  (else s)))\n              string))\n", "  (string-map (lambda (char)\n    \
    \            (if (char-lower-case? char)\n                    (char-upcase char)\n\
    \                    (char-downcase char)))\n              string))\n```\n\n#####\
    \ 3.2.2.7.1\n\n```scheme\n#lang racket\n", "  (string-translate string (string-map\
    \ char-upcase string) (string-map char-downcase string)))\n", "  (define new_string\
    \ \"\")\n  (define (inner str)\n    (if (string=? str \"\")\n        new_string\n\
    \        (if (char-lower-case? (string-ref str 0))\n            (set! new_string\
    \ (string-append new_string (string-upcase (string-ref str 0))))\n           \
    \ (set! new_string (string-append new_string (string-downcase (string-ref str\
    \ 0)))))\n        (inner (substring str 1))))\n  (inner string))\n", "  (map\n\
    \   (lambda (c)\n     (if (char-lower-case? c)\n         (char-upcase c)\n   \
    \      (char-downcase c)))\n   string))\n", "  (define (flip-char ch)\n    (cond\n\
    \      [(char-lower-case? ch) (char-upcase ch)]\n      [(char-upper-case? ch)\
    \ (char-downcase ch)]\n      [else ch]))\n  (string-&gt;list string))\n", "  (string-map\n\
    \   (\u03BB (ch)\n     (if (char-lower-case? ch)\n         (char-upcase ch)\n\
    \         (char-downcase ch)))\n   string))\n", "  (string-map (lambda (c)\n \
    \               (if (char-alphabetic? c)\n                    (if (char-lower-case?\
    \ c)\n                        (char-upcase c)\n                        (char-downcase\
    \ c))\n                    c))\n              string))\n", "  (map char-upcase/downcase\
    \ string))\n", "  (string-map (\u03BB (s)\n                (cond ((char-alphabetic?\
    \ s)\n                       (if (char-lower-case? s)\n                      \
    \     (char-upcase s)\n                           (char-downcase s)))\n      \
    \                (else s)))\n              string))\n</code>\n\n<code>#lang racket\n",
  "  (string-append (map (lambda (ch) (if (char-lower-case? ch) (char-upcase ch) (char-downcase\
    \ ch))) string)))\n", "  (string-map \n   (lambda (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n\
    ```\n\n```\n> (flip_case \"Hi There.\")\n\"hI tHERE.\"\n```\n\n## 7 Find the largest\
    \ number in a list\n```\n#lang racket\n", "  (map string-upcase string))\n", " \
    \ (define (flip x)\n    (if (char-upcase? x)\n        (char-downcase x)\n    \
    \    (char-upcase x)))\n  (string-map flip string))\n", "  (string-join (map\n\
    \                (lambda (c)\n                  (if (char-lower-case? c)\n   \
    \                   (char-upcase c)\n                      (char-downcase c)))\n\
    \                (string->list string))))\n", "  (define (is_letter? char)\n \
    \   (or (char-alphabetic? char) (char-numeric? char)))\n  (define (flip-letter\
    \ char)\n    (if (char-alphabetic? char)\n        (if (char-lower-case? char)\n\
    \            (char-upcase char)\n            (char-downcase char))\n        char))\n\
    \  (string-map flip-letter string))\n", "  (apply string-append (map (match-lambda\n\
    \                              [('#\\A) #\\a]\n                              [('#\\\
    B) #\\b]\n                              [('#\\C) #\\c]\n                     \
    \         [('#\\D) #\\d]\n                              [('#\\E) #\\e]\n     \
    \                         [('#\\F) #\\f]\n                              [('#\\\
    G) #\\g]\n                              [('#\\H) #\\h]\n                     \
    \         [('#\\I) #\\i]\n                              [('#\\J) #\\j]\n     \
    \                         [('#\\K) #\\k]\n                              [('#\\\
    L) #\\l]\n                              [('#\\M) #\\m]\n                     \
    \         [('#\\N) #\\n]\n                              [('#\\O) #\\o]\n     \
    \                         [('#\\P) #\\p]\n                              [('#\\\
    Q) #\\q]\n                              [('#\\R) #\\r]\n                     \
    \         [('#\\S) #\\s]\n                              [('#\\T) #\\t]\n     \
    \                         [('#\\U) #\\u]\n                              [('#\\\
    V) #\\v]\n                              [('#\\W) #\\w]\n                     \
    \         [('#\\X) #\\x]\n                              [('#\\Y) #\\y]\n     \
    \                         [('#\\Z) #\\z]\n                              [('#\\\
    a) #\\A]\n                              [('#\\b) #\\B]\n                     \
    \         [('#\\c) #\\C]\n                              [('#\\d) #\\D]\n     \
    \                         [('#\\e) #\\E]\n                              [('#\\\
    f) #\\F]\n                              [('#\\g) #\\G]\n                     \
    \         [('#\\h) #\\H]\n                              [('#\\i) #\\I]\n     \
    \                         [('#\\j) #\\J]\n                              [('#\\\
    k) #\\K]\n                              [('#\\l) #\\L]\n                     \
    \         [('", "  (define (flip-char c)\n    (if (char-lower-case? c)\n     \
    \   (char-upcase c)\n        (char-downcase c)))\n  (list->string (map flip-char\
    \ (string->list string))))\n", "  (for/list ([letter (in-string string)])\n  \
    \  (if (char-lower-case? letter)\n        (char-upcase letter)\n        (char-downcase\
    \ letter))))\n", "  (string-map\n   (lambda (c)\n     (cond\n       [(char-lower-case?\
    \ c) (char-upcase c)]\n       [(char-upper-case? c) (char-downcase c)]\n     \
    \  [else c]))\n   string))\n", "  (string-map\n   (\u03BB (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n\
    ```\n\n```racket\n#lang racket\n", "  (string-map\n   (lambda (char)\n     (cond\n\
    \       [(char-lower-case? char) (char-upcase char)]\n       [(char-upper-case?\
    \ char) (char-downcase char)]\n       [else char]))\n   string))\n", "  (string-map\
    \ (lambda (c) (if (char-lower-case? c) (char-upcase c) (char-downcase c))) string))\n",
  "  (regexp-replace* #rx\"[a-z]\" string\n                   (lambda (a) (string-append\
    \ (string-upcase a) (string-downcase a)))))\n", '  (apply string-append (map (lambda
    (c) (if (char-lower-case? c) (char-upcase c) (char-downcase c))) string)))', " \
    \ (string-map\n   (\u03BB (c)\n     (if (char-lower-case? c)\n         (char-upcase\
    \ c)\n         (char-downcase c)))\n   string))\n", "  (string-map\n   (lambda\
    \ (c)\n     (if (char-lower-case? c)\n         (char-upcase c)\n         (char-downcase\
    \ c)))\n   string))\n", "  (map (lambda (char)\n         (if (char-alphabetic?\
    \ char)\n             (if (char-lower-case? char)\n                 (char-upcase\
    \ char)\n                 (char-downcase char))\n             char))\n       string))\n",
  "  (string-map\n   (\u03BB (c)\n     (if (char-upcase? c)\n         (char-downcase\
    \ c)\n         (char-upcase c)))\n   string))\n", "  (string-map (lambda (char)\n\
    \t\t(if (char-lower-case? char)\n\t\t    (char-upcase char)\n\t\t    (char-downcase\
    \ char)))\n\t      string))\n", "  (for/string ([c (in-string string)])\n    (if\
    \ (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c))))\n\
    </code>\nI can't figure out how to use <code>string-upcase</code> and <code>string-downcase</code>\
    \ in this case.\n\n\nA:\n\nYou can use <code>string-upcase</code> and <code>string-downcase</code>,\
    \ but you'll need to flip the <code>cond</code> around. Here's a sample:\n<code>(define\
    \ (flip-case s)\n  (cond\n    [(char-alphabetic? (string-ref s 0))\n     (string-downcase\
    \ s)]\n    [else\n     (string-upcase s)]))\n</code>\nI also added a <code>cond</code>\
    \ to handle the first character, but you can probably omit that, too.\n", "  (string-downcase\
    \ (string-upcase string)))\n", "  (string-join (map (\u03BB (c)\n            \
    \          (cond [(char-lower-case? c) (char-upcase c)]\n                    \
    \        [(char-upper-case? c) (char-downcase c)]\n                          \
    \  [else c]))\n                    (string->list string))))\n", "  (if (null?\
    \ string)\n      \"\"\n      (string-append\n       (if (char-lower-case? (car\
    \ string))\n           (string-upcase (string (car string)))\n           (string-downcase\
    \ (string (car string))))\n       (flip_case (cdr string)))))", "  (string-upcase\
    \ (string-downcase string)))\n", "  (string-map\n   (lambda (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n",
  "  (apply string-append (map (\u03BB (x) (if (char-ci&gt;=? x #\\a) (char-upcase\
    \ x) (char-downcase x))) string)))\n</code>\nOne of the caveats of string-append\
    \ is that it only takes a list of strings as input, thus the use of map.\nIs there\
    \ a better way?\n\n\nA:\n\nHere's a solution that uses <code>fold</code> instead\
    \ of <code>map</code>:\n<code>(define (flip-case s)\n  (foldr\n   (lambda (c s)\n\
    \     (if (char-ci&gt;=? c #\\a)\n         (string-append (string (char-upcase\
    \ c)) s)\n         (string-append (string (char-downcase c)) s)))\n   \"\"\n \
    \  s))\n</code>\n", "  (flip_case_helper string))\n", "  (string-map\n   (lambda\
    \ (char)\n     (cond\n       ((char-alphabetic? char)\n        (if (char-lower-case?\
    \ char)\n            (char-upcase char)\n            (char-downcase char)))\n\
    \       (else char)))\n   string))\n", "  (string-map\n   (lambda (x)\n     (if\
    \ (char-numeric? x)\n         x\n         (if (char-upper-case? x)\n         \
    \    (char-downcase x)\n             (char-upcase x))))\n   string))\n", "  (string-map\n\
    \   (lambda (char)\n     (if (char-upcase? char)\n         (char-downcase char)\n\
    \         (char-upcase char)))\n   string))\n", "  (string-map (\u03BB (ch) (if\
    \ (char-lower-case? ch) (char-upcase ch) (char-downcase ch))) string))\n", " \
    \ (regexp-replace* #rx\"[a-z]\" string #:replace (string-downcase (string-upcase\
    \ (match:substring (regexp-match #rx\"[a-z]\" string))))))\n", "  (define (flip_char\
    \ char)\n    (if (char-alphabetic? char)\n        (if (char-lower-case? char)\n\
    \            (char-upcase char)\n            (char-downcase char))\n        char))\n\
    \  (map flip_char string))\n</code>\n", "  (apply string-append (map (lambda (char)\n\
    \                              (match char\n                                [(char-lower-case?\
    \ char) (char-upcase char)]\n                                [(char-upper-case?\
    \ char) (char-downcase char)]\n                                [_            \
    \          char]))\n                            (string->list string))))\n", " \
    \ (string-map (lambda (c)\n                (if (char-upper-case? c)\n        \
    \            (char-downcase c)\n                    (char-upcase c)))\n      \
    \        string))\n```\n\n```racket\n#lang racket\n", "  (define (iter s result)\n\
    \    (cond ((empty? s) result)\n          ((symbol=? (first s) (string-upcase\
    \ (first s))) (iter (rest s) (string-append result (string-downcase (first s)))))\n\
    \          ((symbol=? (first s) (string-downcase (first s))) (iter (rest s) (string-append\
    \ result (string-upcase (first s)))))\n          (else (iter (rest s) (string-append\
    \ result (first s))))))\n  (iter string \"\"))\n", "  (map (lambda (c)\n     \
    \    (cond [(char-lower-case? c) (char-upcase c)]\n               [(char-upper-case?\
    \ c) (char-downcase c)]\n               [else c]))\n       string))\n</code>\n\
    Sample Run\n<code>&gt; (flip_case \"aBcDeF\")\n\"AbCdEf\"\n</code>\nIf you wanted\
    \ to flip all non-alphabetic characters, it's a trivial change to this.\n", " \
    \ (string-&gt;list string)\n  (for/list ([x (in-list string)])\n    (if (char-upper-case?\
    \ x)\n        (char-downcase x)\n        (char-upcase x))))\n", "  (map char-upcase\
    \ (map char-downcase string)))\n", "  (let loop ([string string]\n           \
    \  [new-string \"\"])\n    (cond [(empty? string) new-string]\n          [(lower-case?\
    \ (first string))\n           (loop (rest string) (string-append new-string (string-upcase\
    \ (first string))))]\n          [(upper-case? (first string))\n           (loop\
    \ (rest string) (string-append new-string (string-downcase (first string))))]\n\
    \          [else (loop (rest string) (string-append new-string (first string)))])))\n",
  "  (string-map (\u03BB (x)\n                (cond [(char-upcase? x) (char-downcase\
    \ x)]\n                      [(char-downcase? x) (char-upcase x)]\n          \
    \            [else x]))\n              string))\n", "  (let loop ([chars (string->list\
    \ string)]\n             [fuzz 1])\n    (cond\n      [(empty? chars) empty]\n\
    \      [(and (char-alphabetic? (car chars))\n            (not (char-numeric? (car\
    \ chars))))\n       (cons (if (even? fuzz)\n                 (char-upcase (car\
    \ chars))\n                 (char-downcase (car chars)))\n             (loop (cdr\
    \ chars) (+ fuzz 1)))]\n      [else (cons (car chars) (loop (cdr chars) (+ fuzz\
    \ 1)))])))\n", "  (for/list ([char (in-string string)])\n    (if (char-alphabetic?\
    \ char)\n        (if (char-lower-case? char)\n            (char-upcase char)\n\
    \            (char-downcase char))\n        char)))\n</code>\nThis just displays\
    \ the flipped string. I want to be able to pass in a parameter and then have the\
    \ string be assigned to that parameter.\nI tried changing the for/list to for\
    \ but it said I couldn't do that. I also tried using append-map and list, but\
    \ that won't work because the string will be longer than the original.\nIs there\
    \ a way to do this?\n\n\nA:\n\nThe <code>for/fold</code> is not working since\
    \ you need to pass a string as an initial accumulator (in the <code>for/fold</code>\
    \ form the <code>init</code> argument). \nThis is easy to achieve if you want\
    \ to process the string in reverse order, like this:\n<code>(define (flip-case\
    \ s)\n  (for/fold ([<b>s</b> (string)]\n             [i (sub1 (string-length s))])\n\
    \      ([c (in-string s)] #:from-end true)\n    (string-set! s i (if (char-alphabetic?\
    \ c)\n                         (if (char-lower-case? c)\n                    \
    \         (char-upcase c)\n                             (char-downcase c))\n \
    \                        c))))</code>\nThe <code>i</code> variable represents\
    \ the index of the <code>string-set!</code> operation, and we pass the reversed\
    \ <code>s</code> variable in the <code>for/fold</code> form. The initial value\
    \ is the empty string, and we will process the string in reverse order, hence\
    \ the <code>#:from-end true</code> clause. The initial value of <code>i</code>\
    \ is the index of the last character in the string.\nIn case we want to process\
    \ the string in normal order, we need to create a string with the same length\
    \ as the original string, and then we will replace each character in the string,\
    \ like this:\n<code>(define (flip-case s)\n  (for/fold ([", "  (string-map char-upcase/downcase\
    \ string))\n", "  (map (\u03BB (c) (if (char-alphabetic? c)\n                \
    \  (if (char-lower-case? c)\n                      (char-upcase c)\n         \
    \             (char-downcase c))\n                  c))\n       string))\n", " \
    \ (string-map\n   (lambda (c)\n     (if (char-ci&gt;=? c #\\a)\n         (char-upcase\
    \ c)\n         (char-downcase c)))\n   string))\n</code>\n", "  (string-map\n\
    \   (lambda (character)\n     (if (char-upcase? character)\n         (char-downcase\
    \ character)\n         (char-upcase character)))\n   string))\n</code>\n", " \
    \ (string-downcase (string-upcase string)))\n", "  (string-map\n   (lambda (ch)\n\
    \     (if (char-upper-case? ch)\n         (char-downcase ch)\n         (char-upcase\
    \ ch)))\n   string))\n", "  (regexp-replace* #rx\"[a-z]\" string\n           \
    \        (lambda (m)\n                     (regexp-replace* #rx\"[a-z]\" m\n \
    \                                     (lambda (n)\n                          \
    \              (string-downcase n))))))\n", "  (map (lambda (char)\n         (if\
    \ (char-lower-case? char)\n             (char-upcase char)\n             (char-downcase\
    \ char)))\n       string))\n", "  (string-map\n   (lambda (char)\n     (if (char-upper-case?\
    \ char)\n         (char-downcase char)\n         (char-upcase char)))\n   string))\n\
    </code>\n", "  (apply string-append (map (lambda (x)\n                       \
    \       (if (char-lower-case? x)\n                                  (string-downcase\
    \ (string x))\n                                  (string-upcase (string x))))\
    \ string)))\n", "  (string-append\n   (string-map\n    (lambda (c)\n      (if\
    \ (char-lower-case? c)\n          (char-upcase c)\n          (char-downcase c)))\n\
    \    string)))\n", "  (string-map\n   (lambda (ch)\n     (if (char-lower-case?\
    \ ch)\n         (char-upcase ch)\n         (char-downcase ch)))\n   string))\n",
  "  (string-map\n   (lambda (ch)\n     (if (char-lower-case? ch)\n         (char-upcase\
    \ ch)\n         (char-downcase ch)))\n   string))\n", "  (define upc (string-upcase\
    \ string))\n  (define lwc (string-downcase string))\n  (string-append\n    (map\
    \ (lambda (x) (if (member x lwc) (char-upcase x) (char-downcase x))) string)))\n",
  "  (string-normalize-spaces (string-for/fold ([new \"\"] [c (in-string string)])\n\
    \                                            (string-append new\n            \
    \                                               (if (char-downcase? c)\n     \
    \                                                          (char-upcase c)\n \
    \                                                              (char-downcase\
    \ c))))))\n", "  (list->string (map (\u03BB (c) (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))) (string->list string))))\n", "  (string-map\n   (lambda\
    \ (char)\n     (if (char-lower-case? char)\n         (char-upcase char)\n    \
    \     (char-downcase char)))\n   string))\n", "  (apply string-append (map (\u03BB\
    \ (char)\n                              (if (char-alphabetic? char)\n        \
    \                          (if (char-lower-case? char)\n                     \
    \                 (string-upcase (string char))\n                            \
    \          (string-downcase (string char)))\n                                \
    \  (string char)))\n                            string)))\n", "  (string-map\n\
    \   (lambda (char)\n     (cond\n       [(char-lower-case? char) (char-upcase char)]\n\
    \       [(char-upper-case? char) (char-downcase char)]\n       [else char]))\n\
    \   string))\n</code>\nBut I was wondering if there is any other, more idiomatic\
    \ way to do this in Racket.\n\n\nA:\n\n<code> (string-map char-upcase/downcase\
    \ \"abc\")\n</code>\nwill give you a new string with flipped case.\n<code>#lang\
    \ racket", "  (string-map\n   (lambda (x)\n     (if (char-ci&gt;=? x #\\a)\n \
    \        (char-upcase x)\n         (char-downcase x)))\n   string))\n", "  (map\
    \ (\u03BB (c)\n         (cond\n           ((lower-case? c) (string-&gt;symbol\
    \ (string-upcase (symbol-&gt;string c))))\n           ((upper-case? c) (string-&gt;symbol\
    \ (string-downcase (symbol-&gt;string c))))\n           (else c)))\n       string))\n",
  "  (string-map\n   (lambda (c)\n     (if (char-lower-case? c)\n         (char-upcase\
    \ c)\n         (char-downcase c)))\n   string))\n", "  (string-map (lambda (x)\
    \ (if (char-lower-case? x) (char-upcase x) (char-downcase x))) string))\n", " \
    \ (define (flip c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n  \
    \      (char-downcase c)))\n  (string-&gt;list string))\n", "  (map string-upcase\
    \ string))\n", "  (list->string (map\n                   (\u03BB (c)\n       \
    \              (cond\n                       [(char-upper-case? c) (char-downcase\
    \ c)]\n                       [(char-lower-case? c) (char-upcase c)]\n       \
    \                [else c]))\n                   (string->list string))))\n", " \
    \ (string-copy\n   (string-map\n    (lambda (char)\n      (if (char-alphabetic?\
    \ char)\n          (if (char-upper-case? char)\n              (char-downcase char)\n\
    \              (char-upcase char))\n          char))\n    string)))\n", "  (string-join\
    \ (map (lambda (char)\n                      (cond [(char-alphabetic? char)\n\
    \                             (if (char-upper-case? char)\n                  \
    \               (char-downcase char)\n                                 (char-upcase\
    \ char))]\n                            [else char]))\n                    (string->list\
    \ string))))\n```\n\nYou can see that the `flip_case` function takes a string\
    \ as an argument, and\nthen maps over the list of characters in the string. In\
    \ the mapping function, we\ntake each character in the list and check if it is\
    \ alphabetical with\n`char-alphabetic?`. If it is alphabetical, we check if it\
    \ is uppercase with\n`char-upper-case?`. If it is uppercase, we make it lowercase\
    \ with\n`char-downcase`, and if it is lowercase, we make it uppercase with\n`char-upcase`.\
    \ If it isn't alphabetical, we just leave it as it is.\n\nAll of the `char-*`\
    \ functions are available in `racket/base`, but you can also\nsee a list of them\
    \ on the [Racket docs][racket-char-ref] by searching for\n\"char-\".\n\n[racket-char-ref]:\
    \ https://docs.racket-lang.org/reference/strings.html#%28part._.Characters%29\n\
    \n## Tooling\n\nHere are some tools we will be using in this workshop.\n\n- [VSCode][vscode]\
    \ - Text editor.\n- [Racket][racket] - The Racket language.\n- [DrRacket][drracket]\
    \ - The Racket IDE.\n- [Racket-mode][racket-mode] - Racket syntax highlighting\
    \ for VSCode.\n- [Racket-repl][racket-repl] - Running a Racket REPL inside VSCode.\n\
    \n[vscode]: https://code.visualstudio.com/\n[racket]: https://racket-lang.org/\n\
    [drracket]: https://racket-lang.org/download/\n[racket-mode]: https://github.com/greghendershott/racket-mode\n\
    [racket-repl]: https://github.com/greghendershott", "  (let ((upper? (char-upper-case?\
    \ (string-ref string 0))))\n    (if upper? (string-downcase string) (string-upcase\
    \ string))))\n", "  (for/list ([char (in-string string)])\n    (cond\n      [(char-lower-case?\
    \ char) (char-upcase char)]\n      [(char-upper-case? char) (char-downcase char)]\n\
    \      [else char])))\n", "  (let ((result (make-string (string-length string))))\n\
    \    (for ([i (in-range (string-length string))])\n      (set! result i (string-downcase\
    \ (string-upcase (string-ref string i)))))\n    result))\n", "  (string-join\n\
    \   (map (\u03BB (char)\n          (if (char-lower-case? char)\n             \
    \ (char-upcase char)\n              (char-downcase char)))\n        (string->list\
    \ string))))\n", "  (string-&gt;list string)\n  (map (lambda (char)\n        \
    \ (cond\n           [(lower-case? char) (char-upcase char)]\n           [(upper-case?\
    \ char) (char-downcase char)]\n           [else char]))\n       string))\n</code>\n\
    However, the function always returns an empty list.  What am I doing wrong?\n\n\
    \nA:\n\n<code>string-&gt;list</code> returns a list, but you are not using the\
    \ result, you are passing the string back to <code>map</code> which is what is\
    \ leading to the empty list being returned.\nTry:\n<code>(define (flip_case string)\n\
    \  (map (lambda (char)\n         (cond\n           [(lower-case? char) (char-upcase\
    \ char)]\n           [(upper-case? char) (char-downcase char)]\n           [else\
    \ char]))\n       (string-&gt;list string)))\n</code>\nYou could also use <code>string-map</code>\
    \ to make it simpler:\n<code>(define (flip_case string)\n  (string-map (lambda\
    \ (char)\n                (cond\n                  [(lower-case? char) (char-upcase\
    \ char)]\n                  [(upper-case? char) (char-downcase char)]\n      \
    \            [else char]))\n              string))\n</code>\n", "  (map\n   (lambda\
    \ (x)\n     (if (char-lower-case? x)\n         (char-upcase x)\n         (char-downcase\
    \ x)))\n   string))\n", "  (string-map\n   (lambda (char)\n     (cond\n      \
    \ [(and (char-lower-case? char) (char-alpha? char)) (char-upcase char)]\n    \
    \   [(and (char-upper-case? char) (char-alpha? char)) (char-downcase char)]\n\
    \       [else char]))\n   string))\n", "  (map\n   (lambda (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n\
    </code>\nExample usage:\n<code>&gt; (flip_case \"HelLoWorld\")\n'(\"h\" \"E\"\
    \ \"l\" \"L\" \"o\" \"w\" \"O\" \"r\" \"l\" \"d\")\n</code>\n", "  (if (string=?\
    \ string \"\")\n      \"\"\n      (string-append (if (char-ci=? (string-ref string\
    \ 0) (string-ref string 0))\n                        (string-upcase (string (string-ref\
    \ string 0)))\n                        (string-downcase (string (string-ref string\
    \ 0))))\n                    (flip_case (substring string 1)))))\n", "  (map char-upcase\
    \ string))\n</code>\nThis is the error message I get:\n<code>&gt; (flip_case \"\
    abcdefghijklmnopqrstuvwxyz\")", "  (string-map\n   (lambda (char)\n     (cond\n\
    \       [(char-alphabetic? char)\n        (if (char-lower-case? char)\n      \
    \      (char-upcase char)\n            (char-downcase char))]\n       [else char]))\n\
    \   string))\n</code>\n", "  (let loop ([str string]\n             [index 0])\n\
    \    (if (= index (string-length str))\n        str\n        (loop (string-set!\
    \ str index\n                           (cond [(char-lower-case? (string-ref str\
    \ index))\n                                  (char-upcase (string-ref str index))]\n\
    \                                 [(char-upper-case? (string-ref str index))\n\
    \                                  (char-downcase (string-ref str index))]\n \
    \                                [else (string-ref str index)]))\n           \
    \   (+ index 1)))))\n", "  (map (lambda (char)\n         (cond [(char-lower-case?\
    \ char) (char-upcase char)]\n               [(char-upper-case? char) (char-downcase\
    \ char)]\n               [else char]))\n       string))\n", "  (for/list ([c (in-string\
    \ string)])\n    (if (char-alphabetic? c)\n        (char-downcase c)\n       \
    \ (char-upcase c))))\n", "  (string-map (lambda (s) (if (char-lower-case? s) (char-upcase\
    \ s) (char-downcase s))) string))\n</code>\n", "  (if (string-null? string)\n\
    \      \"\"\n      (let ([head (string-ref string 0)])\n        (if (char-alphabetic?\
    \ head)\n            (if (char-lower-case? head)\n                (string-append\
    \ (string-upcase (string head)) (flip_case (string-tail string 1)))\n        \
    \        (string-append (string-downcase (string head)) (flip_case (string-tail\
    \ string 1))))\n            (string-append (string head) (flip_case (string-tail\
    \ string 1)))))))\n", "  (string-join\n   (map (lambda (char)\n          (if (char-lower-case?\
    \ char)\n              (char-upcase char)\n              (char-downcase char)))\n\
    \        (string->list string))))\n", "  (let loop ([s string] [result '()])\n\
    \    (cond\n      [(empty? s) (reverse result)]\n      [(char-alphabetic? (first\
    \ s))\n       (if (char-lower-case? (first s))\n           (loop (rest s) (cons\
    \ (char-upcase (first s)) result))\n           (loop (rest s) (cons (char-downcase\
    \ (first s)) result)))]\n      [else (loop (rest s) (cons (first s) result))])))\n",
  "  (apply string-append (map (lambda (c) (if (char-alphabetic? c)\n            \
    \                                (if (char-lower-case? c)\n                  \
    \                              (char-upcase c)\n                             \
    \                   (char-downcase c))\n                                     \
    \       c))\n                            string)))\n", "  (define (invert-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (string-map invert-case string))\n", "  (map (curry string-map (lambda\
    \ (char)\n                           (if (char-alphabetic? char)\n           \
    \                    (char-upcase char)\n                               (char-downcase\
    \ char))))\n       string))\n", "  (map symbol-&gt;string\n       (map (\u03BB\
    \ (x) (if (char-lower-case? x) (char-upcase x) (char-downcase x)))\n         \
    \   (string-&gt;list string))))\n", "  (string-join\n   (map\n    (lambda (c)\n\
    \      (if (char-ci&gt;=? c #\\a)\n          (char-upcase c)\n          (char-downcase\
    \ c)))\n    (string-&gt;list string))))\n", "  (define (flip-ch char)\n    (cond\
    \ ((char-downcase? char) (char-upcase char))\n          ((char-upcase? char) (char-downcase\
    \ char))\n          (else char)))\n  (list->string (map flip-ch (string->list\
    \ string))))\n", "  (regexp-replace* #rx\"[a-zA-Z]\" string\n                \
    \   (lambda (s)\n                     (string-downcase (string-upcase s)))))\n",
  "  (map string-upcase (regexp-replace* #rx\"[A-Z]\" string string-downcase)))\n\
    </code>\nAnd a test:\n<code>#lang racket\n", "  (for/list ([char (in-string string)])\n\
    \    (if (char-alphabetic? char)\n        (if (char-lower-case? char)\n      \
    \      (char-upcase char)\n            (char-downcase char))\n        char)))\n",
  "  (cond\n    [(empty? string) empty]\n    [(char-lower-case? (first string))\n\
    \     (string-append (string-upcase (first string)) (flip_case (rest string)))]\n\
    \    [(char-upper-case? (first string))\n     (string-append (string-downcase\
    \ (first string)) (flip_case (rest string)))]\n    [else\n     (string-append\
    \ (first string) (flip_case (rest string)))]))\n", "  (for/string ([char (in-string\
    \ string)])\n    (if (char-lower-case? char)\n        (char-upcase char)\n   \
    \     (char-downcase char))))\n", "  (string-join (map (\u03BB (char)\n      \
    \                (if (char-lower-case? char)\n                          (char-upcase\
    \ char)\n                          (char-downcase char)))\n                  \
    \  (string->list string))))\n```\n\n```Racket\n#lang racket\n", "  (string-join\n\
    \   (for/list ([c (in-string string)])\n     (cond [(char-alphabetic? c)\n   \
    \         (if (char-lower-case? c)\n                (char-upcase c)\n        \
    \        (char-downcase c))]\n           [else c]))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
