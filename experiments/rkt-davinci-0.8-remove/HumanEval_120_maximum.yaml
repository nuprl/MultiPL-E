name: HumanEval_120_maximum
language: rkt
prompt: "#lang racket\n\n;; Given an array arr of integers and a positive integer\
  \ k, return a sorted list \n;; of length k with the maximum k numbers in arr.\n\
  ;; Example 1:\n;; Example 2:\n;; Example 3:\n;; Note:\n;; 1. The length of the array\
  \ will be in the range of [1, 1000].\n;; 2. The elements in the array will be in\
  \ the range of [-1000, 1000].\n;; 3. 0 <= k <= len(arr)\n(define (maximum arr k)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n\
  \    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))\n    (check-equal?\
  \ (candidate (list 4 -4 4) 2) (list 4 4))\n    (check-equal? (candidate (list -3\
  \ 2 1 2 -1 -2 1) 1) (list 2))\n    (check-equal? (candidate (list 123 -123 20 0\
  \ 1 2 -3) 3) (list 2 20 123))\n    (check-equal? (candidate (list -123 20 0 1 2\
  \ -3) 4) (list 0 1 2 20))\n    (check-equal? (candidate (list 5 15 0 3 -13 -8 0)\
  \ 7) (list -13 -8 0 0 3 5 15))\n    (check-equal? (candidate (list -1 0 2 5 3 -10)\
  \ 2) (list 3 5))\n    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))\n  \
  \  (check-equal? (candidate (list 4 -4) 2) (list -4 4))\n    (check-equal? (candidate\
  \ (list -10 10) 2) (list -10 10))\n    (check-equal? (candidate (list 1 2 3 -23\
  \ 243 -400 0) 0) (list ))\n))\n\n(test-humaneval)"
completions: ["  (define (helper list result k)\n    (cond [(empty? list) result]\n\
    \          [(empty? result) (helper (rest list) (list (first list)) k)]\n    \
    \      [(> (first list) (first result)) (helper (rest list) (rest result) (append\
    \ (list (first list)) result))]\n          [else (helper (rest list) result k)]))\n\
    \  (helper arr (list) k))\n", "  (define (max arr)\n    (cond\n      [(null? arr)\
    \ '()]\n      [(null? (cdr arr)) (car arr)]\n      [else\n       (cond\n     \
    \    [(> (car arr) (car (cdr arr))) (max (cons (car arr) (cdr (cdr arr))))]\n\
    \         [else (max (cons (car (cdr arr)) (cdr (cdr arr))))])]))\n  (define (repl\
    \ arr k)\n    (cond\n      [(= k 0) '()]\n      [else (cons (max arr) (repl (remove\
    \ (max arr) arr) (- k 1)))]))\n  (repl arr k))\n", "  (displayln arr)\n  (displayln\
    \ k)\n  (sort arr (lambda (x y) (> x y))))\n", "  (if (equal? (length arr) 0)\n\
    \      '()\n      (let\n          ([arr-sorted (sort arr (lambda (a b) (< a b)))]\n\
    \           [rest (maximum (sublist arr 1 (length arr)) k)])\n        (if (>=\
    \ (length rest) k)\n            rest\n            (cons (first arr-sorted) rest)))))\n",
  "  (define (heapify arr i)\n    (define (swap arr i j)\n      (define tmp (vector-ref\
    \ arr i))\n      (vector-set! arr i (vector-ref arr j))\n      (vector-set! arr\
    \ j tmp))\n    (define (left i) (+ (* 2 i) 1))\n    (define (right i) (+ (* 2\
    \ i) 2))\n    (define (maxIndex arr i j k)\n      (define max-i i)\n      (when\
    \ (< (vector-ref arr j) (vector-ref arr max-i))\n        (set! max-i j))\n   \
    \   (when (< (vector-ref arr k) (vector-ref arr max-i))\n        (set! max-i k))\n\
    \      max-i)\n    (define len (vector-length arr))\n    (let loop ([i i])\n \
    \     (when (< i len)\n        (define (siftDown arr i end)\n          (define\
    \ j (left i))\n          (define r (right i))\n          (define m (maxIndex arr\
    \ i j r))\n          (when (< m end)\n            (swap arr i m)\n           \
    \ (siftDown arr m end)))\n        (siftDown arr i (- len 1))\n        (loop (+\
    \ i 1)))))\n  (define (buildHeap arr)\n    (define (parent i) (quotient (- i 1)\
    \ 2))\n    (let loop ([i (parent (- (vector-length arr) 1))])\n      (when (>=\
    \ i 0)\n        (heapify arr i)\n        (loop (- i 1)))))\n  (define (siftDown\
    \ arr i end)\n    (define (swap arr i j)\n      (define tmp (vector-ref arr i))\n\
    \      (vector-set! arr i (vector-ref arr j))\n      (vector-set! arr j tmp))\n\
    \    (define (left i) (+ (* 2 i) 1))\n    (define (right i) (+ (* 2 i) 2))\n \
    \   (define (maxIndex arr i j k)\n      (define max-i i)\n      (when (< (vector-ref\
    \ arr j) (vector-ref arr max-i))\n        (set!", "  (sort arr &gt;))\n</code>\n\
    However, this implementation does not return a list of length k. What is the idiomatic\
    \ way of doing that?\n\n\nA:\n\nIn Racket, the idiomatic way to do this is to\
    \ use <code>take</code>:\n<code>(define (maximum arr k)\n  (take (sort arr &gt;)\
    \ k))\n</code>\n", "  (make-heap arr k))\n", '  (take (sort (flatten (array->list
    arr)) <) k))', "  (match k\n    [(= 0) '()]\n    [(= 1)\n     (list (max-of-arr\
    \ (first arr) (rest arr)))]\n    [else\n     (if (null? (rest arr))\n        \
    \ arr\n         (append (maximum (first arr) (max (min k (- (length arr) 1)) 0))\n\
    \                 (maximum (rest arr) (- k 1))))]))\n", "  (sort (take (sort (reverse\
    \ arr) <) k) >))\n", "  (sort arr >))\n", "  (define (max-k helper tmp lst)\n\
    \    (if (zero? k) (reverse tmp)\n        (if (null? lst) (reverse tmp)\n    \
    \        (if (&gt; (car lst) (car tmp))\n                (max-k helper (cons (car\
    \ lst) (cdr tmp)) (cdr lst))\n                (max-k helper tmp (cdr lst))))))\n\
    \  (max-k (car arr) (cdr arr) (cdr arr)))\n", "  (array-sort (lambda (a b) (&gt;\
    \ a b)) arr)\n  (subarray arr 0 k))\n", '  (sort arr >))', "  (sort arr &gt;))\n",
  "  (sort arr >))\n", "  (define (max-array arr maxes)\n    (cond [(empty? arr) (reverse\
    \ maxes)]\n          [(> (car arr) (car maxes)) (max-array (cdr arr) (cons (car\
    \ arr) (cdr maxes)))]\n          [else (max-array (cdr arr) maxes)]))\n  (max-array\
    \ arr (build-list k (lambda (x) 0))))\n```\n\n```scheme\n#lang racket\n", "  (define\
    \ (heapify arr i)\n    (let ([l (let ([li (+ i 1)])\n               (if (< li\
    \ (vector-length arr)) li -1))]\n          [r (let ([ri (+ i 2)])\n          \
    \     (if (< ri (vector-length arr)) ri -1))]\n          [largest (if (and l (>\
    \ (vector-ref arr l) (vector-ref arr i))) l i)]\n          [largest (if (and r\
    \ (> (vector-ref arr r) (vector-ref arr largest))) r largest)])\n      (if (=\
    \ largest i)\n          arr\n          (let ([tmp (vector-ref arr i)])\n     \
    \       (vector-set! arr i (vector-ref arr largest))\n            (vector-set!\
    \ arr largest tmp)\n            (heapify arr largest)))))\n  (define (build-heap\
    \ arr)\n    (let loop ([i (- (vector-length arr) 1)])\n      (if (= 0 i)\n   \
    \       arr\n          (let ([arr (heapify arr i)])\n            (loop (- i 1))))))\n\
    \  (let loop ([arr (build-heap arr)]\n             [n (- (vector-length arr) 1)])\n\
    \    (if (= 0 n)\n        (vector-ref arr 0)\n        (let ([tmp (vector-ref arr\
    \ 0)])\n          (vector-set! arr 0 (vector-ref arr n))\n          (vector-set!\
    \ arr n tmp)\n          (heapify arr 0)))))\n", "  (define (insert-sort lst)\n\
    \    (foldl (lambda (x lst)\n             (define (insert x lst)\n           \
    \    (if (empty? lst)\n                   (list x)\n                   (if (<\
    \ x (first lst))\n                       (cons x lst)\n                      \
    \ (cons (first lst) (insert x (rest lst))))))\n             (insert x lst))\n\
    \           empty\n           lst))\n  (define (take n lst)\n    (if (= n 0)\n\
    \        empty\n        (cons (first lst) (take (- n 1) (rest lst)))))\n  (take\
    \ k (insert-sort arr)))\n", "  (sorted (reverse (take (sort arr <) k))))\n", " \
    \ (sort arr >))\n```\n\n```\n#lang racket\n", "  (sort arr < #:key (\u03BB (x)\
    \ (- x))))\n```\n\n- Definition for a binary tree node.\n\n```racket\n#lang racket\n",
  "  (sort arr > (take arr k)))\n", "  (define (aux acc arr)\n    (if (= (length arr)\
    \ 0)\n        acc\n        (begin\n          (define (insert el ls)\n        \
    \    (cond\n              [(empty? ls) (list el)]\n              [(< el (first\
    \ ls)) (cons el ls)]\n              [else (cons (first ls) (insert el (rest ls)))]))\n\
    \          (aux (insert (first arr) acc) (rest arr)))))\n  (take (aux (list (first\
    \ arr)) (rest arr)) k))\n", "  (if (equal? k 1)\n      (if (&gt; (car arr) (cadr\
    \ arr))\n          (list (car arr))\n          (list (cadr arr)))\n      (if (&gt;\
    \ (car arr) (cadr arr))\n          (cons (car arr) (maximum (cdr arr) (- k 1)))\n\
    \          (cons (cadr arr) (maximum (cdr arr) (- k 1))))))\n", "  (let ([n (length\
    \ arr)])\n    (define (sift-down arr i n)\n      (let* ([left (* 2 i)]\n     \
    \        [right (+ 1 left)]\n             [max (if (>= right n) left right)])\n\
    \        (when (< (vector-ref arr max) (vector-ref arr i))\n          (vector-swap!\
    \ arr i max)\n          (sift-down arr max n))))\n    (define (build-heap arr\
    \ n)\n      (let loop ([i (- n 1)])\n        (when (>= i 0)\n          (sift-down\
    \ arr i n)\n          (loop (- i 1)))))\n    (define (heap-sort arr n)\n     \
    \ (build-heap arr n)\n      (let loop ([i (- n 1)])\n        (when (>= i 0)\n\
    \          (vector-swap! arr 0 i)\n          (sift-down arr 0 i)\n          (loop\
    \ (- i 1)))))\n    (define (find-max arr n k)\n      (build-heap arr n)\n    \
    \  (let loop ([i (- n 1)])\n        (if (= i 0)\n            (vector-ref arr i)\n\
    \            (vector-swap! arr 0 i)\n            (sift-down arr 0 i)\n       \
    \     (loop (- i 1)))))\n    (heap-sort arr n)\n    (let ([i 0])\n      (let loop\
    \ ([k k])\n        (if (= k 0)\n            '()\n            (cons (vector-ref\
    \ arr i) (loop (- k 1))))))))\n</code>\n", "  (define (accum a acc)\n    (if (empty?\
    \ a) acc\n        (if (&lt; (first a) (first acc))\n            (accum (rest a)\
    \ (cons (first a) (rest acc)))\n            (accum (rest a) acc))))\n  (accum\
    \ arr (list (first arr))))\n", "  (define (sorted-list lst)\n    (apply max lst))\n\
    \  (sorted-list (take (sort (apply append (apply array-fill (array-length arr)\
    \ 1 arr)) <) k)))", "  (sort > arr)\n  (take k arr))", "  (let loop ([arr arr]\
    \ [k k] [r '()])\n    (cond [(zero? k) r]\n          [else\n           (loop (for/fold\
    \ ([acc (first arr)]) ([a (in-list (rest arr))])\n                   (cond [(&gt;\
    \ a acc) a]\n                         [else acc]))\n                 (- k 1)\n\
    \                 (cons (first arr) r))])))\n</code>\n", "  (if (empty? arr)\n\
    \      empty\n      (append (list (maximum arr))\n              (maximum (filter\
    \ (lambda (x) (&lt; x (maximum arr)))\n                                arr)\n\
    \                       (- k 1)))))\n", "  (let loop ([k (dec k)] [acc '()])\n\
    \    (if (zero? k) acc\n        (loop (dec k) (cons (max (car arr) (car acc))\
    \ (cdr acc))))))\n", "  (define (max-k-helper arr k results)\n    (if (or (empty?\
    \ arr) (= k 0)) results\n        (let* ([max (maximum arr)]\n               [arr\
    \ (remove max arr)])\n          (max-k-helper arr (- k 1) (cons max results)))))\n\
    \  (max-k-helper arr k null))\n", '  (sort (for/list ([x arr]) x) >))', "  (let\
    \ ([n (length arr)])\n    (define (max k arr)\n      (define (sort arr)\n    \
    \    (cond [(or (empty? arr) (= 1 (length arr))) arr]\n              [else (let*\
    \ ([v (first arr)]\n                           [l (rest arr)]\n              \
    \             [p (partition (lambda (e) (< e v)) l)])\n                      (append\
    \ (sort (first p)) (cons v (sort (second p)))))]))\n      (define (partition pred\
    \ l)\n        (let loop ([a '()] [b '()] [l l])\n          (cond [(empty? l) (values\
    \ (reverse a) (reverse b))]\n                [(pred (first l)) (loop (cons (first\
    \ l) a) b (rest l))]\n                [else (loop a (cons (first l) b) (rest l))])))\n\
    \      (let ([a (sort arr)])\n        (cond [(empty? a) '()]\n              [(=\
    \ k 1) (list (first a))]\n              [else (cons (first a) (max (- k 1) (rest\
    \ a)))])))\n    (max k arr)))\n", "  (let loop ([arr arr] [k k] [out '()])\n \
    \   (if (or (empty? arr) (= k 0))\n        out\n        (loop (remove-max arr)\
    \ (- k 1) (cons (max arr) out)))))\n", "  (define (maximum-helper arr k)\n   \
    \ (if (empty? arr) '()\n        (let ([maxarr (list-ref arr 0)])\n          (for\
    \ ([i (in-range (sub1 (length arr)))])\n            (if (&gt; (list-ref arr (+\
    \ i 1)) (list-ref maxarr 0))\n                (set! maxarr (cons (list-ref arr\
    \ (+ i 1)) maxarr))\n                (set! maxarr (cons (list-ref maxarr 0) maxarr))))\n\
    \          (cons (list-ref maxarr 0) (maximum-helper (remove (list-ref maxarr\
    \ 0) arr) (- k 1))))))\n  (reverse (maximum-helper arr k)))\n</code>\nI get this\
    \ error:\n<code>&gt; (maximum '(12 1 2 10 5) 2)\nremove: contract violation\n\
    \  expected: hashable?\n  given: #&lt;procedure:...&gt;\n  in: (remove #&lt;procedure:...&gt;\
    \ '(12 1 2 10 5))\n</code>\nI'd appreciate an explanation of the error, and a\
    \ functional way to get the desired result.\n\nI've since changed the code to\
    \ this:\n<code>#lang racket\n", "  (for/list ([x (in-range k)])\n    (define max-index\
    \ (for/fold ([index 0]) ([index (in-range (add1 (array-length arr)))])\n     \
    \               (if (> (array-ref arr index) (array-ref arr (max-index))) index\
    \ (max-index))))\n    (array-ref arr max-index)))\n", "  (sort arr >))\n", " \
    \ (if (< k 1)\n      (values '() '() '()))\n  (define max (first arr))\n  (define\
    \ max-arr (list max))\n  (define i 0)\n  (define max-indices (list i))\n  (define\
    \ j (add1 i))\n  (for ([j (in-range 1 (length arr))])\n    (if (> (list-ref arr\
    \ j) max)\n        (begin\n          (set! max (list-ref arr j))\n          (set!\
    \ max-arr (list max))\n          (set! max-indices (list j)))\n        (if (=\
    \ (list-ref arr j) max)\n            (begin\n              (set! max-arr (append\
    \ max-arr (list max)))\n              (set! max-indices (append max-indices (list\
    \ j)))))))\n  (for ([i (in-range 1 (sub1 k))])\n    (set! max -1000)\n    (set!\
    \ max-arr '())\n    (set! max-indices '())\n    (set! j (add1 i))\n    (for ([j\
    \ (in-range i (length arr))])\n      (if (and (> (list-ref arr j) max)\n     \
    \          (not (member j max-indices)))\n          (begin\n            (set!\
    \ max (list-ref arr j))\n            (set! max-arr (list max))\n            (set!\
    \ max-indices (list j)))\n          (if (and (= (list-ref arr j) max)\n      \
    \             (not (member j max-indices)))\n              (begin\n          \
    \      (set! max-arr (append max-arr (list max)))\n                (set! max-indices\
    \ (append max-indices (list j)))))))\n    (set! max-arr (reverse max-arr)))\n\
    \  (values (sort max-arr <) max-arr max-indices))\n", "  (sort (take (sort (subseq\
    \ arr 0 k) >) k) <))\n", "  (define maxs (make-vector k #f))\n  (let loop ([arr\
    \ arr])\n    (cond\n      [(empty? arr)\n       maxs]\n      [else\n       (let\
    \ ([max #f])\n         (let loop ([v 0])\n           (cond\n             [(eq?\
    \ v k)\n              (void)]\n             [(not (not (vector-ref maxs v)))\n\
    \              (loop (+ v 1))]\n             [(and (not max) (vector-ref maxs\
    \ v))\n              (vector-set! maxs v max)\n              (loop (+ v 1))]\n\
    \             [(not (vector-ref maxs v))\n              (vector-set! maxs v (car\
    \ arr))\n              (loop (+ v 1))]\n             [else\n              (when\
    \ (< (vector-ref maxs v) (car arr))\n                (set! max (vector-ref maxs\
    \ v))\n                (vector-set! maxs v (car arr)))\n              (loop (+\
    \ v 1))]))\n         (loop (cdr arr)))))))\n", "  (define (loop ret arr)\n   \
    \ (if (and (empty? arr) (= (length ret) k))\n        ret\n        (let* ([acc\
    \ (car arr)]\n               [arr (cdr arr)])\n          (if (&gt; (car acc) (car\
    \ (last ret)))\n              (cons (last ret) (take (length ret) (loop (cons\
    \ acc ret) arr)))\n              (loop ret arr)))))\n  (loop empty arr))\n</code>\n\
    When I try to submit this solution to racket, it says \n<code>$ racket maximum.rkt\
    \ \nread-eval: expected a value for an argument, but found something else \n \
    \ at: #f\n</code>\nI am confused about this error. My solution does not use <code>#f</code>\
    \ in my code at all. When I try <code>racket maximum.rkt 1 2 3</code>, it works\
    \ fine.\n", "  (define (top i k lst)\n    (cond ((<= i (sub1 k)) (cons (max (max-of-list\
    \ lst) (list-ref arr i))\n                                 (top (add1 i) k (remove\
    \ (max-of-list lst) lst))))\n          (else '())))\n  (top 0 k arr))\n", "  (letrec\
    \ ([sorted (in-order arr)]\n           [left (quotient (length sorted) 2)]\n \
    \          [right (- (length sorted) 1)])\n    (cond [(= left 0) sorted]\n   \
    \       [(= right k) (take sorted right)]\n          [(= (length sorted) k) sorted]\n\
    \          [else (let ([y (vector-ref sorted right)])\n                  (cond\
    \ [(< y (vector-ref sorted left))\n                         (maximum (remove-item\
    \ sorted right) k)]\n                        [else (maximum (remove-item sorted\
    \ left) k)]))])))\n```\n\n```racket\n#lang racket\n", "  (for/list ([i (in-range\
    \ (min (length arr) k))])\n    (vector-ref arr i)))\n", "  (sort arr >))\n", " \
    \ (sort (flatten arr) &gt;))\n", "  (sort > arr))\n", "  (sort arr > :key (lambda\
    \ (x) x)))\n", "  (let ([result '()])\n    (for ([i (in-range (length arr))])\n\
    \      (for ([j (in-range (length result))])\n        (if (> (vector-ref arr i)\
    \ (car result))\n            (set! result (cons (vector-ref arr i) (list-tail\
    \ result j)))\n            #t)))\n    (list-take result k)))\n", "  (if (empty?\
    \ arr) empty\n      (define largest (sublist arr k))\n      (for/fold ([output\
    \ empty]) ([x arr])\n        (define max-in-sublist (reduce max largest))\n  \
    \      (if (&lt; max-in-sublist x) (append output (list x)) output))))\n", " \
    \ (let lp ([arr arr] [k k] [acc '()])\n    (if (zero? k)\n        acc\n      \
    \  (lp (filter (lambda (x) (not (equal? x (apply max arr)))) arr)\n          \
    \  (- k 1)\n            (cons (apply max arr) acc)))))\n", "  (reverse (take (sort\
    \ (append (take arr k) arr) >) k)))\n", "  (first\n   (sort arr (\u03BB (x y)\
    \ (< x y)))))\n", "  (define n (hash '()))\n  (for ([i (in-range (length arr))])\n\
    \    (if (hash-has-key? n (list-ref arr i))\n        (set! (hash-ref n (list-ref\
    \ arr i))\n             (+ 1 (hash-ref n (list-ref arr i))))\n        (hash-set!\
    \ n (list-ref arr i) 1)))\n  (define (helper xs)\n    (cond [(null? xs) '()]\n\
    \          [(hash-ref n (car xs))\n           (cons (car xs) (helper (cdr xs)))]\n\
    \          [else (helper (cdr xs))]))\n  (if (<= k (length arr))\n      (helper\
    \ (list->vector (sort (vector->list arr) <)))\n      arr))\n", "  (define (merge\
    \ l1 l2)\n    (cond [(null? l1) l2]\n          [(null? l2) l1]\n          [(<\
    \ (car l1) (car l2)) (cons (car l1) (merge (cdr l1) l2))]\n          [else (cons\
    \ (car l2) (merge l1 (cdr l2)))]))\n  (define (sort lst)\n    (cond [(null? lst)\
    \ lst]\n          [(null? (cdr lst)) lst]\n          [else (merge (sort (sublist\
    \ lst 0 (/ (length lst) 2)))\n                       (sort (sublist lst (/ (length\
    \ lst) 2) (length lst))))]))\n  (sublist (sort arr) 0 k))\n", "  (sort arr &gt;))\n\
    </code>\nThis does not output a list with the maximum k numbers. It always just\
    \ outputs the whole list.\n\n\nA:\n\nThe issue is in your call to <code>sort</code>.\
    \ It is just sorting the list and returning the sorted list.\nInstead you can\
    \ use the <code>take</code> function to only take the first k elements of the\
    \ sorted list.\n<code>(define (maximum arr k)\n  (take (sort arr &gt;) k))\n</code>\n\
    Alternatively you can use <code>quicksort</code> and its <code>take-right</code>\
    \ keyword argument.\n<code>(define (maximum arr k)\n  (quicksort arr &gt; (keyword-arguments\
    \ (take-right k))))\n</code>\n", "  (define (partition l pivot-idx)\n    (define\
    \ (swap lst i j)\n      (list-set lst i (list-ref lst j))\n      (list-set lst\
    \ j (list-ref lst i)))\n    (define (partition-help lst left right pivot-val)\n\
    \      (define pivot-new-idx left)\n      (define (swap-if-less lst i j)\n   \
    \     (if (&lt; (list-ref lst j) pivot-val)\n            (begin\n            \
    \  (swap lst i j)\n              (add1 pivot-new-idx))))\n      (for ([j (in-range\
    \ left (- right 1))])\n        (swap-if-less lst pivot-new-idx j))\n      (swap\
    \ lst pivot-new-idx right)\n      pivot-new-idx)\n    (partition-help l (sub1\
    \ pivot-idx) (- (length l) 1) (list-ref l pivot-idx)))\n  (define (quick-select\
    \ l k)\n    (define pivot-idx (random (length l)))\n    (define new-pivot-idx\
    \ (partition l pivot-idx))\n    (cond\n      [(= k new-pivot-idx) (take l k)]\n\
    \      [(&lt; k new-pivot-idx) (quick-select (take l new-pivot-idx) k)]\n    \
    \  [else (quick-select (drop l (add1 new-pivot-idx)) (- k (add1 new-pivot-idx)))]))\n\
    \  (quick-select arr k))\n", "  (for ([x (sort arr <)])\n    (<= k (length x))))\n",
  "  (let ([len (length arr)])\n    (define (sort-arr l n)\n      (cond [(empty? l)\
    \ (list)]\n            [(zero? n) (list)]\n            [else (let* ([large (max\
    \ (first l) (apply max (rest l)))]\n                         [new-l (remove large\
    \ l)]\n                         [new-n (sub1 n)])\n                    (append\
    \ (list large) (sort-arr new-l new-n)))]))\n    (if (<= len k)\n        (sort-arr\
    \ arr len)\n        (sort-arr arr k))))\n", '  (define (sor', "  (for/list ([i\
    \ (in-range k)])\n    (apply max arr)))\n</code>\nThis code is running with <code>O(kn)</code>\
    \ complexity (worse than the accepted answer). The Racket docs say that <code>max</code>\
    \ is working with a logarithmic complexity, but it looks like that does not apply\
    \ here since I am using <code>apply</code>.  \nWhat would be the best way to implement\
    \ this function using Racket?\n\n\nA:\n\nHeap sort has average case O(n lg n),\
    \ where n is the length of the input array. Racket provides <code>heap-sort</code>\
    \ (documentation) to do this efficiently.\nThe only remaining problem is that\
    \ you need to sort the elements descendingly. We do this by negating the elements\
    \ before sorting and then negating the result. The implementation below uses a\
    \ local <code>-</code> procedure (rather than an anonymous lambda function) to\
    \ prevent repeated allocation of a procedure.\n<code>(define (maximum arr k)\n\
    \  (define (neg arr)\n    (for/list ([x arr]) (- x)))\n  (let ([arr-neg (neg arr)])\n\
    \    (heap-sort &gt; arr-neg)\n    (neg (sublist arr-neg 0 k))))\n</code>\nThe\
    \ above program runs in 0.52 seconds on my machine, down from 5.47 seconds for\
    \ the naive linear-time algorithm.\n", "  (define (max-acc current-max current-max-index\
    \ current-i xs)\n    (if (and (&lt; current-i k) (not (null? xs)))\n        (max-acc\
    \ (if (&gt; (car xs) current-max)\n                    (car xs)\n            \
    \        current-max)\n                (if (&gt; (car xs) current-max)\n     \
    \               current-i\n                    current-max-index)\n          \
    \      (+ current-i 1)\n                (cdr xs))\n        current-max-index))\n\
    \  (max-acc -1000 0 0 arr))\n", "  (filter (lambda (x) (eq? (length x) k))\n \
    \         (permutations arr)))\n", "  (sort arr >))\n", "  (define (find-max arr\
    \ k)\n    (cond\n      [(zero? k) (vector)]\n      [(zero? (vector-length arr))\
    \ (vector)]\n      [else (vector-append (vector (vector-ref arr (argmax arr))\
    \ (vector-ref arr (argmax arr))) (find-max (vector-remove arr (argmax arr)) (-\
    \ k 1)))]))\n  (sort (vector->list (find-max arr k)) <))", "  (sort arr (lambda\
    \ (a b) (&gt; a b))))\n</code>\n", "  (cond\n    ((= k 0) '())\n    ((= k (vector-length\
    \ arr)) (sort arr &gt;))\n    (else\n     (let loop ((arr arr) (k k) (result '()))\n\
    \       (if (= k 0)\n           result\n           (let ((arr-max (apply max arr)))\n\
    \             (loop (vector-remove arr arr-max) (- k 1) (cons arr-max result))))))))\n\
    </code>\nI think the logic is pretty straightforward: keep removing the max of\
    \ the vector and appending to the result list until k is 0.\nI know using the\
    \ built-in <code>max</code> is less than ideal, but I think it's slightly better\
    \ than using <code>vector-ref</code> to set a new max each time, though I'm open\
    \ to suggestions.\nHowever, I'd like to know if it's possible to improve this\
    \ using some higher-order functions.\nI'm looking for a solution in Racket but\
    \ I'd welcome solutions in other languages as well.\n\n\nA:\n\nI'm not sure you\
    \ can do it more efficiently, but you can simplify it a bit by removing the base\
    \ case condition <code>(= k 0)</code>, and removing the call to <code>sort</code>:\n\
    <code>(define (maximum arr k)\n  (cond\n    ((= k (vector-length arr)) arr)\n\
    \    (else\n     (let loop ((arr arr) (k k) (result '()))\n       (if (= k 0)\n\
    \           result\n           (let ((arr-max (apply max arr)))\n            \
    \ (loop (vector-remove arr arr-max) (- k 1) (cons arr-max result))))))))\n</code>\n",
  "  (define n (length arr))\n  (define first (build-list n (\u03BB (i) (list (list\
    \ (list arr i))\n                                           (vector arr)\n   \
    \                                        (vector k i)))))\n  (define (repeat p)\n\
    \    (if (= p n)\n        (maximum arr k)\n        (let* ([x (first p)]\n    \
    \           [q (next x 1)]\n               [v (next x 2)]\n               [w (next\
    \ x 3)])\n          (if (< (get-in v (list q)) (get-in w (list p)))\n        \
    \      (set-in v (list q) (get-in w (list p)))\n              (void))\n      \
    \    (repeat (+ p 1)))))\n  (repeat 0)\n  (apply vector (build-list k (\u03BB\
    \ (i) (get-in (last first) (list i))))))\n", "  (for/list ([i (in-range (length\
    \ arr))]) (list-ref arr i)))\n", "  (if (= k 0)\n      '()\n      (let* ([max-arr\
    \ (max (first arr) (second arr))]\n             [min-arr (min (first arr) (second\
    \ arr))]\n             [max-idx 0]\n             [min-idx 1])\n        (for ([i\
    \ (in-range 2 (length arr))])\n          (let ([value (vector-ref arr i)])\n \
    \           (when (> value max-arr)\n              (set! max-arr value)\n    \
    \          (set! max-idx i))\n            (when (< value min-arr)\n          \
    \    (set! min-arr value)\n              (set! min-idx i))))\n        (cons max-arr\
    \ (maximum (remove-nth min-idx arr) (- k 1))))))", "  (let ([l (vector-length\
    \ arr)])\n    (display \"test\")\n    (display l)\n    (display \"\\n\")\n   \
    \ (for ([i (in-range 0 k)]\n          [j (in-range 0 l)])\n      (if (and (<=\
    \ (vector-ref arr i) (vector-ref arr j))\n               (not (member (vector-ref\
    \ arr j) arr i)))\n          (vector-set! arr i (vector-ref arr j))))\n    arr))\n\
    ```\n\n```", "  (define (max-heap?)\n    (let loop ([lst (length arr)])\n    \
    \  (if (&lt; lst 2)\n          #t\n          (and (&lt;= (vector-ref arr (- lst\
    \ 1)) (vector-ref arr (- lst 2)))\n               (loop (- lst 1))))))\n  (define\
    \ (push-heap)\n    (let* ([lst (length arr)]\n           [last (- lst 1)]\n  \
    \         [parent (quotient last 2)])\n      (if (and (&lt; last 2)\n        \
    \       (&gt; (vector-ref arr last) (vector-ref arr parent)))\n          (begin\
    \ (vector-swap! arr last parent)\n                 (push-heap)))))\n  (define\
    \ (pop-heap)\n    (vector-swap! arr 0 (- (length arr) 1))\n    (vector-pop! arr))\n\
    \  (define (insert-heap n)\n    (vector-push! arr n)\n    (push-heap))\n  (define\
    \ (make-heap)\n    (let loop ([i (quotient (length arr) 2)])\n      (if (&lt;\
    \ i 0)\n          #t\n          (begin (push-heap)\n                 (loop (-\
    \ i 1))))))\n  (define (sort-heap)\n    (define (pop-sort)\n      (pop-heap)\n\
    \      (make-heap))\n    (define (sort-loop)\n      (pop-sort)\n      (if (&lt;\
    \ (length arr) 2)\n          #t\n          (sort-loop)))\n    (sort-loop))\n \
    \ (define (get-k)\n    (define (k-loop)\n      (vector-pop! arr)\n      (if (&lt;\
    \ (length arr) k)\n          #t\n          (k-loop)))\n    (k-loop))\n  (define\
    \ (remove-neg)\n    (define (remove-neg-loop)\n      (if (&lt; (vector-ref arr\
    \ 0) 0)\n          (vector-pop! arr)\n          #t)\n      (if (&lt; (length arr)\
    \ 1)\n          #t\n          (remove-neg", "  (define (is-max num lst)\n    (cond\
    \ ((empty? lst) #t)\n          ((> num (first lst)) #t)\n          (else #f)))\n\
    \  (define (find-max lst)\n    (if (empty? lst)\n        '()\n        (if (is-max\
    \ (first lst) (rest lst))\n            (cons (first lst) (find-max (rest lst)))\n\
    \            (find-max (rest lst)))))\n  (if (= (length arr) k)\n      arr\n \
    \     (if (= 0 k)\n          '()\n          (maximum (find-max arr) (- k 1)))))\n",
  "  (sort arr >))\n```\n\n```racket\n#lang racket\n", "  (sort (keep-n k (sort &gt;\
    \ arr)) &lt;))\n</code>\nand I would like to know how it could be improved. I\
    \ am especially concerned about the readability of the code.\n\n\nA:\n\nThat's\
    \ a pretty clever solution, but I think it can be improved by using the built-in\
    \ sorting procedures and by performing the entire operation in one pass. Notice\
    \ that <code>sort</code> already has an optional <code>key</code> argument that\
    \ allows us to specify how to sort the items, we can use it to sort the elements\
    \ in <code>arr</code> by the absolute value of the element. Also, it's not necessary\
    \ to keep the elements in <code>res</code> sorted, so I modified the code to append\
    \ the new element to the end of the list and then it's only necessary to remove\
    \ the last element if the list is greater than <code>k</code>.\n<code>(define\
    \ (maximum arr k)\n  (sort (foldr (lambda (x res)\n                 (cond\n  \
    \                 [(&gt; (length res) k)\n                    (list-tail res)]\n\
    \                   [else\n                    (append res (list x))]))\n    \
    \           '()\n               arr)\n        &gt;\n        abs))\n</code>\n",
  "  (define (max-helper arr k lst)\n    (let* ([max (apply max arr)]\n          \
    \ [arr (remove max arr)])\n      (if (= k 1)\n          (append lst (list max))\n\
    \          (max-helper arr (- k 1) (append lst (list max))))))\n  (sort (max-helper\
    \ arr k '()) <))\n", "  (let loop ([arr (sort arr <)])\n    (if (= k 0)\n    \
    \    null\n        (cons (first arr) (loop (rest arr))))))\n", "  (sort (map (\u03BB\
    \ (i) (list (vector-ref arr i) i))\n             (iota k))\n        (\u03BB (a\
    \ b) (< (car a) (car b)))))\n", "  (sort arr >))\n</code>\nThere are a lot of\
    \ examples out there to do this in linear time using a binary heap, but this is\
    \ not what I'm looking for.\nI'm looking for a solution, in Racket, without using\
    \ a binary heap, that is of a more complex time than <code>n log n</code>.\nI\
    \ know of a solution which is <code>n^2</code> (finding the biggest number, removing\
    \ it from the array, then going again until you have <code>k</code> elements),\
    \ but I'm looking for a solution between <code>n log n</code> and <code>n^2</code>.\n\
    Is there such a solution?\n\n\nA:\n\nHere's a simple algorithm that runs in O(k\
    \ * n). It's pretty much the same idea as your O(n^2) solution, except we can\
    \ find the max in O(n) time.\n<code>(define (maximum arr k)\n  (for/list ([i (in-range\
    \ k)])\n    (define max (first arr))\n    (define max-index 0)\n    (for ([(a\
    \ i) (in-list arr)])\n      (when (&gt; a max)\n        (set! max a)\n       \
    \ (set! max-index i)))\n    (set-nth arr max-index (first arr))\n    (set-first\
    \ arr max)\n    max))\n</code>\nThe idea is to find the index of the largest item\
    \ in the array, swap that item with the first item, then recurse on the tail of\
    \ the array. I break up the code into three phases for readability, but you can\
    \ combine them into one loop with no speed penalty.\n", "  (maximum-solver arr\
    \ k '() '()))\n", "  (require rackunit)\n  (check-equal? '() (maximum '() 0))\n\
    \  (check-equal? '() (maximum '() 2))\n  (check-equal? '(0) (maximum '(0) 1))\n\
    \  (check-equal? '(0) (maximum '(0) 2))\n  (check-equal? '(3 0) (maximum '(0 3)\
    \ 2))\n  (check-equal? '(2 0) (maximum '(0 3 2) 2))\n  (check-equal? '(2 1 0)\
    \ (maximum '(0 1 2) 3))\n  (check-equal? '(2 1 0) (maximum '(0 1 2) 4))\n  (check-equal?\
    \ '(4 3 2 1 0) (maximum '(0 1 2 3 4) 5))\n  (check-equal? '(4 3 2 1 0) (maximum\
    \ '(0 1 2 3 4) 6))\n  (check-equal? '(9 8 7 6 5 4 3 2 1 0) (maximum '(0 1 2 3\
    \ 4 5 6 7 8 9) 10))\n  (check-equal? '(9 8 7 6 5 4 3 2 1 0) (maximum '(0 1 2 3\
    \ 4 5 6 7 8 9) 11))\n  (check-equal? '(-1 -2 -3 -4 -5 -6 -7 -8 -9 0) (maximum\
    \ '(0 -1 -2 -3 -4 -5 -6 -7 -8 -9) 10))\n  (check-equal? '(-1 -2 -3 -4 -5 -6 -7\
    \ -8 -9 0) (maximum '(0 -1 -2 -3 -4 -5 -6 -7 -8 -9) 11))\n  (sort (shuffle (list->vector\
    \ (for/list ([i (in-range k)]) 0))) #:key sub1 #:cmp >))\n", '  (sort arr >))',
  "  (define (take n lst)\n    (cond ((= n 0) '())\n          ((null? lst) '())\n\
    \          (else (cons (car lst) (take (- n 1) (cdr lst))))))\n  (define (drop\
    \ n lst)\n    (cond ((= n 0) lst)\n          ((null? lst) '())\n          (else\
    \ (drop (- n 1) (cdr lst)))))\n  (define (helper arr1 arr2)\n    (cond ((null?\
    \ arr1) arr2)\n          ((= (length arr2) k) (helper (cdr arr1) (take k (append\
    \ arr2 (list (car arr1))))))\n          (else (helper (cdr arr1) (append arr2\
    \ (list (car arr1)))))))\n  (helper arr '()))\n", '  (sort arr < :key (cut cadr
    <>)))', "  (cond\n    [(zero? k) '()]\n    [(empty? arr) '()]\n    [else (\n \
    \          (cons (first (sort > arr)) (maximum (rest arr) (- k 1)))\n      )]))\n",
  "  (define (merge left right)\n    (cond ((null? left) right)\n          ((null?\
    \ right) left)\n          ((< (car left) (car right))\n           (cons (car right)\
    \ (merge left (cdr right))))\n          (else\n           (cons (car left) (merge\
    \ (cdr left) right)))))\n  (define (sort list)\n    (if (null? list)\n       \
    \ (list)\n        (let ([l (sort (filter (compose odd? length) (partition-all\
    \ 2 list)))])\n          (merge l (sort (filter (compose even? length) (partition-all\
    \ 2 list)))))))\n  (slice (sort arr) (- (length arr) k) (length arr)))\n", " \
    \ (sort (sort (filter (lambda (x) (&lt; 0 x)) arr) &gt;) &lt; k))\n</code>\nWhat\
    \ should I do to get the tests to run?\n\n\nA:\n\nThe bug was indeed in the code.\
    \  I did not realize that the tests would use the code as is, not wrapped in a\
    \ function.  I needed to add an additional set of parens:\n<code>#lang racket\n",
  "  (define max-heap (make-heap \n                    (lambda (a b) (< a b))\n  \
    \                  (list->heap arr)))\n  (define (maximum-help k)\n    (if (=\
    \ k 0)\n        '()\n        (cons (heap-max max-heap) (maximum-help (- k 1)))))\n\
    \  (maximum-help k))\n ", "  (sort arr #:key (\u03BB (x) (- x))))\n</code>\nA\
    \ couple of people have suggested using <code>take</code> instead of <code>sort</code>,\
    \ but that's actually O(n * log n) and not O(n), which is an important distinction\
    \ in competitive programming.\n", "  (sort arr <))\n", "  (sort > arr))\n", " \
    \ (let loop ([result '()]\n             [arr arr])\n    (if (and (not (empty?\
    \ arr)) (< (length result) k))\n        (loop (insert-sorted (first arr) result)\
    \ (rest arr))\n        result)))\n", "  (sort arr &gt;))\n</code>\nHere is the\
    \ result:\n<code>#lang racket\n", "  (apply max (sorted (take arr k))))\n", " \
    \ (let loop ([i 0] [res null])\n    (cond [(= i k) (reverse res)]\n          [else\n\
    \           (let* ([max (apply max arr)]\n                  [index (index-of arr\
    \ max)]\n                  [arr (list-remove arr max)])\n             (loop (+\
    \ i 1) (cons max res)))])))\n", "  (define (max-sort a b)\n    (if (> a b) #t\
    \ #f))\n  (sorted arr max-sort #:key (lambda (x) x) #:count k))", "  (define (insert\
    \ al a)\n    (cond ((null? al) (list a))\n          ((< a (car al)) (cons a al))\n\
    \          (else (cons (car al) (insert (cdr al) a)))))\n  (define (recur al lst)\n\
    \    (cond ((or (null? lst) (= k (length al))) al)\n          (else (recur (insert\
    \ al (car lst)) (cdr lst)))))\n  (recur '() arr))\n", "  (sort arr &gt;))\n",
  "  (define a-length (length arr))\n  (define (max-arr arr max-lst)\n    (if (null?\
    \ arr)\n        max-lst\n        (let* ([a (car arr)]\n               [max-lst\
    \ (if (&gt; a (car max-lst))\n                            (cons a (drop max-lst\
    \ 1))\n                            max-lst)])\n          (max-arr (cdr arr) max-lst))))\n\
    \  (max-arr arr (take (sort &gt; arr) k)))\n</code>\nBut it seems too complicated\
    \ and also inefficient.\n\n\nA:\n\n<code>#lang racket\n", "  (let loop ([xs (cdr\
    \ arr)] [ys (car arr)])\n    (if (= k 0)\n        ys\n        (let ([mx (apply\
    \ max xs)])\n          (if (> mx (car ys))\n              (let loop ([xs xs] [ys\
    \ (cons mx ys)])\n                (if (or (null? xs) (= k (length ys)))\n    \
    \                ys\n                    (let ([mx (apply max xs)])\n        \
    \              (if (> mx (car ys))\n                          (loop (remove mx\
    \ xs) (cons mx ys))\n                          (loop (remove (car ys) xs) (cdr\
    \ ys))))))\n              (loop (remove (car ys) xs) (cdr ys)))))))\n", "  (let\
    \ ([len (length arr)])\n    (quicksort arr 0 (- len 1))\n    (apply vector-ref\
    \ arr (build-list k (\u03BB (x) (- len x 1))))))\n", "  (let ([lst (sort arr &gt;)])\n\
    \    (vector-&gt;list (subvector lst 0 k))))\n</code>\nExample:\n<code>&gt; (maximum\
    \ (build-vector 100 (lambda (i) (- i))) 3)\n'(99 98 97)\n</code>\n\nIt will be\
    \ better to use <code>vector-sort!</code> with a mutable vector, <code>vector-sort</code>\
    \ returns a new vector, thus less efficient.\nFor example,\n<code>#lang racket\n",
  "  (sort arr >))\n", '  (error "todo"))', "  (sort arr > '() k))\n", "  (define\
    \ (max_for arr i j)\n    (if (>= i j) i\n        (if (< (vector-ref arr i) (vector-ref\
    \ arr j)) (max_for arr j (- j 1)) (max_for arr i (- i 1)))))\n  (define (kmax\
    \ arr k i)\n    (if (>= k 0) (cons (vector-ref arr (max_for arr i (- (vector-length\
    \ arr) 1))) (kmax arr (- k 1) (max_for arr i (- (vector-length arr) 1)))) '()))\n\
    \  (kmax arr k 0))", "  (if (empty? arr)\n      empty\n      (array-sort < (subarray\
    \ arr 0 k))))", "  (sort (take (sort arr >) k) <))\n", "  (define find-max\n \
    \   (lambda (arr k acc)\n      (if (zero? k)\n          acc\n          (let ([max\
    \ (apply max arr)])\n            (find-max (filter (lambda (x) (not (= x max)))\
    \ arr) (- k 1) (cons max acc))))))\n  (find-max arr k null))\n</code>\nAm I missing\
    \ something about Racket or is the solution less performant than it should be?\n\
    Thanks in advance.\n\n\nA:\n\nFirst, the <code>max</code> function is a simple\
    \ function that just returns the max item in an arbitrary sequence. It is a simple\
    \ loop with a single comparison and no branching. There is a lot of overhead in\
    \ calling the function and passing the arguments, but the function itself is very\
    \ simple.\nSecond, it's not really a good practice to use <code>apply</code> to\
    \ call the <code>max</code> function. It would be better to pass the argument\
    \ list directly, which I would do like this:\n<code>(max (car arr) (apply max\
    \ (cdr arr)))\n</code>\nThird, <code>find-max</code> is a pretty complicated loop.\
    \ It is a little better to call <code>find-max</code> with all of the arguments\
    \ in the body of the loop rather than passing an accumulator and returning it.\
    \ You might do something like this:\n<code>(define (find-max arr k acc)\n  (if\
    \ (zero? k)\n      acc\n      (let ([max (max (car arr) (apply max (cdr arr)))])\n\
    \        (find-max (filter (lambda (x) (not (= x max))) arr) (- k 1) (cons max\
    \ acc)))))\n</code>\nIt is probably a better practice to use a tail recursive\
    \ helper function to accomplish the looping, like this:\n<code>(define (find-max\
    \ arr k acc)\n  (define (helper arr k acc)\n    (if (zero? k)\n        acc\n \
    \       (let ([max (max (car arr) (apply max (cdr arr)))])\n          (helper\
    \ (filter (lambda (x) (not (= x max))) arr) (- k 1) (cons max acc)))))\n  (helper\
    \ arr k acc))\n</", "  (define (max-arr k)\n    (if (eq? k 0)\n        '()\n \
    \       (let* ([m (apply max arr)]\n               [m-idx (array-index arr m)])\n\
    \          (cons m (max-arr (- k 1)))\n          )))\n  (max-arr k))\n</code>\n\
    And here's my Racket code, which works but is too slow to pass all the test cases\
    \ (Failed case: [5,-3,2,7,8,-5,4,10,1,9,-4,3,6] 2):\n<code>#lang racket\n", " \
    \ (define (insert-sort lst)\n    (for/fold ([lst '()]) ([x (in-list lst)])\n \
    \     (cond\n        [(empty? lst) (list x)]\n        [(empty? (rest lst)) (cons\
    \ x lst)]\n        [(>= x (car lst)) (cons x lst)]\n        [else (cons (car lst)\
    \ (insert-sort (cons x (cdr lst))))])))\n  (for/list ([x (in-list (insert-sort\
    \ arr))])\n    x))\n", "  (sort arr (lambda (a b) (< a b))))\n", "  (let ([p (flatten\
    \ (for/list ([i (in-range k)])\n                      (for/list ([n (in-range\
    \ (vector-length arr))])\n                        (vector (vector-ref arr n) n))))])\n\
    \    (quicksort p (\u03BB (x y) (> (vector-ref x 0) (vector-ref y 0))))\n    (for/list\
    \ ([i (in-range k)])\n      (vector-ref arr (vector-ref (vector-ref p i) 1)))))\n",
  "  (sort (list-ref arr (- (length arr) k)) <))\n", "  (take k (sort > arr)))\n",
  "  (build-list k\n              (\u03BB (index)\n                (apply max (for/list\
    \ ([index (in-range index (- (length arr) k))])\n                            \
    \ (vector-ref arr index))))))\n</code>\n", "  (for/list ([i (in-range (min k (length\
    \ arr)))])\n    (array-ref arr i)))", "  (printf \"~s\\n\" arr)\n  (printf \"\
    ~s\\n\" k)\n  (vector-sort > arr)\n  (vector-ref arr 0)\n  (vector-ref arr 1)\n\
    \  (vector-ref arr 2)\n  (vector-ref arr 3)\n  (vector-ref arr 4)\n  (printf \"\
    ~s\\n\" (vector-ref arr 0))\n  (printf \"~s\\n\" (vector-ref arr 1))\n  (printf\
    \ \"~s\\n\" (vector-ref arr 2))\n  (printf \"~s\\n\" (vector-ref arr 3))\n  (printf\
    \ \"~s\\n\" (vector-ref arr 4))\n  )\n</code>\nWhen I run <code>(maximum #(5 -1\
    \ 4 -7 2) 3)</code> I expect the output <code>#(5 4 2)</code> but I get an error\
    \ <code>vector-sort: expects type &lt;vector-of-real&gt; as 2nd argument, given:\
    \ #(#(1 2) #(3 4) #(5 6))</code>\n\n\nA:\n\nYou're calling <code>vector-sort</code>\
    \ with the wrong arguments, it expects a procedure that tells how to compare two\
    \ elements, not a boolean.\nIn your case, since you're dealing with numbers, you\
    \ can simply use the <code>&gt;</code> comparison operator:\n<code>(vector-sort\
    \ &gt; arr)\n</code>\nExample:\n<code>(define x (vector 1 2 3 4 5))", "  (if (null?\
    \ arr)\n      '()\n      (define (max-of-first? x)\n        (and (not (null? x))\n\
    \             (cond ((= k 0) #f)\n                   ((null? (cdr x)) #t)\n  \
    \                 ((> (car x) (cadr x)) (max-of-first? (cdr x)))\n           \
    \        (#t #f))))\n    (define (max-of-rest? x)\n      (cond ((null? x) #f)\n\
    \            ((< (car x) (cadr x)) (max-of-rest? (cdr x)))\n            (#t #t)))\n\
    \    (cond ((max-of-first? arr) (cons (car arr) (maximum (cdr arr) (- k 1))))\n\
    \          ((max-of-rest? arr) (maximum (cdr arr) k))\n          (#t (maximum\
    \ (cdr arr) (- k 1))))))\n", "  (sort < arr))\n", "  (apply max (take arr k)))\n\
    </code>\n", "  (define (max-k l)\n    (for/list ([e (in-list l)]) (car e)))\n\
    \  (max-k (for/list ([e (in-list arr)]) (list e))))\n", "  (sort arr >))\n", " \
    \ (define (max-sort arr)\n    (let loop ([arr arr] [result '()])\n      (if (null?\
    \ arr)\n          result\n          (loop (remove max arr) (cons max result)))))\n\
    \  (take (max-sort arr) k))\n</code>\nUpdate:\nThis is a faster solution, but\
    \ the problem is that you can't get a list of the n largest elements.\n<code>#lang\
    \ racket\n", "  (let loop ([i 0] [acc '()])\n    (cond\n      [(= i k)\n     \
    \  (sort > acc)]\n      [(= i (vector-length arr))\n       (sort > acc)]\n   \
    \   [else\n       (loop (+ i 1) (append acc (list (vector-ref arr i))))])))",
  "  (let ([len (vector-length arr)])\n    (define (swap! i j)\n      (let ([temp\
    \ (vector-ref arr i)])\n        (vector-set! arr i (vector-ref arr j))\n     \
    \   (vector-set! arr j temp)))\n    (define (sort! lo hi)\n      (cond\n     \
    \   [(> lo hi) '()]\n        [else\n         (let ([pivot (vector-ref arr (+ lo\
    \ (random (- (+ hi 1) lo))))])\n           (let loop ([i (+ lo 1)] [j hi])\n \
    \            (cond\n               [(> i j)\n                (swap! lo (- j 1))\n\
    \                (sort! lo (- j 1))\n                (sort! (+ j 1) hi)]\n   \
    \            [(< (vector-ref arr i) pivot)\n                (swap! i j)\n    \
    \            (loop (+ i 1) (- j 1))]\n               [else\n                (loop\
    \ (+ i 1) j)])))]))\n    (sort! 0 (- len 1))\n    (vector->list (subvector arr\
    \ 0 k))))\n", "  (if (&lt;= k 0)\n      '()\n      (let loop ([arr arr] [res '()])\n\
    \        (if (&lt;= k (length arr))\n            (loop (remove (apply max arr)\
    \ arr) (cons (apply max arr) res))\n            (reverse res)))))\n", "  (define\
    \ a\n    (sort arr <))\n  (define s\n    (stream a))\n  (let f ((k k) (s s))\n\
    \    (if (= k 0)\n        null\n        (cons (stream-first s)\n             \
    \ (f (- k 1) (stream-rest s))))))", "  (let loop ([accum (list)] [arr arr])\n\
    \    (cond [(zero? k) accum]\n          [(null? arr) accum]\n          [else (loop\
    \ (cons (maximum-in-list (car arr) accum) (rest accum)) (cdr arr))])))", "  (define\
    \ n (length arr))\n  (cond [(= n 0) #f]\n        [(= n 1) arr]\n        [(= n\
    \ k) (sort > arr)]\n        [else\n         (define (extract-max arr)\n      \
    \     (cond [(empty? arr) #f]\n                 [else (cons (apply max arr)\n\
    \                             (remove max arr))]))\n         (define (list-insert\
    \ item lst)\n           (cond [(empty? lst) (list item)]\n                 [(<\
    \ item (first lst)) (cons item lst)]\n                 [else (cons (first lst)\n\
    \                             (list-insert item (rest lst)))]))\n         (define\
    \ (list-push item lst)\n           (list-insert item (cdr lst)))\n         (define\
    \ (list-pop lst)\n           (rest lst))\n         (define (build-heap arr)\n\
    \           (define (iter k n)\n             (cond [(<= k n)\n               \
    \     (define (left-child k)\n                      (+ k 1))\n               \
    \     (define (right-child k)\n                      (+ k 2))\n              \
    \      (define (swap lst i j)\n                      (define temp (list-ref lst\
    \ i))\n                      (set-car! (list-ref lst i) (list-ref lst j))\n  \
    \                    (set-car! (list-ref lst j) temp))\n                    (define\
    \ (adjust lst k n)\n                      (let ([a (left-child k)]\n         \
    \                   [b (right-child k)])\n                        (cond [(> a\
    \ n) #f]\n                              [(> b n) (when (and (list-ref lst k)\n\
    \                                                  (< (list-ref lst k) (list-ref\
    \ lst a)))\n                                        (swap lst k a))]\n       \
    \                       [else (when (and (list-ref lst k)\n                  \
    \                             (< (list-ref lst k) (list-ref lst a))\n        \
    \                                       (< (list-ref lst a) (list-ref lst b)))\n\
    \                                       (swap lst k b))\n                    \
    \                (when (and (list-ref lst k", "  (sort (flatten (partition k arr))\
    \ #:key (compose last identity) #:cmp >))\n", "  (sort arr #:key (\u03BB (x) (-\
    \ x)) #:count k #:from-end? #t))\n", "  (match k\n    [0 '()]\n    [else\n   \
    \  (define (max-idx arr)\n       (define (max-idx-r arr max)\n         (match\
    \ arr\n           [(cons x (cons y xs))\n            (if (> x y)\n           \
    \     (max-idx-r (cons y xs) 0)\n                (max-idx-r xs (+ max 1)))]\n\
    \           [empty max]))\n       (max-idx-r arr 0))\n     (define (remove-max\
    \ arr)\n       (match arr\n         [(cons _ xs) (cons (list-ref xs (max-idx xs))\
    \ (remove-max xs))]\n         [empty '()]))\n     (define (remove-maxes arr k)\n\
    \       (if (= k 0) arr\n           (remove-maxes (remove-max arr) (- k 1))))\n\
    \     (remove-maxes arr k)]))\n", "  (define bst (void))\n  (for ([i (in-range\
    \ (length arr))])\n    (match (bst-search bst (vector-ref arr i))\n      [(void)\
    \ (bst-insert! bst (vector-ref arr i))]\n      [node (bst-increment! node)]))\n\
    \  (define (next-max bst)\n    (match bst\n      [(void) '()]\n      [node (define\
    \ (go bst)\n               (match bst\n                 [(void) node]\n      \
    \           [child (go (bst-right child))]))\n             (go (bst-right node))]))\n\
    \  (define (helper bst acc)\n    (cond [(< (length acc) k)\n           (helper\
    \ (next-max bst) (cons (bst-data bst) acc))]\n          [else acc]))\n  (helper\
    \ bst '()))\n", "  (quicksort arr)\n  (take (reverse arr) k))\n", "  (if (<= k\
    \ (length arr))\n      (list-ref (sort (build-list (length arr) #'identity) <)\
    \ (- (length arr) k))\n      (error \"arr is too short\")))", "  (map car (reverse\
    \ (sort (map (curry cons (length arr)) arr)\n                          (\u03BB\
    \ (x y)\n                            (cond [(< (car x) (car y)) #t]\n        \
    \                          [(> (car x) (car y)) #f]\n                        \
    \          [(> (cdr x) (cdr y)) #t]\n                                  [(< (cdr\
    \ x) (cdr y)) #f]))))))", "  (cond [(empty? arr) '()]\n        [(= k 0) '()]\n\
    \        [(= k 1) (list (apply max arr))]\n        [else\n         (let* ([first\
    \ (first arr)]\n                [rest (rest arr)]\n                [rest-max (maximum\
    \ rest (- k 1))])\n           (cond [(> first (first rest-max)) (cons first rest-max)]\n\
    \                 [else (cons (first rest-max) (maximum (cons first (rest rest-max))\
    \ (- k 1)))]))]))\n", "  (if (<= k (length arr))\n      (take (sort (lambda (x\
    \ y)\n                    (> x y))\n                  arr)\n            k)\n \
    \     '(-1)))\n", "  (define (heapify-down arr i)\n    (let ((left-child (min\
    \ (add1 (* 2 i)) (sub1 (vector-length arr))))\n          (right-child (min (add1\
    \ (* 2 i 1)) (sub1 (vector-length arr)))))\n      (if (&gt;= (vector-ref arr left-child)\
    \ (vector-ref arr right-child))\n          (if (&gt; (vector-ref arr left-child)\
    \ (vector-ref arr i))\n              (begin (vector-swap! arr i left-child)\n\
    \                     (heapify-down arr left-child))\n              (void))\n\
    \          (if (&gt; (vector-ref arr right-child) (vector-ref arr i))\n      \
    \        (begin (vector-swap! arr i right-child)\n                     (heapify-down\
    \ arr right-child))\n              (void)))))\n  (define (heapify-up arr i)\n\
    \    (let ((parent (quotient (- i 1) 2)))\n      (if (&gt; (vector-ref arr i)\
    \ (vector-ref arr parent))\n          (begin (vector-swap! arr i parent)\n   \
    \              (heapify-up arr parent))\n          (void))))\n  (define (build-heap\
    \ arr)\n    (let loop ((i (quotient (- (vector-length arr) 1) 2)))\n      (when\
    \ (&gt;= i 0)\n        (heapify-down arr i)\n        (loop (sub1 i)))))\n  (define\
    \ (max-heap-sort arr)\n    (let loop ((i (sub1 (vector-length arr))))\n      (when\
    \ (&gt;= i 0)\n        (vector-swap! arr 0 i)\n        (heapify-down arr 0)\n\
    \        (loop (sub1 i)))))\n  (define (max-heap-k arr k)\n    (let ((heap (make-vector\
    \ k 0)))\n      (vector-set! heap 0 (vector-ref arr 0))\n      (let loop ((i 1))\n\
    \        (when (&lt; i (vector-length arr))\n          (if (&gt; (vector-ref arr\
    \ i) (vector-ref heap 0))", "  (cond [(zero? k) empty]\n        [(= 1 (length\
    \ arr)) arr]\n        [else (cons (max-element arr) (maximum (remove (max-element\
    \ arr) arr) (- k 1)))]))\n", "  (if (< k 1)\n      (display \"Invalid K\")\n \
    \     (define (max-helper arr k new-arr prev-arr)\n        (if (null? arr)\n \
    \           new-arr\n            (max-helper (cdr arr) k (append new-arr (cons\
    \ (max (car arr) (max-item prev-arr)) prev-arr)) (remove (max (car arr) (max-item\
    \ prev-arr)) prev-arr))))\n        (max-helper arr k '() arr)))\n", "  (define\
    \ tmp (sort arr >))\n  (for/list ([e (in-range k)])\n    (list-ref tmp e)))\n",
  "  (define (aux arr k acc)\n    (if (or (= k 0) (empty? arr))\n        acc\n   \
    \     (let ((max (max (first arr) (max (rest arr)))))\n          (aux (remove\
    \ max arr) (- k 1) (cons max acc)))))\n  (reverse (aux arr k '())))\n", "  (define\
    \ (merge-sort lst)\n    (letrec ([merge (lambda (left right)\n               \
    \      (cond [(empty? left) right]\n                           [(empty? right)\
    \ left]\n                           [(< (first left) (first right)) (cons (first\
    \ left) (merge (rest left) right))]\n                           [else (cons (first\
    \ right) (merge left (rest right)))]))]\n            [split (lambda (x)\n    \
    \                 (cond [(empty? x) (values (list) (list))]\n                \
    \           [else (let ([mid (quotient (length x) 2)])\n                     \
    \              (let ([left (build-list mid (\u03BB (i) (list-ref x i)))]\n   \
    \                                      [right (build-list (- (length x) mid) (\u03BB\
    \ (i) (list-ref x (+ i mid))))])\n                                     (values\
    \ left right)))]))]\n            [merge-sort-helper (lambda (x)\n            \
    \                     (cond [(empty? x) (list)]\n                            \
    \           [(zero? (length x)) x]\n                                       [else\
    \ (let-values ([(left right) (split x)])\n                                   \
    \            (merge (merge-sort-helper left) (merge-sort-helper right)))]))])\n\
    \      (merge-sort-helper lst)))\n  (take (merge-sort arr) k))\n", "  (take (sort\
    \ arr #:key #(-) #:mode 'in-place) k))\n", "  (match arr\n    ['() _] '()\n  \
    \  [_ 0] '()\n    [(-1 +2) _] (-1 2)\n    [_ _] (-1 2)))\n", "  (letrec ([flatten\
    \ (lambda (ls)\n                      (cond\n                        [(null? ls)\
    \ (list)]\n                        [(not (list? (car ls))) (cons (car ls) (flatten\
    \ (cdr ls)))]\n                        [else (append (flatten (car ls)) (flatten\
    \ (cdr ls)))]))]\n           [merge (lambda (ls1 ls2)\n                    (cond\n\
    \                      [(null? ls1) ls2]\n                      [(null? ls2) ls1]\n\
    \                      [(> (car ls1) (car ls2)) (cons (car ls1) (merge (cdr ls1)\
    \ ls2))]\n                      [else (cons (car ls2) (merge ls1 (cdr ls2)))]))]\n\
    \           [pop (lambda (ls1 ls2)\n                  (cond\n                \
    \    [(null? ls1) ls2]\n                    [(null? ls2) ls1]\n              \
    \      [(> (car ls1) (car ls2)) (cons (car ls1) (pop (cdr ls1) ls2))]\n      \
    \              [else (cons (car ls2) (pop ls1 (cdr ls2)))]))]\n           [sort\
    \ (lambda (ls)\n                   (if (= (length ls) 1)\n                   \
    \    ls\n                       (let ([left (take ls (/ (length ls) 2))]\n   \
    \                          [right (drop ls (/ (length ls) 2))])\n            \
    \             (merge (sort left) (sort right)))))]\n           [take (lambda (ls\
    \ n)\n                   (cond\n                     [(zero? n) (list)]\n    \
    \                 [(null? ls) (list)]\n                     [else (cons (car ls)\
    \ (take (cdr ls) (- n 1)))]))]\n           [drop (lambda (ls n)\n            \
    \       (cond\n                     [(zero? n) ls]\n                     [(null?\
    \ ls) (list)]\n                     [else (drop (cdr ls) (- n 1))]))])\n    (let\
    \ ([flatten-arr (flatten arr)])\n      (take (sort flatten-arr) k))))", "  (let\
    \ loop ([arr arr] [k k] [acc '()])\n    (if (zero? k)\n        acc\n        (loop\
    \ (remove-max arr) (- k 1) (cons (max arr) acc)))))\n", "  (define len (vector-length\
    \ arr))\n  (define (max-heapify arr i)\n    (define l (vector-ref arr (+ i 1)))\n\
    \    (define r (vector-ref arr (+ i 2)))\n    (define (swap arr i j)\n      (let\
    \ ((tmp (vector-ref arr i)))\n        (vector-set! arr i (vector-ref arr j))\n\
    \        (vector-set! arr j tmp)\n        arr))\n    (if (and (&lt; i (- len 1))\n\
    \             (&gt; l (vector-ref arr i))\n             (&gt; r (vector-ref arr\
    \ i)))\n        (cond ((&gt; l r) (swap arr i (+ i 1)))\n              (else (swap\
    \ arr i (+ i 2))))\n        arr))\n  (define (heapify arr)\n    (define n (quotient\
    \ (- (vector-length arr) 1) 2))\n    (for ([i n])\n      (max-heapify arr (- i\
    \ 1)))\n    arr)\n  (define (extract-max arr)\n    (vector-set! arr 0 (vector-ref\
    \ arr (- (vector-length arr) 1)))\n    (vector-set! arr (- (vector-length arr)\
    \ 1) 0)\n    (heapify arr))\n  (define max-arr (make-vector k 0))\n  (for ([i\
    \ k])\n    (vector-set! max-arr i (vector-ref arr i)))\n  (heapify max-arr)\n\
    \  (for ([i k] [j (+ k 1)])\n    (if (&gt; (vector-ref arr j) (vector-ref max-arr\
    \ 0))\n        (begin\n          (vector-set! max-arr 0 (vector-ref arr j))\n\
    \          (heapify max-arr))))\n  max-arr)\n</code>\nThe code works for the example,\
    \ but I don't know how to run it automatically on test cases with Racket.\n\n\n\
    A:\n\nYou can do it by following these steps:\n\nOpen the Scripts Tab;\nSelect\
    \ the <code>Racket</code> language;\nType (copy-paste) the code there and run\
    \ it;\n\nThe code is running automatically", "  (let ([q (build-max-heap arr)])\n\
    \    (let loop ([k (sub1 k)] [acc (list (list-ref q 0))])\n      (if (zero? k)\n\
    \          acc\n          (loop (sub1 k) (cons (remove-max q) acc))))))\n", " \
    \ (sort arr > (sublist arr 0 k)))\n", "  (make-list k (lambda (i) (exact->inexact\
    \ (max (list-ref arr i) (list-ref arr (add1 i)))))))\n", "  (apply max (take arr\
    \ k)))\n</code>\n", "  (cond [(empty? arr) empty]\n        [(or (= k 0)\n    \
    \         (= k (length arr))) arr]\n        [else (define max (apply max arr))\n\
    \              (define remain-arr (filter (lambda (x) (not (= x max))) arr))\n\
    \              (cons max (maximum remain-arr (- k 1)))]))", "  (if (zero? k) '()\n\
    \      (define max-idx (max-index arr))\n      (cons (vector-ref arr max-idx)\
    \ (maximum (remove arr max-idx) (- k 1)))))\n", "  (if (= k 1)\n      (list (vector-ref\
    \ arr 0))\n      (let ([max (vector-ref arr 0)])\n        (for ((i (in-range (vector-length\
    \ arr))))\n          (set! max (max max (vector-ref arr i))))\n        (cons max\
    \ (maximum arr (- k 1))))))\n", "  (let ([arr (sort arr >)])\n    (take arr k)))\n",
  "  (sort arr <))\n```\n\n```", "  (apply min arr))\n", "  (define n (length arr))\n\
    \  (define (maximum-helper arr i)\n    (match arr\n      [(list) '()]\n      [(cons\
    \ elt rest)\n       (let ((pos (+ i k)))\n         (if (>= pos n)\n          \
    \   (maximum-helper rest (- pos n))\n             (cons elt (maximum-helper rest\
    \ (+ i 1)))))\n       ]))\n  (maximum-helper arr 0))\n", "  (sort (list-of k (array-random-element\
    \ arr)) >))\n", "  (displayln (car (sort arr #:key cdr #:key>? > #:key<? < #:key=?\
    \ equal?))))\n", "  (cond\n    [(empty? arr) '()]\n    [(= k 0) '()]\n    [else\n\
    \     (quicksort arr)])\n  )\n", "  (letrec ([len (length arr)]\n           [take?\
    \ (lambda (n) (and (>= n k) (odd? (+ n 1))))]\n           [heapify (lambda (a\
    \ n)\n                      (for ([i (in-range (quotient n 2) -1 -1)])\n     \
    \                   (let ([largest (if (< (vector-ref a i) (vector-ref a (+ i\
    \ 1)))\n                                           (+ i 1)\n                 \
    \                          i)])\n                          (let ([temp (vector-ref\
    \ a i)])\n                            (vector-set! a i (vector-ref a largest))\n\
    \                            (vector-set! a largest temp))))\n               \
    \       a)]\n           [loop (lambda (a n)\n                   (if (take? n)\n\
    \                       (vector-ref a 0)\n                       (let ([temp (vector-ref\
    \ a 0)])\n                         (vector-set! a 0 (vector-ref a n))\n      \
    \                   (vector-set! a n temp)\n                         (heapify\
    \ a (- n 1))\n                         (loop a (- n 1)))))]\n           [res (let\
    \ ([temp (make-vector len)]\n                     [0 (in-exact-integer-sqrt len)])\n\
    \                  (let ([col (quotient len 0)])\n                    (for ([i\
    \ (in-range 0 col)])\n                      (vector-set! temp (+ (* i 0) i)\n\
    \                                    (vector-ref arr (+ (* i 0) i))))\n      \
    \              (for ([i (in-range (* col 0) len)])\n                      (vector-set!\
    \ temp (+ (* col 0) i)\n                                    (vector-ref arr (+\
    \ (* col 0) i))))\n                    (heapify temp (- len 1))\n            \
    \        (loop temp (- len 1))))])\n    res))\n</code>\n", "  (let ([curr-max\
    \ (array-ref arr 0)])\n    (for/list ([i (in-range (array-length arr))])\n   \
    \   (let ([x (array-ref arr i)])\n        (if (< x curr-max)\n            (values\
    \ curr-max (array-set! arr i curr-max))\n            (values x (array-set! arr\
    \ i curr-max)))))))", "  (apply max (take arr k)))\n", "  (sort (map (\u03BB (x)\
    \ (/ x 1000)) arr) <))\n", "  (list-of 1 2 3 4 5))\n", "  (displayln (list-ref\
    \ arr k)))\n", "  (let ([q (make-quantile-sample-from (vector->list arr))])\n\
    \    (list->vector (hash-get q 'maximum k))))\n", "  (letrec ([helper (lambda\
    \ (arr k)\n                   (if (zero? k)\n                       (values (list)\
    \ arr)\n                       (let* ([pivot (first arr)]\n                  \
    \            [less (filter (lambda (x) (< x pivot)) arr)]\n                  \
    \            [greater (filter (lambda (x) (> x pivot)) arr)]\n               \
    \               [pivot-count (length (filter (lambda (x) (= x pivot)) arr))])\n\
    \                         (let ([less-lst (in-values helper less (- k pivot-count))]\n\
    \                               [greater-lst (in-values helper greater (- k pivot-count))])\n\
    \                           (values (append (first less-lst) (list pivot) (first\
    \ greater-lst))\n                                   (append (second less-lst)\
    \ (second greater-lst))))))))])\n    (first (helper arr k))))\n```\n\n#### Complexity\n\
    \n- Time: `O(n)`\n- Space: `O(n)`", "  (define maxs (make-vector k (void)))\n\
    \  (define (insert-sorted value index)\n    (define (insert-sorted-helper v i)\n\
    \      (let loop ([i i])\n        (if (= i k)\n            (values (list->vector\
    \ (append (sublist (vector->list maxs) 0 (- k 1))\n                          \
    \                (list v)))\n                    (add1 i))\n            (if (>=\
    \ v (vector-ref maxs i))\n                (values (vector-copy maxs) i)\n    \
    \            (loop (add1 i))))))\n    (values (apply vector (append (sublist (vector->list\
    \ maxs) 0 index)\n                                  (list value)\n           \
    \                       (sublist (vector->list maxs) (add1 index))))\n       \
    \     (add1 index)))\n  (define (init-maxs arr k)\n    (define (init-maxs-helper\
    \ arr index m)\n      (if (= index k)\n          m\n          (let-values ([(maxs\
    \ i) (insert-sorted (car arr) (vector-ref m index))])\n            (init-maxs-helper\
    \ (cdr arr) i maxs))))\n    (init-maxs-helper arr 0 (make-vector k 0)))\n  (define\
    \ (find-max arr index)\n    (if (zero? index)\n        (find-max arr (add1 index))\n\
    \        (if (>= (car arr) (vector-ref maxs index))\n            (find-max arr\
    \ (add1 index))\n            index)))\n  (define (find-maxs arr)\n    (if (zero?\
    \ (vector-length arr))\n        maxs\n        (let-values ([(maxs i) (insert-sorted\
    \ (car arr) (find-max arr 0))])\n          (find-maxs (cdr arr) maxs))))\n  (vector->list\
    \ (find-maxs arr (init-maxs arr k))))\n", "  (list (list-ref arr 2)\n        (list-ref\
    \ arr 5)\n        (list-ref arr 8)\n        (list-ref arr 11)\n        (list-ref\
    \ arr 14)))\n</code>\n", "  (sort arr &gt;))\n", "  (sort arr <\n        #:key\
    \ (\u03BB (x) x)))\n</code>\nThe <code>sort</code> function takes a key function\
    \ as an optional keyword argument. The key function transforms each element of\
    \ the array before it is sorted. In this case, we simply want the identity function.\n\
    If you want a list of the maximum <code>k</code> elements, rather than a sorted\
    \ list, then you'll need to iterate from <code>0</code> to <code>k</code> and\
    \ extract elements from the sorted list.\n<code>#lang racket\n", "  (sort (sublist\
    \ arr 0 k) >))\n", "  (sort arr (lambda (a b)\n              (> a b))))\n", " \
    \ (sort arr &gt;))\n", "  (let ([n (length arr)])\n    (if (or (&lt; n k) (= 0\
    \ k))\n        '()\n        (let loop ([arr (sort &gt; arr)] [n (sub1 n)] [k (sub1\
    \ k)])\n          (if (= 0 k)\n              (list (vector-ref arr n))\n     \
    \         (cons (vector-ref arr n) (loop arr (sub1 n) (sub1 k))))))))\n</code>\n",
  "  (sort (length arr) >= arr))\n", "  (define sorted-arr (sort arr <))\n  (reverse\
    \ (sublist sorted-arr 0 k)))\n", "  (define len (vector-length arr))\n  (if (<=\
    \ len k)\n      (vector-sort (lambda (a b) (> a b)) arr)\n      (define pivot\
    \ (vector-ref arr 0))\n      (define left (make-vector 0 0))\n      (define right\
    \ (make-vector 0 0))\n      (vector-for-each\n       (lambda (item)\n        \
    \ (if (<= item pivot)\n             (vector-append left (vector item))\n     \
    \        (vector-append right (vector item))))\n       arr)\n      (define right-len\
    \ (vector-length right))\n      (if (<= right-len k)\n          (vector-append\n\
    \           (maximum left (- k right-len))\n           right)\n          (maximum\
    \ right k))))\n", "  (hash-of-values (count-array arr) k))\n", "  (let ([lst (sort\
    \ arr >)])\n    (sublist lst 0 k)))\n", "  (sort (sublist arr k) >))\n", "  (begin\n\
    \    (define (less? a b)\n      (cond\n        [(< a b) #t]\n        [else #f]))\n\
    \    (define (partition arr p q)\n      (let loop ([left p] [right (add1 q)])\n\
    \        (cond\n          [(> left right) left]\n          [(less? (vector-ref\
    \ arr left) (vector-ref arr right))\n           (begin\n             (vector-swap!\
    \ arr left right)\n             (loop (add1 left) (sub1 right)))]\n          [else\
    \ (loop left (sub1 right))])))\n    (define (quicksort arr p q)\n      (cond\n\
    \        [(> p q) #t]\n        [else\n         (let ([mid (partition arr p q)])\n\
    \           (quicksort arr p (sub1 mid))\n           (quicksort arr (add1 mid)\
    \ q))]))\n    (define (build-list arr p q)\n      (cond\n        [(> p q) null]\n\
    \        [else\n         (cons (vector-ref arr p) (build-list arr (add1 p) q))]))\n\
    \    (quicksort arr 0 (sub1 (vector-length arr)))\n    (build-list arr 0 (sub1\
    \ k))))\n", "  (let* ([len (vector-length arr)]\n         [table (make-vector\
    \ len #f)]\n         [max (vector-ref arr 0)])\n    (vector-set! table 0 (list\
    \ (vector-ref arr 0)))\n    (let loop ([i 1])\n      (when (< i len)\n       \
    \ (vector-set! table i (vector-ref table (- i 1)))\n        (let ([n (vector-ref\
    \ arr i)])\n          (if (> n max)\n              (progn (vector-set! table i\
    \ (cons n (vector-ref table (- i 1))))\n                     (set! max n))\n \
    \             (let loop2 ([count 0] [el (vector-ref table (- i 1))])\n       \
    \         (if (< count k)\n                    (if (< n (car el))\n          \
    \              (progn (set! el (cdr el))\n                               (loop2\
    \ (+ count 1) el))\n                        (vector-set! table i (cons n el)))\n\
    \                    (vector-set! table i (vector-ref table (- i 1))))))\n   \
    \       (loop (+ i 1))))))\n  (vector-ref table (- (vector-length table) 1)))\n",
  "  (define (helper arr k acc)\n    (cond [(empty? arr) acc]\n          [(<= k 0)\
    \ acc]\n          [else (helper (cdr arr) (-- k) (cons (max (car arr) (car acc))\
    \ (cdr acc)))]))\n  (let ([acc (make-list k)])\n    (helper arr k acc)))", " \
    \ (sort arr >))\n```\n### Test Cases\n```", "  (cond\n    [(empty? arr) '()]\n\
    \    [(<= k 0) '()]\n    [else\n     (fold\n      (\u03BB (acc cur)\n        (if\
    \ (and (pair? acc) (pair? cur))\n            (if (> (car cur) (car acc))\n   \
    \             (cons (car cur) (append (cdr acc) (cdr cur)))\n                (cons\
    \ (car acc) (append (cdr acc) (cdr cur))))\n            cur))\n      (first arr)\
    \ (rest arr))]))\n", "  (define (remove-at lst n)\n    (cond\n      [(null? lst)\
    \ lst]\n      [(= n 0) (cdr lst)]\n      [else (cons (car lst) (remove-at (cdr\
    \ lst) (- n 1)))]))\n  (define (find-min lst)\n    (if (null? (cdr lst))\n   \
    \     (car lst)\n        (if (< (car lst) (car (cdr lst)))\n            (find-min\
    \ lst)\n            (find-min (cdr lst)))))\n  (define (delete-min lst)\n    (cond\n\
    \      [(null? lst) lst]\n      [(= (car lst) (find-min lst)) (cdr lst)]\n   \
    \   [else (cons (car lst) (delete-min (cdr lst)))]))\n  (define (max-k lst k)\n\
    \    (if (= k 0)\n        '()\n        (cons (find-min lst) (max-k (delete-min\
    \ lst) (- k 1)))))\n  (max-k arr k))\n", '  (sort arr #:key (compose1 (flip apply
    (sub1 0)) (sub1 0)) #:descending? #t))', "  (sort (take (reverse arr) k) <))\n",
  "  (apply max arr k))\n", "  (let* ([sorted (sort arr <=)]\n         [sorted-k (take\
    \ k sorted)])\n    (reverse sorted-k)))\n", "  (sort arr #&gt;&gt; (take k)))\n",
  "  (for/fold ([max-k '()])\n            ([el (in-list arr)])\n            (if (<=\
    \ (length max-k) k)\n                (if (> (length max-k) 0)\n              \
    \      (append (list el) (filter (lambda (x) (> el x)) max-k))\n             \
    \       (list el))\n                (filter (lambda (x) (> el x)) max-k))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
