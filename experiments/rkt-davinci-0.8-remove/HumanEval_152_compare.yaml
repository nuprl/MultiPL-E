name: HumanEval_152_compare
language: rkt
prompt: "#lang racket\n\n;; I think we all remember that feeling when the result of\
  \ some long-awaited\n;; event is finally known. The feelings and thoughts you have\
  \ at that moment are\n;; definitely worth noting down and comparing.\n;; Your task\
  \ is to determine if a person correctly guessed the results of a number of matches.\n\
  ;; You are given two arrays of scores and guesses of equal length, where each index\
  \ shows a match. \n;; Return an array of the same length denoting how far off each\
  \ guess was. If they have guessed correctly,\n;; the value is 0, and if not, the\
  \ value is the absolute difference between the guess and the score.\n;; example:\n\
  (define (compare game guess)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare))\n\
  \    (check-equal? (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0\
  \ 0 0 3 3))\n    (check-equal? (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0))\
  \ (list 0 0 0 0 0 0))\n    (check-equal? (candidate (list 1 2 3) (list -1 -2 -3))\
  \ (list 2 4 6))\n    (check-equal? (candidate (list 1 2 3 5) (list -1 2 3 4)) (list\
  \ 2 0 0 1))\n))\n\n(test-humaneval)"
completions: ["  (for/list ([i (in-range (length game))])\n    (abs (- (vector-ref\
    \ game i) (vector-ref guess i)))))\n", "  (for/list ([g (in-list game)]\n    \
    \         [q (in-list guess)])\n    (abs (- g q))))\n", "  (map (\u03BB (g u)\
    \ (if (= g u) 0 (abs (- g u)))) game guess))\n", "\t(map abs (- game guess)))\n",
  "  (if (&gt; game guess) (- game guess) (- guess game)))\n", "  (for/list ([a (in-list\
    \ game)]\n             [b (in-list guess)])\n    (abs (- a b))))", "  (map (\u03BB\
    \ (game-score guess-score) \n         (cond ((= game-score guess-score) 0)\n \
    \              (else (abs (- game-score guess-score)))))\n       game guess))\n",
  "  (for/list ([x game] [y guess]) (if (= x y) 0 (abs (- x y)))))\n", "  (map abs\
    \ (- game guess)))\n", "  (for/list ([g game] [u guess]) (abs (- g u))))\n", " \
    \ (map abs (- game guess)))\n", "  (map abs (- game guess)))\n", "  (map abs (map\
    \ - game guess)))\n", '  (map abs (- game guess)))', "  (for/list ([i (in-range\
    \ (length game))])\n    (abs (- (list-ref game i) (list-ref guess i)))))\n", " \
    \ (define (make-negative n) (- 0 n))\n  (map (lambda (game-score guess-score)\n\
    \         (if (= game-score guess-score) 0\n             (make-negative (abs (-\
    \ game-score guess-score)))))\n       game guess))\n", "  (for*/list ([g game]\
    \ [s guess])\n    (let ([diff (- g s)])\n      (cond\n        [(zero? diff) 0]\n\
    \        [else (abs diff)]))))\n", "  (map (lambda (game-cell guess-cell)\n  \
    \       (abs (- game-cell guess-cell)))\n       game guess))\n", "  (map (lambda\
    \ (g s)\n         (if (= g s)\n             0\n             (abs (- g s))))\n\
    \       guess\n       game))", "   (map (lambda (g s)\n           (if (= g s)\n\
    \               0\n               (abs (- g s)))) game guess))\n", "  (map abs\
    \ (map - game guess)))\n", "  (for*/list ([(list s g) (zip game guess)])\n   \
    \ (cond [(= s g) 0]\n          [else (abs (- s g))])))\n</code>\nwhen I run the\
    \ code and input\n<code>(compare '(1 3 5) '(2 3 6))\n</code>\nI get error\n<code>application:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: (list 2 3 6)\n  arguments...: [none]\n</code>\nI am a beginner and I\
    \ would appreciate if someone could help me to identify the problem in my code.\n\
    \n\nA:\n\nThere are a few issues here, but I'm not sure which one you're trying\
    \ to fix:\n\nFirst, the result should be a list of <code>0</code>s or <code>1</code>s,\
    \ not <code>0</code>s or <code>-1</code>s. I think this was a simple mistake in\
    \ the question.\nSecond, you should use <code>cond</code> not <code>cond-&gt;</code>.\
    \ The latter is used when you have expressions that need to be evaluated, not\
    \ values that need to be compared. See the Racket documentation on cond and cond-&gt;.\n\
    Third, the result should be an <code>listof integer</code>, not an <code>integer</code>.\
    \ <code>integer</code> is a primitive type, while <code>listof integer</code>\
    \ is a list of integers. You can't compare a list to an integer.\n\nHere's the\
    \ corrected code:\n<code>#lang racket\n", "  (map (lambda (pair)\n         (if\
    \ (equal? (car pair) (cadr pair))\n             0\n             (abs (- (car pair)\
    \ (cadr pair)))))\n       (zip game guess)))\n</code>\nI tried to compare two\
    \ lists and return a new list with the number I want. So, for example, the input:\n\
    <code>(compare '(1 2 3) '(2 3 1))\n</code>\nshould return:\n<code>'(1 0 2)\n</code>\n\
    But, in this case, it returns:\n<code>'(#&lt;procedure:%map&gt; #&lt;procedure:%map&gt;\
    \ #&lt;procedure:%map&gt;)\n</code>\nCan you please help me?\nBy the way, the\
    \ <code>zip</code> function is the following:\n<code>(define (zip a b)\n  (if\
    \ (null? a)\n      '()\n      (cons (list (car a) (car b))\n            (zip (cdr\
    \ a) (cdr b)))))\n</code>\n\n\nA:\n\nJust a little nit, but in your <code>map</code>\
    \ procedure you have this:\n<code>(if (equal? (car pair) (cadr pair))\n</code>\n\
    Where it should be this:\n<code>(if (equal? (car pair) (cadr pair))\n</code>\n\
    Also, you're using <code>abs</code> incorrectly, it's not a function that accepts\
    \ two arguments, it only accepts one:\n<code>(abs (- (car pair) (cadr pair)))\n\
    </code>\n", "  (for/list ([(list g) (in-list (zip game guess))])\n           \
    \ (cond [(zero? g) 0]\n                  [else (abs (- g (cdr g)))])))\n</code>\n\
    \n<code>#lang racket", "  (for/list ((g game) (q guess))\n    (if (= g q)\n  \
    \      0\n        (abs (- g q)))))", "  (for/list ([i (in-range (length game))])\n\
    \    (if (= (list-ref game i) (list-ref guess i))\n        0\n        (- (list-ref\
    \ game i) (list-ref guess i)))))\n", "  (for/list ([g game] [g2 guess])\n    (abs\
    \ (- g g2))))\n", "    (local [(define results\n            (map (\u03BB (x) (cond\
    \ [(= (car x) (cadr x)) 0]\n                            [else (abs (- (car x)\
    \ (cadr x)))]))\n                (map list game guess)))]\n        results))\n",
  "  (for/list ([g game] [n guess])\n    (if (= g n)\n        0\n        (abs (- g\
    \ n)))))\n", "  (define (iter game guess result)\n    (if (null? game)\n     \
    \   result\n        (iter (cdr game) (cdr guess)\n              (cons (abs (-\
    \ (car game) (car guess))) result))))\n  (reverse (iter game guess null)))\n",
  "  (map abs (map-indexed - game guess)))\n", "  (if (= (length game) (length guess))\n\
    \      (map (lambda (g1 g2)\n             (cond [(= g1 g2) 0]\n              \
    \     [else (abs (- g1 g2))]))\n           game guess)\n      '()))\n", "  (map\
    \ abs (- game guess)))\n", "  (define (f g)\n    (cond [(zero? g) 0]\n       \
    \   [(> g 0) g]\n          [else (- g)]))\n  (map (lambda (g score) (f (- score\
    \ g))) game guess))\n", "  (for/list ([i (in-range (length game))])\n    (cond\n\
    \      [(= (list-ref game i) (list-ref guess i)) 0]\n      [else (abs (- (list-ref\
    \ game i) (list-ref guess i)))])))", "  (map (\u03BB (x y) \n         (cond ((and\
    \ (&gt;= (car x) 0) (&gt;= (cdr x) 0))\n                (if (or (equal? (car x)\
    \ (car y)) (equal? (cdr x) (cdr y)))\n                    0\n                \
    \    (if (not (or (equal? (car x) (cdr x)) (equal? (car y) (cdr y))))\n      \
    \                  (if (equal? (car x) (car y))\n                            (abs\
    \ (- (cdr x) (cdr y)))\n                            (abs (- (car x) (car y))))\n\
    \                        (if (equal? (car x) (cdr x))\n                      \
    \      (min (abs (- (car x) (car y))) (abs (- (car x) (cdr y))))\n           \
    \                 (min (abs (- (cdr x) (car y))) (abs (- (cdr x) (cdr y))))))))\n\
    \               (else 0)))\n       game guess))\n", "  (map (\u03BB (g r) (if\
    \ (= g r) 0 (abs (- g r)))) game guess))\n", "  (for/list ([g (in-list game)]\n\
    \             [g2 (in-list guess)])\n    (cond\n      [(equal? g g2) 0]\n    \
    \  [else (abs (- g g2))])))", "  (map (lambda (a b)\n         (cond\n        \
    \   [(= a b) 0]\n           [else (abs (- a b))]))\n       game guess))\n", " \
    \ (map (\u03BB (g) (abs (- g))) game guess))", "  (map abs (map - game guess)))\n",
  "  (for/list ([a (in-list game)]\n             [b (in-list guess)])\n    (cond [(eq?\
    \ a b) 0]\n          [else (abs (- a b))])))\n", "  (for/list ([game-score (in-list\
    \ game)]\n             [guess-score (in-list guess)])\n    (if (= game-score guess-score)\n\
    \        0\n        (abs (- game-score guess-score)))))\n", "  (map (\u03BB (x\
    \ y) \n         (if (= x y) 0 \n             (abs (- x y))))\n       game guess))\n\
    </code>\n<code>#lang racket\n", "  (for/list ([a game] [b guess])\n    (cond [(=\
    \ a b) 0]\n          [else (abs (- a b))])))\n</code>\nThe first sub-task was\
    \ to calculate the difference between two scores for example:\n4,5 -> 1\n5,5 ->\
    \ 0\nHowever, I am not sure how to compare between two lists of values. My output\
    \ is a list of true/false values and what I want is a list of differences.\n\n\
    \nA:\n\nYour first example\n<code>(cond [(= a b) 0]\n      [else (abs (- a b))])\n\
    </code>\ncould be expressed with a <code>let</code> form:\n<code>(let ([diff (-\
    \ a b)])\n  (if (= diff 0)\n      0\n      (abs diff)))\n</code>\nAnd in this\
    \ case, you could replace the <code>let</code> form with a <code>match</code>\
    \ form:\n<code>(match (- a b)\n  [0 0]\n  [x (abs x)])\n</code>\nNow that you've\
    \ got that down, you need to apply that to the pairs of elements in the two lists.\
    \  That's a job for <code>map</code>!\n<code>(map (lambda (a b)\n       (match\
    \ (- a b)\n         [0 0]\n         [x (abs x)]))\n     game\n     guess)\n</code>\n",
  "  (map (lambda (x y)\n         (if (= x y)\n             0\n             (abs (-\
    \ x y))))\n       game guess))\n", "  (map (lambda (game guess)\n         (if\
    \ (= game guess)\n             0\n             (abs (- game guess))))\n      \
    \ game guess))\n", "  (map abs (map - game guess)))\n", "  (map (lambda (game\
    \ guess)\n         (abs (- game guess)))\n       game guess))", "  (for/list ([match\
    \ (in-list game)]\n             [guess (in-list guess)])\n    (cond\n      [(=\
    \ match guess) 0]\n      [else (abs (- match guess))])))\n", "  (map (lambda (g)\
    \ (if (= g 0) 0 (- g guess))) game))\n", "  (map (lambda (x y)\n         (cond\
    \ [(= x y) 0]\n               [else (abs (- x y))]))\n       game guess))", " \
    \ (map (lambda (g s) \n         (if (= g s) 0 (abs (- g s))))\n       guess game))\n",
  "  (for/list ([(list g s) (for/list ([x game] [y guess]) (list x y))])\n    (abs\
    \ (- g s))))\n", "    (map abs (map - game guess)))\n</code>\nI've looked on the\
    \ Racket website and don't see much on map. Basically, this code is supposed to\
    \ take two lists, compare each number in the list and return a new list with the\
    \ difference in each. I'm really new to this, so any help or suggestions on how\
    \ to improve this code would be great.\nThanks,\nAndrew\nEDIT: To be a little\
    \ more clear, if I have this list:\n<code>(define game '(10 8 4))", "  (for/list\
    \ ([i (in-range (vector-length game))])\n    (if (= (vector-ref game i) (vector-ref\
    \ guess i))\n        0\n        (abs (- (vector-ref game i) (vector-ref guess\
    \ i))))))\n", "  (for/list ([el1 game] [el2 guess])\n    (if (= el1 el2)\n   \
    \     0\n        (abs (- el1 el2)))))\n", "  (map abs (- game guess)))\n", " \
    \ (for/list ([g game] [a guess])\n            (if (= g a)\n                0\n\
    \                (abs (- g a)))))\n</code>\nSince the problem asked for an array\
    \ as output, I had to use <code>for/list</code> instead of <code>for</code>\n\
    PS: I ended up scoring a 3/4 in \"readability\", \"correctness\" and \"style\"\
    . I would welcome any comments about the style of my code.\n\n\nA:\n\nYou are\
    \ using <code>for/list</code> correctly, but using <code>for</code> would have\
    \ been just as good.\nYou could also have implemented your function using <code>map</code>:\n\
    <code>(define (compare game guess)\n  (map (lambda (g a) (if (= g a) 0 (abs (-\
    \ g a))))\n       game\n       guess))\n</code>\nThis is a bit more concise, but\
    \ not necessarily more readable.\nA final alternative could be to use <code>for/list</code>\
    \ with a named <code>let</code> and <code>match</code> instead of an <code>if</code>:\n\
    <code>(define (compare game guess)\n  (for/list ([g game] [a guess])\n    (let\
    \ ([diff (- g a)])\n      (match diff\n        [(abs diff) 0]\n        [(not (zero?\
    \ diff)) (abs diff)]))))\n</code>\nThis is more concise than the original, but\
    \ still easy to understand.\n", "  (map (lambda (g m)\n         (if (= g m)\n\
    \             0\n             (abs (- g m))))\n       guess\n       game))\n",
  "  (for/list ([g game] [r guess])\n            (if (= g r)\n                0\n\
    \                (abs (- g r)))))\n", "  (for/list ([x (in-range (vector-length\
    \ game))])\n    (let ([g (vector-ref game x)]\n          [a (vector-ref guess\
    \ x)])\n      (if (= g a)\n          0\n          (abs (- g a))))))\n", "  (map\
    \ (lambda (sc gu)\n         (if (= sc gu)\n             0\n             (abs (-\
    \ sc gu))))\n       game guess))", "  (map abs (- game guess)))\n", "  (for/list\
    \ ([g game] [gu gue])\n    (abs (- g gu))))\n</code>\nAn example of how that function\
    \ is used:\n<code>#lang racket\n", "  (map (lambda (game guess)\n         (abs\
    \ (- game guess)))\n       game guess))\n", "  (map (lambda (game guess)\n   \
    \      (if (= game guess)\n             0\n             (abs (- game guess))))\n\
    \       game guess))", "  (for/list ((g (in-list game))\n             (u (in-list\
    \ guess)))\n    (if (= g u)\n        0\n        (abs (- g u)))))\n", "  (for/list\
    \ ([x game]\n             [y guess])\n    (abs (- x y))))\n", "  (for/list ([s\
    \ (in-list game)]\n             [g (in-list guess)])\n    (cond [(equal? s g)\
    \ 0]\n          [else (abs (- s g))])))\n", "  (if (eq? (list-ref game 0) (list-ref\
    \ guess 0))\n      0\n      (abs (- (list-ref game 0) (list-ref guess 0)))))\n",
  "  (for/list ([i (in-range (length game))])\n    (if (= (list-ref game i) (list-ref\
    \ guess i))\n        0\n        (- (list-ref game i) (list-ref guess i)))))\n",
  "    (for ([g game] [h guess])\n      (abs (- g h))))\n", "  (for/list ([score (in-list\
    \ game)]\n             [gues (in-list guess)])\n    (cond [(= score gues) 0]\n\
    \          [else (abs (- score gues))])))\n", "  (map (lambda (x y)\n        \
    \ (if (= x y)\n             0\n             (abs (- x y))))\n       game guess))\n",
  "  (map (\u03BB (x y)\n         (abs (- x y)))\n       game guess))", "  (map (\u03BB\
    \ (game-score guess-score)\n         (abs (- game-score guess-score)))\n     \
    \  game guess))", "  (map (lambda (val1 val2)\n         (abs (- val1 val2)))\n\
    \       game guess))\n", "  (apply max (map abs (map - game guess))))\n", "  (map\
    \ abs (map - game guess)))\n", "  (for/list ([m (in-list (zip game guess))])\n\
    \    (define (match x y)\n      (if (= x y)\n          0\n          (abs (- x\
    \ y))))\n    (apply match m)))\n", "  (map (lambda (game guess)\n         (if\
    \ (= game guess)\n             0\n             (abs (- game guess))))\n      \
    \ game guess))", "  (if (empty? game)\n      empty\n      (cons (if (= (first\
    \ game) (first guess))\n                0\n                (abs (- (first game)\
    \ (first guess))))\n            (compare (rest game) (rest guess)))))\n", "  (for/list\
    \ ([a game] [b guess])\n            (if (= a b)\n                0\n         \
    \       (abs (- a b)))))", "  (define (helper game guess)\n    (cond\n      [(empty?\
    \ game) empty]\n      [else (cons (if (= (first game) (first guess)) 0 (abs (-\
    \ (first game) (first guess))))\n                  (helper (rest game) (rest guess)))]))\n\
    \  (helper game guess))", "  (for/list ([a (in-list game)]\n             [b (in-list\
    \ guess)])\n    (if (= a b)\n        0\n        (abs (- a b)))))\n", '  (map abs
    (map - game guess)))', "  (for/list ((game (in-range (length game)))\n       \
    \      (guess (in-range (length guess))))\n             (let* ((g (list-ref game\
    \ game))\n                    (gs (list-ref guess guess)))\n               (if\
    \ (= g gs) 0 (- g gs)))))", "  (map (\u03BB (score guess) (if (= score guess)\
    \ 0 (abs (- score guess)))) game guess))", "  (let loop ([index 0] [result '()])\n\
    \    (if (zero? index)\n        result\n        (loop (- index 1)\n          \
    \    (cons (abs (- (list-ref game index) (list-ref guess index)))\n          \
    \          result)))))\n", "    (if (equal? game guess)\n        0\n        (abs\
    \ (- game guess))))\n", "  (for/list ([i (in-range (length game))])\n    (cond\n\
    \      [(= (vector-ref game i) (vector-ref guess i)) 0]\n      [else (abs (- (vector-ref\
    \ game i) (vector-ref guess i)))])))", "  (for/list ([x (in-range (length game))])\
    \ (abs (- (list-ref game x) (list-ref guess x)))))\n", "  (let ([result (make-vector\
    \ (vector-length game))])\n    (for ([i (in-range (vector-length game))])\n  \
    \    (vector-set! result i (abs (- (vector-ref game i) (vector-ref guess i)))))\n\
    \    result))\n", "  (for/list ([x game] [y guess])\n            (if (= x y)\n\
    \                0\n                (abs (- x y)))))\n", "  (map (lambda (x y)\
    \ (abs (- x y))) game guess))\n", "  (map abs (map - game guess)))\n", "  (map\
    \ (\u03BB (g r) (if (= g r) 0 (abs (- g r)))) game guess))\n", "  (map (\u03BB\
    \ (x y) \n         (if (= x y) 0 \n             (abs (- x y))))\n       game guess))\n",
  "  (map (\u03BB (g) (abs (- g game))) guess))\n", '  (map abs (- game guess)))',
  "  (for/list ([el game] [el2 guess])\n            (if (= el el2)\n             \
    \   0\n                (abs (- el el2)))))\n", "  (map abs (map - game guess)))\n",
  "  (for/list ([idx (in-range (length game))])\n    (if (= (vector-ref game idx)\
    \ (vector-ref guess idx))\n        0\n        (abs (- (vector-ref game idx) (vector-ref\
    \ guess idx))))))\n", "  (map abs (map - game guess)))\n", "  (for/list ([g game]\
    \ [q guess])\n    (abs (- g q))))\n</code>\nI can't understand what is being asked\
    \ for. It may be that I don't understand the for syntax or that I don't understand\
    \ the question or both. \nI have looked at the reference for <code>for</code>\
    \ and <code>for/list</code> but could not find an example of multiple expressions\
    \ in the argument list.\n\n\nA:\n\nThis <code>for</code> is basically a loop that\
    \ will iterate over two lists at the same time.\nIn each iteration, the first\
    \ element of <code>game</code> will be bound to <code>g</code> and the first element\
    \ of <code>guess</code> will be bound to <code>q</code>. In the next iteration,\
    \ the second element of <code>game</code> will be bound to <code>g</code> and\
    \ the second element of <code>guess</code> will be bound to <code>q</code>, and\
    \ so on, until one of the lists is exhausted.\nThe body of the loop, in this case,\
    \ will evaluate to the absolute difference between <code>g</code> and <code>q</code>.\n\
    As the loop will return a list, <code>for/list</code> is being used instead of\
    \ <code>for</code>.\nThis <code>for</code> is equivalent to this <code>for/list</code>:\n\
    <code>(for/list ([i (in-range (length game))])\n  (abs (- (list-ref game i) (list-ref\
    \ guess i))))\n</code>\nThis <code>for</code> is equivalent to this <code>for/list</code>:\n\
    <code>(for/list ([i (in-range (length game))])\n  (abs (- (vector-ref game i)\
    \ (vector-ref guess i))))\n</code>\n\nLet's look at an example. \nGiven this <code>game</code>\
    \ and <code>guess</code>:\n<code>(define game '(2 3 3 3))", "  (map abs (map -\
    \ game guess)))\n", "  (list-map (lambda (game guess)\n            (cond ((= game\
    \ guess) 0)\n                  (else (abs (- game guess)))))\n          game guess))",
  "    (for/list ([g game] [e guess])\n      (if (= g e)\n        0\n        (abs\
    \ (- g e)))))\n", "  (map (lambda (g sc)\n         (if (= g sc)\n            \
    \ 0\n             (abs (- g sc))))\n       guess\n       game))", "\t(map abs\
    \ (map-list - game guess)))\n", "  (let loop ([g game] [q guess] [result '()])\n\
    \    (cond [(empty? g) result]\n          [else\n           (loop (rest g) (rest\
    \ q) (cons (abs (- (first g) (first q))) result))])))\n", "  (for/list ([game-item\
    \ (in-list game)]\n             [guess-item (in-list guess)])\n    (abs (- game-item\
    \ guess-item))))\n", '  (for/list ([i (in-naturals)]) (cond [(= (list-ref game
    i) (list-ref guess i)) 0] [else (abs (- (list-ref game i) (list-ref guess i)))])))',
  "  (map (lambda (score guess)\n         (cond ((= score guess) 0)\n            \
    \   (else (abs (- score guess)))))\n       game guess))", "  (map abs (for/list\
    \ ([g game] [t guess])\n              (- g t))))", "    (for/list ([i game] [j\
    \ guess])\n      (cond\n        [(= i j) 0]\n        [else (abs (- i j))])))\n\
    </code>\n", '  (map abs (- game guess)))', "  (map abs (map - game guess)))\n",
  "  (map abs (- game guess)))\n", "  (build-list (length game)\n              (lambda\
    \ (i)\n                (if (= (list-ref game i) (list-ref guess i))\n        \
    \            0\n                    (- (list-ref game i) (list-ref guess i))))))\n",
  "  (map (\u03BB (x y)\n         (if (= x y)\n             0\n             (abs (-\
    \ x y))))\n       game guess))\n", "  (for/list ([x (in-list game)]\n        \
    \     [y (in-list guess)])\n    (if (= x y)\n        0\n        (abs (- x y)))))\n",
  "  (map abs (- game guess)))\n", "  (map (lambda (g r)\n         (if (= g r)\n \
    \            0\n             (abs (- g r))))\n       game guess))\n</code>\nSo\
    \ for the example given,\n<code>(compare '(1 1 0) '(1 1 0))\n'(0 0 0)\n</code>\n\
    and\n<code>(compare '(1 1 0) '(1 0 1))\n'(0 1 0)\n</code>\n", "  (for/list ([g\
    \ game] [s guess])\n    (if (= g s)\n        0\n        (abs (- g s)))))\n", " \
    \   (map abs (map - game guess)))\n", '  (map abs (- game guess)))', "    (map\
    \ (lambda (x y)\n           (if (= x y) 0 (abs (- x y))))\n         game guess))\n",
  "  (let loop ([i 0] [len (vector-length game)])\n    (if (= i len) '()\n       \
    \ (cons (abs (- (vector-ref game i) (vector-ref guess i))) (loop (+ i 1) len)))))",
  "  (map (\u03BB (x y) (abs (- x y))) game guess))\n", "  (map (\u03BB (x y)\n\t\
    \ (if (= x y)\n\t     0\n\t     (abs (- x y))))\n       game guess))", "  (for/list\
    \ ([(list a b) (in-zip game guess)])\n    (let ([tmp (- a b)])\n      (if (negative?\
    \ tmp) (- tmp) tmp))))\n", "  (for/list ([index (in-range (length game))])\n \
    \   (cond [(equal? (vector-ref game index) (vector-ref guess index)) 0]\n    \
    \      [else (abs (- (vector-ref game index) (vector-ref guess index)))])))",
  "  (if (= (car game) (car guess))\n      0\n      (abs (- (car game) (car guess)))))\n",
  "  (map (\u03BB (pair) (if (= (car pair) (cadr pair)) 0 (- (car pair) (cadr pair))))\
    \ (zip game guess)))\n", "  (if (= game guess)\n      0\n      (abs (- game guess))))\n",
  "  (let loop ([i 0] [m (sub1 (vector-length game))] [result (vector)] )\n    (cond\
    \ \n      [(= i m) (vector-reverse result)]\n      [else \n       (vector-append!\
    \ result \n                       (vector (if (= (vector-ref game i) (vector-ref\
    \ guess i)) 0\n                                 (abs (- (vector-ref game i) (vector-ref\
    \ guess i))))))\n       (loop (add1 i) m result)])))\n", "  (map (lambda (g g1)\
    \ (abs (- g g1))) game guess))\n", "  (for/list ([(g gs) (in-list game guess)])\n\
    \            (if (equal? g gs)\n                0\n                (abs (- g gs)))))\n",
  "  (for/list ((x (in-list game))\n             (y (in-list guess)))\n    (if (=\
    \ x y)\n        0\n        (abs (- x y)))))", "  (letrec ([len (length game)]\n\
    \           [f (lambda (i sum) (if (&lt; i len) (f (+ i 1) (+ sum (abs (- (list-ref\
    \ game i) (list-ref guess i))))) sum))])\n    (f 0 0)))\n", '  (map abs (map -
    game guess)))', "  (map abs (map - game guess)))\n", '  (build-list (length game)
    (lambda (x) (abs (- (list-ref game x) (list-ref guess x))))))', "    (define (loop\
    \ game guess l)\n        (if (null? game)\n            l\n            (loop (cdr\
    \ game) (cdr guess) (cons (if (= (car game) (car guess)) 0 (abs (- (car game)\
    \ (car guess)))) l))))\n    (reverse (loop game guess '())))", "  (map abs (map\
    \ - game guess)))\n", "  (for*/list ([i (in-range (length game))])\n    (abs (-\
    \ (list-ref game i) (list-ref guess i)))))\n", "\t(for/list ([i (in-range (length\
    \ game))])\n\t\t(abs (- (list-ref game i) (list-ref guess i)))))\n", "  (map\n\
    \   (lambda (g gm)\n     (if (= g gm)\n         0\n         (abs (- g gm))))\n\
    \   game guess))", "  (map (lambda (a b) (if (= a b) 0 (abs (- a b)))) game guess))\n",
  "  (for/list ([score game] [guess guess])\n            (cond\n              [(equal?\
    \ score guess) 0]\n              [else (abs (- score guess))])))\n", "  (for/list\
    \ ((g (in-list game))\n             (g (in-list guess)))\n    (if (= g g)\n  \
    \      0\n        (abs (- g g)))))\n", "  (map (lambda (x y)\n         (if (=\
    \ x y)\n             0\n             (abs (- x y))))\n       game guess))", "\t\
    (for/list ([i (in-range (length game))])\n\t\t(abs (- (list-ref game i) (list-ref\
    \ guess i)))))\n", "  (for/list ([i (in-range (vector-length game))])\n    (abs\
    \ (- (vector-ref game i) (vector-ref guess i)))))", "  (map abs (map - game guess)))\n",
  "  (cond ((equal? game guess) 0)\n        ((> game guess) (- game guess))\n    \
    \    ((< game guess) (- guess game))))\n", "  (for/list ((g (in-list game)) (h\
    \ (in-list guess)))\n    (abs (- g h))))\n", '  (map abs (map - game guess)))',
  "  (map (\u03BB (list) (if (= (car list) (cadr list)) 0 (- (cadr list) (car list))))\n\
    \       (map list game guess)))\n", "  (cond\n    [(null? game) empty]\n    [else\
    \ (cons (if (= (car game) (car guess)) 0 (abs (- (car game) (car guess))))\n \
    \               (compare (cdr game) (cdr guess)))]))\n", "  (abs (- game guess)))\n",
  "  (map abs (- game guess)))\n", "    (map \n        (lambda (x y)\n           \
    \ (if (= x y)\n                0\n                (abs (- x y))))\n        game\
    \ guess))", "  (map\n   (lambda (games-and-guesses)\n     (let ((a (car games-and-guesses))\n\
    \           (b (cadr games-and-guesses)))\n       (if (= a b)\n           0\n\
    \           (abs (- a b)))))\n   (map list game guess)))\n", "  (for/list ([g\
    \ game] [q guess])\n    (if (= g q)\n        0\n        (abs (- g q)))))\n", '  (map
    (lambda (g1 g2) (if (= g1 g2) 0 (abs (- g1 g2)))) game guess))', "  (if (equal?\
    \ (length game) (length guess))\n      (map (lambda (x y) (cond ((equal? x y)\
    \ 0)\n                               (else (abs (- x y))))) game guess)\n    \
    \  #f))\n", "  (map (lambda (g x)\n         (if (= g x)\n             0\n    \
    \         (abs (- g x))))\n       guess\n       game))", "  (for/list ([i (in-range\
    \ (length game))])\n    (cond\n      [(= (list-ref game i) (list-ref guess i))\
    \ 0]\n      [else (abs (- (list-ref game i) (list-ref guess i)))])))\n", "  (for/list\
    \ ([x (in-list game)]\n             [y (in-list guess)])\n    (if (= x y)\n  \
    \      0\n        (abs (- x y)))))", "  (map abs (map - game guess)))\n", "  (for/list\
    \ ([i (in-range (length game))])\n            (if (= (list-ref game i) (list-ref\
    \ guess i))\n                0\n                (- (list-ref game i) (list-ref\
    \ guess i)))))\n", '  (map abs (- game guess)))', "  (for/list ([i (in-range (length\
    \ game))])\n    (abs (- (list-ref game i) (list-ref guess i)))))\n", "  (for/list\
    \ ([g (in-list game)]\n             [a (in-list guess)])\n    (abs (- g a))))\n",
  "  (map (\u03BB (g r)\n         (cond\n           [(= g r) 0]\n           [else\
    \ (abs (- g r))]))\n       guess game))\n", "  (map abs (map - game guess)))\n",
  "  (for/list ([i (in-range (length game))])\n    (cond [(= (list-ref game i) (list-ref\
    \ guess i)) 0]\n          [else (abs (- (list-ref game i) (list-ref guess i)))])))\n",
  "    (for/list ([i (in-range (length game))])\n\t      (abs (- (list-ref game i)\
    \ (list-ref guess i)))))\n", "  (let loop ([n (length game)] [a (vector-ref game\
    \ 0)] [b (vector-ref guess 0)] [res (make-vector n)] [i 0])\n    (if (= n i)\n\
    \        res\n        (vector-set! res i (if (= a b) 0 (abs (- a b))))\n     \
    \   (loop (- n 1) (vector-ref game (+ i 1)) (vector-ref guess (+ i 1)) res (+\
    \ i 1)))))\n", "  (if (= game guess)\n      0\n      (abs (- game guess))))\n",
  "  (map abs (map - game guess)))\n", "  (map (lambda (x y) (if (= x y) 0 (abs (-\
    \ x y)))) game guess))\n", "    (map (lambda (game guess)\n        (cond ((> game\
    \ guess) (- game guess))\n              ((< game guess) (- guess game))\n    \
    \          (else 0)))\n        game guess))\n", "  (cond\n    [(empty? game) empty]\n\
    \    [else (cons (if (= (first game) (first guess))\n                    0\n \
    \                   (abs (- (first game) (first guess))))\n                (compare\
    \ (rest game) (rest guess)))]))\n", "  (map abs (- game guess)))\n", "  (for/list\
    \ ([i (in-range (length game))])\n    (if (= (vector-ref game i) (vector-ref guess\
    \ i))\n        0\n        (abs (- (vector-ref game i) (vector-ref guess i))))))\n",
  "  (map (lambda (g) (if (= g (car game)) 0 (- g (car game)))) guess))\n", "    (for/list\
    \ ([score game]\n               [pick guess])\n      (cond\n        [(= score\
    \ pick) 0]\n        [else (abs (- score pick))])))", "  (for/list ([a (in-range\
    \ (length game))])\n    (cond\n      [(= (vector-ref game a) (vector-ref guess\
    \ a)) 0]\n      [else (- (vector-ref game a) (vector-ref guess a))])))\n", " \
    \ (for/list ([v game] [g guess]) (cond [(= v g) 0] [else (abs (- v g))])))\n</code>\n\
    Racket\n<code>#lang racket\n", "  (for/list ([g (in-list game)]\n            \
    \ [p (in-list guess)])\n    (cond\n      [(= g p) 0]\n      [else (abs (- g p))])))\n",
  "    (let ([len (vector-length game)])\n      (for/vector ([i (in-range len)])\n\
    \        (abs (- (vector-ref game i) (vector-ref guess i))))))", "  (map (lambda\
    \ (g gs)\n         (abs (- g gs)))\n       game guess))\n", "  (map (lambda (x\
    \ y)\n         (cond\n           [(= x y) 0]\n           [else (abs (- x y))]))\n\
    \       game guess))\n", "    (for/list ([item (in-list game)])\n            (if\
    \ (= item guess) 0 (abs (- item guess)))))", "    (for/list ([g game] [b guess])\n\
    \        (if (= g b)\n            0\n            (abs (- g b)))))", "    (for/list\
    \ ([g guess] [r game])\n      (cond [(= g r) 0]\n            [else (abs (- g r))])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
