name: HumanEval_117_select_words
language: rkt
prompt: "#lang racket\n\n;; Given a string s and a natural number n, you have been\
  \ tasked to implement \n;; a function that returns a list of all words from string\
  \ s that contain exactly \n;; n consonants, in order these words appear in the string\
  \ s.\n;; If the string s is empty then the function should return an empty list.\n\
  ;; Note: you may assume the input string contains only letters and spaces.\n;; Examples:\n\
  (define (select_words s n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n\
  \    (check-equal? (candidate \"Mary had a little lamb\" 4) (list \"little\"))\n\
  \    (check-equal? (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\"\
  ))\n    (check-equal? (candidate \"simple white space\" 2) (list ))\n    (check-equal?\
  \ (candidate \"Hello world\" 4) (list \"world\"))\n    (check-equal? (candidate\
  \ \"Uncle sam\" 3) (list \"Uncle\"))\n    (check-equal? (candidate \"\" 4) (list\
  \ ))\n    (check-equal? (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"\
  f\"))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? s) empty]\n    [else\n     (if (= n (count-consonants\
    \ (car (string-split s #\\space))))\n         (cons (car (string-split s #\\space))\n\
    \               (select-words (cdr (string-split s #\\space)) n))\n         (select-words\
    \ (cdr (string-split s #\\space)) n))]))\n</code>\nI am receiving a syntax error\
    \ that I can't figure out. \n\n\nA:\n\nThe problem here is that you're using the\
    \ wrong name for the function: you're using <code>select-words</code> when you\
    \ should be using <code>select_words</code>.\nAlso, some advice: instead of using\
    \ <code>car</code> and <code>cdr</code> to access a list, you can use <code>first</code>\
    \ and <code>rest</code> - it's much easier to read!\n", "  (cond\n    [(empty?\
    \ s) '()]\n    [else\n     (let ([i (char-alphabetic? (string-ref s 0))])\n  \
    \     (if (equal? i #f)\n           (select_words (substring s 1 (string-length\
    \ s)) n)\n           (append (list (list->string (list->vector (cadr (member (consonants\
    \ s) n)))))\n                   (select_words (substring s 1 (string-length s))\
    \ n))))]))\n", '  (if (empty? s) empty (list (string-split (string-replace (mapcar
    char-downcase s) #\space #\" ) #\" ))))', "  (define (select_words-inner s n results)\n\
    \    (cond [(empty? s) results]\n          [(consonants-count s n)\n         \
    \  (select_words-inner (rest s) n (append results (list (consonants-count s n))))]\n\
    \          [else (select_words-inner (rest s) n results)]))\n  (select_words-inner\
    \ s n '()))\n", "  (for/list ([word (in-list (string-split s #\\space))]\n   \
    \          #:when (= n (count (map char-alphabetic? (string->list word)) #f)))\n\
    \    word))\n</code>\nThe problem is that on running the program I get this error\n\
    <code>map: expects type &lt;number&gt; as 1st argument, given: #\\a; other arguments\
    \ were: #f\n  in: (char-alphabetic? #\\a)\n  map: contract violation\n  expected:\
    \ (procedure-arity-includes/c 1)\n  given: #f\n  argument position: 2nd\n  other\
    \ arguments...:\n</code>\nI don't understand what this error is trying to tell\
    \ me, can somebody please explain it to me ? \n\n\nA:\n\nYou have this problem\
    \ here:\n<code>(map char-alphabetic? (string-&gt;list word))\n</code>\nYou are\
    \ feeding a whole word to <code>char-alphabetic?</code>, instead of feeding each\
    \ letter individually.\n", "  (regexp-match* #rx(rx (= n (- (in \"bcdfghjklmnpqrstvwxyz\"\
    )\n                              (in \"aeiou\")\n                            \
    \  (* (in \"aeiou\"))))\n                       (? (in \"aeiou\"))\n         \
    \              word-boundary)\n                 s))\n", "  (for/list ([w (in-list\
    \ (string-split s))]\n             #:when (equal? n (length (regexp-match #rx\"\
    [bcdfghjklmnpqrstvwxz]\" w))))\n    w))\n</code>\nThe problem I'm having is that\
    \ it returns lists that don't actually match what I'm looking for. It's missing\
    \ some words that it should find and is also finding some that it shouldn't.\n\
    <code>;; Test Cases", "  (apply append\n         (map (\u03BB (m)\n          \
    \      (list (substring s (car m) (cdr m))))\n              (filter (\u03BB (x)\n\
    \                       (= n (consonants (substring s (car x) (cdr x)))))\n  \
    \                   (split-string s #\\space)))))\n", "  (filter (\u03BB (word)\
    \ (= n (count-consonants word)))\n          (string-split s #\\space)))\n", " \
    \ (list-of-words s n))\n", "  (define (all-words)\n    (string-split s #\\space))\n\
    \  (define (word-vowels word)\n    (string-filter word char-vowel?))\n  (define\
    \ (word-consonants word)\n    (string-filter word char-consonant?))\n  (define\
    \ (word-length word)\n    (length word))\n  (filter (lambda (word) \n        \
    \    (= (word-length (word-consonants word))\n               n)) \n          (all-words)))\n",
  "  (cond [(zero? n) s]\n        [else\n         (for/list ([e (in-string s)])\n\
    \           (select_words (regexp-replace* #rx\" \" e \"\") (- n 1)))]))\n</code>\n\
    It works for all <code>n</code> less than the length of the word, but greater\
    \ than <code>n</code> crashes the program.  For example:\n<code>&gt; (select_words\
    \ \"a bb cd ee ff\" 3)\n'((\"ee\") (\"ff\"))\n&gt; (select_words \"a bb cd ee\
    \ ff\" 4)\n'(() (\"ff\"))\n&gt; (select_words \"a bb cd ee ff\" 5)\n'()\n</code>\n\
    The last line crashes the program.  What am I doing wrong?\n\n\nA:\n\nThe problem\
    \ is that:\n<code>(select_words (regexp-replace* #rx\" \" e \"\") (- n 1))\n</code>\n\
    can return an empty string, and this happens when <code>n &gt; string-length(e)</code>.\n\
    Since <code>for/list</code> calls <code>list</code> on its result (even if it\
    \ is an empty list), you have an empty list inside an empty list. This causes\
    \ the crash.\nI think the problem can be solved like this:\n<code>(define (select_words\
    \ s n)\n  (cond [(zero? n) s]\n        [else\n         (for/list ([e (in-string\
    \ s)])\n           (if (&gt; n (string-length e))\n               \"\"\n     \
    \          (select_words (regexp-replace* #rx\" \" e \"\") (- n 1))))]))\n</code>\n",
  "  (define (is_consonant c)\n    (cond [(char-vowel? c) false]\n          [else\
    \ true]))\n  (let loop ([lst (string-&gt;list s)]\n             [word '()]\n \
    \            [words '()])\n    (cond [(or (empty? lst) (= n 0)) words]\n     \
    \     [(char=? (first lst) #\\space)\n           (loop (rest lst) '()\n      \
    \           (if (= (length word) n)\n                     (cons (list-&gt;string\
    \ (reverse word)) words)\n                     words))]\n          [else (loop\
    \ (rest lst)\n                      (cons (first lst) word)\n                \
    \      words)])))\n", "  (filter\n   (\u03BB (x)\n     (= n\n        (apply +\n\
    \               (map (\u03BB (y)\n                      (if (and (symbol? y) (member\
    \ y (string->list \"bcdfghjklmnpqrstvwxyz\")))\n                          1\n\
    \                          0))\n                    (string->symbol-list x)))))\n\
    \   (split-all s #\\space)))\n", "  (cond\n    [(empty? s) empty]\n    [else\n\
    \     (let ([word (regexp-match/all #rx\"^(.*?) \" s)]\n           [consonants\
    \ (regexp-match/all #rx\"[^aeiou\\s]\" (first word))])\n       (cond\n       \
    \  [(= (length consonants) n) (cons (first word) (select_words (substring s (second\
    \ word)) n))]\n         [else (select_words (substring s (second word)) n)]))]))\n",
  "    (cond [(empty? s) empty]\n          [(number? n) empty]\n          [(even?\
    \ n) s]\n          [(odd? n) s]))\n</code>\nWhere I'm stuck is how to find the\
    \ words that have n number of consonants\n\n\nA:\n\n<code>#lang racket\n", " \
    \ (list-of (list (filter-string (lambda (x) (and (char-alphabetic? x)\n      \
    \                                           (not (vowel? x))))\n             \
    \                   w)\n                (length (filter-string (lambda (x) (and\
    \ (char-alphabetic? x)\n                                                     \
    \   (not (vowel? x))))\n                                       w)))\n        \
    \   (make-list (length (string-split s #\\space))\n                      s)\n\
    \           (lambda (x) (= n (cadr x)))))\n</code>\nI have no idea how to use\
    \ the <code>number?</code> predicate on a string.  I don't know how to include\
    \ it in my <code>filter-string</code> function.\n\n\nA:\n\nThe <code>number?</code>\
    \ predicate determines whether an object is a number. It's not clear what you're\
    \ trying to do, but if you want to check whether a character is a number, instead\
    \ of checking that it's an alphabetic character with <code>char-alphabetic?</code>,\
    \ you can instead check that it's a digit with <code>char-digit?</code>.\n<code>(char-digit?\
    \ #\\0)\n=&gt; #t", "  (cond [(empty? s) empty]\n        [else (if (= n (count-consonants\
    \ (car (regexp-split #rx\" \" s))))\n                 (append (list (car (regexp-split\
    \ #rx\" \" s)))\n                         (select_words (cdr (regexp-split #rx\"\
    \ \" s)) n))\n                 (select_words (cdr (regexp-split #rx\" \" s)) n))]))\n",
  "  (define (is-consonant? c)\n    (match c\n      [#\\a #f]\n      [#\\e #f]\n \
    \     [#\\i #f]\n      [#\\o #f]\n      [#\\u #f]\n      [else #t]))\n  (define\
    \ (count-consonants w)\n    (cond [(empty? w) 0]\n          [(is-consonant? (first\
    \ w)) (add1 (count-consonants (rest w)))]\n          [else (count-consonants (rest\
    \ w))]))\n  (define (select-consonants lst)\n    (cond [(empty? lst) empty]\n\
    \          [(= n (count-consonants (first lst))) (cons (first lst) (select-consonants\
    \ (rest lst)))]\n          [else (select-consonants (rest lst))]))\n  (select-consonants\
    \ (string-split s)))\n</code>\n", "  (cond\n    ((equal? s \"\") '())\n    ((zero?\
    \ n) (list (car (string-split s))))\n    (else\n     (cond\n       ((char-consonant?\
    \ (string-ref s 0)) (cons (car (string-split s))\n                           \
    \                      (select_words (cdr (string-split s)) (- n 1))))\n     \
    \  (else (select_words (cdr (string-split s)) n))))))\n", "  (if (empty? s) '()\n\
    \      (let ([w (first s)])\n        (if (n-consonants? w n) (cons w (select-words\
    \ (rest s) n))\n            (select-words (rest s) n)))))\n", "  (define sx\n\
    \    (remove (lambda (x) (or (char=? x #\\ ) (= n 0)))\n            (string->list\
    \ s)))\n  (let* ([v\n          (for/list ([a sx]\n                     [i (in-naturals)])\n\
    \            (if (or (member (char-downcase a) '#(#\\a #\\e #\\i #\\o #\\u))\n\
    \                    (member (char-upcase a) '#(#\\A #\\E #\\I #\\O #\\U)))\n\
    \                '()\n                (list i)))])\n    (for/list ([w (in-list\
    \ (sublist-indexes sx v))])\n      (string-join (sublist sx (fst w) (snd w))\n\
    \                   #\\space))))", "  (cond\n    [(empty? s) empty]\n    [else\n\
    \     (if (equal? (count_consonants (first s)) n)\n         (cons (first s) (select_words\
    \ (rest s) n))\n         (select_words (rest s) n))]))\n", "  (map string-trim\
    \ (regexp-match* #rx\"\" s)))\n", "  (define (is-vowel c)\n    (or (eq? c #\\\
    a) (eq? c #\\e) (eq? c #\\i) (eq? c #\\o) (eq? c #\\u)))\n  (define (count_consonants\
    \ word)\n    (cond ((string-null? word) 0)\n          ((is-vowel (string-ref word\
    \ 0))\n           (count_consonants (string-tail word)))\n          (else (+ 1\
    \ (count_consonants (string-tail word))))))\n  (define (contains_n_consonants?\
    \ word n)\n    (= n (count_consonants word)))\n  (define (select_words_helper\
    \ ss)\n    (cond ((string-null? ss) '())\n          ((contains_n_consonants? (string-trim\
    \ ss) n)\n           (cons (string-trim ss) (select_words_helper (string-drop\
    \ ss))))\n          (else (select_words_helper (string-drop ss)))))\n  (select_words_helper\
    \ (string-trim s)))\n", "  (cond [(empty? s) empty]\n        [else (define wl\
    \ (string-split s))\n              (define wl (filter\n                      \
    \    (lambda (x) (= n (word-consonants x)))\n                          wl))\n\
    \              (if (empty? wl)\n                  empty\n                  wl)]))\n",
  "  (filter (lambda (word) (string-length (regexp-match* #rx\"[^aeiou]+\" word)))\n\
    \          (string-split s #rx\"\\s+\")))\n", "  (define (count-consonants s)\n\
    \    (define (is-consonant? c)\n      (not (member c '(#\\a #\\e #\\i #\\o #\\\
    u))))\n    (length (filter is-consonant? (string->list s))))\n  (define (is-word?\
    \ s)\n    (not (member s '(\"\" \" \"))))\n  (define (word-count str)\n    (if\
    \ (string-null? str)\n        '()\n        (cons (string-trim (substring str 0\
    \ (string-index str #\\space))) (word-count (string-trim (substring str (string-index\
    \ str #\\space) (string-length str)))))))\n  (filter (lambda (str) (= n (count-consonants\
    \ str))) (filter is-word? (word-count s))))\n", "  (local [(define (count-cons-helper\
    \ s)\n            (cond [(empty? s) (list 0)]\n                  [(member (first\
    \ s) \"aeiou\") (cons 0 (count-cons-helper (rest s)))]\n                  [else\
    \ (cons 1 (count-cons-helper (rest s)))]))\n          (define (word-with-N-cons\
    \ s n)\n            (cond [(empty? s) (list '())]\n                  [(equal?\
    \ n (first (count-cons-helper (first s)))) (cons (first s) (word-with-N-cons (rest\
    \ s) n))]\n                  [else (word-with-N-cons (rest s) n)]))]\n    (word-with-N-cons\
    \ (string-split s #\\space) n)))\n", "  (cond\n    [(empty? s) empty]\n    [else\n\
    \     (if (= n\n            (count-if-not (lambda (c) (char-set-contains? #\"\
    [aeiouAEIOU]\" c))\n                          (string->list (first (regexp-match\
    \ #px\"[a-zA-Z]+\" s)))))\n         (cons (first (regexp-match #px\"[a-zA-Z]+\"\
    \ s))\n               (select_words (substring s (regexp-match-end 0)) n))\n \
    \        (select_words (substring s (regexp-match-end 0)) n))]))\n</code>\n",
  "  (for/list ([w (in-list (string-split s))]\n             #:when (string-consonants-exactly?\
    \ w n))\n    w))\n", "  (match n\n    [(= 0) (remove (\u03BB (str) (not (empty?\
    \ str))) (string-split s))]\n    [(= 1) (filter (\u03BB (str) (not (empty? (filter\
    \ (\u03BB (ch) (member ch \"aeiou\")) str)))) (string-split s))]\n    [(= 2) (filter\
    \ (\u03BB (str) (and (not (empty? (filter (\u03BB (ch) (member ch \"aeiou\"))\
    \ str)))\n                                 (not (empty? (filter (\u03BB (ch) (not\
    \ (member ch \"aeiou\"))) str))))) (string-split s))]\n    [(= 3) (filter (\u03BB\
    \ (str) (and (not (empty? (filter (\u03BB (ch) (member ch \"aeiou\")) str)))\n\
    \                                 (not (empty? (filter (\u03BB (ch) (not (member\
    \ ch \"aeiou\"))) str)))\n                                 (not (empty? (filter\
    \ (\u03BB (ch) (not (member ch \"aeiou\"))) str))))) (string-split s))]\n    [else\
    \  (filter (\u03BB (str) (and (not (empty? (filter (\u03BB (ch) (member ch \"\
    aeiou\")) str)))\n                                 (not (empty? (filter (\u03BB\
    \ (ch) (not (member ch \"aeiou\"))) str)))\n                                 (not\
    \ (empty? (filter (\u03BB (ch) (not (member ch \"aeiou\"))) str)))\n         \
    \                        (not (empty? (filter (\u03BB (ch) (not (member ch \"\
    aeiou\"))) str))))) (string-split s))]))\n", "    (filter (lambda (w) (count-consonants\
    \ w) == n) (word-list s)))\n", "  (define (consonant? c)\n    (member c '#\\b\
    \ #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\\
    v #\\w #\\x #\\y #\\z))\n  (define (count lst)\n    (if (empty? lst) 0\n     \
    \   (+ (if (consonant? (car lst)) 1 0) (count (cdr lst)))))\n  (define (filter\
    \ lst)\n    (if (empty? lst) empty\n        (if (= n (count (car lst))) (cons\
    \ (car lst) (filter (cdr lst))) (filter (cdr lst)))))\n  (filter (filter-map string-&gt;list\
    \ string-split s #\\space)))\n</code>\nTest Cases:\n<code>(select_words \"this\
    \ is a test\" 1)", "  (if (empty? s) '()\n      (let ((w (regexp-match #rx\"[a-zA-Z]+\"\
    \ s)))\n        (if (word-has-n-consonants? (car w) n)\n            (cons (car\
    \ w) (select_words (string-drop s (string-length (car w))) n))\n            (select_words\
    \ (string-drop s (string-length (car w))) n)))))\n", "  (if (string=? s \"\")\n\
    \      empty\n      (build-list s n)\n      )\n  )\n", "  (filter (lambda (x)\
    \ (equal? n (count-consonants x))) (string-&gt;list s)))\n", "  (filter (lambda\
    \ (w)\n            (= n (count-consonants w)))\n          (split s \" \")))\n",
  "  (filter (\u03BB (word) (= n (count-consonants word))) (string-split s #\\space)))\n",
  "  (define (char->int c)\n    (cond [(char=? c #\\a) 0]\n          [(char=? c #\\\
    e) 0]\n          [(char=? c #\\i) 0]\n          [(char=? c #\\o) 0]\n        \
    \  [(char=? c #\\u) 0]\n          [else 1]))\n  (map string-&gt;symbol (filter\
    \ (lambda (word)\n                                 (= n (apply + (map char->int\
    \ (string-&gt;list word)))))\n                               (string-split s))))\n",
  "  (for/list ([word (in-string s)])\n    (if (= n (count-consonants word))\n   \
    \     word)))\n", "  (cond ((string=? s \"\") '())\n        ((= n (get-consonants\
    \ (car (string-split s #\\space))))\n         (cons (car (string-split s #\\space))\n\
    \               (select-words (cdr (string-split s #\\space)) n)))\n        (else\
    \ (select-words (cdr (string-split s #\\space)) n))))\n", "  (define (letter?\
    \ c) (or (char-alphabetic? c) (char-numeric? c)))\n  (define (vowel? c) (or (char=?\
    \ c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u)))\n\
    \  (define (is_word? word)\n    (define (is_word? word n)\n      (cond\n     \
    \   [(empty? word) (if (= n 0) true false)]\n        [(vowel? (first word)) (is_word?\
    \ (rest word) n)]\n        [(letter? (first word)) (is_word? (rest word) (- n\
    \ 1))]\n        [else (is_word? (rest word) n)]))\n    (is_word? word n))\n  (define\
    \ (word? word)\n    (define (word? word)\n      (cond\n        [(empty? word)\
    \ false]\n        [(not (letter? (first word))) false]\n        [else (word? (rest\
    \ word))]))\n    (word? word))\n  (define (helper? s)\n    (cond\n      [(empty?\
    \ s) (cons empty empty)]\n      [(word? s) (cons s (helper? (rest s)))]\n    \
    \  [else (helper? (rest s))]))\n  (define (helper s)\n    (filter is_word? (helper?\
    \ s)))\n  (helper s))\n</code>\nTesting it:\n<code>;(select_words \"Hello there\
    \ Racket\" 2)", "  (filter (lambda (w)\n            (= n (word-length (word-consonants\
    \ w))))\n          (word-list s)))\n</code>\n", "  (define consonents '(#\\b #\\\
    c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\\
    w #\\x #\\y #\\z))\n  (define (is-consonent? c)\n    (if (member c consonents)\n\
    \        #t\n        #f))\n  (define (count-consonents word)\n    (foldl (lambda\
    \ (count c)\n             (if (is-consonent? c)\n                 (+ count 1)\n\
    \                 count))\n           0\n           word))\n  (filter (lambda\
    \ (word)\n            (= n (count-consonents word)))\n          (map (lambda (x)\
    \ (string->list x)) (string-split s))))\n", "  (filter (\u03BB (w) (= n (consonants-in\
    \ w))) (string-split s #\\space)))\n", "  (filter (\u03BB (x) (= n (count x)))\
    \ (string-split s #\\space)))\n", "  (if (empty? s)\n      '()\n      (if (word-has-n-consonants?\
    \ (first (split-at-word s)) n)\n          (cons (first (split-at-word s)) (select-words\
    \ (remove-first-word s) n))\n          (select-words (remove-first-word s) n))))\n",
  "    (cond\n        [(empty? s) empty]\n        [(string-contains-n-consonants?\
    \ s n) (cons s empty)]\n        [else empty]))\n</code>\nThe part I'm not sure\
    \ about is writing <code>string-contains-n-consonants?</code> in Racket.\n", " \
    \ (for/list ((word (in-string s))\n             #:when (equal? n (count-consonants\
    \ word)))\n    word))", "  (define (is-consonant? c)\n    (and (char-alphabetic?\
    \ c) (not (char-vowel? c))))\n  (define (f s i acc)\n    (if (negative? i)\n \
    \       (reverse acc)\n        (let ((c (string-ref s i)))\n          (if (char=?\
    \ c #\\space)\n              (f s (- i 1) acc)\n              (f s (- i 1) (if\
    \ (is-consonant? c) (cons c acc) acc))))))\n  (define (g i s n words)\n    (if\
    \ (or (not (char-alphabetic? (string-ref s i))) (negative? i))\n        (if (=\
    \ (length words) n)\n            (cons (substring s 0 i) words)\n            words)\n\
    \        (g (- i 1) s n (f s i '()))))\n  (let loop ((i (sub1 (string-length s)))\
    \ (words '()))\n    (if (negative? i)\n        words\n        (loop (- i 1) (g\
    \ i s n words)))))\n", "  (for/list ((c (in-string s))\n             #:when (and\
    \ (char-alphabetic? c)\n                         (not (member c '(#\\a #\\e #\\\
    i #\\o #\\u))))\n             #:collect c))\n", "  (if (zero? (string-length s))\n\
    \      '()\n      (let ([words (string-split s)])\n        (let ([reduced (map\
    \ (lambda (w) (filter (lambda (c) (not (member c '(#\\a #\\e #\\i #\\o #\\u))))\
    \ w)) words)])\n          (let ([filtered (filter (lambda (r) (= n (string-length\
    \ r))) reduced)])\n            (filter (lambda (w) (member (map string->symbol\
    \ filtered) (char-set->list (string->char-set w)))) words))))))", "  (for/list\
    \ ([i (in-string s)]\n             #:when (and (not (char-whitespace? i))\n  \
    \                       (equal? n (count (string-filter char-consonant? s))))\n\
    \             #:collect (string-append i)))\n", "  (cond [(empty? s) empty]\n\
    \        [else (cons\n                (if (= n (count-consonants (car (str->list\
    \ s))))\n                    (car (str->list s))\n                    empty)\n\
    \                (select_words (cdr (str->list s)) n))]))\n", "  (cond\n    [(equal?\
    \ s \"\") empty]\n    [(string-contains-all? (regexp \"[bcdfghjklmnpqrstvwxz]\"\
    ) s)\n     (cons (first (string-split s #\\ ))\n           (select_words (substring\
    \ s (add1 (string-index #\\ (first (string-split s #\\ )))) (string-length s))\n\
    \                        n))]\n    [else (select_words (substring s (add1 (string-index\
    \ #\\ (first (string-split s #\\ )))) (string-length s))\n                   \
    \   n)]))\n", "  (let ([lst (string-split s)])\n    (filter (lambda (str)\n\t\
    \      (= n (count-if (lambda (c) (not (vowel? c))) str)))\n\t    lst)))\n", " \
    \ (define (consonant? c)\n    (member c '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\\
    k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z)))\n  (define\
    \ (count c lst)\n    (if (empty? lst)\n        0\n        (+ (if (consonant? (car\
    \ lst)) 1 0) (count c (cdr lst)))))\n  (define (aux s s2 n2 words)\n    (cond\n\
    \      [(empty? s)\n       (cond\n         [(empty? s2) words]\n         [(= n2\
    \ n) (cons s2 words)]\n         [else words])]\n      [(char=? (car s) #\\ )\n\
    \       (cond\n         [(empty? s2) (aux (cdr s) s2 n2 words)]\n         [(=\
    \ n2 n) (aux (cdr s) s2 n2 (cons s2 words))]\n         [else (aux (cdr s) s2 n2\
    \ words)])]\n      [else (aux (cdr s) (cons (car s) s2) (count (car s) (cons (car\
    \ s) s2)) words)]))\n  (aux s '() 0 '()))\n</code>\nEDIT:\nHere's a version using\
    \ the list library and a little more tail recursive.\n<code>#lang racket\n", " \
    \ (cond\n    [(empty? s) '()]\n    [else (check-word n (substring s 0 n))]))\n",
  "  (cond [(empty? s) empty]\n        [else (select-words-help s n '())]))\n", " \
    \ (filter\n   (lambda (str)\n     (= (length (regexp-match #rx\"[b-df-hj-np-tv-z]\"\
    \ str)) n))\n   (string-split s)))\n</code>\nYou are iterating through the list\
    \ of words, not the string. And even if you wanted to iterate through the string,\
    \ there are more efficient ways of doing so.\n<code>;; Given a string s and a\
    \ natural number n, you have been tasked to implement ", "  (if (empty? s)\n \
    \     empty\n      (cons (prefix s) (select_words (suffix s) n))))\n", "  (define\
    \ (is-consonant c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\")) #f #t))\n\
    \  (define (count-consonants word)\n    (if (null? word) 0\n        (+ (if (is-consonant\
    \ (car word)) 1 0)\n           (count-consonants (cdr word)))))\n  (define (match-p\
    \ word)\n    (= n (count-consonants word)))\n  (define (loop word result)\n  \
    \  (if (null? word) result\n        (loop (cdr word) (if (match-p (car word))\
    \ (cons (car word) result) result))))\n  (loop (string-split s) '()))\n", "  (cond\
    \ [(string=? s \"\") '()]\n        [else\n         (string-split s\n         \
    \              (string #\\Space))]))\n", "  (if (empty? s)\n      empty\n    \
    \  (if (equal? n 0)\n          (words s)\n          (filter (lambda (w)\n    \
    \                (equal? n (count (compose consonant? char-alphabetic?) w)))\n\
    \                  (words s)))))\n", "  (cond\n    [(empty? s) empty]\n    [else\
    \ (cons (first s) (select_words (rest s) n))]))\n", "  (cond [(empty? s) '()]\n\
    \        [else (if (= n (count-consonants (first (string-split s #\\space))))\n\
    \                 (cons (first (string-split s #\\space))\n                  \
    \     (select-words (string-join (rest (string-split s #\\space)) #\\space) n))\n\
    \                 (select-words (string-join (rest (string-split s #\\space))\
    \ #\\space) n))]))\n", "  (for/list ([word (in-string s)]\n             #:when\
    \ (and (not (eq? n 0))\n                         (count (lambda (c) (not (char-set-contains?\
    \ #\"[aeiou]\" c))) word)\n                         (= n (count (lambda (c) (not\
    \ (char-set-contains? #\"[aeiou]\" c))) word))))\n    word))\n", "  (define s-list\
    \ (string-&gt;list s))\n  (define (is-consonant? char)\n    (member char '(\"\
    b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\" \"q\" \"\
    r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"z\")))\n  (define (is-vowel? char)\n    (member\
    \ char '(\"a\" \"e\" \"i\" \"o\" \"u\" \"y\")))\n  (define (count-consonants string)\n\
    \    (if (null? string)\n        0\n        (+ (if (is-consonant? (car string))\
    \ 1 0) (count-consonants (cdr string)))))\n  (if (null? s-list)\n      '()\n \
    \     (define (filter_words words_list)\n        (if (null? words_list)\n    \
    \        '()\n            (if (= n (count-consonants (car words_list)))\n    \
    \            (cons (car words_list) (filter_words (cdr words_list)))\n       \
    \         (filter_words (cdr words_list)))))\n      (filter_words (string-split\
    \ s #\\space))))\n</code>\nI hope that helped you, if it didn't please do tell\
    \ me, so I can clarify.\nHave a nice day :)\n", "  (if (empty? s)\n      '()\n\
    \      (cons (filter (lambda (x) (equal? n (count-consonants x)))\n          \
    \         (explode s))\n            (select_words (tail s) n))))\n", "  (cond\
    \ [(string=? s \"\") empty]\n        [else (filter (lambda (w) (= n (count-vowels\
    \ w)))\n                      (split-string s))]))\n", "  (match (regexp-split\
    \ #rx\" +\" s)\n    [(list) (list)]\n    [(list h ...)\n     (append\n      (cond\
    \ [(and (= n (count (string-lowercase h) #\\[a-z] [#\\a #\\e #\\i #\\o #\\u]))\n\
    \                  (not (string-empty? h)))\n             (list h)])\n      (select_words\
    \ (string-join (list h ...) \" \") n))]))\n", "  (cond\n    [(empty? s) empty]\n\
    \    [else (cons (car s) (cons (consonants (cdr s)) (select_words (cdr s) n)))]))\n",
  "  (let* ([s (split-string s)])\n    (filter\n     (lambda (word)\n       (= n (length\
    \ (regexp-match #rx\"[^aeiou ]\" word))))\n     s)))\n", "  (if (empty? s)\n \
    \     '()\n      (cons (first s) (select_words (rest s) n))))", "  (filter (\u03BB\
    \ (w) (= n (count-consonants w))) (split (regexp-split #rx\" +\") s)))\n", " \
    \ (filter (lambda (word)\n            (= n (length (filter (lambda (letter) (not\
    \ (member letter \"aeiouy\")))\n                                 word))))\n  \
    \        (map (lambda (string) (string->list string)) (string-split s))))\n",
  "  (cond [(string=? s \"\") empty]\n        [else (cons (car (regexp-match #rx\"\
    [^aeiouAEIOU]*\" s)) (select_words (string-drop s (string-length (car (regexp-match\
    \ #rx\"[^aeiouAEIOU]*\" s)))) n))]))\n", "  (for/list ([word (in-string s)]\n\
    \             #:when (num-consonants? word n))\n    word))\n", "  (if (string=?\
    \ s \"\")\n      '()\n      (list-of-words s n (list-ref (string-split s) 0) (list-ref\
    \ (string-split s) 1) '())))\n", "  (define (is-vowel c) (member c '(#\\a #\\\
    e #\\i #\\o #\\u)))\n  (define (is-consonant c) (not (is-vowel c)))\n  (define\
    \ (vowel-consonant-count w)\n    (let loop ((w w) (i 0) (j 0))\n      (cond\n\
    \        [(null? w) (values i j)]\n        [(is-vowel (car w)) (loop (cdr w) (+\
    \ i 1) j)]\n        [(is-consonant (car w)) (loop (cdr w) i (+ j 1))])))\n  (define\
    \ (select w)\n    (let ([v n] [c n])\n      (when (and (is-vowel (car w)) (not\
    \ (is-consonant (car w))))\n        (values (substring w 1) (substring w 0 1)\
    \ v c))\n      (when (and (is-consonant (car w)) (not (is-vowel (car w))))\n \
    \       (values (substring w 1) (substring w 0 1) v c))\n      (values w (substring\
    \ w 0 1) v c)))\n  (let loop ((s s) (w '()) (ws '()))\n    (cond\n      [(empty?\
    \ s) ws]\n      [(char=? #\\s (car s))\n       (let ((s (substring s 1)))\n  \
    \       (when (and (not (equal? w \"\")) (equal? n (apply vowel-consonant-count\
    \ w)))\n           (loop s \"\" (cons w ws)))\n         (loop s \"\" ws))]\n \
    \     [else\n       (let-values ([(s w v c) (select s)])\n         (loop s (string-append\
    \ w w) ws))])))", "  (cond\n    [(empty? s) empty]\n    [else (cond\n        \
    \    [(> (consonants (first s)) n) (select_words (rest s) n)]\n            [(=\
    \ (consonants (first s)) n) (append (list (first s))\n                       \
    \                           (select_words (rest s) n))]\n            [else (select_words\
    \ (rest s) n)])]))\n", "  (filter\n   (lambda (x) (= n (length (filter char-consonant?\
    \ (string->list x)))))\n   (split-string s)))\n", "  (filter (lambda (x) (= n\
    \ (count-consonants x)))\n          (split s #\\space)))\n", "  (string-&gt;list\
    \ s))\n</code>\nThis should convert the string to a list.\nHowever, I get the\
    \ following error:\n<code>string-&gt;list: expects argument of type &lt;string&gt;;\
    \ given '(#\\h #\\e #\\l #\\l #\\o #\\space #\\t #\\h #\\e #\\r #\\e)\n</code>\n\
    The input string is: \"hello there\"\nWhat am I doing wrong?\n\n\nA:\n\nThis is\
    \ happening because <code>#lang racket</code> has a macro called <code>'</code>\
    \ that works like <code>quote</code> in other Lisps.\nSo when you write:\n<code>(define\
    \ (select_words s n)\n  (string-&gt;list s))\n</code>\nYou're actually writing:\n\
    <code>(define (select_words s n)\n  (string-&gt;list '(#\\h #\\e #\\l #\\l #\\\
    o #\\space #\\t #\\h #\\e #\\r #\\e)))\n</code>\nBecause you're passing the <code>'</code>-quoted\
    \ string literal to <code>string-&gt;list</code>.\nYou can either use <code>#lang\
    \ racket/base</code> instead, or just pass a string literal without the quotes\
    \ (or in the worst case, an escaped string literal <code>\"\\\"hello there\\\"\
    \"</code>).\n", "  (cond ((string=? s \"\") empty)\n        ((and (string-contains-ci?\
    \ s #\\A) (string-contains-ci? s #\\E)\n              (string-contains-ci? s #\\\
    I) (string-contains-ci? s #\\O)\n              (string-contains-ci? s #\\U)) (list\
    \ (regexp-match #rx\"([AEIOU][^AEIOU]+)\" s)))\n        (else (list (regexp-match\
    \ #rx\"([^AEIOU][^AEIOU]+)\" s)))))\n", "  (define (consonant? c)\n    (member\
    \ c '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\\
    s #\\t #\\v #\\w #\\x #\\y #\\z)))\n  (define (inner input output)\n    (match\
    \ input\n      (('() '()) output)\n      ((cons c rest)\n       (cond ((member\
    \ c '(#\\a #\\e #\\i #\\o #\\u))\n              (inner rest output))\n       \
    \      ((letter? c)\n              (inner rest (append output (list c))))\n  \
    \           ((whitespace? c)\n              (inner rest (if (= n (length output))\n\
    \                              (append output (list c))\n                    \
    \          output)))\n             (else (inner rest output))))))\n  (string-&gt;list\
    \ (inner (string-&gt;list s) '())))\n", "  (cond\n    [(empty? s) empty]\n   \
    \ [(&gt; (number-of-consonants s) n)\n     (cons (take-while (lambda (ch) (not\
    \ (char=? ch #\\space))) s)\n           (select-words (drop-while (lambda (ch)\
    \ (not (char=? ch #\\space))) s) n))]\n    [else (select-words (drop-while (lambda\
    \ (ch) (not (char=? ch #\\space))) s) n)]))\n", "  (define (consonant? ch)\n \
    \   (let ((ch (string-upcase ch)))\n      (cond ((or (char=? ch #\\A) (char=?\
    \ ch #\\E) (char=? ch #\\I) (char=? ch #\\O) (char=? ch #\\U)) #f)\n         \
    \   ((or (char=? ch #\\Y) (char=? ch #\\W)) #f)\n            (else #t))))\n  (let\
    \ loop ((n n) (words (string-tokenize s)) (result '()))\n    (cond ((or (empty?\
    \ words) (negative? n)) result)\n          ((zero? n) (cons (string-join words)\
    \ result))\n          ((let loop ((subwords (string-tokenize (car words))) (consonants\
    \ 0))\n             (cond ((empty? subwords) (if (zero? consonants)\n        \
    \                                  (loop (cdr words) n)\n                    \
    \                      (loop (cdr words) (- n consonants))))\n               \
    \    ((consonant? (car subwords)) (loop (cdr subwords) (+ consonants 1)))\n  \
    \                 (else (loop (cdr subwords) consonants))))\n           (loop\
    \ n (cdr words) result)))))\n", "  (define (vowel? c)\n    (or (equal? c #\\a)\
    \ (equal? c #\\e) (equal? c #\\i) (equal? c #\\o) (equal? c #\\u)))\n  (define\
    \ (consonant? c)\n    (not (vowel? c)))\n  (define (count-consonants word)\n \
    \   (if (empty? word)\n        0\n        (if (consonant? (first word))\n    \
    \        (+ 1 (count-consonants (rest word)))\n            (count-consonants (rest\
    \ word)))))\n  (define (select-words s n)\n    (cond [(empty? s) '()]\n      \
    \    [(equal? (count-consonants (first (split s))) n)\n           (cons (first\
    \ (split s)) (select-words (regexp-replace #rx\"^[^ ]+ \" s) n))]\n          [else\
    \ (select-words (regexp-replace #rx\"^[^ ]+ \" s) n)]))\n  (select-words s n))\n\
    \n", "    (define (is-consonant? c)\n        (cond\n            [(char-ci=? c\
    \ #\\b) #f]\n            [(char-ci=? c #\\c) #f]\n            [(char-ci=? c #\\\
    d) #f]\n            [(char-ci=? c #\\f) #f]\n            [(char-ci=? c #\\g) #f]\n\
    \            [(char-ci=? c #\\h) #f]\n            [(char-ci=? c #\\j) #f]\n  \
    \          [(char-ci=? c #\\k) #f]\n            [(char-ci=? c #\\l) #f]\n    \
    \        [(char-ci=? c #\\m) #f]\n            [(char-ci=? c #\\n) #f]\n      \
    \      [(char-ci=? c #\\p) #f]\n            [(char-ci=? c #\\q) #f]\n        \
    \    [(char-ci=? c #\\r) #f]\n            [(char-ci=? c #\\s) #f]\n          \
    \  [(char-ci=? c #\\t) #f]\n            [(char-ci=? c #\\v) #f]\n            [(char-ci=?\
    \ c #\\w) #f]\n            [(char-ci=? c #\\x) #f]\n            [(char-ci=? c\
    \ #\\y) #f]\n            [(char-ci=? c #\\z) #f]\n            [else #t]))\n  \
    \  (define (consonant-counts word)\n        (cond\n            [(empty? word)\
    \ 0]\n            [(is-consonant? (first word)) (+ 1 (consonant-counts (rest word)))]\n\
    \            [else (consonant-counts (rest word))]))\n    (define (select-words-inner\
    \ s n acc)\n        (cond\n            [(empty? s) (reverse acc)]\n          \
    \  [(equal? n (consonant-counts (first s))) (select-words-inner (rest s) n (cons\
    \ (first s) acc))]\n            [else (select-words-inner (rest s) n", "  (if\
    \ (string=? s \"\")\n      '()\n      (if (eq? (count-consonants (first (string-split\
    \ s #\\space))) n)\n          (cons (first (string-split s #\\space)) (select_words\
    \ (rest-of-string s) n))\n          (select_words (rest-of-string s) n))))\n</code>\n\
    I have a problem when I try to pass select_words to the tests. I get the following\
    \ error:\n<code>Type Checker: function call: expected a function for the first\
    \ argument in the position marked by the arrow, but received 'a; other arguments\
    \ were: 3\n\nType Checker: function call: cannot apply expression of type string\
    \ to an argument of type string -&gt; 'a\n</code>\nMy test looks like this:\n\
    <code>(test (equal? (select_words \"I have been tasked to implement a function\"\
    \ 3) (list \"been\" \"tasked\" \"implement\" \"function\"))\n     \"first test\"\
    \n     (check-equal? (select_words \"I have been tasked to implement a function\"\
    \ 3) (list \"been\" \"tasked\" \"implement\" \"function\"))\n     \"second test\"\
    \n     (check-equal? (select_words \"I have been tasked to implement a function\"\
    \ 4) '())\n     \"third test\"\n     (check-equal? (select_words \"I have been\
    \ tasked to implement a function\" 2) '())\n     \"fourth test\"\n     (check-equal?\
    \ (select_words \"I have been tasked to implement a function\" 1) '())\n     \"\
    fifth test\"\n     (check-equal? (select_words \"I have been tasked to implement\
    \ a function\" 0) '())\n     \"sixth test\"\n     (check-equal? (select_words\
    \ \"I have been tasked to implement a function\" 6) '())\n     \"seventh test\"\
    \n     (check-equal? (select_words \"I have been tasked to implement a function\"\
    \ 7) '())\n     \"eighth test\"\n     (check-equal? (select_words \"I have been\
    \ tasked to implement a function\" 8) '())\n     \"ninth test\"\n     (check-equal?\
    \ (select_words \"I", "  (filter (lambda (word)\n            (= n (length (filter\
    \ (lambda (char)\n                                   (member char (list #\\b #\\\
    c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\\
    w #\\x #\\y #\\z)))\n                                 (string->list word)))))\n\
    \          (string-split s #\\space)))\n", "  (split (cond\n          ((equal?\
    \ s \"\") \"\")\n          ((= n 0)\n           (string-append (string-append\
    \ (substring s 0 1) \" \")\n                          (select_words (substring\
    \ s 1))))\n          ((= n 1)\n           (if (member (substring s 0 1) '(\"a\"\
    \ \"e\" \"i\" \"o\" \"u\"))\n               (string-append (string-append (substring\
    \ s 0 1) \" \")\n                              (select_words (substring s 1) n))\n\
    \             (string-append (substring s 0 1)\n                            (select_words\
    \ (substring s 1) (- n 1)))))\n          (else (if (member (substring s 0 1) '(\"\
    a\" \"e\" \"i\" \"o\" \"u\"))\n                    (select_words (substring s\
    \ 1) n)\n                    (select_words (substring s 1) (- n 1))))))\n    \
    \     \" \"))\n</code>\nBut that gives me the following error:\n<code>module:\
    \ identifier already imported from a different source in: sort!\n</code>\nI'm\
    \ not really sure what I'm doing wrong. I'm very new to Racket, and am not totally\
    \ sure if I'm using the correct methodology. Any help would be appreciated.\n\
    Edit: \nHere's my test case:\n<code>#lang racket\n", "  (cond [(empty? s) empty]\n\
    \        [else (append (select_words (tail s) n)\n                      (list\
    \ (car s)))]))\n", "  (for/list ([word (regexp-match* #rx\"\\w+\" s)])\n    (and\
    \ (= n (count-consonants word)) word)))\n", "  (for/list ([word (in-list (regexp-match*\
    \ #rx\"\\w+\" s))]\n             #:when (= n (count (in-list (regexp-match* #rx\"\
    [bcdfghjklmnpqrstvwxz]\" (string-normalize-spaces word))))))\n    word))\n</code>\n\
    I tried <code>racket -r test</code> but then I get an error: <code>#f: string-normalize-spaces:\
    \ not a string: #f</code>\n\n\nA:\n\nThe problem is that <code>regexp-match*</code>\
    \ returns a list of lists. In this case, the outer list contains one list, which\
    \ is the list of matches. The inner list contains all of the words.\nThis is a\
    \ bit of a not-so-well-documented feature of Racket's pattern language.\nThe fix\
    \ is to simply add an extra <code>for</code> loop around the <code>for/list</code>\
    \ loop to loop over the outer list.\nHere's a version that works:\n<code>#lang\
    \ racket\n", "  (filter (lambda (w)\n            (= n (count-consonants w)))\n\
    \          (string-&gt;words s)))\n", "  (match s\n    [\"\" empty]\n    [s (define\
    \ (is-consonant c)\n          (or (char=? c #\\b)\n              (char=? c #\\\
    c)\n              (char=? c #\\d)\n              (char=? c #\\f)\n           \
    \   (char=? c #\\g)\n              (char=? c #\\h)\n              (char=? c #\\\
    j)\n              (char=? c #\\k)\n              (char=? c #\\l)\n           \
    \   (char=? c #\\m)\n              (char=? c #\\n)\n              (char=? c #\\\
    p)\n              (char=? c #\\q)\n              (char=? c #\\r)\n           \
    \   (char=? c #\\s)\n              (char=? c #\\t)\n              (char=? c #\\\
    v)\n              (char=? c #\\w)\n              (char=? c #\\x)\n           \
    \   (char=? c #\\y)\n              (char=? c #\\z)))\n       (define (count-consonants\
    \ word)\n         (if (string-empty? word)\n             0\n             (if (is-consonant\
    \ (string-ref word 0))\n                 (+ 1 (count-consonants (string-drop word\
    \ 1)))\n                 (count-consonants (string-drop word 1)))))\n       (define\
    \ (loop words)\n         (match words\n           [(cons (cons first _) rest)\n\
    \            (if (= n (count-consonants first))\n                (cons first (loop\
    \ rest))\n                (loop rest))]\n           [_ empty]))\n       (loop\
    \ (string-split s #\\space)))]))\n", "  (match (string-split s #\\space)\n   \
    \ ['() '()]\n    [(list s . ss)\n     (define (n_consonants s)\n       (define\
    \ (is_vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\u)))\n       (length\n\
    \        (filter\n         (lambda (c) (not (is_vowel? c)))\n         (string->list\
    \ s))))\n     (append (if (= n (n_consonants s)) (list s) '())\n             (select_words\
    \ (string-join ss) n))]))", "  (define (helper s index acc)\n    (cond ((or (not\
    \ (char-alpha? (string-ref s index)))\n               (&gt;= index (string-length\
    \ s)))\n           (cond ((&gt;= (length acc) n)\n                  (cons acc\
    \ '()))\n                 (else '())))\n          ((char-consonant? (string-ref\
    \ s index))\n           (helper s (+ index 1) (string-append acc (list (string-ref\
    \ s index)))))\n          (else\n           (helper s (+ index 1) (string-append\
    \ acc (list (string-ref s index)))))))\n  (filter (lambda (x) (= (length x) n))\n\
    \          (helper s 0 \"\")))\n</code>\nis this style of functional programming\
    \ idiomatic in racket?\n\n\nA:\n\nStyle\n\nYou're missing a space after the <code>lambda</code>\
    \ keyword in the body of the <code>select_words</code> function.\nThe <code>filter</code>\
    \ procedure is redundant, you can use <code>list-ref</code> to get only the elements\
    \ in the list that satisfy a condition.\nYou're missing the mandatory <code>#!racket</code>\
    \ shebang in the top of the file.\nUse <code>#| ... |#</code> comments to write\
    \ multi-line comments, as it's easier to read and write.\nUse <code>if</code>\
    \ expressions instead of <code>cond</code> when there are only 2 branches. Also,\
    \ in your case, you can use the <code>and</code> operator to combine conditions.\n\
    \nSolution\n<code>#!racket\n", "  (string-split s))\n", "  (cond [(empty? s) empty]\n\
    \        [else (define (xs s c)\n                (if (empty? s)\n            \
    \        empty\n                    (if (memq (car s) \"aeiou\")\n           \
    \             (xs (cdr s) (+ c 1))\n                        (cons (car s) (xs\
    \ (cdr s) c)))))\n              (define (ys xs n)\n                (cond [(empty?\
    \ xs) empty]\n                      [(>= (count xs) n) (cons (string->list xs)\
    \ (ys empty n))]\n                      [else (ys (cdr xs) n)]))\n           \
    \   (define (zs s n)\n                (cond [(empty? s) empty]\n             \
    \         [(and (not (memq (car s) \"aeiou\")) (empty? (cdr s))) empty]\n    \
    \                  [(and (memq (car s) \"aeiou\") (empty? (cdr s))) (ys empty\
    \ n)]\n                      [(and (not (memq (car s) \"aeiou\")) (memq (car (cdr\
    \ s)) \"aeiou\")) (zs (cdr s) n)]\n                      [(and (not (memq (car\
    \ s) \"aeiou\")) (not (memq (car (cdr s)) \"aeiou\"))) (zs (cdr s) n)]\n     \
    \                 [(and (memq (car s) \"aeiou\") (not (memq (car (cdr s)) \"aeiou\"\
    ))) (zs (cdr s) n)]\n                      [(and (memq (car s) \"aeiou\") (memq\
    \ (car (cdr s)) \"aeiou\")) (cons (string->list (append (cons (car s) empty) (cdr\
    \ s))) (zs (cdr s) n))]))\n              (define (s1 s)\n                (cond\
    \ [(empty? s) empty]\n                      [(memq (car s) \"aeiou\") (zs (cdr\
    \ s) n)]\n                      [else (s1 (cdr s))]))\n              (let* ([s2\
    \ (string-split s \" \")]\n                     [s3 (map xs s2 0)]\n         \
    \            [s4", "  (for/list ((w (in-list (string-split s))))\n    (if (= n\
    \ (length (regexp-match #rx\"[^aeiou ]\" w)))\n        w\n        #f)))\n</code>\n",
  "  (filter (lambda (w) (= n (count-consonants w)))\n          (split-string s)))\n",
  "  (if (empty? s)\n      empty\n      (cons (first (remove (lambda (x)\n       \
    \                      (not (= (list-length (filter\n                        \
    \                           (lambda (c)\n                                    \
    \                 (not (member c '(#\\a #\\e #\\i #\\o #\\u))))\n            \
    \                                       x)))\n                               \
    \           n)))\n                           (regexp-match #rx\"\\w+\" s)))\n\
    \            (select_words (regexp-replace #rx\"\\w+\" s \"\") n))))\n</code>\n\
    I expect <code>(select_words \"test it that\" 2)</code> to return <code>'(\"test\"\
    \ \"that\")</code>, but instead it returns:\n<code>select_words: application:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: #&lt;void&gt;\n  arguments...:\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n\
    \   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n\
    \   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n\
    \   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n\
    \   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n\
    \   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n\
    \   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n   #&lt;undefined&gt;\n\
    \   #&lt;undefined&gt;\n   #&lt;", "  (cond [(string=? s \"\") empty]\n      \
    \  [else\n         (cons (car s) (select_words (cdr s) n))]))\n", "  (map (curry\
    \ string-trim)\n       (filter (curry (lambda (s n) (= n (count-consonants s))))\n\
    \               (map (curry substring s)\n                    (build-list (add1\
    \ (string-length s))\n                                (lambda (x) (list x (add1\
    \ x))))))))\n", "  (match (string-split s #\\space)\n    ([list] '())\n    ([word\
    \ rst]\n     (if (= n (length (consonants word)))\n         (cons word (select_words\
    \ (apply string-append rst) n))\n         (select_words (apply string-append rst)\
    \ n)))))\n", "  (if (zero? (count s))\n      '()\n      (let* ([consonants (string-&gt;list\
    \ \"bcdfghjklmnpqrstvwxyz\")]\n             [all_words (string-split s #\\space)]\n\
    \             [filtered_words (filter \n                              (lambda\
    \ (word) \n                                (= n (count (char-set-&gt;list \n \
    \                                            (string-&gt;char-set word))\n   \
    \                                         consonants)))\n                    \
    \          all_words)])\n        filtered_words)))\n</code>\n", "  (define (helper\
    \ ws)\n    (cond\n      [(empty? ws) empty]\n      [(= n (count-consonants (first\
    \ ws)))\n       (cons (first ws) (helper (rest ws)))]\n      [else (helper (rest\
    \ ws))]))\n  (helper (string-split s #\\space)))", "  (cond [(empty? s) '()]\n\
    \        [else\n         (define first-word (string-tokenize s))\n         (define\
    \ rest-word (select_words (substring s (string-length first-word) (string-length\
    \ s)) n))\n         (cond [(equal? n (count-consonants first-word))\n        \
    \        (cons first-word rest-word)]\n               [else rest-word])]))\n",
  "  (define (is-consonant? x)\n    (cond [(char-whitespace? x) #f]\n          [(member\
    \ x '(#\\a #\\e #\\i #\\o #\\u)) #f]\n          [else #t]))\n  (define (apply-fun\
    \ fn lst)\n    (foldl (lambda (elt lst)\n             (append lst (list (fn elt))))\
    \ '() lst))\n  (define (remove-spaces lst)\n    (filter (lambda (x) (not (char-whitespace?\
    \ x))) lst))\n  (define (group lst)\n    (foldl (lambda (elt lst)\n          \
    \   (if (null? lst)\n                 (list (list elt))\n                 (if\
    \ (equal? (first (first lst)) elt)\n                     (cons (cons elt (first\
    \ lst)) (rest lst))\n                     (cons (list elt) lst)))) '() lst))\n\
    \  (define (word-count lst)\n    (length (remove-spaces lst)))\n  (define (filter-by-len\
    \ lst k)\n    (filter (lambda (x) (= (word-count x) k)) lst))\n  (define (select-words\
    \ lst n)\n    (filter-by-len (group (remove-spaces lst)) n))\n  (apply-fun string->list\
    \ (select-words (string->list s) n)))\n", "  (if (eq? n 0)\n      (if (empty?\
    \ s)\n          (list)\n          (list s))\n      (if (empty? s)\n          (list)\n\
    \          (if (eq? (word-consonants (word-first s)) n)\n              (cons (word-first\
    \ s) (select_words (word-rest s) n))\n              (select_words (word-rest s)\
    \ n)))))\n", "  (filter (lambda (x) (= n (length (string-filter (lambda (c) (member\
    \ c (string-&gt;list \"qwrtypsdfghjklzxcvbnm\"))) x)))) (string-split s)))\n</code>\n\
    I am trying to use <code>string-filter</code> to find out the number of consonants\
    \ in a word.\n<code>string-filter</code> returns a <code>string</code> which I\
    \ need to change to a <code>list</code> to find its length.\nI am not able to\
    \ find out where I am going wrong.\nBelow is the test file:\n<code>#lang racket\n",
  "  (filter (\u03BB (word) (= n (length (filter char-consonant? (string->list word)))))\
    \ (words s)))", "  (define (is-consonant? x)\n    (cond ((or (equal? x #\\b) (equal?\
    \ x #\\c) (equal? x #\\d)\n               (equal? x #\\f) (equal? x #\\g) (equal?\
    \ x #\\h) (equal? x #\\j)\n               (equal? x #\\k) (equal? x #\\l) (equal?\
    \ x #\\m) (equal? x #\\n)\n               (equal? x #\\p) (equal? x #\\q) (equal?\
    \ x #\\r) (equal? x #\\s)\n               (equal? x #\\t) (equal? x #\\v) (equal?\
    \ x #\\w) (equal? x #\\x)\n               (equal? x #\\y) (equal? x #\\z)) #t)\n\
    \          (else #f)))\n  (define (consonants-in-word s)\n    (cond ((empty? s)\
    \ 0)\n          ((is-consonant? (first s)) (+ 1 (consonants-in-word (rest s))))\n\
    \          (else (consonants-in-word (rest s)))))\n  (cond ((or (empty? s) (char=?\
    \ (first s) #\\space)) (list))\n        ((= n (consonants-in-word s)) (cons (list->string\
    \ s) (select_words (rest s) n)))\n        (else (select_words (rest s) n))))\n",
  "  (apply append\n         (for/list ([chunk (in-string s)]\n                  \
    \  #:when (and (string? chunk)\n                                (= n (number-of-consonants\
    \ chunk)))\n                    #:collect (list chunk))))\n", "  (match (regexp-split\
    \ s #px\"\\\\s+\")\n    (`() '())\n    ((list s ss ...)\n     (cond [(= n (length\
    \ (regexp-match* #px\"[bcdfghjklmnpqrstvwxz]\" s)))\n            (cons s (select_words\
    \ (string-join ss) n))]\n           [else (select_words (string-join ss) n)]))))",
  "  (cond [(empty? s) empty]\n        [else (cond [(n = (consonants (first (string-split\
    \ s #\\space)))) \n                     (cons (first (string-split s #\\space))\
    \ (select_words (string-join (rest (string-split s #\\space)) #\\space) n))]\n\
    \                    [else (select_words (string-join (rest (string-split s #\\\
    space)) #\\space) n)])]))\n", "    (for/list ([word (regexp-match* #rx\"\\w+\"\
    \ s)])\n        (when (= n (count (string-count #\\vowel? word)))\n          \
    \  word)))\n", "  (filter (lambda (word)\n            (= n (length (filter char-consonant?\
    \ (string->list word)))))\n          (string-split s)))\n", "  (if (empty? s)\n\
    \      empty\n      (define (cleanup str)\n        (regexp-replace* #rx\"[\" str\
    \ \"\"))\n      (define (cleanup-all str)\n        (cleanup (cleanup str)))\n\
    \      (define (begins-with? strs sub)\n        (cond\n          [(empty? strs)\
    \ #f]\n          [(string=? (first strs) sub) #t]\n          [else (begins-with?\
    \ (rest strs) sub)]))\n      (define (word str)\n        (define (word-aux str\
    \ i)\n          (if (= i 0)\n              (string-&gt;list str)\n           \
    \   (word-aux (string-drop str 1) (- i 1))))\n        (string-&gt;list (string-trim\
    \ str)))\n      (define (consonants str)\n        (define (consonants-aux str\
    \ i acc)\n          (if (= i 0)\n              acc\n              (cond\n    \
    \            [(consonant? (char-downcase (string-ref str i)))\n              \
    \   (consonants-aux str (- i 1) (cons (string-ref str i) acc))]\n            \
    \    [else (consonants-aux str (- i 1) acc)])))\n        (consonants-aux str (string-length\
    \ str) empty))\n      (define (consonant? char)\n        (and (char? char)\n \
    \            (member char '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m\
    \ #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z))))\n      (define (word-length\
    \ str)\n        (length (word str)))\n      (define (word-from-i str i)\n    \
    \    (define (word-from-i-aux str i)\n          (if (char-whitespace? (string-ref\
    \ str i))\n              (substring str i i)\n              (word-from-i-aux str\
    \ (+ i 1))))\n        (word-from-i-aux str i))\n      (define (split str)\n  \
    \      (", "  (define (consonant? c)\n    (and (not (elem? c \"aeiouAEIOU\"))\
    \ (or (char-alphabetic? c) (char-whitespace? c))))\n  (define (check_word w)\n\
    \    (if (or (eq? w \"\") (not (consonant? (string-ref w 0))))\n        0\n  \
    \      (+ 1 (check_word (substring w 1)))))\n  (define (get_word s)\n    (if (string-empty?\
    \ s)\n        \"\"\n        (if (char-whitespace? (string-ref s 0))\n        \
    \    \"\"\n            (string-append (string (string-ref s 0)) (get_word (substring\
    \ s 1))))))\n  (define (get_non_word s)\n    (if (string-empty? s)\n        \"\
    \"\n        (if (char-whitespace? (string-ref s 0))\n            (string (string-ref\
    \ s 0))\n            (get_non_word (substring s 1)))))\n  (define (all_words s)\n\
    \    (cond ((string-empty? s) '())\n          ((char-whitespace? (string-ref s\
    \ 0))\n           (cons (get_word (substring s 1)) (all_words (get_non_word (substring\
    \ s 1)))))\n          (else (all_words (substring s 1)))))\n  (define (filter_words\
    \ ws n)\n    (if (null? ws)\n        '()\n        (if (= n (check_word (car ws)))\n\
    \            (cons (car ws) (filter_words (cdr ws) n))\n            (filter_words\
    \ (cdr ws) n))))\n  (filter_words (all_words s) n))\n", "  (define (is_consonant?\
    \ c)\n    (not (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"y\"))))\n  (define\
    \ (get-words s)\n    (regexp-match* #rx\"([^ ]+)\" s))\n  (define (count-consonants\
    \ word)\n    (accumulate + 0 (map (lambda (c) (if (is_consonant? c) 1 0)) word)))\n\
    \  (filter (lambda (word) (= n (count-consonants word))) (get-words s)))\n\n",
  "  (cond\n    [(zero? n)\n     '()]\n    [(empty? s)\n     '()]\n    [else\n   \
    \  (remove empty?\n             (map (\u03BB (lst)\n                    (cond\n\
    \                      [(= n (length (filter consonant? lst)))\n             \
    \          (list->string lst)]\n                      [else\n                \
    \       '()]))\n                  (for/list ([lst (in-list (string-split s #\\\
    space))])\n                    lst)))]))\n", "  (define (starts-with? str1 str2)\n\
    \    (string=? (substring str1 0 (string-length str2)) str2))\n  (define (vowel?\
    \ str)\n    (starts-with? str \"a\")\n    (starts-with? str \"e\")\n    (starts-with?\
    \ str \"i\")\n    (starts-with? str \"o\")\n    (starts-with? str \"u\"))\n  (define\
    \ (count-consonants str)\n    (cond\n      [(empty? str) 0]\n      [(vowel? (first\
    \ str)) (count-consonants (rest str))]\n      [else (+ 1 (count-consonants (rest\
    \ str)))]))\n  (define (word? str)\n    (not (empty? str)))\n  (define (word-str\
    \ str)\n    (cond\n      [(not (word? str)) (string \"\")]\n      [(word? str)\
    \ (string-append (first str) (word-str (rest str)))]))\n  (define (space? str)\n\
    \    (and (not (empty? str)) (eq? (first str) #\\space)))\n  (define (space-str\
    \ str)\n    (cond\n      [(not (space? str)) (string \"\")]\n      [(space? str)\
    \ (string-append (first str) (space-str (rest str)))]))\n  (define (string-with-n-consonants?\
    \ str n)\n    (= n (count-consonants str)))\n  (define (append-chars str1 str2)\n\
    \    (string-append str1 str2))\n  (define (filter-strings f str)\n    (cond\n\
    \      [(empty? str) (string \"\")]\n      [(f (first str)) (append-chars (first\
    \ str) (filter-strings f (rest str)))]\n      [else (filter-strings f (rest str))]))\n\
    \  (define (get-words str)\n    (cond\n      [(empty? str) empty]\n      [(not\
    \ (empty? (word-str str))) (cons (word-str str) (get-words (filter-strings (lambda\
    \ (x) (not (", "  (cond [(empty? s) empty]\n        [else (append (list (head\
    \ s)) (select_words (tail s) n))]))\n", "  (cond\n    [(string=? s \"\") '()]\n\
    \    [else (define (select-words-helper r)\n            (cond\n              [(empty?\
    \ r) '()]\n              [(zero? (count-vowels (car r))) '()]\n              [(not\
    \ (zero? (count-vowels (car r)))) (cons (car r) (select-words-helper (cdr r)))]))\n\
    \     (select-words-helper (string-split s))]))\n", "  (define (check-word word)\n\
    \    (let loop ([word word] [n 0])\n      (if (empty? word)\n          (if (=\
    \ n 0)\n              '()\n              (cons (string-&gt;list word) '()))\n\
    \          (if (member (car word) (string-&gt;list \"aeiouAEIOU\"))\n        \
    \      (loop (cdr word) n)\n              (loop (cdr word) (- n 1))))))\n  (define\
    \ (select words)\n    (if (empty? words)\n        '()\n        (append (check-word\
    \ (car words)) (select (cdr words)))))\n  (select (string-split s #\\space)))\n",
  "  (filter (lambda (w) (= n (string-length (regexp-match #rx\"[bcdfghjklmnpqrstvwxz]+\"\
    \ w)))) (string-split s #rx\" \")))\n", "  (define (consonant? c) (not (or (char-alphabetic?\
    \ c) (char-whitespace? c))))\n  (define (count-consonants w)\n    (let loop ((w\
    \ w) (count 0))\n      (cond\n        ((null? w) count)\n        ((consonant?\
    \ (car w)) (loop (cdr w) (+ count 1)))\n        (else (loop (cdr w) count)))))\n\
    \  (define (select_words s n)\n    (if (string-null? s)\n        '()\n       \
    \ (let ((w (read-line s)))\n          (if (= n (count-consonants w))\n       \
    \       (cons w (select_words (read-line s) n))\n              (select_words (read-line\
    \ s) n)))))\n  (select_words (string->immutable-string s) n))", "  (cond [(empty?\
    \ s) empty]\n        [else (if (= n (count-consonants (car (string-split s))))\n\
    \                 (cons (car (string-split s)) (select-words (cdr (string-split\
    \ s)) n))\n                 (select-words (cdr (string-split s)) n))]))\n", " \
    \ (cond\n    [(empty? s) '()]\n    [else\n     (define s-list (string-&gt;list\
    \ s))\n     (define rest (select_words (string-join (cdr s-list)) n))\n     (if\
    \ (string=? (string-join (select s-list)) \"\")\n         rest\n         (cons\
    \ (string-join (select s-list)) rest))]))\n", "  (define (is-consonant? c)\n \
    \   (and (char-alphabetic? c)\n         (not (member c '(\"a\" \"e\" \"i\" \"\
    o\" \"u\" \"y\")))))\n  (map (lambda (w)\n         (when (= n (length (filter\
    \ is-consonant? w)))\n           w))\n       (string-split s #\\space)))\n", " \
    \ (for/list ([w (in-string s)])\n    (when (= n (count (lambda (x) (or (= x #\\\
    a) (= x #\\e) (= x #\\i) (= x #\\o) (= x #\\u))) (string->list w)))\n      w)))\n",
  "  (for/list ([word (in-string s)])\n    (when (= n (count-consonants word))\n \
    \     word)))", "  (cond\n    [(empty? s) empty]\n    [else\n     (if (equal?\
    \ n (number-of-consonants (first s)))\n         (cons (first s) (select-words\
    \ (rest s) n))\n         (select-words (rest s) n))]))\n", "  (let loop ([s s]\
    \ [ans '()])\n    (cond [(empty? s) (reverse ans)]\n          [(= n (count-consonants\
    \ (car (tokenize (take s 1)))))\n           (loop (drop s 1) (cons (take s 1)\
    \ ans))]\n          [else (loop (drop s 1) ans)])))\n", '  (filter (lambda (w)
    (= n (apply + (map (lambda (c) (if (consonant? c) 1 0)) w)))) (split-string s)))',
  "  (split s))\n</code>\nI would like to see a solution along with an explanation\
    \ for it (and I am not looking for a solution that works only for English).\n\
    I can split a string by each space by using <code>(split s)</code>, but how do\
    \ I count the consonants and also return only words that have n consonants? I\
    \ can't figure it out.\nI have tried something like this:\n<code>#lang racket\n",
  "  (if (string=? s \"\")\n      '()\n      (let loop ((s (string-split s)) (words\
    \ '()))\n        (cond ((null? s) words)\n              ((= n (count-consonants\
    \ (car s))) (loop (cdr s) (cons (car s) words)))\n              (else (loop (cdr\
    \ s) words))))))\n", "  (cond\n    [(empty? s) empty]\n    [else\n     (if (eq?\
    \ n (count-consonants (first (string-split s #\\space))))\n         (cons (first\
    \ (string-split s #\\space)) (select-words (second (string-split s #\\space))\
    \ n))\n         (select-words (second (string-split s #\\space)) n))]))\n", " \
    \ (cond [(empty? s) empty]\n        [else (cons (string-&gt;list (car (split-string\
    \ s))) \n                    (select_words (cdr (split-string s)) n))]))\n</code>\n\
    Why does this code return only first list?\n<code>&gt; (select_words \"Hello world\"\
    \ 2)\n'((#\\H #\\e #\\l #\\l #\\o) #\\  #\\w #\\o #\\r #\\l #\\d)\n</code>\nIf\
    \ I remove first <code>string-&gt;list</code> I will get this error:\n<code>;cons:\
    \ expected argument of type &lt;proper list&gt;; given #\\  \n</code>\nIt doesn't\
    \ seems like a proper list to me.\n\n\nA:\n\nI think you meant to do something\
    \ like this:\n<code>(define (select_words s n)\n  (cond [(empty? s) empty]\n \
    \       [else (cons (string-&gt;list (car (split-string s))) \n              \
    \      (select_words (cdr (split-string s)) n))]))\n</code>\nThe main problem\
    \ is that <code>split-string</code> splits on any whitespace. So, that means that\
    \ it will split on the space between \"Hello\" and \"world\". When you <code>string-&gt;list</code>\
    \ the first word, you are ignoring the space. You should write a procedure that\
    \ ignores that space.\nYou also need to make sure that you are calling <code>select_words</code>\
    \ recursively on the remaining string, not just the first word.\nI'm not sure\
    \ what you meant with the rest of the procedure, though. I would have written\
    \ the procedure like this:\n<code>(define (select_words s n)\n  (cond [(empty?\
    \ s) empty]\n        [else (if (correct-length? (car (split-string s)) n)\n  \
    \              (cons (car (split-string s)) (select_words (cdr (split-string s))\
    \ n))\n                (select_words (cdr (split-string s)) n))]))\n</code>\n\
    That is, if the first word is the correct length", "  (cond [(empty? s) empty]\n\
    \        [else\n         (if (= n (count-consonants (first (get-words s))))\n\
    \             (cons (first (get-words s)) (select-words (first s) n))\n      \
    \       (select-words (rest s) n))]))\n", "  (if (empty? s) '()\n      (cond ((equal?\
    \ (count-consonants s) n) (cons s '()))\n            (else (select_words (substring\
    \ s 1) n)))))\n", "  (if (string=? s \"\")\n      '()\n      (append (if (= n\
    \ (count-consonants (substring s 0 (string-index s #\\space))))\n            \
    \      (list (substring s 0 (string-index s #\\space)))\n                  '())\n\
    \              (select_words (substring s (+ 1 (string-index s #\\space))) n))))\n",
  "  (cond\n    [(empty? s) empty]\n    [else (cons (list-ref (list->string (list\
    \ (car s))) n)\n                (select_words (cdr s) n))]))\n", "  (for/list\
    \ ([i (in-string s)]\n             #:when (and\n                      (not (char-alphabetic?\
    \ i))\n                      (eq? n (count-consonants (regexp-match #rx\"\\w+\"\
    \ s)))))\n    (regexp-match #rx\"\\w+\" s)))\n", "  (define (is_consonant c)\n\
    \    (and (char-alphabetic? c)\n         (not (member c '(\"a\" \"e\" \"i\" \"\
    o\" \"u\" \"y\")))))\n  (define (consonants word)\n    (cond ((empty? word) 0)\n\
    \          ((is_consonant (first word)) (+ 1 (consonants (rest word))))\n    \
    \      (else (consonants (rest word)))))\n  (if (empty? s) '()\n      (cons (first\
    \ (regexp-match #rx\"\\w+\" s))\n            (select_words (rest (regexp-match\
    \ #rx\"\\w+\" s)) n))))\n\n", "  (define consonants '(#\\b #\\c #\\d #\\f #\\\
    g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\\
    z))\n  (define (is-consonant? c)\n    (member c consonants))\n  (define (consonant-count\
    \ word)\n    (local ((define (count-consonants word count)\n              (cond\n\
    \                [(empty? word) count]\n                [(is-consonant? (first\
    \ word)) (count-consonants (rest word) (+ count 1))]\n                [else (count-consonants\
    \ (rest word) count)])))\n      (count-consonants word 0)))\n  (local ((define\
    \ (select-words words acc)\n            (cond\n              [(empty? words) acc]\n\
    \              [(= n (consonant-count (first words))) (select-words (rest words)\
    \ (append acc (list (first words))))]\n              [else (select-words (rest\
    \ words) acc)])))\n    (select-words (string-&gt;list/c (string-split s \" \"\
    )) '())))\n</code>\n", "  (define (is_vowel x)\n    (member x '(#\\a #\\e #\\\
    i #\\o #\\u #\\y)))\n  (define (count-consonants s)\n    (define (is-con x)\n\
    \      (and (char-alphabetic? x) (not (is_vowel x))))\n    (length (filter is-con\
    \ (string->list s))))\n  (define (right-length? s)\n    (= n (count-consonants\
    \ s)))\n  (define (censor s)\n    (regexp-replace* #rx\"\\W+\" s \" \"))\n  (filter\
    \ right-length? (string-split (censor s) #\\space)))\n", "  (regexp-match* #rx\"\
    ([a-z]*[^aeiou ]{\" n \",}[a-z]*)\" s))\n", "  (cond\n    [(string=? s \"\") '()]\n\
    \    [else (map string-normalize-spaces (regexp-match* #rx\"\\w+\" s))]))\n",
  "  (string-&gt;list (string-trim s)))\n</code>\nThank you in advance!\n\n\nA:\n\n\
    Start with a well-known problem: splitting a string on a character.\n<code>(define\
    \ (split string char)\n  (match* (string char)\n    ['() '()]\n    [('() . rest)\
    \ (split rest char)]\n    [(list . rest)\n     (cons list (split rest char))]))\n\
    </code>\nNow, use a helper function to determine if a word is valid.\n<code>(define\
    \ (word-is-valid? word n)\n  (let loop ([word word] [consonants 0])\n    (if (empty?\
    \ word)\n        (= consonants n)\n        (if (char-consonant? (first word))\n\
    \            (loop (rest word) (+ consonants 1))\n            (loop (rest word)\
    \ consonants)))))\n</code>\nFinally, use <code>filter</code> to generate the desired\
    \ output.\n<code>(define (select-words string n)\n  (filter (\u03BB (word) (word-is-valid?\
    \ word n))\n          (split string #\\space)))\n</code>\n", "  (filter (lambda\
    \ (word) (= n (count-consonants word)))\n          (string-&gt;list s)))\n", " \
    \ (match (map (lambda (w) (if (= n (length (regexp-match #rx\"[^aeiouAEIOU\\s]\"\
    \ w))) w)) (string-split s))\n    ('() '())\n    (e e)))\n", "  (cond [(empty?\
    \ s) empty]\n        [else (if (= n (count-consonants (first (string-split s #\\\
    space))))\n                  (cons (first (string-split s #\\space))\n       \
    \                 (select-words (last (string-split s #\\space)) n))\n       \
    \           (select-words (last (string-split s #\\space)) n))]))\n", "  (cond\n\
    \    [(empty? s) empty]\n    [else (cond [(exactly-n-consonants? s n) (cons s\
    \ empty)]\n               [else (select_words (rest s) n)])]))\n", "  (cond\n\
    \    [(empty? s) empty]\n    [(&gt; (count-consonants (car (string-&gt;list s)))\
    \ n) (cons (car (string-&gt;list s)) (select_words (cdr (string-&gt;list s)) n))]\n\
    \    [else (select_words (cdr (string-&gt;list s)) n)]))\n</code>\nI understand\
    \ what the code is doing, but I'm not sure where to go from here.\n\n\nA:\n\n\
    You don't need to convert the <code>string</code> to a <code>list</code> of characters,\
    \ the <code>string-ref</code> function will do the job for you:\n<code>(define\
    \ (select-words s n)\n  (if (string-empty? s)\n      empty\n      (if (&gt; (count-consonants\
    \ (string-ref s 0)) n)\n          (cons (substring s 0 1) (select-words (substring\
    \ s 1) n))\n          (select-words (substring s 1) n))))\n</code>\nFor instance:\n\
    <code>(select-words \"Three words with five vowels.\" 5)\n=&gt; '(\"words\" \"\
    five\" \"vowels\")\n</code>\nHowever, you'll notice that the function above has\
    \ a performance problem:\n<code>(select-words (string (build-list 1000000 (lambda\
    \ (x) #\\a))) 5)\n&gt;&gt;&gt; Out of memory.\n</code>\nThat's because we're creating\
    \ new substrings every time we make a recursive call. Instead of building a new\
    \ substring for each recursion, we should pass along a pair of indexes that represent\
    \ the beginning and end of the substring, as in the following function:\n<code>(define\
    \ (select-words s start end n)\n  (if (&gt;= start end)\n      empty\n      (if\
    \ (&gt; (count-consonants (string-ref s start)) n)\n          (cons (substring\
    \ s start (+ start 1))\n                (select-words s (+ start 1) end n))\n\
    \          (select-words s (+ start 1) end n))))\n</code>\nNotice that we're",
  "  (match s\n    ['() '()]\n    [(cons (or #\\A #\\E #\\I #\\O #\\U #\\a #\\e #\\\
    i #\\o #\\u) xs)\n     (select_words xs n)]\n    [(cons c xs)\n     (append (cond\
    \ [(equal? n 0) (list (string-trim s))]\n                    [(zero? n) '()]\n\
    \                    [else (select_words xs (- n 1))])\n             (select_words\
    \ xs n))]))\n", "  (foldr (lambda (x xs) (if (= (consonants x) n) (cons x xs)\
    \ xs)) empty (string-split s)))\n", "  (define (is-consonant? c) (member c \"\
    qwrtypsdfghjklzxcvbnm\"))\n  (define (count-consonants s)\n    (if (empty? s)\
    \ 0\n        (+ (if (is-consonant? (first s)) 1 0)\n           (count-consonants\
    \ (rest s)))))\n  (if (empty? s)\n      empty\n      (if (= n (count-consonants\
    \ (word (first s))))\n          (cons (word (first s))\n                (select-words\
    \ (segment (rest s) empty) n))\n          (select-words (segment (rest s) empty)\
    \ n))))\n</code>\nBut it is not working, I am getting a <code>select-words: undefined;\
    \ cannot reference an identifier before its definition</code> error.\nI think\
    \ I am making some mistake in my recursion, but I can't seem to put my finger\
    \ on it, any help would be appreciated.\nAlso, is this the correct approach for\
    \ such a problem?\n\n\nA:\n\nThere are a couple of typos in your code. The main\
    \ problem is that you need to fix a typo: the name of the procedure is <code>select-words</code>,\
    \ not <code>select_words</code>.\n<code>(define (select-words s n)\n  (define\
    \ (is-consonant? c) (member c \"qwrtypsdfghjklzxcvbnm\"))\n  (define (count-consonants\
    \ s)\n    (if (empty? s) 0\n        (+ (if (is-consonant? (first s)) 1 0)\n  \
    \         (count-consonants (rest s)))))\n  (if (empty? s)\n      empty\n    \
    \  (if (= n (count-consonants (word (first s))))\n          (cons (word (first\
    \ s))\n                (select-words (segment (rest s) empty) n))\n          (select-words\
    \ (segment (rest s) empty) n))))\n</code>\n", "  (cond\n    [(empty? s) empty]\n\
    \    [else\n     (define (aux res)\n       (cond\n         [(empty? (rest res))\
    \ res]\n         [else\n          (define curr-word (first res))\n          (define\
    \ curr-cons (consonants-in-word curr-word))\n          (if (= n curr-cons)\n \
    \             (cons curr-word (aux (rest res)))\n              (aux (rest res)))]))\n\
    \     (aux (list->words s))]))\n", "  (for/list ([word (in-string s)])\n    (and\
    \ (= (count-consonants word) n)\n         word)))\n", "  (filter (lambda (word)\
    \ (count-consonants word n))\n          (string-split s #\\space)))\n", "  (regexp-match*\
    \ #rx\"\\w+\" s)\n  ;; (filter\n  ;;  (lambda (x)\n  ;;    (= n (length (regexp-match*\
    \ #rx\"[bcdfghjklmnpqrstvwxz]+\" x))))\n  ;;  (regexp-match* #rx\"\\w+\" s)))\n\
    \  )", "  (cond\n    [(string=? s \"\") '()]\n    [else (append (select_words\
    \ (substring s 1) n)\n                  (if (word? (substring s 0 1))\n      \
    \              (cons (substring s 0 1) '())\n                    '()))]))\n",
  "  (filter\n   (lambda (word)\n     (= n (length (regexp-match* #rx\"[^aeiouy\\\
    s]\" word))))\n   (string-split s #rx\"\\s+\")))\n", "  (match n\n    [(= 1) (filter\
    \ (string-contains s \"bcdfghjklmnpqrstvwxyz\") (string-split s))]\n    [(= 2)\
    \ (filter (string-contains s \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\"\
    ) (string-split s))]\n    [(= 3) (filter (string-contains s \"bcdfghjklmnpqrstvwxyz\"\
    \ \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\") (string-split s))]\n  \
    \  [(= 4) (filter (string-contains s \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\"\
    \ \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\") (string-split s))]\n  \
    \  [(= 5) (filter (string-contains s \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\"\
    \ \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\"\
    ) (string-split s))]\n    [(= 6) (filter (string-contains s \"bcdfghjklmnpqrstvwxyz\"\
    \ \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\"\
    \ \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz\") (string-split s))]\n  \
    \  [(= 7) (filter (string-contains s \"bcdfghjklmnpqrstvwxyz\" \"bcdfghjklmnpqrstvwxyz",
  "  (curry list-of-words (string-&gt;words s) n))\n", "  (cond [(empty? s) '()]\n\
    \        [else\n         (cond [(= (n_consonants s) n) (cons s (select_words (rest\
    \ s) n))]\n               [else (select_words (rest s) n)])]))\n", "  (for/list\
    \ ([word (in-string s)])\n    (if (= n (length (regexp-match* #rx\"[bcdfghjklmnpqrstvwxz]\"\
    \ word)))\n        word\n        '())))", "  (map (lambda (w) (string-append (drop-right\
    \ (string-&gt;list w) (- (string-length w) n))\n                             \
    \     (take (string-&gt;list w) n)))\n       (filter (lambda (w) (equal? (count-vowels\
    \ w) n))\n               (string-split s #\\space))))\n", "  (cond\n    [(empty?\
    \ s) empty]\n    [else (cons (first (match (regexp #rx\"\\w+\") s)) \n       \
    \         (select_words (substring s (regexp-match-end 0)) n))]))", "  (define\
    \ (select_words_iter s n result)\n    (if (empty? s)\n        result\n       \
    \ (if (= n (count-vowels (string-&gt;list (car s))))\n            (select_words_iter\
    \ (cdr s) n (cons (car s) result))\n            (select_words_iter (cdr s) n result))))\n\
    \  (reverse (select_words_iter (string-&gt;list s) n '())))\n", "  (for/list ([word\
    \ (in-list (regexp-match* #rx\"\\S+\" s))]\n             #:when (and (not (empty?\
    \ word)) (= n (word-consonants word))))\n    word))\n", "  (define (is_consonant\
    \ c)\n    (let ((lc (string-downcase c)))\n      (not (or (equal? c \" \")\n \
    \              (equal? lc \"a\")\n               (equal? lc \"e\")\n         \
    \      (equal? lc \"i\")\n               (equal? lc \"o\")\n               (equal?\
    \ lc \"u\")))))\n  (define (count-consonants str)\n    (for/fold ([acc 0]) ([c\
    \ (in-string str)])\n      (if (is_consonant c) (add1 acc) acc)))\n  (filter (\u03BB\
    \ (word) (= n (count-consonants word)))\n          (string-split s)))\n\n</code>\n",
  "  (for/list ([w (in-list (string-split s))]\n             #:when (eq? n (count\
    \ (lambda (c) (not (char-alphabetic? c))) w)))\n    w))\n", "  (select-words-help\
    \ s n '() '()))\n", "  (cond [(empty? s) empty]\n        [else (or (equal? n 0)\
    \ (equal? n (length (filter vowel? (string-&gt;list s)))))\n               (cons\
    \ (list-ref (string-&gt;list s) 0)\n                     (select_words (substring\
    \ s 1 (string-length s)) n))]))\n</code>\nAny help would be greatly appreciated!\n",
  "  (cond [(empty? s) empty]\n        [else (filter (lambda (w) (= n (word-consonants\
    \ w))) (string-split s #\\space))]))\n", "  (for/list ((word (regexp-match #rx\"\
    \\S+\" s)))\n    (when (= n (count (string-replace word (rx\"AEIOUaeiou\") #\"\
    \")))\n      word)))\n", "  (cond [(empty? s) empty]\n        [else (define w\
    \ (first (regexp-match* #rx\"[a-zA-Z]+\" s)))\n              (define (is-word-satisfying-requirements?\
    \ w n)\n                (define (is-consonant? c) (not (regexp-match* #rx\"[aeiouy]+\"\
    \ (string c))))\n                (define (is-consonant-count? count c)\n     \
    \             (if (is-consonant? c)\n                      (is-consonant-count?\
    \ (+ count 1) (string-ref w (- (string-length w) 1)))\n                      count))\n\
    \                (= n (is-consonant-count? 0 (string-ref w 0))))\n           \
    \   (if (is-word-satisfying-requirements? w n)\n                  (cons w (select_words\
    \ (regexp-replace* #rx(rx (seq (seq \"^\" (? \" \")) w)\n                    \
    \                                             (seq (? \" \") (seq (seq \"$\" eos)\
    \ (not blank))))\n                                                       s \"\"\
    ))\n                                      n))]))", "  (define letters '(\"a\"\
    \ \"e\" \"i\" \"o\" \"u\"))\n  (define words (string-split s))\n  (for/list ([word\
    \ words])\n    (define word-length (string-length word))\n    (define number-of-consonants\
    \ (for/sum ([i (in-range word-length)])\n                                    \
    \      (if (member (string-ref word i) letters) 0 1)))\n    (if (= number-of-consonants\
    \ n)\n        word)))\n", "  (filter (\u03BB (x) (= n (count-consonants x))) (string-&gt;words\
    \ s)))\n", "  (if (equal? (count-words s) 0)\n      '()\n      (append (substring\
    \ s 1)\n              (substring s (count-words s)))))\n", "  (cond ((null? s)\
    \ '())\n        ((null? (regexp-match #rx\"^[bcdfghjklmnpqrstvwxz]+$\" s)) '())\n\
    \        ((= n (string-length (regexp-match #rx\"^[bcdfghjklmnpqrstvwxz]+\" s)))\n\
    \         (cons (regexp-match #rx\"^[bcdfghjklmnpqrstvwxz]+\" s)\n           \
    \    (select_words (regexp-replace #rx\"^[bcdfghjklmnpqrstvwxz]+\" s \"\") n)))\n\
    \        (else (select_words (regexp-replace #rx\"^[bcdfghjklmnpqrstvwxz]+\" s\
    \ \"\") n))))\n", "  (list-&gt;string (filter (lambda (w)\n                  \
    \         (= n (char-set-count #\\consonants (string-&gt;char-set w))))\n    \
    \                     (string-&gt;list s))))\n</code>\nor the straightforward\
    \ solution:\n<code>#lang racket\n", "  (filter (lambda (word)\n            (=\
    \ n (count (lambda (char) (not (member char '(#\\a #\\e #\\i #\\o #\\u))))\n \
    \                       (string->list word))))\n          (string-split s #\\\
    space)))\n</code>\n", "  (let ([list (list)])\n    (for ([i (in-range (string-length\
    \ s))])\n      (define substring (substring s i (min (+ i n) (string-length s))))\n\
    \      (define list-of-syllables (string-split substring \" \"))\n      (define\
    \ word (first list-of-syllables))\n      (define consonants (count-consonants\
    \ word))\n      (when (= consonants n)\n        (set! list (append list (list\
    \ word)))))\n    list))\n", "  (cond\n    [(empty? s) empty]\n    [else (cons\
    \ (first s) (select_words (rest s) n))]))\n</code>\nIdeally, given the input <code>'(\u201C\
    Mississippi\u201D 5)</code>, the output would be <code>'(\u201CMississippi\u201D\
    )</code>. \nI'm not sure how to go about this. I also got some feedback saying\
    \ I should use <code>cond</code> instead of <code>if</code> in the code.\n\n\n\
    A:\n\nI would use <code>regexp-match</code> for this, using a regexp which defines\
    \ a word as being a sequence of one or more letters, a word boundary, and then\
    \ one or more letters. As for counting the number of consonants, we can use a\
    \ helper function <code>count-consonants</code> that uses <code>regexp-match</code>\
    \ to count the number of matches for a regexp which defines a consonant as being\
    \ a letter other than A, E, I, O, or U.\n<code>(define (count-consonants str)\n\
    \  (regexp-match* #rx\"[^aeiou]+\" str #:count))\n", "  (cond\n    [(empty? s)\
    \ empty]\n    [else (cons (list-ref (list-of-strings-ref s n) 0)\n           \
    \     (select_words (list-ref (list-of-strings-ref s n) 1) n))]))\n", "  (for/list\
    \ ((word (in-string s))\n             #:when (= n\n                     (for/sum\
    \ ((ch (in-string word))\n                               #:when (consonant? ch))\n\
    \                       1)))\n    word))\n", "  (cond ((equal? (string-length\
    \ s) 0) '())\n        ((equal? n 0) (list (string-trim s)))\n        (else (letrec\
    \ ([aux (lambda (s acc)\n                              (cond ((equal? (string-length\
    \ s) 0) acc)\n                                    ((equal? (string-ref s 0) #\\\
    \ ) (cons (string-trim (string-drop-right s 1)) acc))\n                      \
    \              (else (aux (string-drop-right s 1) acc))))])\n                \
    \ (aux s '())))))\n</code>\n\n<code>#lang racket\n", "  (filter (\u03BB (x) (equal?\
    \ n (count-consonants x)))\n          (split-string s #rx\" +\")))\n", "  (match\
    \ s\n    [(list) empty]\n    [(list #\\(or #\\a #\\e #\\i #\\o #\\u) (rest s)]\n\
    \    [(list #\\(or #\\a #\\e #\\i #\\o #\\u) (rest s)]\n    [(list #\\(or #\\\
    a #\\e #\\i #\\o #\\u) (rest s)]\n    [(list #\\(or #\\a #\\e #\\i #\\o #\\u)\
    \ (rest s)]\n    [(list #\\(or #\\a #\\e #\\i #\\o #\\u) (rest s)]\n    [else\
    \ (cons (list (first s)) (select_words (rest s) n))]))\n</code>\n\nQuestion\n\
    How to count number of elements in the list? I can't use the <code>length</code>\
    \ function because it will be inaccurate. I want to count the number of vowels\
    \ that appear in the list.\n\n\nA:\n\nYou can use <code>length</code> and accumulate\
    \ the count in a helper function:\n<code>(define (count-consonants str)\n  (define\
    \ (helper str count)\n    (if (empty? str)\n        count\n        (let ([ch (first\
    \ str)])\n          (cond [(or (char=? ch #\\a)\n                     (char=?\
    \ ch #\\e)\n                     (char=? ch #\\i)\n                     (char=?\
    \ ch #\\o)\n                     (char=? ch #\\u))\n                 (helper (rest\
    \ str) count)]\n                [else (helper (rest str) (+ count 1))]))))\n \
    \ (helper str 0))\n</code>\n", "  (local ((define (helper str)\n            (for/list\
    \ ([word (in-string (string-split str \" \"))])\n              (when (= n (list-length\
    \ (keep (lambda (char)\n                                              (not (or\
    \ (char-in-range? char #\\a #\\z)\n                                          \
    \             (char-in-range? char #\\A #\\Z))))\n                           \
    \                 (string->list word))))\n                word))))\n    (if (=\
    \ 0 (string-length s))\n        empty\n        (helper s))))\n", "  (filter (lambda\
    \ (word) (= n (length (filter (lambda (c) (not (vowel? c))) word))))\n       \
    \   (string-split s #\\space)))\n", "  (cond\n    [(empty? s) empty]\n    [else\
    \ (regexp-match?\n            #rx\"([a-zA-Z])*\"\n            (regexp-match? #rx\"\
    ([a-zA-Z]+)+\" s) )]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
