name: HumanEval_3_below_zero
language: rkt
prompt: "#lang racket\n\n;; You're given a list of deposit and withdrawal operations\
  \ on a bank account that starts with\n;; zero balance. Your task is to detect if\
  \ at any point the balance of account fallls below zero, and\n;; at that point function\
  \ should return True. Otherwise it should return False.\n(define (below_zero operations)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate below_zero))\n\
  \    (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list 1\
  \ 2 -3 1 2 -3)) #f)\n    (check-equal? (candidate (list 1 2 -4 5 6)) #t)\n    (check-equal?\
  \ (candidate (list 1 -1 2 -2 5 -5 4 -4)) #f)\n    (check-equal? (candidate (list\
  \ 1 -1 2 -2 5 -5 4 -5)) #t)\n    (check-equal? (candidate (list 1 -2 2 -2 5 -5 4\
  \ -4)) #t)\n))\n\n(test-humaneval)"
completions: ["  (define (rec balance operations)\n    (cond [(null? operations) #f]\n\
    \          [(= (car operations) '+ ) (rec (+ balance (cadr operations)) (cddr\
    \ operations))]\n          [(= (car operations) '- ) (if (= (- balance (cadr operations))\
    \ 0)\n                                          (rec (- balance (cadr operations))\
    \ (cddr operations))\n                                          (rec (- balance\
    \ (cadr operations)) (cddr operations)))]\n          [else (error \"Unknown operation:\
    \ ~a\" (car operations))]))\n  (rec 0 operations))\n", "  (cond\n    [(zero? operations)\n\
    \     #f]\n    [(eq? (caar operations) 'deposit)\n     (below_zero (cdr operations))]\n\
    \    [(eq? (caar operations) 'withdraw)\n     (or (negative? (cadr (car operations)))\n\
    \         (below_zero (cdr operations)))]))\n", "  (let loop ([operations operations]\n\
    \             [balance 0])\n    (cond [(empty? operations) false]\n          [(<\
    \ balance 0) true]\n          [else (loop (rest operations)\n                \
    \      (+ balance (first operations)))])))\n", "  (define (below-zero-iter total\
    \ ops)\n    (if (empty? ops)\n        (or (< total 0)\n            false)\n  \
    \      (begin\n          (below-zero-iter (+ total (first ops)) (rest ops)))))\n\
    \  (below-zero-iter 0 operations))\n", "    (define (operation_sum lst)\n    \
    \    (if (null? lst)\n            0\n            (+ (car lst) (operation_sum (cdr\
    \ lst)))))\n    (< (operation_sum operations) 0))\n", "  (define (check operations-acc\
    \ balance)\n    (if (null? operations-acc)\n        (cond [(< balance 0) #t]\n\
    \              [else #f])\n        (let* ([operation (car operations-acc)]\n \
    \              [value (cdr operation)]\n               [balance (+ balance value)])\n\
    \          (check (cdr operations-acc) balance))))\n  (check operations 0))\n",
  "  (let loop ([operations operations]\n             [balance 0])\n    (if (empty?\
    \ operations)\n        (not (positive? balance))\n        (if (positive? (first\
    \ operations))\n            (loop (rest operations) (+ balance (first operations)))\n\
    \            (loop (rest operations) (- balance (first operations)))))))\n", " \
    \ (define (balance account)\n    (foldl + 0 account))\n  (define (process account\
    \ acc)\n    (cond\n      [(< (balance account) 0) true]\n      [else (balance\
    \ account)]))\n  (foldl process 0 operations))\n", "  (let loop ([ops operations]\
    \ [bal 0])\n    (cond [(null? ops) #f]\n          [(equal? (apply + bal (car ops))\
    \ 0) (loop (cdr ops) bal)]\n          [(< (apply + bal (car ops)) 0) #t]\n   \
    \       [else (loop (cdr ops) (apply + bal (car ops)))])))\n\n", "  (let loop\
    \ ([operations operations]\n             [balance 0])\n    (cond [(empty? operations)\n\
    \           false]\n          [(< balance 0)\n           true]\n          [else\n\
    \           (let ([operation (first operations)])\n             (loop (rest operations)\n\
    \                   (+ balance (if (eq? (first operation) 'debit)\n          \
    \                        (- (second operation))\n                            \
    \      (second operation)))))])))", "  (define (below_zero-iter current-balance\
    \ ops)\n    (if (null? ops)\n        false\n        (if (&lt; current-balance\
    \ 0)\n            true\n            (below-zero-iter (apply (first ops) current-balance\
    \ (rest ops)) (rest ops)))))\n  (below-zero-iter 0 operations))\n", "    (let\
    \ ([balance 0])\n        (for ([op operations])\n            (if (zero? (- balance\
    \ (cdr op)))\n                (void)\n                (set! balance (+ balance\
    \ (cdr op))))\n            (if (&lt; balance 0)\n                (return #t)))))\n",
  "  (define (accumulate-ops balance ops)\n    (cond\n      [(empty? ops) balance]\n\
    \      [(>= balance 0) (accumulate-ops (+ balance (first ops)) (rest ops))]\n\
    \      [else true]))\n  (accumulate-ops 0 operations))\n", "  (define (below_zero?\
    \ balance operations)\n    (if (null? operations)\n        (not (positive? balance))\n\
    \        (below_zero? (apply_operation balance (car operations)) (cdr operations))))\n\
    \  (below_zero? 0 operations))\n", "  (cond\n    [(null? operations) false]\n\
    \    [(< (apply - (first operations)) 0) true]\n    [else (below_zero (rest operations))]))\n",
  "  (foldl (lambda (operation balance)\n           (cond [(and (= operation \"W\"\
    )\n                       (> balance 0)) (- balance 10)]\n                 [(=\
    \ operation \"D\") (+ balance 10)]\n                 [else balance]))\n      \
    \   0\n         operations))\n", "  (cond\n    [(empty? operations) false]\n \
    \   [(zero? (first operations)) (below_zero (rest operations))]\n    [(and (<\
    \ (first operations) 0) (zero? (apply + (rest operations)))) true]\n    [else\
    \ (below_zero (rest operations))]))\n```\n\n### Group of n consecutive digits\n\
    [link](https://www.codewars.com/kata/52423db9add6f6fc39000354)\n\n```#lang racket\n",
  "  (if (null? operations)\n      false\n      (let loop ([balance 0] [ops operations])\n\
    \        (cond [(< balance 0) true]\n              [(null? ops) false]\n     \
    \         [else (loop (+ balance (car ops)) (cdr ops))]))))", "  (define (below_zero'\
    \ ops balance)\n    (cond [(empty? ops)\n           #f]\n          [(< balance\
    \ 0)\n           #t]\n          [else\n           (below_zero' (rest ops) (+ balance\
    \ (first ops)))]))\n  (below_zero' operations 0))\n", "  (let loop ([i 0] [result\
    \ '()])\n    (if (= i (length operations))\n        (member 0 result)\n      \
    \  (loop (+ i 1) (cons (+ (car operations) (car result)) (cdr result))))))\n",
  "  (define (below-zero? balance ops)\n    (cond\n      [(empty? ops) #f]\n     \
    \ [(>= balance 0) (below-zero? (add1 (car ops)) (cdr ops))]\n      [else #t]))\n\
    \  (below-zero? 0 operations))\n", "  (let loop ([balance 0] [ops operations])\n\
    \    (cond [(empty? ops) false]\n          [(and (negative? balance) (apply -\
    \ balance)) true]\n          [else (loop (+ balance (car ops)) (cdr ops))])))\n\
    </code>\n", "  (or (null? operations)\n      (if (< (first operations) 0)\n  \
    \        #t\n          (below_zero (rest operations)))))", "  (define balance\
    \ 0)\n  (for/or ([operation operations])\n    (match operation\n      [(list 'deposit\
    \ amount)\n       (set! balance (+ balance amount))]\n      [(list 'withdrawal\
    \ amount)\n       (set! balance (- balance amount))]\n      [_ (error 'below_zero\
    \ \"Unknown operation\")])\n    (< balance 0)))\n", "  (local [(define (evaluate-balance\
    \ result b)\n             (cond\n               [(empty? b) result]\n        \
    \       [(< result 0) #t]\n               [else (evaluate-balance (+ result (car\
    \ b)) (cdr b))]))]\n    (evaluate-balance 0 operations)))\n", "  (zero? (apply\
    \ + (map (\u03BB (transaction) (cadr transaction)) operations))))", "  (let loop\
    \ ([rest operations] [balance 0])\n    (cond [(empty? rest) #f]\n          [(negative?\
    \ balance) #t]\n          [else (loop (rest rest) (+ balance (first rest)))])))\n",
  "  (foldl (lambda (op balance)\n           (if (< balance 0)\n               #t\n\
    \               (+ balance (if (eq? (first op) 'deposit)\n                   \
    \           (second op)\n                              (- (second op))))))\n \
    \        0\n         operations))\n", "  (define (iter ops remaining)\n    (cond\n\
    \      [(null? ops) remaining]\n      [(negative? remaining) #t]\n      [else\
    \ (iter (cdr ops) (+ remaining (car ops)))]))\n  (iter operations 0))\n", "  (if\
    \ (null? operations)\n      #f\n      (let ((current-balance (car operations)))\n\
    \        (if (list? current-balance)\n            (let ((deposit (car current-balance))\n\
    \                  (withdrawal (cadr current-balance)))\n              (if (&lt;\
    \ (- deposit withdrawal) 0)\n                  #t\n                  (below_zero\
    \ (cdr operations))))\n            (if (&lt; current-balance 0)\n            \
    \    #t\n                (below_zero (cdr operations)))))))\n", "  (let ([start-balance\
    \ 0])\n    (for/or ([o operations])\n      (let ([new-balance (+ start-balance\
    \ o)])\n        (if (< new-balance 0)\n            #t\n            (set! start-balance\
    \ new-balance))))))\n", "  (define (iter operations balance)\n    (if (null? operations)\n\
    \        (equal? balance 0)\n        (iter (cdr operations) (+ balance (car operations)))))\n\
    \  (iter operations 0))\n", "  (let loop ([ops operations] [balance 0])\n    (if\
    \ (null? ops)\n        #f\n        (let ([op (car ops)])\n          (if (< (+\
    \ balance op) 0)\n              #t\n              (loop (cdr ops) (+ balance op)))))))\n",
  "  (let loop ([balance 0] [ops operations])\n    (cond [(empty? ops)\n         \
    \  false]\n          [(negative? (car ops))\n           (if (< (+ balance (car\
    \ ops)) 0)\n               true\n               (loop (+ balance (car ops)) (cdr\
    \ ops)))]\n          [else\n           (loop (+ balance (car ops)) (cdr ops))])))\n",
  "  (let loop ([operations operations]\n             [sum 0])\n    (cond\n      [(null?\
    \ operations) #f]\n      [(< sum 0) #t]\n      [else (loop (cdr operations) (+\
    \ sum (car operations)))])))\n", "  (cond [(empty? operations) #f]\n        [(<\
    \ (car operations) 0) #t]\n        [else (below_zero (cdr operations))]))\n",
  "  (local ((define (iter balance ops)\n            (cond [(empty? ops) #f)\n   \
    \               [(negative? (+ balance (first ops))) #t]\n                  [else\
    \ (iter (+ balance (first ops)) (rest ops))])))\n    (iter 0 operations)))\n",
  "    (foldl (lambda (op acc)\n              (if (< acc 0) true\n               \
    \   (cond ((= op 'withdraw) (- acc))\n                        ((= op 'deposit)\
    \ (+ acc)))))\n              0\n              operations))", "  (foldl (lambda\
    \ (op balance)\n           (if (negative? balance) #t #f))\n         0\n     \
    \    operations))", "  (define (update balance [op (cons 0 0)])\n    (cond\n \
    \     [(< (add1 (- (car op) (cdr op))) 0) #t]\n      [else (add1 (- (car op) (cdr\
    \ op)))]))\n  (foldl update 0 operations))\n", "  (define (below_zero-iter balance\
    \ operations)\n    (cond\n      [(empty? operations) false]\n      [(< balance\
    \ 0) true]\n      [else (below-zero-iter (+ balance (first operations)) (rest\
    \ operations))]))\n  (below-zero-iter 0 operations))", "  (let loop ([ops operations]\
    \ [acc 0])\n    (cond\n      [(empty? ops) (not (positive? acc))]\n      [(<=\
    \ acc 0) #t]\n      [else (loop (rest ops) (+ acc (first ops)))])))\n", "  (cond\n\
    \    [(empty? operations) false]\n    [(< (accumulate + 0 operations) 0) true]\n\
    \    [else (below_zero (rest operations))]))\n", "  (let loop ([balance 0] [rest\
    \ operations])\n    (if (null? rest)\n        #f\n        (let ([num (string->number\
    \ (cadr rest))])\n          (if (< balance 0)\n              #t\n            \
    \  (if (string=? (car rest) \"deposit\")\n                  (loop (+ balance num)\
    \ (cddr rest))\n                  (loop (- balance num) (cddr rest))))))))\n",
  "  (foldl (\u03BB (op acc) (if (negative? acc) #t (case op\n                   \
    \                          [(+ _) (+ acc (last op))]\n                       \
    \                      [(- _) (- acc (last op))])))\n         0\n         operations))\n",
  "  (define (check-withdrawal balance op)\n    (if (< (- balance (cdr op)) 0)\n \
    \       #t\n        (check-withdrawal (- balance (cdr op)) (cdr op))))\n  (define\
    \ (check-deposit balance op)\n    (if (pair? (cdr op))\n        (if (< (- balance\
    \ (car op)) 0)\n            #t\n            (check-deposit (+ balance (car op))\
    \ (cdr op)))\n        (if (< (- balance (car op)) 0)\n            #t\n       \
    \     #f)))\n  (if (pair? operations)\n      (check-deposit 0 operations)\n  \
    \    #f))\n", "  (define (iter ops bal)\n    (cond [(empty? ops)\n           false]\n\
    \          [(< bal 0)\n           true]\n          [else\n           (let ([op\
    \ (first ops)])\n             (cond [(symbol=? op 'deposit)\n                \
    \    (iter (rest ops) (+ bal (second ops)))]\n                    [(symbol=? op\
    \ 'withdraw)\n                     (iter (rest ops) (- bal (second ops)))]))]))\n\
    \  (iter operations 0))\n", "  (local ((define (walk list balance)\n         \
    \   (if (empty? list) #f\n              (let* ([item (first list)]\n         \
    \            [op (first item)]\n                     [val (second item)])\n  \
    \              (cond [(string=? op \"deposit\") (walk (rest list) (+ balance val))]\n\
    \                      [(string=? op \"withdraw\") (walk (rest list) (- balance\
    \ val))]\n                      [else (error \"Unknown operation\")])))))\n  \
    \  (walk operations 0)))\n", "  (cond\n    [(empty? operations) #f]\n    [(negative?\
    \ (balance operations)) #t]\n    [else (below_zero (rest operations))]))\n", " \
    \ (let loop ([ops operations] [balance 0])\n    (cond\n      [(empty? ops) #f]\n\
    \      [(< balance 0) #t]\n      [else (loop (rest ops) (+ balance (first ops)))])))\n",
  "  (define initial-balance 0)\n  (for/or ([operation operations])\n    (define balance\
    \ (+ initial-balance operation))\n    (if (< balance 0)\n        (return #t))))\n",
  "  (cond\n    [(empty? operations) false]\n    [(< (accumulate + 0 operations) 0)\
    \ true]\n    [else (below_zero (rest operations))]))\n\n", "  (local ((define\
    \ (loop operations balance)\n            (cond\n              [(null? operations)\
    \ balance]\n              [(>= balance 0) (loop (cdr operations) (+ balance (car\
    \ operations)))]\n              [else true])))\n    (loop operations 0)))\n",
  "  (for/or ([op (in-list operations)])\n    (begin 0 (if (positive? op) (add1 op)\
    \ (sub1 op))\n           (if (negative? op) #t #f))))\n", "  (define (below-zero-inner\
    \ ops balance)\n    (match ops\n      [(cons (cons 'deposit amount) rest) (below-zero-inner\
    \ rest (+ balance amount))]\n      [(cons (cons 'withdraw amount) rest) (below-zero-inner\
    \ rest (- balance amount))]\n      [(cons '[] balance)\n       (if (&lt; balance\
    \ 0) True False)]))\n  (below-zero-inner operations 0))\n", "  (define (balance\
    \ operations)\n    (foldl (lambda (operation value)\n             (cond [(symbol=?\
    \ operation 'deposit) (+ value 100)]\n                   [(symbol=? operation\
    \ 'withdraw) (- value 100)]))\n           0\n           operations))\n  (cond\
    \ [(< (balance operations) 0) #t]\n        [else #f]))\n```\n### 1.1.7 Problem\n\
    \n```", "  (define (iter operations balance)\n    (if (empty? operations)\n  \
    \      false\n        (if (< (last operations) 0)\n            (> (last operations)\
    \ (- balance))\n            (iter (drop-right operations 1) (- balance (last operations))))))\n\
    \  (iter operations 0))\n", "  (define (below-zero-iter ops acc)\n    (if (null?\
    \ ops)\n        false\n        (if (and (negative? acc)\n                 (positive?\
    \ (car ops)))\n            true\n            (below-zero-iter (cdr ops) (+ acc\
    \ (car ops))))))\n  (below-zero-iter operations 0))\n", "  (let* ([fold-fn (lambda\
    \ (b op) (if (string=? (car op) \"deposit\") (+ b (car (cdr op))) (- b (car (cdr\
    \ op)))))]\n         [balance (foldl fold-fn 0 operations)])\n    (< balance 0)))\n",
  "  (let loop ([balance 0] [operations operations])\n    (if (null? operations)\n\
    \        #f\n        (let ([operation (car operations)])\n          (cond [(eq?\
    \ (first operation) 'deposit) (loop (+ balance (second operation)) (cdr operations))]\n\
    \                [(eq? (first operation) 'withdraw) (loop (- balance (second operation))\
    \ (cdr operations))]\n                [else (error 'below_zero \"unknown operation\"\
    \ operation)])))))\n</code>\nExamples\n<code>&gt; (below_zero '((deposit 100)\
    \ (withdraw 50) (deposit 50)))\n#f\n&gt; (below_zero '((deposit 100) (withdraw\
    \ 150) (deposit 50)))\n#t\n</code>\n", "  (local ((define (go ops bal)\n     \
    \       (cond\n              [(empty? ops) #f]\n              [(< bal 0)     #t]\n\
    \              [else         (go (rest ops) (+ bal (first ops)))])))\n    (go\
    \ operations 0)))\n", "  (define (below_zero-iter operations balance)\n    (if\
    \ (empty? operations)\n        #f\n        (define current-operation (first operations))\n\
    \        (define new-balance (+ balance current-operation))\n        (if (< new-balance\
    \ 0)\n            #t\n            (below_zero-iter (rest operations) new-balance))\n\
    \      )\n    )\n  (below_zero-iter operations 0)\n  )\n", "  (cond\n    [(empty?\
    \ operations) #f]\n    [(< (accumulate + 0 operations) 0) #t]\n    [else #f]))\n",
  "  (if (null? operations)\n      false\n      (if (not (null? (cdr operations)))\n\
    \          (if (< (car operations) 0)\n              (if (< (- (car operations)\
    \ (cadr operations)) 0)\n                  true\n                  (below_zero\
    \ (cdr operations)))\n              (below_zero (cdr operations)))\n         \
    \ false)))\n```\n\n```", "  (for/or ([op (in-list operations)])\n          (apply\
    \ < (op) (list 0))))", "    (let loop ((operations operations)\n             \
    \  (balance 0))\n        (if (null? operations)\n            false\n         \
    \   (if (< balance 0)\n                true\n                (loop (cdr operations)\n\
    \                      (+ balance (if (null? (cdr operations)) 0\n           \
    \                        (car operations))))))))\n", "  (if (empty? operations)\n\
    \      #f\n      (let ((current (car operations))\n            (rest (cdr operations)))\n\
    \        (if (< current 0)\n            #t\n            (below_zero rest)))))\n",
  "  (define (loop operations balance)\n    (cond [(empty? operations) #f]\n     \
    \     [(< balance 0) #t]\n          [else (loop (rest operations)\n          \
    \            (+ balance (car operations)))]))\n  (loop operations 0))\n", "  (let\
    \ loop ([balance 0] [operations operations])\n    (if (null? operations)\n   \
    \     false\n        (let ([op (car operations)])\n          (cond\n         \
    \   [(< (car op) 0)\n             (or (< balance (car op))\n                 (loop\
    \ (+ balance (car op)) (cdr operations)))]\n            [else\n             (loop\
    \ (+ balance (car op)) (cdr operations))])))))\n", "  (define (below_zero-iter\
    \ ops sum)\n    (if (null? ops)\n        (> sum 0)\n        (cond ((= 'withdraw\
    \ (first ops))\n               (below_zero-iter (rest ops) (- sum (second ops))))\n\
    \              ((= 'deposit (first ops))\n               (below_zero-iter (rest\
    \ ops) (+ sum (second ops)))))))\n  (below_zero-iter operations 0))\n", "  (let\
    \ loop ([o (reverse operations)] [b 0])\n    (if (null? o)\n        #f\n     \
    \   (let-values ([(dt n) (first o)])\n          (if (and (eq? dt 'deposit)\n \
    \                  (< b n))\n              #t\n              (loop (rest o) (+\
    \ b n)))))))\n", "  (let loop ([ops operations] [balance 0])\n    (cond [(empty?\
    \ ops) #f]\n          [(< (balance ops) 0) #t]\n          [else (loop (rest ops)\
    \ (+ balance (first ops)))])))", "  (let loop ([operations operations]\n     \
    \        [balance 0])\n    (if (empty? operations)\n        #f\n        (let ([operation\
    \ (first operations)])\n          (if (and (not (positive? balance))\n       \
    \            (or (negative? operation)\n                       (positive? balance\
    \ (+ operation))))\n              #t\n              (loop (rest operations) (+\
    \ balance operation)))))))\n", "  (let loop ([balance 0] [ops operations])\n \
    \   (cond [(empty? ops) #f]\n          [(< balance 0) #t]\n          [else (loop\
    \ (+ balance (first ops)) (rest ops))])))", "  (let loop ([balance 0] [ops operations])\n\
    \    (cond [(null? ops) #f]\n          [(< balance 0) #t]\n          [else (loop\
    \ (+ balance (car ops)) (cdr ops))])))\n", "  (let loop ([balance 0] [ops operations])\n\
    \    (cond [(empty? ops) false]\n          [(< (first ops) 0)\n           (let\
    \ ([balance1 (+ balance (first ops))])\n             (if (< balance1 0)\n    \
    \             true\n                 (loop balance1 (rest ops))))]\n         \
    \ [else (loop (+ balance (first ops)) (rest ops))])))\n", "  (define (iter ops\
    \ balance)\n    (if (null? ops)\n        (not (< balance 0))\n        (iter (cdr\
    \ ops)\n              (+ balance (car ops)))))\n  (iter operations 0))\n", " \
    \ (let loop ([ops operations] [balance 0])\n    (cond [(empty? ops) #f]\n    \
    \      [(< balance 0) #t]\n          [else (loop (rest ops) (+ balance (car ops)))])))\n",
  "  (for/or ([operation operations])\n    (equal? (second operation) \"WITHDRAWAL\"\
    )\n    (and (equal? (second operation) \"DEPOSIT\")\n         (apply + (map (lambda\
    \ (elt)\n                         (if (equal? (second elt) \"WITHDRAWAL\")\n \
    \                            (- (first elt))\n                             (first\
    \ elt)))\n                       operations)))))\n", "  (for/or ([(balance _)\
    \ operations]\n           #:break (negative? balance))\n    (negative? balance)))\n",
  "  (let loop ([ops operations] [current-balance 0])\n    (cond [(empty? ops) #f]\n\
    \          [(< current-balance 0) #t]\n          [else (loop (rest ops) (+ current-balance\
    \ (first ops)))])))", "  (for/or ([operation operations])\n          (andlt; 0\
    \ (- (first operation) (second operation)))))\n</code>\nIf you know Python, you\
    \ can think of Racket as Python, with a much more powerful <code>for</code> loop.\n",
  "  (if (null? operations)\n      #f\n      (let* ([balance (car operations)]\n \
    \            [rest-operations (cdr operations)])\n        (if (or (and (negative?\
    \ balance) (< balance 0))\n                (below_zero rest-operations))\n   \
    \         #t\n            #f))))\n", "  (for/or ([(op . amount)] operations)\n\
    \    (cond\n      [(= op \"deposit\") (zero? (- amount))]\n      [(= op \"withdraw\"\
    ) (> amount 0)])))\n", "  (define (process-op op current)\n    (cond [(= 'd op)\
    \ (+ current 1000)]\n          [(= 'w op) (- current 1000)]))\n  (define (loop\
    \ ops current)\n    (cond [(null? ops) false]\n          [(< current 0) true]\n\
    \          [else (loop (cdr ops) (process-op (car ops) current))]))\n  (loop operations\
    \ 0))\n", "  (define (loop operations remaining)\n    (cond [(empty? operations)\
    \ #f]\n          [(< remaining 0) (first operations)]\n          [else (loop (rest\
    \ operations) (+ remaining (first operations)))]))\n  (loop operations 0))\n",
  "  (let loop ([balance 0] [operations operations])\n    (cond [(empty? operations)\n\
    \           #f]\n          [(< balance 0)\n           #t]\n          [else\n \
    \          (loop (+ balance (first operations)) (rest operations))])))\n", " \
    \ (let loop ([ops operations] [balance 0])\n    (if (null? ops)\n        #f\n\
    \        (let ([op (car ops)])\n          (if (< (cdr op) balance)\n         \
    \     #t\n              (loop (cdr ops) (+ balance (cdr op))))))))\n", "  (let\
    \ loop ([operations operations]\n             [balance 0])\n    (cond\n      [(empty?\
    \ operations)\n       #f]\n      [(negative? balance)\n       #t]\n      [else\n\
    \       (let ([op (first operations)])\n         (loop (rest operations)\n   \
    \            (+ balance op)))])))\n", "  (define balance 0)\n  (for ([operation\
    \ operations])\n    (match operation\n      [(list 'deposit amount)\n       (set!\
    \ balance (+ balance amount))]\n      [(list 'withdraw amount)\n       (set! balance\
    \ (- balance amount))]))\n  (< balance 0))\n", "  (cond\n    [(null? operations)\
    \ false]\n    [(< (apply + (map first operations)) 0) true]\n    [else (below_zero\
    \ (rest operations))]))\n", "  (define (iter ops current)\n    (cond\n      [(empty?\
    \ ops) false]\n      [(< current 0) true]\n      [else (iter (rest ops) (op (first\
    \ ops) current))]))\n  (iter operations 0))\n```\n\n``` #lang racket", "  (define\
    \ (sub-check ops)\n    (cond [(empty? ops) 0]\n          [(not(or (eq? (first\
    \ ops) '+)(eq? (first ops) '-)))\n          (error \"invalid operation\")]\n \
    \         [(eq? (first ops) '+) (sub-check (rest ops)) + (second ops)]\n     \
    \     [(eq? (first ops) '-) (sub-check (rest ops)) - (second ops)]))\n  (if(>\
    \ (sub-check operations) 0)\n    False\n    True))", "  (for/or ([op operations])\n\
    \    (if (or (equal? (first op) \"withdraw\")\n            (equal? (first op)\
    \ \"open\")\n            (equal? (first op) \"close\"))\n        (negative? (apply\
    \ - (cdr op)))\n        (positive? (apply + (cdr op)))\n        )\n    )\n  )\n\
    </code>\n", "  (let loop ([operations operations]\n             [balance 0])\n\
    \    (cond [(null? operations) #f]\n          [(< balance 0) #t]\n          [else\
    \ (loop (cdr operations)\n                      (+ balance (car operations)))])))\n",
  "  (define (below_zero? balance operation)\n    (cond\n      [(eq? (car operation)\
    \ 'deposit)\n       (if (&gt; balance (- (cadr operation)))\n           True\n\
    \           False)]\n      [(eq? (car operation) 'withdraw)\n       (if (&lt;\
    \ balance (cadr operation))\n           True\n           False)]))\n  (foldl below_zero?\
    \ False operations))\n", "  (define (check ops bal)\n    (match ops\n      [(list)\
    \ bal]\n      [(cons op ops)\n       (if (zero? bal)\n           (match op\n \
    \            [(cons (+ _ _) _)\n              (check ops bal)])\n           (match\
    \ op\n             [(cons (+ _ _) _)\n              (check ops (+ bal (cadr op)))])\n\
    \           (match op\n             [(cons (- _ _) _)\n              (check ops\
    \ (- bal (cadr op)))])\n           (match op\n             [(cons (* _ _) _)\n\
    \              (check ops (* bal (cadr op)))]))]))\n  (match operations\n    [(list)\
    \ #f]\n    [(cons operation operations)\n     (let ([balance (check operations\
    \ 0)])\n       (if (positive? balance)\n           #f\n           #t))]))\n",
  "  (cond [(null? operations) false]\n        [(or (< (sum operations) 0) (below_zero\
    \ (cdr operations))) true]\n        [else false]))\n", "  (let loop ([operations\
    \ operations]\n             [balance 0])\n    (cond [(null? operations)\n    \
    \       #f]\n          [(< balance 0)\n           #t]\n          [else\n     \
    \      (loop (cdr operations)\n                 (+ balance (car operations)))])))\n",
  "  (if (null? operations)\n      #f\n      (local ((define (fold-operations operations\
    \ balance)\n                (if (null? operations)\n                    balance\n\
    \                    (fold-operations (cdr operations)\n                     \
    \                (+ balance (car operations))))))\n        (if (negative? (fold-operations\
    \ operations 0))\n            #t\n            #f))))\n", "  (define balance 0)\n\
    \  (for ([op operations])\n    (set! balance (+ balance op))\n    (when (< balance\
    \ 0)\n      (return #t)))\n  #f)\n", "  (let loop ([oplist operations] [bal 0])\n\
    \    (cond [(empty? oplist) #f]\n          [(< bal 0) (first oplist)]\n      \
    \    [else (loop (rest oplist) (+ bal (first oplist)))])))\n", "  (cond\n    [(empty?\
    \ operations) #f]\n    [(<= (cadr operations) 0) #t]\n    [else (below_zero (cddr\
    \ operations))]))\n", "  (define (iter operations acc)\n    (cond\n      [(null?\
    \ operations) (if (&lt; acc 0) #t #f)]\n      [(negative? (car operations)) (iter\
    \ (cdr operations) (+ acc (car operations)))]\n      [else (iter (cdr operations)\
    \ (- acc (car operations)))]))\n  (iter operations 0))\n", "  (let loop ([ops\
    \ operations] [balance 0])\n    (cond [(null? ops)\n           #f]\n         \
    \ [(< (cadr ops) balance)\n           #t]\n          [else\n           (loop (cddr\
    \ ops) (+ balance (cadr ops)))])))\n", "  (let loop ([ops operations] [balance\
    \ 0])\n    (if (null? ops)\n        (< balance 0)\n        (loop (cdr ops) (+\
    \ balance (car ops))))))\n", "  (let loop ([balance 0] [ops operations])\n   \
    \ (cond\n      [(empty? ops) False]\n      [(< balance 0) True]\n      [else (loop\
    \ (+ balance (first ops)) (rest ops))])))\n", "  (let loop ([balance 0] [operations\
    \ operations])\n    (cond [(empty? operations)\n           #f]\n          [(>\
    \ (first operations) balance)\n           (loop (+ balance (first operations))\
    \ (rest operations))]\n          [else\n           #t])))\n", "  (define (below_zero_iter\
    \ operations balance)\n    (cond\n      [(empty? operations)\n       false]\n\
    \      [(>= balance 0)\n       (below_zero_iter (rest operations)\n          \
    \              (+ balance (first operations)))]\n      [else\n       true]))\n\
    \  (below_zero_iter operations 0))\n", "  (let loop ([op operations] [balance\
    \ 0])\n    (cond [(empty? op) #f]\n          [(negative? (apply + balance (car\
    \ op))) #t]\n          [else (loop (cdr op) (apply + balance (car op)))])))\n",
  "  (foldl (lambda (op acc)\n           (cond ((string=? op \"deposit\") (+ acc 100))\n\
    \                 ((string=? op \"withdraw\") (- acc 100))\n                 (else\
    \ acc)))\n         0\n         operations))\n", "  (let loop ([ops operations]\
    \ [balance 0])\n    (if (empty? ops)\n        false\n        (define transaction\
    \ (first ops))\n        (define new-balance (+ balance (first transaction)))\n\
    \        (if (&lt; new-balance 0)\n            true\n            (loop (rest ops)\
    \ new-balance)))))\n", "  (define (below-help operations current)\n    (if (null?\
    \ operations)\n        current\n        (if (and (list? (car operations)) (= (length\
    \ (car operations)) 2))\n            (if (and (= (cadr (car operations)) 'withdraw)\
    \ (> (car (car operations)) current))\n                #t\n                (below-help\
    \ (cdr operations) (- current (car (car operations)))))\n            (below-help\
    \ (cdr operations) current))))\n  (below-help operations 0))\n", "  (define (below-zero-helper\
    \ operations balance)\n    (if (and (null? operations) (= balance 0))\n      \
    \  #f\n        (if (and (null? operations) (&lt; balance 0))\n            #t\n\
    \            (if (and (not (null? operations)) (= balance 0))\n              \
    \  (below-zero-helper (cdr operations) (car operations))\n                (if\
    \ (and (not (null? operations)) (&lt; balance 0))\n                    #t\n  \
    \                  (below-zero-helper (cdr operations) (+ balance (car operations))))))))\n\
    \  (below-zero-helper operations 0))\n", "  (define (below_zero-help ops bal)\n\
    \    (if (null? ops)\n        (if (&lt; bal 0)\n            #t\n            #f)\n\
    \        (below_zero-help (cdr ops) (+ bal (car ops)))))\n  (below_zero-help operations\
    \ 0))\n</code>\n", "  (define (check-balance balance op)\n    (cond\n      [(or\
    \ (= balance 0) (= op '+)) (+ balance op)]\n      [(< (- balance op) 0) 'True]\n\
    \      [else (- balance op)]))\n  (define (iter balance operations)\n    (cond\n\
    \      [(null? operations) 'False]\n      [else (iter (check-balance balance (car\
    \ operations)) (cdr operations))]))\n  (iter 0 operations))\n", "  (define (below-zero?\
    \ lst balance)\n    (match lst\n      [(list) false]\n      [(list (list '+ amount)\
    \ rest)\n       (below-zero? rest (+ balance amount))]\n      [(list (list '-\
    \ amount) rest)\n       (if (&lt; balance amount)\n           true\n         \
    \  (below-zero? rest (- balance amount)))]))\n  (below-zero? operations 0))\n\
    </code>\n", "  (let loop ([operations operations]\n             [balance 0])\n\
    \    (cond\n      [(empty? operations)\n       false]\n      [(negative? (+ balance\
    \ (car operations)))\n       true]\n      [else\n       (loop (cdr operations)\
    \ (+ balance (car operations)))])))\n", "  (foldl (lambda (op balance)\n     \
    \      (match op [(cons 'deposit amount) (+ balance amount)]\n               \
    \      [(cons 'withdraw amount) (- balance amount)]))\n         0\n         operations))\n",
  "  (define balance 0)\n  (cond [(null? operations) #f]\n        [(< balance 0) #t]\n\
    \        [else (begin\n                (set! balance (+ balance (car operations)))\n\
    \                (below_zero (cdr operations)))]))", "  (if (empty? operations)\n\
    \      'False\n      (let ([curr-op (first operations)])\n        (cond ((equal?\
    \ (first curr-op) 'withdraw)\n               (if (< (- (second curr-op) (sum operations))\
    \ 0)\n                   'True\n                   (below_zero (rest operations))))\n\
    \              (else (below_zero (rest operations)))))))\n", "  (let loop ([balance\
    \ 0] [operations operations])\n    (cond\n      [(empty? operations) #f]\n   \
    \   [(and (< (car operations) 0)\n            (< balance (abs (car operations))))\n\
    \       #t]\n      [else\n       (loop (+ balance (car operations)) (cdr operations))])))\n",
  "  (let loop ([operations operations]\n             [balance 0])\n    (if (null?\
    \ operations)\n        (= balance 0)\n        (let ([op (car operations)])\n \
    \         (loop (cdr operations)\n                (+ balance (if (symbol=? 'deposit\
    \ (car op))\n                               (cadr op)\n                      \
    \         (* -1 (cadr op)))))))))\n", "  (local ((define (balance ops acc)\n \
    \           (cond\n              [(empty? ops)\n               acc]\n        \
    \      [(negative? acc)\n               #t]\n              [else\n           \
    \    (balance (rest ops) (+ acc (first ops)))])))\n    (balance operations 0)))\n",
  "  (define (below-zero-aux operations so-far)\n    (cond\n      [(empty? operations)\
    \ #f]\n      [(or (< so-far 0) (below-zero-aux (rest operations) (+ so-far (first\
    \ operations)))) #t]\n      [else #f]))\n  (below-zero-aux operations 0))\n",
  "  (define (helper operations balance)\n    (if (and (not (null? operations)) (=\
    \ balance 0))\n        (helper (cdr operations) (- (car operations)))\n      \
    \  (if (and (not (null? operations)) (< balance 0))\n            #t\n        \
    \    (if (null? operations)\n                #f\n                (helper (cdr\
    \ operations) (+ balance (car operations)))))))\n  (helper operations 0))\n",
  "  (let loop ([ops operations] [balance 0])\n    (cond [(empty? ops) (and (&lt;\
    \ balance 0) #t)]\n          [(negative? (first ops)) (loop (rest ops) (- balance\
    \ (first ops)))]\n          [else (loop (rest ops) (+ balance (first ops)))])))\n",
  "  (define total_amount 0)\n  (define (iter operations)\n    (cond\n      [(empty?\
    \ operations) #f]\n      [(negative? (add1 total_amount (first operations))) #t]\n\
    \      [else (begin\n              (set! total_amount (add1 total_amount (first\
    \ operations)))\n              (iter (rest operations)))]))\n  (iter operations))\n",
  "  (define balance 0)\n  (for ([operation operations])\n    (set! balance (+ balance\
    \ (car operation)))\n    (when (< balance 0) (return #t)))\n  #f)\n", "  (define\
    \ (iter operations balance)\n    (cond\n      [(empty? operations) false]\n  \
    \    [(and (= balance 0) (list-ref operations 0) &lt; 0) true]\n      [(= balance\
    \ 0) (iter (rest operations) (list-ref operations 0))]\n      [(&lt; balance 0)\
    \ true]\n      [else (iter (rest operations) (- balance (list-ref operations 0)))]))\n\
    \  (iter operations 0))\n</code>\nI have tested it with Racket (where I've used\
    \ lang racket rather than lang racket/base to allow for the <code>list-ref</code>\
    \ function) and it works as I would expect it to, but I'm wondering if there's\
    \ anything I could have done better.\nThere's a similar question for Python here.\n\
    \n\nA:\n\nI agree with @asmcos, here's a more functional approach:\n<code>(define\
    \ (below-zero operations)\n  (let loop ([operations operations] [balance 0])\n\
    \    (cond\n      [(empty? operations) #f]\n      [(and (zero? balance) (&lt;\
    \ (car operations) 0)) #t]\n      [(zero? balance) (loop (cdr operations) (car\
    \ operations))]\n      [(&lt; balance 0) #t]\n      [else (loop (cdr operations)\
    \ (- balance (car operations)))])))\n</code>\n", "  (define (all_positive-helper\
    \ op bal)\n    (cond ((null? op) bal)\n          ((< bal 0) true)\n          ((pos?\
    \ (car op)) (all_positive-helper (cdr op) (+ bal (car op))))\n          (else\
    \ (all_positive-helper (cdr op) (- bal (car op))))))\n  (all_positive-helper operations\
    \ 0))\n", "  (let loop ([operations operations]\n             [balance 0])\n \
    \   (cond [(empty? operations)\n           #f]\n          [(< balance 0)\n   \
    \        #t]\n          [else\n           (loop (rest operations)\n          \
    \       (+ balance (car operations)))])))\n", "    (equal? (filter (lambda (balance)\
    \ (&lt; balance 0))\n                    (scanl + 0 operations))\n           \
    \ (list -1)))", "  (zero? (apply - (list->set operations))))\n", "    (let loop\
    \ ((ops operations) (balance 0))\n      (cond\n        [(empty? ops) #f]\n   \
    \     [(> balance 0) (loop (rest ops) (cons (first ops) balance))]\n        [else\
    \ #t])))\n", "  (define (iter ops bal)\n    (cond\n      [(empty? ops) #f]\n \
    \     [(positive? bal) (iter (rest ops) (+ bal (first ops)))]\n      [else #t]))\n\
    \  (iter operations 0))\n", "  (define (procedure operations temp)\n    (match\
    \ operations\n      [(list operation)\n       (if (&lt; temp 0) true\n       \
    \    (procedure (rest operations) (+ temp (first operations))))]\n      [else\
    \ false]))\n  (procedure operations 0))\n", "  (define (below_zero-iter operations\
    \ acc)\n    (cond\n      [(empty? operations)\n       (if (< acc 0)\n        \
    \   #t\n           #f)]\n      [else\n       (below-zero-iter (rest operations)\n\
    \                        (+ acc (first operations)))]))\n  (below-zero-iter operations\
    \ 0))", "  (cond [(empty? operations) #f]\n        [(positive? (account_balance\
    \ operations)) #f]\n        [else #t]))\n", "  (define (iter ops acc-balance)\n\
    \    (if (null? ops)\n        (if (&lt; acc-balance 0)\n            #t\n     \
    \       #f)\n        (iter (cdr ops)\n              (+ acc-balance (car ops)))))\n\
    \  (iter operations 0))\n</code>\nI'm using the following test cases.\n<code>(below_zero\
    \ (list 1 -1)) ;; #t", "  (local [(define balance 0)]\n    (if (empty? operations)\n\
    \        #f\n        (if (first operations)\n            (below_zero (rest operations))\n\
    \            (set! balance (- balance (second operations)))\n            (if (&lt;\
    \ balance 0)\n                #t\n                (below_zero (rest operations)))))))\n",
  "  (if (null? operations) false\n      (if (> (car operations) 0)\n          (below_zero\
    \ (cdr operations))\n          true)))\n", "  (if (null? operations)\n      #f\n\
    \      (let* ([op (car operations)]\n             [balance (if (zero? (modulo\
    \ op 2))\n                          (+ 1 balance)\n                          (-\
    \ 1 balance))])\n        (if (negative? balance)\n            #t\n           \
    \ (below_zero (cdr operations))))))\n</code>", "  (let loop ([remaining operations]\n\
    \             [balance 0])\n    (cond [(empty? remaining)\n           false]\n\
    \          [(negative? balance)\n           true]\n          [else\n         \
    \  (loop (rest remaining)\n                 (+ balance (first remaining)))])))\n",
  "  (let loop ([accum 0] [rest operations])\n    (if (null? rest)\n        (< accum\
    \ 0)\n        (loop (+ accum (car rest)) (cdr rest)))))\n\n", "  (define balance\
    \ 0)\n  (for/or ([operation operations])\n    (set! balance (+ balance operation))\n\
    \    (if (< balance 0)\n        #t\n        #f)))", "  (let loop ([ops operations]\
    \ [balance 0])\n    (cond\n      [(empty? ops) false]\n      [(>= balance 0) (loop\
    \ (rest ops) (+ balance (first ops)))]\n      [else true])))\n", "  (define (loop\
    \ balance operations)\n    (if (null? operations)\n        false\n        (let\
    \ ([op (car operations)])\n          (if (or (= balance 0)\n                 \
    \ (&lt; balance 0))\n              true\n              (loop (+ balance (car op))\
    \ (cdr operations))))))\n  (loop 0 operations))\n", "  (let loop ([ops operations]\
    \ [total 0])\n    (cond\n      [(empty? ops) #f]\n      [(< total 0) #t]\n   \
    \   [else (loop (rest ops) (+ total (first ops)))])))\n", "  (let loop ([acc 0]\
    \ [ops operations])\n    (cond [(null? ops) #f]\n          [(< acc 0) #t]\n  \
    \        [else (loop (+ acc (car ops)) (cdr ops))])))\n", "  (let loop ([ops operations]\
    \ [acc 0])\n    (cond [(empty? ops) #f]\n          [(< acc 0) #t]\n          [else\
    \ (loop (rest ops) (+ acc (first ops)))])))", "  (define (below-zero-iter operations\
    \ acc)\n    (if (empty? operations)\n        (if (< acc 0)\n            #t\n \
    \           #f)\n        (let ([[operation amount] (first operations)])\n    \
    \      (if (= operation 'withdraw)\n              (below-zero-iter (rest operations)\
    \ (- acc amount))\n              (below-zero-iter (rest operations) (+ acc amount))))))\n\
    \  (below-zero-iter operations 0))\n", "  (for/or ([op (in-list operations)])\n\
    \    (= (apply add (map (cut -&gt;number &lt;&gt;) op)) &lt; 0)))\n", "  (for/or\
    \ ([(operation amount) operations]\n           #:when (< operation 0))\n    (cond\n\
    \      [(< (- operation) amount) #t]\n      [else #f])))\n```\n### 2.\n```#lang\
    \ racket\n", "    (accumulate (make_combiner_below_zero zero_balance) operations))\n",
  "  (let loop ([operations operations]\n             [balance 0])\n    (cond\n  \
    \    [(empty? operations) #f]\n      [(< balance 0)      #t]\n      [else\n  \
    \     (let ([operation (first operations)])\n         (loop (rest operations)\n\
    \               (+ balance (if (negative? operation)\n                       \
    \      operation\n                             (- operation)))))])))\n", "  (define\
    \ (below-zero-iter ops balance)\n    (if (null? ops)\n        (equal? balance\
    \ 0)\n        (let ([new-balance (+ balance (car ops))])\n          (if (&lt;\
    \ new-balance 0)\n              #t\n              (below-zero-iter (cdr ops) new-balance)))))\n\
    \  (below-zero-iter operations 0))\n", "  (cond\n    [(empty? operations) false]\n\
    \    [(or (&lt; (first operations) 0)\n         (cons (first operations) (below_zero\
    \ (rest operations))))]\n    [else false]))\n</code>\n", "  (cond [(empty? operations)\
    \ false]\n        [(< (sum (car operations)) 0) true]\n        [else (below_zero\
    \ (cdr operations))]))\n", "  (let\n    ([running-total 0])\n    (for\n      ([op\
    \ (in-list operations)])\n      (set! running-total (+ running-total op))\n  \
    \    (when (< running-total 0)\n        (return #t)))\n    #f))\n", "  (if (null?\
    \ operations)\n      #f\n      (let* ([op (car operations)]\n             [amount\
    \ (cdr op)]\n             [type (car op)])\n        (cond\n          [(and (=\
    \ type '+deposit) (< amount 0)) #t]\n          [(and (= type '-withdrawal) (>\
    \ amount 0)) #t]\n          [else (below_zero (cdr operations))]))))\n", "  (define\
    \ (iter operations sum)\n    (cond ((empty? operations) false)\n          ((<\
    \ (car operations) 0) true)\n          (else (iter (cdr operations) (+ (car operations)\
    \ sum)))))\n  (iter operations 0))\n", "  (cond\n    [(empty? operations) false]\n\
    \    [(< (accumulate operations 0) 0) true]\n    [else (below_zero (rest operations))]))\n",
  "  (define operation_list (map string->number operations))\n  (define (iter-below-zero\
    \ op_lst acc)\n    (if (null? op_lst)\n        (= acc 0)\n        (cond\n    \
    \      [(< (- acc (car op_lst)) 0) #t]\n          [else (iter-below-zero (cdr\
    \ op_lst) (- acc (car op_lst)))])))\n  (iter-below-zero operation_list 0))\n```\n\
    \n## Day 6\n### Make a Hash\n\n```#lang racket\n", "  (let loop ([ops operations]\
    \ [balance 0])\n    (cond\n      [(empty? ops) #f]\n      [(< balance 0) #t]\n\
    \      [else (loop (rest ops) (+ balance (first ops)))])))\n", "  (let loop ([ops\
    \ operations] [acc 0])\n    (cond\n      [(empty? ops) #f]\n      [(< acc 0) #t]\n\
    \      [else (loop (rest ops) (+ acc (first ops)))])))", "  (let ([balance 0])\n\
    \    (for ([op operations])\n      (match op\n        [(list 'd amount) (set!\
    \ balance (+ balance amount))]\n        [(list 'w amount) (set! balance (- balance\
    \ amount))]))\n    (< balance 0)))\n", "  (let loop ([operations operations]\n\
    \             [balance 0])\n    (cond [(empty? operations)\n           #f]\n \
    \         [(or (equal? balance 0)\n               (&lt; balance 0))\n        \
    \   #t]\n          [else\n           (loop (rest operations)\n               \
    \  (+ balance (if (equal? (first operations) 'd)\n                           \
    \    -1\n                               1)))])))\n</code>\n", "  (let loop ([balance\
    \ 0] [operations operations])\n    (cond\n      [(null? operations) #f]\n    \
    \  [(>= balance 0) (loop (- balance (car operations)) (cdr operations))]\n   \
    \   [else #t])))\n", "  (for/or ([op operations])\n    (and\n      (negative?\
    \ (account-op op))\n      (or (below-zero (rest operations))\n          (equal?\
    \ 1 (length operations))))))\n", "  (for/or ([operation operations])\n    (let\
    \ (([operation-type amount] operation))\n      (and (equal? operation-type 'withdraw)\n\
    \           (&lt; amount 0)))))\n", "  (if (empty? operations)\n      false\n\
    \      (if (&lt; (list-ref operations 0) 0)\n          true\n          (below_zero\
    \ (cdr operations)))))\n</code>\n\u0422\u0435\u0441\u0442\u044B\n<code>#lang racket\n",
  "  (letrec ([balance 0]\n           [acc ([x])\n                (cond\n        \
    \          [(< balance 0) #t]\n                  [(= x 'deposit) (set! balance\
    \ (+ balance 1)) acc])]\n           [f ([y])\n              (cond\n          \
    \      [(< balance 0) #t]\n                [(null? y) #f]\n                [(=\
    \ (car y) 'withdraw) (set! balance (- balance 1)) (f (cdr y))]\n             \
    \   [(= (car y) 'deposit) (set! balance (+ balance 1)) (f (cdr y))])])\n    (f\
    \ operations)))\n", "  (if (or (empty? operations) (= (length operations) 1))\n\
    \      false\n      (let loop ([ops operations] [current-balance 0])\n       \
    \ (if (and (< current-balance 0)\n                 (empty? ops))\n           \
    \ true\n            (let ([current-op (car ops)])\n              (loop (cdr ops)\n\
    \                    (+ current-balance\n                       (if (eq? (car\
    \ current-op) 'deposit)\n                           (cadr current-op)\n      \
    \                     (- (cadr current-op)))))))))\n", "  (if (empty? operations)\n\
    \      false\n      (let ((item (first operations))\n            (balance (second\
    \ operations)))\n        (cond\n          ((< balance 0)\n           true)\n \
    \         (else\n           (below_zero (rest operations)))))))\n", "  (define\
    \ (below_zero-iter ops balance)\n    (if (null? ops)\n        False\n        (let\
    \ ([op (car ops)])\n          (cond\n            [(< balance 0) True]\n      \
    \      [else (below_zero-iter (cdr ops) (+ balance op))]))))\n  (below_zero-iter\
    \ operations 0))", "  (accumulate (lambda (acc val)\n                (cond\n \
    \                 ((< acc val) #t)\n                  (else #f)))\n          \
    \    0\n              operations))\n", "  (foldl (lambda (op acc)\n          \
    \ (match op\n             [(list 'd amount) (+ acc amount)]\n             [(list\
    \ 'w amount) (- acc amount)]))\n         0\n         operations))\n", "  (local\
    \ ((define (do-loop ops current-balance)\n            (cond\n              [(null?\
    \ ops) current-balance]\n              [(negative? current-balance) true]\n  \
    \            [else (do-loop (cdr ops) (+ current-balance (car ops)))])))\n   \
    \ (do-loop operations 0)))\n", "  (for/or ([operation operations])\n         \
    \ (not (positive? operation))))\n", "  (let loop ([ops operations] [b 0])\n  \
    \  (cond [(null? ops) (if (< b 0) #t #f)]\n          [(> (car ops) 0) (loop (cdr\
    \ ops) (+ b (car ops)))]\n          [else (loop (cdr ops) (- b (car ops)))])))\n",
  "    (foldl\n        (lambda (x y) (if (and (< y 0) (number? y)) #t #f))\n     \
    \   #f\n        (map\n            (lambda (x) (cond\n                [(not (number?\
    \ x)) 0]\n                [(< x 0) x]\n                [else (+ x (foldl + 0 (map\
    \ (lambda (a) (cond\n                                                [(not (number?\
    \ a)) 0]\n                                                [(< a 0) a]\n      \
    \                                          [else (+ a 0)]))\n                \
    \                            (cdr operations))))]))\n            operations)))\n",
  "  (define (fold-fn accum op)\n    (cond\n      [(eq? op -1)\n       (if (negative?\
    \ accum)\n           #t\n           accum)]\n      [else (+ accum op)]))\n  (foldl\
    \ fold-fn 0 operations))\n", "  (define running-total 0)\n  (for ([operation operations])\n\
    \    (set! running-total (+ running-total operation))\n    (if (< running-total\
    \ 0)\n        (return #t)))\n  #f)\n", "  (let loop ([operations operations]\n\
    \             [balance 0])\n    (if (null? operations)\n        #f\n        (let\
    \ ([oper (car operations)])\n          (cond\n            [(< (car oper) 0) (if\
    \ (< balance (abs (car oper))) #t #f)]\n            [else (loop (cdr operations)\
    \ (+ balance (car oper)))])))))\n", "  (let ((balance 0))\n    (for/or ([op operations])\n\
    \      (set! balance (+ balance op))\n      (&lt; balance 0))))\n", "  (foldl\
    \ (lambda (op acc)\n           (match op\n             [('D amount) (+ acc amount)]\n\
    \             [('W amount) (- acc amount)]))\n         0\n         operations\n\
    \         #:result-type 'boolean))\n", "    (cond\n        [(and (pair? operations)\
    \ (= 0 (car operations)))\n            (below_zero (cdr operations))]\n      \
    \  [(and (pair? operations) (&lt; 0 (car operations)))\n            (below_zero\
    \ (cdr operations))]\n        [(and (pair? operations) (&gt; 0 (car operations)))\n\
    \            (below_zero (cons (- (car operations) (car (cdr operations))) (cdr\
    \ (cdr operations))))]\n        [else true]))\n", "  (let loop ([ops operations]\
    \ [current-balance 0])\n    (cond [(empty? ops) #f]\n          [(> (cadr ops)\
    \ current-balance) #t]\n          [else (loop (cddr ops) (+ current-balance (car\
    \ ops)))])))\n", "  (local ((define (go ops balance)\n            (cond [(empty?\
    \ ops) false]\n                  [(< balance 0) true]\n                  [else\
    \ (go (rest ops) (+ balance (first ops)))])))\n    (go operations 0)))\n", " \
    \ (for/or ([op operations])\n          (zero? (apply - op))))\n</code>\nThis solution\
    \ is all about the elegance of the code and it's very efficient. \nMy question\
    \ is: Is it correct? Does it follow all the conditions of the task?\n\n\nA:\n\n\
    This solution is correct. It has linear complexity and doesn't require any additional\
    \ memory.\nIt can be improved in one point: I think it's better to use <code>for/fold</code>\
    \ instead of <code>for/or</code> because it's more verbose and the use of <code>below_zero</code>\
    \ will be more clear:\n<code>(define (below_zero operations)\n  (for/fold ([<b>bal\
    \ 0</b>]) ([op operations])\n    (and (= bal <b>(apply - bal op)</b>))))</code>\n",
  "  (define balance 0)\n  (for ([operation operations])\n    (cond\n      [(negative?\
    \ operation) (set! balance (- balance operation))]\n      [else (set! balance\
    \ (+ balance operation))]))\n  (negative? balance))\n", "  (define (loop operations\
    \ balance)\n    (cond\n      [(null? operations) #f]\n      [(positive? balance)\
    \ (loop (cdr operations) (+ balance (car operations)))]\n      [else #t]))\n \
    \ (loop operations 0))\n", "  (define (acc oper op-rest)\n    (cond\n      [(null?\
    \ op-rest) #f]\n      [(zero? (apply oper (car op-rest))) (acc (operator oper)\
    \ (cdr op-rest))]\n      [else (acc oper (cdr op-rest))]))\n  (acc (operator (car\
    \ operations)) (cdr operations)))\n", "  (for/or ([op (in-list operations)])\n\
    \    (< op 0)))\n", "  (local ((define (operations->balance ops)\n           \
    \ (if (null? ops)\n                0\n                (+ (car ops) (operations->balance\
    \ (cdr ops))))))\n    (if (null? operations)\n        #f\n        (if (< (operations->balance\
    \ operations) 0)\n            #t\n            (below_zero (cdr operations))))))\n",
  "  (cond [(empty? operations) false]\n        [(< (first operations) 0) true]\n\
    \        [else (below_zero (rest operations))]))\n", "  (let loop ([balance 0]\
    \ [ops operations])\n    (cond [(null? ops) #f]\n          [(< balance 0) #t]\n\
    \          [else (loop (+ balance (car ops)) (cdr ops))])))\n", "  (define (iter\
    \ ops acc)\n    (if (null? ops)\n        #f\n        (if (&lt; acc 0)\n      \
    \      #t\n            (iter (cdr ops) (+ acc (car ops))))))\n  (iter operations\
    \ 0))\n", "  (let loop ([i 0] [ops operations])\n    (cond\n      [(empty? ops)\
    \ #f]\n      [(negative? i) #t]\n      [else (loop (+ i (first ops)) (rest ops))])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
