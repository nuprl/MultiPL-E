name: HumanEval_108_count_nums
language: rkt
prompt: "#lang racket\n\n;; Write a function count_nums which takes an array of integers\
  \ and returns\n;; the number of elements which has a sum of digits > 0.\n;; If a\
  \ number is negative, then its first signed digit will be negative:\n;; e.g. -123\
  \ has signed digits -1, 2, and 3.\n(define (count_nums arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_nums))\n\
  \    (check-equal? (candidate (list )) 0)\n    (check-equal? (candidate (list -1\
  \ -2 0)) 0)\n    (check-equal? (candidate (list 1 1 2 -2 3 4 5)) 6)\n    (check-equal?\
  \ (candidate (list 1 6 9 -6 0 1 5)) 5)\n    (check-equal? (candidate (list 1 100\
  \ 98 -7 1 -1)) 4)\n    (check-equal? (candidate (list 12 23 34 -45 -56 0)) 5)\n\
  \    (check-equal? (candidate (list 0 1)) 1)\n    (check-equal? (candidate (list\
  \ 1)) 1)\n))\n\n(test-humaneval)"
completions: ["  (length (filter (\u03BB (x) (not (zero? x)))\n                  (map\
    \ (\u03BB (x) (if (negative? x)\n                                  (let ((d (abs\
    \ x)))\n                                    (if (zero? d)\n                  \
    \                      0\n                                        (modulo (+ (modulo\
    \ d 10)\n                                                  (modulo (/ d 10) 10))\n\
    \                                               10)))\n                      \
    \            (modulo (+ (modulo x 10)\n                                      \
    \      (modulo (/ x 10) 10))\n                                       10)))\n \
    \                      arr))))\n```\n\n```racket", "  (for/fold ([acc 0]) ([x\
    \ arr])\n    (if (> (sum-digits x) 0)\n        (add1 acc)\n        acc)))\n",
  "  (define (accumulate arr sum)\n    (cond\n      [(empty? arr) sum]\n      [(zero?\
    \ (digit-sum (first arr))) (accumulate (rest arr) sum)]\n      [else (accumulate\
    \ (rest arr) (+ sum 1))]))\n  (accumulate arr 0))\n", "  (define (sign-sum n)\n\
    \    (cond\n      [(negative? n) (- n)]\n      [else (+ n)]))\n  (apply + (map\
    \ sign-sum arr)))\n", "  (cond\n    [(empty? arr) 0]\n    [(&gt; (abs (array-ref\
    \ arr 0)) 9) (count_nums (array-copy (subarray arr 1))) ]\n    [else (+ 1 (count_nums\
    \ (array-copy (subarray arr 1))))]))\n</code>\nI'm trying to write a function\
    \ that takes an array of integers and returns the number of elements which has\
    \ a sum of digits > 0.\nMy first thought was to implement it recursively.\nBut\
    \ if I run \n<code>(define x (make-array 3))", "  (define s (+ (apply + (map abs\
    \ arr))))\n  (define digits (map (\u03BB (n) (modulo n 10)) (take (add1 (ceiling\
    \ (log s 10))) (iterate (\u03BB (n) (quotient n 10)) s))))\n  (apply + digits))\n",
  "  (define (sum-digits n)\n    (define (sum-pos-digits n)\n      (cond\n       \
    \ [(zero? n) 0]\n        [else (+ (remainder n 10) (sum-pos-digits (quotient n\
    \ 10)))]))\n    (if (< n 0)\n        (- (sum-pos-digits (- n)))\n        (sum-pos-digits\
    \ n)))\n  (define (non-negative-sum? n)\n    (> (sum-digits n) 0))\n  (apply +\
    \ (map non-negative-sum? arr)))\n", "  (define (count_helper arr n)\n    (cond\
    \ ((null? arr) n)\n          ((&gt; (sum_of_digits (car arr)) 0) (count_helper\
    \ (cdr arr) (+ n 1)))\n          (else (count_helper (cdr arr) n))))\n  (count_helper\
    \ arr 0))\n", "  (accumulate + 0 (map (lambda (x) (if (> 0 (sum_of_digits x))\
    \ 0 1)) arr)))\n", "  (let loop ([arr arr] [counter 0])\n    (if (null? arr)\n\
    \        counter\n        (if (> (sum_of_digits (car arr)) 0)\n            (loop\
    \ (cdr arr) (+ counter 1))\n            (loop (cdr arr) counter)))))\n", "  (let\
    \ loop ([arr arr] [res 0])\n    (if (null? arr)\n        res\n        (let ([cur\
    \ (car arr)])\n          (if (not (zero? (sum-digits cur)))\n              (loop\
    \ (cdr arr) (+ res 1))\n              (loop (cdr arr) res))))))\n", "  (filter\
    \ (lambda (x)\n            (positive? (reduce + (map (lambda (y) (abs y)) (digits\
    \ x)))))\n          arr))\n", "  (define (sum-digits n)\n    (define (iter acc\
    \ n)\n      (if (zero? n)\n          acc\n          (iter (+ acc (remainder n\
    \ 10)) (quotient n 10))))\n    (if (negative? n)\n        (- (iter 0 (- n)))\n\
    \        (iter 0 n)))\n  (define (process x)\n    (if (> (sum-digits x) 0)\n \
    \       1\n        0))\n  (apply + (map process arr)))\n</code>\nNote, I don't\
    \ think you are allowed to use any of the built in functions that operate directly\
    \ on lists.\n", "  (define (signed-digits n)\n    (if (negative? n)\n        (cons\
    \ (- n) (digit-list (- n)))\n        (digit-list n)))\n  (define (signed-digits-sum\
    \ n)\n    (apply + (signed-digits n)))\n  (length (filter (lambda (n) (> (signed-digits-sum\
    \ n) 0)) arr)))\n", "  (cond [(empty? arr) 0]\n        [else\n         (if (not\
    \ (zero? (sum-digits (first arr))))\n             (+ 1 (count_nums (rest arr)))\n\
    \             (count_nums (rest arr)))]))\n", "  (cond ((empty? arr) 0)\n    \
    \    ((< (sum-digits (first arr)) 0)\n         (+ 1 (count_nums (rest arr))))\n\
    \        (else (count_nums (rest arr)))))\n", "  (define (sum-digits n)\n    (cond\n\
    \      [(< n 0) (+ (modulo n 10) (sum-digits (- n 10)))]\n      [(> n 0) (+ (modulo\
    \ n 10) (sum-digits (quotient n 10)))]\n      [else 0]))\n  (length (filter (lambda\
    \ (x) (> (sum-digits x) 0)) arr)))\n```\n\n```racket", "  (define (sum-digits\
    \ n)\n    (if (= n 0)\n        0\n        (+ (remainder n 10) (sum-digits (quotient\
    \ n 10)))))\n  (define (is-nonzero? arr)\n    (if (empty? arr)\n        0\n  \
    \      (if (> (sum-digits (first arr)) 0)\n            (+ 1 (is-nonzero? (rest\
    \ arr)))\n            (is-nonzero? (rest arr)))))\n  (is-nonzero? arr))\n", " \
    \ (define (signed-digits n)\n    (if (negative? n)\n        (cons (- n) (signed-digits\
    \ (remainder (+ n) 10)))\n        (cons n (signed-digits (remainder n 10)))))\n\
    \  (define (sum-digits lst)\n    (if (empty? lst)\n        0\n        (+ (first\
    \ lst) (sum-digits (rest lst)))))\n  (define (res arr)\n    (if (empty? arr)\n\
    \        0\n        (+ (if (> (sum-digits (signed-digits (first arr))) 0) 1 0)\n\
    \           (res (rest arr)))))\n  (res arr))\n", "  (for/fold ([count 0]) ([x\
    \ arr])\n    (if (not (zero? (sum-of-digits x)))\n        (add1 count)\n     \
    \   count)))\n", "  (apply + (map (lambda (n)\n                  (apply + (map\
    \ (lambda (c)\n                                  (char->integer c))\n        \
    \                        (string->list (number->string n)))))\n              \
    \  arr)))\n", '  (length (filter (lambda (x) (not (zero? (sum-digits x)))) arr)))',
  "  (cond\n    [(empty? arr) 0]\n    [else (+ (if (> (sum_signed_digits (first arr))\
    \ 0) 1 0)\n             (count_nums (rest arr)))]))\n", "  (local ((define (digit-sum\
    \ n)\n            (cond\n              [(< n 0) (- 0 (digit-sum (- n)))]\n   \
    \           [(= n 0) 0]\n              [else (+ (modulo n 10) (digit-sum (quotient\
    \ n 10)))])))\n    (define (iter idx acc)\n      (cond\n        [(>= idx (array-length\
    \ arr)) acc]\n        [(> (digit-sum (array-ref arr idx)) 0) (iter (+ idx 1) (+\
    \ acc 1))]\n        [else (iter (+ idx 1) acc)]))\n    (iter 0 0)))\n", "  (count\
    \ (lambda (x) (> (sum_digits x) 0)) arr))\n", "  (cond ((null? arr) 0)\n     \
    \   ((> (apply + (map abs (signed-digits (car arr)))) 0) (+ 1 (count_nums (cdr\
    \ arr))))\n        (else (count_nums (cdr arr)))))\n", "  (let ([retval 0])\n\
    \    (for ([x arr])\n      (if (> (abs (apply + (map (\u03BB (i) (modulo x (expt\
    \ 10 i)))\n                                (range (exact-floor (log10 (abs x)))))))\n\
    \             0)\n          (set! retval (+ retval 1))))\n    retval))\n", " \
    \ (cond\n    [(empty? arr) 0]\n    [(&gt; (sum-digits (first arr)) 0)\n     (+\
    \ 1 (count_nums (rest arr)))]\n    [else (count_nums (rest arr))]))\n", "  (define\
    \ (is_positive? n)\n    (> (+ (abs (sign_of_int (remainder n 10)))\n         \
    \ (abs (sign_of_int (remainder (/ n 10) 10)))\n          (abs (sign_of_int (remainder\
    \ (/ n 100) 10))))\n       0))\n  (define (iter a i)\n    (if (= i (length a))\n\
    \        0\n        (+ (if (is_positive? (list-ref a i)) 1 0)\n           (iter\
    \ a (+ i 1)))))\n  (iter arr 0))\n", "  (if (null? arr)\n      0\n      (if (>\
    \ (sum_digits (abs (car arr))) 0)\n          (+ 1 (count_nums (cdr arr)))\n  \
    \        (count_nums (cdr arr)))))\n", "  (let ((count 0))\n    (for ([x arr])\n\
    \      (when (positive? (count-digits x))\n        (set! count (+ count 1))))\n\
    \    count))\n", "  (define (sum_digits n)\n    (if (zero? n)\n        0\n   \
    \     (+ (remainder n 10)\n           (sum_digits (quotient n 10)))))\n  (define\
    \ (count acc lst)\n    (if (null? lst)\n        acc\n        (if (> (sum_digits\
    \ (car lst)) 0)\n            (count (+ acc 1) (cdr lst))\n            (count acc\
    \ (cdr lst)))))\n  (count 0 arr))", "  (array-length\n   (filter\n    (lambda\
    \ (x)\n      (not\n       (zero? (if (negative? x) (- x) x))))\n    arr)))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else\n     (cond\n       [(> (sum-of-digits\
    \ (first arr)) 0) (+ 1 (count_nums (rest arr)))]\n       [else (count_nums (rest\
    \ arr))])]))", "  (count-nums-helper arr 0))\n", "  (local ((define (count_nums-helper\
    \ rest)\n            (cond [(null? rest) 0]\n                  [(> (sum-digits\
    \ (car rest)) 0) (+ 1 (count_nums-helper (cdr rest)))]\n                  [else\
    \ (count_nums-helper (cdr rest))])))\n    (count_nums-helper arr)))\n", "  (length\
    \ (filter (lambda (num)\n                    (cond\n                      [(<\
    \ num 0)\n                       (< (- num) (sum_of_digits (- num)))]\n      \
    \                [else\n                       (> num (sum_of_digits num))]))\n\
    \                  arr)))\n", "  (length (filter (lambda (x)\n               \
    \     (if (< x 0)\n                        (< x (sum_digits (- x)))\n        \
    \                (> x (sum_digits x))))\n                  arr)))\n", "  (if (null?\
    \ arr)\n      0\n      (if (signed-sum-of-digits (car arr))\n          (+ 1 (count_nums\
    \ (cdr arr)))\n          (count_nums (cdr arr)))))\n", "  (local [(define (first-digit\
    \ num)\n            (cond\n              [(< num 0) (- num (quotient num 10))]\n\
    \              [else (quotient num 10)]))\n          (define (rest-digits num)\n\
    \            (cond\n              [(< num 0) (+ num (quotient num 10))]\n    \
    \          [else (remainder num 10)]))\n          (define (digit-sum num)\n  \
    \          (cond\n              [(< num 0) (+ (first-digit num) (digit-sum (rest-digits\
    \ num)))]\n              [(< num 10) num]\n              [else (+ (first-digit\
    \ num) (digit-sum (rest-digits num)))]))\n          (define (digit-sum-gt-0 arr)\n\
    \            (cond\n              [(empty? arr) empty]\n              [(> (digit-sum\
    \ (first arr)) 0) (cons (first arr) (digit-sum-gt-0 (rest arr)))]\n          \
    \    [else (digit-sum-gt-0 (rest arr))]))]\n    (length (digit-sum-gt-0 arr))))\n",
  "  (array-length\n   (array-filter\n    (lambda (x)\n      (> (foldl + 0 (map abs\
    \ (number->list x))) 0))\n    arr)))\n", "  (filter (curryr sum-of-digits> 0)\
    \ arr))\n", "  (define (sum_digits n)\n    (if (= n 0)\n        0\n        (+\
    \ (abs (remainder n 10))\n           (sum_digits (quotient n 10)))))\n  (define\
    \ (loop n i sum)\n    (if (>= i n)\n        sum\n        (loop n (+ i 1)\n   \
    \           (if (> (sum_digits (array-ref arr i)) 0)\n                  (+ sum\
    \ 1)\n                  sum))))\n  (loop (array-length arr) 0 0))\n", "  (define\
    \ (abs x)\n    (if (< x 0) (- x) x))\n  (define (sum_digits n)\n    (if (zero?\
    \ n) 0\n        (+ (modulo n 10) (sum_digits (quotient n 10)))))\n  (define (count_nums_iter\
    \ arr total)\n    (if (null? arr) total\n        (if (> (sum_digits (abs (car\
    \ arr))) 0)\n            (count_nums_iter (cdr arr) (+ total 1))\n           \
    \ (count_nums_iter (cdr arr) total))))\n  (count_nums_iter arr 0))\n", "  (cond\
    \ [(empty? arr) 0]\n        [else\n         (cond [(>= (array-sum-digits (first\
    \ arr)) 0) (+ 1 (count_nums (rest arr)))]\n               [else (count_nums (rest\
    \ arr))])]))\n", "  (foldl (lambda (e acc) (if (sum_of_digits e) (+ acc 1) acc))\
    \ 0 arr))\n", "  (local ((define (count-nums-local i count)\n            (cond\
    \ ((> i (array-length arr)) count)\n                  ((< (array-ref arr i) 0)\
    \ (count-nums-local (+ i 1) count))\n                  ((> (sum-digits (array-ref\
    \ arr i)) 0) (count-nums-local (+ i 1) (+ count 1)))\n                  (else\
    \ (count-nums-local (+ i 1) count)))))\n    (count-nums-local 0 0)))\n", "  (define\
    \ (sum-of-digits num)\n    (if (= num 0)\n        0\n        (+ (modulo num 10)\
    \ (sum-of-digits (quotient num 10)))))\n  (define (helper arr sum)\n    (if (null?\
    \ arr)\n        sum\n        (if (< (sum-of-digits (car arr)) 0)\n           \
    \ (helper (cdr arr) sum)\n            (helper (cdr arr) (+ sum 1)))))\n  (helper\
    \ arr 0))\n", "  (for/fold ([count 0]) ([i arr])\n    (if (positive? (sum-digits\
    \ i))\n        (add1 count)\n        count)))\n", "  (foldl (lambda (el acc)\n\
    \           (if (&gt; (sum-digits el) 0)\n               (+ acc 1)\n         \
    \      acc))\n         0\n         arr))\n", "  (apply + (map (lambda (x) (if\
    \ (> x 0) 1 0))\n                (map (lambda (x) (apply + (map abs (string->list\
    \ (number->string x)))))\n                     arr))))\n", "  (define (sum-digits\
    \ n)\n    (if (= n 0)\n        0\n        (+ (modulo n 10) (sum-digits (quotient\
    \ n 10)))))\n  (define (sum-signed-digits n)\n    (cond\n      ((< n 0)\n    \
    \   (+ (sum-digits n) -1))\n      ((= n 0)\n       0)\n      (else\n       (sum-digits\
    \ n))))\n  (apply + (map sum-signed-digits arr)))\n", "  (apply + (map (lambda\
    \ (n)\n                  (if (not (zero? n))\n                      (if (negative?\
    \ n) 1 0)\n                      (if (zero? (modulo n 10)) 0 1)))\n          \
    \      arr)))\n", "  (accumulate + 0 (map (compose sum-of-digits abs) arr)))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else\n     (define sum (foldl + 0 (map abs\
    \ (first arr))))\n     (if (> sum 0)\n         (+ 1 (count_nums (rest arr)))\n\
    \         (count_nums (rest arr)))]))\n", "  (let ([count 0])\n    (for ([i (in-range\
    \ (array-length arr))])\n      (define temp (abs (array-ref arr i)))\n      (define\
    \ sum 0)\n      (while (> temp 0)\n        (set! sum (+ sum (remainder temp 10)))\n\
    \        (set! temp (quotient temp 10)))\n      (if (> sum 0)\n          (set!\
    \ count (+ count 1))))\n    count))\n", "  (cond ((null? arr) 0)\n        ((>\
    \ (sum-digits (car arr)) 0)\n         (+ 1 (count_nums (cdr arr))))\n        (else\
    \ (count_nums (cdr arr)))))\n", "  (letrec ([arr->sum (lambda (arr)\n        \
    \               (cond\n                         [(empty? arr) 0]\n           \
    \              [else (+ (car arr) (arr->sum (cdr arr)))]))]\n           [abs-sum\
    \ (lambda (num)\n                      (if (< num 0)\n                       \
    \   (- (arr->sum (abs num)))\n                          (arr->sum num)))]\n  \
    \         [more-than-zero? (lambda (arr)\n                              (cond\n\
    \                                [(empty? arr) false]\n                      \
    \          [(= (abs-sum (car arr)) 0)\n                                 (more-than-zero?\
    \ (cdr arr))]\n                                [else true]))])\n    (cond\n  \
    \    [(empty? arr) 0]\n      [(more-than-zero? arr) (+ 1 (count_nums (cdr arr)))]\n\
    \      [else (count_nums (cdr arr))])))\n```\n\n```racket\n#lang racket\n", " \
    \ (let loop ([lst arr] [count 0])\n    (cond [(empty? lst) count]\n          [(>\
    \ (abs (car lst)) 0)\n           (loop (cdr lst) (+ count 1))]\n          [else\
    \ (loop (cdr lst) count)])))\n", "  (count (array-map (lambda (num)\n\t\t    \
    \  (positive? (sum-digits num)))\n\t\t    arr)))\n", "  (if (null? arr)\n    \
    \  0\n      (if (> (count-digits (car arr)) 0)\n          (+ 1 (count_nums (cdr\
    \ arr)))\n          (count_nums (cdr arr)))))\n", "  ;; helper function to return\
    \ the sum of all digits in a number.\n  ;; Return 0 if number is 0.\n  (define\
    \ (num_sum num)\n    (cond\n      [(= num 0) 0]\n      [else (+ (modulo num 10)\
    \ (num_sum (quotient num 10)))]))\n  ;; helper function for conditional boolean.\n\
    \  ;; Return #t if the number is non-zero.\n  (define (num_cond num)\n    (if\
    \ (not (= num 0)) #t #f))\n  ;; Return the number of elements which has a sum\
    \ of digits > 0.\n  (for/sum ([i arr]\n            #:when (num_cond (num_sum i)))\n\
    \    1))\n", "  (define (signed-digits n)\n    (cond\n      [(negative? n)\n \
    \      (reverse (list (- n)\n                      (quotient n 10)\n         \
    \             (quotient n 100)\n                      (quotient n 1000)\n    \
    \                  (quotient n 10000)\n                      (quotient n 100000)\n\
    \                      (quotient n 1000000)\n                      (quotient n\
    \ 10000000)\n                      (quotient n 100000000)\n                  \
    \    (quotient n 1000000000)))]\n      [else\n       (reverse (list n\n      \
    \                (quotient n 10)\n                      (quotient n 100)\n   \
    \                   (quotient n 1000)\n                      (quotient n 10000)\n\
    \                      (quotient n 100000)\n                      (quotient n\
    \ 1000000)\n                      (quotient n 10000000)\n                    \
    \  (quotient n 100000000)\n                      (quotient n 1000000000))))])\n\
    \  (define (digits n)\n    (cond\n      [(< n 0) (signed-digits (- n))]\n    \
    \  [else (signed-digits n)]))\n  (define (total n)\n    (cond\n      [(zero? n)\
    \ 0]\n      [else (+ (remainder n 10)\n               (total (quotient n 10)))]))\n\
    \  (define (count-nums arr)\n    (cond\n      [(empty? arr) 0]\n      [(> (total\
    \ (car arr)) 0) (+ 1 (count-nums (cdr arr)))]\n      [else (count-nums (cdr arr))]))\n\
    \  (count-nums arr))\n```\n\n```\n> (count_nums (list -1234 7 8 1 5 4 -29 4 7\
    \ 1 5 4 -1234567890))\n6\n```\n\n### Problem 5\n\n```racket\n#lang racket\n",
  "  (length (filter (lambda (i)\n                    (not (eq? 0 (sum_digits i))))\n\
    \                  arr)))\n", "  (let loop ([arr arr] [cnt 0])\n    (if (null?\
    \ arr)\n        cnt\n        (if (> (sum_digits (abs (car arr))) 0)\n        \
    \    (loop (cdr arr) (+ cnt 1))\n            (loop (cdr arr) cnt)))))\n", "  (count\
    \ (filter (lambda (a) (sum_digits (abs a))) arr)))\n", "  (define (signed-digit\
    \ n d)\n    (- n (* d (floor (/ n d)))))\n  (define (sum-digits n)\n    (if (&lt;\
    \ n 10)\n        n\n        (+ (signed-digit n 10) (sum-digits (/ n 10)))))\n\
    \  (length (filter (lambda (n) (&gt; (sum-digits n) 0)) arr)))\n", "  (define\
    \ (abs-sum n)\n    (if (negative? n)\n        (- 0 (sum-digits (- n)))\n     \
    \   (sum-digits n)))\n  (filter (lambda (n) (> (abs-sum n) 0)) arr))\n", "  (length\
    \ (filter (lambda (x) (&gt; (sum-digits x) 0)) arr)))\n", "  (define (iter sum_so_far\
    \ idx)\n    (if (= idx (array-length arr))\n        (if (> sum_so_far 0) 1 0)\n\
    \        (let ([d (abs (remainder (array-ref arr idx) 10))])\n          (iter\
    \ (+ sum_so_far d) (+ idx 1)))))\n  (iter 0 0))\n", "  (length (filter (lambda\
    \ (x) (< 0 (integer-sum (integer->list x)))) arr)))\n", "  (length (filter (lambda\
    \ (num) (positive? (sum-digits num))) arr)))\n", "  (define (count_nums_with_index\
    \ i sum_count)\n    (if (= i (array-length arr))\n        sum_count\n        (if\
    \ (= (array-ref arr i) 0)\n            (count_nums_with_index (+ i 1) sum_count)\n\
    \            (count_nums_with_index (+ i 1) (+ sum_count 1)))))\n  (count_nums_with_index\
    \ 0 0))\n", "  (array-length\n   (array-filter (lambda (n) (> (sum-digits n) 0))\
    \ arr)))\n", "  (cond\n    [(empty? arr) 0]\n    [else\n     (if (> (sum-digits\
    \ (first arr)) 0)\n         (+ 1 (count_nums (rest arr)))\n         (count_nums\
    \ (rest arr)))]))\n", "  (cond\n    [(= (length arr) 0) 0]\n    [(> (sum_of_digits\
    \ (car arr)) 0) (+ 1 (count_nums (cdr arr)))]\n    [else (count_nums (cdr arr))]))\n",
  "  (let loop ([arr arr] [cnt 0])\n    (if (null? arr)\n        cnt\n        (if\
    \ (not (zero? (sum_digits (abs (car arr)))))\n            (loop (cdr arr) (+ cnt\
    \ 1))\n            (loop (cdr arr) cnt)))))\n", "  (let loop ([arr arr] [count\
    \ 0])\n    (cond [(null? arr) count]\n          [(> (sum_digits (car arr)) 0)\
    \ (loop (cdr arr) (+ count 1))]\n          [else (loop (cdr arr) count)])))\n",
  "  (define (sum_digits num)\n    (define (sum_digits_helper a)\n      (if (zero?\
    \ a)\n          0\n          (+ (modulo a 10) (sum_digits_helper (quotient a 10)))))\n\
    \    (if (positive? num)\n        (sum_digits_helper num)\n        (- (sum_digits_helper\
    \ (- num)))))\n  (define (helper x l)\n    (if (empty? l)\n        x\n       \
    \ (if (&gt; (sum_digits (first l)) 0)\n            (helper (+ x 1) (rest l))\n\
    \            (helper x (rest l)))))\n  (helper 0 arr))\n</code>\nI have created\
    \ one function to calculate the sum of digits, then I've called it from another\
    \ function which is intended to count the number of elements in an array which\
    \ has a sum of digits > 0.\nI've tried a few test cases and I think it's working\
    \ for positive numbers, but it doesn't work for negative numbers. For example,\
    \ when I call <code>(count_nums '(10 -20 30))</code>, I'm expecting to get the\
    \ answer 2 because 1+0=1, 2+0=2, 3+0=3 and only 1 and 2 are > 0, but I'm getting\
    \ the answer 1. What am I doing wrong?\n\n\nA:\n\nIf you use <code>negative?</code>\
    \ instead of <code>positive?</code> and <code>quotient/remainder</code> instead\
    \ of <code>quotient</code> and <code>modulo</code>, it works better. Here is the\
    \ code:\n<code>#lang racket\n", "  (apply + (map (lambda (x)\n               \
    \   (if (> (apply + (map (lambda (y)\n                                       \
    \  (abs y))\n                                       (string->list (number->string\
    \ x))))\n                     0)\n                      1\n                  \
    \    0))\n                arr)))\n", "  (length (filter (lambda (x) (> (sum-of-digits\
    \ x) 0)) arr)))\n", "  (define (abs val)\n    (if (&lt; val 0)\n        (- val)\n\
    \        val))\n  (define (len n)\n    (if (= n 0)\n        0\n        (+ 1 (len\
    \ (/ n 10)))))\n  (define (div n d)\n    (if (= n 0)\n        0\n        (+ (*\
    \ d (/ n 10)) (% n 10))))\n  (define (sum n)\n    (if (= n 0)\n        0\n   \
    \     (+ (abs (% n 10)) (sum (div n 10)))))\n  (define (loop n total)\n    (if\
    \ (= n (len arr))\n        total\n        (if (&gt; (sum (list-ref arr n)) 0)\n\
    \            (loop (+ n 1) (+ total 1))\n            (loop (+ n 1) total))))\n\
    \  (loop 0 0))\n", "  (define (sum-digits n)\n    (define (sum-digits-helper n\
    \ acc)\n      (if (= n 0)\n          acc\n          (sum-digits-helper (quotient\
    \ n 10) (+ acc (remainder n 10)))))\n    (if (negative? n)\n        (sum-digits-helper\
    \ (- n) 0)\n        (sum-digits-helper n 0)))\n  (define (count-nums-helper arr\
    \ acc)\n    (if (null? arr)\n        acc\n        (if (< 0 (sum-digits (car arr)))\n\
    \            (count-nums-helper (cdr arr) (+ acc 1))\n            (count-nums-helper\
    \ (cdr arr) acc))))\n  (count-nums-helper arr 0))\n```\n\n```scheme\n#lang racket\n",
  "  (cond\n    ((not (array? arr)) -1)\n    ((not (array-all-integer? arr)) -1)\n\
    \    (else\n      (define (loop i cnt)\n        (cond\n          ((array-ref arr\
    \ i)\n            (if (> (sum_digits (array-ref arr i)) 0)\n              (loop\
    \ (+ i 1) (+ cnt 1))\n              (loop (+ i 1) cnt)))\n          (else cnt)))\n\
    \      (loop 0 0))))\n", "  (count (lambda (num)\n           (> (apply + (signed-digits\
    \ num)) 0))\n         arr))\n", "  (array-length (filter (\u03BB (x)\n       \
    \                  (not (zero? (apply + (map abs (number->list x)))))\n      \
    \                   )\n                       arr\n                       )\n\
    \                )\n  )\n", "  (let loop ([arr arr] [cnt 0])\n    (cond [(null?\
    \ arr) cnt]\n          [(< (sum-digits (car arr)) 0) (loop (cdr arr) cnt)]\n \
    \         [else (loop (cdr arr) (+ cnt 1))])))\n", "  (define (foldr f init lst)\n\
    \    (if (null? lst)\n        init\n        (f (car lst) (foldr f init (cdr lst)))))\n\
    \  (define (sum_nums n)\n    (define (sum_digits n)\n      (if (zero? n)\n   \
    \       0\n          (+ (modulo n 10) (sum_digits (quotient n 10)))))\n    (if\
    \ (negative? n)\n        (sum_digits (- n))\n        (sum_digits n)))\n  (define\
    \ (predicate n)\n    (if (positive? (sum_nums n))\n        1\n        0))\n  (foldr\
    \ + 0 (map predicate arr)))", "  ;; YOUR CODE HERE\n  )\n", "  (length (filter\
    \ (lambda (i)\n                    (sum-digits i))\n                  arr)))\n",
  "  (define (sum-digits n)\n    (if (positive? n)\n        (if (zero? n)\n      \
    \      0\n            (+ (remainder n 10) (sum-digits (quotient n 10))))\n   \
    \     (if (zero? n)\n            0\n            (+ (- (remainder n 10)) (sum-digits\
    \ (quotient n 10))))))\n  (define (aux arr acc)\n    (if (null? arr)\n       \
    \ acc\n        (if (&gt; (sum-digits (car arr)) 0)\n            (aux (cdr arr)\
    \ (+ acc 1))\n            (aux (cdr arr) acc))))\n  (aux arr 0))\n", "  (define\
    \ (signed-digits n)\n    (if (negative? n)\n        (cons '- (map digit->char\
    \ (rest (digits n))))\n        (map digit->char (digits n))))\n  (define (sum-digits\
    \ ds)\n    (apply + (map (\u03BB (x) (string->number (list->string x))) ds)))\n\
    \  (foldl (\u03BB (el acc) (if (> (sum-digits (signed-digits el)) 0) (+ acc 1)\
    \ acc)) 0 arr))\n", "  (cond\n    ((null? arr) 0)\n    ((positive? (sum_digits\
    \ (abs (car arr)))) (add1 (count_nums (cdr arr))))\n    (else (count_nums (cdr\
    \ arr)))))\n", "  (foldl + 0 (map (\u03BB (x) (if (eqv? (sum_digits x) 0) 0 1))\
    \ arr)))\n", "  (array-length\n   (filter (lambda (x)\n             (< 0 (apply\
    \ + (for/list ([d (in-string (number->string x))])\n                         \
    \      (string->number (string d))))))\n           arr)))\n", "  (define nums-with-sum-greater-than-zero\n\
    \    (filter (lambda (x)\n              (let ((digits (array->list (number->string\
    \ x))))\n                (> (apply + digits) 0)))\n            arr))\n  (length\
    \ nums-with-sum-greater-than-zero))\n", "  (let ([len (array-length arr)])\n \
    \   (for/fold ([count 0]) ([i (in-range len)])\n      (if (> (abs (signed-digits-sum\
    \ (array-ref arr i))) 0)\n          (add1 count)\n          count))))\n", "  (define\
    \ (add-digits num)\n    (if (negative? num)\n        (+ (modulo num 10)\n    \
    \       (if (zero? (modulo (- num) 10))\n               0\n               (add-digits\
    \ (quotient (- num) 10))))\n        (+ (modulo num 10)\n           (if (zero?\
    \ (modulo num 10))\n               0\n               (add-digits (quotient num\
    \ 10))))))\n  (for/fold ([total 0]) ([num arr])\n    (if (> (add-digits num) 0)\n\
    \        (+ total 1)\n        total)))\n", "  (define (signed_digits n)\n    (if\
    \ (= n 0)\n        (list)\n        (begin\n          (cons (abs (% n 10))\n  \
    \              (signed_digits (quotient n 10))))))\n  (define (sum_signed_digits\
    \ ns)\n    (if (null? ns)\n        0\n        (+ (car ns) (sum_signed_digits (cdr\
    \ ns)))))\n  (define (sum_of_digits? n)\n    (if (= n 0)\n        #f\n       \
    \ (if (= (sum_signed_digits (signed_digits n)) 0)\n            #f\n          \
    \  #t)))\n  (define (is_signed_digit? n)\n    (if (not (number? n))\n        #f\n\
    \        (if (< n 0)\n            #t\n            #f)))\n  (define (count_ns ns)\n\
    \    (if (null? ns)\n        0\n        (if (and (is_signed_digit? (car ns))\n\
    \                 (sum_of_digits? (car ns)))\n            (+ 1 (count_ns (cdr\
    \ ns)))\n            (count_ns (cdr ns)))))\n  (count_ns arr))\n", "  (foldl (lambda\
    \ (x s)\n           (cond ((< x 0) (add1 s))\n                 ((zero? x) s)\n\
    \                 (else (+ s (sum_digits x)))))\n         0\n         arr))\n",
  "  (define (sum_digits num)\n    (if (negative? num)\n        (add1 (sum_digits\
    \ (abs num)))\n        (let recur ((n num) (sum 0))\n          (if (zero? n)\n\
    \              sum\n              (recur (quotient n 10) (+ sum (remainder n 10)))))))\n\
    \  (define (accumulator num count)\n    (if (zero? num)\n        count\n     \
    \   (if (&gt; (sum_digits num) 0)\n            (accumulator (array-ref arr (add1\
    \ count)) (add1 count))\n            (accumulator (array-ref arr (add1 count))\
    \ count))))\n  (accumulator (array-ref arr 0) 0))\n", "  (define (abs x)\n   \
    \ (if (< x 0)\n        (- x)\n        x))\n  (define (digits_of n)\n    (if (=\
    \ n 0)\n        '()\n        (cons (remainder n 10)\n              (digits_of\
    \ (quotient n 10)))))\n  (length (filter (lambda (n)\n                    (> (apply\
    \ + (digits_of (abs n))) 0))\n                  arr)))\n", "  (for/fold ([n 0])\
    \ ([x arr])\n    (if (and (not (negative? x))\n             (> (apply + (map (compose\
    \ (\u03BB (d) (- d ?0)) symbol->string)\n                               (integer->list\
    \ x))))\n                0))\n        (add1 n)\n        n)))\n```\n\n```racket\n\
    #lang racket\n", "  (define (signed-digits n)\n    (if (negative? n) (negative\
    \ n) n))\n  (count (lambda (n) (> (sum-digits (signed-digits n)) 0)) arr))\n",
  "  (if (empty? arr)\n      0\n      (if (&gt; (count_digits (first arr)) 0)\n  \
    \        (+ 1 (count_nums (rest arr)))\n          (count_nums (rest arr)))))\n",
  "  (length (filter (lambda (x)\n                    (positive? (sum-signed-digits\
    \ x)))\n                  arr)))\n", "  (if (null? arr)\n      0\n      (if (sum-digits\
    \ (car arr))\n          (+ 1 (count_nums (cdr arr)))\n          (count_nums (cdr\
    \ arr)))))\n", "  (local ((define (sum-of-digits num)\n            (cond [(>=\
    \ num 0) num]\n                  [else (- num)])))\n    (local ((define (sum-of-signed-digits\
    \ num)\n              (if (< num 0)\n                  (sum-of-digits (- num))\n\
    \                  (sum-of-digits num))))\n      (local ((define (sum-of-digits-aux\
    \ lst accum)\n                (cond [(empty? lst) accum]\n                   \
    \   [else (sum-of-digits-aux (rest lst) (+ accum (first lst)))])))\n        (local\
    \ ((define (num-elements-with-positive-sum-of-digits lst)\n                  (local\
    \ ((define (count-aux lst accum)\n                            (cond [(empty? lst)\
    \ accum]\n                                  [else (count-aux (rest lst) (+ accum\
    \ (if (positive? (sum-of-signed-digits (first lst))) 1 0)))])))\n            \
    \        (count-aux lst 0))))\n          (num-elements-with-positive-sum-of-digits\
    \ arr))))))", "  (let f ((arr arr) (count 0))\n    (if (null? arr)\n        count\n\
    \        (if (&gt; (apply + (map abs (map (lambda (x) (modulo x 10)) (reverse\
    \ (number->string (car arr)))))) 0)\n            (f (cdr arr) (+ count 1))\n \
    \           (f (cdr arr) count)))))\n", "  (count-if (lambda (x)\n           \
    \   (not (zero? (foldr + 0 (abs-sign-digits x)))))\n            arr))\n", "  (count\
    \ (for/fold ([sum 0]) ([x arr])\n           (let ([s (abs x)])\n             (cond\
    \ [(< s 10)\n                    (+ sum 1)]\n                   [else\n      \
    \              (+ sum (+ s 1))])))))\n", "  (length (filter sum-over-zero? arr)))\n",
  "  (for/fold ([n 0]) ([e arr])\n    (if (<= (total-digits e) 0)\n        n\n   \
    \     (+ n 1))))\n", "  (length (filter (lambda (x) (< 0 (sum_digits x))) arr)))\n",
  "  (cond [(empty? arr) 0]\n        [else\n         (if (not (zero? (abs (sum-digits\
    \ (car arr)))))\n             (+ 1 (count_nums (cdr arr)))\n             (count_nums\
    \ (cdr arr)))]))\n", "  (letrec\n      ((sum (lambda (x)\n              (if (&lt;\
    \ x 0)\n                  (- x)\n                  x)))\n       (sum-digits (lambda\
    \ (x)\n                     (if (= x 0)\n                         0\n        \
    \                 (+ (sum (modulo x 10))\n                            (sum-digits\
    \ (quotient x 10)))))))\n    (length (filter (lambda (x)\n                   \
    \   (&gt; (sum-digits x) 0))\n                    arr))))\n", "  (define (sum-digits\
    \ n)\n    (cond\n      [(negative? n) (- n)]\n      [(zero? n) 0]\n      [else\
    \ (+ (remainder n 10) (sum-digits (quotient n 10)))]))\n  (let loop ([index 0]\
    \ [count 0])\n    (cond\n      [(= index (vector-length arr)) count]\n      [(zero?\
    \ (sum-digits (vector-ref arr index))) (loop (+ index 1) count)]\n      [else\
    \ (loop (+ index 1) (+ count 1))])))\n", "  (define (first-digit n)\n    (if (&lt;\
    \ n 0) (- n)\n        (quotient n (expt 10 (floor (log n 10))))))\n  (define (digit-sum\
    \ n)\n    (define (iter d total)\n      (if (= d 0) total\n          (iter (quotient\
    \ d 10) (+ total (remainder d 10)))))\n    (iter n 0))\n  (define (filter-pred\
    \ x)\n    (&gt; (digit-sum (abs x)) 0))\n  (define (sum arr)\n    (foldl + 0 arr))\n\
    \  (length (filter filter-pred arr)))\n", "  (define (loop i sum)\n    (if (=\
    \ i (length arr))\n        sum\n        (if (< (sum_digits (array-ref arr i))\
    \ 0)\n            (loop (+ i 1) sum)\n            (loop (+ i 1) (+ sum 1)))))\n\
    \  (loop 0 0))\n", "  (define (count_nums-helper arr count)\n    (cond [(empty?\
    \ arr) count]\n          [(/= (sum-of-digits (first arr)) 0)\n           (count_nums-helper\
    \ (rest arr) (+ count 1))]\n          [else (count_nums-helper (rest arr) count)]))\n\
    \  (count_nums-helper arr 0))\n", "  (cond ((null? arr) 0)\n        ((not (number?\
    \ (car arr))) (count_nums (cdr arr)))\n        ((= (sum-digits (car arr)) 0) (count_nums\
    \ (cdr arr)))\n        (else (+ 1 (count_nums (cdr arr))))))\n", "  (length (filter\
    \ (lambda (x) (cond ((< x 0) (apply + (map abs (digits x))))\n               \
    \                     ((> x 0) (apply + (digits x)))))\n                  arr)))",
  "  (foldl (lambda (x y)\n           (if (<= 0 (abs x))\n               (+ y 1)\n\
    \               y))\n         0\n         arr))\n", "  (cond\n    ((null? arr)\
    \ 0)\n    ((sum-of-digits (car arr)) (add1 (count_nums (cdr arr))))\n    (else\
    \ (count_nums (cdr arr)))))\n", "  (foldl (lambda (x acc) (if (positive? (sum-digits\
    \ x)) (+ acc 1) acc)) 0 arr))\n", "  (letrec ((count-zeros (lambda (n)\n     \
    \                    (if (= n 0)\n                             0\n           \
    \                  (+ (remainder n 10)\n                                (count-zeros\
    \ (quotient n 10)))))))\n    (if (null? arr)\n        0\n        (+ (if (not (=\
    \ (count-zeros (car arr)) 0))\n                1\n                0)\n       \
    \    (count-nums (cdr arr))))))\n", "  (count_nums-helper arr 0))\n", "  (define\
    \ (positive_sum_digits? num)\n    (if (&lt; num 0)\n        (positive_sum_digits?\
    \ (- num))\n        (positive_sum_digits? (- num 1) (+ (remainder num 10) 1))\n\
    \        false))\n  (define (positive_sum_digits? n sum)\n    (if (= n 0)\n  \
    \      (if (= sum 0)\n            false\n            true)\n        (positive_sum_digits?\
    \ (quotient n 10) (+ (remainder n 10) sum))))\n  (for/fold ([count 0]) ([num arr])\n\
    \    (if (positive_sum_digits? num)\n        (add1 count)\n        count)))\n\
    </code>\nIf I run it in DrRacket, I get this error:\n<code>&gt; (count_nums (list\
    \ -1234 123456789))\n#&lt;syntax:10:2&gt;: bad syntax (multiple expressions after\
    \ identifier) in: (add1 count)\n</code>\nWhy is this? I'm not sure what it means.\n\
    \n\nA:\n\nWith the help of @Jens Axel S\xF8gaard, I was able to solve this. Here\
    \ is the working code:\n<code>#lang racket\n", "  (for/fold ([count 0]) ([n arr])\n\
    \    (if (apply + (map (compose abs number->string) (list->vector (string->list\
    \ (number->string n)))))\n        (add1 count)\n        count)))\n```\n\n10.\n\
    ```racket\n#lang racket\n", "  (cond\n    [(zero? (array-length arr)) 0]\n   \
    \ [else\n     (if (positive? (array-ref arr 0))\n         (+ 1 (count_nums (array-copy\
    \ (array-slice arr 1) (array-length arr))))\n         (count_nums (array-copy\
    \ (array-slice arr 1) (array-length arr))))]))\n", "  (define (count_digits n)\n\
    \    (cond ((not (positive? n)) 0)\n          ((not (zero? (modulo n 10))) (count_digits\
    \ (quotient n 10)))\n          (else (+ 1 (count_digits (quotient n 10))))))\n\
    \  (cond ((null? arr) 0)\n        ((= 0 (count_digits (car arr))) (count_nums\
    \ (cdr arr)))\n        (else (+ 1 (count_nums (cdr arr))))))\n</code>\n", "  (define\
    \ (iter i count)\n    (if (= i (array-length arr))\n        count\n        (if\
    \ (< (sum-of-digits (abs (array-ref arr i))) 0)\n            (iter (+ i 1) count)\n\
    \            (iter (+ i 1) (+ count 1)))))\n  (iter 0 0))\n", "  (array-fold +\
    \ 0\n              (map (lambda (x) (if (positive? x) 1 0))\n                \
    \   (map (lambda (x) (abs x))\n                        (map (lambda (x) (array-sum\
    \ (map (lambda (x) (abs x)) (integer->list x))))\n                           \
    \  arr)))))\n", "  (accumulate + 0 (map sum-of-digits arr)))\n", "  (let loop\
    \ ([accumulator 0]\n             [items (in-naturals)])\n    (if (empty? items)\n\
    \        accumulator\n        (let ([item (first items)])\n          (if (array-ref\
    \ arr item)\n              (loop (+ accumulator (signum-magnitude (abs (array-ref\
    \ arr item))))\n                   (rest items))\n              (loop accumulator\
    \ (rest items)))))))\n", "  (define (helper lst)\n    (cond [(null? lst) 0]\n\
    \          [(number? (car lst))\n           (if (> (sum_of_digits (car lst)) 0)\n\
    \               (+ 1 (helper (cdr lst)))\n               (helper (cdr lst)))]\n\
    \          [else (helper (cdr lst))]))\n  (helper arr))\n", "  (length (filter\n\
    \    (lambda (x)\n      (define (sd num)\n        (cond\n          [(= num 0)\
    \ 0]\n          [(and (> num 0) (not (zero? (modulo num 10))))\n           (+\
    \ (abs (modulo num 10)) (sd (quotient num 10)))]\n          [(and (< num 0) (not\
    \ (zero? (modulo num 10))))\n           (+ (abs (modulo num 10)) (sd (quotient\
    \ num 10)))]\n          [else (sd (quotient num 10))]))\n      (> (sd x) 0))\n\
    \    arr)))\n", "  (let loop ([i 0] [cnt 0])\n    (if (= i (array-length arr))\n\
    \        cnt\n        (if (positive? (sum-digits (array-ref arr i)))\n       \
    \     (loop (+ i 1) (+ cnt 1))\n            (loop (+ i 1) cnt)))))\n", "  (let\
    \ loop ([i 0] [n 0])\n    (if (= i (array-length arr))\n        n\n        (let\
    \ ([sum (apply + (map abs (integer->list (array-ref arr i))))])\n          (loop\
    \ (+ i 1) (if (> sum 0) (+ n 1) n))))))\n", "  (local [;; recursively sum up the\
    \ digits of a number\n          (define (rdig num)\n            (cond [(< num\
    \ 10) num]\n                  [else (+ (remainder num 10) (rdig (quotient num\
    \ 10)))]))\n          ;; sum up the digits of the first n elements of an array\n\
    \          (define (digarr n)\n            (if (> n (array-length arr)) 0\n  \
    \              (+ (rdig (array-ref arr (- n 1))) (digarr (+ n 1)))))\n       \
    \   ;; is the sum of digits of a number positive?\n          (define (posq num)\n\
    \            (not (zero? (rdig num))))]\n    (array-filter posq arr)))\n", " \
    \ (if (null? arr)\n      0\n      (if (&gt; (apply + (map abs (flatten-signed-digits\
    \ (map char-&gt;integer (string-&gt;list (number-&gt;string (car arr))))))) 0)\n\
    \          (+ 1 (count_nums (cdr arr)))\n          (count_nums (cdr arr)))))\n",
  "  (array-count (lambda (n) (> (sum-digits (abs n)) 0)) arr))\n", "  (count arr))\n",
  "  (define (sum-digits num)\n    (if (&lt; num 0)\n        (- (* -1 (sum-digits\
    \ (* -1 num))))\n        (if (= num 0)\n            0\n            (+ (modulo\
    \ num 10) (sum-digits (quotient num 10))))))\n  (length (filter (lambda (x) (&gt;\
    \ (sum-digits x) 0)) arr)))\n", "  (cond\n    [(empty? arr) 0]\n    [else\n  \
    \   (if (<= (apply + (map (lambda (x) (if (< x 0) (- x) x))\n                \
    \           (signed-digits (first arr))))\n             0)\n         (count_nums\
    \ (rest arr))\n         (+ 1 (count_nums (rest arr))))]))\n", "  (cond\n    [(empty?\
    \ arr) 0]\n    [else\n     (if (> (sum-digits (car arr)) 0)\n         (+ 1 (count_nums\
    \ (cdr arr)))\n         (count_nums (cdr arr)))]))\n", "  (let loop ([arr arr]\
    \ [count 0])\n    (cond [(empty? arr) count]\n          [(> (sum-digits (first\
    \ arr)) 0) (loop (rest arr) (+ count 1))]\n          [else (loop (rest arr) count)])))\n",
  "  (define digits (make-vector 10 0))\n  (let loop ([xs arr])\n    (cond\n     \
    \ [(null? xs) (let ([total 0])\n                   (for ([i (in-range 10)])\n\
    \                     (set! total (+ total (vector-ref digits i))))\n        \
    \           total)]\n      [else\n       (define abs-num (if (negative? (car xs))\n\
    \                           (- (car xs))\n                           (car xs)))\n\
    \       (define digit-sum 0)\n       (define (add_num_to_sum)\n         (let loop\
    \ ([x abs-num])\n           (if (positive? x)\n               (begin\n       \
    \          (set! digit-sum (+ digit-sum (remainder x 10)))\n                 (loop\
    \ (quotient x 10)))\n               (vector-set! digits digit-sum (add1 (vector-ref\
    \ digits digit-sum))))))\n       (add_num_to_sum)\n       (loop (cdr xs))])))\n",
  "  (let ([len (array-length arr)])\n    (for/fold ([acc 0]) ([i (in-range len)])\n\
    \      (if (sum-digits (array-ref arr i))\n          (add1 acc)\n          acc))))\n",
  "  (let ([len (array-length arr)])\n    (cond\n      [(zero? len) 0]\n      [else\n\
    \       (let ([first (array-ref arr 0)])\n         (cond\n           [(not (positive?\
    \ first))\n            (add1 (count_nums (subarray arr 1 (sub1 len))))]\n    \
    \       [(> (array-sum-digits first) 0)\n            (add1 (count_nums (subarray\
    \ arr 1 (sub1 len))))]\n           [else\n            (count_nums (subarray arr\
    \ 1 (sub1 len)))])))]))\n", "  (define (count_nums-helper arr acc)\n    (if (empty?\
    \ arr)\n        acc\n        (if (< 0 (sum-of-digits (first arr)))\n         \
    \   (count_nums-helper (rest arr) (+ acc 1))\n            (count_nums-helper (rest\
    \ arr) acc))))\n  (count_nums-helper arr 0))\n", "  (cond [(empty? arr) 0]\n \
    \       [else\n         (cond [(> (sum-digits (first arr)) 0)\n              \
    \  (+ 1 (count_nums (rest arr)))]\n               [else (count_nums (rest arr))])]))\n",
  "  (define (digit-sum num)\n    (if (and (zero? num)\n             (&lt; num 0))\n\
    \        0\n        (+ (modulo num 10)\n           (digit-sum (quotient num 10)))))\n\
    \  (define (digit-sum-greater-than-zero? num)\n    (&gt; (digit-sum num) 0))\n\
    \  (length (filter digit-sum-greater-than-zero? arr)))\n", "  (if (null? arr)\n\
    \      0\n      (if (sum-gt-0? (abs (car arr)))\n          (+ 1 (count_nums (cdr\
    \ arr)))\n          (count_nums (cdr arr)))))\n", "  (define (sum_digits n)\n\
    \    (if (zero? n)\n        0\n        (+ (sum_digits (quotient n 10)) (remainder\
    \ n 10))))\n  (define (do_count nums)\n    (cond\n      [(null? nums) 0]\n   \
    \   [(> (sum_digits (abs (car nums))) 0) (+ 1 (do_count (cdr nums)))]\n      [else\
    \ (do_count (cdr nums))]))\n  (do_count arr))\n", "  (define (sum_digits n)\n\
    \    (define (abs n)\n      (if (< n 0) (- n) n))\n    (if (< n 10)\n        n\n\
    \        (+ (abs (remainder n 10))\n           (sum_digits (quotient n 10)))))\n\
    \  (define (count n)\n    (if (null? n)\n        0\n        (if (> (sum_digits\
    \ (car n)) 0)\n            (+ 1 (count (cdr n)))\n            (count (cdr n)))))\n\
    \  (count arr))\n", "  (let ((count 0))\n    (array-for-each (lambda (i)\n   \
    \                   (let ((digits (array->list (build-list (exact->inexact (abs\
    \ i))\n                                                            (lambda (i)\n\
    \                                                              (abs (integer->char\
    \ (inexact->integer (modulo (abs i) 10)))))))))\n                        (let\
    \ ((cur-sum 0))\n                          (for ((cur digits))\n             \
    \               (set! cur-sum (+ cur-sum (string->number (string cur)))))\n  \
    \                        (when (> cur-sum 0)\n                            (set!\
    \ count (+ count 1))))))\n                    arr)\n    count))", "  (array-length\
    \ (filter (lambda (i)\n                         (not (zero? (+ (array-ref arr\
    \ i)\n                                        (array-ref arr (add1 i))))))\n \
    \                        (build-array (sub1 (array-length arr))\n            \
    \                          add1))))\n", "  (count '((n) (apply + (map abs (number->list\
    \ n 10)))) arr))\n```\n\n```racket\n#lang racket\n", "  (foldl + 0 (map (lambda\
    \ (x) \n                    (if (positive? (abs x)) 1 0))\n                  arr)))\n",
  "  (apply + (map (lambda (x)\n                  (if (< x 0)\n                  \
    \    (- x)\n                      x))\n                arr)))\n", "  (filter (lambda\
    \ (x) (> (sum-digits x) 0)) arr))\n", "  (length (filter abs-sum-of-digits? arr)))\n",
  "  (letrec ([f (lambda (remaining-arr digit-sum)\n                (if (null? remaining-arr)\n\
    \                    digit-sum\n                    (f (cdr remaining-arr)\n \
    \                      (+ digit-sum (sum-digits (car remaining-arr))))))])\n \
    \   (f arr 0)))\n", "  (define (count_nums-helper i acc)\n    (if (= i (array-length\
    \ arr))\n        acc\n        (if (positive? (sum_of_digits (array-ref arr i)))\n\
    \            (count_nums-helper (+ i 1) (+ acc 1))\n            (count_nums-helper\
    \ (+ i 1) acc))))\n  (count_nums-helper 0 0))\n", "  (define (sum-digits n)\n\
    \    (cond\n      [(zero? n) 0]\n      [else (+ (remainder n 10) (sum-digits (quotient\
    \ n 10)))]))\n  (define (check-sum arr)\n    (cond\n      [(empty? arr) 0]\n \
    \     [(> (sum-digits (first arr)) 0)\n       (+ 1 (check-sum (rest arr)))]\n\
    \      [else (check-sum (rest arr))]))\n  (check-sum arr))\n", "  (define (abs\
    \ x)\n    (if (< x 0)\n        (- x)\n        x))\n  (define (digit_sum x)\n \
    \   (if (= x 0)\n        0\n        (+ (remainder x 10) (digit_sum (quotient x\
    \ 10)))))\n  (length (filter (lambda (x) (> (digit_sum (abs x)) 0)) arr)))\n",
  "  (define (next-digit n)\n    (if (< n 0) (next-digit (- n))\n        (if (< n\
    \ 10) 0\n            (+ (remainder n 10) (next-digit (quotient n 10))))))\n  (define\
    \ (digit-sum n)\n    (if (< n 0) (digit-sum (- n))\n        (if (< n 10) n\n \
    \           (+ (remainder n 10) (digit-sum (quotient n 10))))))\n  (define (loop\
    \ arr i)\n    (if (< i (array-length arr))\n        (if (< (digit-sum (array-ref\
    \ arr i)) 0)\n            (loop arr (+ i 1))\n            (+ 1 (loop arr (+ i\
    \ 1))))\n        0))\n  (loop arr 0))\n", "  (length (filter (lambda (n) (&gt;\
    \ (sum-of-digits n) 0)) arr)))\n", "  (array-count (lambda (n) (&gt; (apply +\
    \ (signed-digits n)) 0)) arr))\n", "  (define (sum-digits n)\n    (if (negative?\
    \ n) (sum-digits (- n))\n        (if (&lt; n 10) n\n            (+ (modulo n 10)\
    \ (sum-digits (quotient n 10))))))\n  (filter (lambda (e) (&gt; (sum-digits e)\
    \ 0)) arr))\n</code>\nTest Cases\n<code>;; (define my-array (array -100 0 -129\
    \ -999 1000 -9001 -8999 9999))", "  (length (filter (lambda (x)\n            \
    \        (if (zero? x) #f\n                      (and (> x 0) (> (sum_digits x)\
    \ 0))\n                      (and (< x 0) (< (sum_digits x) 0))))\n          \
    \        arr)))\n", "  (let loop ([i 0] [n 0])\n    (if (< i (array-length arr))\n\
    \        (let ((d (array-ref arr i)))\n          (if (and (number? d) (< 0 d))\n\
    \              (loop (+ i 1) (+ n 1))\n              (loop (+ i 1) n)))\n    \
    \    n)))\n", "  (let ([fst (array-ref arr 0)])\n    (array-length (filter (\u03BB\
    \ (n)\n                            (not (zero? (modulo n 10))))\n            \
    \              (build-array (array-length arr)\n                             \
    \          (\u03BB (i)\n                                         (if (negative?\
    \ fst)\n                                             (- (array-ref arr i))\n \
    \                                            (array-ref arr i))))))))\n", "  (let\
    \ loop ([arr arr] [num 0])\n    (if (null? arr)\n        num\n        (let* ([x\
    \ (car arr)]\n               [x_sum 0]\n               [x_sign 1])\n         \
    \ (if (negative? x)\n              (begin\n                (set! x_sign -1)\n\
    \                (set! x (- x))))\n          (let loop ([x x] [x_sum x_sum])\n\
    \            (if (zero? x)\n                x_sum\n                (loop (quotient\
    \ x 10) (+ x_sum (remainder x 10)))))\n          (if (> (* x_sign x_sum) 0)\n\
    \              (loop (cdr arr) (+ num 1))\n              (loop (cdr arr) num))))))\n",
  "  (cond [(empty? arr) 0]\n        [else\n         (define signed-digits (mapr abs\
    \ (abs->digits (first arr))))\n         (define sum (apply + signed-digits))\n\
    \         (cond [(zero? sum) (count_nums (rest arr))]\n               [else (+\
    \ 1 (count_nums (rest arr)))])]))\n", "  (let recur ([i 0] [acc 0])\n    (if (=\
    \ i (array-length arr))\n        acc\n        (if (not (zero? (array-ref arr i)))\n\
    \            (recur (+ i 1) (+ acc 1))\n            (recur (+ i 1) acc)))))\n",
  "  (letrec ([signum (lambda (n)\n                     (if (zero? n)\n          \
    \               0\n                         (if (< n 0)\n                    \
    \         (- n)\n                             n)))]\n           [digit-sum (lambda\
    \ (n)\n                        (if (zero? n)\n                            0\n\
    \                            (+ (remainder n 10)\n                           \
    \    (digit-sum (quotient n 10)))))]\n           [acc (lambda (idx)\n        \
    \          (if (= idx (vector-length arr))\n                      0\n        \
    \              (if (< (digit-sum (signum (vector-ref arr idx))) 0)\n         \
    \                 (acc (+ idx 1))\n                          (+ 1 (acc (+ idx\
    \ 1))))))])\n    (acc 0)))\n", "  (let ((acc 0))\n    (for ((i arr))\n      (if\
    \ (> (apply + (map abs (string->list (number->string i)))) 0)\n          (set!\
    \ acc (+ acc 1))))\n    acc))\n```\n\n```racket\n#lang racket\n", "  (length (filter\
    \ (lambda (x) (not (zero? (sum-digits x)))) arr)))\n", "  (foldl (lambda (x acc)\
    \ (if (and (> x 0) (> (sum-digits x) 0)) (+ acc 1) acc)) 0 arr))\n", "  (apply\
    \ + (map (\u03BB (n) (if (< (sum_digits n) 0) 0 1)) arr)))\n", "  (length (filter\
    \ (lambda (n)\n                    (&gt; (sum-digits n) 0))\n                \
    \  arr)))\n", "  (define res 0)\n  (define i 0)\n  (for ([x arr])\n    (when (positive?\
    \ (sum-digits x))\n      (set! res (+ res 1)))\n    (set! i (+ i 1)))\n  res)\n",
  "  (for/fold ([sum 0]) ([i arr])\n    (if (positive? (abs (sum-digits i)))\n   \
    \     (add1 sum)\n        sum)))\n", "  (apply + (map (lambda (e)\n          \
    \        (if (apply + (map abs (digits e))) 0 1))\n                arr)))\n",
  "  (let ((nums-with-sum (filter (\u03BB (x) (&gt; (sum_digits x) 0)) arr)))\n  \
    \  (length nums-with-sum)))\n", "  (foldl (lambda (e r) (if (sum-of-digits e)\
    \ (+ r 1) r)) 0 arr))\n", "  (letrec\n    ((is-sum-of-digits-gt-0? (lambda (num)\n\
    \                               (> (foldl (lambda (x y) (+ x y)) 0 (map abs (number->list\
    \ num))) 0)))\n     (sum-of-digits (lambda (arr)\n                      (foldl\
    \ (lambda (x y) (+ x y)) 0 (map is-sum-of-digits-gt-0? arr)))))\n    (sum-of-digits\
    \ arr)))\n", "  (length (filter (lambda (x) (&gt; (sum-digits x) 0)) arr)))\n",
  "  (let loop ([arr arr] [count 0])\n    (cond [(empty? arr) count]\n          [(>=\
    \ (sum-digits (first arr)) 0) (loop (rest arr) (+ count 1))]\n          [else\
    \ (loop (rest arr) count)])))\n", "  (array-length\n   (filter positive?\n   \
    \        (map sum-digits arr))))\n", "  (let loop ([i 0] [n 0])\n    (if (>= i\
    \ (array-length arr))\n        n\n        (if (positive? (array-ref arr i))\n\
    \            (loop (+ i 1) (+ n 1))\n            (loop (+ i 1) n)))))\n", "  ;;\
    \ we could use foldl here instead of `for'\n  (for/sum ([num arr])\n    (if (positive?\
    \ (sum-digits num)) 1 0)))\n", "  (cond [(empty? arr) 0]\n        [else (+ (count_nums\
    \ (rest arr))\n                 (if (sum_of_digits (first arr)) 1 0))]))\n", " \
    \ (count (lambda (n) (not (= 0 (sum_digits n)))) arr))\n", "  (define (sum_digits\
    \ num)\n    (if (or (= num 0) (= num -1))\n        0\n        (+ (remainder num\
    \ 10) (sum_digits (quotient num 10)))))\n  (define (is_pos num)\n    (not (= num\
    \ 0)))\n  (cond [(empty? arr) 0]\n        [else (+ (if (is_pos (sum_digits (first\
    \ arr))) 1 0)\n                 (count_nums (rest arr)))]))\n", "  (define (sum-digits\
    \ n)\n    (if (= n 0)\n        0\n        (+ (remainder n 10) (sum-digits (quotient\
    \ n 10)))))\n  (define (count-nums-helper i)\n    (if (= i (array-length arr))\n\
    \        0\n        (if (> (sum-digits (array-ref arr i)) 0)\n            (+ 1\
    \ (count-nums-helper (+ i 1)))\n            (count-nums-helper (+ i 1)))))\n \
    \ (count-nums-helper 0))\n", "  (define (sum-digits num)\n    (if (negative? num)\n\
    \        (begin\n          (set! num (- num))\n          (if (negative? num)\n\
    \              (set! num (- num))\n              (void)\n              )\n   \
    \       )\n        (void)\n        )\n    (define (inner n acc)\n      (if (=\
    \ n 0)\n          acc\n          (inner (quotient n 10) (+ acc (remainder n 10)))\n\
    \          )\n      )\n    (inner num 0)\n    )\n  (define (iter n acc)\n    (if\
    \ (= n (length arr))\n        acc\n        (if (> (sum-digits (vector-ref arr\
    \ n)) 0)\n            (iter (+ n 1) (+ acc 1))\n            (iter (+ n 1) acc)\n\
    \            )\n        )\n    )\n  (iter 0 0)\n  )\n", "  (define (digit-sum\
    \ n)\n    (if (= n 0)\n        0\n        (+ (remainder n 10) (digit-sum (quotient\
    \ n 10)))))\n  (define (helper n)\n    (if (equal? 0 n)\n        0\n        (if\
    \ (&gt; 0 (digit-sum (abs n)))\n            0\n            1)))\n  (for/sum ([i\
    \ arr]) (helper i)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
