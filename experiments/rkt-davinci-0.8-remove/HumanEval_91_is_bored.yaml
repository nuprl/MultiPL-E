name: HumanEval_91_is_bored
language: rkt
prompt: "#lang racket\n\n;; You'll be given a string of words, and your task is to\
  \ count the number\n;; of boredoms. A boredom is a sentence that starts with the\
  \ word \"I\".\n;; Sentences are delimited by '.', '?' or '!'.\n;; For example:\n\
  (define (is_bored S)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n\
  \    (check-equal? (candidate \"Hello world\") 0)\n    (check-equal? (candidate\
  \ \"Is the sky blue?\") 0)\n    (check-equal? (candidate \"I love It !\") 1)\n \
  \   (check-equal? (candidate \"bIt\") 0)\n    (check-equal? (candidate \"I feel\
  \ good today. I will be productive. will kill It\") 2)\n    (check-equal? (candidate\
  \ \"You and I are going for a walk\") 0)\n))\n\n(test-humaneval)"
completions: ["  (string-index S \"I\")\n  (string-index S \"!\")\n  (string-index\
    \ S \".\")\n  (string-index S \"?\"))\n", "  (regexp-match? \"^I\" S))\n", " \
    \ (if (= (string-length S) 0) 0\n      (if (string=? (substring S 0 1) \"I\")\
    \ 1 0)))\n", "  (not (empty? (regexp-match #rx\"^I\" S))))\n", "  (cond\n    ((string=?\
    \ S \"I\") 1)\n    (else\n     (let loop ([words (string-split S #\\ )]\n    \
    \            [count 0])\n       (cond\n         [(empty? words) count]\n     \
    \    [(string=? (first words) \"I\")\n          (loop (rest words) (+ count 1))]\n\
    \         [else (loop (rest words) count)])))))\n", "  (if (and (string-prefix?\
    \ \"I\" S) (string-suffix? \".\" S))\n      1\n      0))\n", "  (if (equal? (substring\
    \ S 0 1) \"I\")\n      1\n      0))", "  (string-prefix? \"I\" S))\n", "  (or\
    \ (equal? (substring S 0 1) \"I\")\n      (and (not (equal? (substring S 0 1)\
    \ \" \"))\n           (string-contains S \" I \"))))\n", "  (and (equal? (string-ref\
    \ S 0) #\\I)\n       (equal? (string-ref S 1) #\\ )\n       (equal? (string-ref\
    \ S 2) #\\b)\n       (equal? (string-ref S 3) #\\o)\n       (equal? (string-ref\
    \ S 4) #\\r)\n       (equal? (string-ref S 5) #\\e)\n       (equal? (string-ref\
    \ S 6) #\\d)\n       (equal? (string-ref S 7) #\\m)\n       (equal? (string-ref\
    \ S 8) #\\e)\n       (equal? (string-ref S 9) #\\n)\n       (equal? (string-ref\
    \ S 10) #\\t)))\n", "  (and (not (zero? (string-length S)))\n       (char=? (string-ref\
    \ S 0) #\\I)))\n", "  (regexp-match #rx\"^[I]\" S))\n", "  (cond\n    [(string=?\
    \ S \"I\") 1]\n    [else 0]))\n", "  (if (null? S)\n      #f\n      (if (equal?\
    \ (string-ref S 0) #\\I)\n          #t\n          #f)))\n", "  (if (string-length\
    \ S) (if (string=? (substring S 0 1) \"I\") 1 0) 0))\n", "  (cond\n    ((regexp-match\
    \ #rx\"(I )\" S) #t)\n    (else #f)))\n", '  (find-first-regexp "^I.+" S))', " \
    \ (if (string-contains S #\\I)\n      (if (string-contains S #\\.)\n         \
    \ (+ 1 (is_bored (string-tail S (string-index S #\\.))))\n          (if (string-contains\
    \ S #\\?)\n              (+ 1 (is_bored (string-tail S (string-index S #\\?))))\n\
    \              (if (string-contains S #\\!)\n                  (+ 1 (is_bored\
    \ (string-tail S (string-index S #\\!) 1)))\n                  0)))\n      0))\n",
  "  (regexp-match #rx\"^I\" S))\n", "  (not (regexp-match #rx\"^I\" S)))\n", "  (cond\
    \ ((string=? S \"\") 0)\n        ((string-contains S \".\") (is_bored (substring\
    \ S (string-index S \".\") +1)))\n        ((string-contains S \"?\") (is_bored\
    \ (substring S (string-index S \"?\") +1)))\n        ((string-contains S \"!\"\
    ) (is_bored (substring S (string-index S \"!\") +1)))\n        ((string-contains\
    \ S \"I\") (+ 1 (is_bored (substring S +1))))\n        (else (is_bored (substring\
    \ S +1)))))\n", "  (define (count-boredoms acc S)\n    (cond [(empty? S) acc]\n\
    \          [(prefix? \"I \" S) (count-boredoms (+ acc 1) (suffix S))]\n      \
    \    [else (count-boredoms acc (suffix S))]))\n  (count-boredoms 0 S))\n", " \
    \ (cond\n    [(empty? S) false]\n    [(equal? (first S) \"I\") true]\n    [else\
    \ (is_bored (rest S))]))\n", "  ;; A sentence is a sequence of words\n  (word?\
    \ S)\n  ;; and either ends with a '.', '?' or '!' (followed by a space)\n  (or\
    \ (char=? #\\! (last S))\n      (char=? #\\? (last S))\n      (char=? #\\. (last\
    \ S)))\n  ;; and the first word is 'I'\n  (char=? #\\I (char (first S))))\n",
  "  (list? (member \"I\" (string-split S #\\space))))\n", "  ;; \"I am bored! Finally.\"\
    \ => 1\n  ;; \"I am bored? Finally!\" => 1\n  ;; \"I am not bored. Finally!\"\
    \ => 0\n  (count (string-contains S #\\!) S)\n  (count (string-contains S #\\\
    ?) S)\n  (count (string-contains S #\\.) S)\n  )\n", "  (equal? (substring S 0\
    \ 1) \"I\"))\n", "  (string-contains S \"I\"))\n", "  (regexp-match? #rx\"^I\"\
    \ S))\n", "  (cond ((string=? S \"I am very happy\") 1)\n        ((string=? S\
    \ \"I am very bored\") 2)\n        ((string=? S \"I am happy\") 0)\n        ((string=?\
    \ S \"I am bored\") 1)\n        ((string=? S \"I am very happy!\") 1)\n      \
    \  ((string=? S \"I am very bored!\") 2)\n        ((string=? S \"I am happy!\"\
    ) 0)\n        ((string=? S \"I am bored!\") 1)\n        ((string=? S \"I am very\
    \ happy?\") 1)\n        ((string=? S \"I am very bored?\") 2)\n        ((string=?\
    \ S \"I am happy?\") 0)\n        ((string=? S \"I am bored?\") 1)\n        ((string=?\
    \ S \"I am very happy.\") 1)\n        ((string=? S \"I am very bored.\") 2)\n\
    \        ((string=? S \"I am happy.\") 0)\n        ((string=? S \"I am bored.\"\
    ) 1)\n        ((string=? S \"I am very happy!\") 1)\n        ((string=? S \"I\
    \ am very bored!\") 2)\n        ((string=? S \"I am happy!\") 0)\n        ((string=?\
    \ S \"I am bored!\") 1)\n        ((string=? S \"I am very happy?\") 1)\n     \
    \   ((string=? S \"I am very bored?\") 2)\n        ((string=? S \"I am happy?\"\
    ) 0)\n        ((string=? S \"I am bored?\") 1)\n        ((string=? S \"I am very\
    \ happy.\") 1)\n        ((string=? S \"I am very bored.\") 2)\n        ((string=?\
    \ S \"I am happy.\") 0)\n        ((string=? S \"I am bored.\") 1)\n        ((string=?\
    \ S \"I am very happy\") 1)\n        ((string=? S \"I am very bored\") 2)\n  \
    \      ((string=? S \"I am happy\") 0)\n        ((string=? S \"I am bored\") 1)\n\
    \        ((string=? S \"I am very happy!\") 1)\n        ((string=? S \"I am very\
    \ bored!\")", "  (string-contains S \"I \"))\n", "  (and (string-contains S \"\
    I\") (string-contains S \".\")))\n", "  (cond [(string=? \"I\" (substring S 0\
    \ 1)) 1]\n        [else 0]))", '  (contains "I" (split-regexp S #rx"[.?!]")))',
  "  (cond\n    [(empty? S) 0]\n    [(equal? (car S) \"I\") (add1 (is_bored (cdr S)))]\n\
    \    [else (is_bored (cdr S))]))\n", "  (define (is_bored' L)\n    (if (null?\
    \ L)\n        0\n        (if (equal? \"I\" (first L))\n            (+ 1 (is_bored'\
    \ (rest L)))\n            (is_bored' (rest L)))))\n  (is_bored' (regexp-split\
    \ #rx\"\\\\.|!|\\\\?\" S)))\n", "  (if (string-prefix? \"I\" S)\n      1\n   \
    \   0))\n", "  (match S\n    [(and (list (? char-upper-case?)) _) #t]\n    [_\
    \ #f]))\n", "  (string-match \"I \" S))\n", "  (string-contains S \"I\"))\n",
  "  (cond\n    [(string=? S \"I\") #t]\n    [else #f]))\n", "  (string-contains S\
    \ \" I \"))\n", "  (or (equal? S \"I\") (equal? S \"Iam\") (equal? S \"Iamnot\"\
    ) (equal? S \"Iamalso\")))\n", "  (string-index S #\\I))\n", "  (and (string-prefix?\
    \ (string-upcase S) \"I\")\n       (not (string-suffix? (string-trim-right S)\
    \ \".\"))))\n", "  (and (not (empty? S))\n       (eq? (first S) \"I\")))\n", " \
    \ (equal? (substring S 0 1) \"I\"))\n", "  (and (symbol=? (first (string-&gt;list\
    \ S)) #\\I)\n       (member (list-ref (string-&gt;list S) 1) '(#\\  #\\.))))\n",
  '  (regexp-match? #rx"^I [a-z]+" S))', "  (string-match \"^I\" S))\n", "  (string-index\
    \ S #\\!))\n", '  (regexp-match #rx"^I" S))', "  (or (string=? S \"I\")\n    \
    \  (string=? S \"I am\")\n      (string=? S \"I am happy\")\n      (string=? S\
    \ \"I am very happy\")\n      (string=? S \"I am not happy\")\n      (string=?\
    \ S \"I am not very happy\")\n      (string=? S \"I am not very happy today\"\
    )\n      (string=? S \"I am not very happy today because I went to the cinema\
    \ with my best friend and I did not see the film we wanted to see\")\n      (string=?\
    \ S \"I am not very happy today because I went to the cinema with my best friend\
    \ and I did not see the film we wanted to see but it does not matter\")))\n",
  "  (match S ['(! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . .", "  (regexp-match #rx\"^I \" S))\n", "  (if\
    \ (regexp-match #rx\"^I\" S)\n      (1+ (is_bored (rest S)))\n      0))\n", " \
    \ (string-contains S \"I\"))\n", '  (regexp-match? "^I" S))', '  (equal? (string-ref
    S 0) #\I))', "  (string-contains? S \"I\")\n  )\n", '  (regexp-match #rx"^I" S))',
  "  (not (string-empty? S)))\n", "  (string-contains S \"I\"))\n", "  (eq? \"I\"\
    \ (first (string-tokenize S))))\n", "  (eq? \"I\" (first (string-split S #\\space))))\n",
  "  (string-contains? S \"I am bored\"))\n", "  (and (char=? (string-ref S 0) #\\\
    I)\n       (string-contains S #\\.)\n       (string-contains S #\\!)\n       (string-contains\
    \ S #\\?)))", "  (if (string-prefix? \"I\" S)\n      #t\n      #f))\n", "  (cond\n\
    \    [(string=? S \"I\") 1]\n    [else 0]))", "  (cond ((empty? S) 0)\n      \
    \  ((equal? (substring S 0 1) \"I\")\n         (+ 1 (is_bored (substring S 1))))\n\
    \        (else (is_bored (substring S 1)))))", "  (cond [(string=? S \"I\") #t]\n\
    \        [else #f]))", "  (regexp-match #rx\"I[^.?!]+\" S))\n", '  (regexp-match?
    (regexp #rx"^I[^I]") S))', "  (if (string-empty? S) 0\n      (if (equal? (substring\
    \ S 0 1) \"I\")\n          (+ 1 (is_bored (substring S 1 (string-length S))))\n\
    \          (is_bored (substring S 1 (string-length S))))))\n", "  (string-index\
    \ (string-trim S) \"I\"))\n", "  (if (string-prefix? \"I\" S)\n      1\n     \
    \ 0))\n", "  (if (regexp-match? (regexp \"^I\") S)\n      1\n      0))", "  (define\
    \ (count_boredoms S start)\n    (if (&gt;= (string-length S) (+ start 3))\n  \
    \      (if (string=? (substring S start 3) \"I am\")\n            (add1 (count_boredoms\
    \ S (+ start 1)))\n            (count_boredoms S (+ start 1)))\n        0))\n\
    \  (count_boredoms S 0))\n</code>\n", "  (if (equal? (first (string-split S \"\
    \ \")) \"I\")\n      1\n      0))", "  (string-prefix? \"I\" S))\n", "  (cond\
    \ ((string=? \"I\" (string-take S 1)) #t)\n        (else #f)))", "  (equal? \"\
    I\" (string-ref S 0)))\n", "  (if (string-contains S \"I\")\n      #t\n      #f))\n",
  "  (regexp-match #rx\"^I \" S))\n", "  (cond [(string=? (first S) \"I\") true]\n\
    \        [else false]))\n", "  (cond [(string=? \"I\" (first (string-split S #\\\
    space)))\n         1]\n        [else\n         0]))", "  (string-match \"^I\"\
    \ S))\n", "  (and\n   (not (empty? S))\n   (string=? (substring S 0 1) \"I\")))\n",
  '  (string-contains (list->string (first (regexp-match #rx"I" S))) "I"))', "  (cond\n\
    \    [(string=? \"I\" (first (string-split S))) #t]\n    [else #f]))\n", "  (regexp-match\
    \ #rx\"I[^.?]*[.?!]\" S))\n", "  (cond [(equal? \"I\" (first (string-split S)))\n\
    \         #t]\n        [else\n         #f]))\n", "  (and (regexp-match #rx\"I\
    \ \" S)\n       (not (regexp-match #rx\"I 'm\" S))))", "  (member (first (string-split\
    \ S)) '(#\\I #\\i)))\n", "  (cond [(string=? (string-take S 2) \"I \") #t]\n \
    \       [else #f]))\n", '  (and (string-has-prefix? "I" S) (string-has-prefix?
    "." S)))', '  (string-contains? (string-downcase S) "i "))', "  ;;(string-empty?\
    \ (string-trim (string-replace S #rx\"I\\s+\" \"\")))\n  (string-empty? (string-trim\
    \ (regexp-replace S #rx\"I\\s+\" \"\"))))\n", "  (cond\n    [(empty? S)  0]\n\
    \    [(string=? (first S) \"I\") (is_bored (rest S)) + 1]\n    [else (is_bored\
    \ (rest S))]))", "  (cond\n    [(empty? S) 0]\n    [(string=? (substring S 0 1)\
    \ \"I\") (+ 1 (is_bored (string-drop S 1)))]\n    [else (is_bored (string-drop\
    \ S 1))]))\n", '  (regexp-match* #rx"I" S))', "  (string-contains (substring S\
    \ 0 1) \"I\"))\n", '  (regexp-match #rx"^I" S))', "  (equal? (string-take S 1)\
    \ \"I\"))\n", "  (local [(define L (string-split S #\\space))]\n    (for/fold\
    \ ([count 0]) ([x L])\n      (if (equal? (first x) \"I\")\n          (+ count\
    \ 1)\n          count))))\n", "  (if (equal? (first (string-split S \" \")) \"\
    I\")\n      1\n      0))", '  (regexp-match? "^\\s*I\\s.*\\." S))', "  (regexp-match*\
    \ #rx\"^I[ ]\" S))\n", "  (regexp-match #rx\"^I\" S))\n", "  (regexp-match? #rx\"\
    I\" S))\n", "  (cond\n    [(empty? S) 0]\n    [(string=? (take S 4) \"I am\")\
    \ (+ 1 (is_bored (drop S 5)))]\n    [(string=? (take S 2) \"I \") (+ 1 (is_bored\
    \ (drop S 3)))]\n    [else (is_bored (cdr S))]))\n", "  (cond\n    [(empty? S)\
    \ 0]\n    [(equal? (substring S 0 2) \"I \") (+ 1 (is_bored (substring S 2 (string-length\
    \ S))))]\n    [else (is_bored (substring S 1 (string-length S)))]))\n", "  (string-contains\
    \ S \"I\"))\n", "  (cond\n    [(empty? S) 0]\n    [(equal? (substring S 0 2) \"\
    I \")\n     (+ 1 (is_bored (substring S (+ 2 (string-index S \" \")))))]\n   \
    \ [else (is_bored (substring S 1))]))\n", '  (regexp-match? #rx"^I" S))', "  (string-starts-with?\
    \ S \"I\"))\n", "  (string-length (regexp-match #rx\"I [^?.!]*[?.!]\" S)))\n</code>",
  "  (regexp-match? #rx\"^I \" S))\n", "  (regexp-match #rx\"^I\" S))\n", "  (match\
    \ S\n    ['() false]\n    [(list 'I _ ...) true]\n    [_ (is_bored (cdr S))]))\n",
  "  (equal? (substring S 0 1) \"I\"))\n", "  (string-contains S \"I \"))\n", "  (and\
    \ (string=? (substring S 0 1) \"I\")\n       (memq (string-ref S (sub1 (string-length\
    \ S))) '(#\\! #\\? #\\.))))\n", "  (or (string=? S \"I\")\n      (string=? S \"\
    I am\")\n      (string=? S \"I am bored\")\n      (string=? S \"I am not\")\n\
    \      (string=? S \"I am not bored\")\n      (string=? S \"I am not really\"\
    )\n      (string=? S \"I am not really bored\")\n      (string=? S \"I am not\
    \ really a\")\n      (string=? S \"I am not really a bored\")\n      (string=?\
    \ S \"I am not really a monkey\")\n      (string=? S \"I am not really a monkey.\"\
    )\n      (string=? S \"I am not really a monkey!\")\n      (string=? S \"I am\
    \ not really a monkey?\")\n      (string=? S \"I am not really a bored monkey\"\
    )\n      (string=? S \"I am not really a bored monkey.\")\n      (string=? S \"\
    I am not really a bored monkey!\")\n      (string=? S \"I am not really a bored\
    \ monkey?\")\n      (string=? S \"I am not really a bored monkey. I am not really\"\
    )\n      (string=? S \"I am not really a bored monkey. I am not really bored\"\
    )\n      (string=? S \"I am not really a bored monkey. I am not really bored!\"\
    )\n      (string=? S \"I am not really a bored monkey. I am not really bored?\"\
    )\n      (string=? S \"I am not really a bored monkey! I am not really\")\n  \
    \    (string=? S \"I am not really a bored monkey! I am not really bored\")\n\
    \      (string=? S \"I am not really a bored monkey! I am not really bored!\"\
    )\n      (string=? S \"I am not really a bored monkey! I am not really bored?\"\
    )\n      (string=? S \"I am not really a bored monkey? I am not really\")\n  \
    \    (string=? S \"I am not really a bored monkey? I am not really bored\")\n\
    \      (string=? S \"I am not really a bored monkey? I am not really bored!\"\
    )\n      (string=? S \"I am not really a bored monkey? I am not really bored?\"\
    )\n", "  (string-match \"^I.*\" S))\n", "  (cond [(string=? \"I\" (substring S\
    \ 0 1)) 1]\n        [else 0]))\n", "  (string-match #rx\"^I\\\\W\" S))\n", " \
    \ (cond\n    [(empty? S) 0]\n    [(regexp-match #rx\"^I\" S) (+ 1 (is_bored (regexp-replace\
    \ #rx\"^I[^.!?]+\" S \"\")))]\n    [else (is_bored (regexp-replace #rx\"^[^.!?]+\"\
    \ S \"\"))]))\n", "  (and (string-prefix? \"I\" S)\n       (or (string-suffix?\
    \ \".\" S)\n           (string-suffix? \"?\" S)\n           (string-suffix? \"\
    !\" S))))\n", "  (let*\n      ([words (string-split S)]\n       [count (count\
    \ 1 (apply append (for/list ([w words])\n                                    \
    \   (if (string=? (substring w 0 1) \"I\")\n                                 \
    \          (list 1)\n                                           (list 0)))))]\n\
    \       [count\n        (cond\n         [(string=? (string-upcase (substring (vector-ref\
    \ words 0) 0 1)) \"I\")\n          (count + 1)]\n         [else count])])\n  \
    \  count))\n", "  (regexp-match? \"I \" S))\n", "  (and\n   (string-contains S\
    \ \"I\")\n   (string-contains S \".\")\n   (string-contains S \"?\")\n   (string-contains\
    \ S \"!\")))\n", "  (define (bored? S)\n    (if (empty? S)\n        #f\n     \
    \   (or (string=? \"I\" (first S))\n            (bored? (rest S)))))\n  (define\
    \ (count-boredom S n)\n    (if (empty? S)\n        n\n        (if (bored? (first\
    \ S))\n            (count-boredom (rest S) (+ n 1))\n            (count-boredom\
    \ (rest S) n))))\n  (count-boredom (map string-split (string-split S \"!|\\\\\
    .\")) 0))\n", "  (equal? (car (string-split S)) \"I\"))\n", '  (if (regexp-match?
    (regexp "^I") S) 1 0))', "  (or (string=? S \"\")\n      (equal? #\\I (string-ref\
    \ S 0))))\n", "  (regexp-match #rx\"^I\" S))\n", "  (regexp-match #rx\"^I\\\\\
    W\" S))\n", "  (member S '(I am really really bored.\n            I really hate\
    \ being bored.\n            I really cannot stand it when I'm bored.\n       \
    \     I am so bored that I can't even think straight.\n            I am bored\
    \ enough to eat my own foot.\n            I am so bored of being bored all the\
    \ time.\n            I am too bored to do anything.\n            I am bored to\
    \ death.\n            I am literally so bored right now.\n            I can't\
    \ believe I'm still so bored.\n            I hate being bored.\n            I\
    \ hate being bored so much.\n            I'm bored.\n            I am bored.\n\
    \            I cannot stand being bored.\n            I am so bored right now.\n\
    \            I literally can't stand being bored anymore.\n            I have\
    \ never been so bored in my entire life.\n            I am so bored right now\
    \ I could scream.\n            I can't stand being bored.\n            I am bored\
    \ out of my mind.\n            I am so bored.\n            I am so so bored.\n\
    \            I hate being bored all the time.\n            I am so bored I could\
    \ scream.\n            I am so bored out of my mind.\n            I am so bored\
    \ out of my mind I could scream.\n            I am so bored of being bored all\
    \ the time.\n            I am so bored to death.\n            I am so bored with\
    \ my life.\n            I am so so bored right now.\n            I am so so so\
    \ bored.\n            I am so so so so bored.\n            I am so so so so so\
    \ bored.\n            I am so so so so so so bored.\n            I'm bored to\
    \ death.\n            I am literally so bored right now I could scream.\n    \
    \        I am so bored I could die.\n            I can't stand being bored right\
    \ now.\n            I hate being bored all the time.\n            I am bored out\
    \ of my mind.\n            I can't believe I'm still so bored.\n            I\
    \ cannot stand being bored.\n            I am literally so bored right now I could\
    \ scream.\n            I am so bored I could die.\n            I can't stand being\
    \ bored right now.\n            I am so bored I could cry.\n            I am so\
    \ bored I could vomit.\n            I am so bored I could die.\n            I\
    \ am so bored I could literally die.", "  (string-contains (car (regexp-match\
    \ #rx\"^I\" S)) #\\I))\n", "  (and (string-contains S \"I\") (or (string-contains\
    \ S \"?\") (string-contains S \"!\") (string-contains S \".\"))))\n", "  (or (string=?\
    \ S \"I am bored.\")\n      (string=? S \"I am very bored.\")\n      (string=?\
    \ S \"I am so bored.\")\n      (string=? S \"I am bored out of my mind.\")\n \
    \     (string=? S \"I am so bored out of my mind.\")\n      (string=? S \"I am\
    \ so totally bored.\")\n      (string=? S \"I am so totally bored out of my mind.\"\
    )\n      (string=? S \"I am so totally bored out of my tiny mind.\")\n      (string=?\
    \ S \"I am so totally and completely bored.\")\n      (string=? S \"I am so totally\
    \ and completely bored out of my mind.\")\n      (string=? S \"I am so totally\
    \ and completely bored out of my tiny mind.\")\n      (string=? S \"I am so totally\
    \ and completely and utterly bored.\")\n      (string=? S \"I am so totally and\
    \ completely and utterly bored out of my mind.\")\n      (string=? S \"I am so\
    \ totally and completely and utterly bored out of my tiny mind.\")\n      (string=?\
    \ S \"I am so totally and completely and utterly and really bored.\")\n      (string=?\
    \ S \"I am so totally and completely and utterly and really bored out of my mind.\"\
    )\n      (string=? S \"I am so totally and completely and utterly and really bored\
    \ out of my tiny mind.\")\n      (string=? S \"I am so totally and completely\
    \ and utterly and really and royally bored.\")\n      (string=? S \"I am so totally\
    \ and completely and utterly and really and royally bored out of my mind.\")\n\
    \      (string=? S \"I am so totally and completely and utterly and really and\
    \ royally bored out of my tiny mind.\")\n      (string=? S \"I am so totally and\
    \ completely and utterly and really and royally and seriously bored.\")\n    \
    \  (string=? S \"I am so totally and completely and utterly and really and royally\
    \ and seriously bored out of my mind.\")\n      (string=? S \"I am so totally\
    \ and completely and utterly and really and royally and seriously bored out of\
    \ my tiny mind.\")\n      (string=? S \"I am so totally and completely and utterly\
    \ and really and royally and seriously and extremely bored.\")\n      (string=?\
    \ S \"I am", "  (string-prefix? \"I\" S))\n", "  (and (not (empty? S))\n     \
    \  (char=? (first S) #\\I)\n       (char=? (second S) #\\ )\n       (regexp-match\
    \ #rx\"^I .*\" S)))\n", "  (string-match \"I[^\\.]*[\\.\\?!]\" S))\n", "  (if\
    \ (regexp-match \"^I\" S)\n      'bored\n      'not-bored))", "  (and (eq? (string-ref\
    \ S 0) #\\I)\n       (or (eq? (string-ref S 1) #\\.)\n           (eq? (string-ref\
    \ S 1) #\\?)\n           (eq? (string-ref S 1) #\\!))))\n", "  ;; tokenize\n \
    \ (for/fold ([result #f]) ([token (in-string S #\\! #\\? #\\.)])\n    (if (eq?\
    \ 'I (car token))\n        (if result\n            #t\n            (car token))\n\
    \        result)))\n", "  (string-contains (string-upcase S) \"I\"))\n", "  (if\
    \ (string-index S #\\I)\n      (if (string-index S #\\?)\n          \"meh.\"\n\
    \          \"cheer up!\")\n      \"I'm never bored.\"))\n", "  (regexp-match?\
    \ (regexp \"^I\") (car (string-split S #\\space))))\n", '  (string-contains S
    " I "))', "  (and (string=? (substring S 0 1) \"I\")\n       (or (string=? (substring\
    \ S (sub1 (string-length S))\n                               (string-length S))\
    \ \".\")\n           (string=? (substring S (sub1 (string-length S))\n       \
    \                        (string-length S)) \"?\")\n           (string=? (substring\
    \ S (sub1 (string-length S))\n                               (string-length S))\
    \ \"!\"))))\n", "  (string-contains S \"I \"))\n", "  (regexp-match? #rx\"(^I)\"\
    \ S))\n", "  (and (equal? \"I\" (first (string-tokenize S #\\space)))\n      \
    \ (regexp-match? #rx\"^I\" S)))\n", "  (eq? 'I (first (string-&gt;list S))))\n",
  "  (regexp-match #rx\"^I\" S))\n", "  (cond\n    [(empty? S) 0]\n    [(equal? (first\
    \ S) #\\I) (+ 1 (is_bored (rest S)))]\n    [else (is_bored (rest S))]))\n", " \
    \ ;; #lang racket\n  (regexp-match? #rx\"^I\" S))\n", "  (string-match #rx\"^I\
    \ \" S))\n", "  (cond ((regexp-match #rx\"^I\\\\b\" S) #t)\n        (else #f)))",
  "  (string-contains S \"I \"))\n", "  (if (equal? (substring S 0 1) \"I\")\n   \
    \   (number->string (+ 1 (string->number S)))\n      S))\n", "  (equal? \"I\"\
    \ (car (string-split S #\\space))))\n", '  (regexp-match? #rx"^I.*" S))', '  (regexp-match?
    #rx"I[^?.!]*[?.!]" S))', "  (and (string=? \"I\" (substring S 0 1)) (string-search\
    \ \".\" S)))\n", '  (regexp-match? #rx"I.*\\." S))', "  (equal? (first (string-tokenize\
    \ S)) \"I\"))\n", "  (string-contains S \"I \"))\n", "  (cond [(string=? S \"\
    I\") 1]\n        [else 0]))", "  (string-prefix? \"I\" S))\n", '  (regexp-match?
    (regexp #rx"I+") S))', "  (string-contains S \"I\")\n)\n", "  (if (empty? S)\n\
    \      0\n      (if (equal? (substring S 0 1) \"I\")\n          (+ 1 (is_bored\
    \ (substring S 1 (string-length S))))\n          (is_bored (substring S 1 (string-length\
    \ S))))))\n", "  (eq? (substring S 0 1) \"I\"))\n", "  (string-match? \"^I \"\
    \ S))\n", "  (and (and (string? S) (not (empty? S)))\n       (equal? (string-length\
    \ S) 1)\n       (equal? (string-upcase (substring S 0 1)) \"I\")))\n", "  (regexp-match\
    \ #rx\"^I\" S))\n", "  (string-equal? (string-take S 1) \"I\"))\n", "  (cond [(empty?\
    \ S) empty]\n        [(equal? (first S) \"I\") (rest S)]\n        [else (is_bored\
    \ (rest S))]))\n", "  (regexp-match #rx\"^I\" S))\n", "  (regexp-match #rx\"^I\\\
    s+[a-z]+\\s+[a-z]+\\s+[a-z]+\\s+[a-z]+\\s+[a-z]+\" S))\n", "  (cond ((string=?\
    \ \"I\" (substring S 0 1)) #t)\n        (else #f)))\n", "  (string-prefix? \"\
    I\" S))\n", "  (string-prefix? \"I\" S))\n", "  (if (empty? S)\n      false\n\
    \      (if (string=? (substring S 0 1) \"I\")\n          true\n          (is_bored\
    \ (substring S 1)))))\n", "  (and (and (string=? (substring S 0 1) \"I\")\n  \
    \          (string=? (substring S (sub1 (string-length S))\n                 \
    \               (string-length S))\n                     \".\"))\n       (not\
    \ (string=? (substring S 0 1) \"I.\"))))\n", "  (string-match (regexp #rx\"^ *I\
    \ \") S))\n", "  (match (string-split S)\n    ['() 0]\n    [(list H T)\n     (cond\
    \ [(string=? H \"I\") (add1 (is_bored (string-join T)))]\n           [else (is_bored\
    \ (string-join T))])]))\n", "  (string-empty? (string-trim S)))\n", "  (equal?\
    \ (substring S 0 1) \"I\"))\n", "  (and (not (null? S))\n       (string=? (string-upcase\
    \ (substring S 0 1)) \"I\")))\n", "  (string-prefix? \"I\" S))\n", "  (and (string=?\
    \ \"I\" (substring S 0 1))\n       (member (substring S (sub1 (string-length S)))\
    \ '(\".\" \"?\" \"!\"))))", "  (regexp-match #rx\"^[Ii]\" S))\n", "  (match (string-split\
    \ S)\n    (`(,head . ,rest)\n      (if (string=? \"I\" head)\n          1\n  \
    \        0))))\n", "  (cond\n    [(string=? S \"I\")\n     #t]\n    [(string=?\
    \ S \"I'm\")\n     #t]\n    [(string=? S \"I've\")\n     #t]\n    [(string=? S\
    \ \"I'll\")\n     #t]\n    [(string=? S \"I'd\")\n     #t]\n    [(string=? S \"\
    I'm afraid\")\n     #t]\n    [(string=? S \"I'd like\")\n     #t]\n    [(string=?\
    \ S \"I'm sorry\")\n     #t]\n    [(string=? S \"I'm sure\")\n     #t]\n    [(string=?\
    \ S \"I'll try\")\n     #t]\n    [(string=? S \"I'll make\")\n     #t]\n    [(string=?\
    \ S \"I'm going\")\n     #t]\n    [(string=? S \"I've got\")\n     #t]\n    [(string=?\
    \ S \"I'll give\")\n     #t]\n    [(string=? S \"I'm just\")\n     #t]\n    [(string=?\
    \ S \"I've been\")\n     #t]\n    [(string=? S \"I'm thinking\")\n     #t]\n \
    \   [(string=? S \"I've heard\")\n     #t]\n    [(string=? S \"I'll see\")\n \
    \    #t]\n    [(string=? S \"I'd better\")\n     #t]\n    [(string=? S \"I'm not\"\
    )\n     #t]\n    [(string=? S \"I'll talk\")\n     #t]\n    [(string=? S \"I'll\
    \ think\")\n     #t]\n    [(string=? S \"I'll take\")\n     #t]\n    [(string=?\
    \ S \"I'll tell\")\n     #t]\n    [(string=? S \"I'll leave\")\n     #t]\n   \
    \ [(string=? S \"I'll set\")\n     #t]\n    [(string=? S \"I'm afraid\")\n   \
    \  #t]\n    [(string=? S \"I'll call\")\n     #t]\n    [(string=? S \"I'll come\"\
    )\n     #t]\n    [(string", "  (equal? (string-take S 1) \"I\"))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
