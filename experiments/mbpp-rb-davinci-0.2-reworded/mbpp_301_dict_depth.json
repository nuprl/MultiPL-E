{
  "name": "mbpp_301_dict_depth",
  "language": "rb",
  "prompt": "# Write a function to find the depth of a hash.\ndef dict_depth(d)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_301_dict_depth.py",
  "prompt_terminology": "reworded",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_dict_depth\n    candidate = method(:dict_depth)\n    assert_equal(4, candidate.call({\"a\" => 1, \"b\" => {\"c\" => {\"d\" => {}}}}))\n    assert_equal(2, candidate.call({\"a\" => 1, \"b\" => {\"c\" => \"python\"}}))\n    assert_equal(3, candidate.call({1 => \"Sun\", 2 => {3 => {4 => \"Mon\"}}}))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "  return 0 if d.empty?\n  1 + d.values.map { |v| dict_depth(v) }.max\nend",
    "  return 0 if d.empty?\n  1 + d.values.map { |v| dict_depth(v) }.max\nend",
    "  return 0 if d.empty?\n  return 1 if d.values.all? { |v| !v.is_a?(Hash) }\n  1 + dict_depth(d.values.select { |v| v.is_a?(Hash) }.max_by { |v| dict_depth(v) })\nend",
    "  return 0 unless d.is_a?(Hash)\n  1 + [dict_depth(d.values[0]), dict_depth(d.values[1])].max\nend",
    "  return 0 if d.empty?\n  d.values.map { |v| dict_depth(v) }.max + 1\nend",
    "  return 0 if d.empty?\n  return 1 if d.values.all? { |v| !v.is_a?(Hash) }\n  1 + dict_depth(d.values.max_by { |v| dict_depth(v) })\nend",
    "  return 0 if d.empty?\n  1 + d.values.map { |v| dict_depth(v) }.max\nend",
    "  return 0 if d.empty?\n  d.values.map { |v| dict_depth(v) }.max + 1\nend",
    "  return 0 if d.empty?\n  d.values.map { |v| dict_depth(v) }.max + 1\nend",
    "  return 0 if d.empty?\n  return 1 if d.values.all? { |v| !v.is_a?(Hash) }\n  1 + d.values.map { |v| dict_depth(v) }.max\nend",
    "  return 0 if d.empty?\n  return 1 if d.values.all? { |v| v.is_a?(Integer) }\n  1 + dict_depth(d.values.max_by { |v| dict_depth(v) })\nend",
    "  return 0 if d.empty?\n  d.values.map { |v| dict_depth(v) }.max + 1\nend",
    "  return 0 if d.empty?\n  d.map { |k, v| dict_depth(v) }.max + 1\nend",
    "  return 0 if d.empty?\n  d.map { |k, v| dict_depth(v) }.max + 1\nend",
    "  return 0 if d.empty?\n  return 1 if d.all? { |k, v| v.is_a?(Integer) }\n  1 + dict_depth(d.values.max_by { |v| dict_depth(v) })\nend",
    "  return 0 if d.empty?\n  d.values.map { |v| dict_depth(v) }.max + 1\nend",
    "  return 0 if d.empty?\n  return 1 if d.values.all? { |v| !v.is_a?(Hash) }\n  1 + dict_depth(d.values.max_by { |v| dict_depth(v) })\nend",
    "  return 0 if d.empty?\n  d.map { |k, v| dict_depth(v) }.max + 1\nend",
    "  return 0 if d.empty?\n  1 + d.values.map { |v| dict_depth(v) }.max\nend",
    "  return 0 if d.empty?\n  d.map { |k, v| dict_depth(v) }.max + 1\nend"
  ]
}