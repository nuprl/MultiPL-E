{
  "name": "mbpp_141_pancake_sort",
  "language": "rb",
  "prompt": "# Write a function to sort an array of elements.\ndef pancake_sort(nums)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py",
  "prompt_terminology": "reworded",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pancake_sort\n    candidate = method(:pancake_sort)\n    assert_equal([15, 25, 38, 69, 79], candidate.call([15, 79, 25, 38, 69]))\n    assert_equal([12, 36, 54, 85, 98], candidate.call([98, 12, 54, 36, 85]))\n    assert_equal([12, 23, 32, 41, 42], candidate.call([41, 42, 32, 12, 23]))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "  return nums if nums.length <= 1\n  (nums.length - 1).downto(1) do |i|\n    max_index = 0\n    (0..i).each do |j|\n      max_index = j if nums[j] > nums[max_index]\n    end\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  return nums if nums.length <= 1\n  (nums.length - 1).downto(1).each do |i|\n    max_index = nums[0..i].each_with_index.max[1]\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  # Write your code here.\n  sorted_index = nums.length - 1\n  while sorted_index > 0\n    max_index = find_max(nums, sorted_index)\n    flip(nums, max_index)\n    flip(nums, sorted_index)\n    sorted_index -= 1\n  end\n  nums\nend",
    "  # Write your code here.\n  sorted_index = nums.length - 1\n  while sorted_index > 0\n    max_index = find_max(nums, sorted_index)\n    flip(nums, max_index)\n    flip(nums, sorted_index)\n    sorted_index -= 1\n  end\n  nums\nend",
    "  # Write your code here\n  return nums if nums.length <= 1\n  (nums.length - 1).downto(1) do |size|\n    max_index = find_max_index(nums, size)\n    flip(nums, max_index)\n    flip(nums, size)\n  end\n  nums\nend",
    "  n = nums.length\n  (n - 1).downto(1) do |i|\n    max_index = find_max_index(nums, i)\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  return nums if nums.length <= 1\n  (nums.length - 1).downto(1) do |i|\n    max_index = 0\n    (0..i).each do |j|\n      max_index = j if nums[j] > nums[max_index]\n    end\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  return nums if nums.length <= 1",
    "  # Write your code here\n  return nums if nums.length <= 1\n  (nums.length - 1).downto(1) do |size|\n    max_index = find_max_index(nums, size)\n    flip(nums, max_index)\n    flip(nums, size)\n  end\n  nums\nend",
    "  n = nums.length\n  (n - 1).downto(1) do |i|\n    max_index = find_max_index(nums, i)\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  # Write your code here.\n  sorted_index = nums.length - 1\n  while sorted_index > 0\n    max_index = find_max(nums, sorted_index)\n    flip(nums, max_index)\n    flip(nums, sorted_index)\n    sorted_index -= 1\n  end\n  nums\nend",
    "  # Write your code here\n  n = nums.length\n  for i in 0..n-1\n    max_index = find_max_index(nums, n-i)\n    flip(nums, max_index)\n    flip(nums, n-i-1)\n  end\n  nums\nend",
    "  # Write your code here.\n  sorted_index = nums.length - 1\n  while sorted_index > 0\n    max_index = find_max(nums, sorted_index)\n    flip(nums, max_index)\n    flip(nums, sorted_index)\n    sorted_index -= 1\n  end\n  nums\nend",
    "  # Write your code here\n  return nums if nums.nil? || nums.length <= 1",
    "  # Write your code here.\n  i = nums.length - 1\n  while i > 0\n    max_index = find_max(nums, i)\n    flip(nums, max_index)\n    flip(nums, i)\n    i -= 1\n  end\n  nums\nend",
    "  return nums if nums.length <= 1",
    "  return nums if nums.length <= 1\n  max_index = nums.length - 1\n  while max_index > 0\n    max_num = nums[0]\n    max_num_index = 0\n    (0..max_index).each do |i|\n      if nums[i] > max_num\n        max_num = nums[i]\n        max_num_index = i\n      end\n    end\n    flip(nums, max_num_index)\n    flip(nums, max_index)\n    max_index -= 1\n  end\n  nums\nend",
    "  n = nums.length\n  while n > 1\n    max_index = nums.index(nums[0...n].max)\n    if max_index != n - 1\n      flip(nums, max_index)\n      flip(nums, n - 1)\n    end\n    n -= 1\n  end\n  nums\nend",
    "  nums.length.downto(2) do |size|\n    max_index = nums.slice(0, size).each_with_index.max[1]\n    flip(nums, max_index)\n    flip(nums, size - 1)\n  end\n  nums\nend",
    "  # Write your code here.\n  return nums if nums.length <= 1\n  (nums.length - 1).downto(1) do |idx|\n    max_idx = find_max(nums, idx)\n    flip(nums, max_idx)\n    flip(nums, idx)\n  end\n  nums\nend"
  ]
}