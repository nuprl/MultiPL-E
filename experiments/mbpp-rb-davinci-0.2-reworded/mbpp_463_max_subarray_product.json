{
  "name": "mbpp_463_max_subarray_product",
  "language": "rb",
  "prompt": "# Write a function to find the maximum product subarray of the given array.\ndef max_subarray_product(arr)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "reworded",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_subarray_product\n    candidate = method(:max_subarray_product)\n    assert_equal(112, candidate.call([1, -2, -3, 0, 7, -8, -2]))\n    assert_equal(180, candidate.call([6, -3, -10, 0, 2]))\n    assert_equal(80, candidate.call([-2, -40, 0, -2, -3]))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]",
    "  max_so_far = 1\n  min_so_far = 1\n  max_ending_here = 1\n  arr.each do |num|\n    if num > 0\n      max_ending_here = max_ending_here * num\n      min_so_far = [min_so_far * num, 1].min\n    elsif num == 0\n      max_ending_here = 1\n      min_so_far = 1\n    else\n      temp = max_ending_here\n      max_ending_here = [min_so_far * num, 1].max\n      min_so_far = temp * num\n    end\n    if max_so_far < max_ending_here\n      max_so_far = max_ending_here\n    end\n  end\n  max_so_far\nend",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]\n  (1...arr.length).each do |i|\n    if arr[i] < 0\n      temp = max_product\n      max_product = [min_product * arr[i], arr[i]].max\n      min_product = [temp * arr[i], arr[i]].min\n    else\n      max_product = [max_product * arr[i], arr[i]].max\n      min_product = [min_product * arr[i], arr[i]].min\n    end\n    max_so_far = [max_so_far, max_product].max\n  end\n  max_so_far\nend",
    "  max_product = arr[0]\n  current_product = arr[0]\n  current_min = arr[0]\n  current_max = arr[0]\n  arr[1..-1].each do |num|\n    current_product = [current_product * num, num].max\n    current_max = [current_max * num, num].max\n    current_min = [current_min * num, num].min\n    max_product = [max_product, current_product].max\n  end\n  max_product\nend",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]",
    "  max_product = arr[0]\n  current_product = arr[0]\n  current_min = arr[0]\n  current_max = arr[0]",
    "  max_ending_here = 1\n  min_ending_here = 1\n  max_so_far = 1",
    "  return arr.max if arr.all? { |num| num < 0 }\n  return 0 if arr.all? { |num| num == 0 }",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]",
    "  max_so_far = 1\n  min_so_far = 1\n  max_ending_here = 1\n  arr.each do |num|\n    if num > 0\n      max_ending_here = max_ending_here * num\n      min_so_far = [min_so_far * num, 1].min\n    elsif num == 0\n      max_ending_here = 1\n      min_so_far = 1\n    else\n      temp = max_ending_here\n      max_ending_here = [min_so_far * num, 1].max\n      min_so_far = temp * num\n    end\n    if max_so_far < max_ending_here\n      max_so_far = max_ending_here\n    end\n  end\n  max_so_far\nend",
    "  max_product = arr[0]\n  min_product = arr[0]\n  result = arr[0]",
    "  max_product = arr[0]\n  min_product = arr[0]\n  result = arr[0]\n  for i in 1..arr.length-1\n    if arr[i] < 0\n      temp = max_product\n      max_product = [min_product * arr[i], arr[i]].max\n      min_product = [temp * arr[i], arr[i]].min\n    else\n      max_product = [max_product * arr[i], arr[i]].max\n      min_product = [min_product * arr[i], arr[i]].min\n    end\n    result = [result, max_product].max\n  end\n  result\nend",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]\n  arr.each_with_index do |num, i|\n    next if i == 0\n    temp_max = max_product\n    max_product = [num, max_product * num, min_product * num].max\n    min_product = [num, temp_max * num, min_product * num].min\n    max_so_far = [max_so_far, max_product].max\n  end\n  max_so_far\nend",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]\n  for i in 1...arr.length\n    if arr[i] < 0\n      temp = max_product\n      max_product = [min_product * arr[i], arr[i]].max\n      min_product = [temp * arr[i], arr[i]].min\n    else\n      max_product = [max_product * arr[i], arr[i]].max\n      min_product = [min_product * arr[i], arr[i]].min\n    end\n    max_so_far = [max_so_far, max_product].max\n  end\n  max_so_far\nend",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]",
    "  max_product = arr[0]\n  current_product = arr[0]\n  i = 1\n  while i < arr.length\n    current_product *= arr[i]\n    max_product = [max_product, current_product].max\n    current_product = 1 if current_product == 0\n    i += 1\n  end\n  max_product\nend",
    "  max_product = arr[0]\n  min_product = arr[0]\n  max_so_far = arr[0]"
  ]
}