{
  "name": "mbpp_407_rearrange_bigger",
  "language": "rb",
  "prompt": "# Write a function to create the next bigger number by rearranging the digits of a given number.\ndef rearrange_bigger(n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "reworded",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rearrange_bigger\n    candidate = method(:rearrange_bigger)\n    assert_equal(21, candidate.call(12))\n    assert_equal(false, candidate.call(10))\n    assert_equal(120, candidate.call(102))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "  # get the digits of the number\n  digits = n.to_s.split('')\n  # find the first digit that is smaller than the next digit\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i + 1]\n    i -= 1\n  end\n  # if there is no such digit, the number is already the biggest possible\n  return -1 if i == -1\n  # find the smallest digit that is bigger than the digit at i\n  j = digits.length - 1\n  while j >= 0 && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap the digits at i and j\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits after i\n  digits[i + 1..-1] = digits[i + 1..-1].reverse\n  # return the number\n  digits.join.to_i\nend",
    "  n_str = n.to_s\n  n_arr = n_str.split('')\n  n_arr_sorted = n_arr.sort\n  n_arr_sorted_rev = n_arr_sorted.reverse\n  n_arr_sorted_rev_join = n_arr_sorted_rev.join\n  n_arr_sorted_rev_join_to_i = n_arr_sorted_rev_join.to_i\n  if n_arr_sorted_rev_join_to_i == n\n    return -1\n  else\n    return n_arr_sorted_rev_join_to_i\n  end\nend",
    "  # get the digits of the number\n  digits = n.to_s.split('')\n  # find the first digit that is smaller than the one to its right\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i + 1]\n    i -= 1\n  end\n  # if no such digit exists, the number is the largest possible\n  return -1 if i < 0\n  # find the smallest digit to the right of the pivot that is larger than the pivot\n  j = digits.length - 1\n  while j >= 0 && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap the pivot with the smallest digit to its right that is larger than the pivot\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i + 1..-1] = digits[i + 1..-1].reverse\n  # return the number\n  digits.join.to_i\nend",
    "  # get the digits of the number\n  digits = n.to_s.split('').map(&:to_i)\n  # find the first digit that is smaller than the one to its right\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i+1]\n    i -= 1\n  end\n  # if no such digit exists, the number is the largest possible\n  return -1 if i < 0\n  # find the smallest digit to the right of the pivot that is larger than the pivot\n  j = digits.length - 1\n  while j >= 0 && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap the pivot with the smallest digit to its right\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i+1..-1] = digits[i+1..-1].reverse\n  # return the new number\n  digits.join.to_i\nend",
    "  digits = n.to_s.split('').map(&:to_i)\n  i = digits.length - 1\n  while i > 0 && digits[i - 1] >= digits[i]\n    i -= 1\n  end\n  return -1 if i == 0\n  j = digits.length - 1\n  while digits[j] <= digits[i - 1]\n    j -= 1\n  end\n  digits[i - 1], digits[j] = digits[j], digits[i - 1]\n  digits[i..-1] = digits[i..-1].reverse\n  digits.join.to_i\nend",
    "  return -1 if n.to_s.chars.uniq.size == 1\n  n = n.to_s.chars.sort.reverse.join.to_i\n  n.to_s.chars.permutation.map(&:join).map(&:to_i).sort.reverse.each { |i| return i if i > n }\nend",
    "  n_array = n.to_s.split('')\n  n_array.permutation.to_a.map { |x| x.join.to_i }.sort.reverse.each do |x|\n    return x if x > n\n  end\n  -1\nend",
    "  # get all permutations of the digits\n  perms = n.to_s.chars.permutation.map(&:join).map(&:to_i)\n  # return the first one that is bigger than the original number\n  perms.find { |perm| perm > n }\nend",
    "  n = n.to_s.split('').map(&:to_i)\n  (n.size - 2).downto(0) do |i|\n    if n[i] < n[i + 1]\n      n[i], n[i + 1] = n[i + 1], n[i]\n      return n.join.to_i\n    end\n  end\n  -1\nend",
    "  # get all permutations of the number\n  # select the permutations that are bigger than the original number\n  # return the smallest of those permutations\n  permutations = n.to_s.chars.permutation.to_a.map { |perm| perm.join.to_i }\n  permutations.select { |perm| perm > n }.min\nend",
    "  # convert to array of digits\n  digits = n.to_s.split('').map(&:to_i)\n  # find the first digit that is less than the digit to its right\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i+1]\n    i -= 1\n  end\n  # if no such digit exists, the number is already the largest possible\n  return -1 if i < 0\n  # find the smallest digit to the right of i that is greater than digits[i]\n  j = digits.length - 1\n  while j > i && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap digits[i] and digits[j]\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of i\n  digits[i+1..-1] = digits[i+1..-1].reverse\n  # convert to integer and return\n  digits.join.to_i\nend",
    "  # convert to array of digits\n  digits = n.to_s.split('').map(&:to_i)\n  # find the first digit that is smaller than the digit to its right\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i + 1]\n    i -= 1\n  end\n  # if no such digit exists, return -1\n  return -1 if i < 0\n  # find the smallest digit to the right of the pivot that is larger than the pivot\n  j = digits.length - 1\n  while j > i && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap the pivot with the smallest digit to the right of the pivot\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i + 1..-1] = digits[i + 1..-1].reverse\n  # convert back to integer\n  digits.join.to_i\nend",
    "  digits = n.to_s.split('').map(&:to_i)\n  (digits.size - 2).downto(0) do |i|\n    if digits[i] < digits[i + 1]\n      (i + 1...digits.size).each do |j|\n        if digits[i] < digits[j]\n          digits[i], digits[j] = digits[j], digits[i]\n          break\n        end\n      end\n      digits[i + 1..-1] = digits[i + 1..-1].sort\n      return digits.join.to_i\n    end\n  end\n  -1\nend",
    "  n_array = n.to_s.split('')\n  n_array.each_with_index do |num, index|\n    if n_array[index + 1] && n_array[index + 1].to_i > num.to_i\n      n_array[index], n_array[index + 1] = n_array[index + 1], n_array[index]\n      return n_array.join('').to_i\n    end\n  end\n  -1\nend",
    "  n_arr = n.to_s.split('')\n  n_arr.each_with_index do |num, i|\n    if n_arr[i+1] && num < n_arr[i+1]\n      n_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n      return n_arr.join('').to_i\n    end\n  end\n  -1\nend",
    "  # convert number to array of digits\n  digits = n.to_s.split('')\n  # find the first digit that is smaller than the digit to its right\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i+1]\n    i -= 1\n  end\n  # if no such digit exists, the number is already the largest possible\n  return -1 if i < 0\n  # find the smallest digit to the right of the pivot that is larger than the pivot\n  j = digits.length - 1\n  while j >= 0 && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap the pivot with the smallest digit to the right of the pivot\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i+1..-1] = digits[i+1..-1].reverse\n  # convert the array of digits back to a number\n  digits.join.to_i\nend",
    "  # convert to array of digits\n  digits = n.to_s.split('').map(&:to_i)\n  # find the first digit that is smaller than the digit to its right\n  i = 0\n  while i < digits.length - 1\n    if digits[i] < digits[i+1]\n      break\n    end\n    i += 1\n  end\n  # if no such digit exists, return -1\n  if i == digits.length - 1\n    return -1\n  end\n  # find the smallest digit to the right of the pivot that is larger than the pivot\n  j = i + 1\n  while j < digits.length\n    if digits[j] > digits[i]\n      break\n    end\n    j += 1\n  end\n  # swap the pivot with the smallest digit to its right\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i+1..-1] = digits[i+1..-1].reverse\n  # return the new number\n  digits.join.to_i\nend",
    "  n_arr = n.to_s.split('')\n  n_arr.each_with_index do |num, i|\n    if n_arr[i + 1] && n_arr[i + 1].to_i > num.to_i\n      n_arr[i], n_arr[i + 1] = n_arr[i + 1], n_arr[i]\n      return n_arr.join('').to_i\n    end\n  end\n  -1\nend",
    "  # convert to string\n  n = n.to_s\n  # find the first digit from the right that is smaller than the digit to its right\n  n.reverse.each_char.with_index do |c, i|\n    if c.to_i > n[-i-2].to_i\n      # swap the digits\n      n[-i-1], n[-i-2] = n[-i-2], n[-i-1]\n      # sort the digits to the right of the swapped digits in ascending order\n      n[-i..-1] = n[-i..-1].chars.sort.join\n      # convert to integer\n      return n.to_i\n    end\n  end\n  # if no such digit exists, return -1\n  -1\nend",
    "  return -1 if n.to_s.size == 1\n  digits = n.to_s.split('').map(&:to_i)\n  i = digits.size - 1\n  while i > 0 && digits[i - 1] >= digits[i]\n    i -= 1\n  end\n  return -1 if i <= 0\n  j = digits.size - 1\n  while digits[j] <= digits[i - 1]\n    j -= 1\n  end\n  digits[i - 1], digits[j] = digits[j], digits[i - 1]\n  digits[i..-1] = digits[i..-1].reverse\n  digits.join.to_i\nend"
  ]
}