{
  "name": "mbpp_247_lps",
  "language": "rb",
  "prompt": "# Write a function to find the length of the longest palindromic subsequence in the given string.\ndef lps(str)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "reworded",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_lps\n    candidate = method(:lps)\n    assert_equal(5, candidate.call(\"TENS FOR TENS\"))\n    assert_equal(7, candidate.call(\"CARDIO FOR CARDS\"))\n    assert_equal(9, candidate.call(\"PART OF THE JOURNEY IS PART\"))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "  return str.length if str == str.reverse\n  return lps(str[1..-1]) if str[0] == str[-1]\n  [lps(str[1..-1]), lps(str[0..-2])].max\nend",
    "  return str.length if str.length == 1\n  return 0 if str.length == 0\n  return 2 if str[0] == str[1] && str.length == 2\n  return 2 if str[0] == str[-1] && str.length == 2\n  return 3 if str[0] == str[-1] && str[1] == str[-2] && str.length == 3\n  return lps(str[1..-1]) if str[0] != str[-1]\n  return lps(str[1..-2]) if str[0] != str[-1]\n  return 2 + lps(str[1..-2])\nend",
    "  return str.length if str == str.reverse\n  return 1 if str.length == 1",
    "  return str.length if str == str.reverse\n  return lps(str[1..-1]) if str[0] == str[-1]\n  [lps(str[1..-1]), lps(str[0..-2])].max + 1\nend",
    "  return 0 if str.empty?\n  return 1 if str.length == 1\n  return 2 if str.length == 2 && str[0] == str[1]\n  return 2 if str.length == 2 && str[0] != str[1]",
    "  return str.length if str.length <= 1\n  return 2 if str[0] == str[1]",
    "  return str.length if str.length <= 1\n  return 2 if str.length == 2 && str[0] == str[1]\n  return 1 if str.length == 2 && str[0] != str[1]",
    "  return str.length if str.length <= 1\n  return 2 if str.length == 2 && str[0] == str[1]\n  return 1 if str.length == 2 && str[0] != str[1]",
    "  return 0 if str.empty?\n  return 1 if str.length == 1",
    "  return str.length if str.length <= 1\n  return 2 if str[0] == str[1]\n  return 1 if str[0] != str[1]\n  return 2 + lps(str[1..-2]) if str[0] == str[-1]\n  return [lps(str[1..-1]), lps(str[0..-2])].max\nend",
    "  return 0 if str.empty?\n  return 1 if str.length == 1\n  return 2 if str.length == 2 && str[0] == str[1]\n  return 2 if str.length == 2 && str[0] != str[1]",
    "  return str.length if str.length == 1\n  return 0 if str.length == 0\n  return 2 if str[0] == str[1] && str.length == 2\n  return 2 if str[0] == str[-1] && str.length == 2\n  return lps(str[1..-1]) if str[0] != str[-1]\n  return lps(str[1..-2]) + 2 if str[0] == str[-1]\nend",
    "  return str.length if str.length == 1\n  return 0 if str.length == 0",
    "  return str.length if str.length == 1\n  return 0 if str.length == 0\n  return 2 if str.length == 2 && str[0] == str[1]\n  return 1 if str.length == 2 && str[0] != str[1]\n  return lps(str[1..-1]) if str[0] != str[-1]\n  return 2 + lps(str[1..-2]) if str[0] == str[-1]\nend",
    "  return str.length if str == str.reverse\n  return 1 if str.length == 1\n  return lps(str[1..-1]) if str[0] == str[-1]\n  return [lps(str[1..-1]), lps(str[0..-2])].max\nend",
    "  return 0 if str.empty?\n  return 1 if str.length == 1",
    "  return str.length if str == str.reverse\n  return lps(str[1..-1]) if str[0] == str[-1]\n  [lps(str[1..-1]), lps(str[0..-2])].max\nend",
    "  return str.length if str.length <= 1\n  return 2 if str[0] == str[1]\n  return 1 if str[0] != str[1]\n  return 2 + lps(str[1..-2]) if str[0] == str[-1]\n  [lps(str[1..-1]), lps(str[0..-2])].max\nend",
    "  return str.length if str.length <= 1\n  return 2 if str[0] == str[1]\n  return 1 if str[0] != str[1]\n  return lps(str[1..-1]) if str[0] != str[-1]\n  return 2 + lps(str[1..-2]) if str[0] == str[-1]\nend",
    "  return str.length if str == str.reverse\n  return lps(str[1..-1]) if str[0] == str[-1]\n  [lps(str[1..-1]), lps(str[0..-2])].max\nend"
  ]
}