name: HumanEval_127_intersection
language: rb
prompt: "# You are given two intervals,\n# where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n# The given intervals are closed\
  \ which means that the interval (start, end)\n# includes both start and end.\n#\
  \ For each given interval, it is assumed that its start is less or equal its end.\n\
  # Your task is to determine whether the length of intersection of these two \n#\
  \ intervals is a prime number.\n# Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n# which its length is 1, which not a prime number.\n# If\
  \ the length of the intersection is a prime number, return \"YES\",\n# otherwise,\
  \ return \"NO\".\n# If the two intervals don't intersect, return \"NO\".\n# [input/output]\
  \ samples:\n# >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1,\
  \ 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\n\
  def intersection(interval1, interval2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n\
  \    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1,\
  \ 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"\
  YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2,\
  \ 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n\
  \    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\"\
  , candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2,\
  \ -2], [-3, -2]))\n  end\nend\n"
completions: ["    # Write your code here\nend", "  start = interval1[0] > interval2[0]\
    \ ? interval1[0] : interval2[0]\n  finish = interval1[1] < interval2[1] ? interval1[1]\
    \ : interval2[1]\n  if start <= finish\n    return is_prime(finish - start + 1)\
    \ ? \"YES\" : \"NO\"\n  else\n    return \"NO\"\n  end\nend", "  # Your code here\n\
    end", "  if interval1[0] > interval2[1] or interval2[0] > interval1[1]\n    return\
    \ \"NO\"\n  else\n    min_start = [interval1[0], interval2[0]].max\n    max_end\
    \ = [interval1[1], interval2[1]].min\n    diff = max_end - min_start\n    if diff\
    \ <= 0\n      return \"NO\"\n    else\n      if diff == 1\n        return \"YES\"\
    \n      else\n        return (2..diff-1).all? { |divisor| diff % divisor != 0\
    \ } ? \"YES\" : \"NO\"\n      end\n    end\n  end\nend", "  # This function will\
    \ get the start and end of both intervals\n  # and determine if their are in the\
    \ range of each other\n  intersection = [interval1[0], interval2[0]].max,\n  [interval1[1],\
    \ interval2[1]].min\n  (intersection[0] - intersection[1]).abs.prime? ? \"YES\"\
    \ : \"NO\"\nend", "  if interval1[0] < interval2[0]\n    interval1, interval2\
    \ = interval2, interval1\n  end\n  if interval1[0] > interval2[1]\n    return\
    \ \"NO\"\n  end\n  return prime?((interval1[0] - interval2[1]).abs + 1) ? \"YES\"\
    \ : \"NO\"\nend", "    interval = [interval1, interval2].sort_by { |i| i[0] }\n\
    \    if interval[0][1] > interval[1][0]\n        overlap = [interval[0][1], interval[1][1]].min\
    \ - [interval[0][0], interval[1][0]].max\n        return \"YES\" if overlap >\
    \ 0 && overlap.prime?\n    end\n    \"NO\"\nend", "  # your code here\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  finish >= start ? (start..finish).count.prime? ? \"YES\" : \"NO\" : \"NO\"\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if finish < start\n  (start..finish).length.prime? ? \"YES\"\
    \ : \"NO\"\nend", "    intersect_array = []\n    if interval1[0] <= interval2[0]\
    \ && interval1[1] >= interval2[0]\n        intersect_array << interval2[0]\n \
    \   elsif interval2[0] <= interval1[0] && interval2[1] >= interval1[0]\n     \
    \   intersect_array << interval1[0]\n    else\n        \"NO\"\n    end\n    if\
    \ interval1[0] <= interval2[1] && interval1[1] >= interval2[1]\n        intersect_array\
    \ << interval2[1]\n    elsif interval2[0] <= interval1[1] && interval2[1] >= interval1[1]\n\
    \        intersect_array << interval1[1]\n    else\n        \"NO\"\n    end\n\
    \    length = intersect_array[1] - intersect_array[0]\n    if length > 1\n   \
    \     # Check if length is prime\n        (2..length-1).each do |i|\n        \
    \    if length % i == 0\n                return \"NO\"\n            end\n    \
    \    end\n        return \"YES\"\n    else\n        return \"NO\"\n    end\nend",
  '  return "NO" if interval1[1] < interval2[0] || interval2[1] < interval1[0]', " \
    \   array_intervals = [interval1, interval2]\n    array_intervals.sort! { |x,\
    \ y| x[0] <=> y[0] }\n    intersection = (array_intervals[0][1] - array_intervals[1][0])\n\
    \    return \"NO\" if (intersection < 0)\n    primes = [2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n  \
    \  intersection_primes = primes.include?(intersection)\n    if (intersection_primes)\n\
    \        return \"YES\"\n    else\n        return \"NO\"\n    end\nend", "  if\
    \ (interval1[0] <= interval2[0] && interval2[0] <= interval1[1]) ||\n     (interval2[0]\
    \ <= interval1[0] && interval1[0] <= interval2[1])\n    range = [interval1[0],\
    \ interval1[1], interval2[0], interval2[1]].sort\n    interval = range[1] - range[0]\
    \ + 1\n    return \"YES\" if interval.prime?\n    return \"NO\"\n  else\n    return\
    \ \"NO\"\n  end\nend", "  \nend", "  intersect = []\n  interval1.each do |value|\n\
    \    intersect << value if interval2.include?(value)\n  end\n  intersect.length\
    \ == 0 ? \"NO\" : prime?(intersect.length) ? \"YES\" : \"NO\"\nend", "  ((interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a).length == 1 ? \"YES\" : \"NO\"\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  length = ending - start\n  return 'NO' if length < 0\n  if length.prime?\n\
    \    'YES'\n  else\n    'NO'\n  end\nend", "  is_intersect = intersect?(interval1,\
    \ interval2)\n  is_intersect ? is_prime(length_of_intersect(interval1, interval2))\
    \ : \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  fin = [interval1[1],\
    \ interval2[1]].min\n  return 'NO' if start > fin\n  (start..fin).count.prime?\
    \ ? 'YES' : 'NO'\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
