name: HumanEval_68_pluck
language: rb
prompt: "# \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
  \ plucked node should be the node with the smallest even value.\n# If multiple nodes\
  \ with the same smallest even value are found return the node that has smallest\
  \ index.\n# The plucked node should be returned in an array, [ smalest_value, its\
  \ index ],\n# If there are no even values or the given array is empty, return [].\n\
  # Example 1:\n# >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1,\
  \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
  \ smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>>\
  \ pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value,\
  \ but  there are two zeros,\n# so we will choose the first zero, which has the smallest\
  \ index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\n\
  def pluck(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
  \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
  \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
  \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n\
  \    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
  \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
  \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
completions: ["  arr.select(&:even?).sort.first(2)\nend", "  evens = arr.select(&:even?)\n\
    \  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend", "  unless arr.empty?\n\
    \    evens = arr.select { |n| n.even? }\n    evens.empty? ? [] : [evens.min, arr.index(evens.min)]\n\
    \  else\n    []\n  end\nend", "  even_arr = arr.select{|i| i % 2 == 0}.compact\n\
    \  return [] if even_arr.empty?\n  even_arr.sort!\n  [even_arr[0], arr.index(even_arr[0])]\n\
    end", "  hash = {}\n  arr.each_with_index do |x, i|\n    if x.even?\n      hash[x]\
    \ = i\n    end\n  end\n  if hash.empty?\n    []\n  else\n    min = hash.keys.min\n\
    \    [min, hash[min]]\n  end\nend", "  return [] if arr.empty?\n  arr.map.with_index\
    \ { |x, i| [x, i] if x.even? }.compact.min\nend", "  evs = arr.find_all { |e|\
    \ e.even? }\n  evs.size.zero? ? [] : [evs.min, arr.index(evs.min)]\nend", "  even_numbers\
    \ = arr.select(&:even?)\n  return [] if even_numbers.empty?\n  [even_numbers.min,\
    \ arr.index(even_numbers.min)]\nend", "  evens = arr.select { |num| num.even?\
    \ }\n  return [] if evens.empty?\n  min = evens.min\n  arr.index(min)\nend", " \
    \ arr.sort_by.with_index { |num, i| [num.even? ? 0 : 1, num, i] }.take(1).flatten\n\
    end", "  evens = arr.select { |num| num.even? }\n  evens.empty? ? [] : [evens.min,\
    \ arr.index(evens.min)]\nend", "  #arr.each_with_index { |val, idx| val.even?\
    \ ? return [val, idx] : next }\n  #arr.each_with_index { |val, idx| (val % 2 ==\
    \ 0) ? return [val, idx] : next }\n  arr.each_with_index { |val, idx| (val.even?)\
    \ ? return [val, idx] : next }\n  []\nend", "  return [] if arr.empty?\n  # find\
    \ the smallest even number\n  return [] if arr.index(arr.sort.reject { |num| num.odd?\
    \ }.first).nil?\n  # return index of first instance of smallest even number and\
    \ that number\n  [arr.sort.reject { |num| num.odd? }.first, arr.index(arr.sort.reject\
    \ { |num| num.odd? }.first)]\nend", "  evens = arr.find_all { |x| x.even? }\n\
    \  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\np pluck([4,\
    \ 2, 3]) == [2, 1]\np pluck([1, 2, 3]) == [2, 1]\np pluck([]) == []\np pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]", "  smallest_value = nil\n  smallest_index = nil\n\
    \  arr.each_with_index do |e, i|\n    if e.even?\n      if smallest_value.nil?\
    \ || e < smallest_value\n        smallest_value = e\n        smallest_index =\
    \ i\n      end\n    end\n  end\n  smallest_value.nil? ? [] : [smallest_value,\
    \ smallest_index]\nend", "    small_even = nil\n    small_even_index = nil\n \
    \   arr.each_with_index do |x, i|\n        if small_even == nil\n            if\
    \ x % 2 == 0\n                small_even = x\n                small_even_index\
    \ = i\n            end\n        else\n            if x % 2 == 0\n            \
    \    if x < small_even\n                    small_even = x\n                 \
    \   small_even_index = i\n                end\n            end\n        end\n\
    \    end\n    if small_even == nil\n        return []\n    else\n        return\
    \ [small_even, small_even_index]\n    end\nend\np pluck([4, 2, 3])\np pluck([1,\
    \ 2, 3])\np pluck([])\np pluck([5, 0, 3, 0, 4, 2])", "  evens = arr.select { |el|\
    \ el.even? }\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend", " \
    \ return [] if arr.empty?\n  arr.each_with_index.min_by { |el, _i| el.even? ?\
    \ el : 1.0 / 0 }\nend", "  arr.select { |a| a.even? }.min\nend", "  arr.select\
    \ { |x| x.even? }.min\nend", "  even_numbers = arr.select { |num| num.even? }\n\
    \  return [] if even_numbers.empty?\n  smallest_even_number = even_numbers.min\n\
    \  index = arr.index(smallest_even_number)\n  [smallest_even_number, index]\n\
    end", "  res = [1000, -1]\n  arr.each_with_index do |item, index|\n    if item\
    \ % 2 == 0 && item < res[0]\n      res = [item, index]\n    end\n  end\n  if res[0]\
    \ == 1000\n    return []\n  else\n    return res\n  end\nend", "  even_arr = arr.select{|num|\
    \ num % 2 == 0}.sort\n  index = arr.index(even_arr.first)\n  res = [even_arr.first,\
    \ index]\n  res.any? {|e| e.nil?} ? [] : res\nend", "  plucked = arr.compact.select(&:even?).min\n\
    \  idx = arr.index(plucked)\n  return [] if plucked.nil?\n  [plucked, idx]\nend",
  "  # Write your solution here\nend", "  evens = arr.select { |x| x.even? }\n  evens.sort.take(1)\n\
    end", "  # write your code here\n  index = 0\n  smallest_even = nil\n  arr.each_with_index\
    \ do |value, index|\n    if smallest_even.nil? && value.even?\n      smallest_even\
    \ = value\n    elsif smallest_even.nil? && !value.even?\n      smallest_even =\
    \ nil\n    elsif value.even? && value < smallest_even\n      smallest_even = value\n\
    \    end\n  end\n  smallest_even.nil? ? [] : [smallest_even, arr.index(smallest_even)]\n\
    end", "  smallest_node = arr.sort.find { |n| n.even? }\n  smallest_node.nil? ?\
    \ [] : [smallest_node, arr.index(smallest_node)]\nend", "  evens = arr.select\
    \ { |e| e.even? }\n  return [] if evens.empty?\n  smallest = evens.min\n  [smallest,\
    \ arr.index(smallest)]\nend", "  evens = arr.select(&:even?)\n  evens.each_with_index\
    \ do |num, index|\n    return [num, index] if evens.index(num) == index\n  end\n\
    \  []\nend", "  arr.each_with_index do |x, y|\n    if x % 2 == 0\n      return\
    \ [x, y]\n    end\n  end\n  return []\nend\nputs \"Problem 1: \"\np pluck([1,\
    \ 3, 2, 5, 4]) == [2, 2]\np pluck([1, 2, 3]) == [2, 1]\np pluck([]) == []\np pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\np pluck([4, 2, 3]) == [2, 1]\np pluck([1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10]) == [2, 1]\np pluck([0, -2, 4, -6, 8, -10]) == [-2, 1]\n\
    p pluck([0, 0, -2, 4, -6, 8, -10]) == [0, 0]\np pluck([0, 0, -2, 4, -6, 8, -10,\
    \ -12]) == [0, 0]\np pluck([0, 0, -2, 4, -6, 8, -10, -12, 6]) == [0, 0]\nputs\
    \ \"-\" * 20", "  arr.each_with_index.min_by { |x, i| x % 2 } || []\nend", " \
    \ return [] if arr.empty?\n  evens = arr.select { |val| val.even? }\n  min_even\
    \ = evens.min\n  idx = arr.index(min_even)\n  [min_even, idx]\nend", '  return
    [] if arr.empty?', "  even_val_index = arr.each_with_index.select { |x, _| x %\
    \ 2 == 0 }.map(&:last)\n  even_val_index.empty? ? [] : [arr[even_val_index.first],\
    \ even_val_index.first]\nend", "  arr.map.with_index { |v, i| [v, i] if v.even?\
    \ }.compact.min_by(&:first)\nend", "    return [] if arr.empty?\n    min = min_even(arr)\n\
    \    return [] if min.nil?\n    [min, arr.index(min)]\nend", "  return [] if arr.empty?\n\
    \  evens = arr.select { |e| e.even? }\n  return [] if evens.empty?\n  min = evens.min\n\
    \  [min, arr.index(min)]\nend", "  arr.each_with_index do |v, i|\n    return [v,\
    \ i] if v.even?\n  end\n  []\nend", "  smallest_even = arr.find_all{|num| num\
    \ % 2 == 0}.min\n  ind = arr.index(smallest_even)\n  [smallest_even, ind]\nend",
  "  return [] if arr.empty?\n  min_even = arr.select(&:even?).min\n  min_even ? [min_even,\
    \ arr.index(min_even)] : []\nend", "  even_arr = arr.select { |element| element.even?\
    \ }\n  return [] if even_arr.empty?\n  even_index = arr.index(even_arr.min)\n\
    \  [even_arr.min, even_index]\nend", "  smallest_even = nil\n  idx = nil\n  arr.each_with_index\
    \ do |item, index|\n    if smallest_even && smallest_even.even? && item == smallest_even\n\
    \      next\n    elsif smallest_even && smallest_even.even? && item < smallest_even\n\
    \      smallest_even = item\n      idx = index\n    elsif smallest_even && item\
    \ < smallest_even\n      next\n    elsif item.even?\n      smallest_even = item\n\
    \      idx = index\n    end\n  end\n  smallest_even.nil? ? [] : [smallest_even,\
    \ idx]\nend", '  return [] if arr.empty?', "  evens = arr.select(&:even?)\n  evens.sort![0]\
    \ && [evens[0], arr.index(evens[0])]\nend", "  return [] if arr.empty?\n  evens\
    \ = arr.select { |x| x.even? }\n  evens.min.nil? ? [] : [evens.min, arr.index(evens.min)]\n\
    end", "  even_arr = arr.select{|num| num.even?}\n  even_arr.length > 0 ? [even_arr.min,\
    \ arr.index(even_arr.min)] : []\nend", "  arr.each_with_index do |x, i|\n    return\
    \ [x, i] if x.even?\n  end\n  []\nend", "  min = arr.find_all{|x| x.even?}\n \
    \ return [] if min.empty?\n  arr.index(min.min) ? [min.min, arr.index(min.min)]\
    \ : [min.min, arr.rindex(min.min)]\nend", "  smallest_even_val = nil\n  smallest_even_idx\
    \ = nil\n  arr.each_with_index do |el, idx|\n    next if el.odd?\n    if smallest_even_val.nil?\
    \ || el < smallest_even_val\n      smallest_even_val = el\n      smallest_even_idx\
    \ = idx\n    end\n  end\n  smallest_even_val.nil? ? [] : [smallest_even_val, smallest_even_idx]\n\
    end", "  return [] if arr.empty?\n  return arr if arr.all? { |e| e.odd? }\n  arr.select\
    \ { |e| e.even? }.min\nend", "  results = []\n  evens = arr.select{|num| num.even?}\n\
    \  if !evens.empty?\n    evens.sort!\n    results << evens[0]\n    results <<\
    \ arr.index(evens[0])\n  end\n  return results\nend", "  min_even = arr.min {\
    \ |x, y| [x, y].min.even? ? x <=> y : y <=> x }\n  return [] if arr.empty? ||\
    \ !min_even.even?\n  [min_even, arr.index(min_even)]\nend", "  evens = arr.select\
    \ { |n| n.even? }\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend",
  "    evens = arr.select { |val| val.even? }\n    if evens.length == 0\n        return\
    \ []\n    end\n    return [evens.min, arr.index(evens.min)]\nend", "  even_values\
    \ = arr.select { |x| x.even? }\n  return [] if even_values.empty?\n  even_values.min\
    \ > even_values.max ? [even_values.max, arr.index(even_values.max)] : [even_values.min,\
    \ arr.index(even_values.min)]\nend", "  evens = arr.select { |item| item.even?\
    \ }\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend", "  arr.each_with_index.min_by\
    \ { |el, idx| el.even? ? el : arr.max + 1 } || []\nend", "  arr.select(&:even?).min\n\
    end", "  return [] if arr.empty?\n  even_arr = arr.select { |e| e.even? }\n  return\
    \ [] if even_arr.empty?\n  even_arr.min\n  index = arr.index(even_arr.min)\n \
    \ answer = [even_arr.min, index]\nend", "  arr.each_with_index do |x,i|\n    if\
    \ x.even?\n      return [x,i]\n    end\n  end\n  []\nend", "  smallest_value =\
    \ arr.select { |value| value.even? }.min\n  smallest_index = arr.index(smallest_value)\n\
    \  smallest_value && smallest_index ? [smallest_value, smallest_index] : []\n\
    end", "  arr.each_with_index.min_by{|n, i| n.even? ? n : n.max }\nend", "  smallest_even\
    \ = arr.select { |i| i.even? }.min\n  return [] if smallest_even.nil?\n  [smallest_even,\
    \ arr.index(smallest_even)]\nend", "  min_even = arr.select { |x| x.even? }.min\n\
    \  min_even.nil? ? [] : [min_even, arr.index(min_even)]\nend", '  return [] if
    arr.empty?', "  arr.each_with_index.select{|a,i| (a.even? && a == arr.min)}.flatten.values_at(0,2)\n\
    end", "  arr.each_with_index.select { |x, _y| x.even? }.min_by { |_x, y| y } ||\
    \ []\nend", "  return [] if arr.empty?\n  min_even = nil\n  min_even_index = nil\n\
    \  arr.each_with_index do |val, i|\n    next if val.odd?\n    if min_even.nil?\
    \ || val < min_even\n      min_even = val\n      min_even_index = i\n    end\n\
    \  end\n  return [] if min_even.nil?\n  [min_even, min_even_index]\nend", "  return\
    \ [] if arr.length < 1\n  arr.delete_if { |e| e.odd? }\n  return [] if arr.length\
    \ < 1\n  [arr.min, arr.index(arr.min)]\nend", "  even_and_sorted = arr.sort.select\
    \ { |num| num.even? }\n  return [] if even_and_sorted.size == 0\n  even_and_sorted.first\n\
    end", "  if arr.empty?\n    []\n  else\n    index = arr.index(arr.select(&:even?).min)\n\
    \    [arr[index], index]\n  end\nend\np pluck([4, 2, 3])", "  even_numbers = arr.select(&:even?)\n\
    \  return [] if even_numbers.empty?\n  even_numbers.map.with_index do |num, index|\n\
    \    return [num, index] if num == even_numbers.min\n  end\nend", "  evens = arr.select\
    \ { |n| n.even? }\n  return [] if evens.empty?\n  evens.min < evens.size ? [evens.min,\
    \ evens.index(evens.min)] : [evens.min, evens.size]\nend", "  p arr.select { |i|\
    \ i.even? }.first(2)\nend", "  # Write your code here\nend", "  min = 1.0 / 0\n\
    \  min_i = nil\n  arr.each_with_index do |v, i|\n    if v < min && v.even?\n \
    \     min = v\n      min_i = i\n    end\n  end\n  min_i ? [min, min_i] : []\n\
    end", "  min = []\n  min = arr.each_with_index.select{|x,i| x.even?}.min_by{|x,i|\
    \ x}\n  if arr.include?(0)\n    min = arr.each_with_index.select{|x,i| x == 0}.min_by{|x,i|\
    \ i}\n  end\n  arr.empty? ? [] : min\nend", "  even_array = arr.select{|i| i %\
    \ 2 == 0}\n  even_array.empty? ? [] : [even_array.min, arr.index(even_array.min)]\n\
    end", "  # your code here\nend", "  evs = arr.select(&:even?)\n  evs.size.zero?\
    \ ? [] : [evs.min, arr.index(evs.min)]\nend", "  return [] if arr.empty?\n  n\
    \ = arr.size\n  arr.each_with_index do |x, i|\n    return [x, i] if x.even?\n\
    \  end\n  return []\nend", "  plucked = arr.map.with_index { |value, index| value.even?\
    \ ? [value, index] : nil }.compact.min { |a, b| a[0] <=> b[0] }\n  plucked ? plucked\
    \ : []\nend", "  return [] if arr.empty?\n  even_numbers = arr.select { |num|\
    \ num.even? }\n  return [] if even_numbers.empty?\n  even_numbers.min == even_numbers.max\
    \ ? [even_numbers.min, arr.index(even_numbers.min)] : [even_numbers.min, arr.index(even_numbers.min)]\n\
    end", "  arr.each_with_index do |e, i|\n    return [e, i] if e.even?\n  end\n\
    \  []\nend", "  arr.select(&:even?).min(2).first(2)\nend", "  (1..10001).each\
    \ do |i|\n    return [i, arr.index(i)] if arr.include?(i) && i.even?\n  end\n\
    \  []\nend", "  arr.select{|el| el % 2 == 0}.sort.take(1).zip([arr.index(arr.select{|el|\
    \ el % 2 == 0}.sort.take(1)[0])])[0]\nend", "  return [] if arr.empty?\n  evens\
    \ = arr.select { |i| i.even? }\n  # lowest_value = evens.min\n  return [] if evens.empty?\n\
    \  lowest_value = evens.min\n  index = arr.index(lowest_value)\n  [lowest_value,\
    \ index]\nend", "  return [] if arr.nil? || arr.empty?\n  min = arr.min_by(&:even?)\n\
    \  return [] if min.nil?\n  [min, arr.index(min)]\nend", "  return [] if arr.nil?\
    \ || arr.empty?\n  even_nums = arr.select(&:even?)\n  even_nums.empty? ? [] :\
    \ [even_nums.min, arr.index(even_nums.min)]\nend", "  arr.map.with_index { |v,\
    \ i| [v, i] if v.even? }.compact.min_by(&:first)\nend", "  if arr.empty?\n   \
    \ []\n  else\n    evens = arr.select(&:even?)\n    return [] if evens.empty?\n\
    \    [evens.min, arr.index(evens.min)]\n  end\nend", "  arr.each_with_index.select{|x,\
    \ i| x.even?}.min_by(&:first)\nend", "  plucked = []\n  arr.each_with_index do\
    \ |el, i|\n    if el.even?\n      plucked << [el, i]\n    end\n  end\n  return\
    \ [] if plucked.length == 0\n  plucked.sort[0]\nend", "  # your code here\nend",
  "  # your code here\nend", "  evens = arr.select(&:even?)\n  return [] if evens.empty?\n\
    \  first_even = evens.min\n  [first_even, arr.index(first_even)]\nend", "  evens\
    \ = arr.select(&:even?)\n  return [] if evens.empty?\n  smallest_value = evens.min\n\
    \  smallest_index = arr.index(smallest_value)\n  [smallest_value, smallest_index]\n\
    end", "  a = arr.select{|e| e.even?}\n  if a.empty?\n    return []\n  else\n \
    \   return [a.min, arr.index(a.min)]\n  end\nend", "  arr.select(&:even?).minmax\n\
    end", '  return [] if arr.empty?', "  if arr.empty?\n    return []\n  else\n \
    \   evens = arr.select { |x| x.even? }\n    return [0, 0] if evens.empty?\n  \
    \  smallest_even = evens.min\n    i = arr.index(smallest_even)\n    return [smallest_even,\
    \ i]\n  end\nend", "  filtered = arr.select { |i| i.even? }\n  if filtered.empty?\n\
    \    []\n  else\n    small = filtered.min\n    [small, arr.index(small)]\n  end\n\
    end", "  evens = arr.select(&:even?)\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\n\
    end", "  evens = arr.select(&:even?)\n  return [] if evens.empty?\n  [evens.min,\
    \ arr.index(evens.min)]\nend", "  ans = []\n  unless arr.empty?\n    even_arr\
    \ = arr.select{|x| x.even?}\n    min_even = even_arr.min\n    min_even_index =\
    \ arr.index(min_even)\n    ans = [min_even, min_even_index]\n  end\n  ans\nend",
  "  return [] if arr.empty?\n  evens = arr.select { |e| e.even? }\n  smallest_even\
    \ = evens.min\n  return [] if smallest_even.nil?\n  smallest_even_index = arr.index(smallest_even)\n\
    \  [smallest_even, smallest_even_index]\nend", "  if arr.empty?\n    return []\n\
    \  else\n    arr_2 = arr.select { |i| i.even? }\n    if arr_2.empty?\n      return\
    \ []\n    else\n      value = arr_2.min\n      index = arr.index(value)\n    \
    \  arr_3 = [value, index]\n      return arr_3\n    end\n  end\nend", "  even_nums\
    \ = arr.select { |num| num.even? }\n  return [] if even_nums.empty?\n  even_nums.min\n\
    \  arr.find_index(even_nums.min)\nend", "  # write your code here\n  count = 0\n\
    \  index = 0\n  even = []\n  while count < arr.length\n    even << arr[count]\
    \ if arr[count].even?\n    count += 1\n  end\n  even.min.nil? ? [] : [even.min,\
    \ arr.index(even.min)]\nend", "  smallest_even_value = arr.find_all { |x| x.even?\
    \ }.min\n  arr.find_index(smallest_even_value) ? [smallest_even_value, arr.find_index(smallest_even_value)]\
    \ : []\nend", "  arr.map.with_index { |n, i| n.even? ? [n, i] : nil }.compact.min\n\
    end", "  @plucked = []\n  return @plucked if arr.empty?\n  # pluck_helper(arr)\n\
    \  pluck_rec(arr)\n  @plucked[0]\nend", "  arr.select { |n| n.even? }.min || []\n\
    end", "  return [] if arr.empty?\n  # your code here\nend\np pluck([4, 2, 3])",
  "  even_values = []\n  smallest_index = []\n  arr.each_with_index do |element, index|\n\
    \    even_values << element if element.even?\n    smallest_index << index if element.even?\n\
    \  end\n  return [] if even_values.empty?\n  smallest_value = even_values.min\n\
    \  smallest_value_index = smallest_index[even_values.index(smallest_value)]\n\
    \  [smallest_value, smallest_value_index]\nend", "  return [] if arr.empty?\n\
    \  arr.map.with_index{|x, i| [x, i]}.select{|x| x[0].even?}.min_by{|x| x[0]}\n\
    end", "  # your code goes here\nend", "  arr.select(&:even?).min_by(&:itself)\n\
    end", "  arr.select(&:even?).sort[0] ? [arr.index(arr.select(&:even?).sort[0]),\
    \ arr.select(&:even?).sort[0]] : []\nend", "  evens = arr.select { |e| e.even?\
    \ }\n  return [] if evens.empty?\n  evens.each_with_index.min_by { |e, i| [e,\
    \ i] }\nend", "\tr = []\n\tn = arr.find_index{|e| e.even?}\n\tn ? r = [arr[n],\
    \ n] : r = []\n\treturn r\nend", "  even_arr = arr.select{|n| n.even?}\n  return\
    \ [] if even_arr.empty?\n  min_even = even_arr.min\n  arr.index(min_even)\nend",
  "  results = []\n  arr.each_with_index do |number, index|\n    results << [number,\
    \ index] if number.even?\n  end\n  results.sort[0]\nend", "  arr.select { |node|\
    \ node.even? }.sort_by(&:itself).first(2)\nend", "  arr.index(arr.select { |x|\
    \ x.even? }.min) ? [arr.select { |x| x.even? }.min, arr.index(arr.select { |x|\
    \ x.even? }.min)] : []\nend", "  # edge case\n  return [] if arr.empty?", "  arr.select(&:even?).minmax\n\
    end", "  # YOUR CODE HERE\nend", "  new_arr = []\n  arr.each_with_index do |el,\
    \ i|\n    new_arr << [el, i] if el.even?\n  end\n  new_arr.min_by(&:first)\nend",
  "  answer = []\n  if arr.any? { |item| item % 2 == 0 }\n    arr.each_with_index\
    \ do |item, index|\n      if item % 2 == 0\n        answer.push(item, index)\n\
    \        break\n      end\n    end\n  end\n  answer\nend", "  even_items = arr.select\
    \ { |x| x.even? }.sort\n  return [] if even_items.empty?\n  even_item = even_items.first\n\
    \  index = arr.index(even_item)\n  [even_item, index]\nend", "  evens = arr.select\
    \ { |x| x.even? }.sort\n  evens.empty? ? [] : [evens.first, arr.index(evens.first)]\n\
    end", "  even_arr = arr.select{|val| val.even?}\n  if even_arr.empty?\n    []\n\
    \  else\n    even_arr.sort!\n    arr.map.with_index{|val, i| return [val, i] if\
    \ val == even_arr[0]}\n  end\nend", "  evens = arr.select(&:even?)\n  evens.empty?\
    \ ? [] : [evens.min, arr.index(evens.min)]\nend", "  arr.select(&:even?).min\n\
    end", "  evens = arr.select { |i| i.even? }\n  evens.empty? ? [] : [evens.min,\
    \ arr.index(evens.min)]\nend", "  arr.find_index { |i| i.even? }.nil? ? [] : [arr.min.even?\
    \ ? arr.min : arr.sort.find { |i| i.even? }, arr.find_index { |i| i.even? }]\n\
    end", "  arr.select(&:even?).min(2).shift\nend", "  return [] if arr.empty?\n\
    \  min = arr.min\n  arr[arr.index(min)..-1].any? { |i| i.even? } ? [min, arr.index(min)]\
    \ : []\nend", "  min = 10000\n  min_index = 0\n  arr.each_with_index do |x, i|\n\
    \    if x % 2 == 0\n      if x < min\n        min = x\n        min_index = i\n\
    \      end\n    end\n  end\n  if min == 10000\n    return []\n  else\n    return\
    \ [min, min_index]\n  end\nend", "  ans = []\n  evens = arr.select { |x| x.even?\
    \ }\n  if evens.empty?\n    return ans\n  else\n    evens.min\n    evens.each_with_index\
    \ do |value, index|\n      if value == evens.min\n        ans << value\n     \
    \   ans << index\n        return ans\n      end\n    end\n  end\nend", "  return\
    \ [] if arr.empty?\n  arr.each_with_index do |n,i|\n    return [n,i] if n.even?\n\
    \  end\n  []\nend", "  if arr.empty?\n    []\n  else\n    arr.select { |element|\
    \ element.even? }.sort.uniq.first(2)\n  end\nend", "  arr.select{|x| x.even?}.min\n\
    end\np pluck([4, 2, 3]) == [2, 1]\np pluck([1, 2, 3]) == [2, 1]\np pluck([]) ==\
    \ []\np pluck([5, 0, 3, 0, 4, 2]) == [0, 1]", "  min = 0\n  count = 0\n  idx =\
    \ 0\n  index = 0\n  arr.each do |ele|\n    if ele.even? && ele < min\n      min\
    \ = ele\n      idx = index\n    end\n    index += 1\n  end\n  arr.each do |ele|\n\
    \    if ele.even?\n      count += 1\n    end\n  end\n  if count == 0\n    []\n\
    \  else\n    [min, idx]\n  end\nend", "  i = 0\n  min = arr[0]\n  best_idx = 0\n\
    \  while i < arr.length\n    if arr[i] % 2 == 0 && (min == nil || arr[i] < min)\n\
    \      min = arr[i]\n      best_idx = i\n    end\n    i += 1\n  end\n  if min\
    \ == nil\n    return []\n  else\n    return [min, best_idx]\n  end\nend", "  if\
    \ arr.empty?\n    return []\n  else\n    even_values = arr.map.with_index do |value,\
    \ index|\n      if value.even?\n        value\n      end\n    end.compact\n  \
    \  even_values.empty? ? [] : [even_values.min, arr.index(even_values.min)]\n \
    \ end\nend", "  #\n  # your code here\n  #\nend", "  evens = arr.select { |e|\
    \ e.even? }\n  evens.min ? [evens.min, arr.index(evens.min)] : []\nend", "  arr.select(&:even?).min_by.with_index\
    \ { |v, i| [v, i] }\nend", "  index = 0\n  small = 10000\n  if arr.empty?\n  \
    \  return []\n  else\n    i = 0\n    while i < arr.length\n      if arr[i] !=\
    \ 0 && arr[i] % 2 == 0 && arr[i] < small\n        small = arr[i]\n        index\
    \ = i\n      end\n      i += 1\n    end\n    return [small, index]\n  end\nend",
  "  arr.each_with_index do |e, i|\n    return [e, i] if e.even?\n  end\n  []\nend",
  "  #\n  # your code here\n  #\nend", "  arr.delete_if { |e| e.odd? }.min(2)\nend",
  "  evens = arr.select { |num| num.even? }\n  return [] if evens.empty?\n  smallest_even\
    \ = evens.min\n  [smallest_even, arr.index(smallest_even)]\nend", "  evens = arr.select(&:even?)\n\
    \  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend", "  #\
    \ your code here\nend", "  evens = arr.select { |e| e.even? }\n  evens.first.nil?\
    \ ? [] : [evens.first, arr.index(evens.first)]\nend", "  arr = arr.drop_while\
    \ { |x| x.odd? }\n  return [] if arr.size == 0\n  even_min = arr.min\n  index\
    \ = arr.index(even_min)\n  arr_min = [even_min, index]\nend", "  smallest_even\
    \ = arr.min(&:even?)\n  index = arr.index(smallest_even)\n  index ? [smallest_even,\
    \ index] : []\nend", "  arr.each_with_index do |val, index|\n    return [val,\
    \ index] if val.even?\n  end\n  []\nend", "  evens = arr.select { |num| num.even?\
    \ }\n  evens.min.nil? ? [] : [evens.min, arr.index(evens.min)]\nend", "  even_numbers\
    \ = arr.select { |num| num.even? }\n  even_numbers.length > 0 ? [even_numbers.min,\
    \ arr.index(even_numbers.min)] : []\nend", "    arr.select(&:even?).min\nend",
  "  min_even = nil\n  min_even_index = -1\n  arr.each_with_index do |el, index|\n\
    \    min_even = el if min_even.nil? && el.even?\n    if el.even? && el < min_even\n\
    \      min_even = el\n      min_even_index = index\n    end\n  end\n  return []\
    \ if min_even.nil?\n  [min_even, min_even_index]\nend", "  val = arr.select {\
    \ |e| e.even? }.min\n  [val, arr.index(val)]\nend", "  evens = arr.select { |n|\
    \ n.even? }\n  min = evens.min\n  return [] if min.nil?\n  evens.each_with_index\
    \ { |e, i| return [e, i] if e == min }\nend", "  smallest_value, smallest_index\
    \ = nil\n  arr.each_with_index do |value, index|\n    if value.even?\n      if\
    \ smallest_value.nil? || value < smallest_value\n        smallest_value = value\n\
    \        smallest_index = index\n      end\n    end\n  end\n  [smallest_value,\
    \ smallest_index]\nend", "  arr.each_with_index do |v, i|\n    return [v, i] if\
    \ v.even?\n  end\n  []\nend", "  evens = arr.select { |e| e.even? }\n  evens.length\
    \ == 0 ? [] : [evens.min, arr.index(evens.min)]\nend", "  smallest_even_value\
    \ = nil\n  smallest_even_value_index = nil\n  arr.each_with_index do |value, index|\n\
    \    if value % 2 == 0\n      if smallest_even_value.nil? || value < smallest_even_value\n\
    \        smallest_even_value = value\n        smallest_even_value_index = index\n\
    \      end\n    end\n  end\n  smallest_even_value_index.nil? ? [] : [smallest_even_value,\
    \ smallest_even_value_index]\nend", "  arr.select(&:even?).min\nend", "    return\
    \ [] if arr.nil? || arr.empty?\n    min_even = arr.find { |n| n.even? }\n    return\
    \ [] if min_even.nil?\n    evens = arr.select { |n| n.even? }\n    [evens.min,\
    \ arr.index(evens.min)]\nend", "  return [] if arr.empty?\n  even_numbers = arr.select\
    \ { |x| x.even? }\n  even_numbers.empty? ? [] : [even_numbers.min, arr.index(even_numbers.min)]\n\
    end", "  evens = arr.select { |n| n.even? }\n  evens.empty? ? [] : [evens.min,\
    \ arr.index(evens.min)]\nend", "  arr.select(&:even?).min&.then { |i| [i, arr.index(i)]\
    \ } || []\nend", "  even_nums = arr.select(&:even?)\n  return [] if even_nums.empty?\n\
    \  even_nums.min == even_nums.max ? [even_nums.min, arr.index(even_nums.min)]\
    \ : [even_nums.min, arr.index(even_nums.min)]\nend", "  arr.each_with_index do\
    \ |e, i|\n    return [e, i] if e.even?\n  end\n  []\nend", "  even_arr = arr.select\
    \ { |x| x.even? }\n  even_arr.empty? ? [] : [ even_arr.min, arr.index(even_arr.min)\
    \ ]\nend", "  arr.each_with_index.min { |(x, _), (y, _)| x.even? && y.even? ?\
    \ x <=> y : (x % 2) <=> (y % 2) }\nend", "  arr.map.with_index { |x, i| x.even?\
    \ ? [x, i] : nil }.compact.min_by(&:first) || []\nend", "  return [] if arr.empty?\n\
    \  even_numbers = arr.select { |num| num.even? }\n  return [] if even_numbers.empty?\n\
    \  [even_numbers.min, arr.index(even_numbers.min)]\nend", "  arr.sort.keep_if(&:even?).first(2)\n\
    end\np pluck([4, 2, 3]) # [2, 1]\np pluck([1, 2, 3]) # [2, 1]\np pluck([]) # []\n\
    p pluck([5, 0, 3, 0, 4, 2]) # [0, 1]", "  arr.select(&:even?).min\nend", "  arr.index(arr.select\
    \ { |e| e.even? }.sort.first) ? [arr.select { |e| e.even? }.sort.first, arr.index(arr.select\
    \ { |e| e.even? }.sort.first)] : []\nend", "  evens = arr.find_all(&:even?)\n\
    \  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend", "  arr.each_with_index.select\
    \ { |item, _| item.even? }.min\nend", "    evens = arr.select { |num| num.even?\
    \ }\n    if evens.any?\n        evens.map.with_index { |num, i| [num, i] }.sort_by\
    \ { |num, i| [num, i] }.first\n    else\n        []\n    end\nend", "\tminimum\
    \ = nil\n\tindex = nil\n\tarr.each_with_index do |a, i|\n\t\tif (minimum == nil)\n\
    \t\t\tif a.even?\n\t\t\t\tminimum = a\n\t\t\t\tindex = i\n\t\t\tend\n\t\telsif\
    \ a.even? && a < minimum\n\t\t\tminimum = a\n\t\t\tindex = i\n\t\tend\n\tend\n\
    \tif (minimum == nil)\n\t\treturn []\n\telse\n\t\treturn [minimum, index]\n\t\
    end\nend", "  # CODE HERE\nend", "  arr.each_with_index do |n, i|\n    return\
    \ [n, i] if n.even?\n  end\n  []\nend", "  filtered = arr.select { |n| n.even?\
    \ }\n  return [] if filtered.empty?\n  filtered.uniq.min < 2 ? [2, arr.index(2)]\
    \ : [filtered.min, arr.index(filtered.min)]\nend", "  return [] if arr.empty?\n\
    \  p arr.select { |x| x.even? }.min\n  p arr.find_index(arr.select { |x| x.even?\
    \ }.min)\n  arr.select { |x| x.even? }.min\nend", "    return [] if arr.empty?\n\
    \    smallest_value = 10_000\n    smallest_index = 10_000\n    arr.each_with_index\
    \ do |x, index|\n        if x.even? && x < smallest_value\n            smallest_value\
    \ = x\n            smallest_index = index\n        end\n    end\n    if smallest_value\
    \ == 10_000\n        return []\n    else\n        return [smallest_value, smallest_index]\n\
    \    end\nend", "  return [] if arr.empty?\n  evens = arr.select(&:even?)\n  return\
    \ [] if evens.empty?\n  smallest_even = evens.min\n  smallest_even_index = arr.index(smallest_even)\n\
    \  [smallest_even, smallest_even_index]\nend", "  smallest_even_value_index =\
    \ nil\n  smallest_even_value = nil\n  arr.each_with_index do |value, index|\n\
    \    if value.even?\n      if smallest_even_value.nil? || smallest_even_value\
    \ > value\n        smallest_even_value = value\n        smallest_even_value_index\
    \ = index\n      end\n    end\n  end\n  return [] if smallest_even_value.nil?\n\
    \  [smallest_even_value, smallest_even_value_index]\nend", "  arr.each_with_index.min_by{|x,\
    \ i| (x.even? && x) || Float::INFINITY} || []\nend", "  min = arr.min\n  res =\
    \ arr.index(min)\n  [min, res]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
