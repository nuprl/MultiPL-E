name: HumanEval_68_pluck
language: rb
prompt: "# \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
  \ plucked node should be the node with the smallest even value.\n# If multiple nodes\
  \ with the same smallest even value are found return the node that has smallest\
  \ index.\n# The plucked node should be returned in an array, [ smalest_value, its\
  \ index ],\n# If there are no even values or the given array is empty, return [].\n\
  # Example 1:\n# >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1,\
  \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
  \ smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>>\
  \ pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value,\
  \ but  there are two zeros,\n# so we will choose the first zero, which has the smallest\
  \ index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\n\
  def pluck(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
  \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
  \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
  \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n\
  \    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
  \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
  \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
completions: ["  arr.select(&:even?).sort.first(2)\nend", "  evens = arr.select(&:even?)\n\
    \  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend", "  unless arr.empty?\n\
    \    evens = arr.select { |n| n.even? }\n    evens.empty? ? [] : [evens.min, arr.index(evens.min)]\n\
    \  else\n    []\n  end\nend", "  even_arr = arr.select{|i| i % 2 == 0}.compact\n\
    \  return [] if even_arr.empty?\n  even_arr.sort!\n  [even_arr[0], arr.index(even_arr[0])]\n\
    end", "  hash = {}\n  arr.each_with_index do |x, i|\n    if x.even?\n      hash[x]\
    \ = i\n    end\n  end\n  if hash.empty?\n    []\n  else\n    min = hash.keys.min\n\
    \    [min, hash[min]]\n  end\nend", "  return [] if arr.empty?\n  arr.map.with_index\
    \ { |x, i| [x, i] if x.even? }.compact.min\nend", "  evs = arr.find_all { |e|\
    \ e.even? }\n  evs.size.zero? ? [] : [evs.min, arr.index(evs.min)]\nend", "  even_numbers\
    \ = arr.select(&:even?)\n  return [] if even_numbers.empty?\n  [even_numbers.min,\
    \ arr.index(even_numbers.min)]\nend", "  evens = arr.select { |num| num.even?\
    \ }\n  return [] if evens.empty?\n  min = evens.min\n  arr.index(min)\nend", " \
    \ arr.sort_by.with_index { |num, i| [num.even? ? 0 : 1, num, i] }.take(1).flatten\n\
    end", "  evens = arr.select { |num| num.even? }\n  evens.empty? ? [] : [evens.min,\
    \ arr.index(evens.min)]\nend", "  #arr.each_with_index { |val, idx| val.even?\
    \ ? return [val, idx] : next }\n  #arr.each_with_index { |val, idx| (val % 2 ==\
    \ 0) ? return [val, idx] : next }\n  arr.each_with_index { |val, idx| (val.even?)\
    \ ? return [val, idx] : next }\n  []\nend", "  return [] if arr.empty?\n  # find\
    \ the smallest even number\n  return [] if arr.index(arr.sort.reject { |num| num.odd?\
    \ }.first).nil?\n  # return index of first instance of smallest even number and\
    \ that number\n  [arr.sort.reject { |num| num.odd? }.first, arr.index(arr.sort.reject\
    \ { |num| num.odd? }.first)]\nend", "  evens = arr.find_all { |x| x.even? }\n\
    \  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\np pluck([4,\
    \ 2, 3]) == [2, 1]\np pluck([1, 2, 3]) == [2, 1]\np pluck([]) == []\np pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]", "  smallest_value = nil\n  smallest_index = nil\n\
    \  arr.each_with_index do |e, i|\n    if e.even?\n      if smallest_value.nil?\
    \ || e < smallest_value\n        smallest_value = e\n        smallest_index =\
    \ i\n      end\n    end\n  end\n  smallest_value.nil? ? [] : [smallest_value,\
    \ smallest_index]\nend", "    small_even = nil\n    small_even_index = nil\n \
    \   arr.each_with_index do |x, i|\n        if small_even == nil\n            if\
    \ x % 2 == 0\n                small_even = x\n                small_even_index\
    \ = i\n            end\n        else\n            if x % 2 == 0\n            \
    \    if x < small_even\n                    small_even = x\n                 \
    \   small_even_index = i\n                end\n            end\n        end\n\
    \    end\n    if small_even == nil\n        return []\n    else\n        return\
    \ [small_even, small_even_index]\n    end\nend\np pluck([4, 2, 3])\np pluck([1,\
    \ 2, 3])\np pluck([])\np pluck([5, 0, 3, 0, 4, 2])", "  evens = arr.select { |el|\
    \ el.even? }\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend", " \
    \ return [] if arr.empty?\n  arr.each_with_index.min_by { |el, _i| el.even? ?\
    \ el : 1.0 / 0 }\nend", "  arr.select { |a| a.even? }.min\nend", "  arr.select\
    \ { |x| x.even? }.min\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
