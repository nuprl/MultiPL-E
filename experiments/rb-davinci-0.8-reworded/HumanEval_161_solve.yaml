name: HumanEval_161_solve
language: rb
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"\
  ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"\
  ))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n\
  \    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"\
  2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"\
  #$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"
completions: ["  a=[]\n  s.each_char do |i|\n    if i[/[a-zA-Z]/] \n      a << i.swapcase\n\
    \    else\n      a << i\n    end\n  end\n  a.join\nend", "  return s.reverse if\
    \ s.gsub(/[a-zA-Z]/, '').length == s.length\n  temp = ''\n  s.split('').each {\
    \ |i| temp += i.swapcase }\n  temp\nend", "  if s.gsub(/[a-zA-Z]/, '').length\
    \ == s.length\n    s.reverse\n  else\n    s.tr(\"A-Za-z\", \"a-zA-Z\")\n  end\n\
    end", "  if s.scan(/[a-zA-Z]/).empty?\n    s.reverse\n  else\n    s.chars.map\
    \ { |c| c =~ /[a-zA-Z]/ ? c.swapcase : c }.join\n  end\nend", "  (s.chars.select\
    \ { |i| i =~ /[a-zA-Z]/ }.empty?) ? (s.reverse) : (s.chars.map { |i| \n  \t(i\
    \ =~ /[a-zA-Z]/) ? ((i == i.upcase) ? (i.downcase) : (i.upcase)) : (i) }.join)\n\
    end", "    s.reverse.split('').map{|char| (char.ord.between?(65,90) || char.ord.between?(97,122))\
    \ ? char.swapcase : char}.join('')\nend", "  s.tr(\"A-Za-z\", \"a-zA-Z\")\nend",
  "  \nend", "  if s.count(\"[A-Za-z]\") == 0\n    s.reverse\n  else\n    s.tr('A-Za-z',\
    \ 'a-zA-Z')\n  end\nend", "  s.tr(\"0-9\", \"\") == \"\" ? s.reverse : s.tr(\"\
    a-zA-Z\", \"A-Za-z\")\nend", "  if s.empty?\n    return s\n  else\n    s.chars.map\
    \ { |c| (c =~ /[a-z]/i) ? c.swapcase : c }.join\n  end\nend", "  up_case = s.upcase.chars\n\
    \  down_case = s.downcase.chars\n  output = []\n  s.chars.each_with_index do |char,\
    \ index|\n    if ('a'..'z').include?(char)\n      output << up_case[index]\n \
    \   elsif ('A'..'Z').include?(char)\n      output << down_case[index]\n    else\n\
    \      output << char\n    end\n  end\n  output.join(\"\")\nend", "    s.reverse.tr('a-zA-Z',\
    \ 'A-Za-z')\nend", "  (s.scan(/[a-zA-Z]/).empty?) ? s.reverse : s.tr(\"a-zA-Z\"\
    , \"A-Za-z\")\nend", "  s.chars.map { |c| /[a-z]/ =~ c ? c.upcase : c.downcase\
    \ }.join\nend", "  if !s.split(\"\").map {|x| x =~ /[A-Za-z]/}.include?(nil)\n\
    \    s.swapcase\n  else\n    s.reverse\n  end\nend", "  s == \"\" ? \"\" : s.reverse.tr(\"\
    a-zA-Z\", \"A-Za-z\")\nend", "  s.size == 0 ? s : s.chars.map{|e| e.match(/[a-zA-Z]/)\
    \ ? e.swapcase : e}.join\nend", "  s.reverse.gsub(/[a-z]/i) { |c| c == c.upcase\
    \ ? c.downcase : c.upcase }\nend\nputs solve('#a@C')", "  # your code here\nend",
  "    s.chars.map{|c| c.ord.between?(65,90) ? c.downcase : c.upcase }.join\nend",
  "  string = s.split(\"\")\n  letters = string.select { |x| x =~ /[[:alpha:]]/ }\n\
    \  letters.each do |a|\n    if (a =~ /[[:lower:]]/)\n      a.upcase!\n    else\n\
    \      a.downcase!\n    end\n  end\n  if letters.length == 0\n    string.reverse.join\n\
    \  else\n    string.join\n  end\nend", "\t((s==s.reverse) or (s.length == 0))\
    \ ? s.reverse : s.tr(\"a-zA-Z\", \"A-Za-z\")\nend", "  return reverse_str(s) if\
    \ s.count(\"a-zA-Z\") == 0\n  s.split(\"\").map do |i|\n    if i =~ /[a-zA-Z]/\
    \ then i.swapcase else i end\n  end.join(\"\")\nend", "  #s.tr('a-zA-Z', 'A-Za-z')\n\
    \  s.reverse\nend", "    arr = s.chars\n    str = \"\"\n    arr.each do |char|\n\
    \        if char =~ /[a-z]/\n            str << char.upcase\n        elsif char\
    \ =~ /[A-Z]/\n            str << char.downcase\n        else\n            str\
    \ << char\n        end\n    end\n    str\nend", "\tif s.index(/[a-zA-Z]/) == nil\n\
    \t\ts.reverse\n\telse\n\t\ts.gsub(/[a-zA-Z]/) {|c| c.upcase == c ? c.downcase\
    \ : c.upcase}\n\tend\nend", "  s.chars.map { |c| c.upcase == c ? c.downcase :\
    \ c.upcase }.join\nend", "  s.downcase!\n  letters = s.scan(/[a-z]/)\n  letters.map!{|letter|\
    \ letter.upcase!}\n  s.gsub!(/[a-z]/,letters.join)\n  s.empty? ?  s = s.reverse\
    \ : s\nend", "  s == s.reverse ? s : s.reverse\nend", "  s.swapcase.reverse\n\
    end", "    # We want to do the following.\n    # (1) Find the index of the first\
    \ letter in the string. If there is no letter, return the reversed string.\n \
    \   # (2) We will read the string from the index of the first letter until the\
    \ end of the string, \n    # and copy the string to a new string one character\
    \ at a time.\n    # (3) We will check each character if it is a letter or not.\
    \ If it is a letter, we will change its case. \n    # If it is not a letter, we\
    \ will keep it as it is.\n    # (4) We will add the reversed part of the string\
    \ that is before the first letter, \n    # and the reversed part of the string\
    \ that is after the last letter.\n    s.reverse!\n    first_letter_index = -1\n\
    \    s.chars.each_with_index do |char, index|\n        if char =~ /[a-zA-Z]/\n\
    \            first_letter_index = index\n            break\n        end\n    end\n\
    \    return s if first_letter_index == -1\n    result = \"\"\n    s.chars.each_with_index\
    \ do |char, index|\n        if char =~ /[a-zA-Z]/\n            if char == char.upcase\n\
    \                result += char.downcase\n            else\n                result\
    \ += char.upcase\n            end\n        else\n            result += char\n\
    \        end\n    end\n    s[0...first_letter_index].reverse + result + s[(first_letter_index\
    \ + result.length)...s.length].reverse\nend", "  s.gsub(/[a-zA-Z]/, {'a' => 'A',\
    \ 'A' => 'a', 'b' => 'B', 'B' => 'b', 'c' => 'C', 'C' => 'c', 'd' => 'D', 'D'\
    \ => 'd', 'e' => 'E', 'E' => 'e', 'f' => 'F', 'F' => 'f', 'g' => 'G', 'G' => 'g',\
    \ 'h' => 'H', 'H' => 'h', 'i' => 'I', 'I' => 'i', 'j' => 'J', 'J' => 'j', 'k'\
    \ => 'K', 'K' => 'k', 'l' => 'L', 'L' => 'l', 'm' => 'M', 'M' => 'm', 'n' => 'N',\
    \ 'N' => 'n', 'o' => 'O', 'O' => 'o', 'p' => 'P', 'P' => 'p', 'q' => 'Q', 'Q'\
    \ => 'q', 'r' => 'R', 'R' => 'r', 's' => 'S', 'S' => 's', 't' => 'T', 'T' => 't',\
    \ 'u' => 'U', 'U' => 'u', 'v' => 'V', 'V' => 'v', 'w' => 'W', 'W' => 'w', 'x'\
    \ => 'X', 'X' => 'x', 'y' => 'Y', 'Y' => 'y', 'z' => 'Z', 'Z' => 'z'})\nend",
  "  return s.reverse if s.delete(\"a-zA-Z\").length == s.length\n  s.gsub(/[a-zA-Z]/)\
    \ { |l| l.swapcase }\nend", "  return s.reverse if s[/[a-zA-Z]/].nil?\n  s.gsub(/[a-zA-Z]/,\
    \ '\\0' => ->(m){ m.swapcase })\nend", "  s.gsub(/[a-zA-Z]/, &:swapcase)\nend",
  "  s.chars.map { |c| /[a-z]/i.match(c) ? c.swapcase : c }.join.reverse\nend", " \
    \   return s.reverse unless s.chars.any? { |char| ('a'..'z').include?(char) ||\
    \ ('A'..'Z').include?(char) }\n    s.chars.map do |char|\n        if ('a'..'z').include?(char)\n\
    \            char.upcase\n        elsif ('A'..'Z').include?(char)\n          \
    \  char.downcase\n        else\n            char\n        end\n    end.join('')\n\
    end", "  if s.chars.all? { |ch| ch =~ /\\d/ }\n    s.reverse\n  else\n    s.chars.map\
    \ do |ch|\n      if ch =~ /[a-z]/\n        ch.upcase\n      elsif ch =~ /[A-Z]/\n\
    \        ch.downcase\n      else\n        ch\n      end\n    end.join\n  end\n\
    end", "    rev = \"\"\n    s.each_char do |l|\n        if l =~ /[a-zA-Z]/\n  \
    \          rev += l.swapcase\n        else\n            rev += l\n        end\n\
    \    end\n    rev\nend", "\tletters = \"abcdefghijklmnopqrstuvwxyz\"\n\ts.split(\"\
    \").map { |x|\n\t\tx =~ /[#{letters}]/ ? x.tr('a-z', 'A-Z').tr('A-Z', 'a-z') :\
    \ x\n\t}.join(\"\")\nend", "  s == s.to_i.to_s ? s.reverse : s.gsub(/[a-zA-Z]/,\
    \ &:swapcase)\nend", "  s.swapcase\nend", "  if /[a-zA-Z]/.match(s)\n    s.reverse.swapcase\n\
    \  else\n    s.reverse\n  end\nend", "   if s.match(/[a-zA-Z]/)\n      s.swapcase\n\
    \   else\n      s.reverse\n   end\nend", "  s.chars.map { |c| c =~ /[a-z]/ ? c.upcase\
    \ : c.downcase }.join\nend", "  return s.reverse if s.scan(/\\w/).empty?\n  s.chars.map\
    \ { |char| char =~ /\\w/ ? char.swapcase : char }.join\nend", "  if (s =~ /[[:alpha:]]/)\
    \ == nil\n    s.reverse\n  else\n    s.swapcase\n  end\nend", "  s.reverse.gsub(/[a-z]/i,\
    \ &:swapcase)\nend", "  s.chars.map do |x|\n    if x =~ /[a-z]/i\n      x == x.upcase\
    \ ? x.downcase : x.upcase\n    else\n      x\n    end\n  end.join\nend", "   \
    \ # Write your code here\n    s.gsub(/[a-zA-Z]/, \"a\"=>\"A\", \"b\"=>\"B\", \"\
    c\"=>\"C\", \"d\"=>\"D\", \"e\"=>\"E\", \"f\"=>\"F\", \"g\"=>\"G\", \"h\"=>\"\
    H\", \"i\"=>\"I\", \"j\"=>\"J\", \"k\"=>\"K\", \"l\"=>\"L\", \"m\"=>\"M\", \"\
    n\"=>\"N\", \"o\"=>\"O\", \"p\"=>\"P\", \"q\"=>\"Q\", \"r\"=>\"R\", \"s\"=>\"\
    S\", \"t\"=>\"T\", \"u\"=>\"U\", \"v\"=>\"V\", \"w\"=>\"W\", \"x\"=>\"X\", \"\
    y\"=>\"Y\", \"z\"=>\"Z\", \"A\"=>\"a\", \"B\"=>\"b\", \"C\"=>\"c\", \"D\"=>\"\
    d\", \"E\"=>\"e\", \"F\"=>\"f\", \"G\"=>\"g\", \"H\"=>\"h\", \"I\"=>\"i\", \"\
    J\"=>\"j\", \"K\"=>\"k\", \"L\"=>\"l\", \"M\"=>\"m\", \"N\"=>\"n\", \"O\"=>\"\
    o\", \"P\"=>\"p\", \"Q\"=>\"q\", \"R\"=>\"r\", \"S\"=>\"s\", \"T\"=>\"t\", \"\
    U\"=>\"u\", \"V\"=>\"v\", \"W\"=>\"w\", \"X\"=>\"x\", \"Y\"=>\"y\", \"Z\"=>\"\
    z\")\nend", "  s.chars.map do |x|\n    x =~ /[a-z]/ ? x.upcase : x.downcase\n\
    \  end.join\nend", "    s.tr!('A-Za-z', 'a-zA-Z')\n    s.reverse!\nend", "  s.scan(/[a-zA-Z]/).empty?\
    \ ? s.reverse : s.swapcase\nend", "  if s.split('').any? { |letter| /[a-zA-Z]/.match(letter)\
    \ }\n    s.split('').map { |letter| /[a-zA-Z]/.match(letter) ? letter.swapcase\
    \ : letter }.join\n  else\n    s.reverse\n  end\nend", "  s.swapcase.reverse\n\
    end", "  s.gsub(/[a-zA-Z]/, 'a' => 'A', 'A' => 'a', 'b' => 'B', 'B' => 'b', 'c'\
    \ => 'C', 'C' => 'c', 'd' => 'D', 'D' => 'd', 'e' => 'E', 'E' => 'e', 'f' => 'F',\
    \ 'F' => 'f', 'g' => 'G', 'G' => 'g', 'h' => 'H', 'H' => 'h', 'i' => 'I', 'I'\
    \ => 'i', 'j' => 'J', 'J' => 'j', 'k' => 'K', 'K' => 'k', 'l' => 'L', 'L' => 'l',\
    \ 'm' => 'M', 'M' => 'm', 'n' => 'N', 'N' => 'n', 'o' => 'O', 'O' => 'o', 'p'\
    \ => 'P', 'P' => 'p', 'q' => 'Q', 'Q' => 'q', 'r' => 'R', 'R' => 'r', 's' => 'S',\
    \ 'S' => 's', 't' => 'T', 'T' => 't', 'u' => 'U', 'U' => 'u', 'v' => 'V', 'V'\
    \ => 'v', 'w' => 'W', 'W' => 'w', 'x' => 'X', 'X' => 'x', 'y' => 'Y', 'Y' => 'y',\
    \ 'z' => 'Z', 'Z' => 'z') || s.reverse\nend", "  s.reverse\nend\nputs solve(\"\
    1234\") == \"4321\"\nputs solve(\"ab\") == \"AB\"\nputs solve(\"#a@C\") == \"\
    #A@c\"", "  s = s.gsub(/[a-z]/, &:swapcase) if s.match(/[a-z]/)\n  s.reverse\n\
    end", "  s.gsub(/[a-zA-Z]/, 'a' => 'A', 'A' => 'a', 'b' => 'B', 'B' => 'b', 'c'\
    \ => 'C', 'C' => 'c', 'd' => 'D', 'D' => 'd', 'e' => 'E', 'E' => 'e', 'f' => 'F',\
    \ 'F' => 'f', 'g' => 'G', 'G' => 'g', 'h' => 'H', 'H' => 'h', 'i' => 'I', 'I'\
    \ => 'i', 'j' => 'J', 'J' => 'j', 'k' => 'K', 'K' => 'k', 'l' => 'L', 'L' => 'l',\
    \ 'm' => 'M', 'M' => 'm', 'n' => 'N', 'N' => 'n', 'o' => 'O', 'O' => 'o', 'p'\
    \ => 'P', 'P' => 'p', 'q' => 'Q', 'Q' => 'q', 'r' => 'R', 'R' => 'r', 's' => 'S',\
    \ 'S' => 's', 't' => 'T', 'T' => 't', 'u' => 'U', 'U' => 'u', 'v' => 'V', 'V'\
    \ => 'v', 'w' => 'W', 'W' => 'w', 'x' => 'X', 'X' => 'x', 'y' => 'Y', 'Y' => 'y',\
    \ 'z' => 'Z', 'Z' => 'z')\nend", "    s.split(\"\").map do |x|\n        if x =~\
    \ /[a-z]/\n            x.upcase\n        elsif x =~ /[A-Z]/\n            x.downcase\n\
    \        else\n            x\n        end\n    end.join(\"\")\nend", "  s.gsub(/\\\
    p{L}/) { |c| c == c.upcase ? c.downcase : c.upcase }.reverse\nend", "  s.gsub(/\\\
    p{Alpha}/) { |c| c.upcase == c ? c.downcase : c.upcase }.reverse\nend", "    i\
    \ = 0\n    count = 0\n    while i < s.length\n        if s[i] =~ /[a-zA-Z]/\n\
    \            count += 1\n        end\n        i += 1\n    end\n    if count ==\
    \ 0\n        return s.reverse\n    end\n    i = 0\n    while i < s.length\n  \
    \      if s[i] =~ /[a-z]/\n            s[i] = s[i].upcase\n        elsif s[i]\
    \ =~ /[A-Z]/\n            s[i] = s[i].downcase\n        end\n        i += 1\n\
    \    end\n    return s\nend", "  if !s.match(/[a-zA-Z]/)\n    s.reverse\n  else\n\
    \    s.gsub(/[a-zA-Z]/, &:swapcase)\n  end\nend", "    return s.reverse if s.count(\"\
    A-Za-z\") == 0\n    s.chars.map { |x| x.match(/[A-Za-z]/) ? x.swapcase : x }.join\n\
    end", "    if s.scan(/[a-zA-Z]/).size == 0\n        return s.reverse\n    end\n\
    \    res = \"\"\n    s.each_char do |c|\n        res += c == c.upcase ? c.downcase\
    \ : c.upcase\n    end\n    res\nend", "  s.gsub(/[a-zA-Z]/, 'a' => 'A', 'A' =>\
    \ 'a', 'b' => 'B', 'B' => 'b', 'c' => 'C', 'C' => 'c', 'd' => 'D', 'D' => 'd',\
    \ 'e' => 'E', 'E' => 'e', 'f' => 'F', 'F' => 'f', 'g' => 'G', 'G' => 'g', 'h'\
    \ => 'H', 'H' => 'h', 'i' => 'I', 'I' => 'i', 'j' => 'J', 'J' => 'j', 'k' => 'K',\
    \ 'K' => 'k', 'l' => 'L', 'L' => 'l', 'm' => 'M', 'M' => 'm', 'n' => 'N', 'N'\
    \ => 'n', 'o' => 'O', 'O' => 'o', 'p' => 'P', 'P' => 'p', 'q' => 'Q', 'Q' => 'q',\
    \ 'r' => 'R', 'R' => 'r', 's' => 'S', 'S' => 's', 't' => 'T', 'T' => 't', 'u'\
    \ => 'U', 'U' => 'u', 'v' => 'V', 'V' => 'v', 'w' => 'W', 'W' => 'w', 'x' => 'X',\
    \ 'X' => 'x', 'y' => 'Y', 'Y' => 'y', 'z' => 'Z', 'Z' => 'z')\nend", "  if s.size\
    \ < 3\n    s.reverse\n  else\n    s.gsub(/[a-z]/i, 'a' => 'A', 'b' => 'B', 'c'\
    \ => 'C', 'd' => 'D', 'e' => 'E', 'f' => 'F', 'g' => 'G', 'h' => 'H', 'i' => 'I',\
    \ 'j' => 'J', 'k' => 'K', 'l' => 'L', 'm' => 'M', 'n' => 'N', 'o' => 'O', 'p'\
    \ => 'P', 'q' => 'Q', 'r' => 'R', 's' => 'S', 't' => 'T', 'u' => 'U', 'v' => 'V',\
    \ 'w' => 'W', 'x' => 'X', 'y' => 'Y', 'z' => 'Z', 'A' => 'a', 'B' => 'b', 'C'\
    \ => 'c', 'D' => 'd', 'E' => 'e', 'F' => 'f', 'G' => 'g', 'H' => 'h', 'I' => 'i',\
    \ 'J' => 'j', 'K' => 'k', 'L' => 'l', 'M' => 'm', 'N' => 'n', 'O' => 'o', 'P'\
    \ => 'p', 'Q' => 'q', 'R' => 'r', 'S' => 's', 'T' => 't', 'U' => 'u', 'V' => 'v',\
    \ 'W' => 'w', 'X' => 'x', 'Y' => 'y', 'Z' => 'z')\n  end\nend", "\tif s.include?\
    \ /[a-zA-Z]/\n\t\ts.tr(\"a-zA-Z\", \"A-Za-z\")\n\telse\n\t\ts.reverse\n\tend\n\
    end", "\t\nend", "  result = \"\"\n  s.each_char do |char|\n    result << char.match(/[a-zA-Z]/)\
    \ ? char.swapcase : char\n  end\n  s.match(/[a-zA-Z]/) ? result : result.reverse\n\
    end", "  s.each_char.map { |c| c =~ /[a-z]/ ? c.upcase : c.downcase }.join\nend",
  "  s.gsub(/[a-zA-Z]/, 'a' => 'A', 'b' => 'B', 'c' => 'C', 'd' => 'D', 'e' => 'E',\
    \ 'f' => 'F', 'g' => 'G', 'h' => 'H', 'i' => 'I', 'j' => 'J', 'k' => 'K', 'l'\
    \ => 'L', 'm' => 'M', 'n' => 'N', 'o' => 'O', 'p' => 'P', 'q' => 'Q', 'r' => 'R',\
    \ 's' => 'S', 't' => 'T', 'u' => 'U', 'v' => 'V', 'w' => 'W', 'x' => 'X', 'y'\
    \ => 'Y', 'z' => 'Z', 'A' => 'a', 'B' => 'b', 'C' => 'c', 'D' => 'd', 'E' => 'e',\
    \ 'F' => 'f', 'G' => 'g', 'H' => 'h', 'I' => 'i', 'J' => 'j', 'K' => 'k', 'L'\
    \ => 'l', 'M' => 'm', 'N' => 'n', 'O' => 'o', 'P' => 'p', 'Q' => 'q', 'R' => 'r',\
    \ 'S' => 's', 'T' => 't', 'U' => 'u', 'V' => 'v', 'W' => 'w', 'X' => 'x', 'Y'\
    \ => 'y', 'Z' => 'z')\nend", "  s.reverse.gsub(/[a-z]/, &:upcase).gsub(/[A-Z]/,\
    \ &:downcase)\nend", "  res = \"\"\n  s.each_char do |c|\n    res << ((?a..?z).include?(c)\
    \ ? c.upcase : c.downcase)\n  end\n  res\nend", "  # check if there are any letters\
    \ in string s\n  # if so, swap their case from lower to upper and vice versa\n\
    \  # if not, reverse the string\n  s.empty? ? \"\" : s.gsub(/[a-zA-Z]/, 'a' =>\
    \ 'A', 'b' => 'B', 'c' => 'C', 'd' => 'D', 'e' => 'E', 'f' => 'F', 'g' => 'G',\
    \ 'h' => 'H', 'i' => 'I', 'j' => 'J', 'k' => 'K', 'l' => 'L', 'm' => 'M', 'n'\
    \ => 'N', 'o' => 'O', 'p' => 'P', 'q' => 'Q', 'r' => 'R', 's' => 'S', 't' => 'T',\
    \ 'u' => 'U', 'v' => 'V', 'w' => 'W', 'x' => 'X', 'y' => 'Y', 'z' => 'Z', 'A'\
    \ => 'a', 'B' => 'b', 'C' => 'c', 'D' => 'd', 'E' => 'e', 'F' => 'f', 'G' => 'g',\
    \ 'H' => 'h', 'I' => 'i', 'J' => 'j', 'K' => 'k', 'L' => 'l', 'M' => 'm', 'N'\
    \ => 'n', 'O' => 'o', 'P' => 'p', 'Q' => 'q', 'R' => 'r', 'S' => 's', 'T' => 't',\
    \ 'U' => 'u', 'V' => 'v', 'W' => 'w', 'X' => 'x', 'Y' => 'y', 'Z' => 'z')\nend",
  "    if s.split(\"\").any? {|x| x =~ /[a-zA-Z]/}\n        s.split(\"\").map {|i|\
    \ i =~ /[a-zA-Z]/ ? i.swapcase : i}.join(\"\")\n    else\n        s.reverse\n\
    \    end\nend", "  s.tr(\"A-Za-z\", \"a-zA-Z\")\nend", "  s.reverse! if s.count(\"\
    a-zA-Z\") == 0\n  s.swapcase!\nend", "  s.length <= 1 ? s.reverse : (s.scan(/[a-zA-Z]/).map\
    \ { |c| c.casecmp?(c) ? c.swapcase : c }).join\nend", "  s.tr(\"A-Za-z\", \"a-zA-Z\"\
    )\nend", "\tans = \"\"\n\tup = 0\n\tdown = 0\n\ts.each_char do |char|\n\t\tif\
    \ char == char.upcase\n\t\t\tup += 1\n\t\telsif char == char.downcase\n\t\t\t\
    down += 1\n\t\tend\n\tend\n\tif up > 0 || down > 0\n\t\ts.each_char do |char|\n\
    \t\t\tif char == char.upcase\n\t\t\t\tans << char.downcase\n\t\t\telsif char ==\
    \ char.downcase\n\t\t\t\tans << char.upcase\n\t\t\telse\n\t\t\t\tans << char\n\
    \t\t\tend\n\t\tend\n\t\tans\n\telse\n\t\tans = s.reverse\n\tend\nend", "  # your\
    \ code here\nend", "    newStr = ''\n    for i in 0..s.length\n        if s[i]\
    \ =~ /[a-z]/\n            newStr = newStr + s[i].upcase\n        elsif s[i] =~\
    \ /[A-Z]/\n            newStr = newStr + s[i].downcase\n        else\n       \
    \     newStr = newStr + s[i]\n        end\n    end\n    return newStr\nend", " \
    \ s = s.split('')\n  s.reverse.map do |c|\n    if ('a'..'z').include?(c)\n   \
    \   c.upcase\n    elsif ('A'..'Z').include?(c)\n      c.downcase\n    else\n \
    \     c\n    end\n  end.join\nend", "    l = s.size\n    if l == 0\n        return\
    \ \"\"\n    end\n    for i in 0..l-1\n        if (s[i] >=\"a\" && s[i] <=\"z\"\
    )\n            s[i] = s[i].upcase\n        elsif s[i] >=\"A\" && s[i] <=\"Z\"\n\
    \            s[i] = s[i].downcase\n        end\n    end\n    return s.reverse\n\
    end", "  s.chars.map do |char|\n    if char.match(/[a-zA-Z]/)\n      if char.match(/[a-z]/)\n\
    \        char.upcase\n      else\n        char.downcase\n      end\n    else\n\
    \      char\n    end\n  end.join.reverse\nend", "  flag = false\n  result = \"\
    \"\n  s.each_char do |c|\n    if ('a'..'z').include?(c) || ('A'..'Z').include?(c)\n\
    \      flag = true\n      result << c.swapcase\n    else\n      result << c\n\
    \    end\n  end\n  if flag\n    result\n  else\n    result.reverse\n  end\nend",
  "  s.reverse.tr(\"A-Za-z\", \"a-zA-Z\")\nend", "  result = \"\"\n  s.each_char do\
    \ |c|\n    if c =~ /[[:alpha:]]/\n      result << (c == c.upcase ? c.downcase\
    \ : c.upcase)\n    else\n      result << c\n    end\n  end\n  result.reverse\n\
    end", "  s.tr(\"a-zA-Z\", \"A-Za-z\")\nend", "  s.tr!('a-z', 'A-Z') if s =~ /[a-z]/\n\
    \  s.tr!('A-Z', 'a-z') if s =~ /[A-Z]/\n  s.reverse\nend", "  new_s = s.chars.map\
    \ do |c|\n    if c =~ /[a-z]/\n      c.upcase\n    elsif c =~ /[A-Z]/\n      c.downcase\n\
    \    else\n      c\n    end\n  end\n  new_s.join\nend", "  s.gsub(/[a-zA-Z]/,\
    \ 'a' => 'A', 'b' => 'B', 'c' => 'C', 'd' => 'D', 'e' => 'E', 'f' => 'F', 'g'\
    \ => 'G', 'h' => 'H', 'i' => 'I', 'j' => 'J', 'k' => 'K', 'l' => 'L', 'm' => 'M',\
    \ 'n' => 'N', 'o' => 'O', 'p' => 'P', 'q' => 'Q', 'r' => 'R', 's' => 'S', 't'\
    \ => 'T', 'u' => 'U', 'v' => 'V', 'w' => 'W', 'x' => 'X', 'y' => 'Y', 'z' => 'Z',\
    \ 'A' => 'a', 'B' => 'b', 'C' => 'c', 'D' => 'd', 'E' => 'e', 'F' => 'f', 'G'\
    \ => 'g', 'H' => 'h', 'I' => 'i', 'J' => 'j', 'K' => 'k', 'L' => 'l', 'M' => 'm',\
    \ 'N' => 'n', 'O' => 'o', 'P' => 'p', 'Q' => 'q', 'R' => 'r', 'S' => 's', 'T'\
    \ => 't', 'U' => 'u', 'V' => 'v', 'W' => 'w', 'X' => 'x', 'Y' => 'y', 'Z' => 'z')\n\
    end", "  if s.count(\"[a-zA-Z]\") == 0\n    return s.reverse\n  else\n    s.gsub(/[a-zA-Z]/)\
    \ { |c| c == c.upcase ? c.downcase : c.upcase }\n  end\nend", "  if (s[/[a-zA-Z]/])\
    \ == nil\n    return s.reverse\n  else\n    return s.tr('a-zA-Z', 'A-Za-z')\n\
    \  end\nend", "  s.chars.map { |char| char.match(/[a-zA-Z]/) ? char.swapcase :\
    \ char }.join\nend", "  flag = false\n  tmp = \"\"\n  s.each_char do |ch|\n  \
    \  if !(ch =~ /[[:alnum:]]/)\n      tmp += ch\n    else\n      flag = true\n \
    \     tmp += ch.swapcase\n    end\n  end\n  return flag ? tmp : tmp.reverse\n\
    end", "  if s.match(/[a-zA-Z]/)\n    s.tr('a-zA-Z', 'A-Za-z')\n  else\n    s.reverse\n\
    \  end\nend", "  a = []\n  s.split(\"\").each do |x|\n    if x.match(/[a-zA-Z]/)\n\
    \      if x == x.downcase\n        a << x.upcase\n      else\n        a << x.downcase\n\
    \      end\n    else\n      a << x\n    end\n  end\n  a.join(\"\")\nend", "  \
    \  if s =~ /[a-zA-Z]/\n        if s =~ /[a-z]/\n            s.swapcase\n     \
    \   else\n            s.reverse\n        end\n    else\n        s.reverse\n  \
    \  end\nend", "  s.swapcase\nend\nsolve(\"#a@C\")", "\tnew_s = \"\"\n\ts.each_char\
    \ do |c|\n\t\tif c =~ /[a-zA-Z]/\n\t\t\tif c == c.upcase\n\t\t\t\tnew_s << c.downcase\n\
    \t\t\telse\n\t\t\t\tnew_s << c.upcase\n\t\t\tend\n\t\telse\n\t\t\tnew_s << c\n\
    \t\tend\n\tend\n\tif new_s == \"\"\n\t\tnew_s = s.reverse\n\tend\n\tnew_s\nend",
  "  s.reverse!\n  (0...s.length).each do |i|\n    if s[i] =~ /[a-z]/\n      s[i]\
    \ = s[i].upcase\n    elsif s[i] =~ /[A-Z]/\n      s[i] = s[i].downcase\n    end\n\
    \  end\n  s\nend", "  s.reverse!\n  str = ''\n  s.each_char do |c|\n    c =~ /[a-z]/\
    \ ? str << c.upcase : str << c.downcase\n  end\n  str\nend", "  str = []\n  s.split('').each\
    \ do |i|\n    if i == i.upcase\n      str << i.downcase\n    elsif i == i.downcase\n\
    \      str << i.upcase\n    else\n      str << i\n    end\n  end\n  str.join('')\n\
    end", "  if s.count(\"A-Za-z\") > 0\n    s.swapcase\n  else\n    s.reverse\n \
    \ end\nend", "  s.reverse\nend", "  if s.count(\"a-zA-Z\") < 1\n    s.reverse\n\
    \  else\n    result = []\n    s.each_char do |n|\n      if n.match(/[a-zA-Z]/)\n\
    \        result << n.swapcase\n      else\n        result << n\n      end\n  \
    \  end\n    result.join(\"\")\n  end\nend", "  s.gsub(/[a-zA-Z]/, 'a' => 'A',\
    \ 'A' => 'a', 'b' => 'B', 'B' => 'b', 'c' => 'C', 'C' => 'c', 'd' => 'D', 'D'\
    \ => 'd', 'e' => 'E', 'E' => 'e', 'f' => 'F', 'F' => 'f', 'g' => 'G', 'G' => 'g',\
    \ 'h' => 'H', 'H' => 'h', 'i' => 'I', 'I' => 'i', 'j' => 'J', 'J' => 'j', 'k'\
    \ => 'K', 'K' => 'k', 'l' => 'L', 'L' => 'l', 'm' => 'M', 'M' => 'm', 'n' => 'N',\
    \ 'N' => 'n', 'o' => 'O', 'O' => 'o', 'p' => 'P', 'P' => 'p', 'q' => 'Q', 'Q'\
    \ => 'q', 'r' => 'R', 'R' => 'r', 's' => 'S', 'S' => 's', 't' => 'T', 'T' => 't',\
    \ 'u' => 'U', 'U' => 'u', 'v' => 'V', 'V' => 'v', 'w' => 'W', 'W' => 'w', 'x'\
    \ => 'X', 'X' => 'x', 'y' => 'Y', 'Y' => 'y', 'z' => 'Z', 'Z' => 'z')\nend", " \
    \ s.gsub(/[a-zA-Z]/, 'a' => 'A', 'A' => 'a')\nend", "    s.chars.each_with_index.map\
    \ { |x, i| \n        if x.match(/[a-zA-Z]/)\n            x.upcase == x ? x.downcase\
    \ : x.upcase\n        else\n            x\n        end\n    }.join\nend", "  s.reverse.gsub(/[a-z]/i)\
    \ { |match| match == match.upcase ? match.downcase : match.upcase }\nend", " \
    \ s.gsub(/[a-zA-Z]/, 'a' => 'A', 'b' => 'B', 'c' => 'C', 'd' => 'D', 'e' => 'E',\
    \ 'f' => 'F', 'g' => 'G', 'h' => 'H', 'i' => 'I', 'j' => 'J', 'k' => 'K', 'l'\
    \ => 'L', 'm' => 'M', 'n' => 'N', 'o' => 'O', 'p' => 'P', 'q' => 'Q', 'r' => 'R',\
    \ 's' => 'S', 't' => 'T', 'u' => 'U', 'v' => 'V', 'w' => 'W', 'x' => 'X', 'y'\
    \ => 'Y', 'z' => 'Z', 'A' => 'a', 'B' => 'b', 'C' => 'c', 'D' => 'd', 'E' => 'e',\
    \ 'F' => 'f', 'G' => 'g', 'H' => 'h', 'I' => 'i', 'J' => 'j', 'K' => 'k', 'L'\
    \ => 'l', 'M' => 'm', 'N' => 'n', 'O' => 'o', 'P' => 'p', 'Q' => 'q', 'R' => 'r',\
    \ 'S' => 's', 'T' => 't', 'U' => 'u', 'V' => 'v', 'W' => 'w', 'X' => 'x', 'Y'\
    \ => 'y', 'Z' => 'z')\nend", "  s.tr('a-zA-Z', 'A-Za-z')\nend", "  # Write your\
    \ code here\nend", "  #code here\nend", "    s.gsub(/[a-zA-Z]/, 'a' => 'A', 'A'\
    \ => 'a')\nend", "  s.chars.map do |char|\n    char =~ /[a-z]/ ? char.upcase :\
    \ char.downcase\n  end.join('')\nend", "\ts.swapcase\nend\nputs solve(\"ab\")",
  "  new_s = \"\"\n  if s.count(\"a-zA-Z\") != 0\n    s.each_char { |char| new_s <<\
    \ char.swapcase }\n  else\n    new_s = s.reverse\n  end\n  new_s\nend", "  if\
    \ s.match(/[a-zA-Z]/)\n    s.chars.map{|c| c.match(/[a-zA-Z]/) ? c.swapcase :\
    \ c}.join\n  else\n    s.reverse\n  end\nend", "  s.gsub(/[a-zA-Z]/, &:swapcase)\n\
    end", "  return s.reverse if s.scan(/[a-zA-Z]/).empty?\n  s.chars.map{|a| a=~/[a-zA-Z]/\
    \ ? a.downcase == a ? a.upcase : a.downcase : a}.join\nend", "  s.tr('A-Za-z',\
    \ 'a-zA-Z')\nend", "  s.chars.map { |i|\n    if i =~ /[[:alpha:]]/\n      i ==\
    \ i.upcase ? i.downcase : i.upcase\n    else\n      i\n    end\n  }.join\nend",
  "  #code here\nend", "    s.reverse.tr('A-Za-z', 'a-zA-Z')\nend", "  s.split('').map\
    \ { |c| c =~ /[a-z]/ ? c.upcase : c.downcase }.join('')\nend", "  s.swapcase\n\
    end", "  if s.match(/[a-zA-Z]/) == nil\n    return s.reverse\n  else\n    b =\
    \ s.chars.map{|i| i.match(/[a-zA-Z]/) ? i.match(/[a-z]/) ? i.upcase : i.downcase\
    \ : i}\n    return b.join(\"\")\n  end\nend", "  s.empty? ? s : s.reverse\nend",
  "   s.chars.map { |x| x.match(/[a-zA-Z]/) ? x.swapcase : x }.join\nend", "  s.gsub(/[a-zA-Z]/,\
    \ {'a' => 'A', 'b' => 'B', 'c' => 'C', 'd' => 'D', 'e' => 'E', 'f' => 'F', 'g'\
    \ => 'G', 'h' => 'H', 'i' => 'I', 'j' => 'J', 'k' => 'K', 'l' => 'L', 'm' => 'M',\
    \ 'n' => 'N', 'o' => 'O', 'p' => 'P', 'q' => 'Q', 'r' => 'R', 's' => 'S', 't'\
    \ => 'T', 'u' => 'U', 'v' => 'V', 'w' => 'W', 'x' => 'X', 'y' => 'Y', 'z' => 'Z',\
    \ 'A' => 'a', 'B' => 'b', 'C' => 'c', 'D' => 'd', 'E' => 'e', 'F' => 'f', 'G'\
    \ => 'g', 'H' => 'h', 'I' => 'i', 'J' => 'j', 'K' => 'k', 'L' => 'l', 'M' => 'm',\
    \ 'N' => 'n', 'O' => 'o', 'P' => 'p', 'Q' => 'q', 'R' => 'r', 'S' => 's', 'T'\
    \ => 't', 'U' => 'u', 'V' => 'v', 'W' => 'w', 'X' => 'x', 'Y' => 'y', 'Z' => 'z'})\n\
    end", "  s.reverse.tr(\"a-zA-Z\", \"A-Za-z\")\nend", "  letters = s.chars.select\
    \ { |c| c =~ /[a-zA-Z]/ }\n  letters.each do |letter|\n    case letter\n    when\
    \ /[a-z]/\n      letter.upcase!\n    when /[A-Z]/\n      letter.downcase!\n  \
    \  end\n  end\n  letters.join\nend", "  s.gsub(/[a-zA-Z]/) { |x| x == x.upcase\
    \ ? x.downcase : x.upcase }.reverse\nend", "  s.tr(\"a-zA-Z\", \"A-Za-z\")\nend",
  "  if s == s.to_i.to_s\n    return s.reverse\n  else\n    new_s = ''\n    s.each_char\
    \ do |ch|\n      if ('a'..'z').include?(ch)\n        new_s += ch.upcase\n    \
    \  elsif ('A'..'Z').include?(ch)\n        new_s += ch.downcase\n      else\n \
    \       new_s += ch\n      end\n    end\n    return new_s\n  end\nend", "  s.gsub(/[a-zA-Z]/,\
    \ 'a' => 'A', 'A' => 'a', 'b' => 'B', 'B' => 'b', 'c' => 'C', 'C' => 'c', 'd'\
    \ => 'D', 'D' => 'd', 'e' => 'E', 'E' => 'e', 'f' => 'F', 'F' => 'f', 'g' => 'G',\
    \ 'G' => 'g', 'h' => 'H', 'H' => 'h', 'i' => 'I', 'I' => 'i', 'j' => 'J', 'J'\
    \ => 'j', 'k' => 'K', 'K' => 'k', 'l' => 'L', 'L' => 'l', 'm' => 'M', 'M' => 'm',\
    \ 'n' => 'N', 'N' => 'n', 'o' => 'O', 'O' => 'o', 'p' => 'P', 'P' => 'p', 'q'\
    \ => 'Q', 'Q' => 'q', 'r' => 'R', 'R' => 'r', 's' => 'S', 'S' => 's', 't' => 'T',\
    \ 'T' => 't', 'u' => 'U', 'U' => 'u', 'v' => 'V', 'V' => 'v', 'w' => 'W', 'W'\
    \ => 'w', 'x' => 'X', 'X' => 'x', 'y' => 'Y', 'Y' => 'y', 'z' => 'Z', 'Z' => 'z')\n\
    end", "  return s.reverse if !s.match(/[a-zA-Z]/)\n  s.chars.map{|c| c.match(/[a-zA-Z]/)\
    \ ? c.swapcase : c}.join\nend", "  s.gsub(/[a-zA-Z]/, \"a\"=>\"A\", \"b\"=>\"\
    B\", \"c\"=>\"C\", \"d\"=>\"D\", \"e\"=>\"E\", \"f\"=>\"F\", \"g\"=>\"G\", \"\
    h\"=>\"H\", \"i\"=>\"I\", \"j\"=>\"J\", \"k\"=>\"K\", \"l\"=>\"L\", \"m\"=>\"\
    M\", \"n\"=>\"N\", \"o\"=>\"O\", \"p\"=>\"P\", \"q\"=>\"Q\", \"r\"=>\"R\", \"\
    s\"=>\"S\", \"t\"=>\"T\", \"u\"=>\"U\", \"v\"=>\"V\", \"w\"=>\"W\", \"x\"=>\"\
    X\", \"y\"=>\"Y\", \"z\"=>\"Z\", \"A\"=>\"a\", \"B\"=>\"b\", \"C\"=>\"c\", \"\
    D\"=>\"d\", \"E\"=>\"e\", \"F\"=>\"f\", \"G\"=>\"g\", \"H\"=>\"h\", \"I\"=>\"\
    i\", \"J\"=>\"j\", \"K\"=>\"k\", \"L\"=>\"l\", \"M\"=>\"m\", \"N\"=>\"n\", \"\
    O\"=>\"o\", \"P\"=>\"p\", \"Q\"=>\"q\", \"R\"=>\"r\", \"S\"=>\"s\", \"T\"=>\"\
    t\", \"U\"=>\"u\", \"V\"=>\"v\", \"W\"=>\"w\", \"X\"=>\"x\", \"Y\"=>\"y\", \"\
    Z\"=>\"z\")\nend", "  s.swapcase!\n  s\nend", "  s.chars.map { |c| c.match(/[a-zA-Z]/)\
    \ ? c.upcase! : c.downcase! }.join\nend", "  s == s.reverse ? s : s.reverse.gsub(/[A-Z]/,&:downcase).gsub(/[a-z]/,&:upcase)\n\
    end", "\tif s.match(/[a-zA-Z]/)\n\t\treturn s.tr(\"a-zA-Z\", \"A-Za-z\")\n\telse\n\
    \t\treturn s.reverse\n\tend\nend", "  s.reverse\nend", "  s.gsub(/[a-zA-Z]/, '\\\
    0' => '@').reverse\nend", "  # ..\nend", "  s.empty? ? s : s.gsub(/[a-zA-Z]/,\
    \ &:swapcase)\nend", "  return s.reverse if s.match(/[A-Za-z]/).nil?\n  s.chars.map\
    \ { |c| c.match(/[A-Za-z]/) ? c.swapcase : c }.join\nend", "\tif s.downcase ==\
    \ s.upcase\n\t\treturn s.reverse\n\tend\n\tresult = s.chars.map do |c|\n\t\tif\
    \ c == c.downcase\n\t\t\tc.upcase\n\t\telsif c == c.upcase\n\t\t\tc.downcase\n\
    \t\telse\n\t\t\tc\n\t\tend\n\tend\n\tresult.join\nend\np solve('#a@C')", "  letters\
    \ = s.scan(/[a-zA-Z]/)\n  if letters.empty?\n    s.reverse\n  else\n    s.chars.map\
    \ do |char|\n      if char =~ /[a-zA-Z]/\n        char.downcase == char ? char.upcase\
    \ : char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\
    end\np solve('#a@C')", "  arr = []\n  s.split(\"\").each do |i|\n    if i =~ /[a-zA-Z]/\n\
    \      if i == i.upcase\n        arr << i.downcase\n      else\n        arr <<\
    \ i.upcase\n      end\n    else\n      arr << i\n    end\n  end\n  arr.join(\"\
    \")\nend", "\ts.swapcase\nend", "    s.reverse!\n    s = s.chars.map { |c| c.upcase\
    \ == c ? c.downcase : c.upcase }.join\n    return s\nend", "\treturn s.reverse\
    \ if s.scan(/[a-zA-Z]/).empty?\n\ts.gsub(/[a-zA-Z]/, \"A\" => \"a\", \"a\" =>\
    \ \"A\", \"B\" => \"b\", \"b\" => \"B\", \"C\" => \"c\", \"c\" => \"C\", \"D\"\
    \ => \"d\", \"d\" => \"D\", \"E\" => \"e\", \"e\" => \"E\", \"F\" => \"f\", \"\
    f\" => \"F\", \"G\" => \"g\", \"g\" => \"G\", \"H\" => \"h\", \"h\" => \"H\",\
    \ \"I\" => \"i\", \"i\" => \"I\", \"J\" => \"j\", \"j\" => \"J\", \"K\" => \"\
    k\", \"k\" => \"K\", \"L\" => \"l\", \"l\" => \"L\", \"M\" => \"m\", \"m\" =>\
    \ \"M\", \"N\" => \"n\", \"n\" => \"N\", \"O\" => \"o\", \"o\" => \"O\", \"P\"\
    \ => \"p\", \"p\" => \"P\", \"Q\" => \"q\", \"q\" => \"Q\", \"R\" => \"r\", \"\
    r\" => \"R\", \"S\" => \"s\", \"s\" => \"S\", \"T\" => \"t\", \"t\" => \"T\",\
    \ \"U\" => \"u\", \"u\" => \"U\", \"V\" => \"v\", \"v\" => \"V\", \"W\" => \"\
    w\", \"w\" => \"W\", \"X\" => \"x\", \"x\" => \"X\", \"Y\" => \"y\", \"y\" =>\
    \ \"Y\", \"Z\" => \"z\", \"z\" => \"Z\")\nend", "  s.swapcase\nend", "  s.chars.map\
    \ { |x| x.match(/[a-zA-Z]/) ? x.swapcase : x }.join\nend", "    # write your code\
    \ here\nend", "   s.tr!('a-z', 'A-Z') if s.count('a-z') != 0\n   s.tr!('A-Z',\
    \ 'a-z') if s.count('A-Z') != 0\n   s.reverse\nend", "  # n = s.length\n  # a\
    \ = s.split('')\n  # for i in 0..n-1\n  #   if (a[i] != \"a\" && a[i] != \"b\"\
    \ && a[i] != \"c\" && a[i] != \"d\" && a[i] != \"e\" && a[i] != \"f\" && a[i]\
    \ != \"g\" && a[i] != \"h\" && a[i] != \"i\" && a[i] != \"j\" && a[i] != \"k\"\
    \ && a[i] != \"l\" && a[i] != \"m\" && a[i] != \"n\" && a[i] != \"o\" && a[i]\
    \ != \"p\" && a[i] != \"q\" && a[i] != \"r\" && a[i] != \"s\" && a[i] != \"t\"\
    \ && a[i] != \"u\" && a[i] != \"v\" && a[i] != \"w\" && a[i] != \"x\" && a[i]\
    \ != \"y\" && a[i] != \"z\" && a[i] != \"A\" && a[i] != \"B\" && a[i] != \"C\"\
    \ && a[i] != \"D\" && a[i] != \"E\" && a[i] != \"F\" && a[i] != \"G\" && a[i]\
    \ != \"H\" && a[i] != \"I\" && a[i] != \"J\" && a[i] != \"K\" && a[i] != \"L\"\
    \ && a[i] != \"M\" && a[i] != \"N\" && a[i] != \"O\" && a[i] != \"P\" && a[i]\
    \ != \"Q\" && a[i] != \"R\" && a[i] != \"S\" && a[i] != \"T\" && a[i] != \"U\"\
    \ && a[i] != \"V\" && a[i] != \"W\" && a[i] != \"X\" && a[i] != \"Y\" && a[i]\
    \ != \"Z\")\n  #     a[i] =", "  s.chars.map{|c| c =~ /[a-z]/ ? c.upcase : c.downcase}.join\n\
    end", "  s.gsub(/\\D+/, \"\").empty? ? s.reverse : s.chars.map{|v| v =~ /\\d/\
    \ ? v : v.swapcase}.join\nend", "  s = s.to_s.reverse\n  s = s.split('').map{|a|\
    \ /[A-Z]/.match(a) ? a.downcase : /[a-z]/.match(a) ? a.upcase : a}.join('')\n\
    \  puts s\nend", "  s.reverse!\n  if s.match(/[a-zA-Z]/)\n    s.gsub!(/[a-z]/,\
    \ 'a' => 'A', 'b' => 'B', 'c' => 'C', 'd' => 'D', 'e' => 'E', 'f' => 'F', 'g'\
    \ => 'G', 'h' => 'H', 'i' => 'I', 'j' => 'J', 'k' => 'K', 'l' => 'L', 'm' => 'M',\
    \ 'n' => 'N', 'o' => 'O', 'p' => 'P', 'q' => 'Q', 'r' => 'R', 's' => 'S', 't'\
    \ => 'T', 'u' => 'U', 'v' => 'V', 'w' => 'W', 'x' => 'X', 'y' => 'Y', 'z' => 'Z')\n\
    \    s.gsub!(/[A-Z]/, 'A' => 'a', 'B' => 'b', 'C' => 'c', 'D' => 'd', 'E' => 'e',\
    \ 'F' => 'f', 'G' => 'g', 'H' => 'h', 'I' => 'i', 'J' => 'j', 'K' => 'k', 'L'\
    \ => 'l', 'M' => 'm', 'N' => 'n', 'O' => 'o', 'P' => 'p', 'Q' => 'q', 'R' => 'r',\
    \ 'S' => 's', 'T' => 't', 'U' => 'u', 'V' => 'v', 'W' => 'w', 'X' => 'x', 'Y'\
    \ => 'y', 'Z' => 'z')\n  end\n  s\nend", "    s.chars.map do |e|\n        e.match(/[a-z]/i)\
    \ ? e.swapcase : e\n    end.join\nend", "  s.reverse\nend", "  if s.empty?\n \
    \   s.reverse\n  else\n    s.chars.map { |x| x.match(/[a-zA-Z]/) ? x.swapcase\
    \ : x }.join\n  end\nend", "  arr = []\n  s.each_char do |i|\n    i.is_a?(String)\
    \ ? arr << i.swapcase : arr << i\n  end\n  arr.join.reverse\nend", "  \nend",
  "  array = s.split('')\n  rev_array = []\n  array.each do |x|\n    if x =~ /[a-z]/\n\
    \      rev_array << x.upcase\n    elsif x =~ /[A-Z]/\n      rev_array << x.downcase\n\
    \    else\n      rev_array << x\n    end\n  end\n  rev_array.join('')\nend", " \
    \ # your code here\nend", "  str = ''\n  s.each_char do |char|\n    str += if\
    \ char.match(/[a-z]/)\n              char.upcase\n            elsif char.match(/[A-Z]/)\n\
    \              char.downcase\n            else\n              char\n         \
    \   end\n  end\n  str\nend", "    return s.reverse if s.match(/[a-zA-Z]/).nil?\n\
    \    s.chars.map{|c| c.match(/[a-zA-Z]/) ? c.swapcase : c}.join\nend", "  s.reverse\n\
    end", "  i = 0\n  while i < s.length\n    if s[i] =~ /[a-zA-Z]/\n      if s[i]\
    \ == s[i].upcase\n        s[i] = s[i].downcase\n      else\n        s[i] = s[i].upcase\n\
    \      end\n    end\n    i += 1\n  end\n  s.reverse\nend", "  s.gsub(/[a-zA-Z]/,\
    \ &:swapcase)\nend", "    s.chars.map { |x| x =~ /[a-z]/ ? x.upcase : x.downcase\
    \ }.join\nend", "  s.gsub(/[a-zA-Z]/, 'a' => 'A', 'A' => 'a')\nend", "  letter\
    \ = false\n  s.each_char.map do |el|\n    if el.match(/[a-zA-Z]/)\n      letter\
    \ = true\n      el.upcase!\n    end\n  end\n  !letter ? s.reverse : s\nend", " \
    \ a = []\n  s.each_char do |char|\n    if char == char.upcase\n      a << char.downcase\n\
    \    elsif char == char.downcase\n      a << char.upcase\n    else\n      a <<\
    \ char\n    end\n  end\n  a.join('')\nend", "  s.tr(\"A-Za-z\", \"a-zA-Z\")\n\
    end", "  s.tr('a-zA-Z', 'A-Za-z')\nend", "  s.tr('a-zA-Z', 'A-Za-z')\nend", " \
    \ (a=s.chars.map{|x| x=~/[a-z]/ ? x.upcase : x =~/[A-Z]/ ? x.downcase : x}.join)=~/[a-zA-Z]/\
    \ ? a : a.reverse\nend", "  return s.reverse if s[/[a-zA-Z]/].nil?\n  s.chars.map\
    \ { |e| e[/[a-zA-Z]/] ? e.swapcase : e }.join\nend", "    if s.count(\"a-zA-Z\"\
    ) == 0\n        return s.reverse\n    else\n        new_string = s.each_char.map\
    \ do |char|\n            if char == char.upcase\n                char.downcase\n\
    \            elsif char == char.downcase\n                char.upcase\n      \
    \      else\n                char\n            end\n        end\n        return\
    \ new_string.join\n    end\nend", "  s = s.split('')\n  s.map! { |ch| ch.ord >\
    \ 64 && ch.ord < 91 ? ch.downcase : ch.upcase }.join\nend", "  s.gsub(/\\w/, &:swapcase)\n\
    end", "  s.chars.reverse.map{|char| char[/[a-z]/] ? char.upcase : char[/[A-Z]/]\
    \ ? char.downcase : char}.join\nend", "  return s.reverse if s.count(\"a-zA-Z\"\
    ) == 0\n  s.chars.map{|x|\n    if x[/[a-zA-Z]/]\n      x == x.upcase ? x.downcase\
    \ : x.upcase\n    else\n      x\n    end\n  }.join(\"\")\nend", "  if (s.count\
    \ \"A-Za-z\") > 0\n    s.swapcase\n  else\n    s.reverse\n  end\nend", "  if s.count(\"\
    a-zA-Z\") == 0\n    s.reverse\n  else\n    s.swapcase\n  end\nend", "  if s.length\
    \ == 0\n    s.reverse\n  else\n    s.reverse.tr('a-zA-Z', 'A-Za-z')\n  end\nend",
  "  m = s.chars.map { |c| c =~ /[a-z]/ ? c.upcase : c =~ /[A-Z]/ ? c.downcase : c\
    \ }\n  m.join.reverse\nend", "    return s.reverse if s.count(\"a-zA-Z\")==0\n\
    \    s.chars.map{|x| x.ord>96 && x.ord<123 ? x.upcase : x.ord>64 && x.ord<91 ?\
    \ x.downcase : x}.join\nend", "  letters = s.chars.select { |c| c.match(/[a-zA-Z]/)\
    \ }\n  letters.empty? ? s.reverse : s.tr('a-zA-Z', 'A-Za-z')\nend", "  s.chars.map{|i|\
    \ i.match(/[a-zA-Z]/) ? i.swapcase : i}.join\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
