name: HumanEval_161_solve
language: rb
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"\
  ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"\
  ))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n\
  \    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"\
  2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"\
  #$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"
completions: ["  a=[]\n  s.each_char do |i|\n    if i[/[a-zA-Z]/] \n      a << i.swapcase\n\
    \    else\n      a << i\n    end\n  end\n  a.join\nend", "  return s.reverse if\
    \ s.gsub(/[a-zA-Z]/, '').length == s.length\n  temp = ''\n  s.split('').each {\
    \ |i| temp += i.swapcase }\n  temp\nend", "  if s.gsub(/[a-zA-Z]/, '').length\
    \ == s.length\n    s.reverse\n  else\n    s.tr(\"A-Za-z\", \"a-zA-Z\")\n  end\n\
    end", "  if s.scan(/[a-zA-Z]/).empty?\n    s.reverse\n  else\n    s.chars.map\
    \ { |c| c =~ /[a-zA-Z]/ ? c.swapcase : c }.join\n  end\nend", "  (s.chars.select\
    \ { |i| i =~ /[a-zA-Z]/ }.empty?) ? (s.reverse) : (s.chars.map { |i| \n  \t(i\
    \ =~ /[a-zA-Z]/) ? ((i == i.upcase) ? (i.downcase) : (i.upcase)) : (i) }.join)\n\
    end", "    s.reverse.split('').map{|char| (char.ord.between?(65,90) || char.ord.between?(97,122))\
    \ ? char.swapcase : char}.join('')\nend", "  s.tr(\"A-Za-z\", \"a-zA-Z\")\nend",
  "  \nend", "  if s.count(\"[A-Za-z]\") == 0\n    s.reverse\n  else\n    s.tr('A-Za-z',\
    \ 'a-zA-Z')\n  end\nend", "  s.tr(\"0-9\", \"\") == \"\" ? s.reverse : s.tr(\"\
    a-zA-Z\", \"A-Za-z\")\nend", "  if s.empty?\n    return s\n  else\n    s.chars.map\
    \ { |c| (c =~ /[a-z]/i) ? c.swapcase : c }.join\n  end\nend", "  up_case = s.upcase.chars\n\
    \  down_case = s.downcase.chars\n  output = []\n  s.chars.each_with_index do |char,\
    \ index|\n    if ('a'..'z').include?(char)\n      output << up_case[index]\n \
    \   elsif ('A'..'Z').include?(char)\n      output << down_case[index]\n    else\n\
    \      output << char\n    end\n  end\n  output.join(\"\")\nend", "    s.reverse.tr('a-zA-Z',\
    \ 'A-Za-z')\nend", "  (s.scan(/[a-zA-Z]/).empty?) ? s.reverse : s.tr(\"a-zA-Z\"\
    , \"A-Za-z\")\nend", "  s.chars.map { |c| /[a-z]/ =~ c ? c.upcase : c.downcase\
    \ }.join\nend", "  if !s.split(\"\").map {|x| x =~ /[A-Za-z]/}.include?(nil)\n\
    \    s.swapcase\n  else\n    s.reverse\n  end\nend", "  s == \"\" ? \"\" : s.reverse.tr(\"\
    a-zA-Z\", \"A-Za-z\")\nend", "  s.size == 0 ? s : s.chars.map{|e| e.match(/[a-zA-Z]/)\
    \ ? e.swapcase : e}.join\nend", "  s.reverse.gsub(/[a-z]/i) { |c| c == c.upcase\
    \ ? c.downcase : c.upcase }\nend\nputs solve('#a@C')", "  # your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
