name: HumanEval_149_sorted_list_sum
language: rb
prompt: "# Write a function that accepts an array of strings as a parameter,\n# deletes\
  \ the strings that have odd lengths from it,\n# and returns the resulted array with\
  \ a sorted order,\n# The array is always an array of strings and never an array\
  \ of numbers,\n# and it may contain duplicates.\n# The order of the array should\
  \ be ascending by length of each word, and you\n# should return the array sorted\
  \ by that rule.\n# If two words have the same length, sort the array alphabetically.\n\
  # The function should return an array of strings in sorted order.\n# You may assume\
  \ that all words will have the same length.\n# For example:\n# >>> list_sort.call([\"\
  aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\"\
  , \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n\
  \    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"\
  aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"\
  school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\"\
  , \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"\
  d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"\
  AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\"\
  , \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"],\
  \ candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"
completions: ["  lst.sort.select { |word| word.length.even? }\nend", "  return []\
    \ if lst.empty?\n  lst.sort_by(&:length).select { |i| i.length.even? }\nend",
  "  lst.sort_by { |word| [word.length, word] }\nend", "  lst = lst.map{|str| str.to_i}\n\
    \  length = lst.length\n  if length == 0\n    return 0\n  end\n  if length ==\
    \ 1\n    return lst[0]\n  end\n  lst.inject(:+)\nend", "  sum = 0\n  lst.sort.each\
    \ { |num| sum += num }\n  sum\nend", "  lst.reduce(0) { |memo, obj| memo + obj.length\
    \ }\nend", "  lst.select { |string| string.length.even? }.sort_by { |string| string.length\
    \ }\nend", "  lst.select { |e| e.length.even? }.sort_by { |e| e.downcase }\nend",
  "  lst.select{|x| x.length.even?}.sort_by{|x| x.length}.sort\nend", "    res = []\n\
    \    lst.sort_by!{|word| word.length}\n    lst.each do |word|\n        res <<\
    \ word if word.length.even?\n    end\n    return res\nend", "  temp = []\n  lst.each\
    \ do |a|\n    temp << a.length\n  end\n  temp.sort!.uniq!\n  res = []\n  temp.each\
    \ do |a|\n    lst.each do |x|\n      if x.length == a\n        res << x\n    \
    \  end\n    end\n  end\n  res\nend", "  return lst.select { |x| x.length.even?\
    \ }.sort\nend", "  new_lst = lst.select { |word| word.length.even? }\n  new_lst.sort_by\
    \ { |word| word.length }\nend", "  lst.map(&:length).select(&:odd?).sort.reduce(:+)\n\
    end", "  sum = 0\n  lst.each do |element|\n    sum += element\n  end\n  sum\n\
    end", "  # lst.map { |s| s.length }.sort\n  lst.map { |s| s.length }.uniq.sort\n\
    end", "  lst.sort_by! { |word| word.length }\n  result = []\n  lst.each do |word|\n\
    \    if word.length.even?\n      result << word\n    end\n  end\n  result\nend",
  "  lst.sort.reverse\nend", "  return [] if lst.empty?\n  lst.select { |str| str.length.even?\
    \ }.sort { |a, b| a <=> b }\nend", "  lst.select { |e| e.length.even? }.sort {\
    \ |a, b| a <=> b }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
