name: HumanEval_139_special_factorial
language: rb
prompt: "# The Brazilian factorial is defined as:\n# brazilian_factorial(n) = n! *\
  \ (n-1)! * (n-2)! * ... * 1!\n# where n > 0\n# For example:\n# >>> special_factorial.call(4)\n\
  # 288\n# The function will receive an integer as input and should return the special\n\
  # factorial of this integer.\ndef special_factorial(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_special_factorial\n\
  \    candidate = method(:special_factorial)\n    assert_equal(288, candidate.call(4))\n\
  \    assert_equal(34560, candidate.call(5))\n    assert_equal(125411328000, candidate.call(7))\n\
  \    assert_equal(1, candidate.call(1))\n  end\nend\n"
completions: ["    n.downto(1).reduce(:*)\nend\n ", "  # TODO: your code here!\nend",
  "  factorial = n\n  if n > 1\n    factorial = n * special_factorial(n-1)\n  end\n\
    \  factorial\nend", "  res = 1\n  for i in 1..n\n    res *= factorial(i)\n  end\n\
    \  res\nend", "  factorial = n.downto(1).inject(:*)\n  res = 1\n  n.downto(1).each\
    \ do |i|\n    res *= factorial\n    factorial /= i\n  end\n  res\nend", end, " \
    \ return nil if n < 1\n  (1..n).to_a.inject(:*) * (1..n-1).to_a.inject(:*)\nend",
  "\treturn nil if n < 1\n\tn! * (n-1)! * (n-2)! * ... * 1!\nend", "  # TODO: Your\
    \ code here\nend", "  return 1 if n == 0\n  factorial = 1\n  while n > 0\n   \
    \ factorial *= factorial_iterative(n)\n    n -= 1\n  end\n  factorial\nend", " \
    \ (1..n).reduce(:*) * (1..n-1).reduce(:*)\nend", "  # your code here\nend", " \
    \ factorials = []\n  (1..n).each do |i|\n    factorials << i\n  end\n  factorials.inject(:*)\n\
    end", "  return nil if n <= 0\n  (1..n).inject(:*) * (1..n-1).inject(:*)\nend",
  "  raise ArgumentError, 'input must be positive' if n < 1\n  n <= 1 ? 1 : n * special_factorial(n\
    \ - 1)\nend", "  # Write your code here\nend", "  if n == 0\n    raise ArgumentError\n\
    \  end\n  result = 1\n  (1..n).each do |k|\n    result *= k\n  end\n  result\n\
    end", "  n < 0 ? 1 : n * special_factorial(n - 1)\nend", "  return 1 if n == 0\n\
    \  (1..n).inject(:*) * special_factorial(n-1)\nend", "  # If the input is invalid,\
    \ return nil\n  if n < 1\n    return nil\n  end", "  if n > 0\n    (1..n).reduce(:*)\
    \ * (1..n-1).reduce(:*)\n  else\n    n\n  end\nend", "  # Write your code here\n\
    end", "  product = 1\n  while n > 0\n    product *= factorial(n)\n    n -= 1\n\
    \  end\n  product\nend", "  # Your code here\nend", "  return nil if n < 1\n \
    \ (1..n).reduce(:*)\nend", "  if n == 0\n    1\n  else\n    n * special_factorial(n-1)\n\
    \  end\nend", "  return n.downto(1).inject(:*)\nend\nputs special_factorial(4)",
  "  n.downto(1).reduce(:*) || 1\nend", "  sf = 1\n  n.downto(1) { |i| sf *= i }\n\
    \  (n-1).downto(1) { |i| sf *= i }\n  return sf\nend", "  a = (1..n).to_a\n  result\
    \ = a.inject(:*)\n  a.reverse!\n  a.each do |i|\n    result *= i\n  end\n  result\n\
    end", "  # TODO: implement the special_factorial method\n  raise NotImplementedError\n\
    end", "  n < 1 ? n : n * special_factorial(n - 1)\nend", "  return n * (n-1) *\
    \ (n-2) * (n-3) * (n-4) * (n-5) * (n-6) * (n-7) * (n-8) * (n-9) * (n-10) * (n-11)\
    \ * (n-12) * (n-13) * (n-14) * (n-15) * (n-16) * (n-17) * (n-18) * (n-19) * (n-20)\n\
    end", "  n < 1 ? 1 : n * special_factorial(n - 1)\nend", "  total = 1\n  while\
    \ n > 0\n    total *= factorial(n)\n    n -= 1\n  end\n  total\nend", "  total\
    \ = 1\n  while n > 0\n    total *= n\n    n -= 1\n  end\n  total\nend", "  # First\
    \ we use the vanilla factorial to get the 'original' factorial.\n  original_factorial\
    \ = (1..n).inject(:*)", "  value = 1\n  n.downto(1) do |i|\n    value *= i\n \
    \ end\n  value\nend", "  special_factorial_recursive(n)\nend", "  return nil if\
    \ n <= 0\n  (1..n).inject(:*) * (1..n-1).inject(:*)\nend", "  n < 1 ? nil : n.downto(1).inject(:*)\n\
    end", end, "  n < 0 ? nil : n.downto(1).reduce(:*)\nend", "  return 1 if n < 2\n\
    \  (1..n).reduce(:*) * special_factorial(n - 1)\nend", "  product = 1\n  1.upto(n)\
    \ do |i|\n    product *= i * factorial(i - 1)\n  end\n  product\nend", "  return\
    \ 1 if n <= 1\n  (1..n).inject(:*) * special_factorial(n - 1)\nend", "  # Write\
    \ your code here\nend", "  return 1 if n == 0\n  n * special_factorial(n - 1)\n\
    end", "  factorial = 1\n  if n == 0\n    factorial = 1\n  elsif n == 1\n    factorial\
    \ = 1\n  else\n    (1..n).each do |num|\n      factorial *= num\n    end\n  end\n\
    \  factorial\nend", "  unless n > 0\n    throw \"Number must be greater than 0\"\
    \n  end\n  factorial(n) * factorial(n-1)\nend", "  raise ArgumentError if n <=\
    \ 0\n  (1..n).reduce(:*) * factorial(n - 1)\nend", "  (1..n).to_a.inject(:*) *\
    \ (1..n-1).to_a.inject(:*)\nend", "  counter = n\n  total = 1\n  while counter\
    \ > 0\n    total *= (factorial(counter))\n    counter -= 1\n  end\n  total\nend",
  "  raise ArgumentError if n <= 0\n  res = 1\n  i = n\n  while i > 0\n    res *=\
    \ factorial(i)\n    i -= 1\n  end\n  res\nend", "  n < 0 ? nil : n.downto(1).inject(:*)\n\
    end", "  # Put your code here\nend", "  (1..n).inject(:*) || 1\nend", "  i = n\
    \ - 1\n  while i > 0\n    n *= i\n    i -= 1\n  end\n  n\nend", "  brazilian_factorial(n)\n\
    end", "  return 1 if n <= 1\n  (1..n).to_a.inject(:*) * special_factorial(n -\
    \ 1)\nend", "  n == 0 ? 1 : n * special_factorial(n - 1)\nend", "  if n > 0\n\
    \    total = 1\n    n.downto(1) do |x|\n      x.downto(1) do |y|\n        total\
    \ *= y\n      end\n    end\n    total\n  else\n    0\n  end\nend", "    # Return\
    \ the brazilian factorial of n\n    if n <= 1\n        return 1\n    else\n  \
    \      return n * special_factorial(n-1)\n    end\nend", "  # Your code here\n\
    end", "  #if n > 0\n    factorial = (1..n).inject(:*)\n    factorial * special_factorial(n-1)\n\
    \  #else\n    #factorial = 1\n  #end\nend", "  #factory of n\n  n_factorial =\
    \ 1\n  while n > 0\n    n_factorial *= n\n    n -= 1\n  end\n  #factory of (n-1)\n\
    \  n_1_factorial = 1\n  while n > 1\n    n_1_factorial *= n - 1\n    n -= 1\n\
    \  end\n  #factory of (n-2)\n  n_2_factorial = 1\n  while n > 2\n    n_2_factorial\
    \ *= n - 2\n    n -= 1\n  end\n  #factory of (n-3)\n  n_3_factorial = 1\n  while\
    \ n > 3\n    n_3_factorial *= n - 3\n    n -= 1\n  end\n  #factory of (n-4)\n\
    \  n_4_factorial = 1\n  while n > 4\n    n_4_factorial *= n - 4\n    n -= 1\n\
    \  end\n  #factory of (n-5)\n  n_5_factorial = 1\n  while n > 5\n    n_5_factorial\
    \ *= n - 5\n    n -= 1\n  end\n  #brazilian factorial\n  n_factorial * n_1_factorial\
    \ * n_2_factorial * n_3_factorial * n_4_factorial * n_5_factorial\nend", "  return\
    \ 1 if n == 0\n  (1..n).reduce(:*) * special_factorial(n - 1)\nend", "  if n <=\
    \ 1\n    1\n  else\n    n * special_factorial(n-1)\n  end\nend", "  if n == 0\n\
    \    1\n  else\n    n * special_factorial(n-1)\n  end\nend", "\t# write your code\
    \ here!\nend", "  @fac = 1\n  for i in 1..n\n    @fac *= i\n  end\n  return @fac\n\
    end", "  (1..n).inject(:*) * (1..n-1).inject(:*)\nend", "  return 1 if n == 0\n\
    \  n*special_factorial(n-1)\nend", "  if n == 0\n    1\n  else\n    n * special_factorial(n-1)\n\
    \  end\nend", "  (1..n).inject(:*) * factorial(n-1)\nend", "  (1..n).inject(:*)\
    \ * (1..n-1).inject(:*)\nend", "  return 1 if n <= 1\n  n * special_factorial(n\
    \ - 1)\nend", "  # Write your code here\nend", "  # Write your code here\nend",
  "  if n == 0\n    return 1\n  else\n    return factorial(n) * special_factorial(n-1)\n\
    \  end\nend", "  return 1 if n == 0\n  n * special_factorial(n - 1)\nend", " \
    \ factorial = 1\n  for i in 1..n\n    factorial *= i\n  end\n  factorial\nend",
  "  1.upto(n).map{|i| (1..i).inject(:*)}.inject(:*)\nend", "  # 1*2*3*4\n  f = 1\n\
    \  while n > 0\n    f *= n\n    n -= 1\n  end\n  return f\nend", "  return (1..n).inject(:*)\
    \ * (1..n-1).inject(:*) * (1..n-2).inject(:*)\nend", "  (1..n).inject(:*) * (1..n-1).inject(:*)\n\
    end", "  raise ArgumentError if n <= 0\n  product = 1\n  n.downto(1) { |i| product\
    \ *= i }\n  product\nend", "  return 1 if n < 2\n  n * special_factorial(n - 1)\n\
    end", "  return nil if n <= 0\n  (1..n).reduce(:*)\nend", "  (1..n).reduce(:*)\
    \ * (1..n-1).reduce(:*)\nend", "  return 'nil' if n <= 0\n  (1..n).reduce(:*)\
    \ * (1..n-1).reduce(:*)\nend", "  raise ArgumentError if n < 0\n  (1..n).inject(:*)\
    \ * factorial(n - 1)\nend", "  return 1 if n <= 1\n  n * special_factorial(n -\
    \ 1)\nend", "  arr = (1..n).to_a\n  final = 1\n  until arr.length == 0\n    final\
    \ *= arr.reduce(:*)\n    arr.pop\n  end\n  final\nend", "  if n == 0\n    1\n\
    \  else\n    factorial(n) * special_factorial(n-1)\n  end\nend", "  #Your code\
    \ here\nend", "  special_factorial_iter(1, 1, n)\nend", "  return nil if n <=\
    \ 0\n  (1..n).inject(:*) * (1..n-1).inject(:*)\nend", "  return 1 if n == 0\n\
    \  brazilian_factorial(n)\nend", "  brazilian_factorial = 1\n  i = 1\n  while\
    \ i <= n\n    brazilian_factorial *= i * factorial(i)\n    i += 1\n  end\n  brazilian_factorial\n\
    end", "  factorials = factorial_list(n)\n  factorials.inject(:*)\nend", "  n >\
    \ 0 ? n * special_factorial(n-1) : 1\nend", "  (1..n).reduce(:*) * (1..n-1).reduce(:*)\n\
    end", "  @ans = 1\n  n.downto(1) do |i|\n    @ans *= i\n  end\n  return @ans\n\
    end", "  if n == 0\n    return 1\n  else\n    n * special_factorial(n-1)\n  end\n\
    end", "  if n > 0\n    return ((1..n).to_a.inject(:*))*special_factorial(n-1)\n\
    \  else\n    return 1\n  end\nend", "  raise ArgumentError if n < 0\n  return\
    \ 1 if n == 0", "  factorial = 1\n  (1..n).each do |i|\n    factorial *= i\n \
    \ end\n  factorial\nend", "  # TODO: Compute the special factorial of n\nend",
  "  # TODO: implement\nend", "  i = 1\n  factorial = 1\n  while i <= n\n    factorial\
    \ *= i * (i-1)\n    i += 1\n  end\n  factorial\nend", "  return 1 if n == 0\n\
    \  (1..n).inject(:*) * special_factorial(n-1)\nend", "  # put your code here\n\
    end", "  # your code here\nend", "  # Write your code here\nend", "  (1..n).inject(:*)\
    \ || 1\nend", "  n > 0 ? n * special_factorial(n-1) : 1\nend", "  # your code\
    \ here\nend", "  return 1 if n <= 1\n  (1..n).reduce(:*) * special_factorial(n\
    \ - 1)\nend", "  # Your code here\nend", '  n * n * n * n * n * n * n * n * n
    * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *
    n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
    * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *
    n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
    * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *
    n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
    * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *
    n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
    * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *
    n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
    * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *
    n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
    * n * n * n * n * n * n * n * n * n * n * n * n *', end, "  if n == 0\n    return\
    \ 0\n  end\n  x = (1..n).reduce(:*)\n  y = special_factorial(n-1)\n  if y == 0\n\
    \    return x\n  else\n    return x * y\n  end\nend", "  # TODO: return the special\
    \ factorial of n\n  if n == 0 || n == 1\n    return 1\n  end\n  return n * special_factorial(n-1)\n\
    end", "  # Add your solution here!\nend", "  #your code here\nend", "  return\
    \ 1 if n == 0\n  return n * special_factorial(n-1)\nend", "\t# this code will\
    \ run only on submission\nend", "  res = 1\n  (1..n).each do |num|\n    res *=\
    \ num\n  end\n  res\nend", "  (1..n).inject(:*)\nend", "  n_factorial = (1..n).inject(:*)\n\
    \  (1..n-1).inject(1) { |acc, i| acc *= n_factorial / i }\nend", "  (1..n).reduce(:*)\
    \ * special_factorial(n - 1) if n > 0\nend", "  return 1 if n <= 1\n  n * special_factorial(n\
    \ - 1)\nend", "  n <= 1 ? 1 : n * special_factorial(n - 1)\nend", "  n.downto(1).reduce(:*)\n\
    end", "  raise \"This is not a positive integer\" unless n.is_a?(Integer) && n\
    \ > 0\n  n.downto(1).inject(:*)\nend", "  n > 0 ? n * special_factorial(n-1) :\
    \ 1\nend", "  s = 1\n  for i in 1..n\n    s *= i\n  end\n  s\nend", "    # Write\
    \ your code here...\nend", "  # Your code here\nend", "  return 1 if n <= 1\n\
    \  n * special_factorial(n - 1)\nend", "  return nil if n <= 0\n  (1..n).to_a.inject(:*)\
    \ * (1..n-1).to_a.inject(:*)\nend", "  (1..n).inject(:*) * (1..n - 1).inject(:*)\n\
    end", "  (1..n).reduce(:*) * (1..n - 1).reduce(:*)\nend", "  i, factorial = n,\
    \ 1\n  while i > 0\n    factorial *= i\n    i -= 1\n  end\n  factorial\nend",
  "  # Special factorial is multiplying factorial of n to every other \n  # descending\
    \ factorial of n\n  (1..n).reduce(:*) * (1..n-1).reduce(:*) * (1..n-2).reduce(:*)\n\
    end\nputs special_factorial(4)", "  # write your code here\nend", "  factorial\
    \ = 1\n  (1..n).each do |i|\n    factorial *= i\n  end\n  factorial\nend", " \
    \ (1..n).reduce(:*) * (1..n - 1).reduce(:*) * (1..n - 2).reduce(:*)\nend", " \
    \ return 1 if n == 0\n  n * special_factorial(n - 1)\nend", "  raise ArgumentError\
    \ unless n > 0\n  (1..n).reduce(:*) * (1..n - 1).reduce(:*)\nend", "  return n\
    \ == 0 ? 1 : n * special_factorial(n - 1)\nend", "  brazilian_factorial(n)\nend",
  "  x = 1\n  (1..n).each do |i|\n    x *= (i * factorial(i-1))\n  end\n  x\nend",
  "  # Fill in this method\nend", "    raise(ArgumentError, \"The argument must be\
    \ greater than 0\") if n <= 0\n    return 1 if n == 1\n    return n * special_factorial(n-1)\n\
    end", "  return nil if n < 1\n  (1..n).inject(:*) * (1..n-1).inject(:*)\nend",
  "  factorial(n) * factorial(n-1)\nend", "\t# TODO: return the special factorial\
    \ of n\n\tif n > 0\n\t\treturn n * (n-1) * (n-2) * special_factorial(n-3)\n\t\
    else\n\t\treturn 1\n\tend\nend", "\t\nend", "  array = []\n  total = 1\n  if n\
    \ == 0\n    array << total\n  else\n    n.times do |i|\n      total *= (n - i)\n\
    \      array << total\n    end\n  end\n  array.inject(:*)\nend", "  factorial(n)\
    \ * factorial(n-1)\nend", "\tif n == 0\n\t\treturn 1\n\telse\n\t\treturn n * special_factorial(n-1)\n\
    \tend\nend\nputs special_factorial(4)", "  return unless n.is_a?(Integer)\n  return\
    \ 0 if n <= 0\n  (1..n).inject(:*) * (1..n-1).inject(:*)\nend", "  range = (1..n).to_a\n\
    \  range.inject(:*) * range.pop.inject(:*)\nend", "  # write your code here\n\
    end", "  return 1 if n == 0\n  n * special_factorial(n - 1)\nend", "    n.downto(1).inject(:*)\n\
    end", "  special_factorial = 1\n  special_factorial = (1..n).reduce(:*) * special_factorial\n\
    \  special_factorial\nend", "  n.downto(1).reduce(:*) || 1\nend", "  (1..n).inject(:*)\n\
    end", "  n.downto(1).reduce(:*)\nend", "  # WRITE YOUR CODE HERE\nend", "  if\
    \ n <= 1\n    return 1\n  else\n    return n * special_factorial(n-1)\n  end\n\
    end", "  return 1 if n == 0\n  n * special_factorial(n - 1)\nend", "  raise ArgumentError\
    \ if n < 0\n  raise ArgumentError if n == 0\n  (1..n).inject(:*) * (1..n-1).inject(:*)\n\
    end", "  return 1 if n == 0\n  (1..n).reduce(:*) * special_factorial(n - 1)\n\
    end", "  return 1 if n <= 1\n  n * special_factorial(n - 1)\nend", "  n > 0 ?\
    \ n.downto(1).reduce(:*) : 1\nend", "  if n <= 0\n    return 0\n  else\n    factorial\
    \ = 1\n    (1..n).each do |number|\n      factorial *= number\n    end\n    (1..n-1).each\
    \ do |number|\n      factorial *= number\n    end\n    return factorial\n  end\n\
    end", "  # TODO: implement this function\nend", "  if n < 0\n    raise \"Number\
    \ must be positive\"\n  end\n  multiplier = 1\n  if n == 0\n    return multiplier\n\
    \  end\n  start = n\n  while start >= 1\n    multiplier *= start\n    start -=\
    \ 1\n  end\n  return multiplier\nend", "  # YOUR CODE HERE\nend", "  (1..n).reduce(:*)\
    \ * (1..n-1).reduce(:*)\nend", "  raise \"n must be positive\" if n < 1\n  return\
    \ 1 if n == 1\n  (1..n).inject(:*) * special_factorial(n-1)\nend", "    n.downto(1).reduce(:*)\n\
    end", "  (1..n).inject(:*) * (1..n-1).inject(:*)\nend\nspecial_factorial(5)",
  "  # your code here\nend", "  return 1 if n == 0\n  n * special_factorial(n - 1)\n\
    end", "  factorial = 1\n  for i in (1..n)\n    factorial *= i\n  end\n  return\
    \ factorial\nend", "  brazilian_factorial = 1\n  while n > 0\n    brazilian_factorial\
    \ *= factorial(n)\n    n -= 1\n  end\n  brazilian_factorial\nend", "  raise InvalidInputError,\
    \ \"The input must be an integer.\" unless n.is_a? Integer\n  raise InvalidInputError,\
    \ \"The input must be positive.\" unless n >= 0\n  n.downto(1).inject(:*) || 1\n\
    end", "  if n == 0\n    1\n  else\n    total = 1\n    for i in 1..n\n      total\
    \ *= i\n    end\n    total\n  end\nend", "  if n < 1\n    raise ArgumentError.new(\"\
    Wrong argument\")\n  end\n  count = n\n  sum = 1\n  while count > 0\n    sum *=\
    \ count\n    count -= 1\n  end\n  sum\nend", "  return 1 if n <= 1\n  n * special_factorial(n\
    \ - 1)\nend", "  if n == 0\n    1\n  else\n    n * special_factorial(n-1)\n  end\n\
    end", "  # Your code here\nend", "  return nil if n <= 0\n  (1..n).reduce(:*)\
    \ * (1..n-1).reduce(:*)\nend", "  brazilian_factorial = 1\n  while n > 0\n   \
    \ brazilian_factorial *= factorial(n)\n    n -= 1\n  end\n  brazilian_factorial\n\
    end", "  return \"error\" if n == 0 || n < 0\n  factorial = 1\n  (1..n).each do\
    \ |i|\n    factorial *= i\n  end\n  factorial * special_factorial(n-1)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
