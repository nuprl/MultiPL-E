name: HumanEval_20_find_closest_elements
language: rb
prompt: "# From a supplied array of numbers (of length at least two) select and return\
  \ two that are the closest to each\n# other and return them in order (smaller number,\
  \ larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  # [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
  # [2.0, 2.0]\ndef find_closest_elements(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n\
  \    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0,\
  \ 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2,\
  \ 3.1, 4.1, 5.1]))\n  end\nend\n"
completions: ["  distances = {}\n  numbers.each_with_index do |number, index|\n  \
    \  distances[index] = number\n  end\n  sorted_distances = distances.sort_by {\
    \ |distance, number| number }\n  sorted_distances.each_with_index do |element,\
    \ index|\n    current_number = element[1]\n    if index == 0\n      distances[element[0]]\
    \ = sorted_distances[index + 1][1] - current_number\n    elsif index == sorted_distances.length\
    \ - 1\n      distances[element[0]] = current_number - sorted_distances[index -\
    \ 1][1]\n    else\n      distances[element[0]] = [sorted_distances[index + 1][1]\
    \ - current_number, current_number - sorted_distances[index - 1][1]].min\n   \
    \ end\n  end\n  closest_distance = distances.min_by { |k, v| v }[1]\n  closest_elements\
    \ = distances.select { |k, v| v == closest_distance }\n  closest_elements = closest_elements.sort_by\
    \ { |k, v| k }\n  element_one = numbers[closest_elements[0][0]]\n  element_two\
    \ = numbers[closest_elements[1][0]]\n  [element_one, element_two]\nend", "  if\
    \ numbers.length < 2\n    return nil\n  end\n  closest_diff = nil\n  closest_element_1\
    \ = nil\n  closest_element_2 = nil\n  numbers.each_with_index do |element, index|\n\
    \    if index != numbers.length - 1\n      if closest_diff == nil || closest_diff\
    \ > (element - numbers[index + 1]).abs\n        closest_diff = (element - numbers[index\
    \ + 1]).abs\n        closest_element_1 = element\n        closest_element_2 =\
    \ numbers[index + 1]\n      end\n    end\n  end\n  [closest_element_1, closest_element_2]\n\
    end", "  smallest_difference = numbers[0] - numbers[1]\n  closest_elements = [numbers[0],\
    \ numbers[1]]\n  for i in (0..numbers.length-2)\n    for j in (i+1..numbers.length-1)\n\
    \      difference = numbers[i] - numbers[j]\n      if difference.abs < smallest_difference.abs\n\
    \        smallest_difference = difference\n        closest_elements = [numbers[i],\
    \ numbers[j]]\n      end\n    end\n  end\n  closest_elements\nend", "  min = numbers[1]\
    \ - numbers[0]\n  pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do\
    \ |a, i|\n    i.upto(numbers.length-1) do |j|\n      if numbers[j] - a < min\n\
    \        min = numbers[j] - a\n        pair = [a, numbers[j]]\n      end\n   \
    \ end\n  end\n  return pair\nend", "  hash = Hash.new()\n  numbers.each_with_index\
    \ { |x,i| hash[x] = i }\n  numbers.sort!\n  smallest_diff = numbers[1] - numbers[0]\n\
    \  closest_elements = [numbers[0], numbers[1]]\n  for i in 1..numbers.length-1\n\
    \    if (numbers[i] - numbers[i-1]) < smallest_diff\n      smallest_diff = numbers[i]\
    \ - numbers[i-1]\n      closest_elements = [numbers[i-1], numbers[i]]\n    end\n\
    \  end\n  closest_elements\nend", "  result = []\n  numbers.each_with_index do\
    \ |number, index|\n    next_number = numbers[index + 1]\n    if next_number\n\
    \      diff_1 = (number - next_number).abs\n      diff_2 = (number - result[0]).abs\n\
    \      if diff_1 < diff_2\n        result = [number, next_number]\n      end\n\
    \    end\n  end\n  result\nend", "  numbers.map.with_index do |number, index|\n\
    \    next if index == 0\n    if index == numbers.length - 1\n      [number, numbers[index\
    \ - 1]]\n    else\n      diff_current = number - numbers[index - 1]\n      diff_next\
    \ = numbers[index + 1] - number\n      diff_current < diff_next ? [numbers[index\
    \ - 1], number] : [number, numbers[index + 1]]\n    end\n  end.compact.min_by\
    \ { |pair| pair[1] - pair[0] }\nend", "\tsmallest = numbers[0]\n\tbiggest = numbers[1]\n\
    \tnumbers.each_with_index do |num, index|\n\t\tif index != 0 && index != 1\n\t\
    \t\tif (num - numbers[index - 1]).abs < (biggest - smallest).abs\n\t\t\t\tsmallest\
    \ = numbers[index - 1]\n\t\t\t\tbiggest = num\n\t\t\tend\n\t\tend\n\tend\n\t[smallest,\
    \ biggest]\nend", "  numbers.sort!\n  distance = numbers[1] - numbers[0]\n  closest_numbers\
    \ = [numbers[0], numbers[1]]\n  for i in 1..numbers.length-2\n    if distance\
    \ > numbers[i+1] - numbers[i]\n      distance = numbers[i+1] - numbers[i]\n  \
    \    closest_numbers = [numbers[i], numbers[i+1]]\n    end\n  end\n  closest_numbers\n\
    end\nputs find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\nputs find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])", "\tnumbers = numbers.map(&:to_f)\n\tresult = [numbers[0],\
    \ numbers[1]]\n\t\n\tnumbers.each_with_index do |num, idx|\n\t\tbreak if idx >=\
    \ numbers.length - 1\n\t\t\n\t\tif (num - numbers[idx + 1]).abs < (result[0] -\
    \ result[1]).abs\n\t\t\tresult = [num, numbers[idx + 1]]\n\t\tend\n\tend\n\t\n\
    \treturn result\nend", "  length = numbers.length\n  raise ArgumentError, \"arguments\
    \ should be an array with length at least 2\" if length < 2\n  min_num, min_index\
    \ = numbers[0], 0\n  max_num, max_index = numbers[0], 0\n  # find out maximum\
    \ and minimum number from an array\n  numbers.each_with_index do |n, i|\n    if\
    \ n < min_num\n      min_num = n\n      min_index = i\n    end\n    if n > max_num\n\
    \      max_num = n\n      max_index = i\n    end\n  end\n  # current min and max\
    \ distance\n  min_dis = 0\n  max_dis = 0\n  # find out maximum and minimum distance\n\
    \  numbers.each_with_index do |n, i|\n    if i != min_index && i != max_index\n\
    \      if (n - min_num).abs < (n - max_num).abs\n        dis = (n - min_num).abs\n\
    \        if dis > min_dis\n          min_dis = dis\n        end\n      else\n\
    \        dis = (n - max_num).abs\n        if dis > max_dis\n          max_dis\
    \ = dis\n        end\n      end\n    end\n  end\n  # compare min_dis and max_dis\n\
    \  if min_dis > max_dis\n    return [min_num, max_num]\n  else\n    return [max_num,\
    \ min_num]\n  end\nend", "\tp numbers\n\tmin_diff = numbers[0] - numbers[1]\n\t\
    numbers.each_with_index do |num, index|\n\t\tif index != numbers.length - 1\n\t\
    \t\tif (num - numbers[index + 1]).abs < min_diff\n\t\t\t\tmin_diff = (num - numbers[index\
    \ + 1]).abs\n\t\t\t\tclosest_num = [num, numbers[index + 1]]\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn closest_num\nend", "  difference = 100000\n  # iterate over\
    \ each number\n  numbers.each_with_index do |number, index|\n    # iterate over\
    \ the rest of the numbers\n    numbers[index + 1..-1].each do |next_number|\n\
    \      if difference > (number - next_number).abs\n        difference = (number\
    \ - next_number).abs\n        closest_pair = [number, next_number]\n      end\n\
    \    end\n  end\n  return closest_pair\nend", "  numbers.combination(2).min_by\
    \ { |x, y| (x - y).abs }\nend", "  numbers.sort!\n  diff = []\n  numbers.each_cons(2)\
    \ do |pair|\n    diff << (pair[1] - pair[0]).abs\n  end\n  smallest_diff = diff.min\n\
    \  smallest_diff_index = diff.index(smallest_diff)\n  [numbers[smallest_diff_index],\
    \ numbers[smallest_diff_index + 1]]\nend", "  numbers.sort\n  min_diff = numbers[-1]\
    \ - numbers[0]\n  closest_elements = [numbers[0], numbers[1]]\n  numbers.each_with_index\
    \ do |number, index|\n    next if index == numbers.length - 1\n    if numbers[index\
    \ + 1] - number < min_diff\n      min_diff = numbers[index + 1] - number\n   \
    \   closest_elements = [number, numbers[index + 1]]\n    end\n  end\n  closest_elements\n\
    end", "  numbers.sort!\n  diffs = []\n  numbers.each_cons(2) do |x, y|\n    diffs\
    \ << { diff: y - x, numbers: [x, y] }\n  end\n  min_diff = diffs.min_by { |diff|\
    \ diff[:diff] }\n  min_diff[:numbers]\nend", "  numbers.sort!\n  closest_pair\
    \ = []\n  last_distance = nil\n  numbers.each_cons(2) do |pair|\n    distance\
    \ = pair[1] - pair[0]\n    if last_distance.nil?\n      closest_pair = pair\n\
    \      last_distance = distance\n    elsif distance < last_distance\n      closest_pair\
    \ = pair\n      last_distance = distance\n    end\n  end\n  closest_pair\nend",
  "  numbers = numbers.sort\n  min_diff = Float::INFINITY\n  min_elements = []\n \
    \ numbers.each_with_index do |n, i|\n    if i == numbers.length - 1\n      break\n\
    \    end\n    if numbers[i + 1] - n < min_diff\n      min_diff = numbers[i + 1]\
    \ - n\n      min_elements = [n, numbers[i + 1]]\n    end\n  end\n  min_elements\n\
    end", "  numbers.combination(2).reduce do |memo, pair|\n    memo.first.reduce(pair)\
    \ do |memo, other|\n      (memo.last - memo.first).abs < (other.last - other.first).abs\
    \ ? memo : other\n    end\n  end\nend", "  numbers.sort!\n  min_dist = numbers[0]\
    \ - numbers[1]\n  min_dist = numbers[1] - numbers[0] if min_dist < 0\n  result\
    \ = []\n  numbers.each_with_index do |e, i|\n    if i == numbers.length - 1\n\
    \      break\n    end\n    if (e - numbers[i + 1]).abs < min_dist\n      min_dist\
    \ = (e - numbers[i + 1]).abs\n      result = [e, numbers[i + 1]]\n    end\n  end\n\
    \  result\nend", "  numbers.combination(2).min_by { |a, b| (a - b).abs }\nend",
  '  sorted_numbers = numbers.sort', "  best_pair = numbers.combination(2).min_by\
    \ { |a, b| (a - b).abs }\n  return best_pair if best_pair[0] != best_pair[1]\n\
    \  best_pair.reverse\nend", "  # first sort the array\n  numbers.sort!", "  return\
    \ [numbers[0], numbers[1]] if numbers.length == 2\n  raise ArgumentError.new('Please\
    \ provide an array of numbers') unless numbers.is_a?(Array) && numbers.length\
    \ > 1\n  raise ArgumentError.new('Numbers should be floats') unless numbers.select\
    \ { |num| num.is_a?(Float) }.length == numbers.length\n  closest_diff = (numbers[0]\
    \ - numbers[1]).abs\n  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index\
    \ do |number, index|\n    next if index == numbers.length - 1\n    diff = (number\
    \ - numbers[index + 1]).abs\n    closest_pair = [number, numbers[index + 1]] if\
    \ diff < closest_diff\n    closest_diff = diff if diff < closest_diff\n  end\n\
    \  closest_pair\nend", "  numbers.combination(2).min_by { |x, y| (x - y).abs }\n\
    end", "  closest_diff = Float::INFINITY\n  closest_pair = []\n  x = 0\n  while\
    \ x < numbers.length - 1\n    if numbers[x] > numbers[x + 1]\n      y = x + 1\n\
    \      while y < numbers.length\n        z = y + 1\n        while z < numbers.length\n\
    \          diff = (numbers[y] - numbers[x]).abs\n          if diff < closest_diff\n\
    \            closest_diff = diff\n            closest_pair = [numbers[x], numbers[y]]\n\
    \          end\n          z += 1\n        end\n        y += 1\n      end\n   \
    \ else\n      diff = (numbers[x + 1] - numbers[x]).abs\n      if diff < closest_diff\n\
    \        closest_diff = diff\n        closest_pair = [numbers[x], numbers[x +\
    \ 1]]\n      end\n    end\n    x += 1\n  end\n  closest_pair\nend", "  closest_elements\
    \ = []\n  numbers.sort!", "  i = 0\n  closest_elements = [numbers[0], numbers[1]]\n\
    \  closest_difference = (numbers[0] - numbers[1]).abs\n  numbers.each do |num|\n\
    \    j = 0\n    while j < numbers.length - 1\n      difference = (num - numbers[j\
    \ + 1]).abs\n      if difference < closest_difference\n        closest_elements\
    \ = [num, numbers[j + 1]]\n        closest_difference = difference\n      end\n\
    \      j += 1\n    end\n    i += 1\n  end\n  closest_elements\nend", "  # TODO:\n\
    end", "  arr = []\n  (0..numbers.length - 2).each do |i|\n    arr << [numbers[i],\
    \ numbers[i + 1]].sort if (numbers[i] - numbers[i + 1]).abs == numbers.min_by{|n|\
    \ (numbers[i] - n).abs }\n  end\n  return arr.first\nend", "  return [] if numbers.empty?\n\
    \  min_distance = (numbers[0] - numbers[1]).abs\n  closest_pairs = []\n  numbers.each_with_index\
    \ do |number, index|\n    next if index == numbers.length - 1\n    if ((number\
    \ - numbers[index + 1]).abs < min_distance)\n      min_distance = (number - numbers[index\
    \ + 1]).abs\n      closest_pairs = [number, numbers[index + 1]]\n    end\n  end\n\
    \  closest_pairs\nend", "  numbers.combination(2).to_a.min_by { |a, b| (a - b).abs\
    \ }\nend", "  # numbers = numbers.sort\n  diff = numbers[1] - numbers[0]\n  numbers.each_index\
    \ do |i|\n    next if i == numbers.length - 1\n    temp = numbers[i + 1] - numbers[i]\n\
    \    diff = temp if temp < diff\n  end\n  numbers.each_with_index do |num, i|\n\
    \    next if i == numbers.length - 1\n    return [num, numbers[i + 1]] if numbers[i\
    \ + 1] - num == diff\n  end\nend", "  closest_distance = (numbers[1] - numbers[0]).abs\n\
    \  closest_elements = [numbers[0], numbers[1]]\n  numbers.length.times do |i|\n\
    \    ((i + 1)...numbers.length).each do |j|\n      if (numbers[j] - numbers[i]).abs\
    \ < closest_distance\n        closest_distance = (numbers[j] - numbers[i]).abs\n\
    \        closest_elements = [numbers[i], numbers[j]]\n      end\n    end\n  end\n\
    \  return closest_elements\nend", "  numbers.map { |n| n.abs }.sort.take(2)\n\
    end", "  #return [] if numbers.nil? || numbers.size < 2\n  return [] if numbers.size\
    \ < 2\n  closest_pair = [numbers[0], numbers[1]]\n  for i in 0..numbers.size-2\n\
    \    for j in i+1..numbers.size-1\n      if (numbers[j] - numbers[i]).abs < (closest_pair[1]\
    \ - closest_pair[0]).abs\n        closest_pair = [numbers[i], numbers[j]]\n  \
    \    end\n    end\n  end\n  closest_pair\nend", "  return [] if numbers.length\
    \ < 2\n  closest_pair = [numbers[0], numbers[1]]\n  closest_distance = (numbers[0]\
    \ - numbers[1]).abs\n  for i in 0..numbers.length - 2\n    for j in i + 1..numbers.length\
    \ - 1\n      if (numbers[i] - numbers[j]).abs < closest_distance\n        closest_pair\
    \ = [numbers[i], numbers[j]]\n        closest_distance = (numbers[i] - numbers[j]).abs\n\
    \      end\n    end\n  end\n  closest_pair\nend", '  numbers = numbers.sort',
  "  # TODO\nend", "  i = 1\n  closest_elements = []\n  while i < numbers.length\n\
    \    if (numbers[i] - numbers[i-1]).abs == 0.8\n      closest_elements << numbers[i-1]\n\
    \      closest_elements << numbers[i]\n    end\n    i += 1\n  end\n  if closest_elements\
    \ == []\n    puts \"There are no elements that are closest to each other.\"\n\
    \  else\n    puts closest_elements\n  end\nend\nfind_closest_elements([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])", "  # TODO: implement\nend", "  numbers.combination(2).map\
    \ { |x, y| [x, y, (x - y).abs] }.min_by { |x, y, d| d }[0..1]\nend", "  numbers.sort!\n\
    \  total_distance = numbers[numbers.length - 1] - numbers[0]\n  closest_distance\
    \ = total_distance\n  closest_elements = [numbers[0], numbers[1]]\n  closest_index\
    \ = 0\n  while closest_index < numbers.length - 1\n    current_distance = numbers[closest_index\
    \ + 1] - numbers[closest_index]\n    if current_distance < closest_distance\n\
    \      closest_distance = current_distance\n      closest_elements = [numbers[closest_index],\
    \ numbers[closest_index + 1]]\n    end\n    closest_index += 1\n  end\n  closest_elements\n\
    end", "  numbers.combination(2).to_a.\n    map { |a, b| [a, b, (a - b).abs] }.\n\
    \    sort_by { |a, b, d| d }.\n    first[0..1]\nend", "\t# your code here\n\t\
    a = []\n\tfor i in 0..numbers.length-1\n\t\tfor j in 0..numbers.length-1\n\t\t\
    \tif (i != j)\n\t\t\t\ta.push((numbers[i] - numbers[j]).abs)\n\t\t\tend\n\t\t\
    end\n\tend\n\td = a.min\n\tnew_a = []\n\tfor i in 0..numbers.length-1\n\t\tfor\
    \ j in 0..numbers.length-1\n\t\t\tif (i != j)\n\t\t\t\tif ((numbers[i] - numbers[j]).abs\
    \ == d)\n\t\t\t\t\tnew_a.push(numbers[i])\n\t\t\t\t\tnew_a.push(numbers[j])\n\t\
    \t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn new_a.uniq\nend", '  numbers =
    numbers.sort', "  numbers = numbers.sort\n  closest_pair = [numbers[0], numbers[1]]\n\
    \  distance = closest_pair[1] - closest_pair[0]\n  numbers.each_with_index do\
    \ |number, index|\n    if index != 0\n      new_distance = number - numbers[index\
    \ - 1]\n      if new_distance < distance\n        distance = new_distance\n  \
    \      closest_pair = [numbers[index - 1], number]\n      end\n    end\n  end\n\
    \  closest_pair\nend", "  closest_two = [numbers[0], numbers[1]]\n  numbers.each_with_index\
    \ do |num, i|\n    next if i < 1\n    if (closest_two[0] - closest_two[1]).abs\
    \ > (num - numbers[i - 1]).abs\n      closest_two = [num, numbers[i - 1]]\n  \
    \  end\n  end\n  closest_two.sort\nend", "  smallest_difference = numbers[1] -\
    \ numbers[0]\n  closest_elements = [numbers[0], numbers[1]]\n  numbers.each_with_index\
    \ do |num, idx|\n    if idx < numbers.length - 1\n      difference = numbers[idx\
    \ + 1] - num\n      if difference < smallest_difference\n        smallest_difference\
    \ = difference\n        closest_elements = [num, numbers[idx + 1]]\n      end\n\
    \    end\n  end\n  closest_elements\nend", "  closest_elements = []\n  first_num\
    \ = closest_elements[0]\n  numbers.each_with_index do |x, i|\n    if (x-1).abs\
    \ < (first_num-1).abs\n      closest_elements = []\n      closest_elements <<\
    \ x\n      closest_elements << numbers[i+1]\n    end\n  end\n  return closest_elements\n\
    end", "\traise ArgumentError, \"there must be at least two elements in the array\"\
    \ if numbers.size < 2\n\tdiff = []\n\tnumbers.each_with_index do |v,i|\n\t\tunless\
    \ numbers[i+1].nil?\n\t\t\tdiff << (v - numbers[i+1]).abs\n\t\tend\n\tend\n\t\
    elements = [numbers[diff.index(diff.min)], numbers[diff.index(diff.min)+1]]\n\t\
    return elements.sort\nend", "  numbers.combination(2).map { |a, b| [a, b, (a -\
    \ b).abs] }.min_by { |e| e[2] }.take(2)\nend", "  # if numbers.length < 2\n  #\
    \   return []\n  # end\n  # numbers.sort\n  # min_diff = numbers[1] - numbers[0]\n\
    \  # min_pair = [numbers[0], numbers[1]]\n  # for i in 1..numbers.length-2\n \
    \ #   diff = numbers[i+1] - numbers[i]\n  #   if diff < min_diff\n  #     min_diff\
    \ = diff\n  #     min_pair = [numbers[i], numbers[i+1]]\n  #   end\n  # end\n\
    \  # min_pair\n  min_pair = []\n  min_diff = nil\n  numbers.combination(2).to_a.each\
    \ do |pair|\n    diff = (pair[0] - pair[1]).abs\n    if min_diff.nil? || diff\
    \ < min_diff\n      min_diff = diff\n      min_pair = pair\n    end\n  end\n \
    \ min_pair\nend", "  sorted_numbers = numbers.sort\n  closest_difference = (sorted_numbers[1]\
    \ - sorted_numbers[0]).abs\n  closest_numbers = sorted_numbers[0, 2]\n  sorted_numbers.each_cons(2)\
    \ do |numbers|\n    difference = (numbers[1] - numbers[0]).abs\n    if difference\
    \ < closest_difference\n      closest_difference = difference\n      closest_numbers\
    \ = numbers\n    end\n  end\n  closest_numbers\nend", "  diff_hash = {}\n  numbers.each_with_index\
    \ do |num1, index1|\n    numbers.each_with_index do |num2, index2|\n      if index1\
    \ < index2\n        diff = (num1 - num2).abs\n        diff_hash[diff] = [num1,\
    \ num2]\n      end\n    end\n  end\n  diff_hash[diff_hash.keys.min]\nend", " \
    \ numbers.sort!\n  smallest_difference = nil\n  closest_elements = nil\n  numbers.each_cons(2)\
    \ do |x, y|\n    difference = (x - y).abs\n    if smallest_difference.nil? ||\
    \ difference < smallest_difference\n      smallest_difference = difference\n \
    \     closest_elements = [x, y]\n    end\n  end\n  closest_elements\nend", " \
    \ numbers.map.with_index do |num, index|\n    num_after = numbers[index + 1]\n\
    \    [num, num_after]\n  end.reject { |num_pair| num_pair.last.nil? }.min_by do\
    \ |num_pair|\n    (num_pair.last - num_pair.first).abs\n  end\nend", "  return\
    \ [numbers[0], numbers[1]] if numbers.size == 2\n  first = numbers[0]\n  second\
    \ = numbers[1]\n  closest_diff = (first - second).abs\n  for i in 0..numbers.size-2\n\
    \    for j in i+1..numbers.size-1\n      diff = (numbers[i] - numbers[j]).abs\n\
    \      if diff < closest_diff\n        closest_diff = diff\n        first = numbers[i]\n\
    \        second = numbers[j]\n      end\n    end\n  end\n  [first, second]\nend",
  "  return [] if numbers.nil? || numbers.length < 2\n  numbers.sort!\n  result =\
    \ [numbers[0], numbers[1]]\n  numbers.each_with_index do |number, i|\n    next\
    \ if i == 0\n    if (numbers[i] - numbers[i - 1]).abs < (result[1] - result[0]).abs\n\
    \      result = [numbers[i - 1], numbers[i]]\n    end\n  end\n  result\nend",
  "  numbers.combination(2).min_by { |x, y| (x - y).abs }\nend", "  numbers.sort!\n\
    \  closest_distance = Float::INFINITY\n  closest_elements = []\n  numbers.each_with_index\
    \ do |number, index|\n    if index < numbers.length - 1\n      next_number = numbers[index\
    \ + 1]\n      distance = next_number - number\n      if distance < closest_distance\n\
    \        closest_distance = distance\n        closest_elements = [number, next_number]\n\
    \      end\n    end\n  end\n  closest_elements\nend", "  @closest_elements = []\n\
    \  @current_closest_distance = -1\n  numbers.each_with_index do |number, index|\n\
    \    next_number = index < numbers.length - 1 ? numbers[index + 1] : nil\n   \
    \ if next_number.nil?\n      break\n    end\n    distance = next_number - number\n\
    \    if @current_closest_distance == -1\n      @current_closest_distance = distance\n\
    \      @closest_elements = [number, next_number]\n    elsif distance < @current_closest_distance\n\
    \      @current_closest_distance = distance\n      @closest_elements = [number,\
    \ next_number]\n    end\n  end\n  @closest_elements\nend", "  numbers = numbers.sort!\n\
    \  diff = 100\n  closest_elements = []\n  numbers.each_index do |i|\n    numbers[i].to_f\
    \ + 1 == numbers[i + 1].to_f if i < numbers.length - 1\n    if (numbers[i].to_f\
    \ + 1 - numbers[i + 1].to_f).abs < diff\n      diff = (numbers[i].to_f + 1 - numbers[i\
    \ + 1].to_f).abs\n      closest_elements[0] = numbers[i].to_f\n      closest_elements[1]\
    \ = numbers[i + 1].to_f\n    end\n  end\n  closest_elements\nend", "  numbers.combination(2).to_a.map\
    \ do |a, b|\n    [a, b, (a - b).abs]\n  end.min_by{|a, b, distance| distance}[0..1]\n\
    end", "  numbers.sort!\n  closest_diff = numbers[1] - numbers[0]\n  closest_pair\
    \ = numbers[0..1]\n  numbers.each_with_index do |number, index|\n    next if index\
    \ < numbers.length - 1\n    diff = numbers[index + 1] - number\n    if diff <\
    \ closest_diff\n      closest_diff = diff\n      closest_pair = [number, numbers[index\
    \ + 1]]\n    end\n  end\n  closest_pair\nend", "\tsmallest_difference = 100000\n\
    \telements = []\n\ti = 0\n\twhile i < numbers.length\n\t\tj = i + 1\n\t\twhile\
    \ j < numbers.length\n\t\t\tif (numbers[j] - numbers[i]).abs < smallest_difference\n\
    \t\t\t\tsmallest_difference = (numbers[j] - numbers[i]).abs\n\t\t\t\telements\
    \ = [numbers[i], numbers[j]]\n\t\t\telsif (numbers[j] - numbers[i]).abs == smallest_difference\n\
    \t\t\t\telements = [numbers[i], numbers[j]]\n\t\t\tend\n\t\t\tj += 1\n\t\tend\n\
    \t\ti += 1\n\tend\n\telements\nend", "  numbers.sort!\n  closest_pair = [numbers[0],\
    \ numbers[1]]\n  closest_gap = numbers[1] - numbers[0]\n  i = 0\n  while i < numbers.length\
    \ - 1\n    gap = numbers[i + 1] - numbers[i]\n    if gap < closest_gap\n     \
    \ closest_gap = gap\n      closest_pair = [numbers[i], numbers[i + 1]]\n    end\n\
    \    i += 1\n  end\n  closest_pair\nend", "  numbers.sort!\n  closest_elements\
    \ = []\n  numbers.each_with_index do |n, i|\n    numbers.each_with_index do |m,\
    \ j|\n      if n == m && i == j\n        next\n      elsif closest_elements.empty?\n\
    \        closest_elements = [n, m]\n      elsif (n - m).abs < (closest_elements[0]\
    \ - closest_elements[1]).abs\n        closest_elements = [n, m]\n      end\n \
    \   end\n  end\n  closest_elements\nend", "  raise \"You should pass at least\
    \ two numbers\" if numbers.length < 2\n  min_distance = numbers[1] - numbers[0]\n\
    \  closest_numbers = [numbers[0], numbers[1]]\n  numbers.each_with_index do |first_element,\
    \ first_index|\n    numbers.each_with_index do |second_element, second_index|\n\
    \      next if first_index == second_index\n      distance = (first_element -\
    \ second_element).abs\n      next if distance >= min_distance\n      min_distance\
    \ = distance\n      closest_numbers = [first_element, second_element].sort\n \
    \   end\n  end\n  closest_numbers\nend", "  numbers.sort!\n  smallest_difference\
    \ = numbers[1] - numbers[0]\n  closest_numbers = [numbers[0], numbers[1]]\n  (0..numbers.length\
    \ - 2).each do |index|\n    if numbers[index + 1] - numbers[index] < smallest_difference\n\
    \      smallest_difference = numbers[index + 1] - numbers[index]\n      closest_numbers\
    \ = [numbers[index], numbers[index + 1]]\n    end\n  end\n  return closest_numbers\n\
    end", "  # TODO: implement\nend", "\t# return numbers if numbers.size == 2\n\t\
    # m = []\n\t# for i in 0..numbers.size-2\n\t# \tn = numbers[i+1] - numbers[i]\n\
    \t# \tm.push(n)\n\t# end\n\t# for i in 0..m.size-1\n\t# \tif m[i] == m.min\n\t\
    # \t\treturn [numbers[i], numbers[i+1]]\n\t# \tend\n\t# end\n\t# return numbers[-2..-1]\n\
    \tnumbers.combination(2).min_by { |a, b| (a - b).abs }\nend", "  raise Exception\
    \ unless numbers.size >= 2\n  numbers.combination(2).to_a.map { |pair| [pair.sum,\
    \ pair] }.sort[0][1]\nend", "  # find closest elements\n  closest_elements = []\n\
    \  closest_value = nil\n  for i in 0..numbers.length - 2\n    for j in i+1..numbers.length\
    \ - 1\n      if closest_value.nil?\n        closest_value = (numbers[i] - numbers[j]).abs\n\
    \        closest_elements = [numbers[i], numbers[j]]\n      elsif (numbers[i]\
    \ - numbers[j]).abs < closest_value\n        closest_value = (numbers[i] - numbers[j]).abs\n\
    \        closest_elements = [numbers[i], numbers[j]]\n      end\n    end\n  end\n\
    \  # return the smaller one first\n  return [closest_elements.min, closest_elements.max]\n\
    end", "  numbers.sort.combination(2).to_a.map { |a, b| b - a }.min\nend", "  result\
    \ = [numbers[0], numbers[1]]\n  distance = (numbers[0] - numbers[1]).abs\n  numbers.each_with_index\
    \ do |number, index|\n    next_index = index + 1\n    until next_index >= numbers.length\n\
    \      if (number - numbers[next_index]).abs < distance\n        distance = (number\
    \ - numbers[next_index]).abs\n        result = [number, numbers[next_index]].sort\n\
    \      end\n      next_index += 1\n    end\n  end\n  result\nend", "  numbers\
    \ = numbers.sort\n  closest_diff = numbers[0]\n  numbers.each_with_index do |n,\
    \ i|\n    next if i == 0\n    diff = n - numbers[i - 1]\n    if diff < closest_diff\n\
    \      closest_diff = diff\n      closest_elements = [numbers[i - 1], n]\n   \
    \ end\n  end\n  closest_elements\nend", "  index = 0\n  diff = 0\n  res = []\n\
    \  numbers.each_index do |i|\n    next if i == 0\n    unless (numbers[i] - numbers[i-1]).abs\
    \ > diff\n      diff = (numbers[i] - numbers[i-1]).abs\n      index = i\n    end\n\
    \  end\n  res << numbers[index - 1]\n  res << numbers[index]\n  res\nend", '  numbers.sort!',
  "  numbers.combination(2).to_a.sort_by{|a,b| (a-b).abs}.first\nend", "  # Using\
    \ a brute force algorithm, compare the first element against each other element\
    \ and keep track of\n  # the two closest elements.\n  closest_elements = [nil,\
    \ nil]\n  smallest_difference = nil\n  numbers.each_with_index do |number, index|\n\
    \    numbers[index + 1..-1].each do |other_number|\n      difference = (number\
    \ - other_number).abs\n      if closest_elements.include?(nil) || difference <\
    \ smallest_difference\n        closest_elements = [number, other_number].sort\n\
    \        smallest_difference = difference\n      end\n    end\n  end\n  closest_elements\n\
    end", "  num = numbers[0]\n  i = 1\n  while i < numbers.length\n    if (numbers[i]\
    \ - num).abs < (numbers[i-1] - num).abs\n      numbers[i-1] = num\n    else\n\
    \      numbers[i] = num\n    end\n    num = numbers[i]\n    i += 1\n  end\n  return\
    \ numbers[i-2], numbers[i-1]\nend", "  if numbers.count > 1\n    if numbers.count\
    \ == 2\n      if numbers[0] < numbers[1]\n        return [numbers[0], numbers[1]]\n\
    \      else\n        return [numbers[1], numbers[0]]\n      end\n    else\n  \
    \    diff = numbers[1] - numbers[0]\n      smallest = numbers[0]\n      largest\
    \ = numbers[1]\n      numbers.each_with_index do |a, i|\n        if (i+1) < numbers.count\n\
    \          b = numbers[i+1]\n          if (b - a) < diff\n            diff = b\
    \ - a\n            smallest = a\n            largest = b\n          end\n    \
    \    end\n      end\n      return [smallest, largest]\n    end\n  else\n    return\
    \ []\n  end\nend", "  numbers.sort.each_cons(2).map{|a,b| [a,b] if (a-b).abs ==\
    \ numbers.map{|x| (x-b).abs}.min}.compact.first\nend", "  elements = []\n  numbers.each_with_index\
    \ do |num, i|\n    next_num = numbers[i + 1]\n    next if next_num.nil?\n    elements\
    \ << [num, next_num] if (num - next_num).abs == numbers.min_by { |x| (x - next_num).abs\
    \ }\n  end\n  puts \"find_closest_elements: #{elements.inspect}\"\nend\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\nfind_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])",
  "  # numbers.combination(2).map { |(a, b)| [a, b, (a - b).abs] }.sort_by(&:last).first.take(2)\n\
    \  numbers.combination(2).min_by { |(a, b)| (a - b).abs }\nend", "  result = []\n\
    \  index = 1\n  min_diff = (numbers[0] - numbers[1]).abs\n  index_array = [0,\
    \ 1]\n  for i in index..numbers.length - 1\n    diff = (numbers[i] - numbers[i\
    \ - 1]).abs\n    if diff < min_diff\n      min_diff = diff\n      index_array\
    \ = [i - 1, i]\n    end\n  end\n  result = index_array.map { |index| numbers[index]\
    \ }\n  result\nend", "  numbers.sort!\n  closest_pair = []\n  closest_distance\
    \ = numbers[1] - numbers[0]\n  (0..numbers.length - 2).each do |i|\n    current_distance\
    \ = numbers[i + 1] - numbers[i]\n    if current_distance < closest_distance\n\
    \      closest_distance = current_distance\n      closest_pair = [numbers[i],\
    \ numbers[i + 1]]\n    end\n  end\n  closest_pair\nend", "  # REPLACE THIS CODE\
    \ WITH YOUR find_closest_elements METHOD\n  numbers.sort!\n  index = 0\n  difference\
    \ = numbers[1] - numbers[0]\n  while index < numbers.length - 1\n    if numbers[index\
    \ + 1] - numbers[index] < difference\n      difference = numbers[index + 1] -\
    \ numbers[index]\n    end\n    index += 1\n  end\n  index = 0\n  while index <\
    \ numbers.length - 1\n    if numbers[index + 1] - numbers[index] == difference\n\
    \      return [numbers[index], numbers[index + 1]]\n    end\n    index += 1\n\
    \  end\nend", "  #Find the minimum difference between two numbers in the array\n\
    \  smallest_difference = (numbers[1] - numbers[0]).abs", "  if numbers.nil? ||\
    \ numbers.length <= 1\n    return nil\n  end", "  closest_numbers = []\n  closest_difference\
    \ = Float::INFINITY\n  numbers.each_with_index do |number, index|\n    numbers[index\
    \ + 1..-1].each do |other_number|\n      difference = number - other_number\n\
    \      next if difference.negative?\n      if difference < closest_difference\n\
    \        closest_numbers = [number, other_number]\n        closest_difference\
    \ = difference\n      end\n    end\n  end\n  closest_numbers\nend", "  closest_numbers\
    \ = [numbers[0], numbers[1]]\n  smallest_difference = (numbers[0] - numbers[1]).abs",
  "  closest_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do |num, index|\n\
    \    next if index + 1 == numbers.length\n    if (num - numbers[index + 1]).abs\
    \ < (closest_pair[0] - closest_pair[1]).abs\n      closest_pair = [num, numbers[index\
    \ + 1]]\n    end\n  end\n  closest_pair\nend", "  numbers = numbers.sort\n  closest_pair\
    \ = []\n  closest_difference = numbers[-1] - numbers[0]\n  numbers.each_with_index\
    \ do |n, i|\n    break if i >= numbers.length - 1\n    if (numbers[i+1] - n).abs\
    \ < closest_difference\n      closest_pair = [n, numbers[i+1]]\n      closest_difference\
    \ = (numbers[i+1] - n).abs\n    end\n  end\n  closest_pair\nend", "  closest_pair\
    \ = []\n  closest_difference = Float::INFINITY\n  i = 0\n  j = 1\n  while i <\
    \ numbers.length - 1\n    while j < numbers.length\n      if (numbers[j] - numbers[i]).abs\
    \ < closest_difference\n        closest_pair = [numbers[i], numbers[j]]\n    \
    \    closest_difference = (numbers[j] - numbers[i]).abs\n      end\n      j +=\
    \ 1\n    end\n    i += 1\n    j = i + 1\n  end\n  return closest_pair\nend\nputs\
    \ \"The closest pair are #{find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])}\"",
  "  numbers.combination(2).map { |(a, b)| [a, b, (a - b).abs] }.min_by { |(_, _,\
    \ dist)| dist }[0, 2]\nend", "  numbers.sort!\n  closes = []\n  distances = []\n\
    \  for i in 0..numbers.length-2\n    distances << numbers[i+1] - numbers[i]\n\
    \  end\n  ind = distances.index(distances.min)\n  closes << numbers[ind]\n  closes\
    \ << numbers[ind+1]\n  closes\nend", "  min = numbers[1] - numbers[0]\n  result\
    \ = []\n  numbers.each_with_index do |number, index|\n    next if index + 1 ==\
    \ numbers.length\n    tmp = numbers[index + 1] - number\n    if tmp < min\n  \
    \    min = tmp\n      result = [number, numbers[index + 1]]\n    end\n  end\n\
    \  result\nend", "  numbers.sort!\n  # small element\n  sm = nil\n  # large element\n\
    \  lg = nil\n  min_diff = nil\n  numbers.each_with_index do |num, i|\n    if i\
    \ != numbers.length - 1\n      diff = numbers[i + 1] - num\n      if min_diff.nil?\n\
    \        min_diff = diff\n        sm = num\n        lg = numbers[i + 1]\n    \
    \  elsif diff < min_diff\n        min_diff = diff\n        sm = num\n        lg\
    \ = numbers[i + 1]\n      end\n    end\n  end\n  [sm, lg]\nend", "  numbers.sort!\n\
    \  min_diff = (numbers[1] - numbers[0]).abs\n  min_pairs = [numbers[0], numbers[1]]\n\
    \  (0..numbers.length-2).each do |i|\n    if (numbers[i+1] - numbers[i]).abs <\
    \ min_diff\n      min_diff = (numbers[i+1] - numbers[i]).abs\n      min_pairs\
    \ = [numbers[i], numbers[i+1]]\n    end\n  end\n  min_pairs\nend", "  closest_numbers\
    \ = [numbers[0], numbers[1]]\n  numbers.each_with_index do |num1, index1|\n  \
    \  next if index1 == numbers.length - 1\n    numbers.each_with_index do |num2,\
    \ index2|\n      if index2 > index1\n        if (num2 - num1).abs < (closest_numbers[1]\
    \ - closest_numbers[0]).abs\n          closest_numbers = [num1, num2]\n      \
    \  end\n      end\n    end\n  end\n  closest_numbers\nend", "  # Assume first\
    \ two numbers are closest\n  result = [numbers[0], numbers[1]]\n  closest_gap\
    \ = (numbers[1] - numbers[0]).abs", "  sorted_numbers = numbers.sort\n  index\
    \ = 0\n  smallest_difference = (sorted_numbers[index + 1] - sorted_numbers[index]).abs\n\
    \  while index < (sorted_numbers.length - 1)\n    if (sorted_numbers[index + 1]\
    \ - sorted_numbers[index]).abs < smallest_difference\n      smallest_difference\
    \ = (sorted_numbers[index + 1] - sorted_numbers[index]).abs\n      closest_pair\
    \ = sorted_numbers[index], sorted_numbers[index + 1]\n    end\n    index += 1\n\
    \  end\n  closest_pair\nend", "  distance_hash = {}\n  numbers.each_with_index\
    \ do |number, index|\n    ((index + 1)...numbers.length).each do |n|\n      key\
    \ = (number - numbers[n]).abs\n      value = [number, numbers[n]].sort\n     \
    \ distance_hash[key] = value\n    end\n  end\n  distance_hash.values.first\nend",
  "  unless numbers.length >= 2\n    raise ArgumentError, \"Invalid array length\"\
    \n  end", "  raise ArgumentError, 'at least two numbers must be supplied' if numbers.length\
    \ < 2\n  numbers.sort!", "  pairs = []\n  numbers.each_with_index do |n, i|\n\
    \    pairs << [n, numbers[i+1]] if numbers[i+1]\n  end\n  pairs.sort_by! { |p|\
    \ (p[0] - p[1]).abs }\n  pairs.first\nend", "  i = 0\n  closest_pair = nil\n \
    \ closest_pair_distance = nil\n  while i < numbers.length do\n    if i == numbers.length\
    \ - 1\n      return [numbers[i], numbers[i]]\n    else\n      current_pair = [numbers[i],\
    \ numbers[i+1]]\n      current_pair_distance = (current_pair[0] - current_pair[1]).abs\n\
    \      if closest_pair_distance.nil? || current_pair_distance < closest_pair_distance\n\
    \        closest_pair = current_pair\n        closest_pair_distance = current_pair_distance\n\
    \      end\n    end\n    i += 1\n  end\n  closest_pair\nend", "  array = numbers.sort\n\
    \  difference = array[0] - array[1]\n  pair = []\n  (0..array.length-2).each do\
    \ |x|\n    if (array[x] - array[x+1]).abs < difference\n      difference = (array[x]\
    \ - array[x+1]).abs\n      pair = [array[x], array[x+1]]\n    end\n  end\n  return\
    \ pair\nend", "  numbers.sort!\n  closest_numbers = [numbers[0], numbers[1]]\n\
    \  closest_distance = numbers[1] - numbers[0]\n  numbers.each_with_index do |number,\
    \ index|\n    next if index.zero? || index == numbers.length - 1\n    difference\
    \ = numbers[index + 1] - number\n    next unless difference < closest_distance\n\
    \    closest_numbers = [number, numbers[index + 1]]\n    closest_distance = difference\n\
    \  end\n  closest_numbers\nend", "  numbers = numbers.sort.uniq\n  diff = (numbers[1]\
    \ - numbers[0]).abs\n  index = 0\n  (1..numbers.length-1).each do |i|\n    if\
    \ (numbers[i] - numbers[i-1]).abs < diff\n      diff = (numbers[i] - numbers[i-1]).abs\n\
    \      index = i-1\n    end\n  end\n  [numbers[index], numbers[index+1]]\nend",
  "  # YOUR CODE HERE\nend", "  # TODO\nend", "  pairs = {}\n  (0..numbers.length-2).each\
    \ do |index|\n    pairs[index] = (numbers[index+1] - numbers[index]).abs\n  end\n\
    \  min_index = pairs.key(pairs.values.min)\n  [numbers[min_index], numbers[min_index+1]]\n\
    end", "  # Given an array, check which two numbers are closest to each other.\n\
    \  # [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n  # min1 = 1.0\n  # min2 = 2.0\n  # diff\
    \ = 1.0\n  # min1 = 1.0\n  # min2 = 2.2\n  # diff = 1.2\n  # min1 = 2.0\n  # min2\
    \ = 2.2\n  # diff = 0.2\n  # ...\n  # return [min1, min2]", "  # TODO: implement\
    \ me!\nend", "  raise ArgumentError, 'numbers must be an array of at least two\
    \ numbers' unless numbers.is_a?(Array) && numbers.length >= 2\n  numbers.sort!\
    \ { |a, b| a <=> b }\n  closest_distance = (numbers[1] - numbers[0]).abs\n  closest_elements\
    \ = [numbers[0], numbers[1]]\n  for i in 1..numbers.length-2\n    distance = (numbers[i+1]\
    \ - numbers[i]).abs\n    if distance < closest_distance\n      closest_distance\
    \ = distance\n      closest_elements = [numbers[i], numbers[i+1]]\n    end\n \
    \ end\n  closest_elements\nend", "  selected_pair = []\n  difference = 0\n  numbers.each_with_index\
    \ do |number, index|\n    if numbers[index+1]\n      if difference == 0 || numbers[index+1]\
    \ - number < difference\n        difference = numbers[index+1] - number\n    \
    \    selected_pair = [number, numbers[index+1]]\n      end\n    end\n  end\n \
    \ selected_pair\nend", "  numbers.combination(2).min_by{|a,b| (a-b).abs}\nend",
  "  # Find closest elements\n  arr = numbers.uniq.sort\n  closest = []\n  closest[0]\
    \ = arr[0]\n  closest[1] = arr[1]\n  distance = closest[1] - closest[0]\n  for\
    \ i in 0..arr.length-2\n    for j in i+1..arr.length-1\n      if arr[j] - arr[i]\
    \ < distance\n        closest[0] = arr[i]\n        closest[1] = arr[j]\n     \
    \   distance = closest[1] - closest[0]\n      end\n    end\n  end\n  closest\n\
    end", "  pairs = numbers.map{|num| [num, numbers.map{|n| (num - n).abs}]}.sort_by{|x|\
    \ x[1].sum}\n  [pairs[0][0], pairs[1][0]].sort_by{|x| x}\nend", "  numbers.minmax.reverse\n\
    end", "  require 'debugger';debugger\n  smallest_distance = (numbers[1] - numbers[0]).abs\n\
    \  closest_elements = [numbers[0], numbers[1]]\n  (numbers.length - 1).times do\
    \ |i|\n    distance = (numbers[i+1] - numbers[i]).abs\n    if distance < smallest_distance\n\
    \      smallest_distance = distance\n      closest_elements = [numbers[i], numbers[i+1]]\n\
    \    end\n  end\n  closest_elements\nend", "    diffs = numbers.each_cons(2).map{|a,b|\
    \ a-b}\n    numbers[diffs.index(diffs.min)]\nend", '  return numbers if numbers.empty?',
  "  smallest_dif = numbers[1] - numbers[0]\n  closest_elements = []\n  numbers.each_index\
    \ do |i|\n    (i + 1...numbers.length).each do |j|\n      dif = numbers[j] - numbers[i]\n\
    \      if dif < smallest_dif\n        smallest_dif = dif\n        closest_elements\
    \ = [numbers[i], numbers[j]]\n      end\n    end\n  end\n  closest_elements\n\
    end", "  array = numbers.sort\n  closest = array[1] - array[0]\n  closest_array\
    \ = [array[0], array[1]]\n  (1..array.length-1).each do |i|\n    difference =\
    \ array[i] - array[i-1]\n    if difference < closest\n      closest = difference\n\
    \      closest_array = [array[i-1], array[i]]\n    end\n  end\n  return closest_array\n\
    end", "  distance_map = {}\n  numbers.each_with_index do |item, index|\n    next\
    \ if index == 0\n    distance_map[item - numbers[index - 1]] = [numbers[index\
    \ - 1], item]\n  end\n  distance_map[distance_map.keys.min]\nend", "  return [numbers[0],\
    \ numbers[1]] if numbers.size == 2\n  min_difference = Float::INFINITY\n  pairs\
    \ = []\n  numbers.combination(2).each do |pair|\n    difference = (pair[0] - pair[1]).abs\n\
    \    if difference < min_difference\n      min_difference = difference\n     \
    \ pairs = [pair]\n    elsif difference == min_difference\n      pairs << pair\n\
    \    end\n  end\n  pairs.sort.first\nend", "  smallest_delta = Float::INFINITY\n\
    \  smallest_delta_numbers = []\n  numbers.each_with_index do |a, i|\n    next\
    \ if numbers[i + 1].nil?\n    delta = (a - numbers[i + 1]).abs\n    if delta <\
    \ smallest_delta\n      smallest_delta = delta\n      smallest_delta_numbers =\
    \ [a, numbers[i + 1]]\n    end\n  end\n  smallest_delta_numbers\nend", "  # sort\
    \ the array\n  sorted_numbers = numbers.sort\n  # compare the diffrence between\
    \ each elements to find the smallest diffrence.\n  difference = {}\n  sorted_numbers.each_with_index\
    \ do |number, index|\n    if index < sorted_numbers.length - 1\n      difference[\"\
    #{number}-#{sorted_numbers[index + 1]}\"] = number - sorted_numbers[index + 1]\n\
    \    end\n  end\n  # get the key and return the numbers in sorted order\n  smallest_difference\
    \ = difference.min_by { |key, value| value.abs }[0]\n  return smallest_difference.split(\"\
    -\").sort\nend", "  # difference = 0\n  # smallest_difference = -1\n  # result\
    \ = []\n  # numbers.each_with_index do |number, index|\n  #   next if index ==\
    \ numbers.length - 1\n  #   difference = (number - numbers[index + 1]).abs\n \
    \ #   if smallest_difference < 0 || difference < smallest_difference\n  #    \
    \ smallest_difference = difference\n  #     result = [number, numbers[index +\
    \ 1]]\n  #   end\n  # end\n  # result\n  a, b = numbers.sort.combination(2).min_by\
    \ { |x, y| (x - y).abs }\n  [a, b]\nend", "  min_diff = Float::INFINITY\n  numbers_sorted\
    \ = numbers.sort\n  (0...numbers_sorted.length - 1).each do |i|\n    diff = (numbers_sorted[i\
    \ + 1] - numbers_sorted[i]).abs\n    min_diff = diff if diff < min_diff\n  end\n\
    \  min_diff_numbers = []\n  (0...numbers_sorted.length - 1).each do |i|\n    diff\
    \ = (numbers_sorted[i + 1] - numbers_sorted[i]).abs\n    min_diff_numbers << [numbers_sorted[i],\
    \ numbers_sorted[i + 1]] if diff == min_diff\n  end\n  min_diff_numbers.sort.first\n\
    end", "  a, b = numbers.sort.minmax_by { |c, d| (c - d).abs }\n  [a, b]\nend",
  "  closest_pair = nil\n  closest_difference = nil\n  # iterate through the combinations\
    \ of pairs in the array\n  (0...numbers.size).each do |i|\n    (i+1...numbers.size).each\
    \ do |j|\n      difference = (numbers[i] - numbers[j]).abs\n      if closest_difference.nil?\
    \ || difference < closest_difference\n        closest_pair = [numbers[i], numbers[j]]\n\
    \        closest_difference = difference\n      end\n    end\n  end\n  closest_pair.sort\n\
    end", "  min_distance = Float::INFINITY\n  elements = []\n  numbers.each_with_index\
    \ do |value, index|\n    numbers[index + 1..-1].each do |value_2|\n      distance\
    \ = (value - value_2).abs\n      if distance < min_distance\n        min_distance\
    \ = distance\n        elements = [value, value_2]\n      end\n    end\n  end\n\
    \  elements\nend", "  arr = numbers.sort\n  diff = (arr[1] - arr[0]).abs\n  final\
    \ = []\n  arr.each_with_index do |a, index|\n    if index < arr.length - 1\n \
    \     diff2 = (arr[index + 1] - a).abs\n      if diff2 < diff\n        diff =\
    \ diff2\n        final = [a, arr[index + 1]]\n      end\n    end\n  end\n  final\n\
    end", "  closest_diff = numbers[1] - numbers[0]\n  closest_pair = [numbers[0],\
    \ numbers[1]]\n  numbers.each_with_index do |e, i|\n    next if i+1 == numbers.length\n\
    \    diff = numbers[i+1] - e\n    if diff < closest_diff\n      closest_diff =\
    \ diff\n      closest_pair = [e, numbers[i+1]]\n    end\n  end\n  closest_pair\n\
    end", "  numbers.combination(2).min_by { |x, y| (x - y).abs }\nend", "  numbers.sort!\n\
    \  numbers.each_cons(2).each_with_object([0, 1]) do |(a, b), (i1, i2)|\n    if\
    \ (b - a).abs < (numbers[i2] - numbers[i1]).abs\n      i1, i2 = numbers.index(a),\
    \ numbers.index(b)\n    end\n  end\nend", "  numbers.each_with_index.inject({:index\
    \ => 0, :smaller => numbers[0], :bigger => numbers[1], :diff => (numbers[1] -\
    \ numbers[0]).abs}) do |memo, (e,i)|\n    if i > 0\n      d = (e - numbers[i-1]).abs\n\
    \      if d < memo[:diff]\n        memo[:index] = i\n        memo[:smaller] =\
    \ numbers[i-1]\n        memo[:bigger] = e\n        memo[:diff] = d\n      end\n\
    \    end\n    memo\n  end\n  [numbers[memo[:index]-1], numbers[memo[:index]]]\n\
    end", "  numbers = numbers.sort\n  min_diff = numbers[1] - numbers[0]\n  min_pair\
    \ = [numbers[0], numbers[1]]\n  numbers.each_with_index do |x, index|\n    if\
    \ index == numbers.length - 1\n      break\n    end\n    if (numbers[index + 1]\
    \ - x) < min_diff\n      min_diff = numbers[index + 1] - x\n      min_pair = [x,\
    \ numbers[index + 1]]\n    end\n  end\n  min_pair\nend", "  first_number = numbers.pop\n\
    \  closest_match = [first_number, first_number]\n  numbers.each do |n|\n    if\
    \ (n - first_number).abs < (closest_match[1] - closest_match[0]).abs\n      closest_match\
    \ = [first_number, n]\n    end\n  end\n  closest_match\nend", "  numbers = numbers.sort\n\
    \  minimum_difference = (numbers[1] - numbers[0]).abs\n  number_one = numbers[0]\n\
    \  number_two = numbers[1]\n  numbers.each_with_index do |number, index|\n   \
    \ break if index == numbers.length - 1\n    next_number = numbers[index + 1]\n\
    \    difference = (next_number - number).abs\n    if difference < minimum_difference\n\
    \      minimum_difference = difference\n      number_one = number\n      number_two\
    \ = next_number\n    end\n  end\n  [number_one, number_two]\nend", "  numbers.sort!\n\
    \  closest_elements = [numbers[0], numbers[1]]\n  min_diff = closest_elements[1]\
    \ - closest_elements[0]\n  numbers.each_cons(2) do |pair|\n    diff = pair[1]\
    \ - pair[0]\n    if diff < min_diff\n      closest_elements = pair\n      min_diff\
    \ = diff\n    end\n  end\n  closest_elements\nend", "  result = []\n  distances\
    \ = []\n  (0..numbers.length-2).each do |number|\n    distances << (numbers[number]\
    \ - numbers[number+1]).abs\n  end\n  distance = distances.min\n  result = numbers.values_at(distances.index(distance),distances.index(distance)+1)\n\
    \  result\nend", "  # sort the array in ascending order\n  #numbers.sort!\n  #\
    \ create a new sorted array\n  new_array = numbers.sort\n  # create a new array\
    \ to store the closest elements\n  closest_elements = []\n  # set the first two\
    \ elements in the new array as the two elements in closest_elements array\n  closest_elements[0]\
    \ = new_array[0]\n  closest_elements[1] = new_array[1]\n  # iterate through the\
    \ new array starting from the 3rd element\n  new_array[2..-1].each do |element|\n\
    \    # compare the difference between the first 2 elements and the current element\n\
    \    # if the difference between the current element and the first element is\
    \ smaller than the difference between\n    # the first and second elements, replace\
    \ the first element with the current element\n    # in the else, if the difference\
    \ between the current element and the second element is smaller than the difference\n\
    \    # between the first and second elements, replace the second element with\
    \ the current element\n    if (element - new_array[0]).abs < (new_array[1] - new_array[0]).abs\n\
    \      closest_elements[0] = element\n    elsif (element - new_array[1]).abs <\
    \ (new_array[1] - new_array[0]).abs\n      closest_elements[1] = element\n   \
    \ end\n  end\n  # return the closest_elements array\n  closest_elements\nend",
  "  numbers.map { |number| numbers.map { |number2| [number, number2].sort }.uniq\
    \ }.flatten(1).uniq.sort_by { |numbers| numbers[1] - numbers[0] }.first\nend",
  "  numbers.combination(2).min_by { |x, y| (x - y).abs }\nend", "  numbers = numbers.sort\n\
    \  closest_diff = numbers[1] - numbers[0]\n  closest_numbers = [numbers[0], numbers[1]]\n\
    \  numbers.each_with_index do |number, i|\n    next if i == 0\n    prev_number\
    \ = numbers[i - 1]\n    diff = number - prev_number\n    if diff < closest_diff\n\
    \      closest_diff = diff\n      closest_numbers = [prev_number, number]\n  \
    \  end\n  end\n  closest_numbers\nend", "  # current_min = numbers[1] - numbers[0]\n\
    \  # numbers.each_with_index do |num, index|\n  #   if index < numbers.length\
    \ - 1\n  #     cur_diff = numbers[index + 1] - num\n  #     current_min = cur_diff\
    \ if cur_diff < current_min\n  #   end\n  # end\n  # final_nums = []\n  # numbers.each_with_index\
    \ do |num, index|\n  #   if index < numbers.length - 1\n  #     cur_diff = numbers[index\
    \ + 1] - num\n  #     if cur_diff == current_min\n  #       final_nums = [num,\
    \ numbers[index + 1]]\n  #     end\n  #   end\n  # end\n  # final_nums\n  numbers.sort.each_cons(2).min_by\
    \ { |a, b| (a - b).abs }\nend", "  closest_pair = {\n    :difference => Float::INFINITY,\n\
    \    :numbers => []\n  }", "  # sort in ascending order\n  sorted_numbers = numbers.sort",
  "  size = numbers.size\n  if size < 2\n    return nil\n  end\n  min_diff = numbers[1]\
    \ - numbers[0]\n  min_first_element = numbers[0]\n  min_second_element = numbers[1]\n\
    \  for i in 0..size-2\n    for j in i+1..size-1\n      if (numbers[j] - numbers[i])\
    \ < min_diff\n        min_diff = numbers[j] - numbers[i]\n        min_first_element\
    \ = numbers[i]\n        min_second_element = numbers[j]\n      end\n    end\n\
    \  end\n  [min_first_element, min_second_element]\nend", "  numbers.sort!\n  distance\
    \ = numbers[1] - numbers[0]\n  elements = [numbers[0], numbers[1]]\n  for i in\
    \ (1..numbers.length-1)\n    if numbers[i] - numbers[i-1] < distance\n      distance\
    \ = numbers[i] - numbers[i-1]\n      elements = [numbers[i-1], numbers[i]]\n \
    \   end\n  end\n  elements\nend", "  closest_pair = [numbers[0], numbers[1]]\n\
    \  distance = closest_pair[1] - closest_pair[0]\n  numbers.each_with_index do\
    \ |num, i|\n    next if i + 1 == numbers.length\n    next_num = numbers[i + 1]\n\
    \    new_distance = next_num - num\n    if new_distance < distance\n      closest_pair\
    \ = [num, next_num]\n      distance = new_distance\n    end\n  end\n  closest_pair\n\
    end", '  numbers.sort!', "  max = -1\n  n1 = nil\n  n2 = nil\n  numbers.each_with_index\
    \ do |n, i|\n    numbers[i+1..-1].each do |m|\n      distance = (n - m).abs\n\
    \      if distance > max\n        max = distance\n        n1 = m\n        n2 =\
    \ n\n      end\n    end\n  end\n  [n1, n2]\nend", "  closest_pair = numbers.combination(2).min_by\
    \ { |a, b| (a - b).abs }\n  closest_pair.sort\nend", "  min_diff = Float::INFINITY\n\
    \  result = []\n  numbers.each_with_index do |x, i|\n    # if there is no next\
    \ element then break\n    break if numbers[i + 1].nil?\n    next_elem = numbers[i\
    \ + 1]\n    diff = (x - next_elem).abs\n    if diff < min_diff\n      min_diff\
    \ = diff\n      result = [x, next_elem]\n    end\n  end\n  result\nend", "  numbers.combination(2).min_by{|a,b|\
    \ (a-b).abs}\nend", "  closest_elements = [numbers[0], numbers[1]]\n  lowest_difference\
    \ = (numbers[0] - numbers[1]).abs", "  raise ArgumentError, 'Must supply an array\
    \ of at least two numbers' if numbers.empty? || numbers.length == 1\n  numbers.combination(2).map\
    \ { |a, b| [(a - b).abs, a, b] }.min[1..2]\nend", "  min_difference = Float::INFINITY\n\
    \  closest_elements = []\n  numbers.each_with_index do |number, index|\n    difference\
    \ = Float::INFINITY\n    (index+1..numbers.length - 1).each do |i|\n      difference\
    \ = numbers[i] - number\n      if difference < min_difference\n        min_difference\
    \ = difference\n        closest_elements = [number, numbers[i]]\n      end\n \
    \   end\n  end\n  closest_elements\nend", "  #use two passes over the array -\
    \ the outer loop to keep track of the index\n  #the inner loop to compare the\
    \ number to all the other numbers in the array\n  #keep track of the smallest\
    \ difference between numbers and keep track of the two numbers as a result\n \
    \ smallest_difference = nil\n  first_number = nil\n  second_number = nil\n  numbers.each_with_index\
    \ do |number, index|\n    numbers[index+1..-1].each do |other_number|\n      difference\
    \ = (number - other_number).abs\n      if smallest_difference.nil? || difference\
    \ < smallest_difference\n        smallest_difference = difference\n        first_number\
    \ = number\n        second_number = other_number\n      end\n    end\n  end\n\
    \  [first_number, second_number].sort\nend", "  # ... your code goes here\nend",
  "  first_num = numbers[0]\n  second_num = numbers[1]\n  numbers.each_with_index\
    \ do |n, i|\n    next if i == 0\n    if (n - first_num).abs < (second_num - first_num).abs\n\
    \      second_num = n\n    end\n  end\n  [first_num, second_num]\nend", "  # sort\
    \ and use each with index to compare each element\n  smallest_num = []\n  numbers.sort!\n\
    \  numbers.each_with_index do |num, index|\n    if index == numbers.length - 1\n\
    \      return smallest_num\n    else\n      num2 = numbers[index + 1]\n      if\
    \ smallest_num.empty?\n        smallest_num << num\n        smallest_num << num2\n\
    \      elsif (num2 - num).abs < (smallest_num[1] - smallest_num[0]).abs\n    \
    \    smallest_num[0] = num\n        smallest_num[1] = num2\n      end\n    end\n\
    \  end\nend", "  # Your code here\nend", "  return nil if numbers.size < 2\n \
    \ numbers.map! { |num|\n    num.to_f\n  }\n  numbers.combination(2).to_a.min_by\
    \ { |el|\n    (el[0] - el[1]).abs\n  }\nend", "\t# diff_hash = {}\n\t# numbers.each_with_index\
    \ do |num, index|\n\t# \tif index + 1 < numbers.length\n\t# \t\tdiff_hash[num]\
    \ = numbers[index + 1] - num\n\t# \tend\n\t# end\n\t# smallest_diff = diff_hash.values.min\n\
    \t# diff_hash.select! { |k, v| v == smallest_diff }\n\t# final_diff_hash = {}\n\
    \t# diff_hash.each_key do |k|\n\t# \tfinal_diff_hash[k] = numbers[numbers.index(k)\
    \ + 1]\n\t# end\n\t# final_diff_hash.first\nend", "  # Find the absolute difference\
    \ between each pair of numbers\n  # Put them in an array\n  # Select the first\
    \ two smallest numbers\n  # Put the smallest number first\n  # Return the result",
  "  numbers.sort!\n  closest_diff = numbers[0..-2].each_with_index.inject([]) do\
    \ |result, (element, i)|\n    result << [numbers[i + 1] - element, [element, numbers[i\
    \ + 1]]]\n  end\n  closest_diff.min_by(&:first).last\nend", "  numbers.map.with_index\
    \ { |n, i| [n, i] }.sort.combination(2).min_by { |x, y| (x[0] - y[0]).abs }.map\
    \ { |n| n[0] }\nend", "  # returns an array with the same numbers as the input\
    \ array in a random order.\n  shuffled_arr = numbers.shuffle\n  # Sort the numbers\
    \ from smallest to largest\n  sorted_arr = shuffled_arr.sort\n  closest_value\
    \ = nil\n  difference = nil\n  closest_values = []\n  sorted_arr.each_with_index\
    \ do |value, index|\n    # Check if it is the last number\n    if index != sorted_arr.length\
    \ - 1\n      # Calculate the difference with the next number and check if it is\
    \ the smallest difference so far\n      current_difference = (value - sorted_arr[index\
    \ + 1]).abs\n      if difference.nil? || current_difference < difference\n   \
    \     difference = current_difference\n        closest_value = value\n       \
    \ closest_values = [value, sorted_arr[index + 1]]\n      end\n    end\n  end\n\
    \  closest_values\nend", "  # TODO: Return the two closest elements\n  numbers.combination(2).min_by\
    \ { |a, b| (a - b).abs }\nend", "  numbers = numbers.sort\n  diffs = []\n  numbers.each_cons(2)\
    \ do |a, b|\n    diffs << (a - b).abs\n  end\n  min_index = diffs.index(diffs.min)\n\
    \  [numbers[min_index], numbers[min_index + 1]]\nend", "    i = 0\n    closest\
    \ = 0\n    closest_pair = []\n    pair = []\n    until i == numbers.length - 1\n\
    \        num = numbers[i]\n        num_next = numbers[i + 1]\n        diff = (num\
    \ - num_next).abs\n        if closest.nil? || diff < closest\n            closest\
    \ = diff\n            closest_pair = [num, num_next]\n        end\n        i +=\
    \ 1\n    end\n    closest_pair\nend", "  numbers.sort!\n  dist = Hash.new\n  numbers.each_with_index\
    \ do |num, index|\n    if index != numbers.length - 1\n      dist[num] = numbers[index\
    \ + 1] - num\n    end\n  end\n  min = dist.min_by { |key, value| value }\n  [min[0],\
    \ min[0] + min[1]]\nend", "  # 1.0 is the initial distance\n  # 2.0 is the initial\
    \ minimum\n  # [2.0, 2.0] is the initial min_pair\n  numbers.each_with_index.reduce([1.0,\
    \ 2.0, [2.0, 2.0]]) do |memo, (number, index)|\n    other_numbers = numbers[index+1..-1]\n\
    \    unless other_numbers.empty?\n      closest_other_number, distance = other_numbers.reduce([nil,\
    \ memo[0]]) do |sub_memo, other_number|\n        if (other_number - number).abs\
    \ < sub_memo[1]\n          [other_number, (other_number - number).abs]\n     \
    \   else\n          sub_memo\n        end\n      end\n      if distance < memo[0]\n\
    \        [distance, [number, closest_other_number].sort]\n      else\n       \
    \ memo\n      end\n    else\n      memo\n    end\n  end[2]\nend", "  sorted_numbers\
    \ = numbers.sort\n  smallest_numbers = [sorted_numbers[0], sorted_numbers[1]]\n\
    \  sorted_numbers.each_with_index do |n, i|\n    next if i == 0\n    difference\
    \ = (n - sorted_numbers[i - 1]).abs\n    if difference < (smallest_numbers[1]\
    \ - smallest_numbers[0]).abs\n      smallest_numbers = [sorted_numbers[i - 1],\
    \ n]\n    end\n  end\n  smallest_numbers\nend", "\t# new_array = []\n\t# closest_elements\
    \ = []\n\t# sorted_array = numbers.sort\n\t# sorted_array.each_with_index do |num,\
    \ i|\n\t# \tif sorted_array[i+1]\n\t# \t\tnew_array << sorted_array[i+1] - num\n\
    \t# \tend\n\t# end\n\t# minimum = new_array.min\n\t# first_index = new_array.index(minimum)\n\
    \t# second_index = first_index + 1\n\t# closest_elements << sorted_array[first_index]\n\
    \t# closest_elements << sorted_array[second_index]\n\t# closest_elements\n\t#\
    \ if numbers[0] == numbers[1]\n\t# \t[numbers[0], numbers[1]]\n\t# else\n\t# \t\
    index1 = 0\n\t# \tindex2 = 1\n\t# \tdifferences = []\n\t# \tnumbers.sort.each_with_index\
    \ do |num, i|\n\t# \t\tif numbers[i+1]\n\t# \t\t\tdifferences << numbers[i+1]\
    \ - num\n\t# \t\tend\n\t# \tend\n\t# \tminimum = differences.min\n\t# \tindex1\
    \ = differences.index(minimum)\n\t# \tindex2 = index1 + 1\n\t# \t[numbers[index1],\
    \ numbers[index2]]\n\t# end\n\t# if numbers[0] == numbers[1]\n\t# \t[numbers[0],\
    \ numbers[1]]\n\t# else\n\t# \tdifferences = []\n\t# \tnumbers.sort.each_with_index\
    \ do |num, i|\n\t# \t\tif numbers[i+1]\n\t# \t\t\tdifferences << numbers[i+1]\
    \ - num\n\t# \t\tend\n\t# \tend\n\t# \tminimum = differences.min\n\t# \tindex1\
    \ = differences.index(minimum)\n\t# \tindex2 = index1 + 1\n\t# \t[numbers[index1],\
    \ numbers[index2]]\n\t# end\n\tdiff", "  numbers.combination(2).min_by{|a,b| (a-b).abs}.sort\n\
    end", "  numbers.sort!\n  diffs = []\n  numbers.each_cons(2) do |a, b|\n    diffs\
    \ << a - b\n  end\n  diffs.index(diffs.min)\n  [numbers[diffs.index(diffs.min)],\
    \ numbers[diffs.index(diffs.min) + 1]]\nend", "    distances = {}\n    array_numbers\
    \ = []\n    (0..numbers.length-2).each do |i|\n        temp = numbers[i+1] - numbers[i]\n\
    \        distances[\"#{numbers[i]}-#{numbers[i+1]}\"] = temp.abs\n    end\n  \
    \  distances = distances.sort_by {|k,v| v}\n    distances.keys.each do |k|\n \
    \       array_numbers = k.split(\"-\")\n    end\n    return array_numbers\nend",
  '  numbers.sort!', "  raise \"You need at least two numbers to find the closest\"\
    \ if numbers.size < 2\n  raise \"I only work with numbers\" unless numbers.all?\
    \ { |number| number.kind_of?(Numeric) }", "  numbers.combination(2).map{|x,y|\
    \ [x,y,(x-y).abs]}.min_by{|a,b,c| c}[0..1]\nend", "  # create an empty hash where\
    \ key is number and value is the difference between the number and its next number\n\
    \  # sort the hash by value\n  # return the first two keys in an array\n  closest_numbers\
    \ = {}\n  numbers.each_with_index do |num, index|\n    if index < numbers.length\
    \ - 1\n      diff = (num - numbers[index + 1]).abs\n      closest_numbers[num]\
    \ = diff\n    end\n  end\n  sorted_by_value = closest_numbers.sort_by { |k, v|\
    \ v }\n  puts sorted_by_value\n  [sorted_by_value[0][0], sorted_by_value[1][0]]\n\
    end", "  # Your code here\nend", "  # TODO\nend", "  diffs = []\n  numbers.each_with_index\
    \ do |n,i|\n    numbers[i+1..-1].each do |m|\n      diffs << [(n-m).abs, n, m]\n\
    \    end\n  end\n  diffs.sort.shift[1..2]\nend", '  numbers = numbers.sort', " \
    \ closest_numbers = []\n  smallest_difference = nil\n  numbers.combination(2).each\
    \ do |pair|\n    diff = (pair[0] - pair[1]).abs\n    if smallest_difference.nil?\
    \ || diff < smallest_difference\n      smallest_difference = diff\n      closest_numbers\
    \ = pair\n    end\n  end\n  closest_numbers\nend", "  numbers = numbers.sort.reverse\n\
    \  closest_diff = numbers[0] - numbers[1]\n  i = 0\n  closest_elements = []\n\
    \  while i < numbers.length - 1\n    if (numbers[i] - numbers[i + 1]).abs < closest_diff\n\
    \      closest_diff = (numbers[i] - numbers[i + 1]).abs\n      closest_elements\
    \ = [numbers[i + 1], numbers[i]]\n    end\n    i += 1\n  end\n  closest_elements\n\
    end", "  numbers.sort!\n  diff = Float::INFINITY\n  result = [nil, nil]\n  numbers.each_with_index\
    \ do |n, i|\n    if (i + 1) < numbers.length\n      if numbers[i + 1] - n < diff\n\
    \        diff = numbers[i + 1] - n\n        result = [n, numbers[i + 1]]\n   \
    \   end\n    end\n  end\n  result\nend", "  numbers.sort\n  if numbers.length\
    \ == 2\n    if numbers[0] == numbers[1]\n      numbers\n    else\n      return\
    \ numbers.first(2)\n    end\n  end\n  closest_dist = (numbers[1] - numbers[0]).abs\n\
    \  i = 1\n  while i < numbers.length-1\n    dist = (numbers[i+1] - numbers[i]).abs\n\
    \    if dist < closest_dist\n      closest_dist = dist\n      closest_i = i\n\
    \    end\n    i += 1\n  end\n  return numbers[closest_i, 2]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
