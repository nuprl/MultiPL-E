name: HumanEval_20_find_closest_elements
language: rb
prompt: "# From a supplied array of numbers (of length at least two) select and return\
  \ two that are the closest to each\n# other and return them in order (smaller number,\
  \ larger number).\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  # [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
  # [2.0, 2.0]\ndef find_closest_elements(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n\
  \    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0,\
  \ 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2,\
  \ 3.1, 4.1, 5.1]))\n  end\nend\n"
completions: ["  distances = {}\n  numbers.each_with_index do |number, index|\n  \
    \  distances[index] = number\n  end\n  sorted_distances = distances.sort_by {\
    \ |distance, number| number }\n  sorted_distances.each_with_index do |element,\
    \ index|\n    current_number = element[1]\n    if index == 0\n      distances[element[0]]\
    \ = sorted_distances[index + 1][1] - current_number\n    elsif index == sorted_distances.length\
    \ - 1\n      distances[element[0]] = current_number - sorted_distances[index -\
    \ 1][1]\n    else\n      distances[element[0]] = [sorted_distances[index + 1][1]\
    \ - current_number, current_number - sorted_distances[index - 1][1]].min\n   \
    \ end\n  end\n  closest_distance = distances.min_by { |k, v| v }[1]\n  closest_elements\
    \ = distances.select { |k, v| v == closest_distance }\n  closest_elements = closest_elements.sort_by\
    \ { |k, v| k }\n  element_one = numbers[closest_elements[0][0]]\n  element_two\
    \ = numbers[closest_elements[1][0]]\n  [element_one, element_two]\nend", "  if\
    \ numbers.length < 2\n    return nil\n  end\n  closest_diff = nil\n  closest_element_1\
    \ = nil\n  closest_element_2 = nil\n  numbers.each_with_index do |element, index|\n\
    \    if index != numbers.length - 1\n      if closest_diff == nil || closest_diff\
    \ > (element - numbers[index + 1]).abs\n        closest_diff = (element - numbers[index\
    \ + 1]).abs\n        closest_element_1 = element\n        closest_element_2 =\
    \ numbers[index + 1]\n      end\n    end\n  end\n  [closest_element_1, closest_element_2]\n\
    end", "  smallest_difference = numbers[0] - numbers[1]\n  closest_elements = [numbers[0],\
    \ numbers[1]]\n  for i in (0..numbers.length-2)\n    for j in (i+1..numbers.length-1)\n\
    \      difference = numbers[i] - numbers[j]\n      if difference.abs < smallest_difference.abs\n\
    \        smallest_difference = difference\n        closest_elements = [numbers[i],\
    \ numbers[j]]\n      end\n    end\n  end\n  closest_elements\nend", "  min = numbers[1]\
    \ - numbers[0]\n  pair = [numbers[0], numbers[1]]\n  numbers.each_with_index do\
    \ |a, i|\n    i.upto(numbers.length-1) do |j|\n      if numbers[j] - a < min\n\
    \        min = numbers[j] - a\n        pair = [a, numbers[j]]\n      end\n   \
    \ end\n  end\n  return pair\nend", "  hash = Hash.new()\n  numbers.each_with_index\
    \ { |x,i| hash[x] = i }\n  numbers.sort!\n  smallest_diff = numbers[1] - numbers[0]\n\
    \  closest_elements = [numbers[0], numbers[1]]\n  for i in 1..numbers.length-1\n\
    \    if (numbers[i] - numbers[i-1]) < smallest_diff\n      smallest_diff = numbers[i]\
    \ - numbers[i-1]\n      closest_elements = [numbers[i-1], numbers[i]]\n    end\n\
    \  end\n  closest_elements\nend", "  result = []\n  numbers.each_with_index do\
    \ |number, index|\n    next_number = numbers[index + 1]\n    if next_number\n\
    \      diff_1 = (number - next_number).abs\n      diff_2 = (number - result[0]).abs\n\
    \      if diff_1 < diff_2\n        result = [number, next_number]\n      end\n\
    \    end\n  end\n  result\nend", "  numbers.map.with_index do |number, index|\n\
    \    next if index == 0\n    if index == numbers.length - 1\n      [number, numbers[index\
    \ - 1]]\n    else\n      diff_current = number - numbers[index - 1]\n      diff_next\
    \ = numbers[index + 1] - number\n      diff_current < diff_next ? [numbers[index\
    \ - 1], number] : [number, numbers[index + 1]]\n    end\n  end.compact.min_by\
    \ { |pair| pair[1] - pair[0] }\nend", "\tsmallest = numbers[0]\n\tbiggest = numbers[1]\n\
    \tnumbers.each_with_index do |num, index|\n\t\tif index != 0 && index != 1\n\t\
    \t\tif (num - numbers[index - 1]).abs < (biggest - smallest).abs\n\t\t\t\tsmallest\
    \ = numbers[index - 1]\n\t\t\t\tbiggest = num\n\t\t\tend\n\t\tend\n\tend\n\t[smallest,\
    \ biggest]\nend", "  numbers.sort!\n  distance = numbers[1] - numbers[0]\n  closest_numbers\
    \ = [numbers[0], numbers[1]]\n  for i in 1..numbers.length-2\n    if distance\
    \ > numbers[i+1] - numbers[i]\n      distance = numbers[i+1] - numbers[i]\n  \
    \    closest_numbers = [numbers[i], numbers[i+1]]\n    end\n  end\n  closest_numbers\n\
    end\nputs find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\nputs find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])", "\tnumbers = numbers.map(&:to_f)\n\tresult = [numbers[0],\
    \ numbers[1]]\n\t\n\tnumbers.each_with_index do |num, idx|\n\t\tbreak if idx >=\
    \ numbers.length - 1\n\t\t\n\t\tif (num - numbers[idx + 1]).abs < (result[0] -\
    \ result[1]).abs\n\t\t\tresult = [num, numbers[idx + 1]]\n\t\tend\n\tend\n\t\n\
    \treturn result\nend", "  length = numbers.length\n  raise ArgumentError, \"arguments\
    \ should be an array with length at least 2\" if length < 2\n  min_num, min_index\
    \ = numbers[0], 0\n  max_num, max_index = numbers[0], 0\n  # find out maximum\
    \ and minimum number from an array\n  numbers.each_with_index do |n, i|\n    if\
    \ n < min_num\n      min_num = n\n      min_index = i\n    end\n    if n > max_num\n\
    \      max_num = n\n      max_index = i\n    end\n  end\n  # current min and max\
    \ distance\n  min_dis = 0\n  max_dis = 0\n  # find out maximum and minimum distance\n\
    \  numbers.each_with_index do |n, i|\n    if i != min_index && i != max_index\n\
    \      if (n - min_num).abs < (n - max_num).abs\n        dis = (n - min_num).abs\n\
    \        if dis > min_dis\n          min_dis = dis\n        end\n      else\n\
    \        dis = (n - max_num).abs\n        if dis > max_dis\n          max_dis\
    \ = dis\n        end\n      end\n    end\n  end\n  # compare min_dis and max_dis\n\
    \  if min_dis > max_dis\n    return [min_num, max_num]\n  else\n    return [max_num,\
    \ min_num]\n  end\nend", "\tp numbers\n\tmin_diff = numbers[0] - numbers[1]\n\t\
    numbers.each_with_index do |num, index|\n\t\tif index != numbers.length - 1\n\t\
    \t\tif (num - numbers[index + 1]).abs < min_diff\n\t\t\t\tmin_diff = (num - numbers[index\
    \ + 1]).abs\n\t\t\t\tclosest_num = [num, numbers[index + 1]]\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn closest_num\nend", "  difference = 100000\n  # iterate over\
    \ each number\n  numbers.each_with_index do |number, index|\n    # iterate over\
    \ the rest of the numbers\n    numbers[index + 1..-1].each do |next_number|\n\
    \      if difference > (number - next_number).abs\n        difference = (number\
    \ - next_number).abs\n        closest_pair = [number, next_number]\n      end\n\
    \    end\n  end\n  return closest_pair\nend", "  numbers.combination(2).min_by\
    \ { |x, y| (x - y).abs }\nend", "  numbers.sort!\n  diff = []\n  numbers.each_cons(2)\
    \ do |pair|\n    diff << (pair[1] - pair[0]).abs\n  end\n  smallest_diff = diff.min\n\
    \  smallest_diff_index = diff.index(smallest_diff)\n  [numbers[smallest_diff_index],\
    \ numbers[smallest_diff_index + 1]]\nend", "  numbers.sort\n  min_diff = numbers[-1]\
    \ - numbers[0]\n  closest_elements = [numbers[0], numbers[1]]\n  numbers.each_with_index\
    \ do |number, index|\n    next if index == numbers.length - 1\n    if numbers[index\
    \ + 1] - number < min_diff\n      min_diff = numbers[index + 1] - number\n   \
    \   closest_elements = [number, numbers[index + 1]]\n    end\n  end\n  closest_elements\n\
    end", "  numbers.sort!\n  diffs = []\n  numbers.each_cons(2) do |x, y|\n    diffs\
    \ << { diff: y - x, numbers: [x, y] }\n  end\n  min_diff = diffs.min_by { |diff|\
    \ diff[:diff] }\n  min_diff[:numbers]\nend", "  numbers.sort!\n  closest_pair\
    \ = []\n  last_distance = nil\n  numbers.each_cons(2) do |pair|\n    distance\
    \ = pair[1] - pair[0]\n    if last_distance.nil?\n      closest_pair = pair\n\
    \      last_distance = distance\n    elsif distance < last_distance\n      closest_pair\
    \ = pair\n      last_distance = distance\n    end\n  end\n  closest_pair\nend",
  "  numbers = numbers.sort\n  min_diff = Float::INFINITY\n  min_elements = []\n \
    \ numbers.each_with_index do |n, i|\n    if i == numbers.length - 1\n      break\n\
    \    end\n    if numbers[i + 1] - n < min_diff\n      min_diff = numbers[i + 1]\
    \ - n\n      min_elements = [n, numbers[i + 1]]\n    end\n  end\n  min_elements\n\
    end", "  numbers.combination(2).reduce do |memo, pair|\n    memo.first.reduce(pair)\
    \ do |memo, other|\n      (memo.last - memo.first).abs < (other.last - other.first).abs\
    \ ? memo : other\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
