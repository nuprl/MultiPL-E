name: HumanEval_18_how_many_times
language: rb
prompt: "# Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n# >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"\
  aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string,\
  \ substring)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n\
  \    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\"\
  , \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4,\
  \ candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"\
  john doe\", \"john\"))\n  end\nend\n"
completions: ["  count = 0\n  if string.match(substring)\n    count += 1\n    how_many_times(string.sub(substring,\
    \ \"\"), substring)\n  end\n  count\nend", "  # create a counter and a result\n\
    \  counter = 0\n  result = []\n  # loop through the string by character\n  string.each_char\
    \ do |char|\n    # if the character is in the substring\n    if char == substring[0]\n\
    \      # if the next characters match\n      if string[counter, substring.length]\
    \ == substring\n        # push the substring into the result array\n        result\
    \ << substring\n      end\n    end\n    # advance the counter\n    counter +=\
    \ 1\n  end\n  # return the length of the result array\n  result.length\nend",
  "  string.scan(/(?=#{substring})/).count\nend", "  count = 0\n  offset = 0\n  while\
    \ offset = string.index(substring, offset)\n    count += 1\n    offset += 1\n\
    \  end\n  count\nend", "  string.gsub(/(?=#{substring})/, '*').count('*')\nend",
  "  count = 0\n  string.scan(substring).each do |match|\n    count += 1\n  end\n\
    \  count\nend", "  string.scan(/(?=#{substring})/).count\nend", "  raise Exception.new(\"\
    empty string\") if substring.empty?\n  return 0 if string.empty?", "  found =\
    \ 0\n  string.scan(/#{substring}/) { found += 1 }\n  found\nend", "\ti=0\n\tx=0\n\
    \twhile i<string.length\n\t\tif string[i]==substring[0]\n\t\t\tif string[i+1]==substring[1]\n\
    \t\t\t\tx+=1\n\t\t\tend\n\t\tend\n\t\ti+=1\n\tend\n\tx\nend", "  count = 0\n \
    \ index = 0\n  string.chars.each_with_index do |letter, i|\n    if letter == substring[index]\n\
    \      index += 1\n      if index == substring.length\n        count += 1\n  \
    \      index = 0\n      end\n    else\n      index = 0\n    end\n  end\n  count\n\
    end", "    string.scan(substring).length\nend", "  return 0 if string.length ==\
    \ 0\n  num = 0\n  string.split('').each_with_index do |_, i|\n    num += 1 if\
    \ string[i, substring.length] == substring\n  end\n  num\nend", "  how_many_times\
    \ = 0\n  for i in 0..string.length\n    for j in 0..substring.length\n      count\
    \ = 0\n      for k in 0..substring.length\n        count += 1 if string[i+k] ==\
    \ substring[j+k]\n      end\n      how_many_times += 1 if count == substring.length\n\
    \    end\n  end\n  how_many_times\nend", "  raise ArgumentError, \"String can't\
    \ be nil\" if string.nil?\n  raise ArgumentError, \"Substring can't be nil\" if\
    \ substring.nil?\n  string.scan(/(?=#{substring})/).count\nend", "  count = 0\n\
    \  for i in 0..string.length-1\n    count += 1 if string[i, substring.length]\
    \ == substring\n  end\n  count\nend", "  string.scan(substring).length\nend",
  "  count = 0\n  index = 0\n  while index < string.length\n    index = string.index(substring,\
    \ index)\n    if index == nil\n      return count\n    else\n      count += 1\n\
    \      index += 1\n    end\n  end\n  return count\nend", "  string.scan(/(?=#{substring})/).count\n\
    end", "    # Convert string and substring to arrays, so we can use .drop()\n \
    \   letters = string.split(\"\")\n    letters.unshift(substring)\n    # Detect\
    \ where substring is\n    locs = letters.each_index.select { |index| letters[index]\
    \ == substring }\n    # Drop the substring, leaving just the string\n    string\
    \ = letters.drop(1)\n    # Count the substring\n    count = 0\n    length = substring.length\n\
    \    while locs.length > 0\n        count += 1\n        # Shift the string by\
    \ the substring length to detect the next substring\n        # Drop the first\
    \ element of locs, since it has been counted\n        string = string.drop(locs.shift\
    \ - length + 1)\n        locs = string.each_index.select { |index| string[index]\
    \ == substring }\n    end\n    count\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
