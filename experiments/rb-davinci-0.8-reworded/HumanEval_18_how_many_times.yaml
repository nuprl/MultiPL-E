name: HumanEval_18_how_many_times
language: rb
prompt: "# Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n# >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"\
  aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string,\
  \ substring)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n\
  \    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\"\
  , \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4,\
  \ candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"\
  john doe\", \"john\"))\n  end\nend\n"
completions: ["  count = 0\n  if string.match(substring)\n    count += 1\n    how_many_times(string.sub(substring,\
    \ \"\"), substring)\n  end\n  count\nend", "  # create a counter and a result\n\
    \  counter = 0\n  result = []\n  # loop through the string by character\n  string.each_char\
    \ do |char|\n    # if the character is in the substring\n    if char == substring[0]\n\
    \      # if the next characters match\n      if string[counter, substring.length]\
    \ == substring\n        # push the substring into the result array\n        result\
    \ << substring\n      end\n    end\n    # advance the counter\n    counter +=\
    \ 1\n  end\n  # return the length of the result array\n  result.length\nend",
  "  string.scan(/(?=#{substring})/).count\nend", "  count = 0\n  offset = 0\n  while\
    \ offset = string.index(substring, offset)\n    count += 1\n    offset += 1\n\
    \  end\n  count\nend", "  string.gsub(/(?=#{substring})/, '*').count('*')\nend",
  "  count = 0\n  string.scan(substring).each do |match|\n    count += 1\n  end\n\
    \  count\nend", "  string.scan(/(?=#{substring})/).count\nend", "  raise Exception.new(\"\
    empty string\") if substring.empty?\n  return 0 if string.empty?", "  found =\
    \ 0\n  string.scan(/#{substring}/) { found += 1 }\n  found\nend", "\ti=0\n\tx=0\n\
    \twhile i<string.length\n\t\tif string[i]==substring[0]\n\t\t\tif string[i+1]==substring[1]\n\
    \t\t\t\tx+=1\n\t\t\tend\n\t\tend\n\t\ti+=1\n\tend\n\tx\nend", "  count = 0\n \
    \ index = 0\n  string.chars.each_with_index do |letter, i|\n    if letter == substring[index]\n\
    \      index += 1\n      if index == substring.length\n        count += 1\n  \
    \      index = 0\n      end\n    else\n      index = 0\n    end\n  end\n  count\n\
    end", "    string.scan(substring).length\nend", "  return 0 if string.length ==\
    \ 0\n  num = 0\n  string.split('').each_with_index do |_, i|\n    num += 1 if\
    \ string[i, substring.length] == substring\n  end\n  num\nend", "  how_many_times\
    \ = 0\n  for i in 0..string.length\n    for j in 0..substring.length\n      count\
    \ = 0\n      for k in 0..substring.length\n        count += 1 if string[i+k] ==\
    \ substring[j+k]\n      end\n      how_many_times += 1 if count == substring.length\n\
    \    end\n  end\n  how_many_times\nend", "  raise ArgumentError, \"String can't\
    \ be nil\" if string.nil?\n  raise ArgumentError, \"Substring can't be nil\" if\
    \ substring.nil?\n  string.scan(/(?=#{substring})/).count\nend", "  count = 0\n\
    \  for i in 0..string.length-1\n    count += 1 if string[i, substring.length]\
    \ == substring\n  end\n  count\nend", "  string.scan(substring).length\nend",
  "  count = 0\n  index = 0\n  while index < string.length\n    index = string.index(substring,\
    \ index)\n    if index == nil\n      return count\n    else\n      count += 1\n\
    \      index += 1\n    end\n  end\n  return count\nend", "  string.scan(/(?=#{substring})/).count\n\
    end", "    # Convert string and substring to arrays, so we can use .drop()\n \
    \   letters = string.split(\"\")\n    letters.unshift(substring)\n    # Detect\
    \ where substring is\n    locs = letters.each_index.select { |index| letters[index]\
    \ == substring }\n    # Drop the substring, leaving just the string\n    string\
    \ = letters.drop(1)\n    # Count the substring\n    count = 0\n    length = substring.length\n\
    \    while locs.length > 0\n        count += 1\n        # Shift the string by\
    \ the substring length to detect the next substring\n        # Drop the first\
    \ element of locs, since it has been counted\n        string = string.drop(locs.shift\
    \ - length + 1)\n        locs = string.each_index.select { |index| string[index]\
    \ == substring }\n    end\n    count\nend", "  total = 0\n  count = 0\n  while\
    \ count < string.length\n    if string[count..count + substring.length - 1] ==\
    \ substring\n      total += 1\n    end\n    count += 1\n  end\n  total\nend",
  "  count = 0\n  string.each_char.with_index do |char, index|\n    if string[index..index\
    \ + substring.length - 1] == substring\n      count += 1\n    end\n  end\n  count\n\
    end", "  return 0 if string.empty?\n  return 1 if substring.length == 1\n  count\
    \ = 0\n  idx = 0\n  while idx < string.length\n    if string[idx, substring.length]\
    \ == substring\n      count += 1\n      idx += substring.length\n    else\n  \
    \    idx += 1\n    end\n  end\n  count\nend", "  string.scan(substring).count\n\
    end", "    string.scan(substring).count\nend", "  return string.scan(substring).count\n\
    end", "  string.scan(/#{substring}/).count\nend", "  # Write your code here\n\
    end", "  string.scan(substring).count\nend", "  string.scan(/(?=#{substring})/).count\n\
    end", "  return 0 if string.size < substring.size\n  return string.size if substring.size\
    \ == 1\n  count = 0\n  0.upto(string.size - substring.size) do |i|\n    count\
    \ += 1 if string[i..(i + substring.size - 1)] == substring\n  end\n  count\nend",
  "    string.scan(substring).count\nend", "  if string == \"\"\n    return 0\n  end\n\
    \  times = 0\n  for i in 0..string.length - substring.length\n    if string[i,\
    \ substring.length] == substring\n      times += 1\n    end\n  end\n  return times\n\
    end", "  return 0 if substring.length > string.length\n  return 1 if substring.length\
    \ == string.length", "    count = 0\n    (0..string.length-substring.length).each\
    \ do |i|\n        count += 1 if string[i..i+substring.length-1] == substring\n\
    \    end\n    count\nend", "  string.scan(/(?=#{substring})/).count\nend", "\t\
    # ans = []\n\t# (0..string.length-1).each do |i|\n\t# \tif (string[i] == substring[0])\n\
    \t# \t\tif (substring == string[i..i+substring.length-1])\n\t# \t\t\tans << i\n\
    \t# \t\tend\n\t# \tend\n\t# end\n\t# ans.length\n\ti = 0\n\tcount = 0\n\twhile\
    \ (i <= string.length-substring.length)\n\t\tif (string[i] == substring[0])\n\t\
    \t\tif (substring == string[i..i+substring.length-1])\n\t\t\t\tcount += 1\n\t\t\
    \tend\n\t\tend\n\t\ti += 1\n\tend\n\tcount\nend", '  return 0 if substring.empty?',
  "  raise NotImplementedError\nend", "  string.scan(/(?=#{substring})/).count\nend",
  "  count = 0\n  (0..string.length - substring.length).each do |index|\n    if string[index..index\
    \ + substring.length - 1] == substring\n      count += 1\n    end\n  end\n  count\n\
    end", "  string.scan(/#{substring}/).count\nend", "  count = 0\n  n = substring.length\n\
    \  until n > string.length\n    if string[0..n-1] == substring\n      count +=\
    \ 1\n    end\n    string.slice!(0)\n  end\n  count\nend", "  return 0 if string.empty?\n\
    \  return string.scan(substring).length\nend", "  return 0 if string.empty?\n\
    \  # This is the actual text area\n  counter = 0\n  (0..string.length).each do\
    \ |i|\n    if string[i..i+substring.length-1] == substring\n      counter += 1\n\
    \    end\n  end\n  counter\nend", "  count = 0\n  (0..string.length - substring.length).each\
    \ do |i|\n    if string[i, substring.length] == substring\n      count += 1\n\
    \    end\n  end\n  count\nend", "  # call the function only if the string isn't\
    \ empty\n  string.empty? ? 0 :\n  string.scan(/(?=#{substring})/).count\nend",
  "  substring_length = substring.length\n  times = 0\n  index = 0\n  while (index\
    \ + substring_length) <= string.length\n    current_substring = string[index..(index\
    \ + substring_length - 1)]\n    if current_substring == substring\n      times\
    \ += 1\n    end\n    index += 1\n  end\n  times\nend", "  count = 0\n  (0..string.length).each\
    \ do |idx|\n    count += 1 if string[idx..idx + substring.length - 1] == substring\n\
    \  end\n  count\nend", "  string.scan(/(?=#{substring})/).count\nend", '  return
    0 if substring.empty?', "  string.scan(substring).count\nend", "  string.scan(/(?=#{substring})/).count\n\
    end", "  string.scan(/(?=#{substring})/).count\nend", "  return 0 if string.empty?\n\
    \  return 0 if substring.empty?\n  return 0 if substring.length > string.length\n\
    \  new_str = string.downcase\n  new_substr = substring.downcase\n  count = 0\n\
    \  (0..new_str.length - new_substr.length).each do |i|\n    if new_str[i, new_substr.length]\
    \ == new_substr\n      count += 1\n    end\n  end\n  count\nend", "  return 0\
    \ if string.empty?\n  return 0 if substring.empty?\n  return 0 if substring.length\
    \ > string.length\n  count = 0\n  index = 0\n  while index = string.index(substring,\
    \ index)\n    count += 1\n    index += 1\n  end\n  count\nend", "  string.scan(substring).count\n\
    end", "  count = 0\n  string.size.times do |i|\n    count += 1 if string[i..-1].start_with?(substring)\n\
    \  end\n  count\nend", "  times = 0\n  string.scan(/#{substring}/) { times +=\
    \ 1 }\n  times\nend", "  counter = 0\n  while string.include?(substring)\n   \
    \ string.sub!(substring, \"\")\n    counter += 1\n  end\n  counter\nend", "  string.scan(/(?=#{substring})/).count\n\
    end", "  return string.scan(substring).length if string.length < 2\n  return 0\
    \ if string.length < substring.length\n  return 1 if string.scan(substring).length\
    \ == 1\n  return how_many_times(string.chop, substring) + how_many_times(string.chop.chop,\
    \ substring)\nend", "  i = 0\n  count = 0\n  while i < string.length\n    if string[i,\
    \ substring.length] == substring\n      count += 1\n      i += substring.length\n\
    \    else\n      i += 1\n    end\n  end\n  count\nend", "    string.scan(/#{substring}/).count\n\
    end", "  string_length = string.length\n  substring_length = substring.length\n\
    \  count = 0\n  i = 0\n  while (i < string_length)\n    if (string[i, substring_length]\
    \ == substring)\n      count += 1\n      i += substring_length\n    else\n   \
    \   i += 1\n    end\n  end\n  count\nend", "  if string.size == 0 || substring.size\
    \ == 0\n    0\n  else\n    count = 0\n    (0..string.size - substring.size).each\
    \ do |i|\n      count += 1 if string[i..i + substring.size - 1] == substring\n\
    \    end\n    count\n  end\nend", "  (string.length - substring.length + 1).times.count\
    \ { |i|\n    string[i, substring.length] == substring\n  }\nend", "  counter =\
    \ 0\n  substring_length = substring.length\n  for i in 0..string.length - substring_length\n\
    \    counter += 1 if string[i..i + substring_length - 1] == substring\n  end\n\
    \  counter\nend", "  i = 0\n  count = 0\n  while i < string.length\n    if string[i..i\
    \ + substring.length - 1] == substring\n      count += 1\n      i += substring.length\
    \ - 1\n    end\n    i += 1\n  end\n  count\nend", "    count = 0\n    string.size.times\
    \ do |i|\n        match = string[i, substring.size]\n        count += 1 if match\
    \ == substring\n    end\n    count\nend", "  string.scan(substring).length\nend",
  "  (string.length - substring.length + 1).times.count { |i|\n    string[i, substring.length]\
    \ == substring\n  }\nend", "  count = 0\n  if string == \"\"\n    count\n  else\n\
    \    count = 1 + how_many_times(string[1..-1], substring)\n  end\nend", "  count\
    \ = 0\n  i = 0\n  while i <= string.length\n    if string[i..-1].start_with?(substring)\n\
    \      count += 1\n      i += substring.length\n    else\n      i += 1\n    end\n\
    \  end\n  count\nend", "  return string.scan(substring).count\nend", "  string.scan(substring).count\n\
    end", "  return 0 if string.length == 0 || substring.length == 0\n  # substring_length\
    \ = substring.length - 1\n  # array = string.split(substring)\n  # if array.length\
    \ == 1\n  #   string.include?(substring) ? 1 : 0\n  # else\n  #   array.length\
    \ - 1\n  # end\n  str = string.split(substring)\n  str.length - 1\nend", "  count\
    \ = 0\n  sub_length = substring.length", "  if string.empty? || substring.empty?\n\
    \    0\n  else\n    string.scan(substring).length\n  end\nend", "  return 0 if\
    \ string.length == 0 || substring.length == 0\n  new_string = string.gsub(substring,\
    \ ' ')\n  number_of_spaces = new_string.length - string.length\n  (number_of_spaces\
    \ + 1) / 2\nend", "  string.scan(substring).count\nend", "  raise TypeError unless\
    \ string.class == String && substring.class == String\n  return 0 if string.empty?\
    \ || substring.empty?\n  return string.length / substring.length if string ==\
    \ substring", '  return 0 if string.empty? || substring.empty?', "  times = 0\n\
    \  pos = string.index(substring)\n  while pos != nil\n    times += 1\n    pos\
    \ = string.index(substring, pos + 1)\n  end\n  times\nend", end, "  string.scan(substring).count\n\
    end", "  # Your code goes here\nend", "  count = 0\n  index = 0\n  while index\
    \ < string.length\n    if string[index, substring.length] == substring\n     \
    \ count += 1\n      index += substring.length\n    else\n      index += 1\n  \
    \  end\n  end\n  count\nend", "  count = 0\n  while string.include?(substring)\n\
    \    string = string.sub(substring, '')\n    count += 1\n  end\n  count\nend",
  "  p string\n  p substring\n  counter = 0\n  string.scan(substring) do |match|\n\
    \    counter += 1\n  end\n  counter\nend", "  0\nend", "  (string.length - substring.length\
    \ + 1).times.map { |i|\n    string[i, substring.length] == substring\n  }.select{\
    \ |element| element == true }.length\nend", "  count = 0\n  index = 0\n  string_length\
    \ = string.length\n  substring_length = substring.length\n  while index < string_length\n\
    \    if string[index, substring_length] == substring\n      count += 1\n     \
    \ index += substring_length\n    else\n      index += 1\n    end\n  end\n  count\n\
    end", "  count = 0\n  string.size.times do |n|\n    count += 1 if string[n..(n\
    \ + substring.size - 1)] == substring\n  end\n  count\nend", "  if string.length\
    \ == 0\n    return 0\n  end\n  matches = 0\n  (0..string.length-substring.length).each\
    \ do |i|\n    if string[i, substring.length] == substring\n      matches += 1\n\
    \    end\n  end\n  matches\nend", "  # Your code here\nend", "  string.scan(substring).length\n\
    end", "  # co_string = string.codepoints\n  # co_substring = substring.codepoints\n\
    \  # p co_string.size\n  string_size = string.size\n  substring_size = substring.size\n\
    \  count = 0\n  while string_size >= substring_size\n    if (string[(string_size\
    \ - substring_size), substring_size] == substring)\n      count += 1\n    end\n\
    \    string_size -= 1\n  end\n  count\nend", "  string.scan(/(?=#{substring})/).length\n\
    end", "  times = 0\n  string.scan(substring) { times += 1 }\n  times\nend", " \
    \ count = 0\n  idx = 0\n  while string.index(substring, idx) != nil\n    count\
    \ += 1\n    idx = string.index(substring, idx) + 1\n  end\n  count\nend", "  string.split(substring).length\
    \ - 1\nend", "  count = 0\n  (0..string.length).each do |index|\n    count +=\
    \ 1 if string[index..index + substring.length - 1] == substring\n  end\n  count\n\
    end", "  count = 0\n  (0..string.length).each do |i|\n    substring_start = i\n\
    \    substring_end = i + substring.length - 1\n    next if substring_end > string.length\
    \ - 1\n    count += 1 if string[substring_start..substring_end] == substring\n\
    \  end\n  count\nend", "  string.size\nend", "  matches = string.scan(substring)\n\
    \  matches.length\nend", "  times = string.scan(/#{substring}/).length\n  puts\
    \ times\nend", "  i = string.scan(substring).count\n  puts i\nend", "  0\nend",
  "  raise \"TODO\"\nend", "  # returns the number of times substring can be found\
    \ in the string\n  string.scan(substring).count\nend", "  return 0 if substring.length\
    \ > string.length\n  if string.include?(substring)\n    string.chars.each_cons(substring.length).count\
    \ { |arr| arr.join == substring }\n  else\n    0\n  end\nend", "  string.scan(substring).length\n\
    end", '  return 0 if string.empty?', "  return 0 if string.empty? || substring.empty?\n\
    \  counter = 0\n  index = 0\n  loop do\n    if string.index(substring, index)\n\
    \      counter += 1\n      index = string.index(substring, index) + 1\n    else\n\
    \      break\n    end\n  end\n  counter\nend", "  return 0 if string.empty?\n\
    \  substring_size = substring.size\n  return string.count(substring) if substring_size\
    \ == 1\n  substring_index = string.index(substring)\n  substring_index = 0 if\
    \ substring_index.nil?\n  1 + how_many_times(string[substring_index + substring_size..-1],\
    \ substring)\nend", "  string.scan(/#{substring}/).count\nend", "  raise ArgumentError,\
    \ \"The substring cannot be empty\" if substring.empty?\n  return 0 if string.empty?",
  "  l = substring.length\n  (0..string.length - l).count { |i| string[i, l] == substring\
    \ }\nend", "  string.scan(/#{substring}/).count\nend", "  # Your code here\nend",
  "    count = 0\n    index = 0\n    while index < string.length\n        if string[index..(index\
    \ + substring.length - 1)] == substring\n            count += 1\n        end\n\
    \        index += 1\n    end\n    count\nend", "  string.scan(substring).count\n\
    end", "  count = 0\n  0.upto(string.length - substring.length) do |index|\n  \
    \  count += 1 if string[index, substring.length] == substring\n  end\n  count\n\
    end", "  string.scan(substring).count\nend", "  # TODO: implement this method\n\
    end", "  string.scan(substring).length\nend", "  return 0 if string.size < substring.size\n\
    \  return 1 if string.size == substring.size\n  return how_many_times(string[1..-1],\
    \ substring) + how_many_times(string[0..-2], substring) if string.size > substring.size",
  "\t# split the string into an array of substrings of the length of the substring\
    \ and then count the amount of time the substring is in the string\n\tstring.scan(/(?=#{substring})/).count\n\
    end", "  string.scan(substring).length\nend", "  if string.empty?\n    0\n  else\n\
    \    string.scan(/(?=#{substring})/).count\n  end\nend", "  count = 0\n  for i\
    \ in 0..string.length\n    if string[i..(i+substring.length-1)] == substring\n\
    \      count += 1\n    end\n  end\n  return count\nend", "\tstring.scan(/(?=#{substring})/).count\n\
    end", "  count = 0\n  string.scan(substring) { count += 1 }\n  count\nend", " \
    \ return 0 if string.empty?\n  return 1 if substring.length == 1", "  string.scan(substring).count\n\
    end", "  string.scan(substring).count\nend", "  return 0 if substring.length >\
    \ string.length\n  return 1 if substring.length == string.length\n  count = 0\n\
    \  sub_pos = 0\n  sub_length = substring.length\n  string.split('').each_with_index\
    \ do |letter, i|\n    if substring[sub_pos] == letter\n      if substring[sub_pos+1]\
    \ == string[i+1]\n        sub_pos += 1\n        count += 1 if sub_pos == sub_length-1\n\
    \      else\n        sub_pos = 0\n      end\n    end\n  end\n  count\nend", " \
    \ count = 0\n  (0..string.length).each do |i|\n    if string[i..substring.length]\
    \ == substring\n      count += 1\n    end\n  end\n  count\nend", "  count = 0\n\
    \  (0..string.length).each do |n|\n    string.include?(substring) ? count += 1\
    \ : count\n  end\n  count\nend", "  count = 0\n  index = 0\n  while index <= string.length\
    \ - substring.length\n    index = string.index(substring, index)\n    break if\
    \ index.nil?\n    count += 1\n    index += 1\n  end\n  count\nend", "  string.scan(/#{substring}/).count\n\
    end", "  count = 0\n  i = 0\n  index = 0\n  while i < string.length\n    index\
    \ = string.index(substring, i)\n    break if index.nil?\n    count += 1\n    i\
    \ = index + 1\n  end\n  count\nend", "  raise ArgumentError, \"Input must be a\
    \ string\" unless string.is_a?(String) && substring.is_a?(String)\n  raise ArgumentError,\
    \ \"Input string must be longer than substring\" unless string.length >= substring.length\n\
    \  return string.scan(substring).length\nend", "  str_length = string.length\n\
    \  sub_length = substring.length\n  r = 0\n  index = 0\n  while (index + sub_length)\
    \ <= str_length\n    if string[index, sub_length] == substring\n      r += 1\n\
    \      index += sub_length\n    else\n      index += 1\n    end\n  end\n  r\n\
    end", "  # TODO: Implement\nend", "  if string.size == 0\n    return 0\n  elsif\
    \ substring.size == 0\n    return 0\n  else\n    string_array = string.split(//)\n\
    \    substring_array = substring.split(//)\n    count = 0\n    index = 0\n   \
    \ while index < string_array.size\n      if string_array[index] == substring_array[0]\n\
    \        substring_index = 0\n        while substring_index < substring_array.size\n\
    \          if string_array[index+substring_index] == substring_array[substring_index]\n\
    \            if substring_index == substring_array.size - 1\n              count\
    \ += 1\n            end\n          else\n            break\n          end\n  \
    \        substring_index += 1\n        end\n      end\n      index += 1\n    end\n\
    \    return count\n  end\nend", "  count = 0\n  sub_count = 0\n  sub_arr = substring.split('')\n\
    \  sub_len = sub_arr.length\n  loop do\n    string.match(substring) ? count +=\
    \ 1 : break\n    string = string.sub(substring, '!')\n  end\n  count\nend", '  return
    0 if string.empty? || substring.empty?', "  string.chars.each_cons(substring.length).inject(0)\
    \ do |memo, current|\n    memo += 1 if current.join == substring\n    memo\n \
    \ end\nend", "  return 0 if string.empty? || substring.empty?\n  count = 0\n \
    \ substring_length = substring.length", "  return 0 if substring.length > string.length\n\
    \  count = 0\n  (0..string.length - substring.length).each do |i|\n    count +=\
    \ 1 if string[i, substring.length] == substring\n  end\n  count\nend", "  string.scan(substring).count\n\
    end", "  string.scan(/#{substring}/).count\nend", "  return 0 if string.empty?\
    \ || substring.empty?\n  string.scan(/(?=#{substring})/).count\nend", "  return\
    \ 0 if substring.length > string.length\n  count = 0\n  (0..string.length - substring.length).each\
    \ do |i|\n    count += 1 if string[i..i + substring.length - 1] == substring\n\
    \  end\n  count\nend", "  times = 0\n  index = 0\n  while (index = string.index(substring,\
    \ index))\n    times += 1\n    index += 1\n  end\n  times\nend", "  count = 0\n\
    \  loop do\n    if string.include?(substring)\n      count += 1\n      string.sub!(substring,\
    \ \"\")\n    else\n      break\n    end\n  end\n  count\nend", "  string.scan(substring).length\n\
    end", "  return 0 if string.length == 0\n  count = 0\n  string.split('').each_with_index\
    \ do |char, index|\n    if string[index..index + substring.length - 1] == substring\n\
    \      count += 1\n    end\n  end\n  count\nend", "    counter = 0\n    if substring.length\
    \ > 0\n        i = 0\n        while i < string.length\n            if string[i]\
    \ == substring[0]\n                if string[i..i+substring.length-1] == substring\n\
    \                    counter += 1\n                end\n            end\n    \
    \        i += 1\n        end\n    end\n    return counter\nend", "  # code here\n\
    end", "  return string.scan(substring).length\nend", "  count = 0\n  for i in\
    \ 0..string.length\n    for j in 0..substring.length\n      if string[i] == substring[j]\n\
    \        count = count + 1\n      end\n    end\n  end\n  count\nend", "  string.scan(/(?=#{substring})/).count\n\
    end", "    count = 0\n    substring.length.times do |start_index|\n        start_index.upto(string.length\
    \ - substring.length) do |sub_start_index|\n            if substring[start_index]\
    \ == string[sub_start_index]\n                count += 1 if substring[start_index..-1]\
    \ == string[sub_start_index..sub_start_index + substring.length - 1]\n       \
    \     end\n        end\n    end\n    count\nend", "  return 0 if substring.length\
    \ == 0\n  string.scan(substring).length\nend", "  index = string.index(substring)\n\
    \  index ? 1 + how_many_times(string[index + 1..-1], substring) : 0\nend", " \
    \ raise \"Implement me!\"\nend", "  string.scan(/(?=#{substring})/).count\nend",
  "  return 0 if string.empty?\n  return 1 if substring.empty?\n  if string.length\
    \ > substring.length\n    string[substring] ? string.scan(substring).length :\
    \ 0\n  else\n    string == substring ? 1 : 0\n  end\nend", "  start_pos = 0\n\
    \  count = 0\n  while string.index(substring, start_pos)\n    count += 1\n   \
    \ start_pos = string.index(substring, start_pos) + 1\n  end\n  count\nend", " \
    \ string.scan(/(?=#{substring})/).count\nend", "  result = 0\n  string.scan(substring)\
    \ { result += 1 }\n  result\nend", "  return 0 if string.empty?\n  string.scan(/(?=#{substring})/).count\n\
    end", "\t# Your Code Here\nend", "  return 0 if string.empty? || substring.empty?\n\
    \  return string.count(substring) if substring.length == 1\n  return 0 if string.length\
    \ < substring.length\n  n = 0\n  i = 0\n  while i <= string.length - substring.length\n\
    \    if string[i] == substring[0]\n      n += 1 if string[i, substring.length]\
    \ == substring\n    end\n    i += 1\n  end\n  n\nend", "  # your code here\nend",
  "  n = string.length\n  m = substring.length\n  count = 0\n  for i in 0..n-m\n \
    \   if string[i,m] == substring\n      count += 1\n    end\n  end\n  return count\n\
    end", "  (string.length - substring.length + 1).times.count { |i| string[i..i\
    \ + substring.length - 1] == substring }\nend", "  x = 0\n  string.scan(substring)\
    \ {x += 1}\n  x\nend", "  return 0 if substring.empty?\n  string.downcase.scan(/(?=#{substring})/).count\n\
    end", "  string.scan(/(?=#{substring})/).count\nend", "  string.scan(/(?=#{substring})/).count\n\
    end", "  count = 0\n  string.scan(substring).count\nend", "  string.scan(/(?=#{substring})/).count\n\
    end", "  # Regex of the subsring\n  regex = Regexp.new(substring)\n  # Search\
    \ string for regex\n  string.scan(regex).length\nend", "  string.size == 0 ? 0\
    \ : string.scan(/(?=#{substring})/).count\nend", "  count = 0\n  return count\
    \ if string.length == 0\n  count = 1 if string == substring\n  string.length.times\
    \ do |i|\n    if substring == string[i...i+substring.length]\n      count += 1\n\
    \    end\n  end\n  count\nend", "  string.scan(substring).count\nend", "  string.scan(substring).count\n\
    end", "  return 0 if string.empty? || substring.empty?\n  string.scan(/(?=#{substring})/).count\n\
    end", "  res = 0\n  last_idx = 0\n  while (last_idx = string.index(substring,\
    \ last_idx))\n    res += 1\n    last_idx += 1\n  end\n  res\nend", "  # TODO:\
    \ YOUR CODE HERE\nend", "  start_index = 0\n  occurences = 0\n  while (index =\
    \ string.index(substring, start_index))\n    occurences += 1\n    start_index\
    \ = index + 1\n  end\n  occurences\nend", "  count = 0\n  i = 0\n  while i < string.length\n\
    \    if string[i, substring.length] == substring\n      count += 1\n      i +=\
    \ substring.length - 1\n    end\n    i += 1\n  end\n  count\nend", "    string.scan(substring).length\n\
    end", "  return 0 if string.length == 0\n  string.scan(substring).length\nend",
  "  string.scan(/(?=#{substring})/).count\nend", "  # Your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
