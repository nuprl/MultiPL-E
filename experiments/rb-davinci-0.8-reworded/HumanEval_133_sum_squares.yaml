name: HumanEval_133_sum_squares
language: rb
prompt: "# You are given an array of numbers.\n# You need to return the sum of squared\
  \ numbers in the given array,\n# round each element in the array to the upper int(Ceiling)\
  \ first.\n# Examples:\n# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0,\
  \ 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4,\
  \ 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n\
  \    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0,\
  \ 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84,\
  \ candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4,\
  \ 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230,\
  \ candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0,\
  \ 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086,\
  \ candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n\
  \    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0,\
  \ 1.0, 0.0]))\n  end\nend\n"
completions: ["  lst.map{|num| num.ceil}.map{|num| num**2}.reduce(:+)\nend", "  #Your\
    \ code here\nend", "  lst.map!{|num| num.ceil}.map{|num| num**2}.inject(:+)\n\
    end", "  lst.map{|e| e.ceil ** 2}.reduce(:+)\nend", "  lst.map { |x| x.ceil**2\
    \ }.sum\nend", "  lst.map { |n| n.ceil ** 2 }.reduce(:+)\nend", "  lst.map { |el|\
    \ el.ceil**2 }.sum\nend", "  lst.map!{|x| (x + 1).ceil}.map{|x| x * x}.inject(:+)\n\
    end", "  lst.map{|n| n.ceil ** 2}.sum\nend", "  lst.map { |n| n.ceil**2 }.sum\n\
    end", "  lst.map { |n| (n + 0.5).ceil**2 }.reduce(:+)\nend", "  lst.map! { |number|\
    \ number.ceil }\n  lst.map! { |number| number * number }\n  lst.reduce(:+)\nend",
  "  lst.map { |num| num.ceil ** 2 }.reduce(:+)\nend", "  lst.map { |x| x.ceil**2\
    \ }.reduce(:+)\nend", "  lst.map { |v| v.ceil }.map { |v| v ** 2 }.reduce(:+)\n\
    end", "  lst.map{|n| n.ceil ** 2}.reduce(:+)\nend", "  sum = 0\n  lst.each do\
    \ |n|\n    sum += (n.ceil)**2\n  end\n  sum\nend", "  lst.map { |x| x.ceil**2\
    \ }.reduce(:+)\nend", "  total = 0\n  lst.each { |num| total += num.ceil**2 }\n\
    \  total\nend", "  s = 0\n  lst.each { |n| s += n.ceil ** 2 }\n  s\nend", "  lst.map\
    \ { |num| num ** 2 }.sum\nend", "  lst.map!{|x| x.ceil}\n  lst.map!{|x| x**2}\n\
    \  sum = 0\n  lst.each {|x| sum += x}\n  return sum\nend", "  new_lst = lst.map\
    \ { |x| x.ceil }\n  final_lst = new_lst.map { |x| x ** 2 }\n  final_lst.sum\n\
    end", "  lst.map{|element| element = element.ceil}.reduce(0){|total, element|\
    \ total + element**2}\nend", "  lst.inject(0) { |sum, i| sum + i.ceil**2 }\nend",
  "  lst.map!{|x| x.ceil}.map{|x| x*x}.reduce(:+)\nend", "  lst.map{|n| n.ceil **\
    \ 2}.sum\nend", "  lst.map { |e| (e - e.round + e.ceil)**2 }.reduce(:+)\nend",
  "    lst.map{|x| x.ceil**2}.reduce(:+)\nend", "  lst.map { |x| x.ceil }.map { |x|\
    \ x * x }.reduce(:+)\nend", end, "  lst.map { |x| x.ceil ** 2 }.sum\nend", " \
    \ lst.map { |e| (e + 0.5).to_i }.map { |e| e**2 }.reduce(:+)\nend", "  lst.map!\
    \ { |number| number.ceil }\n  sum = 0\n  lst.each { |number| sum += number**2\
    \ }\n  sum\nend", "\t#lst = [1.0, 2.0, 3.0]\n\t#lst = lst.map {|e| e.ceil }\n\t\
    #num = lst.collect {|e| e*e }\n\t#num = num.inject {|sum, e| sum + e }\n\t#print\
    \ num\n\t#num = 0\n\t#lst.each {|x| num += x**2}\n\t#return num\n\tlst.collect\
    \ {|e| e.ceil }.inject {|sum, e| sum + e**2 }\nend", "\tlst.map! {|x| x.ceil}\n\
    \tlst.map! {|x| x*x}\n\tsum = 0\n\tlst.each {|x| sum += x}\n\tsum\nend", "  (lst.map\
    \ { |n| n.ceil ** 2 }).reduce(:+)\nend", "  lst.map { |x| x.ceil }.map { |x| x**2\
    \ }.sum\nend", "  lst.map{|x| x.ceil**2}.reduce(:+)\nend", "  lst.map{|el| el.ceil\
    \ ** 2}.reduce(:+)\nend", "  sum = 0\n  lst.each { |x| sum += (x.ceil ** 2) }\n\
    \  sum\nend", "  lst.map!{|i| i.ceil}\n  lst.map!{|i| i**2}\n  return lst.reduce(:+)\n\
    end", "  squares = []\n  lst.each do |n|\n    n = n.ceil()\n    squares << n **\
    \ 2\n  end\n  p squares.reduce(:+)\nend", "  n = []\n  lst.each do |x|\n    x\
    \ = x.ceil\n    n << x**2\n  end\n  return n.inject(:+)\nend", "\t#your code here\n\
    \tresult = 0\n\tlst.each do |number|\n\t\tresult += number.ceil**2\n\tend\n\t\
    result\nend", "  lst.map!{|e| e.ceil}\n  lst.map!{|e| e**2}\n  lst.inject(:+)\n\
    end", "  result = 0\n  lst.each { |num| result += num.ceil**2 }\n  result\nend",
  "  sum = 0\n  lst.each do |num|\n    sum += num.ceil**2\n  end\n  sum\nend", " \
    \ lst.map{|x| x.ceil ** 2}.sum\nend", "  lst.each_with_index { |v, i| lst[i] =\
    \ v.ceil }\n  lst.inject(0) { |sum, v| sum + v**2 }\nend", "  lst.map! { |x| x.ceil\
    \ }\n  lst.map! { |x| x * x }\n  lst.reduce(:+)\nend", "  sum = 0\n  lst.each\
    \ { |e| sum += e.ceil ** 2 }\n  sum\nend", "  puts lst.map{|num| num.ceil**2}.inject(:+)\n\
    end", "  lst.map { |a| a.ceil**2 }.reduce(:+)\nend", "  lst.map{|i| i.ceil**2}.inject(:+)\n\
    end", "  squared_lst = lst.map { |i| i ** 2 }\n  squared_lst.inject(:+)\nend",
  "  sum = 0\n  lst.each do |x|\n    sum += x.ceil ** 2\n  end\n  sum\nend", "  lst.map!{|e|\
    \ e = e.ceil}\n  lst.map!{|e| e = e**2}\n  lst.inject{|sum, e| sum + e}\nend",
  "  return lst.map { |a| a.ceil**2 }.sum\nend", "  # TODO: Your code here\nend",
  "  lst.map!{|x| x.ceil }\n  lst.map!{|x| x**2 }\n  sum = 0\n  lst.each{|x| sum +=\
    \ x}\n  return sum\nend\nputs sum_squares([1.0, 2.0, 3.0])\nputs sum_squares([1.0,\
    \ 4.0, 9.0])\nputs sum_squares([1.0, 3.0, 5.0, 7.0])\nputs sum_squares([1.4, 4.2,\
    \ 0.0])\nputs sum_squares([-2.4, 1.0, 1.0])", "  lst.map{|x| x.ceil ** 2}.reduce(:+)\n\
    end", "  lst.map! { |e| e.ceil}\n  total = 0\n  lst.each { |num| total += num\
    \ ** 2 }\n  return total\nend", "  lst.map!{|x| x.ceil}.map!{|x| x**2}.reduce(:+)\n\
    end", "  lst.map{|x|x.ceil**2}.reduce(:+)\nend", "  (lst.map { |x| x.ceil }).map\
    \ { |x| x**2 }.reduce(:+)\nend", "  lst.map{|x| x.ceil ** 2}.reduce(:+)\nend",
  "  # Code here\nend", "  new_lst = lst.map { |item| item.ceil }\n  new_lst.map {\
    \ |item| item ** 2 }.reduce(:+)\nend", "  # your code here\nend", "  # lst.map\
    \ { |x| x.ceil }.map { |x| x * x }.reduce(:+)\n  # lst.map { |x| x.ceil ** 2 }.reduce(:+)\n\
    \  # lst.map { |x| x.ceil ** 2 }.sum\n  lst.map { |x| x.ceil ** 2 }.inject(:+)\n\
    end", "  lst.map! { |num| num.ceil }\n  lst.map! { |num| num * num }\n  lst.inject(:+)\n\
    end", "  lst.map! { |x| x.ceil }\n  lst.map! { |x| x ** 2 }\n  sum = 0\n  lst.each\
    \ { |x| sum += x }\n  sum\nend", "\tsum = 0\n\tfor i in lst\n\t\tsum += i ** 2\n\
    \tend\n\tsum\nend", "  lst.map{|e|e.ceil**2}.reduce(:+)\nend", "  ceiled_lst =\
    \ lst.map { |x| x.ceil }\n  ceiled_lst.map { |x| x**2 }.sum\nend", "  lst.map\
    \ { |x| x.ceil**2 }.sum\nend", "  lst.map { |n| n.ceil ** 2 }.reduce(:+)\nend",
  "  sum = 0\n  for i in 0..lst.length-1\n    if lst[i] < 0\n      sum += (lst[i].ceil**2)\n\
    \    else\n      sum += (lst[i].floor**2)\n    end\n  end\n  return sum\nend",
  "  lst.map! { |num| num.ceil }\n  lst.inject(0) { |sum, i| sum + i * i }\nend",
  "  lst.map { |x| x.ceil ** 2 }.sum\nend", "  lst.map { |num| num = num.ceil }.inject(0)\
    \ { |result, num| result + num**2 }\nend", "  lst.map{|e| e.ceil ** 2}.sum\nend",
  "  lst.map! { |x| x.ceil }\n  lst.map! { |x| x ** 2 }\n  lst.inject(:+)\nend", " \
    \ lst.map!{|i| i.ceil}\n  lst.map!{|i| i*i}\n  lst.inject(:+)\nend", "  lst.map!{|x|\
    \ x.ceil}.inject(0){|sum,x| sum + x**2}\nend", "  sum = 0\n  lst.each { |x| sum\
    \ += Math.sqrt(x).ceil ** 2 }\n  sum\nend", "  lst.map{|a| a.ceil ** 2}.reduce(:+)\n\
    end", "  # Your code here\nend", "  lst.map!{|x| x.ceil}.map{|x| x**2}.reduce(:+)\n\
    end\nputs sum_squares([1.0, 2.0, 3.0])\nputs sum_squares([1.0, 4.0, 9.0])\nputs\
    \ sum_squares([1.0, 3.0, 5.0, 7.0])\nputs sum_squares([1.4, 4.2, 0.0])\nputs sum_squares([-2.4,\
    \ 1.0, 1.0])", "  # your code here\nend", "  lst.map! { |i| i.ceil }\n  sum =\
    \ 0\n  lst.each { |i| sum += i * i }\n  sum\nend", "    lst = lst.map{|e| e.ceil}\n\
    \    return lst.inject(0){|sum, elem| sum + elem**2}\nend", "  lst.map{|x| x.ceil**2}.reduce(:+)\n\
    end", "  lst.map!{|i| i.ceil}\n  puts lst.map{|i| i**2}.reduce(:+)\nend", "  lst.map\
    \ { |x| x = x.ceil ** 2 }.sum\nend", "    if lst.length > 0\n        return lst.map\
    \ { |e| e = e.ceil }.map { |x| x * x }.reduce(:+)\n    else\n        return nil\n\
    \    end\nend", "  lst.map { |e| e.ceil**2 }.sum\nend", "  sum = 0\n  array =\
    \ lst.map { |x| x.ceil }\n  array.each { |x| sum += x ** 2 }\n  sum\nend", " \
    \ # Write your code here\nend", "  lst.map!{|x| x.ceil}\n  sum = 0\n  lst.each\
    \ do |x|\n    sum = sum + x ** 2\n  end\n  sum\nend", "  lst.map { |item| item.ceil\
    \ ** 2 }.reduce(:+)\nend", "  return 0 if lst.empty?\n  lst.map { |n| (n.ceil)**2\
    \ }.reduce(:+)\nend", "  lst.map { |e| e.ceil }.map { |e| e ** 2 }.sum\nend",
  "  lst.map! { |x| x.ceil ** 2 }\n  lst.reduce(:+)\nend", "  # Create a new empty\
    \ array\n  # Create a counter that checks if the array has finished\n  # Create\
    \ a loop to go through the elements in the array\n  # Take each element and remove\
    \ the dot, turn it into an integer, and add it to the new array\n  # While the\
    \ counter is less than the array's length\n  # Add the counter to the index of\
    \ the new array, which is already squared\n  # Increment the counter\n  # Return\
    \ the sum of the squared numbers", "  lst.map!{|x| x.ceil}.map{|x| x**2}.reduce(:+)\n\
    end", "  lst.map { |number| (number + 0.5).floor ** 2 }.reduce(:+)\nend", "  \
    \  nums = lst.map{|x| x.ceil}\n    nums.map{|x| x ** 2}.sum\nend", "  square =\
    \ lst.map { |x| Math.sqrt(x).ceil ** 2 }\n  square.inject(:+)\nend", "  lst.map\
    \ { |i| i.ceil ** 2 }.sum\nend", "  lst.map{|x| x.ceil**2}.reduce(:+)\nend", '  sum_square
    = 0', "  lst.map{|l| l.ceil**2}.sum\nend", "  sum = 0\n  lst.each do |x|\n   \
    \ sum += x.ceil ** 2\n  end\n  sum\nend", "  # TODO: Implement this method\n \
    \ lst.map{|l| l.ceil**2}.reduce(:+)\nend", "  lst.map{|x|x.ceil}.inject(0){|sum,x|\
    \ sum + x**2}\nend", "  result = 0\n  lst.each do |a|\n    result += (a.ceil)**2\n\
    \  end\n  result\nend", "  lst.map{|i| i = i.ceil}\n     .reduce(0){|i, j| i +\
    \ j**2}\nend", "  lst.map { |e| e.ceil }.inject(0) { |acc, e| acc + e**2 }\nend",
  "  lst.map { |x| x.ceil ** 2 }.sum\nend", "  lst.map{|x| x.ceil ** 2}.sum\nend",
  "  # You can solve it here\n  lst.map!{|x| x.ceil}\n  lst.map!{|x| x**2}\n  lst.inject(:+)\n\
    end", "  lst.map { |e| e.ceil**2 }.reduce(:+)\nend", "  lst.map!(&:ceil).map!{|i|\
    \ i ** 2}.reduce(:+)\nend", "  lst.map { |x| x.ceil ** 2 }.reduce(:+)\nend", " \
    \   return lst.map { |e| e.ceil**2 }.sum\nend", "  lst.map { |e| e.ceil ** 2 }.sum\n\
    end", "  # lst.map{|x| x.ceil ** 2}.reduce(:+)\n  #or\n  lst.map{|x| x.ceil **\
    \ 2}.sum\nend", "  lst.map! { |x| x.ceil }\n  lst.map! { |x| x ** 2 }\n  lst.inject(:+)\n\
    end", "    lst.map { |number| number.ceil**2 }.reduce(:+)\nend", "  lst.map {\
    \ |x| x.ceil }.map { |x| x * x }.sum\nend", "  lst.map!{|x| x.ceil}\n  lst.map!{|x|\
    \ x*x}\n  lst.reduce(:+)\nend", "  lst.map! { |x| x.ceil }\n  lst.reduce(0) {\
    \ |sum, n| sum + n * n }\nend", "\tresult = lst.map{|n| n.ceil}.map{|n| n*n}.inject(:+)\n\
    \tresult\nend", "  lst.map! { |x| x.ceil }\n  lst.map! { |x| x ** 2 }\n  sum =\
    \ 0\n  lst.each { |x| sum += x }\n  return sum\nend", "  # your code here\nend",
  "  lst.map { |x| x.ceil**2 }.sum\nend", "  r = 0\n  lst.each do |e|\n    e = e.ceil\n\
    \    r += e * e\n  end\n  r\nend", "  sum = 0\n  lst.each do |x|\n    sum += (x.ceil)**2\n\
    \  end\n  sum\nend", "  lst.map { |i| i.ceil }.map { |i| i ** 2 }.reduce(:+)\n\
    end", "  result = 0\n  lst.each do |i|\n    i = i.ceil.to_i\n    i = i ** 2\n\
    \    result += i\n  end\n  result\nend", "  lst.map { |i| i.ceil }.map { |i| i**2\
    \ }.sum\nend", "  lst.map { |num| num.ceil ** 2 }.reduce(:+)\nend", "  lst.map{|i|\
    \ i.ceil ** 2}.reduce(:+)\nend", "  sum = 0\n  lst.each do |i|\n    sum += i **\
    \ 2\n  end\n  sum\nend", "  lst.map!(&:ceil).reduce(0) { |sum, x| sum + x**2 }\n\
    end", "  lst.map { |e| e.ceil**2 }.sum\nend", "  lst.map { |x| x.ceil**2 }.sum\n\
    end", "  if lst.empty?\n    raise ArgumentError, \"Function must be called with\
    \ at least one argument\"\n  end\n  lst.reduce(0) { |sum, el| sum + el**2 }\n\
    end", "  lst.map { |x| x.ceil }.map { |x| x ** 2 }.reduce(:+)\nend", "  lst.map{|x|\
    \ x.ceil ** 2}.sum\nend", "  lst.map! { |num| num.ceil }\n  lst.inject(0) { |sum,\
    \ num| sum + num ** 2 }\nend", "  squared_numbers = lst.map { |x| x.ceil ** 2\
    \ }\n  squared_numbers.inject(:+)\nend", "  lst.map{|e| e.ceil}.map{|e| e*e}.sum\n\
    end", "  lst.map! { |num| num.ceil }\n  lst.map! { |num| num ** 2 }\n  lst.reduce(:+)\n\
    end", "  lst.map { |e| e.ceil**2 }.sum\nend", "  lst.map { |e| e.ceil ** 2 }.sum\n\
    end", "  lst.map{|n| n.ceil}.inject(0){|sum, i| sum + i*i}\nend", "  lst.map {\
    \ |i| i.ceil**2 }.sum\nend", "  lst.map { |n| n.ceil }.reduce(0) { |a, e| a +\
    \ e**2 }\nend", "  lst.map { |e| e.ceil ** 2 }.sum\nend", "  lst.inject(0) { |sum,\
    \ i| sum + i.ceil**2 }\nend", "  lst.map { |e| e.ceil ** 2 }.reduce(:+)\nend",
  "  lst.map! { |i| i.ceil }\n  lst.map! { |i| i**2 }\n  lst.reduce(:+)\nend", " \
    \ lst.map! { |x| x.ceil }\n  lst.map! { |x| x ** 2 }\n  lst.inject(:+)\nend",
  "  lst.map { |e| e = (e + 0.999999).to_i }.map { |e| e = e**2 }.sum\nend", "   \
    \ lst.map { |e| e.ceil ** 2 }.reduce(:+)\nend", "  lst.map{|x| x.ceil**2}.reduce(:+)\n\
    end", "  lst.map{|x| x.ceil}.map{|x| x**2}.inject(:+)\nend", "  return 0 if lst.nil?\
    \ || lst.size == 0\n  lst.map { |value| value.ceil ** 2 }.inject(:+)\nend", " \
    \ lst.map{|x| x.ceil}.inject(0){|sum, x| sum + x*x}\nend", "  lst.map!{|x| x.ceil}.map!{|x|\
    \ x**2}.inject(:+)\nend", "  lst.map!(&:ceil).map { |el| el**2 }.reduce(:+)\n\
    end", "  lst.map { |i| i.ceil ** 2 }.reduce(:+)\nend", "  lst.map{|num| (num.ceil)**2}.reduce(:+)\n\
    end", "  # initialize a new array\n  # iterate over the list\n  # math each array\
    \ value to the ceil\n  # square each value\n  # reduce array and sum it up\n \
    \ lst.map { |num| num.ceil ** 2 }.reduce(:+)\nend", "\tlst.map{|x| x.ceil**2}.inject(:+)\n\
    end", "  sum = 0\n  lst.each do |x|\n    sum += x.ceil ** 2\n  end\n  sum\nend",
  "  lst.map { |x| x.ceil ** 2 }.sum\nend", "  lst.map { |el| el.ceil }.map { |el|\
    \ el**2 }.reduce(:+)\nend", "  lst.map { |num| num.ceil ** 2 }.sum\nend", "  lst.map\
    \ { |x| x.ceil ** 2 }.sum\nend", "  lst.map { |x| x.ceil**2 }.sum\nend", "  lst.map!{|num|\
    \ num.ceil}\n  lst.reduce(0){|sum, num| sum + num ** 2}\nend", "  # TODO: Implement\
    \ the method\n  return lst.collect{|x| x.ceil}.inject(0){|sum,x| sum + x*x}\n\
    end", "  lst.map { |e| e = e.ceil**2 }.reduce(:+)\nend", "  lst.map { |x| x =\
    \ x.ceil**2 }.reduce(:+)\nend", "  lst.map{|item| item.ceil ** 2}.sum\nend", " \
    \ return 0 if lst.empty?\n  lst.map { |x| x.ceil }.map { |x| x**2 }.inject(:+)\n\
    end", "  lst.map{|x| x.ceil**2}.reduce(:+)\nend", "  #  your code here\nend",
  "  lst.map{|e| e.ceil ** 2}.reduce(:+)\nend", "  lst.map! { |x| x.ceil }\n  lst.map!\
    \ { |x| x * x }\n  lst.reduce(:+)\nend", "  lst.map { |n| n.ceil }.map { |n| n**2\
    \ }.sum\nend", "  return 0 if lst.nil?\n  lst.map{|e| e = e.ceil}.inject(0){|sum,\
    \ i| sum += i ** 2}\nend", "  lst.map{|n| n.ceil**2}.sum\nend", "\nend", "  return\
    \ 0 if lst.empty?\n  lst.map { |x| x.ceil**2 }.inject(:+)\nend", "    lst.map{|e|\
    \ e.ceil**2}.sum\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
