name: HumanEval_83_starts_one_ends
language: rb
prompt: "# Given a positive integer n, return the count of the numbers of n-digit\n\
  # positive integers that start or end with 1.\ndef starts_one_ends(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n\
  \    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n\
  \    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n\
  \    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n\
  \  end\nend\n"
completions: ["  return 1 if n == 1\n  return 10 if n == 2\n  return 9 * 10 ** (n\
    \ - 2) + (starts_one_ends(n - 1) - starts_one_ends(n - 2))\nend", "  if n == 1\n\
    \    return 2\n  else\n    return (10 ** (n - 1)) + starts_one_ends(n - 1)\n \
    \ end\nend", "  if n <= 1\n    return 0\n  end\n  count = 0\n  (1..n).each do\
    \ |m|\n    if m == 1\n      count += 1\n    else\n      count += 9 * (10 ** (m\
    \ - 2))\n    end\n  end\n  count\nend", "\treturn 0 if n == 0\n\treturn 1 if n\
    \ == 1\n\treturn 10 * (starts_one_ends(n-1) + starts_one_ends(n-2))\nend", " \
    \ return n if n == 1\n  10 ** (n - 1) + 9 * 10 ** (n - 2) + starts_one_ends(n\
    \ - 1)\nend", "\tn == 1 ? 2 : (10 ** (n - 1)) + (10 ** (n - 2))\nend", "  res\
    \ = 10 ** (n - 1)\n  res + 9 * (10 ** (n - 2))\nend", "\t(n <= 1) ? 1 : (10**(n-1))\
    \ + starts_one_ends(n-1)\nend", "  return 1 if n <= 1\n  return 10 if n == 2\n\
    \  return 10 + 9*(n-2)\nend", "  return 0 if n < 1\n  return 1 if n == 1\n  return\
    \ 1 if n == 2\n  return 2 if n == 3\n  return 3 if n == 4\n  return 5 if n ==\
    \ 5\n  starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend", "  return 1 if n\
    \ == 1\n  return 10 if n == 2\n  return (10 ** (n - 1)) + 9 if n == 3\n  (10 **\
    \ (n - 1)) + 9 * (n - 1)\nend", "    return 0 if n <= 0\n    return starts_one_ends(n\
    \ - 1) + pow10(n - 1)\nend", "  # Your code here\nend", "  (1..n).sum { |digits|\
    \ 9 * 9**(digits - 2) }\nend", "  (10**(n-1)) + (10**(n-1))*9 - (10**(n-2))\n\
    end", "  return 1 if n == 1\n  return 10 if n == 2\n  return starts_one_ends(n\
    \ - 1) + (10 ** (n - 2))\nend", "  nums = []\n  (1..9).each do |i|\n    nums +=\
    \ (1..9).map { |j| i*10**(n-1) + j }\n  end\n  nums.length\nend", "  if n == 1\n\
    \    return 2\n  end\n  return 10 ** (n - 1) + starts_one_ends(n - 1)\nend", " \
    \ count = 0\n  for i in 1..n do\n    count += 10**(i-1)\n  end\n  count * 2\n\
    end", "  if n == 1\n    return 2\n  end\n  # res = 0\n  # n.times do |i|\n  #\
    \   (1..(10 ** i - 1)).each do |v|\n  #     if v.to_s.end_with?(\"1\")\n  #  \
    \     res += 1\n  #     end\n  #   end\n  # end\n  # res\n  # \u662F\u4E0D\u662F\
    \u53EF\u4EE5\u548C\u4E0A\u4E00\u9898\u7684\u7ED3\u679C\u6C42\u548C\uFF1F\n  return\
    \ starts_one_ends(n - 1) + count_one(n)\nend", "  dp = Array.new(n+1)\n  dp[0]\
    \ = 1\n  dp[1] = 1\n  for i in 2..n\n    dp[i] = dp[i-1] + dp[i-2]\n  end\n  return\
    \ dp[n]\nend", "  case n\n  when 1\n    return 2\n  when 2\n    return 3\n  else\n\
    \    return starts_one_ends(n - 1) + starts_one_ends(n - 2)\n  end\nend", "  arr\
    \ = [1, 1]\n  n.times do\n    arr = [arr[1], arr[0] + arr[1]]\n  end\n  arr.reduce(:+)\n\
    end", "  # Exponent for 10^n\n  pow = 10 ** n\n  # The count for the start and\
    \ end of 1 is 1.\n  count = 1\n  (1..n - 1).each do |i|\n    count += 9 * 9 **\
    \ (i - 1)\n  end\n  count\nend", "  (n-1)**2\nend", "  return 1 if n == 1\n  #\
    \ Otherwise, this function is equivalent to the number of 9-digit numbers\n  #\
    \ (which is 9*10^8) plus the number of numbers ending in 1 that are not\n  # 9-digit\
    \ numbers.\n  # The latter is equal to the number of numbers of n-1 digits that\
    \ start with\n  # one minus the number of numbers of n-1 digits that start with\
    \ 1 and end\n  # with 1.\n  # Finally, the latter is equal to the number of n-1\
    \ digit numbers minus the\n  # number of n-2 digit numbers.\n  9*10**(n-1) + starts_one_ends(n-1)\
    \ - starts_one_ends(n-2)\nend", "  # return the count for a number of n digits\
    \ that starts with 1\n  def starts_one(n)\n    return 0 if n < 2\n    return 9\
    \ if n == 2\n    (1 + (1..n-2).inject(9) { |prod, k| prod * (9 - k + 2) }).to_i\n\
    \  end", end, "  n < 2 ? n : (n * 10) - 9\nend", "  return 0 if n == 0\n  return\
    \ 10 if n == 1\n  return 81 if n == 2\n  count = 0\n  (1..n).each do |i|\n   \
    \ count += 9 * 10**(i-1)\n  end\n  count\nend", "  return (n - 1) * 10**(n - 2)\n\
    end", "  if n == 1\n    return 2\n  end\n  nums = ['1']\n  (n - 1).times do\n\
    \    nums = ['1'] + nums.map { |num| '0' + num } + nums.map { |num| '1' + num\
    \ }\n  end\n  nums.select { |num| num[0] == '1' || num[-1] == '1' }.count\nend",
  "  # your code here\nend", "    n == 1 ? 2 : n == 2 ? 3 : 2 ** (n - 1)\nend", end,
  "  (n > 1 ? 10 : 1) * 9**(n - 1)\nend", "  return 0 if n == 0\n  return 1 if n ==\
    \ 1\n  return 10 ** (n - 1) + 1 if n == 2\n  ones = 10 ** (n - 1) + starts_one_ends(n\
    \ - 1)\n  ends = (n - 2) * 10 ** (n - 2)\n  ones + ends\nend", "  count = 0\n\
    \  i = 10**(n-1)\n  10**n.times do\n    if i % 10 == 1\n      count += 1\n   \
    \ end\n    i += 1\n  end\n  count\nend", "  raise ArgumentError, \"n must be positive\"\
    \ if n < 1\n  if n == 1\n    return 2\n  end\n  tens = 1\n  ((n - 1) / 2).times\
    \ {tens *= 10}\n  (n - 1) % 2 == 0 ? tens + tens / 10 : tens + tens / 10 + tens\n\
    end", "  #count = 0\n  #(10**(n-1))..(10**n-1) do |num|\n  #  count += 1 if num.to_s[0]\
    \ == \"1\" || num.to_s[-1] == \"1\"\n  #end\n  #count\n  # Could also do this\
    \ all in one line with Regex, but that's less readable\n  #(10**(n-1))..(10**n-1).count\
    \ { |num| num.to_s =~ /^1|1$/ }\nend", "  return 0 if n == 0\n  first = starts_one_ends(n\
    \ - 1)\n  last = starts_one_ends(n - 2)\n  first + (last * 9) + 10\nend", "  return\
    \ 0 if n == 0\n  return 1 if n == 1\n  return 10 if n == 2\n  return 10 * (n -\
    \ 1) + 1\nend", '  return 10 if n == 1', '  return 10 if n == 1', "  arr = []\n\
    \  count = 0\n  # Generate an array of all the numbers\n  (1..10**n-1).each do\
    \ |num|\n    arr << num\n  end\n  # Iterate through the array and count the nums\
    \ that start and end with 1\n  arr.each do |i|\n    if i.to_s[0] == \"1\" || i.to_s[-1]\
    \ == \"1\"\n      count += 1\n    end\n  end\n  count\nend", "  arr = []\n  (1..n).each\
    \ do |i|\n    arr << (1...n).to_a.map { |j| (1 * 10**j) + (1 * 10**(i - j - 1))\
    \ }\n  end\n  arr.flatten.length\nend", "  n == 1 ? 2 : 10 ** (n - 1) + 10 **\
    \ (n - 2)\nend", "  if n == 1\n    return 2\n  end\n  power = (10 ** (n - 1))\n\
    \  power + 9 * 10 ** (n - 2)\nend", "  return (n-1)*10**(n-2) if n == 1\n  (n-1)*10**(n-2)\
    \ + starts_one_ends(n-1)\nend", "  (10**(n-1)) + 1 + 9*(10**(n-1) - 1)\nend",
  "  (1..n).reduce(0) { |a, i| a + (i-1)*(10**(i-1) - 10**(i-2)) }\nend", "  return\
    \ 0 if n < 1\n  return 9 if n == 1\n  return 9 + 9 * 10**(n - 2)\nend", "  # We\
    \ have n digits. We choose one to be the one that starts with 1 and\n  # another\
    \ to be the one that ends with 1. All the other digits are 0-9.\n  ((n - 1) *\
    \ 9) * ((n - 1) * 9)\nend", "  # A recursion\n  if n == 1\n    2\n  else\n   \
    \ (9 ** (n - 1)) * 2\n  end\nend", "  digits = {1 => true, 0 => false}\n  return\
    \ 0 if n == 1", "  return 0 if n < 1\n  dp = Array.new(n) { Array.new(2, 0) }\n\
    \  (0..9).each do |i|\n    dp[0][i == 1 ? 1 : 0] += 1\n  end\n  (1...n).each do\
    \ |i|\n    (0..9).each do |j|\n      dp[i][1] += dp[i - 1][1] if j == 1\n    \
    \  dp[i][0] += dp[i - 1][0] + dp[i - 1][1]\n    end\n  end\n  dp[n - 1][0] + dp[n\
    \ - 1][1]\nend", "    count = 0\n    while n > 0\n        count += 9 * 10 ** (n\
    \ - 1)\n        n -= 1\n    end\n    count\nend", "  return 0 if n < 1\n  return\
    \ 10 if n == 1\n  # This can be solved recursively by thinking about the number\
    \ of ways to\n  # append 1 to n-1 digit numbers, and the number of ways to prepend\
    \ 1 to n-1\n  # digit numbers\n  recurse(n, true) + recurse(n, false)\nend", " \
    \ raise 'Input must be a positive integer' unless n.is_a?(Integer) && n.positive?",
  "  arr = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n  (n - 1).times do\n    arr = [0, sum(arr),\
    \ sum(arr), sum(arr), sum(arr), sum(arr), sum(arr), sum(arr), sum(arr), sum(arr)]\n\
    \  end\n  sum(arr)\nend", "  if n == 1\n    2\n  else\n    9 + 8 * 9 ** (n - 2)\n\
    \  end\nend", "  return 1 if n == 1\n  count = 1\n  num = 10**(n-1)\n  count +=\
    \ num * (n-1)\n  count += num\n  count\nend", "  count = 0\n  n.times do |i|\n\
    \    count += count_numbers(i)\n  end\n  count\nend", "  start_ones = 10**(n-1)\n\
    \  end_ones = 10**(n-1)\n  total = start_ones + end_ones\n  total - 9\nend", " \
    \ return 1 if n == 1\n  return 2 if n == 2\n  # 2 for the 10 and 1, and 10 for\
    \ each between 10 and 99\n  2 + 10 * (n - 2)\nend", " \n \n def number_of_ones(num)\n\
    \  count = 0\n  i = 1\n  while i <= num do\n    count += 1 if num[i] == 1\n  \
    \  i += 1\n  end\n  count\nend", "  return 10 if n == 1\n  return 9 if n == 2\n\
    \  return 9 * 10 ** (n - 2)\nend", end, "  (1..(10**n)).count { |i| i.to_s =~\
    \ /^1|1$/ }\nend", "  return 0 if n == 0\n  if n == 1\n    return 2\n  end\n \
    \ if n == 2\n    return 3\n  end\n  n_minus1 = starts_one_ends(n-1)\n  n_minus2\
    \ = starts_one_ends(n-2)\n  return 10*n_minus1 + n_minus2\nend", "  ones = 1\n\
    \  (1..n).each do |n|\n    ones = ones * 9\n  end\n  ones * 10\nend", "  n1 =\
    \ 0\n  n2 = 0\n  n3 = 0\n  n4 = 0\n  if n == 1\n    return 1\n  elsif n == 2\n\
    \    return 11\n  elsif n == 3\n    return 111\n  elsif n == 4\n    return 1111\n\
    \  else\n    n1 = starts_one_ends(n-1)\n    n2 = starts_one_ends(n-2)\n    n3\
    \ = starts_one_ends(n-3)\n    n4 = starts_one_ends(n-4)\n  end\n  (n1*10)+(n2*9)+(n3*9)+(n4*8)\n\
    end", "  return 1 if n == 1\n  (10**(n-1)) + (9 * (10**(n-2)))\nend", "  return\
    \ 0 if n == 0\n  return 1 if n == 1\n  (count_starts_one(n-1) + count_ends_one(n-1))\n\
    end", end, "  return 10 if n == 1\n  return 19 if n == 2\n  base = 9\n  (n - 3).times\
    \ { |_| base *= 9 }\n  (10 + base * 2).to_s.length\nend", "  return 0 if n ==\
    \ 0\n  return 1 if n == 1\n  return starts_one_ends(n - 1) + 10 ** (n - 1)\nend",
  "  return 1 if n == 1\n  return 10 if n == 2\n  return starts_one_ends(n - 1) +\
    \ 10 * (1..(n - 2)).inject(:*) + starts_one_ends(n - 2)\nend", "  return 0 if\
    \ n == 0\n  # edges cases\n  return 10 if n == 1\n  return 55 if n == 2\n  # number\
    \ of numbers that start with one\n  # if n = 4, its the same as number of numbers\
    \ with three digits,\n  # which is the number of numbers with two digits * 10\n\
    \  # if n = 5, its the same as number of numbers with four digits,\n  # which\
    \ is the number of numbers with three digits * 10\n  return starts_one_ends(n\
    \ - 1) * 10\nend", end, "  return 0 if n == 0\n  return 1 if n == 1\n  return\
    \ 10 if n == 2\n  return 10 + 9 * 9 * 8 ** (n - 3) + 9 * 9 * 8 ** (n - 3)\nend",
  "  count = 0\n  (1..9).each do |start|\n    count += find_numbers(n - 1, true, start)\n\
    \  end\n  (1..9).each do |end_|\n    count += find_numbers(n - 1, false, end_)\n\
    \  end\n  count\nend", "  return 0 if n == 0\n  return 1 if n == 1\n  # Explanation:\n\
    \  # - The last digit must be 1.\n  # - There are 10 choices for the first digit,\
    \ regardless of what the\n  #   remaining n-2 digits are.\n  # - There are 9 choices\
    \ for each of the remaining n-2 digits. This is\n  #   because we don't want any\
    \ leading zeros.\n  # - We have to account for duplicates, i.e. if we've already\
    \ counted\n  #   the number 1324, then we don't want to count 4132 as well. This\
    \ is\n  #   where the multiplication by 2 comes from.\n  # - We then have to subtract\
    \ one from the result, because we've counted\n  #   our initial \"1\" n times\
    \ instead of n-1 times.\n  return 10 * 9 ** (n - 2) * 2 - 1\nend", "  return 0\
    \ if n < 1\n  return 9 if n == 1\n  if n == 2\n    return 18\n  end\n  starts_one_ends(n-1)\
    \ + 9*10**(n-2)\nend", "  a = 1\n  b = 1\n  for i in 0..n-2\n    a += 9 * 10**i\n\
    \    b += (10 - i - 1) * 10**i\n  end\n  b + a\nend", "  (1..n).inject(0) { |sum,\
    \ i| sum + 9 * 10**(i - 1) }\nend", "  return 0 if n <= 0\n  return 9 if n ==\
    \ 1\n  return 10 * starts_one_ends(n - 1) - 9 * starts_one_ends(n - 2)\nend",
  "  if n == 1\n    return 2\n  else\n    return 10**(n-1) + 9*10**(n-2)\n  end\n\
    end", "  count = 0\n  (1..n).each do |i|\n    count += 9 * (10 ** (i - 1))\n \
    \ end\n  count\nend", "  return -1 if n < 1\n  return 9 if n == 1\n  return 9*10**(n-2)\n\
    end", "  count_ones(n) + count_ones(n - 1)\nend", "  i = 3\n  sum = 0\n  while\
    \ i <= n\n    sum += 9 * 10 ** (i - 2)\n    i += 1\n  end\n  sum\nend", "\t# n\
    \ = 1\n\t# n = 2\n\t# n = 3\n\t\t# a 2 digit number starting with 1 can be 10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18, 19\n\t\t# a 2 digit number ending with 1 can\
    \ be 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\t\t# total: 20\n\t# n = 4\n\t\t# a 3 digit\
    \ number starting with 1 can be 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,\
    \ 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,\
    \ 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141,\
    \ 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157,\
    \ 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173,\
    \ 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,\
    \ 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\
    \ 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221,\
    \ 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237,\
    \ 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,\
    \ 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269,\
    \ 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285,\
    \ 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301,",
  "  (10**(n-1))..(10**n-1)\n    .to_a\n    .select { |i| i.to_s[0] == '1' || i.to_s[-1]\
    \ == '1' }\n    .count\nend", "  (n-1)*(10**(n-2))\nend", "  start_and_end_one(n)\
    \ + end_one(n)\nend", "  ones = 0\n  zeros = 0\n  (1..n-1).each do |i|\n    ones\
    \ += 10**i\n    zeros += 9*10**(i-1)\n  end\n  return ones + zeros\nend", "  #\
    \ we can count the number of n-digit integers that end in 1, since we\n  # know\
    \ that there are 10^(n-1) such integers, and then subtract this\n  # from the\
    \ total number of n-digit integers (10^n)\n  # however, we need to make sure that\
    \ we don't double-count the integers\n  # with a 1 in the first digit and a 1\
    \ in the last digit. Fortunately,\n  # this number is easy to calculate as well,\
    \ since there are 10^(n-2) such\n  # integers\n  10**n - (10**(n-1) - 10**(n-2))\n\
    end", "  return 9 if n == 1\n  count = 9\n  (n - 2).times do\n    count = count\
    \ * 9 + 1\n  end\n  count\nend\nputs starts_one_ends(4) == 7692", "  # f(n) =\
    \ f(n-1) + 10^(n-1) - 1\n  return 0 if n == 0\n  return 10 if n == 1\n  starts_one_ends(n-1)\
    \ + 10**(n-1) - 1\nend", "  # HINT:\n  # 2^(n-1) - 2^(n-2)\nend", "  if n == 1\n\
    \    return 10\n  end\n  return 10*(10**(n-1)) + starts_one_ends(n-1)\nend", " \
    \ return 1 if n == 1\n  return 10 if n == 2\n  return 91 if n == 3\n  return (n-2)*81\
    \ if n > 3\nend", "  (1..n-1).each do |start|\n    (1..n-1).each do |end|\n  \
    \    counts += start_one_end(start, end)\n    end\n  end\nend", "  # start with\
    \ 1\n  count = 1\n  # first digit is already 1\n  count += n - 1", "  return 9\
    \ if n == 1\n  count = 9\n  2.upto(n) do |i|\n    count += 9 * 10**(i-2)\n  end\n\
    \  count\nend", '  [1, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377,
    610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
    317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352,
    24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733,
    1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074,
    32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162,
    591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842,
    10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141,
    117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393,
    1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464,
    14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497,
    160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258,
    1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309,
    7540113804746346429, 12200160415121876738, 197', "  return 0 if n == 0\n  return\
    \ 1 if n == 1\n  return 10 if n == 2\n  (2..n).inject(10) { |sum, i| sum + 9 *\
    \ 10**(i - 2) }\nend", "  return 1 if n == 1\n  nums = Array.new(n + 1, 0)\n \
    \ nums[1] = 1\n  nums[2] = 2\n  nums[3] = 3\n  (4..n).each do |i|\n    nums[i]\
    \ = nums[i - 1] + nums[i - 2]\n  end\n  nums[n]\nend", "\nend", "  total = 0\n\
    \  for i in 1..n\n    total += 9 * (10 ** (i - 1))\n  end\n  total\nend", "  count\
    \ = 0\n  for i in 1..n\n    count += 10**(i-1)\n  end\n  count * 2\nend", end,
  "  #find all the numbers in the range of 0..(10**n - 1)\n  #find the ones that start\
    \ with 1\n  #find the ones that end with 1\n  #return the count of them (the length\
    \ of the array)\n  range = (0..(10**n - 1))\n  range.select { |num| num.to_s.chars.first\
    \ == \"1\" || num.to_s.chars.last == \"1\" }.count\nend", "  count = 0\n  #number\
    \ of n-digit positive integers that start or end with 1, except for\n  #the 1\
    \ at the beginning/end\n  inner_count = 10 ** (n - 1) - 1\n  #the possible 1s\
    \ at the beginning/end\n  end_count = 10 ** (n - 1)\n  #10 ** n represents the\
    \ numbers of n-digit positive integers\n  return inner_count * end_count + 10\
    \ ** n\nend", "  starting_one = 10 ** (n - 1)\n  ending_one = 10 ** (n - 2)",
  "  return n if n == 1\n  10 * (starts_one_ends(n - 1) + 10 ** (n - 2))\nend", " \
    \ return 0 if n <= 1\n  return 10 if n == 2\n  total = 10", "  # value 0..9, digit\
    \ in position 0, digit in position n\n  count = 0\n  n.times do |digit|\n    count\
    \ += count_digit(digit, digit, n)\n  end\n  count += count_digit(10, 10, n)\n\
    \  count\nend", "  return 1 if n == 1\n  (10 ** (n - 1)) + (9 * 9 ** (n - 2))\n\
    end", "  (1..n).to_a.map { |i| 2 * 10**(i - 1) }.sum\nend", "  # amount of numbers\
    \ that starts with 1 and ends with 1\n  # amount of numbers that starts with 1\
    \ and ends with any number\n  # amount of numbers that starts with any number\
    \ and ends with 1\n  # return all three added together\n  combinations = 10 **\
    \ (n - 1)\n  combinations + combinations * 9 + combinations\nend", "  return 1\
    \ if n == 1\n  return starts_one_ends(n - 1) + (n - 1) * 9\nend", "  if n > 1\n\
    \    (10 ** (n - 1)) + starts_one_ends(n - 1)\n  else\n    1\n  end\nend", " \
    \ # When n is 1, there is only one number that starts with 1 and that is 1.\n\
    \  return 1 if n == 1", "  (1..n).sum { |i| (10**(i-1)..10**i - 1).count { |j|\
    \ j.to_s.start_with?('1') } }\nend", "  base = 100**(n-1)\n  (1..9).inject(0)\
    \ { |sum, i| sum + 9*base + 1 }\nend", "  count = 0\n  (1..n).each do |digits|\n\
    \    count += 9 * 10 ** (digits - 2)\n  end\n  count\nend", end, "  return 10\
    \ if n == 1\n  sum = 0\n  (1..9).each do |i|\n    sum += starts_one_ends(n - 1)\n\
    \  end\n  sum * 2\nend", "  return 0 if n == 0\n  return 10 if n == 1\n  return\
    \ 81 if n == 2\n  return 689 if n == 3\n  return 5456 if n == 4\n  return 39281\
    \ if n == 5\n  return 270271 if n == 6\n  return 1809025 if n == 7\n  return 1152921\
    \ if n == 8\n  return 6741961 if n == 9\n  return 238728641 if n == 10\n  return\
    \ 5790343953 if n == 11\n  return -121769395521 if n == 12\n  return 2028728307551\
    \ if n == 13\n  return -30759195487673 if n == 14\n  return -461168601842739 if\
    \ n == 15\n  return 68719476735 if n == 16\n  return -1308176686799977 if n ==\
    \ 17\n  return 2248985757492765 if n == 18\n  return -351843720888339 if n ==\
    \ 19\n  return 5159780352 if n == 20\n  return -7450580596923828 if n == 21\n\
    \  return 109951162777665 if n == 22\n  return -152587890625 if n == 23\n  return\
    \ 21565153194965 if n == 24\n  return -31381059609 if n == 25\n  return 44019430407775\
    \ if n == 26\n  return -616230762793 if n == 27\n  return 85221065989875 if n\
    \ == 28\n  return -11923598678887 if n == 29\n  return 16777216 if n == 30\n \
    \ return -2384185791015625 if n == 31\n  return -3449055349907 if n == 32\n  return\
    \ -48065531052475 if n == 33\n  return 66535274879169 if n == 34\n  return -9223372036854775\
    \ if n == 35\n  return 1298157898132769 if n == 36\n  return -1812780625081133\
    \ if n == 37\n  return -253405914083875 if n == 38\n  return -351843720888339\
    \ if n == 39\n  return 4806553105", "  return 0 if n < 2\n  starts_one_ends(n\
    \ - 1) + count_digits(n) + count_digits(n - 1)\nend", "  return 0 if n <= 0\n\
    \  count = 1\n  return 9 if n == 1\n  prev = 9\n  (n - 1).times do\n    count\
    \ += prev * 9\n    prev = prev * 10 + 9\n  end\n  count\nend", "  if n == 1\n\
    \    return 1\n  end\n  (10 ** (n - 1) - 10 ** (n - 2) + starts_one_ends(n - 1))\
    \ % 1000000007\nend", "  if n == 1\n    2\n  else\n    (9 ** (n - 1)) * 2\n  end\n\
    end", "  if n == 1\n    return 2\n  else\n    return 1 + 9 * Math.log10(n-1).floor\n\
    \  end\nend", "  (\"1\" * n).to_i - (\"1\" + \"0\" * (n - 1)).to_i + 1\nend",
  "  (2**(n-1)).to_s.count('1')\nend", "  if n == 1\n    return 2\n  else\n    return\
    \ count_ones(n-1) + starts_one_ends(n-1)\n  end\nend", "  count = 0\n  # your\
    \ code here\n  return count\nend", "  return n if n == 1\n  return n ** 2 - 1\
    \ if n == 2\n  return n ** 2 - n + 2 if n == 3\n  (1..n).to_a.map { |x| 9 * 10\
    \ ** (x - 1) }.sum - (n - 3)\nend", "  if n > 1\n    (10 ** (n - 1)) + (10 **\
    \ (n - 2))\n  else\n    1\n  end\nend", "  # n=1: 10, 11\n  # n=2: 10, 11, 20,\
    \ 21, 100, 101, 110, 111\n  # n=3: 10, 11, 20, 21, 100, 101, 110, 111, 200, 201,\
    \ 210, 211, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111\n  # n=4: 10, 11, 20,\
    \ 21, 100, 101, 110, 111, 200, 201, 210, 211, 1000, 1001, 1010, 1011, 1100, 1101,\
    \ 1110, 1111, 2000, 2001, 2010, 2011, 2100, 2101, 2110, 2111, 10000, 10001, 10010,\
    \ 10011, 10100, 10101, 10110, 10111, 11000, 11001, 11010, 11011, 11100, 11101,\
    \ 11110, 11111\n  # n=5: 10, 11, 20, 21, 100, 101, 110, 111, 200, 201, 210, 211,\
    \ 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111, 2000, 2001, 2010, 2011, 2100,\
    \ 2101, 2110, 2111, 10000, 10001, 10010, 10011, 10100, 10101, 10110, 10111, 11000,\
    \ 11001, 11010, 11011, 11100, 11101, 11110, 11111, 20000, 20001, 20010, 20011,\
    \ 20100, 20101, 20110, 20111, 21000, 21001, 21010, 21011, 21100, 21101, 21110,\
    \ 21111\n  # n=6: 10, 11, 20, 21, 100, 101, 110, 111, 200, 201, 210, 211, 1000,\
    \ 1001, 1010, 1011, 1100, 1101, 1110, 1111, 2000, 2001, 2010, 2011, 2100, 2101,\
    \ 2110, 2111, 10000, 10001, 10010, 10011, 10100, 10101, 10110, 10111, 11000, 11001,\
    \ 11010, 11011, 11100, 11101, 11110, 11111, 20000, 20001, 20010, 20011, 20100,\
    \ 20101, 20110, 20111, 21", "  return 1 if n == 1\n  return 9 * 10 ** (n - 2)\
    \ + 10 * starts_one_ends(n - 1)\nend", "  return 1 if n == 1\n  Math.log10(n).floor\
    \ + 1\nend", "  return n if n < 10\n  10.upto(n) do |i|\n    return i - 1 if 10\
    \ ** (i - 1) > n\n  end\nend", "  return 0 if n == 0\n  count = 0\n  (1..n).each\
    \ do |i|\n    count += 9 * 10 ** (i - 1) + 10 ** (i - 1)\n  end\n  count\nend",
  "  (1 + 10 ** (n - 1)) * 10 ** (n - 1)\nend", "  total = 0\n  (1..9).each do |i|\n\
    \    total += 1 if i == n\n    total += 1 if i < n\n    total += starts_one_ends(n\
    \ - 1)\n  end\n  total\nend", "  return 1 if n == 1\n  return 10 if n == 2\n \
    \ return 100 if n == 3\n  return 121 if n == 4\n  n2 = n - 1\n  return starts_one_ends(n2)\
    \ + 9 * count_digit(n2)\nend", "  # TODO: implement\nend", "  if n == 1\n    return\
    \ 1\n  end\n  count = 0\n  high = 10**(n-1)\n  low = 10**(n-2)\n  #number starts\
    \ with 1\n  count += 9*(high-low) + starts_one_ends(n-1)\n  #number ends with\
    \ 1\n  count += high - low\n  return count\nend", "  nums = 0\n  ones = 1\n  while\
    \ ones <= n\n    nums += 9*10**(ones-1)\n    ones += 1\n  end\n  nums - 10**(n-1)\n\
    end", "  a = Array.new(n, 1)\n  a[0] = 2\n  count = a.inject(:*)\n  count *= (10**(n-1)\
    \ - 1)\n  count\nend", "  (n - 1) * 9 + 1\nend", "  if n == 1\n    return 2\n\
    \  end\n  n * (9**(n-1))\nend", "  if n <= 1\n    return 1\n  end\n  (10 ** (n\
    \ - 1)) + (9 * 9 ** (n - 2))\nend", "  return 0 if n < 1\n  return 9 if n == 1\n\
    \  (9 * 10 ** (n - 2) + 9 * 10 ** (n - 1))\nend", "  count = 0\n  (1..n).each\
    \ do |m|\n    count += 10**(m-1)\n  end\n  (2..n).each do |m|\n    count += 10**(m-2)\n\
    \  end\n  count\nend", "  return 1 if n == 1\n  # D[i][j] is the number of i-digit\
    \ positive integers that either start or\n  # end with j.\n  dp = Array.new(n\
    \ + 1) { Array.new(2, 0) }\n  dp[1][0] = 9\n  dp[1][1] = 1\n  (2..n).each do |i|\n\
    \    dp[i][0] = dp[i - 1][0] * 9 + dp[i - 1][1]\n    dp[i][1] = dp[i - 1][0] +\
    \ dp[i - 1][1]\n  end\n  dp[n][0] + dp[n][1]\nend", "  base = (1..n).map { |i|\
    \ i * 10 }.inject(:*)\n  base + (n-1) * base\nend", "  n > 1 ? 9*(10**(n-2)) :\
    \ 1\nend", "  ((10 ** (n - 1))...(10 ** n)).count { |i| i.to_s =~ /^1|1$/ }\n\
    end", "  # Count all numbers with 1 at the end\n  sum = 0\n  10.times do |i|\n\
    \    sum += _count_1(n - 1, i)\n  end\n  # Add numbers with 1 at the start\n \
    \ sum += _count_1(n - 1, 1)\nend", "  a = (1..n).inject(1) { |s, x| s * 10 }\n\
    \  b = a / 10\n  a - b\nend", "\treturn n if n <= 0\n\tnums = []\n\t# Iterate\
    \ through every number starting with 1.\n\tfor i in 1..(10**(n-1))-1\n\t\t# If\
    \ number is 1 digit, add it to the numbers array.\n\t\tif i.to_s.length == 1\n\
    \t\t\tnums << i\n\t\t# If number is 2 digits, check if the first and last digit\
    \ are 1.\n\t\telsif i.to_s.length == 2\n\t\t\tnum_array = i.to_s.split('')\n\t\
    \t\tnums << i if num_array[0] == \"1\" || num_array[1] == \"1\"\n\t\t# If number\
    \ is 3 digits, check if the first or last digit are 1.\n\t\telsif i.to_s.length\
    \ == 3\n\t\t\tnum_array = i.to_s.split('')\n\t\t\tnums << i if num_array[0] ==\
    \ \"1\" || num_array[2] == \"1\"\n\t\t# If number is 4 digits, check if the first\
    \ or last digit are 1.\n\t\telsif i.to_s.length == 4\n\t\t\tnum_array = i.to_s.split('')\n\
    \t\t\tnums << i if num_array[0] == \"1\" || num_array[3] == \"1\"\n\t\t# If number\
    \ is 5 digits, check if the first or last digit are 1.\n\t\telsif i.to_s.length\
    \ == 5\n\t\t\tnum_array = i.to_s.split('')\n\t\t\tnums << i if num_array[0] ==\
    \ \"1\" || num_array[4] == \"1\"\n\t\t# If number is 6 digits, check if the first\
    \ or last digit are 1.\n\t\telsif i.to_s.length == 6\n\t\t\tnum_array = i.to_s.split('')\n\
    \t\t\tnums << i if num_array[0] == \"1\" || num_array[5] == \"1\"\n\t\t# If number\
    \ is 7 digits, check if the first or last digit are 1.\n", "  (10**(n-1)..10**n-1).count\
    \ { |i| i.to_s.start_with?('1') || i.to_s.end_with?('1') }\nend", "  (n == 1 ?\
    \ 1 : 10 * starts_one_ends(n - 1) + 10 ** (n - 1))\nend", "  (1..n).inject(0)\
    \ { |count, i| count + 9 * (10 ** (i - 1)) }\nend", "\treturn n if n == 1\n\t\
    return 0 if n == 0\n\t10*starts_one_ends(n-1) + 10**(n-1)\nend", "  puts \"starts_one_ends\"\
    \n  numbers = []\n  (10**(n-1)..10**n-1).each do |num|\n    num = num.to_s\n \
    \   if num[0] == \"1\" || num[-1] == \"1\"\n      numbers << num\n    end\n  end\n\
    \  numbers.count\nend", "  raise if n < 1\n  return n if n == 1\n  # 1xx...x +\
    \ 2 * starts_one_ends(n - 1)\n  1 * 10**(n - 1) + 2 * starts_one_ends(n - 1)\n\
    end", "  return 10 ** (n - 1)\nend", "  10 ** (n - 1) + 9 * 9 ** (n - 1)\nend",
  "  return 1 if n == 1\n  count = 0\n  (1..9).each do |i|\n    count += start_ends(n\
    \ - 1, i)\n  end\n  count\nend", "  sum = 0\n  i = 0\n  while i < n\n    a = 10\
    \ ** i\n    if i == 0\n      sum += 9\n    else\n      sum += ((a * 10) - 1) -\
    \ (a - 1)\n    end\n    i += 1\n  end\n  sum\nend", "  def is_one(n)\n    n ==\
    \ 1\n  end", "  # b = 10**(n-1)\n  # (((b+10)-b) * (b-1)) + b\n  (10**(n-1)) *\
    \ 11\nend", "  start_with_one = (n-1)*9**(n-1)\n  ends_with_one = 9**(n-1)\n \
    \ start_with_one + ends_with_one\nend", "  # Write your code here\n  puts n\n\
    end", "  return n if n < 10\n  f = n / 10\n  s = n % 10\n  (2 * f * (10 ** (n\
    \ - 2)) + (10 ** (n - 1))).to_i\nend", "  return 0 if n == 0\n  return 1 if n\
    \ == 1\n  return 10 if n == 2\n  return 2 * 9 ** 2 + starts_one_ends(n - 1)\n\
    end", "  num_list = []\n  (1..9).each do |num|\n    num_list << num\n    num_list\
    \ << num * 10**(n-1)\n  end\n  num_list.uniq.length\nend", "  sum = 0\n  (1..n).each\
    \ do |i|\n    sum += 9 * 10 ** (i - 1)\n  end\n  sum\nend", "  n_to_array(n).count\
    \ { |digit| digit == 1 }\nend", "  raise ArgumentError if n < 1\n  return 9 if\
    \ n == 1\n  return 9 + 9 * 10**(n - 2)\nend", "  return n if n < 2\n  count =\
    \ 0\n  (1..n).each do |i|\n    count += (10 ** (i - 1))\n  end\n  count * 2\n\
    end", "  (0..n-1).reduce([0,1]) { |s, i| [s[1], (s[1] + s[0]) * 10] }[1]\nend",
  "  return 1 if n == 1\n  return 10 if n == 2\n  arr = Array.new(n+1, 0)\n  arr[1]\
    \ = 1\n  arr[2] = 10\n  for i in 3..n\n    arr[i] = (arr[i-1] * 10) - (arr[i-2]\
    \ * 9)\n  end\n  arr[n]\nend", "  return 0 if n <= 1\n  i = 0\n  count = 0\n \
    \ while i < n\n    count += 10**i\n    i += 1\n  end\n  count*2 - (10**(n-1))\
    \ - 2\nend", "  return 1 if n == 1\n  return 10 if n == 2\n  (9 * 10**(n - 2))\
    \ + 1\nend", "  return n if n < 10\n  10**(n-1) + (10**(n-1) - 10**(n-2)) + starts_one_ends(n-1)\n\
    end", "  return 0 if n <= 0\n  # What if we sum the counts of numbers of (n-1)-digit\
    \ positive integers\n  # that start with 1 and that end with 1?\n  #\n  # The\
    \ (n-1)-digit numbers that start with 1 are the same as the (n-1)-digit\n  # numbers\
    \ that end with 1, so we count them twice.\n  #\n  # The (n-1)-digit numbers that\
    \ start with 1 or end with 1 are the same as\n  # the (n-1)-digit numbers that\
    \ neither start with 1 nor end with 1. We count\n  # them once.\n  return count_num_nums(n-1)*2\
    \ - count_num_nums(n-1)\nend", "  return (n * 10 ** (n - 1)) + (10 ** (n - 1))\n\
    end", "  # TODO\nend", "  return 10 if n == 1\n  return 9 * ((10 ** (n - 1)) -\
    \ (10 ** (n - 2)))\nend", "  count = 0\n  for i in 1..9\n    count += 1 if n.to_s.start_with?(i.to_s)\n\
    \    count += 1 if n.to_s.end_with?(i.to_s)\n  end\n  count\nend", "  sum = 0\n\
    \  (1..n).each do |i|\n    sum += i * (10 ** (i - 1))\n  end\n  sum\nend", " \
    \ \"\n  10**(n-1) + 9*10**(n-2) + 9*10**(n-3) + ... + 9*10**1 + 9*10**0\n  = 10**(n-1)\
    \ + 9*10**(n-2)*(10 + 9 + ... + 1)\n  = 10**(n-1) + 9*10**(n-2)*(10**2-1)/9\n\
    \  = 10**(n-1) + 10**(n-1) - 10**(n-2)\n  = 2*10**(n-1) - 10**(n-2)\n  \"\n  2*10**(n-1)\
    \ - 10**(n-2)\nend", "\tn\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
