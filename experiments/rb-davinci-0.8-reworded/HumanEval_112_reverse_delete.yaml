name: HumanEval_112_reverse_delete
language: rb
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return an array containing the result string and true/false\
  \ for the check.\n# Example\n# >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"\
  bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n\
  # >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s,\
  \ c)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n\
  \    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"\
  abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\"\
  , \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"\
  ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n  \
  \  assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"\
  abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\"\
  , true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true],\
  \ candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"\
  mamma\", \"mia\"))\n  end\nend\n"
completions: ["  s.delete!(c)\n  res = []\n  res << s << (s == s.reverse)\nend", " \
    \ result = s.delete(c)\n  palindrome = result == result.reverse\n  [result, palindrome]\n\
    end", "  p = s.gsub(/#{c}/, '')\n  q = p.reverse\n  [p, p==q]\nend", "  result\
    \ = s.delete c\n  [result, result == result.reverse]\nend", "  s.gsub!(/#{c}/,\
    \ '')\n  is_palindrome = s == s.reverse\n  [s, is_palindrome]\nend", "  s = s.gsub(Regexp.new(\"\
    [#{c}]\"), \"\")\n  arr = []\n  arr.push(s)\n  arr.push(s == s.reverse)\n  arr\n\
    end", "  v = s.delete(c)\n  v == v.reverse ? [v, true] : [v, false]\nend", " \
    \ new_s = \"\"\n  (0...s.length).each do |i|\n    unless c.include?(s[i])\n  \
    \    new_s += s[i]\n    end\n  end\n  if new_s == new_s.reverse\n    return [new_s,\
    \ true]\n  else\n    return [new_s, false]\n  end\nend\np reverse_delete(\"abcde\"\
    , \"ae\")\np reverse_delete(\"abcdef\", \"b\")\np reverse_delete(\"abcdedcba\"\
    , \"ab\")", "  c.each_char { |ch| s.delete!(ch) }\n  s.empty? ? [s, true] : [s,\
    \ s == s.reverse]\nend", "  c.chars.each do |letter|\n    s.gsub!(letter, '')\n\
    \  end\n  s.reverse == s ? [s, true] : [s, false]\nend", "    s.chars.reject {\
    \ |ch| c.include?(ch) }.join\nend", "  if s.chars.map { |x| x unless c.include?(x)\
    \ }.reject(&:nil?).join.reverse == s.chars.map { |x| x unless c.include?(x) }.reject(&:nil?).join\n\
    \    [s.chars.map { |x| x unless c.include?(x) }.reject(&:nil?).join, true]\n\
    \  else\n    [s.chars.map { |x| x unless c.include?(x) }.reject(&:nil?).join,\
    \ false]\n  end\nend", "  word = s.split('')\n  word.each { |i| word.delete(i)\
    \ if c.include?(i) }\n  word = word.join\n  answer = []\n  answer << word\n  if\
    \ word == word.reverse\n    answer << true\n  else\n    answer << false\n  end\n\
    \  answer\nend", "  s.chars.delete_if { |ch| c.include?(ch) }.join.reverse ==\
    \ s.chars.delete_if { |ch| c.include?(ch) }.join ? [s.chars.delete_if { |ch| c.include?(ch)\
    \ }.join, true] : [s.chars.delete_if { |ch| c.include?(ch) }.join, false]\nend",
  "  arr = s.split('')\n  arr.delete_if { |char| c.include?(char) }\n  result = arr.join('')\n\
    \  is_palindrome = result == result.reverse\n  [result, is_palindrome]\nend",
  "  s.delete!(c)\n  return [s, s.eql?(s.reverse)]\nend", "  a = []\n  s.each_char\
    \ do |x|\n    a << x if c.index(x).nil?\n  end\n  b = a.join('')\n  if b.reverse\
    \ == b\n    p [b, true]\n  else\n    p [b, false]\n  end\nend", "  s.delete!(c)\n\
    \  p [s, s == s.reverse]\nend", "  # return [s.gsub(/#{c}/, ''), s.gsub(/#{c}/,\
    \ '') == s.gsub(/#{c}/, '').reverse]\n  return [s.tr(c, ''), s.tr(c, '') == s.tr(c,\
    \ '').reverse]\nend", "  s.delete!(c)\n  s.reverse == s ? [s, true] : [s, false]\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
