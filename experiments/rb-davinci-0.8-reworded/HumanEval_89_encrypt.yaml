name: HumanEval_89_encrypt
language: rb
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\n# >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"\
  asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"\
  et\")\n# \"ix\"\ndef encrypt(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n\
  \    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"\
  ))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"\
  kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n\
  \    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"\
  lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  , candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"\
  e\", candidate.call(\"a\"))\n  end\nend\n"
completions: ["\tx = \"abcdefghijklmnopqrstuvwxyz\".split(\"\")\n\ty = \"cdefghijklmnopqrstuvwxyzab\"\
    .split(\"\")\n\tz = Hash[x.zip(y)]\n\ts.split(\"\").map {|letter| z[letter]}.join(\"\
    \")\nend", "  alphabet = ('a'..'z').to_a\n  s.each_char.map { |char| alphabet[alphabet.index(char)\
    \ + 2] }.join\nend", "  # Put your code here\nend", "  s.tr(\"a-z\",\"c-za-b\"\
    )\nend", "    lower_case = (\"a\"..\"z\").to_a\n    upper_case = (\"A\"..\"Z\"\
    ).to_a\n    # make an array of lower case letters and an array of upper case letters",
  "  string = s.split(\"\")\n  string.map do |e|\n    if e == \" \"\n      e = \"\
    \ \"\n    elsif e == \"z\"\n      e = \"b\"\n    elsif e == \"y\"\n      e = \"\
    a\"\n    else\n      e = (e.ord + 2).chr\n    end\n  end.join(\"\")\nend", "\t\
    letters = s.split(\"\")\n\tanswer = []\n\tletters.each do |letter|\n\t\tpos =\
    \ alphabet.index(letter)\n\t\tif pos +2 > 25\n\t\t\tanswer << alphabet[pos+2-26]\n\
    \t\telse\n\t\t\tanswer << alphabet[pos+2]\n\t\tend\n\tend\n\treturn answer.join\n\
    end", "    s.each_char.map { |c| (c.ord + (c.ord - 96) * 2).chr }.join\nend",
  "    alphabet = ('a'..'z').to_a.concat(('a'..'z').to_a)\n    (0...s.length).map\
    \ { |i| alphabet[alphabet.index(s[i]) + (2 * 2)] }.join\nend", "\t# alphabet =\
    \ [*('a'..'z')]\n\t# s.split(\"\").map{|letter| \n\t# \tif letter == 'y'\n\t#\
    \ \t\t'a'\n\t# \telsif letter == 'z'\n\t# \t\t'b'\n\t# \telse\n\t# \t\talphabet[alphabet.index(letter)+2]\n\
    \t# \tend\n\t# }.join\n\talphabet = [*('a'..'z')]\n\ts.split(\"\").map{|letter|\n\
    \t\talphabet[alphabet.index(letter)-2]\n\t}.join\nend", "    # new_str = \"\"\n\
    \    # s.each_char do |ch|\n    #     if (\"a\"..\"z\").include?(ch)\n    #  \
    \       new_str += ('a'.ord + (ch.ord - 'a'.ord + 2)%26).chr\n    #     else\n\
    \    #         new_str += ch\n    #     end\n    # end\n    # new_str\n    s.tr(\"\
    a-z\", \"c-za-b\")\nend", "  s.tr(\"a-z\", \"c-za-b\")\nend", "  split_string\
    \ = s.split(\"\")\n  result = \"\"\n  split_string.each do |letter|\n    is_upper\
    \ = letter.is_upper?\n    curr_letter = letter.downcase\n    if ('a'..'x').include?(curr_letter)\n\
    \      curr_letter = curr_letter.next.next\n    elsif ('y'..'z').include?(curr_letter)\n\
    \      curr_letter = 'a'\n    else\n      curr_letter = curr_letter\n    end\n\
    \    if is_upper\n      curr_letter = curr_letter.upcase\n    end\n    result\
    \ += curr_letter\n  end\n  result\nend\nputs \"call encrypt('asdfghjkl') #{encrypt('asdfghjkl')}\"\
    \nputs \"call encrypt('gf') #{encrypt('gf')}\"\nputs \"call encrypt('et') #{encrypt('et')}\"\
    \nputs \"call encrypt('H') #{encrypt('H')}\"", "  ret = \"\"\n  s.each_char do\
    \ |c|\n    if c == \"a\"\n      ret += \"c\"\n    elsif c == \"b\"\n      ret\
    \ += \"d\"\n    elsif c == \"c\"\n      ret += \"e\"\n    elsif c == \"d\"\n \
    \     ret += \"f\"\n    elsif c == \"e\"\n      ret += \"g\"\n    elsif c == \"\
    f\"\n      ret += \"h\"\n    elsif c == \"g\"\n      ret += \"i\"\n    elsif c\
    \ == \"h\"\n      ret += \"j\"\n    elsif c == \"i\"\n      ret += \"k\"\n   \
    \ elsif c == \"j\"\n      ret += \"l\"\n    elsif c == \"k\"\n      ret += \"\
    m\"\n    elsif c == \"l\"\n      ret += \"n\"\n    elsif c == \"m\"\n      ret\
    \ += \"o\"\n    elsif c == \"n\"\n      ret += \"p\"\n    elsif c == \"o\"\n \
    \     ret += \"q\"\n    elsif c == \"p\"\n      ret += \"r\"\n    elsif c == \"\
    q\"\n      ret += \"s\"\n    elsif c == \"r\"\n      ret += \"t\"\n    elsif c\
    \ == \"s\"\n      ret += \"u\"\n    elsif c == \"t\"\n      ret += \"v\"\n   \
    \ elsif c == \"u\"\n      ret += \"w\"\n    elsif c == \"v\"\n      ret += \"\
    x\"\n    elsif c == \"w\"\n      ret += \"y\"\n    elsif c == \"x\"\n      ret\
    \ += \"z\"\n    elsif c == \"y\"\n      ret += \"a\"\n    elsif c == \"z\"\n \
    \     ret += \"b\"\n    else\n      ret += c\n    end\n  end\n  return ret\nend",
  "\talphabet = ('a'..'z').to_a.join\n\talphabet_split = alphabet.split(\"\")\n\t\
    alphabet_rotated = alphabet_split.rotate(2*2)\n\talphabet_rotated_joint = alphabet_rotated.join\n\
    \ts.tr(alphabet, alphabet_rotated_joint)\nend", "\t#s = s.split(\"\")\n\t#s =\
    \ s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map\
    \ {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\
    \t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\
    \")\n\t\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\
    \t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\
    \")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t\n\t#s = s.split(\"\")\n\
    \t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map\
    \ {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\
    \t#s = s.join(\"\")\n\t\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s\
    \ = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\
    \")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t\n\
    \t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")", "  alpha\
    \ = ('a'..'z').to_a\n  encrypted = \"\"\n  s.each_char do |ch|\n    encrypted\
    \ += alpha[(alpha.index(ch.downcase) + 2) % 26]\n  end\n  encrypted\nend", "\t\
    a = s.split(\"\")\n\tc = []\n\ta.each do |i|\n\t\tif i.ord >= 97 && i.ord <= 109\n\
    \t\t\ti = (i.ord + 2).chr\n\t\telsif i.ord >= 110 && i.ord <= 122\n\t\t\ti = (i.ord\
    \ - 24).chr\n\t\telsif i.ord >= 65 && i.ord <= 77\n\t\t\ti = (i.ord + 2).chr\n\
    \t\telsif i.ord >= 78 && i.ord <= 90\n\t\t\ti = (i.ord - 24).chr\n\t\tend\n\t\t\
    c << i\n\tend\n\tc.join(\"\")\nend\nputs encrypt(\"hello\")\nputs encrypt(\"OLE\"\
    )\nputs encrypt(\"HI\")\nputs encrypt(\"ASDFGHJKL\")", "  alph = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  alph_arr = alph.split(\"\")\n  new_alph = \"cdefghijklmnopqrstuvwxyzab\"\n\
    \  new_alph_arr = new_alph.split(\"\")\n  new_s = \"\"\n  s.each_char do |c|\n\
    \    i = alph_arr.index(c)\n    new_s += new_alph_arr[i]\n  end\n  new_s\nend",
  "\t# solution code\n\tnew_string = \"\"\n\ti = 0\n\twhile i < s.length\n\t\tnew_letter\
    \ = s[i].ord + 2 * 2\n\t\tnew_string += new_letter.chr\n\t\ti += 1\n\tend\n\t\
    new_string\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
