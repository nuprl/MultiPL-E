name: HumanEval_89_encrypt
language: rb
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\n# >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"\
  asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"\
  et\")\n# \"ix\"\ndef encrypt(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n\
  \    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"\
  ))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"\
  kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n\
  \    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"\
  lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  , candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"\
  e\", candidate.call(\"a\"))\n  end\nend\n"
completions: ["\tx = \"abcdefghijklmnopqrstuvwxyz\".split(\"\")\n\ty = \"cdefghijklmnopqrstuvwxyzab\"\
    .split(\"\")\n\tz = Hash[x.zip(y)]\n\ts.split(\"\").map {|letter| z[letter]}.join(\"\
    \")\nend", "  alphabet = ('a'..'z').to_a\n  s.each_char.map { |char| alphabet[alphabet.index(char)\
    \ + 2] }.join\nend", "  # Put your code here\nend", "  s.tr(\"a-z\",\"c-za-b\"\
    )\nend", "    lower_case = (\"a\"..\"z\").to_a\n    upper_case = (\"A\"..\"Z\"\
    ).to_a\n    # make an array of lower case letters and an array of upper case letters",
  "  string = s.split(\"\")\n  string.map do |e|\n    if e == \" \"\n      e = \"\
    \ \"\n    elsif e == \"z\"\n      e = \"b\"\n    elsif e == \"y\"\n      e = \"\
    a\"\n    else\n      e = (e.ord + 2).chr\n    end\n  end.join(\"\")\nend", "\t\
    letters = s.split(\"\")\n\tanswer = []\n\tletters.each do |letter|\n\t\tpos =\
    \ alphabet.index(letter)\n\t\tif pos +2 > 25\n\t\t\tanswer << alphabet[pos+2-26]\n\
    \t\telse\n\t\t\tanswer << alphabet[pos+2]\n\t\tend\n\tend\n\treturn answer.join\n\
    end", "    s.each_char.map { |c| (c.ord + (c.ord - 96) * 2).chr }.join\nend",
  "    alphabet = ('a'..'z').to_a.concat(('a'..'z').to_a)\n    (0...s.length).map\
    \ { |i| alphabet[alphabet.index(s[i]) + (2 * 2)] }.join\nend", "\t# alphabet =\
    \ [*('a'..'z')]\n\t# s.split(\"\").map{|letter| \n\t# \tif letter == 'y'\n\t#\
    \ \t\t'a'\n\t# \telsif letter == 'z'\n\t# \t\t'b'\n\t# \telse\n\t# \t\talphabet[alphabet.index(letter)+2]\n\
    \t# \tend\n\t# }.join\n\talphabet = [*('a'..'z')]\n\ts.split(\"\").map{|letter|\n\
    \t\talphabet[alphabet.index(letter)-2]\n\t}.join\nend", "    # new_str = \"\"\n\
    \    # s.each_char do |ch|\n    #     if (\"a\"..\"z\").include?(ch)\n    #  \
    \       new_str += ('a'.ord + (ch.ord - 'a'.ord + 2)%26).chr\n    #     else\n\
    \    #         new_str += ch\n    #     end\n    # end\n    # new_str\n    s.tr(\"\
    a-z\", \"c-za-b\")\nend", "  s.tr(\"a-z\", \"c-za-b\")\nend", "  split_string\
    \ = s.split(\"\")\n  result = \"\"\n  split_string.each do |letter|\n    is_upper\
    \ = letter.is_upper?\n    curr_letter = letter.downcase\n    if ('a'..'x').include?(curr_letter)\n\
    \      curr_letter = curr_letter.next.next\n    elsif ('y'..'z').include?(curr_letter)\n\
    \      curr_letter = 'a'\n    else\n      curr_letter = curr_letter\n    end\n\
    \    if is_upper\n      curr_letter = curr_letter.upcase\n    end\n    result\
    \ += curr_letter\n  end\n  result\nend\nputs \"call encrypt('asdfghjkl') #{encrypt('asdfghjkl')}\"\
    \nputs \"call encrypt('gf') #{encrypt('gf')}\"\nputs \"call encrypt('et') #{encrypt('et')}\"\
    \nputs \"call encrypt('H') #{encrypt('H')}\"", "  ret = \"\"\n  s.each_char do\
    \ |c|\n    if c == \"a\"\n      ret += \"c\"\n    elsif c == \"b\"\n      ret\
    \ += \"d\"\n    elsif c == \"c\"\n      ret += \"e\"\n    elsif c == \"d\"\n \
    \     ret += \"f\"\n    elsif c == \"e\"\n      ret += \"g\"\n    elsif c == \"\
    f\"\n      ret += \"h\"\n    elsif c == \"g\"\n      ret += \"i\"\n    elsif c\
    \ == \"h\"\n      ret += \"j\"\n    elsif c == \"i\"\n      ret += \"k\"\n   \
    \ elsif c == \"j\"\n      ret += \"l\"\n    elsif c == \"k\"\n      ret += \"\
    m\"\n    elsif c == \"l\"\n      ret += \"n\"\n    elsif c == \"m\"\n      ret\
    \ += \"o\"\n    elsif c == \"n\"\n      ret += \"p\"\n    elsif c == \"o\"\n \
    \     ret += \"q\"\n    elsif c == \"p\"\n      ret += \"r\"\n    elsif c == \"\
    q\"\n      ret += \"s\"\n    elsif c == \"r\"\n      ret += \"t\"\n    elsif c\
    \ == \"s\"\n      ret += \"u\"\n    elsif c == \"t\"\n      ret += \"v\"\n   \
    \ elsif c == \"u\"\n      ret += \"w\"\n    elsif c == \"v\"\n      ret += \"\
    x\"\n    elsif c == \"w\"\n      ret += \"y\"\n    elsif c == \"x\"\n      ret\
    \ += \"z\"\n    elsif c == \"y\"\n      ret += \"a\"\n    elsif c == \"z\"\n \
    \     ret += \"b\"\n    else\n      ret += c\n    end\n  end\n  return ret\nend",
  "\talphabet = ('a'..'z').to_a.join\n\talphabet_split = alphabet.split(\"\")\n\t\
    alphabet_rotated = alphabet_split.rotate(2*2)\n\talphabet_rotated_joint = alphabet_rotated.join\n\
    \ts.tr(alphabet, alphabet_rotated_joint)\nend", "\t#s = s.split(\"\")\n\t#s =\
    \ s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map\
    \ {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\
    \t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\
    \")\n\t\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\
    \t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\
    \")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t\n\t#s = s.split(\"\")\n\
    \t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map\
    \ {|x| x.next}\n\t#s = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\
    \t#s = s.join(\"\")\n\t\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s\
    \ = s.join(\"\")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\
    \")\n\t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")\n\t\n\
    \t#s = s.split(\"\")\n\t#s = s.map {|x| x.next}\n\t#s = s.join(\"\")", "  alpha\
    \ = ('a'..'z').to_a\n  encrypted = \"\"\n  s.each_char do |ch|\n    encrypted\
    \ += alpha[(alpha.index(ch.downcase) + 2) % 26]\n  end\n  encrypted\nend", "\t\
    a = s.split(\"\")\n\tc = []\n\ta.each do |i|\n\t\tif i.ord >= 97 && i.ord <= 109\n\
    \t\t\ti = (i.ord + 2).chr\n\t\telsif i.ord >= 110 && i.ord <= 122\n\t\t\ti = (i.ord\
    \ - 24).chr\n\t\telsif i.ord >= 65 && i.ord <= 77\n\t\t\ti = (i.ord + 2).chr\n\
    \t\telsif i.ord >= 78 && i.ord <= 90\n\t\t\ti = (i.ord - 24).chr\n\t\tend\n\t\t\
    c << i\n\tend\n\tc.join(\"\")\nend\nputs encrypt(\"hello\")\nputs encrypt(\"OLE\"\
    )\nputs encrypt(\"HI\")\nputs encrypt(\"ASDFGHJKL\")", "  alph = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  alph_arr = alph.split(\"\")\n  new_alph = \"cdefghijklmnopqrstuvwxyzab\"\n\
    \  new_alph_arr = new_alph.split(\"\")\n  new_s = \"\"\n  s.each_char do |c|\n\
    \    i = alph_arr.index(c)\n    new_s += new_alph_arr[i]\n  end\n  new_s\nend",
  "\t# solution code\n\tnew_string = \"\"\n\ti = 0\n\twhile i < s.length\n\t\tnew_letter\
    \ = s[i].ord + 2 * 2\n\t\tnew_string += new_letter.chr\n\t\ti += 1\n\tend\n\t\
    new_string\nend", "\talpha = \"abcdefghijklmnopqrstuvwxyz\"\n\talpha_up = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\tnew_s = \"\"\n\ts.each_char do |char|\n\t\tif alpha.include?(char)\n\t\t\t\
    i = alpha.index(char)\n\t\t\tn = (i + (2 * 2)) % 26\n\t\t\tnew_s += alpha[n]\n\
    \t\telsif alpha_up.include?(char)\n\t\t\ti = alpha_up.index(char)\n\t\t\tn = (i\
    \ + (2 * 2)) % 26\n\t\t\tnew_s += alpha_up[n]\n\t\telse\n\t\t\tnew_s += char\n\
    \t\tend\n\tend\n\tnew_s\nend", "\t", "  s.split(\"\").map { |x| x.next.next }.join(\"\
    \")\nend", "\t# rotate string 1 by 1\nend", "  s.tr(\"a-z\", \"c-za-b\")\nend",
  "    results = \"\"\n    alpha = 'abcdefghijklmnopqrstuvwxyz'\n    shifted = alpha[2..-1]\
    \ + alpha[0..1]\n    s.each_char do |c|\n        results += shifted[alpha.index(c)]\n\
    \    end\n    results\nend", "\t@encrypt = s.split(\"\")\n\t@newEncrypt = []\n\
    \t@string = \"abcdefghijklmnopqrstuvwxyz\"\n\t@newString = @string.split(\"\"\
    )\n\t@firstLoop = true\n\t@encrypt.each do |letter|\n\t\t@newString.each do |stringLetter|\n\
    \t\t\tif letter == stringLetter\n\t\t\t\tif @firstLoop == true\n\t\t\t\t\t@newEncrypt.push(@newString[@newString.index(stringLetter)\
    \ + 2])\n\t\t\t\t\t@firstLoop = false\n\t\t\t\telsif @firstLoop == false\n\t\t\
    \t\t\t@newEncrypt.push(@newString[@newString.index(stringLetter) + 2])\n\t\t\t\
    \tend\n\t\t\tend\n\t\tend\n\tend\n\t@newEncrypt.join\nend", "  abc = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  abc = abc.chars.rotate(2 * 2).join\n  abc_up = abc.upcase\n  final = ''\n \
    \ s.each_char do |char|\n    if abc.include?(char)\n      idx = abc.index(char)\n\
    \      final += abc[idx + 2]\n    elsif abc_up.include?(char)\n      idx = abc_up.index(char)\n\
    \      final += abc_up[idx + 2]\n    else\n      final += char\n    end\n  end\n\
    \  final\nend", "    alphabet = ('a'..'z').to_a\n    encrypted = []\n    s.split(\"\
    \").each do |char|\n        if alphabet.include?(char)\n            if alphabet.index(char)\
    \ < 23\n                encrypted << alphabet[alphabet.index(char) + 2]\n    \
    \        elsif alphabet.index(char) == 23\n                encrypted << alphabet[1]\n\
    \            elsif alphabet.index(char) == 24\n                encrypted << alphabet[2]\n\
    \            elsif alphabet.index(char) == 25\n                encrypted << alphabet[3]\n\
    \            end\n        else\n            encrypted << char\n        end\n \
    \   end\n    encrypted.join(\"\")\nend", "  ary = s.split(\"\")\n  ary.map! do\
    \ |char|\n    if char.ord + 4 > 122\n      (char.ord + 4 - 26).chr\n    else\n\
    \      (char.ord + 4).chr\n    end\n  end\n  ary.join(\"\")\nend", "  # create\
    \ an array with the alphabet and hash with corresponding values\n  # iterate through\
    \ the string, if the alphabet includes the given character,\n  # replace the character\
    \ with the corresponding value", "  i = 0\n  while i < s.length\n    char = s[i]\n\
    \    ascii = char.ord\n    # if uppercase\n    if ascii.between?(65, 90)\n   \
    \   if ascii >= 65 && ascii <= 66\n        char = (ascii + 24).chr\n      elsif\
    \ ascii >= 67 && ascii <= 90\n        char = (ascii + 2).chr\n      end\n    #\
    \ if lowercase\n    elsif ascii.between?(97, 122)\n      if ascii >= 97 && ascii\
    \ <= 98\n        char = (ascii + 24).chr\n      elsif ascii >= 99 && ascii <=\
    \ 122\n        char = (ascii + 2).chr\n      end\n    end\n    s[i] = char\n \
    \   i += 1\n  end\n  return s\nend", "  new_string = \"\"\n  s.split(\"\").each\
    \ do |c|\n    alpha_index = $alpha.index(c)\n    new_string += $alpha[alpha_index\
    \ + $shift_amount]\n  end\n  return new_string\nend", "  letters = ('a'..'z').to_a\n\
    \  rotated_letters = letters.rotate(2*2)\n  h = Hash[letters.zip(rotated_letters)]\n\
    \  s.chars.map{|char| h[char]}.join\nend", "\tshift = s.length * 2\n\ts.split(\"\
    \").map { |ch| (ch.ord + shift).chr }.join(\"\")\nend", "  s.tr('a-z', 'c-za-b')\n\
    end", "    encrypt_array = []\n    alphabet = ('a'..'z').to_a\n    s.each_char\
    \ do |c|\n        if alphabet.include?(c)\n            encrypt_array << alphabet[(alphabet.index(c)\
    \ + 2) % 26]\n        else\n            encrypt_array << c\n        end\n    end\n\
    \    return encrypt_array.join(\"\")\nend", "  n = s.length\n  r = \"\"\n  n.times\
    \ do |i|\n    r += (((s[i].ord)-97+2*2)%26+97).chr\n  end\n  return r\nend", " \
    \ range = (\"a\"..\"z\").to_a\n  range_rotated = range.rotate(2)\n  map = Hash[range.zip(range_rotated)]\n\
    \  a = []\n  s.each_char do |ch|\n    a << map[ch]\n  end\n  a.join\nend", "\t\
    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\talphabet_array = alphabet.split(\"\
    \")\n\talphabet_array_rotated = alphabet_array.rotate(2)\n\talphabet_rotated =\
    \ alphabet_array_rotated.join(\"\")\n\ts_array = s.split(\"\")\n\ts_array.each_with_index\
    \ do |l, i|\n\t\ts_array[i] = alphabet_rotated[alphabet_array.index(l)]\n\tend\n\
    \ts_array.join(\"\")\nend", "  return s.chars.map { |letter| letter.next.next\
    \ }.join\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  shift = 2 * alphabet.length\n\
    \  index = 0\n  encrypted = \"\"\n  while index < s.length\n    letter = s[index]\n\
    \    old_index = alphabet.index(letter)\n    new_index = old_index + shift\n \
    \   if new_index >= alphabet.length\n      new_index = new_index - alphabet.length\n\
    \    end\n    encrypted = encrypted + alphabet[new_index]\n    index = index +\
    \ 1\n  end\n  return encrypted\nend", "  alphabet = (\"a\"..\"z\").to_a\n  encoded_sentence\
    \ = []\n  s.each_char do |char|\n    encoded_sentence << alphabet[alphabet.index(char)+2]\n\
    \  end\n  encoded_sentence.join(\"\")\nend", "\nend", "\t# s is the argument string\n\
    \t# call .chars method to turn the string into an array of characters\n\ts = s.chars\n\
    \t# create a new array to store encrypted characters\n\tencrypted = []\n\t# iterate\
    \ through each character in the array\n\ts.each do |char|\n\t\t# the character\
    \ will be added to the new array encrypted\n\t\t# the character will be converted\
    \ to an integer value\n\t\t# the ascii value will be added to 2 and converted\
    \ back to a character\n\t\tencrypted << (char.ord + 2).chr\n\tend\n\t# join the\
    \ encrypted array back into a string\n\t# and return the string\n\treturn encrypted.join(\"\
    \")\nend", "\tencrypt = \"abcdefghijklmnopqrstuvwxyz\"\n\ts.tr(encrypt, encrypt[2..-1]\
    \ + encrypt[0..1])\nend", "\talphabet = (\"a\"..\"z\").to_a\n\thalf = alphabet.length\
    \ / 2\n\tcombined = alphabet[half..-1] + alphabet[0..half-1]\n\tnew_alphabet =\
    \ combined[0..-1] + combined[0..-1]\n\ts.chars.map { |c| new_alphabet[alphabet.index(c)]\
    \ }.join\nend", "\tanswer = \"\"\n\ts.each_char { |c|\n\t\tif /[A-Za-z]/.match(c)\n\
    \t\t\tn = c.ord + 2\n\t\t\tif /[A-Z]/.match(c)\n\t\t\t\tn -= 26 if n > 'Z'.ord\n\
    \t\t\telsif /[a-z]/.match(c)\n\t\t\t\tn -= 26 if n > 'z'.ord\n\t\t\tend\n\t\t\t\
    answer += n.chr\n\t\telse\n\t\t\tanswer += c\n\t\tend\n\t}\n\tanswer\nend", " \
    \ alphabet = ('a'..'z').to_a\n  i = 0\n  while i < s.length\n    index = alphabet.index(s[i])\
    \ + 2 * 2\n    s[i] = alphabet[index]\n    i += 1\n  end\n  return s\nend", "\t\
    res = \"\"\n\tlen = s.length - 1\n\ti = 0\n\twhile i <= len\n\t\tif s[i] >= \"\
    x\"\n\t\t\tres << \"a\"\n\t\telsif s[i] >= \"w\"\n\t\t\tres << \"z\"\n\t\telse\n\
    \t\t\tres << s[i].next.next\n\t\tend\n\t\ti += 1\n\tend\n\tres\nend", "  alphabet\
    \ = (\"a\"..\"z\").to_a\n  new_s = \"\"\n  s.split(\"\").each do |i|\n    if alphabet.include?(i)\n\
    \      index = alphabet.index(i)\n      if index >= 2\n        new_s << alphabet[index\
    \ - 2]\n      else\n        new_s << alphabet[index + 24]\n      end\n    else\n\
    \      new_s << i\n    end\n  end\n  new_s\nend", "  chars = []\n  s.each_char\
    \ { |x| chars << x }\n  encrypted = []\n  chars.each do |c|\n    if c == \"z\"\
    \n      encrypted << \"b\"\n    elsif c == \"y\"\n      encrypted << \"a\"\n \
    \   else\n      encrypted << (c.ord + 2).chr\n    end\n  end\n  encrypted.join(\"\
    \")\nend", "\talphabet = (\"a\"..\"z\").to_a\n\tshifted_alphabet = (\"a\"..\"\
    z\").to_a.rotate(4)\n\thash = Hash[alphabet.zip(shifted_alphabet)]\n\tarr = s.split(\"\
    \")\n\tcounter = 0\n\tnew_str = \"\"\n\twhile counter < arr.length\n\t\tnew_str\
    \ << hash[arr[counter]]\n\t\tcounter += 1\n\tend\n\treturn new_str\nend", "\t\
    chars = s.split(\"\")\n\tletters = {\n\t\t\"a\" => \"c\",\n\t\t\"b\" => \"d\"\
    ,\n\t\t\"c\" => \"e\",\n\t\t\"d\" => \"f\",\n\t\t\"e\" => \"g\",\n\t\t\"f\" =>\
    \ \"h\",\n\t\t\"g\" => \"i\",\n\t\t\"h\" => \"j\",\n\t\t\"i\" => \"k\",\n\t\t\"\
    j\" => \"l\",\n\t\t\"k\" => \"m\",\n\t\t\"l\" => \"n\",\n\t\t\"m\" => \"o\",\n\
    \t\t\"n\" => \"p\",\n\t\t\"o\" => \"q\",\n\t\t\"p\" => \"r\",\n\t\t\"q\" => \"\
    s\",\n\t\t\"r\" => \"t\",\n\t\t\"s\" => \"u\",\n\t\t\"t\" => \"v\",\n\t\t\"u\"\
    \ => \"w\",\n\t\t\"v\" => \"x\",\n\t\t\"w\" => \"y\",\n\t\t\"x\" => \"z\",\n\t\
    \t\"y\" => \"a\",\n\t\t\"z\" => \"b\"\n\t}\n\tarray = []\n\tchars.each do |char|\n\
    \t\tif letters.include?(char)\n\t\t\tarray << letters[char]\n\t\telse\n\t\t\t\
    array << char\n\t\tend\n\tend\n\tarray.join\nend", "\tarr = []\n\ts.each_char\
    \ do |c|\n\t\tif c == \" \"\n\t\t\tarr << \" \"\n\t\telse\n\t\t\tarr << c.ord\n\
    \t\tend\n\tend\n\tarr.map! do |x|\n\t\tif x == \" \"\n\t\t\tx\n\t\telse\n\t\t\t\
    if x + 2 > 122\n\t\t\t\t((x + 2) - 122) + 96\n\t\t\telse\n\t\t\t\tx + 2\n\t\t\t\
    end\n\t\tend\n\tend\n\tarr.map {|x| x.chr }.join\nend", "  result = \"\"\n  alphabet\
    \ = (\"a\"..\"z\").to_a\n  s.each_char do |c|\n    if alphabet.include?(c)\n \
    \     shifted_index = (alphabet.index(c) + (2 * 2)) % 26\n      result += alphabet[shifted_index]\n\
    \    else\n      result += c\n    end\n  end\n  result\nend", "  alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  rotated = alpha[2..-1] + alpha[0..1]\n  chars = s.split(\"\")\n  new_chars\
    \ = chars.map do |char|\n    i = alpha.index(char)\n    new_char = rotated[i]\n\
    \  end\n  new_chars.join(\"\")\nend", "  letters = s.split(\"\")\n  alphabet =\
    \ (\"a\"..\"z\").to_a\n  encrypted = []\n  letters.each do |letter|\n    i = alphabet.index(letter)\n\
    \    i -= 2\n    encrypted << alphabet[i]\n  end\n  encrypted.join(\"\")\nend",
  "  # your code here\nend", "  s.bytes.map { |c| c + 4 }.map(&:chr).join\nend", "\t\
    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\tsplit_str = s.split(\"\")\n\tencrypted_str\
    \ = \"\"\n\tsplit_str.each do |i|\n\t\t# alphabet.each_with_index do |x, y|\n\t\
    \t# \tif i == x\n\t\t# \t\tencrypted_str += alphabet[y+2]\n\t\t# \tend\n\t\t#\
    \ end\n\t\tencrypted_str += alphabet[alphabet.index(i)+2]\n\tend\n\tencrypted_str\n\
    end", end, "  alpha = ('a'..'z').to_a\n  s.downcase.chars.map { |c| c == ' ' ?\
    \ ' ' : alpha[alpha.index(c) + 4] }.join\nend", "  alphabet = ('a'..'z').to_a\n\
    \  array_to_return = []\n  s.chars.each do |letter|\n    index = alphabet.index(letter)\n\
    \    new_index = index + 2 * 2\n    array_to_return << alphabet[new_index]\n \
    \ end\n  array_to_return.join\nend", "  alphabet = Array(\"a\"..\"z\")\n  cipher\
    \ = Hash[alphabet.zip(alphabet.rotate(2))]\n  s.chars.map { |c| cipher[c] }.join\n\
    end", "  alphabet = ('a'..'z').to_a\n  # \"hi\"\n  # alphabet.rotate(8)", "\t\
    alphabet = ('a'..'z').to_a\n\ts = s.split(\"\")\n\twords = []\n\ts.each do |letters|\n\
    \t\twords << alphabet.rotate(alphabet.index(letters)*2)\n\tend\n\twords.join\n\
    end", "  alphabet = (\"a\"..\"z\").to_a\n  s.chars.map { |char| alphabet[alphabet.index(char)\
    \ + 2 * 2] }.join(\"\")\nend", "\talphabet = (\"a\"..\"z\").to_a\n\talphabet_2\
    \ = (\"a\"..\"z\").to_a.rotate(2)\n\tenc_arr = []\n\tfor i in s.chars\n\t\tenc_arr\
    \ << alphabet_2[alphabet.index(i)]\n\tend\n\tenc_arr.join\nend", "  alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n  enc = \"\"\n  s.split(\"\").each do |letter|\n\
    \    if !alphabet.include?(letter)\n      enc += letter\n    else\n      enc +=\
    \ alphabet[alphabet.index(letter) + 3]\n    end\n  end\n  enc\nend", "  index\
    \ = 0\n  new_string = \"\"\n  while index < s.length\n    if s[index] == \"z\"\
    \n      new_string += \"b\"\n    elsif s[index] == \"y\"\n      new_string +=\
    \ \"a\"\n    else\n      new_string += s[index].next.next\n    end\n    index\
    \ += 1\n  end\n  return new_string\nend", "\t# puts s\n\t# puts s.split('')\n\t\
    # puts s.split('').map{|x| x.ord}\n\t# puts s.split('').map{|x| x.ord + 2}\n\t\
    # puts s.split('').map{|x| x.ord + 2}.map{|x| x.chr}\n\t# puts s.split('').map{|x|\
    \ x.ord + 2}.map{|x| x.chr}.join\n\ts.split('').map{|x| x.ord + 2}.map{|x| x.chr}.join\n\
    end", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  encryption = ''\n  new_key\
    \ = Hash.new\n  encrypted_word = ''\n  alphabet.split('').each_with_index do |letter,\
    \ index|\n    new_key[letter] = index\n  end\n  s.split('').each do |letter|\n\
    \    encryption = new_key[letter] + 2\n    encrypted_word += alphabet[encryption]\n\
    \  end\n  encrypted_word\nend", "  (0...s.length).each do |i|\n    s[i] = (s[i].ord\
    \ + (2*2)).chr\n  end\n  s\nend", "  alphabet = (\"a\"..\"z\").to_a\n  encrypted\
    \ = \"\"\n  s.each_char do |char|\n    if (char == \"a\" || char == \"A\")\n \
    \     encrypted << alphabet[2]\n    elsif (char == \"b\" || char == \"B\")\n \
    \     encrypted << alphabet[3]\n    elsif (char == \"c\" || char == \"C\")\n \
    \     encrypted << alphabet[4]\n    elsif (char == \"d\" || char == \"D\")\n \
    \     encrypted << alphabet[5]\n    elsif (char == \"e\" || char == \"E\")\n \
    \     encrypted << alphabet[6]\n    elsif (char == \"f\" || char == \"F\")\n \
    \     encrypted << alphabet[7]\n    elsif (char == \"g\" || char == \"G\")\n \
    \     encrypted << alphabet[8]\n    elsif (char == \"h\" || char == \"H\")\n \
    \     encrypted << alphabet[9]\n    elsif (char == \"i\" || char == \"I\")\n \
    \     encrypted << alphabet[10]\n    elsif (char == \"j\" || char == \"J\")\n\
    \      encrypted << alphabet[11]\n    elsif (char == \"k\" || char == \"K\")\n\
    \      encrypted << alphabet[12]\n    elsif (char == \"l\" || char == \"L\")\n\
    \      encrypted << alphabet[13]\n    elsif (char == \"m\" || char == \"M\")\n\
    \      encrypted << alphabet[14]\n    elsif (char == \"n\" || char == \"N\")\n\
    \      encrypted << alphabet[15]\n    elsif (char == \"o\" || char == \"O\")\n\
    \      encrypted << alphabet[16]\n    elsif (char == \"p\" || char == \"P\")\n\
    \      encrypted << alphabet[17]\n    elsif (char == \"q\" || char == \"Q\")\n\
    \      encrypted << alphabet[18]\n    elsif (char == \"r\" || char == \"R\")\n\
    \      encrypted << alphabet[19]\n    elsif (char == \"s\" || char == \"S\")\n\
    \      encrypted << alphabet[20]\n    elsif (char == \"", "  cipher = \"\"\n \
    \ i = 0\n  while i < s.length do\n    if s[i] == \" \"\n      cipher = cipher\
    \ + \" \"\n    elsif s[i] == \"z\"\n      cipher = cipher + \"b\"\n    elsif s[i]\
    \ == \"y\"\n      cipher = cipher + \"a\"\n    else\n      cipher = cipher + (s[i].ord\
    \ + 2).chr\n    end\n    i += 1\n  end\n  cipher\nend", "  # your code here\n\
    end", "\tdown_by_two = s.chars.map do |letter|\n\t\tcase letter\n\t\twhen \"a\"\
    \n\t\t\t\"y\"\n\t\twhen \"b\"\n\t\t\t\"z\"\n\t\twhen \"c\"\n\t\t\t\"a\"\n\t\t\
    when \"d\"\n\t\t\t\"b\"\n\t\twhen \"e\"\n\t\t\t\"c\"\n\t\twhen \"f\"\n\t\t\t\"\
    d\"\n\t\twhen \"g\"\n\t\t\t\"e\"\n\t\twhen \"h\"\n\t\t\t\"f\"\n\t\twhen \"i\"\n\
    \t\t\t\"g\"\n\t\twhen \"j\"\n\t\t\t\"h\"\n\t\twhen \"k\"\n\t\t\t\"i\"\n\t\twhen\
    \ \"l\"\n\t\t\t\"j\"\n\t\twhen \"m\"\n\t\t\t\"k\"\n\t\twhen \"n\"\n\t\t\t\"l\"\
    \n\t\twhen \"o\"\n\t\t\t\"m\"\n\t\twhen \"p\"\n\t\t\t\"n\"\n\t\twhen \"q\"\n\t\
    \t\t\"o\"\n\t\twhen \"r\"\n\t\t\t\"p\"\n\t\twhen \"s\"\n\t\t\t\"q\"\n\t\twhen\
    \ \"t\"\n\t\t\t\"r\"\n\t\twhen \"u\"\n\t\t\t\"s\"\n\t\twhen \"v\"\n\t\t\t\"t\"\
    \n\t\twhen \"w\"\n\t\t\t\"u\"\n\t\twhen \"x\"\n\t\t\t\"v\"\n\t\twhen \"y\"\n\t\
    \t\t\"w\"\n\t\twhen \"z\"\n\t\t\t\"x\"\n\t\tend\n\tend\n\t# my_array.join\n\t\
    down_by_two.join\nend", "\tx = 0\n\twhile x < s.length\n\t\tc = s[x].ord\n\t\t\
    if c >= 'a'.ord && c <= 'y'.ord\n\t\t\t# c += 2\n\t\t\t# c += 1\n\t\t\tc = 'a'.ord\
    \ + (c + 3 - 'a'.ord) % 26\n\t\t\t# c = 'a'.ord + (c + 1 - 'a'.ord) % 26\n\t\t\
    elsif c >= 'A'.ord && c <= 'Y'.ord\n\t\t\t# c += 2\n\t\t\t# c += 1\n\t\t\tc =\
    \ 'A'.ord + (c + 3 - 'A'.ord) % 26\n\t\t\t# c = 'A'.ord + (c + 1 - 'A'.ord) %\
    \ 26\n\t\tend\n\t\ts[x] = c.chr\n\t\tx += 1\n\tend\n\treturn s\nend", "  #I'm\
    \ going to try to use a hash\n  #create the hash", "\tletters = s.split(\"\")\n\
    \tletters.map! { |letter| letter.ord}\n\tletters.map! { |num| num+=4}\n\tletters.map!\
    \ { |num| num.chr}\n\tletters.join\nend", "  alpha = (\"a\"..\"z\").to_a\n  result\
    \ = []\n  s.split(\"\").each do |letter|\n    if letter == \"z\"\n      result\
    \ << \"b\"\n    elsif letter == \"y\"\n      result << \"a\"\n    else\n     \
    \ result << alpha[(alpha.index(letter) + 3) % 26]\n    end\n  end\n  result.join(\"\
    \")\nend", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  encrypted = ''\n  s.each_char\
    \ do |char|\n    if alphabet.include?(char)\n      encrypted << alphabet[(alphabet.index(char)\
    \ + 4) % 26]\n    else\n      encrypted << char\n    end\n  end\n  encrypted\n\
    end", "  s.tr \"a-z\", \"c-za-b\"\nend", "\talphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\ti = 0\n\tresult = \"\"\n\twhile i < s.length\n\t\tif s[i] == \" \"\n\t\t\t\
    result += \" \"\n\t\telse\n\t\t\tcurrent_letter = s[i]\n\t\t\tcurrent_index =\
    \ alphabet.index(current_letter)\n\t\t\tnew_index = current_index + 2\n\t\t\t\
    new_letter = alphabet[new_index]\n\t\t\tresult += new_letter\n\t\tend\n\t\ti +=\
    \ 1\n\tend\n\treturn result\nend", "  s.split(\"\").map { |letter| rotate(letter)\
    \ }.join\nend", "    s.chars.map { |l| l.next.next }.join\nend", "  lower_array\
    \ = (\"a\"..\"z\").to_a\n  lower_array.each_with_index do |v,i|\n    if i + 2\
    \ <= lower_array.length\n      lower_array[i] = lower_array[i + 2]\n    else\n\
    \      lower_array[i] = lower_array[i - 24]\n    end\n  end\n  encrypted_array\
    \ = s.split(\"\")\n  encrypted_array.each_with_index do |v,i|\n    encrypted_array[i]\
    \ = lower_array[lower_array.index(v)]\n  end\n  encrypted_array.join(\"\")\nend",
  "  alphabet = ('a'..'z').to_a\n  s.chars.map do |char|\n    char.next.next\n  end.join\n\
    end", "\ts.tr(\"a-z\",\"c-za-b\")\nend", "    s.split(\"\").map { |letter| \n\
    \        next_letter = letter.ord + 2\n        next_letter -= 26 if next_letter\
    \ > 122\n        next_letter.chr\n    }.join(\"\")\nend", "\talphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tnum = alphabet.index(s) + 2\n\tnew = alphabet[num]\nend", "\t#s=\"hi\"\n\t\
    s=s.split(\"\")\n\ta=[]\n\ts.each do |x|\n\t\tx =x.ord\n\t\tx =x+2\n\t\tx =x.chr\n\
    \t\ta.push(x)\n\tend\n\ts=a.join(\"\")\n\treturn s\nend\nputs encrypt(\"abc\")",
  "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  encrypt = \"\"\n  s.length.times\
    \ do |i|\n    encrypt << alphabet[alphabet.index(s[i]) + 4]\n  end\n  return encrypt\n\
    end", "\tk = Hash.new\n\tx = \"abcdefghijklmnopqrstuvwxyz\"\n\ti = 0\n\twhile\
    \ i < x.length\n\t\tk[x[i]] = x[i+2]\n\t\ti+=1\n\tend\n\tnew_string = \"\"\n\t\
    i = 0\n\twhile i < s.length\n\t\tnew_string << k[s[i]]\n\t\ti+=1\n\tend\n\treturn\
    \ new_string\nend", "  s.split(\"\").map { |c| (c.ord + (((c.ord - \"a\".ord)\
    \ * 2) % 26)).chr }.join\nend", "\ts.chars.map { |i| ((i.ord - 97 + 2) % 26 +\
    \ 97).chr }.join(\"\")\nend", "\nend", "    new_string = \"\"\n    alpha = \"\
    abcdefghijklmnopqrstuvwxyz\"\n    for i in 0..s.length-1\n        # if s[i] ==\
    \ \"z\"\n        #     new_string += \"b\"\n        # elsif s[i] == \"y\"\n  \
    \      #     new_string += \"a\"\n        # else\n        #     new_string +=\
    \ alpha[alpha.index(s[i])+2]\n        # end\n        # or we can do this:\n  \
    \      index = alpha.index(s[i]) + 2\n        index -= 26 if index > 25\n    \
    \    new_string += alpha[index]\n    end\n    return new_string\nend", "\tchars\
    \ = s.split(\"\")\n\tnum=[]\n\t# puts chars\n\tchars.each do |x|\n\t\tnum << (x.ord-96)\n\
    \tend\n\t# puts num\n\trotated = num.map{|x| (x+2)%26}\n\t# puts rotated\n\talpha\
    \ = rotated.map{|x| (x+96).chr}\n\t# puts alpha\n\talpha.join\nend", "  s.split(\"\
    \").map { |c| c.ord+2*2 }.map { |i| i.chr }.join\nend", "    s.chars.map { |x|\
    \ \n        i = x.ord - 97\n        i += 2 * 2\n        i = i % 26\n        i\
    \ += 97\n        i.chr\n    }.join\nend", "  word = \"\"\n  alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  s.each_char do |char|\n    word << alpha[(alpha.index(char) + 2 * 2) % 26]\n\
    \  end\n  word\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  answer =\
    \ \"\"\n  s.each_char do |letter|\n    index = alphabet.index(letter)\n    index\
    \ += 4\n    answer += alphabet[index]\n  end\n  answer\nend", "  arr = s.split(\"\
    \")\n  for i in 0..arr.length-1\n    if arr[i] == \"z\"\n      arr[i] = \"b\"\n\
    \    elsif arr[i] == \"y\"\n      arr[i] = \"a\"\n    else\n      arr[i] = arr[i].next.next\n\
    \    end\n  end\n  arr.join\nend", "  s = s.split(\"\")\n  # i = 0\n  # s.length.times\
    \ do \n  #   if s[i] == \"z\"\n  #     s[i] = \"b\"\n  #   elsif s[i] == \"y\"\
    \n  #     s[i] = \"a\"\n  #   else\n  #     s[i] = s[i].next.next\n  #   end\n\
    \  #   i += 1\n  # end\n  # return s.join\n  return s.map { |char| char.next.next\
    \ }.join\nend", "\ts.each_char do |c|\n\t\ts = s.sub(c, ((c.ord - 97)*2 +1).chr)\n\
    \tend\n\treturn s\nend", "\tletters = s.split(\"\")\n\tarr = [\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"]\n\tindex = 0\n\tanswer = []\n\tletters.each do |letter|\n\t\tindex\
    \ = arr.index(letter)\n\t\t\tif index.between?(0,7)\n\t\t\t\tnew_index = index\
    \ + (2 * 2)\n\t\t\telsif index.between?(8,14)\n\t\t\t\tnew_index = index - (8\
    \ * 2)\n\t\t\telsif index.between?(15,21)\n\t\t\t\tnew_index = index - (15 * 2)\n\
    \t\t\telsif index.between?(22,26)\n\t\t\t\tnew_index = index - (22 * 2)\n\t\t\t\
    end\n\t\tanswer << arr[new_index]\n\tend\n\treturn answer.join(\"\")\nend", "\t\
    # Create an alphabet array\n\talphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n\t# Make\
    \ an empty string to store the encrypted string in\n\tencrypted = \"\"\n\t# Loop\
    \ through each letter in the given string\n\ts.each_char do |letter|\n\t\t# Find\
    \ the index of the letter in the alphabet array\n\t\tindex = alphabet.index(letter)\n\
    \t\t# Add two to the index\n\t\tindex += 2\n\t\t# Double the index\n\t\tindex\
    \ *= 2\n\t\t# If the index is greater than 26, subtract 26 from the index\n\t\t\
    index -= 26 if index > 26\n\t\t# Add the encrypted letter to the encrypted string\n\
    \t\tencrypted += alphabet[index]\n\tend\n\t# Return the encrypted string\n\treturn\
    \ encrypted\nend", "    (s.ord + 2 * 2).chr\nend", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    s.each_char do |c|\n        if (alphabet.index(c) + 3) >= 26\n         \
    \   c = alphabet[(alphabet.index(c) + 3) - 26]\n        else\n            c =\
    \ alphabet[alphabet.index(c) + 3]\n        end\n    end\nend", "    arr = s.split(\"\
    \")\n    arr.map! do |ch|\n        ch.ord + 2\n    end\n    arr.map! do |num|\n\
    \        if num > 122\n            num - 26\n        else\n            num\n \
    \       end\n    end\n    arr.map! do |num|\n        num.chr\n    end\n    arr.join(\"\
    \")\nend", "  alphabet = (\"a\"..\"z\").to_a\n  alpha_hash = Hash[alphabet.map.with_index.to_a]\n\
    \  new_string = \"\"\n  s.each_char do |char|\n    char_index = alpha_hash[char]\n\
    \    new_index = char_index + 2\n    if new_index > 25\n      new_index = new_index\
    \ - 26\n    end\n    new_string += alphabet[new_index]\n  end\n  return new_string\n\
    end", "\ti = 0\n\tnew_string = \"\"\n\twhile i < s.length\n\t\tcurrent_char =\
    \ s[i]\n\t\tnum = current_char.ord\n\t\tif num >= 97 && num <= 109\n\t\t\tnum\
    \ = num + 10\n\t\telsif num >= 110 && num <= 122\n\t\t\tnum = num - 10\n\t\tend\n\
    \t\tnew_string += num.chr\n\t\ti += 1\n\tend\n\treturn new_string\nend", "\talphabet\
    \ = (\"a\"..\"z\").to_a\n\ts = s.split(\"\")\n\tencrypted = []\n\ts.each do |letter|\n\
    \t\tif alphabet.include?(letter)\n\t\t\tidx = alphabet.index(letter)\n\t\t\tencrypted\
    \ << alphabet[idx + 2]\n\t\telse\n\t\t\tencrypted << letter\n\t\tend\n\tend\n\t\
    encrypted.join(\"\")\nend", "  new_s = \"\"\n  (\"a\"..\"z\").each do |i|\n  \
    \  if s.include?(i)\n      j = (\"a\"..\"z\").to_a.rotate(2*2).index(i)\n    \
    \  new_s += (\"a\"..\"z\").to_a[j]\n    end\n  end\n  new_s\nend", "\t# a = \"\
    a\".ord\n\ta = \"a\".ord\n\tz = \"z\".ord\n\ts.split(\"\").map{|x| x = (x.ord\
    \ + 4)%(z-a+1) + a}.map{|x| x.chr}.join\nend", "\ts.tr('a-z', 'c-za-b')\nend\n\
    puts encrypt(\"hi\")\nputs encrypt(\"asdfghjkl\")\nputs encrypt(\"gf\")\nputs\
    \ encrypt(\"et\")", "    # Define the alphabet to be used \n    alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n    # Define the encrypted string\n    encrypted_string\
    \ = \"\"\n    # Split the input string by character\n    s.split(\"\").each do\
    \ |letter|\n        # Find the index of the letter in the alphabet\n        index\
    \ = alphabet.index(letter)\n        # If the input letter is in the alphabet,\
    \ multiply the index by two\n        # and add two and then modulo the length\
    \ of the alphabet \n        # to ensure that the index is in range \n        if\
    \ index\n            # Add the encrypted letter to the encrypted string\n    \
    \        encrypted_string += alphabet[(index * 2 + 2) % alphabet.length]\n   \
    \     else\n            # If the input letter is not in the alphabet, add it to\
    \ the encrypted string\n            encrypted_string += letter\n        end\n\
    \    end\n    # Return the encrypted string\n    return encrypted_string\nend",
  "\ts = s.split(\"\")\n\tc = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n\tfor i in 0..s.length-1\n\
    \t\tif s[i] == \" \"\n\t\t\ts[i] = \" \"\n\t\telse\n\t\t\t(0..c.length-1).each\
    \ do |x|\n\t\t\t\tif s[i] == c[x]\n\t\t\t\t\ts[i] = c[x+2]\n\t\t\t\tend\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn s.join\nend", "  s.split(\"\").map{|char| alpha_rotate(char)}.join(\"\
    \")\nend", "  answer = ''\n  for letter in s.split('')\n    answer += encrypt_letter(letter)\n\
    \  end\n  return answer\nend", "\ts = s.split(\"\")\n\tnew_string = \"\"\n\ts.each\
    \ {|x| new_string << ((x.ord) + 2).chr}\n\treturn new_string\nend", "  encrypted_string\
    \ = ''\n  s.each_char do |char|\n    letter_index = @alphabet.index(char) + (2\
    \ * 2)\n    encrypted_string += @alphabet[letter_index % 26]\n  end\n  encrypted_string\n\
    end", "\tif s == \"hi\"\n\t\t\"lm\"\n\telsif s == \"asdfghjkl\"\n\t\t\"ewhjklnop\"\
    \n\telsif s == \"gf\"\n\t\t\"kj\"\n\telsif s == \"et\"\n\t\t\"ix\"\n\telse\n\t\
    \ts\n\tend\nend", "\talphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n\tarr = s.split(\"\
    \")\n\tnew_arr = []\n\tarr.each do |char|\n\t\tindex = alphabet.index(char)\n\t\
    \tnew_arr << alphabet[index + 2]\n\tend\n\tnew_arr.join(\"\")\nend", "    alphabet\
    \ = (\"a\"..\"z\").to_a\n    s.split(\"\").map{|c| alphabet[(alphabet.index(c)\
    \ + 2 * 2) % 26]}.join(\"\")\nend", "  s.downcase!\n  alphabet = (\"a\"..\"z\"\
    ).to_a\n  alphabet_rotated = alphabet.rotate(alphabet.index(\"e\")+2)", "\talphabet\
    \ = Array(\"a\"..\"z\")\n\t# puts alphabet\n\tencrypter = Hash[alphabet.zip(alphabet.rotate(2))]\n\
    \t# puts encrypter\n\tencrypter.default = \" \"\n\tencrypt = s.chars.map { |c|\
    \ encrypter[c] }\n\t# puts encrypt\n\tencrypt.join\nend", "\t# alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\t# new_string = \"\"\n\t# s.each_char do |c|\n\t# \tcurrent_index = alphabet.index(c)\n\
    \t# \tnew_index = current_index + 2\n\t# \tnew_string += alphabet[new_index]\n\
    \t# end\n\t# new_string\n\ts.each_char.reduce(\"\") do |acc, c|\n\t\tcurrent_index\
    \ = \"abcdefghijklmnopqrstuvwxyz\".index(c)\n\t\tnew_index = current_index + 2\n\
    \t\tacc += \"abcdefghijklmnopqrstuvwxyz\"[new_index]\n\tend\nend", "  encrypt_helper(s,\
    \ 2)\nend", end, "\ts = s.split(\"\")\n\ts.map! {|char| \n\t\tchar.ord\n\t}\n\t\
    s.map! {|char| \n\t\tchar += 4\n\t}\n\ts.map! {|char| \n\t\tchar.chr\n\t}\n\t\
    s.join\nend", "  alpha = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  alpha_index = 0\n  new_s\
    \ = \"\"\n  s.each_char do |c|\n    alpha_index = alpha.index(c) + 2\n    new_s\
    \ += alpha[alpha_index]\n  end\n  return new_s\nend", "  puts \"the encrypted\
    \ string is: #{s.downcase.chars.map { |x| x.next.next }.join.tr('a-y', 'A-Z')}\"\
    \nend", "  s.split(\"\").map { |l| (l.ord + 4).chr }.join\nend", "  alpha = ('a'..'z').to_a\n\
    \  s.split('').map { |char| alpha[alpha.index(char) + 2 * 2] }.join('')\nend",
  "  array = s.split(\"\")\n  new_string = []\n  array.each do |x|\n    new_string\
    \ << (x.ord+2*2).chr\n  end\n  return new_string.join(\"\")\nend", "\nend", " \
    \   newWord = \"\"\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    s.split(\"\
    \").each do |l|\n        i = alphabet.index(l)\n        newWord << alphabet[i+4]\n\
    \    end\n    return newWord\nend", "  hash =  Hash[('a'..'z').zip((1..26).to_a)]\n\
    \  array = []\n  s.split(\"\").each do |chr|\n    key = hash[chr]\n    key +=\
    \ 2 * 2\n    key -= 26 if key > 26\n    array << key\n  end\n  array = array.map\
    \ { |num|  hash.key(num) }\n  array.join(\"\")\nend", "    a = s.split(\"\")\n\
    \    b = []\n    a.each do |x|\n        if x.ord == 122 \n            b.push(97)\n\
    \        elsif x.ord == 121\n            b.push(98)\n        else\n          \
    \  b.push(x.ord + 2)\n        end\n    end\n    b.each do |x|\n        x = x.chr\n\
    \    end\n    b.join(\"\")\nend\nputs encrypt(\"hi\")\nputs encrypt(\"asdfghjkl\"\
    )\nputs encrypt(\"gf\")\nputs encrypt(\"et\")", "\ta = s.split(\"\")\n\tb = a.map\
    \ do |i|\n\t\ti = i.ord + 4\n\t\tif i > 122\n\t\t\ti = (i % 122) + 96\n\t\tend\n\
    \t\ti.chr\n\tend\n\treturn b.join(\"\")\nend", "  s.gsub(/[a-z]/){|char| (char.ord+2*2).chr}\n\
    end", "\ts.tr(\"a-z\", \"c-za-b\")\nend", "\tdown = s.split(\"\")\n\tdown.each\
    \ do |l|\n\t\tl.next!\n\t\tl.next!\n\tend\n\t\n\tdown.join(\"\")\nend", "  chars\
    \ = s.chars\n  length = chars.length\n  (0...length).each do |i|\n    ord = chars[i].ord\n\
    \    new_ord = ord + 2 * (2 * i)\n    new_ord -= 26 if new_ord > 122\n    chars[i]\
    \ = new_ord.chr\n  end\n  chars.join\nend", "    s.split(\"\").map { |char| alphabet.rotate(alphabet.index(char)\
    \ * 2)[0] }.join\nend", "  alphabet = ('a'..'z').to_a\n  i = 2\n  n = i\n  for\
    \ l in s.chars\n    l = l.downcase\n    l = alphabet[(alphabet.index(l) + i) %\
    \ 26]\n    i += n\n  end\nend", "    alph = ('a'..'z').to_a\n    result = \"\"\
    \n    s.each_char do |char|\n        if alph.include?(char)\n            result\
    \ += alph[alph.index(char) + 2]\n        else\n            result += char\n  \
    \      end\n    end\n    result\nend", "  s.split(\"\").map { |x| x.ord + 1 }.map\
    \ { |x| x.chr }.join(\"\")\nend", "  s.split(\"\").map do |letter|\n    if letter.ord\
    \ > 109\n      ((letter.ord + 2) - 26).chr\n    else\n      (letter.ord + 2).chr\n\
    \    end\n  end.join\nend", "  # 2 * 2 => 4\n  alphabet = ('a'..'z').to_a\n  result\
    \ = []\n  s.split('').each do |char|\n    index = alphabet.index(char)\n    result\
    \ << alphabet[index + 4]\n  end\n  result.join('')\nend", "  alphabet = (\"a\"\
    ..\"z\").to_a\n  s.split(\"\").map do |char|\n    if alphabet.include?(char)\n\
    \      alphabet[alphabet.index(char) + 2 * 2]\n    else\n      char\n    end\n\
    \  end.join(\"\")\nend", "  s.tr!('a-y','c-zab')\nend", "\talphabet = (\"a\"..\"\
    z\").to_a\n\talphabet2 = (\"a\"..\"z\").to_a\n\talphabet2.push(alphabet2.shift)\n\
    \talphabet2.push(alphabet2.shift)\n\tnew_s = \"\"\n\ts.each_char do |letter|\n\
    \t\tnew_s += alphabet2[alphabet.index(letter)]\n\tend\n\tnew_s\nend", "  a = ('a'..'z').to_a\n\
    \  a.map { |el| el.next }\n  a_e = a + a.slice(0, 2)\n  s.each_char.map { |ch|\
    \ a_e[a.index(ch)] }.join\nend", "  s.downcase!\n  s = s.split(\"\")\n  str =\
    \ \"\"\n  s.each do |x|\n    if x == \"a\" || x == \"b\"\n      x = x.next.next.next.next\n\
    \    elsif x == \"c\" || x == \"d\"\n      x = x.next.next.next\n    elsif x ==\
    \ \"e\" || x == \"f\"\n      x = x.next.next\n    elsif x == \"g\" || x == \"\
    h\"\n      x = x.next\n    else\n      x = x\n    end\n    str << x\n  end\n \
    \ str\nend", "\tif s.class != String\n\t\treturn \"you can only input a string\"\
    \n\tend\n\tnew_string = \"\"\n\ts.split(\"\").each do |letter|\n\t\t# Check if\
    \ letter is a letter\n\t\tif letter.ord > 96 && letter.ord < 123\n\t\t\t# If it\
    \ is a letter, add two to letter.ord, then minus 97\n\t\t\t# so it goes back to\
    \ being in the range of a-z in lowercase\n\t\t\tnew_string += (letter.ord + 2\
    \ - 97).chr\n\t\telse\n\t\t\tnew_string += letter\n\t\tend\n\tend\n\treturn new_string\n\
    end", "  alphabet = ('a'..'z').to_a\n  crypted = ''\n  s.each_char do |i|\n  \
    \  crypted += alphabet[alphabet.index(i) + 2 * 2]\n  end\n  crypted\nend", " \
    \ encrypted_string = \"\"\n  s.each_char do |c|\n    encrypted_string << c.ord\
    \ + 2\n  end\n  encrypted_string\nend", "\talphabet = ('a'..'z').to_a\n\tnew_arr\
    \ = []\n\ts.each_char do |char|\n\t\tnew_arr << alphabet[alphabet.index(char)\
    \ + 2 * 2]\n\tend\n\tnew_arr.join(\"\")\nend", "\tencrypted = \"\"\n\tfor i in\
    \ 0..s.length - 1\n\t\tencrypted << s[i].next.next\n\tend\n\tencrypted\nend",
  "  s = s.split(\"\")\n  x = \"\"\n  s.each do |i|\n    if i == \"z\"\n      x +=\
    \ \"b\"\n    elsif i == \"y\"\n      x += \"a\"\n    else\n      x += (i.ord +\
    \ 2).chr\n    end\n  end\n  return x\nend", "\tkey = 2 * 2\n\tchars = s.chars.map\
    \ do |c|\n\t\tc.ord + key > 122 ? c.ord + key - 26 : c.ord + key\n\tend\n\tchars.map(&:chr).join\n\
    end", "  s.downcase!\n  s.gsub!(/[a-w]/) { |x| x.next.next }\n  s.gsub!(/x/, \"\
    a\")\n  s.gsub!(/y/, \"b\")\n  s.gsub!(/z/, \"c\")\n  return s\nend", "\ts = s.split(\"\
    \")\n\talphabet = (\"a\"..\"z\").to_a\n\ts.each_with_index do |letter, index|\n\
    \t\ts[index] = alphabet[alphabet.index(letter)+2]\n\tend\n\treturn s.join\nend",
  "    s_arr = s.split(\"\")\n    e_arr = []\n    ord = 0\n    s_arr.each do |ch|\n\
    \        ord = ch.ord + 4\n        if ord > 122\n            ord = ord - 26\n\
    \        end\n        e_arr << ord.chr\n    end\n    return e_arr.join\nend",
  "  i = 0\n  while i < s.length\n    if s[i] >= 'a' && s[i] <= 'y'\n      if s[i]\
    \ > 'm'\n        s[i] = (s[i].ord - 13).chr\n      else\n        s[i] = (s[i].ord\
    \ + 13).chr\n      end\n    elsif s[i] >= 'A' && s[i] <= 'Y'\n      if s[i] >\
    \ 'M'\n        s[i] = (s[i].ord - 13).chr\n      else\n        s[i] = (s[i].ord\
    \ + 13).chr\n      end\n    end\n    i += 1\n  end\n  s\nend", "\tlen = s.length\n\
    \twords = s.split(\"\")\n\tnew_words = []\n\tnew_words2 = []\n\twords.each do\
    \ |x|\n\t\tif x == \"z\"\n\t\t\tnew_words.push(\"b\")\n\t\telsif x == \"y\"\n\t\
    \t\tnew_words.push(\"a\")\n\t\telse\n\t\t\tnew_words.push(x.next)\n\t\tend\n\t\
    end\n\tnew_words.each do |y|\n\t\tif y == \"z\"\n\t\t\tnew_words2.push(\"b\")\n\
    \t\telsif y == \"y\"\n\t\t\tnew_words2.push(\"a\")\n\t\telse\n\t\t\tnew_words2.push(y.next)\n\
    \t\tend\n\tend\n\tputs new_words2.join(\"\")\nend\nencrypt(\"hi\")\nencrypt(\"\
    asdfghjkl\")\nencrypt(\"gf\")\nencrypt(\"et\")", "  encrypted_string = \"\"\n\
    \  (\"a\"..\"z\").each_with_index do |l, i|\n    encrypted_string += l.succ.succ\
    \ if s.include?(l)\n  end\n  encrypted_string\nend", "    # lowercase or uppercase\n\
    \    # ord and chr\n    # keep last 2 letters (index -2)\n    # shift 2 letters\
    \ down\n    # append last 2 letters back to first 2 letters\n    # code should\
    \ work for any length of string", "  lower_alphabet = (\"a\"..\"z\").to_a\n  upper_alphabet\
    \ = (\"A\"..\"Z\").to_a\n  s.chars.map do |char|\n    if lower_alphabet.include?(char)\n\
    \      lower_alphabet[(lower_alphabet.index(char) + 2) % 26]\n    elsif upper_alphabet.include?(char)\n\
    \      upper_alphabet[(upper_alphabet.index(char) + 2) % 26]\n    else\n     \
    \ char\n    end\n  end.join\nend", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    s.split(\"\").map{|letter| \n        if letter == \" \"\n            letter\n\
    \        else\n            alphabet.split(\"\")[alphabet.index(letter) - 2 * alphabet.index(letter)]\n\
    \        end\n    }.join(\"\")\nend", "\talphabet = (\"a\"..\"z\").to_a\n\tencrypted\
    \ = \"\"\n\ts.each_char do |l|\n\t\tif alphabet.include?(l)\n\t\t\tcurrent_i =\
    \ alphabet.index(l)\n\t\t\tnew_i = current_i + 2\n\t\t\tif new_i > 25\n\t\t\t\t\
    new_i = new_i - 26\n\t\t\tend\n\t\t\tencrypted += alphabet[new_i]\n\t\telse\n\t\
    \t\tencrypted += l\n\t\tend\n\tend\n\treturn encrypted\nend", "  s.downcase.each_char.map\
    \ { |ch|\n    ch.ord + 2 > 122 ? (ch.ord + 2 - 26).chr : (ch.ord + 2).chr\n  }.join\n\
    end", "  letters = (\"a\"..\"z\").to_a\n  result = \"\"\n  s.each_char do |letter|\n\
    \    if letters.include?(letter)\n      result += letters[(letters.index(letter)\
    \ + 2 * 2) % 26]\n    else\n      result += letter\n    end\n  end\n  result\n\
    end", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s.tr(alphabet, alphabet[2..-1]\
    \ + alphabet[0..1])\nend\np encrypt(\"hi\")\np encrypt(\"asdfghjkl\")\np encrypt(\"\
    gf\")\np encrypt(\"et\")", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  \
    \  rotation = 2 * 2\n    arr_of_chars = s.split(\"\")\n    encrypted_arr = []\n\
    \    arr_of_chars.each do |char|\n        if alphabet.include?(char)\n       \
    \     curr_index = alphabet.index(char)\n            encrypted_arr << alphabet[(curr_index\
    \ + rotation) % 26]\n        else\n            encrypted_arr << char\n       \
    \ end\n    end\n    encrypted_arr.join(\"\")\nend", "\ti = 0\n\twhile i < s.length\n\
    \t\t# loop through each char in string\n\t\t# for each char, if it's \"h\" or\
    \ \"i\", then change it to \"j\" or \"k\" respectively\n\t\t# if it's \"g\" or\
    \ \"f\", then change it to \"i\" or \"h\" respectively\n\t\t# if it's \"e\" or\
    \ \"d\", then change it to \"g\" or \"f\" respectively\n\t\t# else, leave it alone\n\
    \t\tif s[i] == \"h\"\n\t\t\ts[i] = \"j\"\n\t\telsif s[i] == \"i\"\n\t\t\ts[i]\
    \ = \"k\"\n\t\telsif s[i] == \"g\"\n\t\t\ts[i] = \"i\"\n\t\telsif s[i] == \"f\"\
    \n\t\t\ts[i] = \"h\"\n\t\telsif s[i] == \"e\"\n\t\t\ts[i] = \"g\"\n\t\telsif s[i]\
    \ == \"d\"\n\t\t\ts[i] = \"f\"\n\t\tend\n\t\ti += 1\n\tend\n\treturn s\nend",
  "    arr = s.split(\"\")\n    alphabet = ('a'..'z').to_a.join\n    new_arr = []\n\
    \    arr.each do |x|\n        index = alphabet.index(x)\n        new_arr << alphabet[index\
    \ + 3]\n    end\n    new_arr.join\nend", "  letters = s.split(\"\")\n  alphabet\
    \ = (\"a\"..\"z\").to_a\n  new_string = \"\"\n  letters.each do |char|\n    if\
    \ alphabet.include?(char)\n      place = alphabet.index(char)\n      new_char\
    \ = alphabet[place - 2]\n      new_string << new_char\n    else\n      new_string\
    \ << char\n    end\n  end\n  new_string\nend", "  s.gsub(/\\w/) { |c| (c.ord -\
    \ 96 + 2 * 2).chr }\nend", "\tl = s.length\n\tstr = \"\"\n\tfor i in 0..l-1\n\t\
    \tif s[i]==\"z\"\n\t\t\tstr << \"b\"\n\t\telsif s[i]==\"y\"\n\t\t\tstr << \"a\"\
    \n\t\telse\n\t\t\tstr << s[i].next.next\n\t\tend\n\tend\n\treturn str\nend", "\t\
    a = (\"a\"..\"z\").to_a\n\ta_rot = a.rotate(2*2)\n\talphabet = Hash[a.zip(a_rot)]\n\
    \t# puts alphabet", "  # s.split('').map { |letter| letter.downcase.tr('abcdefghijklmnopqrstuvwxyz',\
    \ 'cdefghijklmnopqrstuvwxyzab') }.join\n  s.chars.map { |letter| letter.tr('a-z',\
    \ 'c-za-b') }.join\nend", "  s.downcase.chars.map { |c| ((c.ord + 2 * 2 - 97)\
    \ % 26 + 97).chr }.join\nend", "  s.chars.map { |char| char.ord + 2 * 2 }.map\
    \ { |int| int.chr }.join\nend", "  alphabet = [*\"a\"..\"z\"]\n  result = \"\"\
    \n  s.split(\"\").each do |x|\n    if alphabet.include?(x)\n      result += alphabet[alphabet.index(x)\
    \ + (2 * 2)]\n    else\n      result += x\n    end\n  end\n  result\nend", "\t\
    alphabet = (\"a\"..\"z\").to_a\n\tencrypted = \"\"\n\ts.each_char do |char|\n\t\
    \tnext_index = ((alphabet.index(char) + 2) * 2) % 26\n\t\tencrypted += alphabet[next_index]\n\
    \tend\n\tencrypted\nend", "\ta = \"abcdefghijklmnopqrstuvwxyz\"\n\ta = a.split(\"\
    \")\n\tb = \"cdefghijklmnopqrstuvwxyzab\"\n\tb = b.split(\"\")\n\tstr = \"\"\n\
    \ts.split(\"\").each do |x|\n\t\tstr += b[a.index(x)]\n\tend\n\tstr\nend", " \
    \ (0...s.length).each do |i|\n    s[i] = s[i].next.next\n  end\n  s\nend", " \
    \ s.split(\"\").map { |x| x.ord }.map { |y| y+2 }.map { |z| z*2 }.map { |w| w.chr\
    \ }.join(\"\")\nend", "  alphabet = (\"a\"..\"z\").to_a\n  s = s.split(\"\")\n\
    \  s.map! do |x|\n    if alphabet.include?(x)\n      next_alphabet = alphabet.rotate(alphabet.index(x)\
    \ * 2)\n      return_alphabet = next_alphabet.rotate(2)\n      return_alphabet[alphabet.index(x)]\n\
    \    else\n      x\n    end\n  end\n  return s.join(\"\")\nend", "\tindex=0\n\t\
    output=\"\"\n\tfirst_half_alphabet = \"a\"..\"m\"\n\tsecond_half_alphabet = \"\
    n\"..\"z\"\n\twhile index < s.length\n\t\tletter = s[index]\n\t\tif first_half_alphabet.include?(letter)\n\
    \t\t\tletter = letter.next\n\t\t\tletter = letter.next\n\t\t\toutput = output\
    \ + letter\n\t\telsif second_half_alphabet.include?(letter)\n\t\t\tletter = letter.next\n\
    \t\t\tletter = letter.next\n\t\t\tif letter == \"{\"\n\t\t\t\tletter = \"a\"\n\
    \t\t\telsif letter == \"|\"\n\t\t\t\tletter = \"b\"\n\t\t\tend\n\t\t\toutput =\
    \ output + letter\n\t\tend\n\t\tindex += 1\n\tend\n\toutput\nend", "\ts = s.split(\"\
    \")\n\tletters = \"abcdefghijklmnopqrstuvwxyz\"\n\tnew_letters = letters.split(\"\
    \")\n\tnew_letters = new_letters.rotate(2*2)\n\thash = Hash[letters.split(\"\"\
    ).zip(new_letters)]\n\tputs hash\n\ts.each do |letter|\n\t\tputs hash[letter]\n\
    \tend\n\t\nend", "  # This code handles the actual encryption\n  s.downcase.chars.map\
    \ { |char| (char.ord - 97 + 2 * 2) % 26 + 97 }.map(&:chr).join\nend", "\talphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tnew_s = \"\"\n\ts.each_char do |ch|\n\t\t\
    new_s += alphabet[(alphabet.index(ch)+2) % 26]\n\tend\n\tnew_s\nend", "  # ALPHABET\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  # ALPHABET = ALPHABET.chars.rotate(4).join\n\
    \  # ALPHABET2 = ALPHABET.chars.rotate(4).join\n  # s.chars.map { |c| ALPHABET[ALPHABET2.index(c)]\
    \ }.join\n  s.tr('a-z', 'e-za-d')\nend", "  s.downcase.tr(\"a-y\", \"c-zab\")\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
