name: HumanEval_153_Strongest_Extension
language: rb
prompt: "# You will be given the name of a class (a string) and an array of extensions.\n\
  # The extensions are to be used to load additional classes to the class. The\n#\
  \ strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  # letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n# in the extension's name, the strength is given by the fraction CAP - SM. \n\
  # You should find the strongest extension and return a string in this \n# format:\
  \ ClassName.StrongestExtensionName.\n# If there are two or more extensions with\
  \ the same strength, you should\n# choose the one that comes first in the array.\n\
  # For example, if you are given \"Slices\" as the class and an array of the\n# extensions:\
  \ ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n# return 'Slices.SErviNGSliCes'\
  \ since 'SErviNGSliCes' is the strongest extension \n# (its strength is -1).\n#\
  \ Example:\n# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"\
  ])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n\
  \    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\"\
  , candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"\
  Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\"\
  , \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\"\
  , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n\
  \    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
  , \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"\
  Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\"\
  , candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
  , \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\"\
  , [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"\
  _\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\"\
  , [\"671235\", \"Bb\"]))\n  end\nend\n"
completions: ["  if extensions.length == 0\n    return class_name\n  end\n  strengths\
    \ = []\n  extensions.each do |extension|\n    strengths << extension.count(\"\
    A-Z\") - extension.count(\"a-z\")\n  end\n  strongest_index = strengths.index(strengths.max)\n\
    \  class_name + \".\" + extensions[strongest_index]\nend", "  strongest_extension\
    \ = extensions.sort_by do |element|\n    capital_count = element.count('A-Z')\n\
    \    small_count = element.count('a-z')\n    strength = capital_count - small_count\n\
    \    strength\n  end", "  extensions.sort! { |x, y| strength(x) <=> strength(y)\
    \ }\n  \"#{class_name}.#{extensions.last}\"\nend", "\tstrongest_extension = extensions.sort_by\
    \ { |extension| extension.count(\"A-Z\") - extension.count(\"a-z\") }.last\n\t\
    puts \"#{class_name}.#{strongest_extension}\"\nend", "    strongest_extension\
    \ = ''\n    extension_strength = 0\n    extensions.each do |e|\n        s = e.chars.select\
    \ { |i| /[A-Z]/.match(i) }.count - e.chars.select { |i| /[a-z]/.match(i) }.count\n\
    \        if s > extension_strength\n            extension_strength = s\n     \
    \       strongest_extension = e\n        end\n    end\n    return \"#{class_name}.#{strongest_extension}\"\
    \nend", "  #create strength hash\n  strength_hash = {}\n  #iterate over extensions\
    \ and assign strength to each extension\n  extensions.each do |extension|\n  \
    \  caps = extension.count(\"A-Z\")\n    lowers = extension.count(\"a-z\")\n  \
    \  strength_hash[extension] = caps - lowers\n  end\n  #find max strength\n  max_strength\
    \ = strength_hash.values.max\n  #select strongest extension(s)\n  strongest_extensions\
    \ = strength_hash.select {|k,v| v == max_strength}\n  #check for duplicates\n\
    \  if strongest_extensions.count == 1\n    \"#{class_name}.#{strongest_extensions.keys[0]}\"\
    \n  else\n    #find smallest index\n    smallest_index = extensions.each_with_index.map\
    \ {|extension, index| extension if strongest_extensions.keys.include?(extension)\
    \ }.compact.min_by {|element| extensions.index(element)}\n    \"#{class_name}.#{smallest_index}\"\
    \n  end\nend", "  extension_strength = {}\n  extensions.each do |extension|\n\
    \    extension_strength[extension] = extension.count(\"A-Z\") - extension.count(\"\
    a-z\")\n  end\n  \"#{class_name}.#{extension_strength.max_by{|k,v| v}[0]}\"\n\
    end", "  is_class = class_name.match(/\\A[A-Z][a-z]+\\z/) ? true : false\n  is_extension\
    \ = extensions.all? { |str| str.match(/\\A[A-Z][a-z]+\\z/) ? true : false }\n\
    \  output = \"\"\n  return output if !is_class || !is_extension\n  strongest_ext\
    \ = extensions.inject { |memo, str| \n    memo_cap = memo.count(\"A-Z\")\n   \
    \ memo_sm = memo.count(\"a-z\")\n    str_cap = str.count(\"A-Z\")\n    str_sm\
    \ = str.count(\"a-z\")\n    memo_diff = memo_cap - memo_sm\n    str_diff = str_cap\
    \ - str_sm\n    memo_diff > str_diff ? memo : str\n  }\n  output = \"#{class_name}.#{strongest_ext}\"\
    \n  output\nend", "  class_name + '.' + extensions.max_by { |e| [extensions.count(e),\
    \ extensions.index(e)] }\nend", "  arr = extensions.map { |ext| ext.split(//)\
    \ }\n  arr = arr.map { |e| [e.count { |x| x.match(/[A-Z]/) }, e.count { |x| x.match(/[a-z]/)\
    \ }] }\n  ext = arr.each_with_index.max_by { |e, i| e[0] - e[1] }\n  return class_name\
    \ + \".\" + extensions[ext[1]]\nend", "    # Write your code here\n    # To print\
    \ results to the standard output you can use puts\n    # Example puts \"Hello\
    \ world!\"\n    \n    puts(Strongest_Extension.call(\"Slices\", [\"SErviNGSliCes\"\
    , \"Cheese\", \"StuFfed\"]))\n    #puts(Strongest_Extension.call(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]))\nend", "  strength_hash = {}\n  strongest_extension\
    \ = ''\n  strength = 0\n  extensions.each do |extension|\n    strength_hash[extension]\
    \ = extension.count('A-Z') - extension.count('a-z')\n    if strength_hash[extension]\
    \ > strength\n      strength = strength_hash[extension]\n      strongest_extension\
    \ = extension\n    end\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend",
  "  scores = []\n  extensions.each do |extension|\n    scores << [extension, score(extension)]\n\
    \  end\n  scores.sort! { |score_1, score_2| score_2[1] <=> score_1[1] }\n  scores.reject!\
    \ { |score| score[1] < scores[0][1] }\n  scores.sort! { |score_1, score_2| score_1[0]\
    \ <=> score_2[0] }\n  scores.map! { |score| score[0] }\n  \"#{class_name}.#{scores[0]}\"\
    \nend", "  # your code here\nend", "\tstrongest_extension = ''\n\tcurrent_strongest_extension_strength\
    \ = 0\n\textensions.each { |extension|\n\t\textension_strength = 0\n\t\textension.each_char\
    \ { |character| \n\t\t\tif character =~ /[A-Z]/\n\t\t\t\textension_strength +=\
    \ 1\n\t\t\telse\n\t\t\t\textension_strength -= 1\n\t\t\tend\n\t\t}\n\t\tif extension_strength\
    \ > current_strongest_extension_strength\n\t\t\tcurrent_strongest_extension_strength\
    \ = extension_strength\n\t\t\tstrongest_extension = extension\n\t\tend\n\t}\n\t\
    return class_name + '.' + strongest_extension\nend", "  # Your code goes here\n\
    end", "  strength_idx = {}\n  extensions.each_with_index do |ext, i|\n    strength_idx[i]\
    \ = ext.count(\"A-Z\") - ext.count(\"a-z\")\n  end\n  strongest_idx = strength_idx.max_by{|k,v|\
    \ v}[0]\n  \"#{class_name}.#{extensions[strongest_idx]}\"\nend", "  strongest_extension\
    \ = \"\"\n  strength = 0\n  if extensions.length > 0\n    extensions.each do |extension|\n\
    \      cap = extension.count(\"A-Z\")\n      sm = extension.count(\"a-z\")\n \
    \     if cap - sm > strength\n        strength = cap - sm\n        strongest_extension\
    \ = extension\n      end\n    end\n  end\n  class_name + \".\" + strongest_extension\n\
    end", "  strongest_extension = \"\"\n  strongest_extension_strength = 0", "  strongest_extension\
    \ = \"\"\n  strongest_extension_strength = 0\n  extensions.each do |extension|\n\
    \    extension_strength = (extension.length - extension.upcase.length) - extension.length\
    \ + extension.upcase.length\n    if extension_strength > strongest_extension_strength\n\
    \      strongest_extension_strength = extension_strength\n      strongest_extension\
    \ = extension\n    end\n  end\n  return \"#{class_name}.#{strongest_extension}\"\
    \nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
