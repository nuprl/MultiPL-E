name: HumanEval_163_generate_integers
language: rb
prompt: "# Given two positive integers a and b, return the even digits between a\n\
  # and b, in ascending order.\n# For example:\n# >>> generate_integers.call(2, 8)\n\
  # [2, 4, 6, 8]\n# >>> generate_integers.call(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(10,\
  \ 14)\n# []\ndef generate_integers(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n\
  \    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2,\
  \ 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2,\
  \ 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n\
  \  end\nend\n"
completions: ["  (a..b).select(&:even?)\nend", "  (a..b).select { |v| v.even? }\n\
    end", "  if a > b\n    a, b = b, a\n  end\n  (a..b).select { |i| i.even? }\nend",
  "  (a..b).select { |x| x % 2 == 0 }\nend", "  result = []\n  while a <= b\n    if\
    \ a.even?\n      result << a\n    end\n    a += 1\n  end\n  result\nend", "  a,\
    \ b = [a, b].sort\n  (a..b).select(&:even?)\nend", "  (a..b).select(&:even?)\n\
    end", "  output = []\n  a.upto(b) do |i|\n    output << i if i.even?\n  end\n\
    \  output\nend", "  # :reek:UtilityFunction\n  (a..b).select(&:even?)\nend", " \
    \ (a..b).select { |n| n.even? }\nend", "  range = a > b ? (b..a) : (a..b)\n  range.to_a.select(&:even?)\n\
    end", "  a, b = [a, b].sort\n  (a..b).select(&:even?)\nend", "  results = []\n\
    \  a.upto(b) do |num|\n    results << num if num.even?\n  end\n  results\nend",
  "  # <YOUR CODE GOES HERE>\nend", "  # TODO: return a list of even integer in range\
    \ [a, b]\n  # Hint: ruby's `Range` class may help:\n  # http://ruby-doc.org/core-2.2.0/Range.html\n\
    \  (a..b).select(&:even?)\nend", "  range = a..b\n  range.select { |number| number.even?\
    \ }\nend", "  # Your code here\nend", "  (a..b).select(&:even?)\nend", "  (a..b).select(&:even?)\n\
    end", "  even_arr = (a..b).select { |num| num.even? }\n  if a > b\n    return\
    \ even_arr.reverse\n  else\n    return even_arr\n  end\nend", "  (a..b).select\
    \ { |number| number.even? }\nend", "  # your code here\nend", "  (a..b).step(2).to_a\n\
    end", "  (a..b).select { |n| n.even? }\nend", "  even_digits = []\n  (a..b).each\
    \ do |i|\n    even_digits << i if i.even?\n  end\n  even_digits\nend", "  if a\
    \ == b\n    [a]\n  elsif a > b\n    Array(b..a).select{|n| n.even?}\n  else\n\
    \    Array(a..b).select{|n| n.even?}\n  end\nend", "  (a..b).step(2).to_a\nend",
  "  if a > b\n    c = a\n    a = b\n    b = c\n  end\n  if a % 2 == 0\n    (a..b).select\
    \ { |i| i.even? }\n  else\n    (a..b).select { |i| i.even? }[1..-1]\n  end\nend",
  "  begin\n    numbers = (a..b).to_a\n    even_numbers = numbers.select do |x|\n\
    \      x.even?\n    end\n    even_numbers\n  rescue\n    puts \"That's not a number.\
    \ Please try again.\"\n  end\nend", "  [*a..b].select { |n| n.even? }\nend", " \
    \ (a..b).select(&:even?)\nend", "  a, b = b, a if a > b\n  (a..b).select { |num|\
    \ num.even? }\nend", "  (a..b).select { |i| i.even? }\nend", "  (a..b).select\
    \ { |n| n.even? }\nend", "  arr = []\n  if a > b\n    a, b = b, a\n  end\n  (a..b).each\
    \ do |num|\n    arr << num if num.even?\n  end\n  arr\nend", "  (a..b).select\
    \ { |n| n.even? }\nend", "  output = []\n  b < a ? (a..b).each { |i| i.even? ?\
    \ output << i : nil } : (b..a).each { |i| i.even? ? output << i : nil }\n  output\n\
    end", "  (a..b).select(&:even?)\nend", "  [a, b].min.upto([a, b].max).select {\
    \ |x| x.even? }\nend", "  return [] if b < a\n  (a..b).select { |num| num.even?\
    \ }\nend", "  even_digits = []\n  (a..b).each do |num|\n    if num % 2 == 0\n\
    \      even_digits << num\n    end\n  end\n  even_digits\nend", "  a, b = b, a\
    \ if a > b\n  all_evens = (a..b).select(&:even?)\n  all_evens\nend", "  b >= a\
    \ ? (a..b).to_a.select(&:even?) : (b..a).to_a.select(&:even?)\nend", "  (a..b).select(&:even?)\n\
    end", "  ary = []\n  (a..b).each do |num|\n    ary << num if num.even?\n  end\n\
    \  ary\nend", "  (a..b).to_a.select { |x| x % 2 == 0 }\nend", "  (a..b).select\
    \ { |i| i.even? }\nend", "  range = (a..b).to_a\n  range.select { |num| num.even?\
    \ }\nend", "  (a..b).select { |i| i.even? }\nend", "  arr = []\n  if a == b\n\
    \    arr << a if a.even?\n  elsif a < b\n    while a <= b\n      arr << a if a.even?\n\
    \      a += 1\n    end\n  else\n    while a >= b\n      arr << a if a.even?\n\
    \      a -= 1\n    end\n  end\n  arr\nend", "  puts \"Losing\"\nend", '  return
    [] if a % 2 != 0 || b % 2 != 0', "  # TODO: return even digits between a and b\n\
    end", "  (a..b).select(&:even?)\nend", "  even_digits = []\n  (a..b).each do |n|\n\
    \    even_digits << n if n.even?\n  end\n  even_digits\nend", "  # your code here\n\
    end", "  return [] if a > b\n  (a..b).step(2).to_a\nend", "  # your code here\n\
    end", "  # TODO: Your code here\nend", "  (a..b).select { |n| n.even? }\nend",
  "  return [] if a > b\n  (a..b).select { |num| num.even? }\nend", "  (a..b).select\
    \ { |num| num.even? }\nend", "  (a..b).select { |n| n.even? }\nend", "  # write\
    \ your code here\nend", "  (a..b).select { |x| x.even? }\nend", "  (a..b).map(&:to_s).select\
    \ { |n| n.to_i.even? }.map(&:to_i)\nend", "  (a..b).select(&:even?)\nend", " \
    \ return [] if a.odd? && b.odd?\n  range = (a..b).to_a\n  range.select { |integer|\
    \ integer.even? }\nend", "  (a..b).to_a.select { |i| i.even? }\nend", "  nums\
    \ = []\n  a.upto(b) do |num|\n    nums << num if num.even?\n  end\n  nums\nend",
  "  # your code here\nend\n```", "  arr = (a..b).to_a\n  arr.delete_if { |num| num.odd?\
    \ }\nend", "  (a..b).select(&:even?)\nend", "  # The range of numbers to search.\n\
    \  range = (a..b).to_a", "  smallest = [a, b].min\n  biggest = [a, b].max\n  even_numbers\
    \ = []\n  (smallest..biggest).each do |n|\n    if n.even?\n      even_numbers\
    \ << n\n    end\n  end\n  even_numbers\nend", "  # TODO: implement\nend", "  numbers\
    \ = []\n  a < b ? numbers = [*a..b] : numbers = [*b..a]\n  if a % 2 == 0\n   \
    \ numbers.delete_if { |x| x % 2 != 0 }\n  else\n    numbers.delete_if { |x| x\
    \ % 2 == 0 }\n  end\nend", "  (a..b).step(2).to_a\nend", "  (a..b).select(&:even?)\n\
    end", "  result = []\n  (a..b).each do |num|\n    result << num if num.even?\n\
    \  end\n  result\nend", "  (a..b).select(&:even?)\nend", "  (a..b).select { |i|\
    \ i.even? }\nend", "  (a..b).select(&:even?)\nend", "  (a..b).select { |v| v.even?\
    \ }\nend", "  a, b = b, a if a > b\n  (a..b).step(2).to_a\nend", "  # your code\
    \ here\nend", '  return [] if a > b', "  a, b = b, a if a > b\n  a.upto(b).select(&:even?)\n\
    end", "  max, min = [a, b].max, [a, b].min\n  result = []\n  (min..max).each do\
    \ |i|\n    result << i if i.even?\n  end\n  result\nend", "  # your code here\n\
    end", "  arr = []\n  a.upto(b) do |x|\n    if x % 2 == 0\n      arr << x\n   \
    \ end\n  end\n  arr\nend", "  even_digits = []\n  # sorted_number = [a, b].sort\n\
    \  if a > b\n    a, b = b, a\n  end\n  a.upto(b) do |i|\n    even_digits << i\
    \ if i.even?\n  end\n  even_digits\nend", "  a, b = [a, b].sort\n  (a..b).select(&:even?)\n\
    end", "  return [] if a > b\n  (a..b).select(&:even?)\nend", "  even_numbers =\
    \ []\n  (a..b).each do |number|\n    even_numbers << number if number.even?\n\
    \  end\n  even_numbers\nend", "  (a..b).select(&:even?)\nend", "  a, b = b, a\
    \ if a > b\n  (a..b).select(&:even?)\nend", "  (a..b).select(&:even?)\nend", " \
    \ range = a..b\n  range.to_a.select { |element| element.even? }\nend", "  if a\
    \ < b\n    new_nums = a.upto(b).select { |i| i.even? }\n  else\n    new_nums =\
    \ b.upto(a).select { |i| i.even? }\n  end\n  new_nums\nend", "  evens = []\n \
    \ min = [a, b].min\n  max = [a, b].max\n  (min..max).each do |num|\n    evens\
    \ << num if num.even?\n  end\n  evens\nend", "  a, b = [a, b].sort\n  evens =\
    \ (a..b).to_a.select{|i| i.even?}\n  evens.length > 0 ? evens : []\nend", "  min,\
    \ max = [a, b].sort\n  (min..max).select(&:even?)\nend", "  (a..b).select(&:even?)\n\
    end", "  (a..b).select { |n| n.even? }\nend", "  (a..b).select(&:even?)\nend",
  "  if a <= b\n    (a..b).select(&:even?)\n  else\n    (b..a).select(&:even?)\n \
    \ end\nend", "  min, max = [a, b].minmax\n  (min..max).select(&:even?)\nend",
  "  (a..b).to_a.select { |num| num.even? }\nend", "  # code goes here\nend", "  unless\
    \ a == b\n    a < b ? (a..b).to_a.select(&:even?) : (b..a).to_a.select(&:even?)\n\
    \  end\nend", "  # write code here\nend", "  (a..b).select(&:even?)\nend", " \
    \ (a..b).select(&:even?)\nend", "  array = []\n  (a..b).each do |i|\n    if i\
    \ % 2 == 0\n      array << i\n    end\n  end\n  return array\nend", "  if a >\
    \ b\n    [a, b] = [b, a]\n  end\n  (a..b).select(&:even?)\nend", "  [*a..b].map\
    \ { |num| num if num.even? }.compact\nend", "  start, stop = [a, b].sort\n  (start..stop).select(&:even?)\n\
    end", "  Enumerator.new do |yielder|\n    if a < b\n      (a..b).each do |num|\n\
    \        yielder << num if num.even?\n      end\n    else\n      (b..a).each do\
    \ |num|\n        yielder << num if num.even?\n      end\n    end\n  end\nend",
  "    even_array = []\n    (a..b).each do |x|\n        if x.even?\n            even_array\
    \ << x\n        end\n    end\n    return even_array\nend", "  (a..b).select {\
    \ |i| i.even? }\nend", "  # TODO: implement me\nend", "  numbers = (a..b).to_a\n\
    \  return numbers.select { |n| n.even? }\nend", "  # TODO\nend", "  (a..b).to_a.select(&:even?)\n\
    end", "  (a..b).select { |x| x.even? }\nend", "  array = []\n  (a..b).each do\
    \ |n|\n    if n.even?\n      array << n\n    end\n  end\n  array\nend", "  (a..b).select\
    \ { |x| x.even? }\nend", "  result = []\n  range = a > b ? (b..a) : (a..b)\n \
    \ range.each do |num|\n    if num.even?\n      result << num\n    end\n  end\n\
    \  result\nend", "  # TODO: implement the method\nend", "  if a <= b\n    (a..b).map\
    \ { |n| n if n.even? }.compact\n  else\n    (b..a).map { |n| n if n.even? }.compact\n\
    \  end\nend", "    low = a\n    high = b\n    if a > b\n        low = b\n    \
    \    high = a\n    end\n    evens = []\n    while low <= high\n        if low\
    \ % 2 == 0\n            evens << low\n        end\n        low += 1\n    end\n\
    \    evens\nend", "  # your code here\nend", "  a_arr = a.to_s.split('')\n  b_arr\
    \ = b.to_s.split('')\n  if a_arr.length < b_arr.length\n    a_arr = a_arr.join.rjust(b_arr.length,\
    \ '0').split('')\n  end\n  if a_arr.length > b_arr.length\n    b_arr = b_arr.join.rjust(a_arr.length,\
    \ '0').split('')\n  end\n  temp = a_arr\n  result = []\n  b_arr.length.times do\
    \ |i|\n    result << temp.join.to_i if temp.join.to_i <= b.to_i && (temp.join.to_i).even?\n\
    \    temp[i] = a_arr[i].next\n  end\n  result.sort\nend", "  (a..b).select { |num|\
    \ num.even? }\nend", "  (a..b).select(&:even?)\nend", "  (a..b).to_a.select{|n|\
    \ n.even? }\nend", "  # TODO: implement me\nend", "  [].tap do |numbers|\n   \
    \ start = a > b ? b : a\n    stop = a > b ? a : b\n    (start..stop).each do |number|\n\
    \      numbers << number if number.even?\n    end\n  end\nend", "  range = (a..b).to_a.select\
    \ { |n| n.even? }\n  range.length > 0 ? range : 'No even digits'\nend", "  (a..b).select(&:even?)\n\
    end", "  list = []\n  if a < b\n    (a..b).each do |n|\n      list << n if n.even?\n\
    \    end\n  else\n    (b..a).each do |n|\n      list << n if n.even?\n    end\n\
    \  end\n  list\nend", "  (a..b).to_a.select(&:even?)\nend", "  (a..b).map { |num|\
    \ num if num.even? }.compact\nend", "  (a..b).select(&:even?)\nend", "  # TODO:\
    \ implement this method\nend", "  if a <= b\n    (a..b).select(&:even?)\n  else\n\
    \    (b..a).select(&:even?)\n  end\nend", "  (a..b).map { |i| i if i.even? }.compact\n\
    end", "  (a..b).select { |num| num.even? }\nend", "  (a..b).select(&:even?)\n\
    end", "  a.upto(b).select(&:even?)\nend", "  (a..b).select(&:even?)\nend", " \
    \ (a..b).select { |num| num.even? }\nend", "  (a..b).to_a.select { |n| n.even?\
    \ }\nend", "  # TODO: your code here\nend", "  if a.even?\n    min = a\n  else\n\
    \    min = a + 1\n  end\n  if b.even?\n    max = b\n  else\n    max = b - 1\n\
    \  end\n  (min..max).step(2).to_a\nend", "  (a..b).select { |n| n.even? }\nend",
  "  nums = []\n  until a > b\n    nums << a if a.even?\n    a += 1\n  end\n  nums\n\
    end", "  range = (a..b).to_a\n  range.delete_if { |n| n.odd? }\nend", "  if b\
    \ < a\n    return generate_integers(b, a)\n  end\n  (a..b).select(&:even?)\nend",
  "  return [] if b < a\n  (a..b).select { |x| x.even? }\nend", "  if a > b\n    start\
    \ = b\n    finish = a\n  else\n    start = a\n    finish = b\n  end\n  array =\
    \ []\n  start.upto(finish) do |num|\n    array << num if num.even?\n  end\n  array\n\
    end", "  if b > a\n    (a..b).select { |x| x.even? }\n  else\n    (b..a).select\
    \ { |x| x.even? }\n  end\nend", "  raise \"Write code here to pass tests\"\nend",
  "  (a..b).select { |num| num.even? }\nend", "  (a..b).select(&:even?)\nend", " \
    \ (a..b).select { |n| n.even? }\nend", "  (a..b).select { |i| i.even? }\nend",
  "  ary = []\n  a.upto(b) do |i|\n    if i.even?\n      ary << i\n    end\n  end\n\
    \  ary\nend", "  integers = []\n  (a..b).each do |num|\n    if num.even?\n   \
    \   integers << num\n    end\n  end\n  integers\nend", "  # TODO: Implement this\
    \ method\nend", "  (a..b).select { |num| num.even? }\nend", "  (a..b).select {\
    \ |num| num.even? }\nend", "  # 1. Get the all even numbers between a and b.\n\
    \  # 2. Sort the numbers.\n  all_numbers = (a..b).to_a\n  even_numbers = all_numbers.select\
    \ { |num| num.even? }\n  even_numbers.sort\nend", "  evens = []\n  [a, b].min.upto([a,\
    \ b].max) do |n|\n    evens << n if n.even?\n  end\n  evens\nend", "  if a < b\n\
    \    (a..b).find_all { |n| n.even? }\n  else\n    (b..a).find_all { |n| n.even?\
    \ }\n  end\nend", "  (a..b).select(&:even?)\nend", "  a.upto(b).select(&:even?)\n\
    end", "  (a..b).select(&:even?)\nend", "  if a <= b\n    a.upto(b).select { |num|\
    \ num.even? }\n  else\n    b.upto(a).select { |num| num.even? }\n  end\nend",
  "  (a..b).select { |num| num.even? }\nend", "  (a..b).select(&:even?)\nend", " \
    \ (a..b).select(&:even?)\nend", "  (a..b).select(&:even?)\nend", "  (a..b).map(&:even?).select\
    \ { |element| element == true }\nend", "  (a..b).select(&:even?)\nend", "  (a..b).select(&:even?)\n\
    end", '  retur', "  even_digits = []\n  (a..b).each do |num|\n    num_digits =\
    \ num.to_s.chars.map(&:to_i)\n    num_digits.each do |digit|\n      even_digits\
    \ << num if digit.even?\n    end\n  end\n  even_digits.uniq.sort\nend", "  # Insert\
    \ your code here\nend", "  (a..b).step(2).to_a\nend", "  a.step(b, 2).to_a\nend",
  "  (a..b).select { |n| n.even? }\nend", "  (a..b).select { |x| x.even? }\nend",
  "  (a..b).select { |i| i.even? }\nend", "  (a..b).select { |num| num.even? }\nend",
  "  (a..b).select { |e| e.even? }\nend", "  (a..b).to_a.select(&:even?)\nend", " \
    \ even_arr = []\n  if a > b\n    i = b\n    while i <= a\n      even_arr << i\
    \ if i.even?\n      i += 1\n    end\n  else\n    i = a\n    while i <= b\n   \
    \   even_arr << i if i.even?\n      i += 1\n    end\n  end\n  even_arr\nend",
  "  return [] if a > b\n  (a..b).select { |number| number.even? }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
