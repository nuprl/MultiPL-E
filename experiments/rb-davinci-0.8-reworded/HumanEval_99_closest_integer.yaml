name: HumanEval_99_closest_integer
language: rb
prompt: "# Create a function that takes a value (string) representing a number\n#\
  \ and returns the closest integer to it. If the number is equidistant\n# from two\
  \ integers, round it away from zero.\n# Examples\n# >>> closest_integer.call(\"\
  10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away\
  \ from zero means that if the given number is equidistant\n# from two integers,\
  \ the one you should return is the one that is the\n# farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should\
  \ return -15.\ndef closest_integer(value)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
  \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
  10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
  -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"\
  0\"))\n  end\nend\n"
completions: ["  value.to_f.round\nend", "  close_int = value.to_i\n  if close_int\
    \ < value.to_f\n    close_int += 1\n  end\n  close_int\nend", "  if value.nil?\n\
    \    nil\n  else\n    round = (value.to_f / 1).round\n    if round > value.to_f\n\
    \      round -= 1\n    else\n      round\n    end\n  end\nend", "  value = value.to_f.round\n\
    \  puts value\nend", "  return value.to_i if value.to_i == value.to_f\n  value.to_f\
    \ > value.to_i ? value.to_i + 1 : value.to_i\nend", "  value = value.to_f.round\n\
    \  if value >= 0\n    value\n  else\n    value - 1\n  end\nend", "  value.to_f.round\n\
    end", "  value = value.to_f\n  if value > 0\n    return (value + 0.5).to_i\n \
    \ else\n    return (value - 0.5).to_i\n  end\nend", "  (value.to_f + 0.5).floor\n\
    end", "  value = value.to_f\n  (value - value.to_i).abs < 0.5 ? value.to_i : value.to_i\
    \ + 1\nend", "  if value == value.to_i.to_s\n    value.to_i\n  else\n    if value.to_f\
    \ - value.to_i >= 0.5\n      value.to_i + 1\n    else\n      value.to_i\n    end\n\
    \  end\nend", "  value = value.to_f\n  i = 0\n  result = 0\n  while value > i\n\
    \    result = i\n    i += 1\n  end\n  if (value - result) < 0.5\n    result\n\
    \  else\n    result += 1\n  end\nend", "  x = value.to_f\n  x = x.round\n  return\
    \ x\nend", "  value.to_f.round\nend", "  if value.include?(\".\")\n    value.to_f.round\n\
    \  else\n    value.to_i\n  end\nend", "  Float(value).round\nend", "  value.to_f.round\n\
    end", "  value.to_f.round\nend", "  value.to_f.round\nend", "  if value.include?\
    \ \".\"\n    value = value.to_f\n    if value > 0\n      value = value.ceil\n\
    \    else\n      value = value.floor\n    end\n  else\n    value = value.to_i\n\
    \  end\n  value\nend\nclosest_integer.call(\"10\")\nclosest_integer.call(\"15.3\"\
    )"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
