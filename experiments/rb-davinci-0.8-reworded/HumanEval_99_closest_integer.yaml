name: HumanEval_99_closest_integer
language: rb
prompt: "# Create a function that takes a value (string) representing a number\n#\
  \ and returns the closest integer to it. If the number is equidistant\n# from two\
  \ integers, round it away from zero.\n# Examples\n# >>> closest_integer.call(\"\
  10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away\
  \ from zero means that if the given number is equidistant\n# from two integers,\
  \ the one you should return is the one that is the\n# farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should\
  \ return -15.\ndef closest_integer(value)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
  \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
  10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
  -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"\
  0\"))\n  end\nend\n"
completions: ["  value.to_f.round\nend", "  close_int = value.to_i\n  if close_int\
    \ < value.to_f\n    close_int += 1\n  end\n  close_int\nend", "  if value.nil?\n\
    \    nil\n  else\n    round = (value.to_f / 1).round\n    if round > value.to_f\n\
    \      round -= 1\n    else\n      round\n    end\n  end\nend", "  value = value.to_f.round\n\
    \  puts value\nend", "  return value.to_i if value.to_i == value.to_f\n  value.to_f\
    \ > value.to_i ? value.to_i + 1 : value.to_i\nend", "  value = value.to_f.round\n\
    \  if value >= 0\n    value\n  else\n    value - 1\n  end\nend", "  value.to_f.round\n\
    end", "  value = value.to_f\n  if value > 0\n    return (value + 0.5).to_i\n \
    \ else\n    return (value - 0.5).to_i\n  end\nend", "  (value.to_f + 0.5).floor\n\
    end", "  value = value.to_f\n  (value - value.to_i).abs < 0.5 ? value.to_i : value.to_i\
    \ + 1\nend", "  if value == value.to_i.to_s\n    value.to_i\n  else\n    if value.to_f\
    \ - value.to_i >= 0.5\n      value.to_i + 1\n    else\n      value.to_i\n    end\n\
    \  end\nend", "  value = value.to_f\n  i = 0\n  result = 0\n  while value > i\n\
    \    result = i\n    i += 1\n  end\n  if (value - result) < 0.5\n    result\n\
    \  else\n    result += 1\n  end\nend", "  x = value.to_f\n  x = x.round\n  return\
    \ x\nend", "  value.to_f.round\nend", "  if value.include?(\".\")\n    value.to_f.round\n\
    \  else\n    value.to_i\n  end\nend", "  Float(value).round\nend", "  value.to_f.round\n\
    end", "  value.to_f.round\nend", "  value.to_f.round\nend", "  if value.include?\
    \ \".\"\n    value = value.to_f\n    if value > 0\n      value = value.ceil\n\
    \    else\n      value = value.floor\n    end\n  else\n    value = value.to_i\n\
    \  end\n  value\nend\nclosest_integer.call(\"10\")\nclosest_integer.call(\"15.3\"\
    )", "  value.to_f.round\nend", "  value.to_f.round\nend", "  result = value.to_f.round\n\
    \  result > 0 ? result.to_i : result.ceil\nend", "  value = value.to_f\n  if value\
    \ > 0\n    if value % 1 > 0.5\n      return value.to_i + 1\n    else\n      return\
    \ value.to_i\n    end\n  else\n    if value % 1 < -0.5\n      return value.to_i\
    \ - 1\n    else\n      return value.to_i\n    end\n  end\nend", "  first_number\
    \ = value.to_i\n  second_number = first_number + 1\n  given_number = value.to_f\n\
    \  if given_number - first_number > 0.5\n    second_number\n  else\n    first_number\n\
    \  end\nend", "  value.to_f.round\nend", "  value = value.to_f\n  (value % 1.0)\
    \ < 0.5 ? value.floor : value.ceil\nend", "  (value.to_f + 0.5).to_i\nend", " \
    \ return value.to_i if value.is_a?(Integer)\n  return value if value.to_i == value.to_f\n\
    \  value.to_f > value.to_i ? value.to_i + 1 : value.to_i\nend", "  # change string\
    \ to number\n  number = value.to_f", "  # convert the string to a float\n  # use\
    \ the conversion method to_i to convert to an integer\n  # round - http://ruby-doc.org/core-2.2.0/Float.html#method-i-round\n\
    \  # round by itself will round to the nearest integer\n  # add 0.5 to the value\
    \ before rounding to get the right results\n  (value.to_f + 0.5).round\nend",
  "  value = value.to_f.round\n  value\nend", "  num = value.to_f\n  num.round\nend",
  "  (value.to_f + 0.5).to_i\nend", "  case value\n  when value =~ /\\d+/\n    value.to_i\n\
    \  when value =~ /\\d*\\.\\d/\n    if value.to_f.round == value.to_f.round(1)\n\
    \      value.to_f.round\n    else\n      value.to_f.round(1)\n    end\n  end\n\
    end", "  return value.to_i if value.nil? || value.match(/\\A[+-]?\\d+?(\\.\\d+)?\\\
    Z/)[1].nil?\n  value.to_f.round\nend", "  if value.include? \".\"\n    float_value\
    \ = value.to_f\n    if float_value > 0\n      float_value.ceil\n    else\n   \
    \   float_value.floor\n    end\n  else\n    value.to_i\n  end\nend", "  value.to_f.round\n\
    end", "  value.to_f.round\nend", "  value.to_f.round\nend", "  value.to_f.round\n\
    end", "  (value.to_f + 0.5).to_i\nend", "  if value.match(/\\.[5]/) && value.include?(\"\
    -\")\n    value = value.to_i - 1\n  elsif value.match(/\\.[5]/)\n    value = value.to_i\
    \ + 1\n  else\n    value = value.to_i\n  end\nend", "  integer = value.to_i\n\
    \  [integer, integer + 1].sort_by do |i|\n    (value.to_f - i).abs\n  end.first\n\
    end", "  return value.to_i if value.to_i == value.to_f\n  value.to_f > value.to_i\
    \ ? value.to_i + 1 : value.to_i\nend", "  # Your Code Here\nend", "  value.to_f.round\n\
    end", "  closest_int = value.to_i\n  if value.to_f - closest_int == 0.5\n    if\
    \ closest_int > 0\n      closest_int + 1\n    else\n      closest_int - 1\n  \
    \  end\n  else\n    closest_int\n  end\nend", "  return value.to_i if value.include?('.')\
    \ == false\n  a = value.to_f\n  return (a - a.floor) < 0.5 ? a.floor : a.ceil\n\
    end", "  number = value.to_f.round\n  return number if value == number.to_s\n\
    \  integer = value.to_i\n  value > integer ? integer + 1 : integer\nend", "  if\
    \ value.to_i < value.to_f\n    value.to_i + 1\n  else\n    value.to_i\n  end\n\
    end", "  a = value.to_f.round\n  b = value.to_f.round(1)\n  a == b ? a : a = value.to_f.round(1)\n\
    end", "  value = value.to_f.round\n  if value > 0\n    value += 0.5\n  else\n\
    \    value -= 0.5\n  end\n  value.to_i\nend", "  number = value.to_f\n  if number\
    \ % 1 >= 0.5\n    (number + 1).to_i\n  else\n    number.to_i\n  end\nend", " \
    \ value.to_f.round\nend\nputs closest_integer('10')\nputs closest_integer('15.3')\n\
    puts closest_integer('14.5')\nputs closest_integer('-14.5')", "  if value.to_f\
    \ - value.to_i > 0.5\n    return value.to_i + 1\n  else\n    return value.to_i\n\
    \  end\nend", "  arr = value.split('.')\n  if arr.length == 1\n    return value.to_i\n\
    \  elsif arr[1].to_i >= 5\n    arr[0].to_i + 1\n  else\n    arr[0].to_i\n  end\n\
    end", "  value = value.to_f\n  value.round\nend", "  # TODO: return closest integer\
    \ to value\n  #value.gsub(\".\", \"\").to_i\n  if value.to_f == value.to_i\n \
    \   return value.to_i\n  else\n    if value.to_f < 0\n      return value.to_i\
    \ - 1\n    else\n      return value.to_i + 1\n    end\n  end\nend", "  #value\
    \ = value.to_f\n  value.to_i\nend", "  num = value.to_f.round\n  puts num\nend",
  "  value = value.to_f\n  number = value.round\n  if value > number\n    number +=\
    \ 1\n  elsif value < number\n    number -= 1\n  end\n  number\nend", "  nearest_float\
    \ = value.to_f.round\n  if nearest_float == 0 && value[0] == \"-\"\n    return\
    \ -1\n  else\n    return nearest_float\n  end\nend", "  if value.to_f % 1 >= 0.5\n\
    \    value.to_i + 1\n  else\n    value.to_i\n  end\nend", '  x = value.to_f',
  "  value.to_f.round\nend", "  int_value = value.to_i\n  return int_value if value\
    \ == int_value.to_s\n  int_value + (value[-1] == '5' ? (value[0] == '-' ? -1 :\
    \ 1) : 0)\nend", "  value = value.to_f\n  min_distance = Float::INFINITY\n  closest_int\
    \ = nil\n  (value.to_i - 10..value.to_i + 10).each do |int|\n    distance = (value\
    \ - int).abs\n    if distance < min_distance\n      min_distance = distance\n\
    \      closest_int = int\n    end\n  end\n  closest_int\nend", "  str = value.split(\"\
    .\").first.to_i\n  if value.include?(\".\") && value.split(\".\").last.to_i >=\
    \ 5\n    return str += 1\n  end\n  return str\nend", "  num = value.to_f\n  num.round\n\
    end", "  # TODO: implement the method\nend", "  (value.to_f.round).to_i\nend",
  "  # TODO: Implement the function\nend", "  #You can return a string or an integer.\n\
    \  #The value will always be a string.\n  #In this problem, I'm choosing to return\
    \ a string.\n  #First split the string by the \".\" character to remove the decimals,\n\
    \  #which will leave us with a string representation of the integer\n  #component\
    \ of the input.\n  new_value = value.split(\".\")[0]\n  #If the integer component\
    \ is less than 0, set the sign variable\n  #to \"-\" otherwise set it to \"+\"\
    .\n  sign = value.to_i < 0 ? \"-\" : \"+\"\n  #If there is a decimal component,\
    \ calculate how far away from the\n  #integer component it is.\n  if value.include?(\"\
    .\")\n    decimal_value = value.split(\".\")[1].to_f\n    #If the decimal is greater\
    \ than or equal to 0.5\n    #add 1 to the integer component, otherwise, don't\
    \ add anything.\n    if decimal_value >= 0.5\n      new_value = (new_value.to_i\
    \ + 1).to_s\n    end\n  end\n  #Combine the sign, the integer component, and the\
    \ \".\" character\n  #to form a proper number string.\n  \"#{sign}#{new_value}.\"\
    \nend", "  value.to_f.round\nend\nputs \"\\nClosest integer:\\n\" + \"*\" * 15\
    \ + \"\\n\"\nputs closest_integer(\"10\") == 10\nputs closest_integer(\"15.3\"\
    ) == 15\nputs closest_integer(\"14.5\") == 15\nputs closest_integer(\"-14.5\"\
    ) == -15", "  return value.to_i if value.to_f == value.to_i\n  return value.to_i\
    \ + 1 if value.to_f > value.to_i\n  value.to_i - 1\nend", "  # ~~~START~~~\n \
    \ value.to_i\n  # ~~~END~~~\nend", "  (value.to_f * 10).round / 10\nend", "  if\
    \ value.include?(\".\")\n    value.to_f.round\n  else\n    value.to_i\n  end\n\
    end", "  # code goes here\nend", "  value.to_f.round\nend", "  # Your code here\n\
    end", "  round_away_from_zero(value.to_f).to_i\nend", "  value.to_f.round\nend",
  "  value = value.to_f\n  if value % 1 > 0.5\n    value.ceil\n  else\n    value.floor\n\
    \  end\nend", "  # Your code here\nend", "  # (value.to_f.round).to_i\n  return\
    \ value.to_i if value.to_i == value.to_f\n  value.to_f.round\nend", "  value =\
    \ value.to_f\n  if value == value.to_i\n    value.to_i\n  elsif value < 0\n  \
    \  value = value.abs\n    if value - value.to_i > 0.5\n      (value.to_i - 1)\
    \ * -1\n    else\n      value.to_i * -1\n    end\n  else\n    if value - value.to_i\
    \ > 0.5\n      value.to_i + 1\n    else\n      value.to_i\n    end\n  end\nend",
  "  value.to_f.round\nend", "  if value.to_f % 1 == 0\n    value.to_i\n  else\n \
    \   value.to_f % 1 < 0.5 ? value.to_i : value.to_i + 1\n  end\nend", "  if value.to_i\
    \ == value.to_f\n    value.to_i\n  else\n    if value.split(\".\")[1].to_i >=\
    \ 5\n      value.to_i + 1\n    else\n      value.to_i\n    end\n  end\nend", " \
    \ num = value.to_f\n  if num < 0\n    return num.round\n  else\n    return num.round\n\
    \  end\nend", "  if value.include?(\".\")\n    value = value.to_f\n    value =\
    \ value.round\n  end\n  value = value.to_i\nend", "  ((value.to_f + 0.5).to_i).to_s\n\
    end", "  new_value = value.to_f.round\n  new_value.to_i\nend", "  num = value.to_f\n\
    \  num.ceil\nend", "  value.to_f.round\nend", "  value = value.to_f\n  value.round\n\
    end", "  num = value.to_f\n  num.round\nend", "\tnumber = value.to_f.round\n\t\
    if number == value.to_f\n\t\tnumber\n\telse\n\t\tnumber = value.to_f.ceil\n\t\
    end\nend", "  rounded_integer = value.to_f.round\n  previous_integer = rounded_integer\
    \ - 1\n  next_integer = rounded_integer + 1\n  if next_integer - value.to_f <\
    \ value.to_f - previous_integer\n    return next_integer\n  else\n    return previous_integer\n\
    \  end\nend", "  rounded_value = value.to_f.round\n  if rounded_value.to_f > value.to_f\n\
    \    rounded_value -= 1\n  end\n  rounded_value\nend", "  if value.include? \"\
    .\"\n    num_value = value.to_f\n    if num_value < 0\n      return (num_value\
    \ - 0.5).to_i\n    else\n      return (num_value + 0.5).to_i\n    end\n  else\n\
    \    return value.to_i\n  end\nend", "  value.to_f.round\nend", "  # integer_value\
    \ = value.to_i\n  # if (value - integer_value) > 0.5\n  #   integer_value += 1\n\
    \  # end\n  # integer_value\n  value.to_i\nend", "\tnum = value.to_f.round\n\t\
    \n\tif num > value.to_f\n\t\tnum -= 1\n\tend\n\treturn num\nend\nputs closest_integer(\"\
    10\")\nputs closest_integer(\"15.3\")\nputs closest_integer(\"14.5\")\nputs closest_integer(\"\
    -14.5\")\nputs closest_integer(\"-10\")", "  number = value.to_f\n  round_up =\
    \ number.ceil\n  round_down = number.floor\n  if (number - round_down) == (round_up\
    \ - number)\n    number.ceil.to_i\n  elsif (number - round_down) > (round_up -\
    \ number)\n    round_up\n  else\n    round_down\n  end\nend", "  value = value.to_f\n\
    \  if value % 1 >= 0.5\n    return value.to_i + 1\n  else\n    return value.to_i\n\
    \  end\nend", "  # :reek:FeatureEnvy\n  # :reek:TooManyStatements\n  # :reek:UtilityFunction\n\
    \  # :reek:UncommunicativeMethodName\n  # :reek:UncommunicativeVariableName\n\
    \  # :reek:UncommunicativeParameterName\n  # :reek:UncommunicativeVariableName\n\
    \  # :reek:TooManyStatements\n  # :reek:FeatureEnvy\n  value = value.to_f\n  x\
    \ = (value).abs\n  y = value - x\n  value = if value < 0\n            x.floor\n\
    \          elsif value > 0\n            x.ceil\n          else\n            value\n\
    \          end\n  value = value + y\n  value.to_i\nend", "  num = value.to_f\n\
    \  if (num.round - num).abs == 0.5\n    if num > 0\n      num.round\n    else\n\
    \      (num.round) - 1\n    end\n  else\n    num.round\n  end\nend", "  value.to_f.round\n\
    end", "  value.to_f.round\nend", "  value.to_f.round\nend", "  (value.to_f + 0.5).to_i\n\
    end", "  if value.to_f == value.to_i\n    value.to_i\n  else\n    if value.to_f\
    \ - value.to_i >= 0.5\n      value.to_i + 1\n    else\n      value.to_i\n    end\n\
    \  end\nend", "  x = value.to_f.round\n  if x > value.to_f\n    x -= 1\n  end\n\
    \  return x\nend", "  value.to_f.round\nend", "  value.to_f.round\nend", "  value\
    \ = value.to_f\n  value.round\nend", "  closest_integer = value.to_i\n  if value.include?('.')\n\
    \    closest_integer += 1 if value.split('.').last.to_i >= 5\n  end\n  closest_integer\n\
    end", "  value.to_f.round\nend", "  # Write your code here\nend", "  value.to_f.round(0)\n\
    end", "  closest_int = (value.to_f + 0.5).to_i\n  if closest_int > value.to_f\n\
    \    closest_int - 1\n  else\n    closest_int\n  end\nend", "  x = value.to_f.to_i\n\
    \  return x if x.to_f == value.to_f\n  return x + 1 if x.to_f < value.to_f\n \
    \ return x - 1 if x.to_f > value.to_f\nend", "  value.to_f.round\nend", "  value.to_f.round\n\
    end", "  return value.to_i if value == value.to_i.to_s\n  value.to_f.round\nend",
  "  # your code here\nend", "  value.to_f.round\nend", "  value.to_f.round\nend",
  "  value.to_f.round\nend", "  i = value.to_i\n  i += 1 if (value.to_f - i) >= 0.5\n\
    \  i\nend", "  value = (value.to_f * 10).round / 10.0\n  value.ceil\nend", " \
    \ # your code here\nend\n```", "\tvalue.to_f.round\nend", "  value = value.to_f\n\
    \  if value == value.floor\n    value.to_i\n  elsif value < value.floor\n    (value.to_i\
    \ - 1)\n  else\n    value.to_i + 1\n  end\nend", "  split_value = value.split(\"\
    .\")\n  if split_value.length == 1\n    return value.to_i\n  elsif split_value[1].to_i\
    \ < 5\n    return split_value[0].to_i\n  else\n    return split_value[0].to_i.next\n\
    \  end\nend", "  if value =~ /^[+-]?[0-9]+$/\n    value.to_i\n  else\n    value.to_f.round\n\
    \  end\nend", "  value.to_f.round\nend", "  value.to_f.round\nend", "  value =\
    \ value.to_f\n  value.round\nend", "  is_float = value.index('.')", "  # TODO\n\
    end", "  value.to_f.round\nend", "  ((value.to_f + 0.5).floor).to_i\nend", " \
    \ value.to_f.round\nend", "  # your code goes here\nend", "  value.to_f.round\n\
    end", "  value = value.to_f\n  if value == value.to_i\n    return value.to_i\n\
    \  elsif value - value.to_i > 0.5\n    return value.to_i + 1\n  else\n    return\
    \ value.to_i\n  end\nend", "  value.to_f.round\nend", "  (value.to_f).round\n\
    end", "  value.to_f.round\nend", "  num = value.to_f\n  return num.round if num.abs\
    \ < 1\n  return (num + 0.5).to_i if num >= 0\n  return (num - 0.5).to_i if num\
    \ < 0\nend", "  value.to_f.round\nend", "  # Convert the value to Float\n  value\
    \ = value.to_f\n  # Find the closest integer to the float\n  # and return the\
    \ integer\n  value.round\nend", "  return value.to_i\nend", "  # Your code here\n\
    end", "  a = value.to_f.round\n  if a == value.to_f\n    a\n  else\n    a + 1\n\
    \  end\nend", "  n = value.to_f\n  return n.round if n.to_i == n\n  return (n\
    \ > 0 ? n.ceil : n.floor)\nend", "  (value.to_f + 0.5).to_i\nend", "  return value.to_i\n\
    end", "  closest_num = value.to_i\n  if value.to_i < value.to_f\n    closest_num\
    \ += 1\n  end\n  closest_num\nend", "  value.to_f.round\nend", "  value = Float(value)\n\
    \  # value.round(0)\n  return value.to_i if value % 1 == 0\n  return (value +\
    \ 0.5).to_i if value % 1 < 0.5\n  return (value - 0.5).to_i if value % 1 > 0.5\n\
    end", "  num = value.to_f.round\n  return num\nend", "  value = value.to_f\n \
    \ if value >= value.floor + 0.5\n    (value.ceil)\n  else\n    (value.floor)\n\
    \  end\nend", "  # Your code here\nend", "  value.to_f.round\nend", "  value =\
    \ value.to_f\n  return value.to_i if value == value.to_i\n  value > 0 ? value.ceil\
    \ : value.floor\nend", "  number = value.to_f.to_i\n  return value if number.to_s\
    \ == value\n  value.to_f > 0 ? number + 1 : number - 1\nend", "  closest_int =\
    \ value.to_i\n  closest_int += 1 if value.to_f - closest_int > 0.5\n  closest_int\n\
    end", "  value.to_f.round\nend", "  return value.to_i if value.to_i.to_f == value.to_f\n\
    \  return (value.to_i + 1) if value.to_i.to_f > value.to_f\n  return (value.to_i\
    \ - 1) if value.to_i.to_f < value.to_f\nend", "  return value.to_i if value.to_i.to_f\
    \ == value.to_f\n  value.to_f.round > 0 ? value.to_i + 1 : value.to_i - 1\nend",
  "  value.to_f.round\nend", "  value.to_f.round\nend", "  if value.to_i == value.to_f\n\
    \    return value.to_i\n  else\n    if value.to_f > 0\n      return value.to_i\
    \ + 1\n    else\n      return value.to_i - 1\n    end\n  end\nend", "  # :reek:DuplicateMethodCall\
    \ {enabled: false}\n  n = value.to_f\n  if n.abs.round - n.abs < 0.5\n    n.round\n\
    \  else\n    n.floor\n  end\nend", "  value = value.to_f\n  if value == value.to_i\n\
    \    return value.to_i\n  elsif value < 0\n    return value.to_i - 1\n  else\n\
    \    return value.to_i + 1\n  end\nend", "  # value.to_i\n  # value.round\n  closest_integer\
    \ = if value.to_i < value\n    value.to_i + 1\n  else\n    value.to_i\n  end\n\
    end\nputs closest_integer(\"10\")\nputs closest_integer(\"15.3\")\nputs closest_integer(\"\
    14.5\")\nputs closest_integer(\"-14.5\")", "  (value.to_f + 0.5).to_i\nend", " \
    \ value = value.to_f.round\n  return value\nend", "  if value.to_i < value.to_f\n\
    \    return value.to_i\n  else\n    return value.to_i + 1\n  end\nend", "  (value.to_f\
    \ + 0.5).to_i\nend", "  closest_integer = value.to_i\n  if closest_integer > value.to_f\n\
    \    return closest_integer -= 1\n  end\n  closest_integer\nend", "    # Your\
    \ code here\nend", "  value.to_f.round\nend", "  ((value.to_f - value.to_i) >=\
    \ 0.5 ? value.to_i.next : value.to_i)\nend", "  value.to_f.round\nend", "  value\
    \ = value.to_f\n  if value % 1 == 0\n    return value.to_i\n  elsif value % 1\
    \ == 0.5\n    if value < 0\n      return value.to_i - 1\n    else\n      return\
    \ value.to_i + 1\n    end\n  else\n    return value.to_i\n  end\nend", "    value\
    \ = value.to_f.round\n    return value\nend", "  value.to_f.round\nend", "  num\
    \ = value.to_f\n  num.round\nend", "  if (value.to_f % 1) == 0\n    value.to_i\n\
    \  else\n    value.to_f.round.to_i\n  end\nend", "  value.to_f.round\nend", " \
    \ # puts value\n  # return value.to_i if value.to_i.to_s == value.to_s\n  # value.split('.')\n\
    \  # float_num = value.to_f\n  # float_num.ceil\n  # float_num.floor\n  # [float_num.ceil,\
    \ float_num.floor].min_by { |x| (x - float_num).abs }", "  value.to_f.round\n\
    end", "  value.to_f.round\nend", "  res = value.to_f.round\n  if res.even?\n \
    \   res\n  else\n    res.to_i - 1\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
