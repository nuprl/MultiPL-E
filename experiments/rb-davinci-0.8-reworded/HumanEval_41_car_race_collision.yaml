name: HumanEval_41_car_race_collision
language: rb
prompt: "# Imagine a road that's a perfectly straight infinitely long line.\n# n cars\
  \ are driving left to right;  simultaneously, a different set of n cars\n# are driving\
  \ right to left.   The two sets of cars start out being very far from\n# each other.\
  \  All cars move in the same speed.  Two cars are said to collide\n# when a car\
  \ that's moving left to right hits a car that's moving right to left.\n# However,\
  \ the cars are infinitely sturdy and strong; as a result, they continue moving\n\
  # in their trajectory as if they did not collide.\n# This function outputs the number\
  \ of such collisions.\ndef car_race_collision(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n\
  \    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n\
  \    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n\
  \    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n\
  \  end\nend\n"
completions: ["  # The number of collisions can be found using the following simple\
    \ expression\n  # Note this expression is asymptotically optimal in that it is\
    \ linear in n.\n  n * (n - 1) / 2\nend", "  collisions = 0\n  arr1 = (1..n).to_a\n\
    \  arr2 = (1..n).to_a.reverse\n  0.upto(n - 1) do |i|\n    collisions += 1 if\
    \ arr1[i] == arr2[i]\n  end\n  collisions\nend", "  # randomly position the cars\
    \ on the road\n  left = []\n  right = []\n  n.times do\n    left << rand(1000)\n\
    \    right << rand(1000)\n  end", "  # Given n cars, we can write down all possible\
    \ pairs: [(1, n), (2, n-1), ..., (n, 1)]\n  # We want to count how many (i, j)\
    \ pairs there are where i > j.\n  # This is equivalent to counting how many pairs\
    \ (i, j) there are with i < j\n  # and then dividing the result by 2.\n  # This\
    \ is the same as counting the number of pairs that are less than (n, n-1)\n  #\
    \ and then dividing the result by 2.\n  count = 0\n  (1..n-1).each do |i|\n  \
    \  (i+1..n).each do |j|\n      count += 1\n    end\n  end\n  count/2\nend", " \
    \ collisions = 0\n  c = 0\n  for i in 0..n\n    for j in i+1..n\n      c += 1\n\
    \      if i < j\n        collisions += 1\n      end\n    end\n  end\n  puts c\n\
    \  return collisions\nend", "  # For each car that's driving left to right,\n\
    \  # we find the first car that it would hit if it keeps going left to right.\n\
    \  # Keep track of the *time at which* the left-to-right car would hit the right-to-left\
    \ car.\n  # Then, we use this time to find the next car that the left-to-right\
    \ car would hit.\n  # So, the first thing we need to do is figure out which car\
    \ each left-to-right car\n  # would hit.  In order to do that, we sort the right-to-left\
    \ cars by the time at which\n  # they would hit the left-to-right cars.  Next,\
    \ we need to figure out which right-to-left\n  # car each left-to-right car would\
    \ hit, in order.\n  # Let's take an example:\n  # n = 5\n  # L = [0, 2, 3, 6,\
    \ 10]\n  # R = [1, 4, 5, 7, 8]\n  # First, let's sort the right-to-left cars by\
    \ their respective times:\n  # [1, 4, 5, 7, 8]\n  # ^    ^    ^    ^    ^\n  #\
    \ 1    2    3    4    5\n  # So, the left-to-right car with index 0 would hit\
    \ the right-to-left car with index 1,\n  # The left-to-right car with index 1\
    \ would hit the right-to-left car with index 2, etc.\n  # Now, we need to figure\
    \ out which right-to-left car each left-to-right car would hit, in order.\n  #\
    \ The left-to-right car with index 0 would hit the right-to-left car with index\
    \ 1.\n  # The left-to-right car with index 1 would hit the right-to-left car with\
    \ index 2.\n  # The left-to-right car with index 2 would hit the right-to-left\
    \ car with index 4.\n  # The left-to-right car with index 3 would hit the right-to-left\
    \ car with index 5.\n  # The left-to-right car with index 4 would hit the right-to-left\
    \ car with index 5.\n  # We can do that by", "  return 0 if n <= 1\n  n * (n -\
    \ 1)\nend", "  faster_speed_cars = []\n  faster_speed_cars << 1\n  counter = 0\n\
    \  while faster_speed_cars.last < n\n    faster_speed_cars << faster_speed_cars.last\
    \ + counter\n    counter += 1\n  end\n  faster_speed_cars.last\nend", "  # your\
    \ solution goes here\n  return n*(n-1)\nend", "  n * n\nend", "  x = []\n  y =\
    \ []\n  (1..n).each {|i| x.push i}\n  (1..n).each {|i| y.push i}\n  x.permutation.count\
    \ + y.permutation.count - 2 * n\nend", "  return n\nend", "\t# We'll keep a doubly\
    \ linked list of the cars that are driving left to right.\n\t# The node representing\
    \ a particular car will hold the position of the car\n\t# at the moment of the\
    \ most recent collision (if any).\n\tclass CarNode\n\t\tattr_accessor :position,\
    \ :prev, :next", "  left_to_right = 1.upto(n).map {|x| x}\n  right_to_left = n.downto(1).map\
    \ {|x| x}\n  left_to_right & right_to_left\nend", "  evens = n.times.map {|i|\
    \ i * 2 }\n  odds = n.times.map {|i| i * 2 + 1 }\n  collisions = 0\n  evens.each\
    \ do |e|\n    odds.each do |o|\n      collisions += 1 if e == o\n    end\n  end\n\
    \  collisions\nend", '  collisions = 0', "  # YOUR CODE HERE\nend", "    # we\
    \ can pair cars moving in opposite directions based on their position at time\
    \ 0\n    # Call the left-to-right moving cars A1, A2, A3 ... An\n    # and the\
    \ right-to-left moving cars B1, B2, B3 ... Bn\n    # Recall that the left-to-right\
    \ cars start out at position -k and the right-to-left cars start out at k\n  \
    \  # where k is sufficiently large so that the cars are initially very far apart\
    \ from each other.\n    # At time t=0, A1 and B1 are the only cars that can collide,\
    \ because they're the closest cars.\n    # Moreover, they will collide at time\
    \ t=1, because they move 1 unit of distance at each time step.\n    # At time\
    \ t=1, A1 and B1 have already collided.  But A2 and B2 can collide.  They'll collide\
    \ at time t=2.\n    # Similarly, at time t=2, A2 and B2 collide, but A3 and B3\
    \ can collide, and they'll collide at time t=3\n    # This pattern will continue\
    \ until we exhaust the cars.\n    # Let c(i) denote the number of collisions at\
    \ time i.\n    # c(i) = n - i\n    # The total number of collisions is equal to\n\
    \    # SUM(i, 0 to n-1) c(i)\n    # This summation can be simplified to (n-1)\
    \ + (n-2) + (n-3) + ... + 1\n    # This is an arithmetic series with initial term\
    \ = 1 and common difference = 1\n    # So, the total number of collisions is (n*(n-1))/2\n\
    \    return (n*(n-1))/2\nend", "  # checks if the two cars collide at t time\n\
    \  # a: position of car moving left to right\n  # b: position of car moving right\
    \ to left\n  # t: time\n  check_collision = lambda do |a, b, t|\n    if (a - b).abs\
    \ < t\n      true\n    else\n      false\n    end\n  end", "  midpoint = n/2\n\
    \  left_trajectory = []\n  right_trajectory = []\n  return 0 if n <= 1\n  1.upto(midpoint)\
    \ do |num|\n    left_trajectory << num\n    right_trajectory << n-num+1\n  end\n\
    \  right_trajectory << (n+1)/2 if n.odd?\n  left_trajectory.each_with_index do\
    \ |num, idx|\n    if right_trajectory.include?(num)\n      right_trajectory.delete(num)\n\
    \      next\n    end\n    if idx >= right_trajectory.length\n      break\n   \
    \ end\n    return car_race_collision(idx) + car_race_collision(right_trajectory.length-idx)\n\
    \  end\nend", "  # We can represent the initial positions of the cars as a two\
    \ arrays of numbers.\n  # One array represents the cars driving left to right;\
    \ the other, the cars\n  # driving right to left.\n  n.times do\n    # Each car\
    \ is randomly positioned at a position in the interval [0, 1),\n    # i.e., [0,\
    \ 1), [0, 1), [0, 1), etc.\n    # The cars drive at a speed of 1; thus, each car\
    \ is a line segment of [0, 1),\n    # i.e., [0, 1), [0, 1), [0, 1), etc.\n   \
    \ l2r_car_positions = [rand, rand, rand, rand, rand, rand, rand, rand, rand, rand]\n\
    \    r2l_car_positions = [rand, rand, rand, rand, rand, rand, rand, rand, rand,\
    \ rand]\n    # Sort the car positions.\n    l2r_car_positions.sort!\n    r2l_car_positions.sort!\n\
    \    # Merge the two arrays.\n    # We're using the Schwartzian transform to sort\
    \ the cars; we want to\n    # order the cars by the positions where they will\
    \ collide.\n    # The position where cars collide are the same as the positions\
    \ where\n    # the car positions start to differ.\n    #\n    # We could have\
    \ simply sorted the two arrays, and then iterated over\n    # the sorted arrays,\
    \ looking for positions where the car positions differ.\n    # However, this would\
    \ have been slower; we'd have had to iterate over\n    # the array n times.\n\
    \    # Instead, we'll use the \"merge\" operation, which will also iterate over\n\
    \    # the array n times.  However, the merge operation will only iterate over\n\
    \    # the array once, and then stop.\n    # This will be much faster than sorting\
    \ the array, and then iterating over\n    # the array n times.\n    #\n    # This\
    \ is an example of dynamic programming.\n    sorted_car_positions = l2r_car_positions.map\
    \ { |e| [e, true] }.merge(r2l_car_positions.map { |e| [e, false", "  count = 0\n\
    \  for i in 0..n\n    for j in 0..n\n      if i < j\n        count += 1\n    \
    \  end\n    end\n  end\n  return count\nend", "  # I see that the only collisions\
    \ that can occur are when two cars,\n  # one moving left to right and the other\
    \ moving right to left,\n  # meet each other at the origin, point 0.  This is\
    \ because\n  # the two sets of cars started out very far from each other.\n  #\n\
    \  # Imagine there are two groups of cars, one moving left to right and the other\n\
    \  # moving right to left.  Each car starts out at a position that's very negative\n\
    \  # or very positive, and ends at a position that's very positive or very negative.\n\
    \  # Any car moving left to right will pass by the origin in order to end at a\
    \ very\n  # positive position.  Any car moving right to left will also pass by\
    \ the origin\n  # in order to end at a very negative position.\n  #\n  # That\
    \ being said, two cars collide only when they meet at the origin.\n  # Thus, if\
    \ there are n cars moving left to right and n cars moving right to left,\n  #\
    \ then the total number of collisions is n.", "\tcars = (1..n).to_a\n\t# left_to_right\
    \ = Hash.new\n\t# right_to_left = Hash.new\n\t# count = 0\n\tcars.each_with_index\
    \ do |element, index|\n\t\tcars.each_with_index do |element2, index2|\n\t\t\t\
    if index < index2\n\t\t\t\tif element == element2\n\t\t\t\t\tputs \"collision\"\
    \n\t\t\t\t\t# count += 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t# count\n\
    end", "\tleft_to_right = []\n\tright_to_left = []\n\tcollisions = 0\n\tn.times\
    \ { left_to_right << true }\n\tn.times { right_to_left << true }\n\twhile left_to_right.length\
    \ > 0 && right_to_left.length > 0\n\t\tcurrent_right = right_to_left.shift\n\t\
    \tcurrent_left = left_to_right.shift\n\t\tif current_right && current_left\n\t\
    \t\tcollisions += 1\n\t\t\tcurrent_right = false\n\t\t\tcurrent_left = false\n\
    \t\tend\n\t\tleft_to_right << current_left\n\t\tright_to_left << current_right\n\
    \tend\n\tcollisions\nend", "  # The input number n is the number of cars.\n  #\
    \ Assume n > 0; n will be a positive integer.\n  # If you have n=1, then there\
    \ will be 0 collisions.\n  # If you have n=2, then there will be 1 collision.\n\
    \  # If you have n=3, then there will be 3 collisions.\n  # If you have n=4, then\
    \ there will be 6 collisions.\n  # The pattern is: 1, 1, 3, 6, 10, 15, 21, 28,\
    \ 36, 45\n  # If you notice the pattern, you can see that the number of collisions\n\
    \  # is the sum of the natural numbers from 1 to n-1.\n  sum = 0\n  for i in 1..n-1\n\
    \    sum += i\n  end\n  return sum\nend", "  # TODO: write your code here!\nend",
  "  num = 0\n  arr1 = (1..n).to_a\n  arr2 = (1..n).to_a.reverse", "  # Put code here\n\
    end", "    left_right = []\n    right_left = []\n    0.upto(n-1) do |index|\n\
    \        left_right[index] = index + 1\n        right_left[index] = (n-1)-index\n\
    \    end\n    counter = 0\n    for i in 0..n-1\n        for j in 0..n-1\n    \
    \        if left_right[i] == right_left[j]\n                counter = counter\
    \ + 1\n            end\n        end\n    end\n    return counter\nend", "  num_of_collisions\
    \ = 0\n  # assuming cars are indexed from 1 to n\n  # the car i moving right to\
    \ left has its index at i, but\n  # the car i moving left to right has its index\
    \ at n+i\n  (1..n).each do |i|\n    # if the car with index i is even, then it's\
    \ moving left to right;\n    # otherwise, it's moving right to left\n    moving_right_to_left\
    \ = i.odd?\n    # the car with index i moves 1 step; the car with index n+i moves\n\
    \    # 1 step as well\n    i += 1 if moving_right_to_left\n    n += 1 unless moving_right_to_left\n\
    \    num_of_collisions += 1 if i == n\n  end\n  num_of_collisions\nend", "  #\
    \ Your code goes here!\nend", "  # If a car drives n miles to reach the leftmost\
    \ car moving right to left,\n  # it must have collided with n-1 cars moving right\
    \ to left.\n  # So the total number of collisions is n * (n-1).\n  n * (n-1)\n\
    end", "  @n=n\n  n.times do |i|\n    puts \"car #{i} has collided #{@num_of_collisions}\
    \ times\"\n    j=i+1\n    while j<@n\n      @num_of_collisions+=1\n      j+=1\n\
    \    end\n  end\n  return @num_of_collisions\nend", "  # Write your code here.\n\
    end", "  # Implement this function\n  return n * n\nend", "  cars_left_to_right\
    \ = (1..n).to_a\n  cars_right_to_left = (1..n).to_a.reverse\n  collisions = 0\n\
    \  until cars_left_to_right.empty? || cars_right_to_left.empty?\n    if cars_left_to_right.first\
    \ < cars_right_to_left.first\n      cars_left_to_right.shift\n    elsif cars_left_to_right.first\
    \ > cars_right_to_left.first\n      cars_right_to_left.shift\n    else\n     \
    \ collisions += 1\n      cars_left_to_right.shift\n      cars_right_to_left.shift\n\
    \    end\n  end\n  collisions\nend", "  l2r = (1..n).to_a\n  r2l = (1..n).to_a.reverse",
  "  puts \"car_race_collision(#{n})\"\n  if n < 1\n    return 0\n  end\n  a = []\n\
    \  b = []\n  n.times do |i|\n    a << i\n    b << n - i - 1\n  end\n  collisions\
    \ = 0\n  while a.length > 0\n    collisions += 1 if a[0] == b[0]\n    a.shift\n\
    \    b.pop\n  end\n  collisions\nend", "  # Your code goes here.\nend", "  # Counter\
    \ that stores the number of collisions between cars.\n  collision_counter = 0",
  "  # the cars which go from left to right are the cars whose numbers are\n  # a\
    \ multiple of two;  the cars which go from right to left are the cars\n  # whose\
    \ numbers are a multiple of two plus one\n  ((n * 2) - 1).downto(1).reduce(0)\
    \ do |collisions, car_num|\n    # check whether the car is moving from left to\
    \ right\n    if car_num % 2 == 0\n      # car is moving from left to right;  let's\
    \ see how many collisions\n      # it has\n      hits = car_num / 2\n      collisions\
    \ + hits\n    else\n      # car is moving from right to left;  let's see how many\
    \ collisions\n      # it has\n      hits = (car_num + 1) / 2\n      collisions\
    \ + hits\n    end\n  end\nend", "  output = 0\n  intersection = 0\n  cars_left\
    \ = (1..n).to_a\n  cars_right = (1..n).to_a\n  cars_left.each do |car|\n    cars_right.each\
    \ do |car_r|\n      if (car >= car_r) && (car - car_r <= car_r)\n        output\
    \ += 1\n      end\n    end\n  end\n  return output\nend", "  # Your code here\n\
    end", "  return 0 if n <= 1\n  count = 0\n  cars_left = n.times.to_a\n  cars_right\
    \ = n.times.to_a.reverse\n  loop do\n    break if cars_left.empty? || cars_right.empty?\n\
    \    if cars_left.first > cars_right.first\n      cars_right.shift\n      count\
    \ += 1\n    else\n      cars_left.shift\n    end\n  end\n  count\nend", "  return\
    \ 0 if n <= 1\n  Math.log2(n).floor\nend", "  n\nend", "  raise Exception.new\
    \ \"The two populations of cars cannot be of different sizes!\" if n[0] != n[1]\n\
    \  n[0]\nend", "    (1..n).map {|i| Math.sqrt(i) }.reduce(:+)\nend", "  # Your\
    \ code goes here.\n  # Do not use a loop.\n  # There's a solution in O(1) or better.\n\
    \  return 0 if n <= 1\n  n * (n - 1)\nend", "  n * n\nend", "    # This is a nice\
    \ trick to use with Ruby's Enumerable's.\n    # If you are unfamiliar with Enumerables\
    \ in Ruby, you should go learn about them\n    # immediately by reading the Enumerable\
    \ documentation.\n    #\n    # Enumerable#map returns an Enumerable (usually an\
    \ Array) that contains the results\n    # of applying the block you provide to\
    \ each element of the original Enumerable.\n    #\n    # For example,\n    # [1,\
    \ 2, 3].map { |x| x * x }\n    # would return [1, 4, 9]\n    #\n    # In this\
    \ case, we are taking an array of integers, passing each of them as an\n    #\
    \ argument to a block that squares them, and returning an array of the results.\n\
    \    #\n    # When using the & operator, it is essential to think about the \"\
    shape\" of the\n    # data, and the shape of the function.\n    #\n    # In this\
    \ case, we have an array of integers, and we are passing them to a function\n\
    \    # that takes an integer, squares it, and returns the result.  As a result,\
    \ our\n    # map function can be replaced with the function that & is being passed.\n\
    \    #\n    # Note: map! is the \"bang\" version of map.  It performs the same\
    \ operation but in\n    # place.  However, the output of map! is no longer an\
    \ Enumerable; instead, it\n    # returns the object that was operated on.  Since\
    \ our output has no Enumerable\n    # operations on it, we can safely use the\
    \ bang version of map.\n    #\n    # Finally, we are using the count function,\
    \ which is similar to the length function.\n    # The difference is that count\
    \ takes an argument, a block, and only counts the number\n    # of elements that\
    \ return true when passed to that block.\n    #\n    # For example, if you have\
    \ an array of integers, and you want to count how many of\n    # them are even,\
    \ you can use count.\n    #\n    # [1, 2, 3, 4, 5].count { |x| x.even? }\n   \
    \ # would return 2.\n    #\n    # We are using count to count the number of cars\
    \ that collide, in this case those\n    #", "  right_cars = (1..n).to_a\n  left_cars\
    \ = (1..n).to_a.reverse", "  # Suppose that the cars moving left to right are\
    \ yellow and the cars moving right to left are green.\n  #\n  # Consider a car\
    \ that's yellow and moving left to right.  Say this car moves a certain\n  # distance\
    \ d.  Then all the cars that are green and moving right to left that are within\n\
    \  # distance d get hit by this car.  Therefore, if we know the distance a yellow\
    \ car moves\n  # and we know the position of the green cars, we can figure out\
    \ the number of collisions\n  # that yellow car causes.\n  #\n  # Let's call the\
    \ distance between two closest yellow cars d_y.  Let's call the distance between\n\
    \  # two closest green cars d_g.  We don't know d_y and d_g, but we know that:\n\
    \  # \n  #  d_y <= (n - 1) / n\n  #  d_g <= (n - 1) / n\n  #\n  # Consider the\
    \ yellow car that's closest to the center.  Say this car moves distance d_y.\n\
    \  # How many green cars are within distance d_y?  If you draw a circle of radius\
    \ d_y around\n  # this yellow car, how many green cars will be in that circle?\
    \  If there's a yellow car\n  # at 0 and a green car at 1, then there will be\
    \ one green car in the circle, because the\n  # green car is within distance 1.\
    \  But if there's a yellow car at 0 and two green cars\n  # at 1 and 2, then there\
    \ are two green cars in the circle.  This will happen whenever the\n  # green\
    \ cars are closer to each other than the yellow cars.  Therefore, for this yellow\n\
    \  # car, it will cause\n  # \n  #    2 * (n - 1) / n - 1\n  #\n  # green cars\
    \ to collide.  (We subtract 1 to avoid double counting;  we'll count the green\n\
    \  # car twice if we don't subtract 1.)\n  #\n  # There are n yellow cars and\
    \ n green cars.  The yellow car that's closest to the center\n  # will cause 2\
    \ * (n - 1) / n - 1 green cars to collide.  There are n green cars, so there\n\
    \  # are n - 1", "\t# invariant: a[0..n-1] and b[0..n-1] are sorted arrays of\
    \ distinct elements\n\ta = []\n\tb = []\n\t1.upto(n) do |i|\n\t\ta[i] = i\n\t\t\
    b[i] = i\n\tend\n\t# invariant: a[0..n-1] and b[0..n-1] are sorted arrays of distinct\
    \ elements\n\t# pairwise_merge_cars(a, b) returns the number of collisions\n\t\
    return pairwise_merge_cars(a, b)\nend", "  car_l_to_r = []\n  car_r_to_l = []\n\
    \  # Assumptions:\n  # - The cars all move at the same speed.\n  # - No two cars\
    \ can be at the same location at the same time.\n  # At the end of the trip, everyone\
    \ has to reach their destination.\n  # We can model the cars' journey by setting\
    \ up a directed graph where the cars are the nodes,\n  # and the edges have weights\
    \ equal to the time it takes for the car to reach their destination.\n  # We're\
    \ basically given the starting node, and we're trying to find the ending node.\n\
    \  #\n  # Create a directed graph\n  # |V| = 2n\n  # |E| = n^2\n  #   (n to the\
    \ right, n to the left)\n  # Each edge has weight 1.  Each node has the following\
    \ label:\n  # ('left' or 'right', index)\n  #\n  # We now start by picking a random\
    \ starting node.  Then we find all the shortest paths\n  # and take the max of\
    \ the shortest paths.  I.e., we want to find the max number of hops\n  # it takes\
    \ to get from each starting node to the other.\n  #\n  # We can use Dijkstra's\
    \ algorithm to find the shortest path.\n  # But first, we'll create the graph.\n\
    \  #\n  # Each node is labeled as ('left' or 'right', index), where left index\
    \ should be from 1 to n,\n  # and right index should be from n+1 to 2n.\n  # The\
    \ distances are all 1.\n  (1..n).each do |index|\n    car_l_to_r << ['left', index]\n\
    \    car_r_to_l << ['right', index]\n  end\n  # Initialize a hash as a graph.\n\
    \  graph = {}\n  # Create the graph.\n  car_l_to_r.each do |car|\n    right_index\
    \ = car[1] + n\n    car_r_to_l.each do |new_car|\n      graph[car] = {} if graph[car].nil?\n\
    \      graph[car][new_car] = 1\n    end\n ", "  n\nend", "  num_left = n\n  num_right\
    \ = n\n  collisions = 0\n  # Don't move right car if there is a left car at the\
    \ same position\n  # (This is to avoid double counting collisions)\n  right_car_in_position\
    \ = false\n  n.times do |i|\n    if i == 0\n      # On the left most position,\
    \ there is a left car and no right car\n      collisions += 1\n      num_left\
    \ -= 1\n      right_car_in_position = false\n    elsif right_car_in_position ==\
    \ false\n      # There is no right car in the position\n      # There will be\
    \ collisions when the left car meets a right car in the same position\n      #\
    \ If there are more right cars left than there are positions, move right car\n\
    \      if num_right > (n - i)\n        collisions += 1\n        num_right -= 1\n\
    \        right_car_in_position = true\n      else\n        # No right car in this\
    \ position\n        right_car_in_position = false\n      end\n    else\n     \
    \ # There is a right car in the position\n      # If there are more left cars\
    \ left than there are positions, move left car\n      if num_left > (n - i)\n\
    \        collisions += 1\n        num_left -= 1\n        right_car_in_position\
    \ = true\n      else\n        # No left car in this position\n        right_car_in_position\
    \ = true\n      end\n    end\n  end\n  collisions\nend", "  require 'bigdecimal'\n\
    \  require 'bigdecimal/util'\n  result = (n * BigDecimal.new(n - 1) / 2).to_i\n\
    \  puts \"Collisions: #{result}\"\n  result\nend", "  num_collisions = 0\n  cars_1\
    \ = (1..n).to_a\n  cars_2 = (1..n).to_a.reverse", "  left = (1..n).to_a.reverse\n\
    \  right = (1..n).to_a\n  left_cars = []\n  right_cars = []\n  count = 0\n  left.each\
    \ do |n|\n    if left_cars.include?(n)\n      # do nothing\n    else\n      left_cars\
    \ << n\n    end\n  end\n  left_cars.each do |left_car|\n    right.each do |right_car|\n\
    \      if left_car == right_car\n        count += 1\n      end\n    end\n  end\n\
    \  return count\nend", "  return 0 if n == 0\n  return 0 if n == 1\n  return 1\
    \ if n == 2\n  return 1 if n == 3\n  return 3 if n == 4\n  # the number of collisions\
    \ is the number of unique pairs of cars that can collide.\n  # how many unique\
    \ pairs of cars can collide?  As the two groups of cars move\n  # towards each\
    \ other, the cars that are closest to each other are the most likely\n  # to collide.\
    \  As such, the first car of the left-to-right group and the last car\n  # of\
    \ the right-to-left group have the highest chance of colliding.  That gives us\n\
    \  # one collision.  For the next collision, we consider the first and second\
    \ cars of\n  # the left-to-right group, or the last and second-to-last cars of\
    \ the right-to-left\n  # group.  There are 2 possible collisions in total.  In\
    \ general, there are 2 collisions\n  # for a group of 4 cars, 3 collisions for\
    \ a group of 6 cars, and 4 collisions for a group\n  # of 8 cars.  This can be\
    \ generalized as follows:\n  # n  -> number of cars\n  # (n / 2) -> number of\
    \ unique pairs of cars that can collide.\n  # (n / 2) - 1  -> number of collisions\n\
    \  # therefore, the general formula is:\n  # collision = (n / 2) - 1\n  return\
    \ (n / 2) - 1\nend", "  n\nend", "  # Complete this function.\nend", "\tleft_cars_locations\
    \ = []\n\tright_cars_locations = []\n\tcollisions = 0\n\t\n\tfor i in 1..n\n\t\
    \tleft_cars_locations << i\n\t\tright_cars_locations << n - i + 1\n\tend\n\t\n\
    \tfor i in 0..n - 1\n\t\tfor j in 0..n - 1\n\t\t\tif left_cars_locations[i] ==\
    \ right_cars_locations[j]\n\t\t\t\tcollisions += 1\n\t\t\tend\n\t\tend\n\tend\n\
    \t\n\treturn collisions\nend", "  return 0 if n == 0\n  n - 1\nend", "\tarr =\
    \ []\n\t0.upto(n-1) do |x|\n\t\tarr << x\n\tend\n\tarr2 = arr.dup\n\tarr2.reverse!\n\
    \treturn arr2 & arr\nend", "  return -1 if n < 0\n  if n <= 1\n    return 0\n\
    \  end\n  k = 1\n  n -= 1\n  k += n * (n + 1) / 2\n  k\nend", "  # TODO: your\
    \ code here!\nend", "  left_to_right_times = n.times.map { rand }.sort\n  right_to_left_times\
    \ = n.times.map { rand }.sort\n  collisions = 0\n  right_to_left_times.each do\
    \ |time|\n    left_to_right_times.each do |other_time|\n      collisions += 1\
    \ if time >= other_time\n    end\n  end\n  collisions\nend", "    o = 0\n    #\
    \ ruby's main loop only runs once. \n    while n > 0\n        while n > 0\n  \
    \          o += 1\n            n -= 1\n        end\n        n -= 1\n    end\n\
    \    return o\nend", "  # This function is based on the observation that, if the\
    \ left-right cars get\n  # priority, then the collisions are simply the number\
    \ of right-left cars\n  # (regardless of whether they're coming from the right\
    \ or the left) that\n  # are in front of a left-right car (regardless of whether\
    \ they're going left\n  # or right).\n  #\n  # Consider any car that's heading\
    \ right to left.  Regardless of whether\n  # there are any cars heading left to\
    \ right, this car won't collide with any\n  # cars heading left to right because\
    \ the head-on collision never occurs.\n  # Thus, we simply add the number of cars\
    \ heading right to left for each\n  # car that's heading left to right.\n  return\
    \ n * n\nend", "  @n=n\n  @a=@n-1\n  @b=0\n  @coll=0\n  while @b<@n\n    while\
    \ @a>=0\n      if @a>@b\n        @coll+=1\n      end\n      @a-=1\n    end\n \
    \   @b+=1\n    @a=@n-1\n  end\n  @coll\nend", "  # the key to this problem is\
    \ making the connection between the two sets of cars\n  # the cars are always\
    \ going to be moving at the same speed.\n  # the cars are also going to be colliding\
    \ in the same time that they would collide if they were going at the same speed.\n\
    \  # the distance between them is going to be the same.\n  # this means that it\
    \ doesn't matter which direction they are moving in, they are going to collide\
    \ at the same time.\n  # the only thing that changes is the order that they collide\
    \ in.\n  # so, the algorithm will have to deal with them as if they are going\
    \ at the same speed.\n  # this means that they are going to be colliding at the\
    \ same time regardless of order.\n  # this means that the algorithm will only\
    \ have to deal with one set of cars.\n  # so, we can first shift the cars so that\
    \ they all start at the same place.\n  # then we can just count the number of\
    \ collisions in the shifted array.\n  # we can use a selection sort algorithm\
    \ to do this.\n  # the worst case scenario for the algorithm would be O(n^2) where\
    \ n is the number of cars", "  return 0 if n <= 1\n  i = 0\n  j = n-1\n  collisions\
    \ = 0\n  for i in 0..(n-1)\n    for j in (n-1).downto(0)\n      collisions +=\
    \ 1 if (i < j)\n    end\n  end\n  collisions\nend", "  return car_race_collision_helper(n,\
    \ 0, [], [])\nend", "  # TODO: implement\nend", end, "  if n <= 0\n    return\
    \ 0\n  end\n  return n - 1\nend", "  # YOUR CODE HERE\nend", "  # WRITE YOUR CODE\
    \ HERE\nend", "  m = n\n  i = 0\n  count = 0\n  while m != 0\n    if (i == m)\n\
    \      return count\n    end\n    count += i * m\n    i += 1\n    m -= 1\n  end\n\
    \  return count\nend", "  n*(n-1)\nend", "  # YOUR CODE HERE\nend", '  return
    0 if n <= 1', "  # write code here\nend", "  lefthand = []\n  righthand = []\n\
    \  collisions = 0\n  i = 0\n  n.times do\n    lefthand[i] = i\n    righthand[i]\
    \ = n+i\n    i += 1\n  end\n  i = 0\n  until i == n\n    j = 0\n    until j ==\
    \ n\n      if lefthand[i] == righthand[j]\n        collisions += 1\n      end\n\
    \      j += 1\n    end\n    i += 1\n  end\n  collisions\nend", "  return -1 if\
    \ n <= 0\n  return 0 if n == 1\n  return (n * (n - 1)) / 2 if n > 1\nend", " \
    \ # keep track of the number of collisions\n  num_collisions = 0", "  # TODO\n\
    end", "  return 1 if n == 0\n  # This is a geometric series.\n  # To calculate\
    \ the sum of the first n terms of a geometric series with first term a and common\
    \ ratio r,\n  # we use the formula (a(1-r^n))/(1-r).  In this case, the first\
    \ term is 1, and the common ratio is n/(n+1).\n  return ((1.0 - (n/(n+1.0))**(n+1))/(1-n/(n+1.0))).to_i\n\
    end", "  # For n = 5, we have the following progress:\n  #     Left-to-right cars:\
    \  RRRRR  LLRRL  LLLRR  LLLLL\n  # Right-to-left cars:      LLLLL  RRRRR  RRRRL\
    \  RRLLL\n  # There are 3 collisions.\n  # Approach: We use the fact that each\
    \ of the n cars will collide once and only once.\n  # After the first collision,\
    \ there are 2n - 1 cars on the road; after the second collision,\n  # there are\
    \ 2n - 2 cars, and so on.  Using this, we add the sum 1 + 2 + ... + n = n(n+1)/2.\n\
    \  return (n * (n + 1)) / 2\nend", "  count = 0\n  for i in 0..n-1\n    for j\
    \ in n..2*n-1\n      count += 1\n    end\n  end\n  return count\nend", "\t# enter\
    \ your solution here\n\tleft_to_right = (1..n).to_a\n\tright_to_left = (1..n).to_a.reverse\n\
    \tcollisions = 0\n\tuntil left_to_right.empty? || right_to_left.empty?\n\t\tif\
    \ left_to_right.first < right_to_left.first\n\t\t\tcollisions += 1\n\t\t\tleft_to_right.shift\n\
    \t\telse\n\t\t\tright_to_left.shift\n\t\tend\n\tend\n\tcollisions\nend", "\t#\
    \ Use long_road array to represent the road.\n\t# long_road[i] would equal 1 if\
    \ a car is driving right to left at position i.\n\t# long_road[i] would equal\
    \ -1 if a car is driving left to right at position i.\n\t# long_road[i] would\
    \ equal 0 if no car is driving at position i.\n\tlong_road = []\n\t(0..n).each\
    \ do |i|\n\t\tlong_road[i] = 1\n\tend\n\t(n..2*n).each do |i|\n\t\tlong_road[i]\
    \ = -1\n\tend\n\tlong_road[n] = 0\n\t# Count the number of collisions that occur\
    \ in a time period of 1.\n\t# This is done by counting the number of collisions\
    \ when n cars are\n\t# driving in the same direction (in this case, all cars are\
    \ driving left to right).\n\t# The number of collisions when n cars are driving\
    \ in the same direction is equal to\n\t# the sum of all numbers that are equal\
    \ to -2.\n\tcollisions = 0\n\tlong_road.each do |i|\n\t\tif i == -2\n\t\t\tcollisions\
    \ += 1\n\t\tend\n\tend\n\t# So far, we've only counted the number of collisions\
    \ at a particular time.\n\t# We want to multiply this value by the number of times\
    \ that we want to check\n\t# whether cars are colliding.  Because cars travel\
    \ at a constant speed,\n\t# we need to check this value once per time unit.\n\t\
    # There is a total of 2*n time units until the cars are back to their original\n\
    \t# positions.\n\treturn collisions * 2 * n\nend", "  if n <= 0\n    puts \"error:\
    \ need at least one car\"\n    return nil\n  end\n  collisions = 0\n  a = []\n\
    \  b = []\n  1.upto(n) do |i|\n    a[i] = i\n    b[i] = n+1-i\n  end\n  1.upto(n)\
    \ do |i|\n    1.upto(n) do |j|\n      if a[i] == b[j]\n        collisions += 1\n\
    \      end\n    end\n  end\n  collisions\nend", "  #returns an integer\nend",
  "  seen = {}\n  i = 0\n  n.times do\n    i+=1\n    next unless seen[i]\n    return\
    \ 2*i - 1\n  end\n  0\nend", "  if n <= 1\n    return 0\n  end\n  total_collisions\
    \ = n - 1", "  # This is an O(n^2) solution\n  # collisions = 0\n  # n.times do\
    \ |idx|\n  #   n.times do |idx2|\n  #     if idx < idx2\n  #       collisions\
    \ += 1\n  #     end\n  #   end\n  # end\n  # collisions", "  l_c, r_c = [], []\n\
    \  n.times do\n    l_c << rand(100_000_000)\n    r_c << rand(100_000_000)\n  end\n\
    \  l_c.sort!\n  r_c.sort!\n  p l_c\n  p r_c\n  i, j = 0, 0\n  collisions = 0\n\
    \  until i == n || j == n\n    if r_c[j] < l_c[i]\n      collisions += 1\n   \
    \   j += 1\n    else\n      i += 1\n    end\n  end\n  collisions\nend", "  # Assume\
    \ that n is a non-negative integer.\n  # We will assume that the n cars moving\
    \ left to right are numbered\n  # 1, 2, ..., n and that the n cars moving right\
    \ to left are numbered\n  # n+1, n+2, ..., 2n.\n  # We will use 2n-1 to store\
    \ the number of cars moving left to right\n  # that have not yet collided with\
    \ a car moving right to left.\n  # For example, if n = 4, then this number is\
    \ initially 5.\n  # Similarly, we will use 2n to store the number of cars moving\
    \ right to left\n  # that have not yet collided with a car moving left to right.\n\
    \  # For example, if n = 4, then this number is initially 4.\n  cars_left = 2*n-1\n\
    \  cars_right = 2*n\n  # This number is the number of collisions.\n  collisions\
    \ = 0\n  # This number is the number of cars moving left to right that have collided\n\
    \  # with cars moving right to left.\n  collided_cars_left = 0\n  # This number\
    \ is the number of cars moving right to left that have collided\n  # with cars\
    \ moving left to right.\n  collided_cars_right = 0\n  # As long as there's at\
    \ least one car that has not collided with a car\n  # on the other side, iterate\
    \ as follows.\n  while cars_left + cars_right > 0\n    # This is a random number\
    \ between 1 and the number of cars that have not\n    # collided with a car on\
    \ the other side.\n    random_number = rand(cars_left + cars_right)\n    # If\
    \ the random number is between 1 and the number of cars moving left to right\n\
    \    # that have not collided with a car moving right to left, then a car moving\n\
    \    # left to right has collided with a car moving right to left.\n    if random_number\
    \ < cars_left\n      # Increment the number of collisions.\n      collisions +=\
    \ 1\n      # Increment the number of cars moving left to right that have collided\n\
    \      # with cars moving right to left.\n      collided_cars_left += 1\n    \
    \  # Decrement the number of cars moving left to right that have not yet\n   \
    \   # collided with a car moving", "  n * n\nend", "  i = 0\n  j = 0\n  ans =\
    \ 0\n  while (i < n && j < n)\n    if (i == j)\n      ans += 1\n      i += 1\n\
    \      j += 1\n    elsif (i < j)\n      i += 1\n    else\n      j += 1\n    end\n\
    \  end\n  ans\nend", "  # if n <= 0\n  #   raise ArgumentError.new \"n must be\
    \ positive\"\n  # end\n  return 0 if n < 2\n  return 1 if n == 2\n  # In this\
    \ problem, we want to find the sum of the first n integers.\n  # We know that\
    \ there is a closed form formula for this:  the sum of the first n integers\n\
    \  # is n * (n + 1) / 2.  But let's be a little more clever and implement\n  #\
    \ a different solution.\n  # The first car in the first set of cars will collide\
    \ with the first car in the second set of cars.\n  # The second car in the first\
    \ set of cars will collide with the second car in the second set of cars.\n  #\
    \ ...\n  # The nth car in the first set of cars will collide with the nth car\
    \ in the second set of cars.\n  # So, the sum of first n integers is equal to\
    \ the number of collisions.\n  collisions = 0\n  for i in 1..n\n    collisions\
    \ += i\n  end\n  return collisions\nend", "    left_to_right = Array.new(n, 1)\n\
    \    right_to_left = Array.new(n, -1)\n    # Start the n cars in left to right,\
    \ and the other n cars in right to left.\n    collision_count = 0\n    while collision_count\
    \ < n\n        # Check to see if all cars have moved off the map.\n        collision_count\
    \ = 0\n        # Move all cars from left to right.\n        (0...n).each do |i|\n\
    \            left_to_right[i] += 1\n            if left_to_right[i] > n\n    \
    \            collision_count += 1\n            end\n        end\n        # Move\
    \ all cars from right to left.\n        (0...n).each do |i|\n            right_to_left[i]\
    \ -= 1\n            if right_to_left[i] < -n\n                collision_count\
    \ += 1\n            end\n        end\n        puts \"left to right cars: #{left_to_right}\"\
    \n        puts \"right to left cars: #{right_to_left}\"\n        puts \"collision\
    \ count: #{collision_count}\"\n        puts\n    end\n    # Determine the number\
    \ of collisions.\n    (0...n).each do |i|\n        # Check if car i in right to\
    \ left collided with any car.\n        collision_count = 0\n        (0...n).each\
    \ do |j|\n            if left_to_right[j] >= 0 && left_to_right[j] == -right_to_left[i]\n\
    \                collision_count += 1\n            end\n        end\n        if\
    \ collision_count > 0\n            puts \"Car #{i} in right to left collided with\
    \ #{collision_count} cars.\"\n        end\n    end\nend\ncar_race_collision(5)",
  "  # Write your code here.\nend", "\th = n*2 + 1\n\treturn (h*(h+1)/2) - 2*n - 1\n\
    end", "  # 1) We assert that the input n is a positive integer.\n  raise TypeError,\
    \ 'n is not a positive integer' unless n.is_a?(Integer) && n.positive?", "  i\
    \ = 1\n  total = 0\n  while i <= n\n    j = 1\n    while j <= n\n      if i ==\
    \ j\n        j += 1\n        next\n      end\n      total += 1\n      j += 1\n\
    \    end\n    i += 1\n  end\n  return total\nend", "  n * (n - 1) / 2\nend", " \
    \ # n represents the number of cars going in each direction\n  # for n cars going\
    \ in each direction, there are n*(n-1) possible pairs of cars\n  # going in opposite\
    \ directions.\n  # for each pair of cars, use the formula for determining whether\
    \ or not the cars\n  # collide: start < end + delta && end > start - delta.\n\
    \  # start is the start time of the left to right car and end is the end time\
    \ of\n  # the right to left car.  delta is the distance between the cars at the\
    \ start.\n  # given the fact that they are infinitely far apart at the start,\
    \ delta is a\n  # constant.  However, since it is a constant, we can ignore it.\n\
    \  # then the equation above can be simplified to the following:\n  # start <\
    \ end && end > start\n  # in other words, the two cars will collide if the start\
    \ time of the left to right\n  # car is less than the end time of the right to\
    \ left car and if the end time of the\n  # right to left car is greater than the\
    \ start time of the left to right car.\n  # to determine the number of possible\
    \ collisions, first use n to define the range of\n  # values for the start time\
    \ and end time of the left to right and right to left cars\n  # respectively.\
    \  then use the equation described above to determine the number of\n  # collisions.\n\
    \  collisions = 0\n  (1..n).each do |start|\n    (1..n).each do |end_time|\n \
    \     collisions += 1 if start < end_time && end_time > start\n    end\n  end\n\
    \  collisions\nend", "  # 1)  Sort the left to right cars.  Do the same for the\
    \ right to left cars.\n  # 2)  Merge the sorted lists\n  # 3)  Count the number\
    \ of merges that result in a collision\n  # O(n log n) time", "  return n * (n\
    \ - 1) / 2\nend", end, "  left_right = Array.new(n)\n  right_left = Array.new(n)\n\
    \  collisions = 0\n  (0..n-1).each do |i|\n    left_right[i] = i\n    right_left[i]\
    \ = n - i - 1\n  end\n  left_right.sort!\n  right_left.sort!\n  left_right.each\
    \ do |curr|\n    collisions += left_right.bsearch_index { |x| x > curr }\n  end\n\
    \  collisions\nend", "  return (n-1) ** 2\nend", "  # rearranging the original\
    \ problem to remove the problem of \"infinitely long\"\n  # assume the cars are\
    \ moving at a constant speed of 1 unit per second.\n  # also, assume that only\
    \ two cars collide at a time. (as a result of this assumption,\n  #  the size\
    \ of the array is halved).\n  # assume that time starts at 0, and ends at n, since\
    \ the starting position of\n  # the cars are so far apart.  (as a result of this\
    \ assumption, the array is\n  # halved again).", "\tif n > 0\n\t\t# This is a\
    \ very fast and very simple solution.\n\t\t# It works because as you pass to the\
    \ next number, there's always one more collision.\n\t\t# For instance, when n\
    \ = 10, the number of collisions is 10. \n\t\t# When n = 11, the number of collisions\
    \ is 11.  \n\t\t# Why?  Because in both cases, each car has 10 collisions; in\
    \ the latter case, \n\t\t# the extra 11th car joins the race and has 1 collision\
    \ (with the first car)\n\t\t# I could have used recursive calls or explicit loops,\
    \ but both would be slower\n\t\t# than this solution.  I could have also used\
    \ Gauss' formula; that would be\n\t\t# very easy and quick, but would use more\
    \ memory.\n\t\treturn n\n\telse\n\t\treturn 0\n\tend\nend", "  n*(n-1)\nend",
  "  i = 0;\n  collisions = 0;\n  cars = {}\n  while i < n\n    cars[i] = 0;\n   \
    \ i += 1;\n  end\n  i = 0;\n  while i < n\n    cars[i] += 1;\n    j = 0;\n   \
    \ while j < n\n      if cars[j] == cars[i] && j != i\n        collisions += 1;\n\
    \      end\n      j += 1;\n    end\n    i += 1;\n  end\n  collisions\nend", "\t\
    car1 = []\n\tcar2 = []\n\tcollisions = 0\n\tfor i in 0..n-1\n\t\tcar1[i] = rand(10000)\n\
    \t\tcar2[i] = rand(10000)\n\tend\n\tcar1.sort!\n\tcar2.sort!\n\tfor i in 0..n-1\n\
    \t\tif car1[i] < car2[i]\n\t\t\tcollisions += n - i\n\t\tend\n\tend\n\treturn\
    \ collisions\nend", "  cars_l2r = Array.new(n) { |i| i + 1 }\n  cars_r2l = Array.new(n)\
    \ { |i| i + 1 }\n  collisions = 0\n  (1..n).each do |i|\n    current_car_l2r =\
    \ cars_l2r[i - 1]\n    current_car_r2l = cars_r2l[n - i]\n    if current_car_l2r\
    \ == current_car_r2l\n      collisions += 1\n    end\n  end\n  collisions\nend",
  "  return 0 if n == 0 || n == 1\n  left = Array.new(n) {rand(n*10)}\n  right = Array.new(n)\
    \ {rand(n*10)}\n  left = left.sort\n  right = right.sort\n  collision = 0\n  i\
    \ = 0\n  j = 0\n  while j < right.length && i < left.length\n    if left[i] <\
    \ right[j]\n      i += 1\n    elsif left[i] > right[j]\n      j += 1\n    else\n\
    \      j += 1\n      i += 1\n      collision += 1\n    end\n  end\n  collision\n\
    end", "  # A lot of solutions use a Hash to count the number of each car.  That's\
    \ great because\n  # using a Hash is a very common technique.  However, I also\
    \ want to introduce you to\n  # an even more common technique: sorting.  So I'm\
    \ going to sort the cars.\n  #\n  # Imagine that the left-to-right cars are numbered\
    \ 1 to n, and the right-to-left cars\n  # are numbered n+1 to 2n.  Then sorting\
    \ the cars is equivalent to sorting the numbers\n  # 1 to 2n.  To do this, I'll\
    \ use Array.new to create an array of numbers 1 to 2n,\n  # and then I'll use\
    \ Array.sort! to sort it.\n  cars = Array.new(2*n){|i| i+1}", "  # You may not\
    \ use loops!\n  return (2 * n) - 1\nend", "    cars = []\n    cars.push(1)\n \
    \   cars.push(-1)\n    i = 2\n    while i <= n\n        cars.push(i)\n       \
    \ cars.push(-i)\n        i += 1\n    end\n    # The total number of collisions\
    \ is equal to the total number of pairs\n    # of cars such that the left car\
    \ is bigger than the right car\n    return count_pairs(cars)\nend", "\tnum_collisions\
    \ = 0\n\treturn num_collisions\nend", "  cars_l2r = []\n  cars_r2l = []\n  collisions\
    \ = 0\n  (1..n).each do |c|\n    cars_l2r << c\n    cars_r2l << n - c + 1\n  end\n\
    \  cars_l2r.each do |l|\n    cars_r2l.each do |r|\n      if l == r\n        collisions\
    \ += 1\n      end\n    end\n  end\n  collisions\nend", "  # Your code goes here.\n\
    \  return 0 if n <= 1", "  cars_moving_left_to_right = (1..n).to_a\n  cars_moving_right_to_left\
    \ = (1..n).to_a.reverse\n  collisions = 0\n  until cars_moving_left_to_right.empty?\
    \ || cars_moving_right_to_left.empty?\n    collisions += 1 if cars_moving_left_to_right.first\
    \ == cars_moving_right_to_left.first\n    cars_moving_left_to_right.shift\n  \
    \  cars_moving_right_to_left.shift\n  end\n  collisions\nend", "\tleft_right =\
    \ (1..n).to_a\n\tright_left = (1..n).to_a.reverse\n\tcollisions = 0\n\tuntil left_right.empty?\
    \ || right_left.empty?\n\t\tif left_right.first == right_left.first\n\t\t\tcollisions\
    \ += 1\n\t\t\tleft_right.shift\n\t\t\tright_left.shift\n\t\telsif left_right.first\
    \ < right_left.first\n\t\t\tleft_right.shift\n\t\telse\n\t\t\tright_left.shift\n\
    \t\tend\n\tend\n\tcollisions\nend", "  #\n  # YOUR CODE HERE\n  #\n  first_half\
    \ = []\n  second_half = []\n  counter = 0\n  while n != 0\n    first_half.push(n)\n\
    \    second_half.push(n)\n    n -= 1\n  end\n  while first_half != [] && second_half\
    \ != []\n    if first_half[0] < second_half[-1]\n      first_half.shift\n    \
    \  second_half.pop\n      counter += 1\n    else\n      first_half.shift\n   \
    \   second_half.pop\n    end\n  end\n  return counter\nend", "\tcars_left = n\n\
    \tcars_right = n\n\tcollisions = 0\n\tif cars_left > 0 and cars_right > 0\n\t\t\
    collisions += 1\n\t\tcars_left -= 1\n\t\tcars_right -= 1\n\tend\n\treturn collisions\n\
    end", "  r2l = [] # array of car locations; positive number for cars going right\
    \ to left\n  l2r = [] # array of car locations; negative number for cars going\
    \ left to right\n  # initialize car locations\n  0.upto(n - 1) do |idx|\n    r2l\
    \ << idx + 1\n    l2r << -(idx + 1)\n  end\n  collision_count = 0\n  # simulate\
    \ cars moving\n  1.upto(n) do |time|\n    collision_count += r2l.size - (r2l &\
    \ l2r).size\n    r2l.map! { |loc| loc + 1 }\n    l2r.map! { |loc| loc - 1 }\n\
    \  end\n  collision_count\nend", "  if n <= 1\n    0\n  else\n    n * (n - 1)\
    \ / 2\n  end\nend", "  # your code goes here\nend", "  right_to_left_cars = Array.new(n)\n\
    \  left_to_right_cars = Array.new(n)\n  right_to_left_cars.each_with_index do\
    \ |car, index|\n    right_to_left_cars[index] = index + 1\n  end\n  left_to_right_cars.each_with_index\
    \ do |car, index|\n    left_to_right_cars[index] = index + 1\n  end\n  collisions\
    \ = 0\n  left_to_right_cars.each do |car_1|\n    right_to_left_cars.each do |car_2|\n\
    \      if car_1 == car_2\n        collisions += 1\n      end\n    end\n  end\n\
    \  return collisions\nend", "\tright_travelling_cars = []\n\tleft_travelling_cars\
    \ = []\n\t0.upto(n-1) do |i|\n\t\tright_travelling_cars[i] = i\n\t\tleft_travelling_cars[i]\
    \ = n - i - 1\n\tend\n\tcount = 0\n\tright_travelling_cars.each do |car|\n\t\t\
    left_travelling_cars.each do |other_car|\n\t\t\tif car == other_car\n\t\t\t\t\
    count += 1\n\t\t\tend\n\t\tend\n\tend\n\tcount\nend", "  cars = []\n  cars +=\
    \ Array.new(n) { rand(-n..0) }\n  cars += Array.new(n) { rand(1..n) }\n  collisions\
    \ = 0\n  cars.each_with_index do |car, i|\n    cars.each_with_index do |car2,\
    \ j|\n      collisions += 1 if car == car2 && i != j\n    end\n  end\n  collisions\
    \ / 2\nend", "  # YOUR CODE HERE\nend", "  if n == 1\n    0\n  else\n    first\
    \ = (n - 1) * n\n    second = ((n - 1) * (n - 2)) / 2\n    first + second\n  end\n\
    end", "  # Let's draw an example.  Say n=10.\n  # This means that there are 10\
    \ cars moving from left to right and 10 cars moving\n  # from right to left. \
    \ I'll draw them as T's.  I won't worry about drawing the cars\n  # moving left\
    \ to right and right to left as separate symbols.  I'll just indicate\n  # the\
    \ direction by drawing the T's with their tails pointing in the right direction.\n\
    \  #\n  # A collision will occur when two oppositely traveling cars are at the\
    \ same position.\n  # So this is the same as asking, for each car that's traveling\
    \ left to right, how many\n  # cars traveling right to left are to its left. \
    \ Let's see how we can use math to make\n  # this easier to compute.\n  #\n  #\
    \ Start off with the cars very far from each other.  Then we can see that a car\n\
    \  # traveling left to right will collide with the first car traveling right to\
    \ left\n  # when the two cars get very close to each other.  That is, when the\
    \ car traveling\n  # left to right is only one step away from the car traveling\
    \ right to left.\n  # Then, when the car traveling left to right moves one step,\
    \ they collide.\n  #\n  # If a car traveling left to right collides with the first\
    \ car traveling right to left,\n  # then the car that's traveling left to right\
    \ must have been adjacent to\n  # the car traveling right to left.  If a car traveling\
    \ left to right collides with\n  # the second car traveling right to left, then\
    \ the car traveling left to right must\n  # have been two steps away from the\
    \ car traveling right to left.  Similarly, if a car\n  # traveling left to right\
    \ collides with the third car traveling right to left, then\n  # the car traveling\
    \ left to right must have been three steps away from the car\n  # traveling right\
    \ to left.\n  #\n  # The distance between a car traveling left to right and the\
    \ first car traveling\n  # right to left is same as the distance between the car\
    \ traveling left to right\n  # and the second car traveling right to left, minus\
    \ one.  That is, if a car traveling\n  # left to right collides with the third\
    \ car traveling right to left, then the\n  # car traveling left", "  count = 0\n\
    \  car = 0\n  cars = []\n  cars_rev = []\n  while car < n\n    cars << car\n \
    \   cars_rev << car\n    car += 1\n  end\n  cars_rev.reverse!\n  cars.each do\
    \ |car|\n    cars_rev.each do |car_rev|\n      if car_rev == car\n        count\
    \ += 1\n      end\n    end\n  end\n  count\nend", "  return 0 if n <= 1\n  mid\
    \ = n / 2\n  # If a car moving right to left bumps into a car moving left to right,\n\
    \  # and the left to right car is the kth car in the line, then the car moving\n\
    \  # right to left is the (n - k + 1)th car.  For example, if the left to right\n\
    \  # cars are [2, 5, 9, 3, 12, 5, 9], then the right to left cars are [1, 6, 10,\
    \ 4, 11, 7, 8].\n  # The collision happens when (right to left car) = (left to\
    \ right car), i.e.\n  # (n - k + 1) = k.  So the number of collisions is the number\
    \ of integers k\n  # such that k lies in the range [1, n] and (n - k + 1) = k.\n\
    \  # Since the left to right cars go from 1 to n, it makes sense that\n  # the\
    \ right to left cars go from n to 1.  The collision takes place when\n  # the\
    \ kth left to right car and the (n - k + 1)th right to left car meet,\n  # which\
    \ happens when 2k = n + 1.  So the number of collisions is the number\n  # of\
    \ k's in the range [1, n] such that 2k = n + 1.  That is, the number of\n  # k's\
    \ in the range [1, n] such that k = (n + 1) / 2.\n  return 1 if n.even?\n  return\
    \ 0\nend", "\tlefts = []\n\trights = []\n\tn.times do\n\t\tlefts << rand\n\t\t\
    rights << rand\n\tend\n\t#sorting\n\tlefts.sort!\n\trights.sort!\n\ti = 0\n\t\
    j = 0\n\t#linear search\n\twhile i < n && j < n\n\t\tif lefts[i] < rights[j]\n\
    \t\t\ti += 1\n\t\t\tj += 1\n\t\telse\n\t\t\tj += 1\n\t\tend\n\tend\n\treturn j\n\
    end", "  # We will solve this problem using a merge sort variant.\n  # We model\
    \ the cars in the form of a sorted array.  We start out with two arrays\n  # of\
    \ size n/2.  Each array is sorted.  The cars in the first array move from left\
    \ to right\n  # and the cars in the second array move from right to left.  For\
    \ example, we can model\n  # the left to right moving cars using the array [1,\
    \ 2, 3, 4] and the right to left moving\n  # cars using the array [10, 9, 8, 7].\n\
    \  #\n  # When all cars are at the same distance of the road, the position of\
    \ the cars are\n  # [1, 9, 2, 8, 3, 7, 4, 6].  How did we arrive at this ordering?\
    \  This is exactly\n  # the ordering we get by taking the sum of each element\
    \ in the array 1, 2, 3, 4 and\n  # adding it to each element in the array 10,\
    \ 9, 8, 7.\n  # So, when we just sum the positions of the cars, we get the result\n\
    \  # 1 + 9 + 2 + 8 + 3 + 7 + 4 + 6 = 40.\n  #\n  # To detect collisions, we need\
    \ to know when the cars are at the same position\n  # of the road.  This is easy\
    \ to detect.  We can just subtract each element in the first\n  # array to each\
    \ element in the second array.  For example, we can detect the collision\n  #\
    \ between 1 and 9 as well as the collision between 2 and 8, and so on.\n  #\n\
    \  # So, we will model the cars using two arrays of size n.  We will merge sort\
    \ the two arrays.\n  # Each element in the merged array will represent the sum\
    \ of the positions of the cars.\n  # To detect collisions, we will subtract each\
    \ element in the left half of the array from\n  # each element in the right half\
    \ of the array.\n  merged_array = []\n  collisions = 0\n  # Odd length array\n\
    \  if n % 2 == 1\n    left_array = Array.new(n/2) { |i| i + 1 }\n    right_array\
    \ = Array.new(n/2) { |i| n - i }\n   ", "  left_to_right = Array.new(n) { rand(0..n)\
    \ }\n  right_to_left = Array.new(n) { rand(0..n) }\n  puts \"left_to_right #{left_to_right}\"\
    \n  puts \"right_to_left #{right_to_left}\"\n  count = 0\n  (0..n - 1).each do\
    \ |i|\n    (0..n - 1).each do |j|\n      if left_to_right[i] > right_to_left[j]\n\
    \        count += 1\n      end\n    end\n  end\n  count\nend", "    # Memoization\
    \ (caching) is not needed here.\n    # Your solution here.\nend", "    collisions\
    \ = 0\n    cars = (1..n).to_a\n    cars.each do |car|\n        if (cars.include?(car))\n\
    \            collisions += 1\n        end\n    end\n    collisions\nend", "  points\
    \ = []\n  for i in 0..n-1\n    points[i] = i\n  end\n  for i in 0..n-1\n    points[i+n]\
    \ = n-1-i\n  end\n  merge_sort(points)\nend", "  collisions = 0\n  right_to_left\
    \ = Array.new(n, true)\n  left_to_right = Array.new(n, false)\n  while left_to_right.any?\
    \ && right_to_left.any?\n    collisions += 1 if left_to_right.pop && right_to_left.pop\n\
    \  end\n  collisions\nend", "  if n <= 0\n    return 0\n  end\n  # We can easily\
    \ prove that the number of collisions is\n  # n * (n - 1).\n  return n * (n -\
    \ 1)\nend", "  left = Array.new(n)\n  right = Array.new(n)\n  n.times do |i|\n\
    \    left[i] = i\n    right[i] = n-i-1\n  end\n  num = 0\n  while !left.empty?\
    \ && !right.empty?\n    i = left.shift\n    j = right.shift\n    num += 1 if i\
    \ == j\n  end\n  num\nend", "  # Brute force O(n^2) solution\n  # collisions =\
    \ 0\n  # for i in 0..n-1\n  #   for j in i+1..n-1\n  #     if right_to_left[i]\
    \ < left_to_right[j] && right_to_left[j] > left_to_right[i]\n  #       collisions\
    \ += 1\n  #     end\n  #   end\n  # end\n  # collisions", "  #todo\nend", "  #\
    \ first, we think about the trajectory of the first car in the left to right\n\
    \  # direction.  The car will collide with the last car in the right to left direction,\n\
    \  # then collide with the (n-1)th car in the right to left direction, then collide\n\
    \  # with the (n-2)th car in the right to left direction, etc.  In other words,\n\
    \  # the first car in the left to right direction will collide with (1 + 2 + 3\
    \ + ... + n)\n  # cars.  We'll call this number sum_of_n.\n  sum_of_n = n * (n\
    \ + 1) / 2", "  left_car_positions = []\n  right_car_positions = []\n  n.times\
    \ do |i|\n    left_car_positions << (n - i)\n    right_car_positions << i\n  end\n\
    \  merge_sort(left_car_positions, right_car_positions)\nend", "  cars_left = []\n\
    \  cars_right = []\n  (1..n).each do |i|\n    cars_left.push(i)\n    cars_right.push(i)\n\
    \  end\n  i = 0\n  (1..n).each do |j|\n    if j == cars_left[i]\n      cars_left.delete_at(i)\n\
    \      cars_right.delete_at(i)\n      i -= 1\n    end\n    i += 1\n  end\n  cars_left.length\n\
    end", "  # YOUR CODE HERE\nend", "\treturn 0 if n == 0\n\tsorted_speeds = 1.upto(n).map{|i|\
    \ i}.sort\n\tleft_to_right = sorted_speeds\n\tright_to_left = sorted_speeds.reverse\n\
    \t# print left_to_right, \"\\n\"\n\t# print right_to_left, \"\\n\"\n\tcount =\
    \ 0\n\t(n-1).downto(0).each do |i|\n\t\tif left_to_right[i] > right_to_left[i]\n\
    \t\t\t(0..i).each do |j|\n\t\t\t\tright_to_left[j] += 1\n\t\t\tend\n\t\t\tcount\
    \ += 1\n\t\tend\n\tend\n\treturn count\nend", "  n\nend", "  # edge case\n  if\
    \ n <= 0\n    puts \"Cars need to be inputted\"\n    return 0\n  end", "  num_collisions\
    \ = 0\n  car_positions = Array.new(n, nil)", "    return (n * (n - 1)) / 2\nend",
  "\t\nend", "  if n < 2\n    return 0\n  end\n  #slots = (n + 2) / 2 # (n + 2) is\
    \ the number of slots required to fit n + 2 cars, n cars going left and n cars\
    \ going right, (n + 2) is rounded up to the nearest integer\n  #car_locations\
    \ = Array.new(slots, 0) # we use 0 to mean that a slot is empty\n  #1.upto(n)\
    \ do |i|\n  #  car_locations[i] = -1 # we use -1 to mean a car moving left (from\
    \ left to right)\n  #  car_locations[car_locations.length - i] = 1 # we use 1\
    \ to mean a car moving right (from right to left)\n  #end\n  #\n  #puts \"car_locations:\
    \ #{car_locations}\"\n  #\n  #collisions = 0\n  #(car_locations.length - 1).times\
    \ do |i|\n  #  if car_locations[i] != 0 and car_locations[i + 1] != 0 and car_locations[i]\
    \ != car_locations[i + 1]\n  #    collisions += 1\n  #  end\n  #end\n  #return\
    \ collisions", "  collisions = 0\n  left = 0\n  right = 0\n  while left < n ||\
    \ right < n\n    if left < n\n      print(\"left car: #{left}\")\n      left +=\
    \ 1\n    end\n    if right < n\n      print(\"right car: #{right}\")\n      right\
    \ += 1\n    end\n    if left == right\n      collisions += 1\n    end\n  end\n\
    \  collisions\nend", "  pairs = []\n  n.times do |i|\n    pairs[i] = [rand(1..100),\
    \ rand(1..100)]\n  end\n  pairs.sort_by { |k, v| v }\n  pairs.count { |k, v| k\
    \ < v }\nend", "  left_to_right = (1..n).to_a\n  right_to_left = (1..n).to_a.reverse\n\
    \  collisions = 0\n  left_to_right.each do |i|\n    right_to_left.each do |j|\n\
    \      if i == j\n        collisions += 1\n      end\n    end\n  end\n  collisions\n\
    end", "  while n != 1\n    if n.even?\n      n = n / 2\n    else\n      n = 3\
    \ * n + 1\n    end\n  end\n  return n\nend", "  cars_from_left = (1..n).to_a\n\
    \  cars_from_right = (1..n).to_a.reverse", "  # For n cars going left, we start\
    \ out with one pair of colliding cars.\n  collisions = 1\n  left_to_right = true\n\
    \  right_to_left = false\n  # We have n cars, each of which is traveling at a\
    \ speed of 1.  This means that\n  # left_to_right_speed = 1 and right_to_left_speed\
    \ = 1.\n  car_count = 1\n  while car_count < n\n    left_to_right_speed = car_count\n\
    \    right_to_left_speed = left_to_right_speed + 1\n    left_to_right_distance\
    \ = left_to_right_speed\n    right_to_left_distance = right_to_left_speed\n  \
    \  left_to_right_index = 0\n    right_to_left_index = 0\n    # This loop will\
    \ end when the left to right and right to left cars\n    # meet at the middle.\n\
    \    while left_to_right_index < left_to_right_distance && right_to_left_index\
    \ < right_to_left_distance\n      if left_to_right_index == right_to_left_index\n\
    \        collisions += 1\n      end\n      # Each time a car moves, we need to\
    \ update the index to indicate its new location.\n      left_to_right_index +=\
    \ 1\n      right_to_left_index += 1\n    end\n    car_count += 1\n  end\n  collisions\n\
    end", "  # n.downto(0) do |i|\n  #   n.upto(2*n) do |j|\n  #     if (i - j).abs\
    \ == n\n  #       return i * (i-1) / 2 + j * (j-1) / 2\n  #     end\n  #   end\n\
    \  # end\n  2 * n * (n-1) + n\nend", "\t# TODO: implement me\n\tsum = 0\n\tfor\
    \ i in 1..n\n\t\tsum += i\n\tend\n\treturn sum\nend", "  i = 0\n  while i < n\n\
    \    j = 0\n    while j < n\n      if i == j\n        j += 1\n        next\n \
    \     end\n      if i < j\n        return i\n      end\n      j += 1\n    end\n\
    \    i += 1\n  end\n  return 0\nend", "\tcollisions = 0;\n\tcars_left_to_right\
    \ = 1..n;\n\tcars_right_to_left = 1..n;\n\twhile cars_left_to_right.any? || cars_right_to_left.any?\n\
    \t\tcollisions += 1 if cars_left_to_right.delete(cars_right_to_left.delete(collisions))\n\
    \tend\n\tcollisions\nend", "\treturn 0 if n == 0\n\treturn 1 if n == 1\n\treturn\
    \ (n * (n - 1)) / 2\nend", "  # write your solution here\n  results = []\n  #cars1\
    \ = (1..n).to_a\n  #cars2 = (1..n).to_a\n  cars1 = [[1, n],[2, n],[3, n],[4, n],[5,\
    \ n],[6, n],[7, n],[8, n],[9, n],[10, n]]\n  cars2 = [[1, n],[2, n],[3, n],[4,\
    \ n],[5, n],[6, n],[7, n],[8, n],[9, n],[10, n]]\n  cars1.each do |array|\n  \
    \  a = array[0]\n    b = array[1]\n    results << [a, b] if (a*b)%n == 0\n  end\n\
    \  cars2.each do |array|\n    a = array[0]\n    b = array[1]\n    results << [a,\
    \ b] if (a*b)%n == 0\n  end\n  results.length\nend", "  # initialize some variables\n\
    \  left_to_right = 0\n  right_to_left = 0\n  collisions = 0", "\t# This method\
    \ is destructive, so let's copy the array first.\n\t# Please note that this is\
    \ really a 3-dimensional array.\n\t# An element of the array is a line in a direction\
    \ of the cars.\n\t# For example, [[[0, 1], [2, 1], [3, 1]], [[0, -1], [1, -1],\
    \ [3, -1]]]\n\t# means that we have 3 cars moving right to left, and 2 cars moving\
    \ left to right.\n\t# The first element of an element is the position of the car.\n\
    \t# The second element of an element is the direction of the car.\n\tcars = [[[0,\
    \ 1]] * n, [[0, -1]] * n]\n\t# the number of collisions is 0 initially.\n\tcollisions\
    \ = 0\n\t# while there is at least one car in either direction:\n\twhile !cars[0].empty?\
    \ && !cars[1].empty?\n\t\t# call the function that finds the next collision.\n\
    \t\t# the function takes the cars and the first element of the cars array\n\t\t\
    # (which is the first direction in our cars array).\n\t\t# we then add the number\
    \ of collisions that we've found so far to the number\n\t\t# of collisions we've\
    \ found.\n\t\tcollisions += find_next_collision(cars, cars[0].first)\n\tend\n\t\
    # return the collisions.\n\tcollisions\nend", "  puts \"cars: #{n}\"\n  n.odd?\
    \ ? \"N/A\" : (1..n).inject(:+)\nend", "  if n < 1\n    return 0\n  else\n   \
    \ return 1 + car_race_collision(n - 1)\n  end\nend", "  # The move_right_cars\
    \ method returns a new array of cars that is the result of moving the\n  # given\
    \ array of cars 1 step to the right.\n  def move_right_cars(right_cars)\n    r\
    \ = right_cars.dup\n    (0...r.length).each do |i|\n      r[i] = r[i] + 1\n  \
    \  end\n    r\n  end", "  # your code here\n  collisions = 0\n  car1 = []\n  car2\
    \ = []\n  while(n > 0)\n    car1 << n\n    car2 << n\n    n -= 1\n  end\n  car1.each\
    \ do |c1|\n    car2.each do |c2|\n      if(c1 == c2)\n        collisions += 1\n\
    \      end\n    end\n  end\n  collisions\nend", "  # Fill this in.\n  # We can\
    \ solve this problem in O(n) time and O(1) space.\n  # This is an interesting\
    \ problem.\n  # For even n, suppose the original positions of the cars are\n \
    \ #    1, 2, 3, 4, 5, 6, 7, 8\n  # then the cars are paired as\n  #    1, 2, 3,\
    \ 4, 5, 6, 7, 8,\n  #    8, 7, 6, 5, 4, 3, 2, 1\n  # Then the cars on the bottom\
    \ line are moving to the left,\n  # while the cars on the top line are moving\
    \ to the right.\n  # There will be n/2 - 1 collisions, since cars are infinitely\
    \ sturdy.\n  # For odd n, the number of collisions is still n/2 - 1,\n  # except\
    \ that the last car which is staying put at the center of the road\n  # will never\
    \ collide with any other car.\n  # This yields a solution of (n - 1) / 2.\n  (n\
    \ - 1) / 2\nend", '    collisions = 0', "  return 0 if n <= 1\n  # Let's say the\
    \ cars moving left to right are cars a, b, c, d, e, and f.\n  # The cars moving\
    \ right to left are cars g, h, i, j, k, and l.\n  # For example, car a hits car\
    \ g, car b hits car h, car c hits car i, car d hits car j,\n  # car e hits car\
    \ k, and car f hits car l.\n  # There's exactly one way to arrange the cars to\
    \ have 0 collisions: put car a\n  # right behind car f.  That way, car g would\
    \ not hit any car.\n  # There's also exactly one way to arrange the cars to have\
    \ 1 collision: put car a\n  # right behind car f, and put car f right behind car\
    \ g.  Car g will collide with\n  # car f;  no other car collides with any other\
    \ car.\n  # There's also exactly one way to arrange the cars to have 2 collisions:\
    \ put car a\n  # right behind car f, put car f right behind car g, and put car\
    \ g right behind car a.\n  # Car g will collide with car f, and car a will collide\
    \ with car g.  No other car\n  # collides with any other car.\n  # If you continue\
    \ this pattern, you will see that the total number of collisions\n  # is equal\
    \ to the sum of the numbers from 1 to n.\n  # Does this pattern have a name? \
    \ It looks like the nth triangular number.\n  (1..n).reduce(&:+)\nend", "  # @param\
    \ {Integer} n\n  # @return {Integer}\n  i = j = collisions = 0\n  left = right\
    \ = []\n  while i < n\n    left[i] = n - i\n    i += 1\n  end\n  while j < n\n\
    \    right[j] = n - j\n    j += 1\n  end\n  i = j = 0\n  while i < n && j < n\n\
    \    if left[i] == right[j]\n      collisions += 1\n      i += 1\n      j += 1\n\
    \    elsif left[i] < right[j]\n      i += 1\n    else\n      j += 1\n    end\n\
    \  end\n  collisions\nend", "  set1 = (1..n).to_a.shuffle\n  set2 = (1..n).to_a.shuffle\n\
    \  count = 0\n  set1.each do |car1|\n    set2.each do |car2|\n      if car1 ==\
    \ car2\n        count += 1\n      end\n    end\n  end\n  count\nend", "    # COMPLETE\n\
    end", "  # Compute the number of collisions by subtracting the number of cars\
    \ that\n  # passed each other.\n  left_right_sorted = (1..n).sort\n  right_left_sorted\
    \ = (1..n).sort.reverse\n  passed_each_other = n\n  for i in 0..n-1\n    for j\
    \ in 0..n-1\n      if (left_right_sorted[i] < right_left_sorted[j])\n        passed_each_other\
    \ -= 1\n        break\n      end\n    end\n  end\n  return n - passed_each_other\n\
    end", "  # your code here\nend", "  max_speed = n + 1\n  min_speed = 1\n  right_to_left_speeds\
    \ = (1..n).to_a.reverse\n  left_to_right_speeds = (1..n).to_a\n  # puts \"Max\
    \ speed: #{max_speed}\"\n  # puts \"Left to right speeds: #{left_to_right_speeds}\"\
    \n  # puts \"Right to left speeds: #{right_to_left_speeds}\"\n  collisions = 0\n\
    \  (1..n).each do |index|\n    left_speed = left_to_right_speeds[index - 1]\n\
    \    right_speed = right_to_left_speeds[index - 1]\n    if left_speed == max_speed\n\
    \      # puts \"Left speed #{left_speed} is max speed, #{right_speed} will collide\
    \ with it\"\n      collisions += 1\n    elsif right_speed == min_speed\n     \
    \ # puts \"Right speed #{right_speed} is min speed, #{left_speed} will collide\
    \ with it\"\n      collisions += 1\n    elsif left_speed > right_speed\n     \
    \ # puts \"Left speed #{left_speed} is faster than right speed #{right_speed},\
    \ they will collide\"\n      collisions += 1\n    end\n  end\n  return collisions\n\
    end", "  # Write your code here!\nend", "  collisions = 0\n  pos = {}\n  n.times\
    \ do |i|\n    # at the start, car i starts at position i\n    pos[i] = i\n  end\n\
    \  n.times do |i|\n    # at the end of each second, car i moves 1 position\n \
    \   pos[i] += 1\n  end\n  n.times do |i|\n    j = pos.keys.select { |k| k != i\
    \ }.min_by { |k| pos[k] }\n    # car i and car j collide when they are in the\
    \ same position\n    collisions += 1 if pos[i] == pos[j]\n  end\n  collisions\n\
    end", "\t# Insert your code here.\n\tcars_came = Array.new(n)\n\tcars_left = Array.new(n)\n\
    \t0.upto(n-1) do |i|\n\t\tcars_came[i] = i\n\t\tcars_left[i] = i\n\tend\n\treturn\
    \ car_race_collision_helper(cars_came, cars_left)\nend", "  # Return value: an\
    \ integer.\n  # This function returns the number of collisions.\n  \n  # The cars\
    \ cannot collide unless they are moving opposite directions, one\n  # left to\
    \ right and the other right to left.\n  # \n  # Given a car moving left to right,\
    \ it must go beyond the \"left edge\" of the other\n  # car moving right to left\
    \ in order to collide with it.\n  # \n  # Similarly, given a car moving right\
    \ to left, it must go beyond the \"right edge\" of the\n  # other car moving left\
    \ to right in order to collide with it.\n  # \n  # Thus, given a car moving left\
    \ to right, we only need to find the number of cars\n  # moving right to left\
    \ that are \"close\" enough to it.  By symmetry, we only need to\n  # find the\
    \ number of cars moving left to right that are \"close\" enough to the car\n \
    \ # moving right to left.\n  # \n  # Thus, the number of collisions is equal to\
    \ the sum of the number of cars\n  # moving left to right that are close enough\
    \ to the cars moving right to left, and\n  # the number of cars moving right to\
    \ left that are close enough to the cars moving\n  # left to right.\n  # \n  #\
    \ The number of cars moving left to right that are close enough to the cars moving\n\
    \  # right to left is the sum of the number of cars moving right to left that\
    \ are close\n  # enough to each of the cars moving left to right.\n  # \n  # By\
    \ symmetry, the number of cars moving right to left that are close enough to the\
    \ cars\n  # moving left to right is the sum of the number of cars moving left\
    \ to right that are\n  # close enough to each of the cars moving right to left.\n\
    \  # \n  # Thus, the number of collisions is equal to twice the sum of the number\
    \ of cars\n  # moving right to left that are close enough to each of the cars\
    \ moving left to right.\n  # \n  # To compute this sum, we can use a binary search\
    \ to find the number of cars moving\n  # right to left that are close enough to\
    \ a particular car moving left to right, and\n  # similarly, a binary search to\
    \ find the number of cars moving left to right that", "  left_to_right = (1..n).to_a\n\
    \  right_to_left = (1..n).to_a.reverse\n  collisions = 0\n  left_to_right.each\
    \ do |car|\n    if right_to_left.include?(car)\n      collisions += 1\n    end\n\
    \  end\n  collisions\nend", "  cars_left = n.times.map{|i|i}.to_a\n  cars_right\
    \ = n.times.map{|i|i}.to_a\n  collisions = 0\n  while !cars_left.empty? && !cars_right.empty?\n\
    \    cars_left.map! do |pos|\n      pos + 1\n    end\n    cars_right.map! do |pos|\n\
    \      pos - 1\n    end\n    collisions += [cars_left.size, cars_right.size].min\n\
    \    cars_left.delete_if{|car| car > n}\n    cars_right.delete_if{|car| car <\
    \ 0}\n  end\n  collisions\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
