name: HumanEval_58_common
language: rb
prompt: "# Return sorted unique common elements for two arrays.\n# >>> common.call([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n\
  \    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5,\
  \ 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3,\
  \ 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"
completions: ["  (l1 & l2).sort\nend", "  l1.uniq.sort & l2.uniq.sort\nend", "  l1.select\
    \ { |e| l2.include?(e) }.uniq.sort\nend", "  (l1 & l2).sort.uniq\nend", "  l1\
    \ & l2\nend", "  return (l1 & l2).sort\nend", "  l1 & l2 & l1.uniq & l2.uniq\n\
    end", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", "  l1.uniq.sort\
    \ & l2.uniq.sort\nend", "  l1.uniq.sort & l2.uniq.sort\nend", "  l1.sort.uniq\
    \ & l2.sort.uniq\nend", "  l1.uniq.sort & l2.uniq.sort\nend", "  l1.uniq.sort\
    \ & l2.uniq.sort\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "  l1\
    \ & l2\nend", "  (l1 & l2).sort\nend", "  l1 & l2\nend", "  (l1 & l2).sort\nend",
  "  (l1 & l2).sort.uniq\nend", "  arr = []\n  l1.each { |i| arr << i if l2.include?(i)\
    \ }\n  arr.uniq.sort\nend", "  (l1 & l2).sort.uniq\nend", "  l1 & l2\nend", " \
    \ l1.uniq.sort & l2.uniq.sort\nend", "\tuniq_l1 = l1.uniq\n\tuniq_l2 = l2.uniq\n\
    \tcompare_l1_to_l2 = uniq_l1.select { |element| uniq_l2.include?(element) }\n\t\
    compare_l2_to_l1 = uniq_l2.select { |element| uniq_l1.include?(element) }\n\t\
    result = compare_l1_to_l2 + compare_l2_to_l1\n\tresult.uniq.sort\nend", "\t(l1\
    \ & l2).sort\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", " \
    \ (l1&l2).sort.uniq\nend", "  l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", " \
    \ l1 & l2\nend", "  l1.sort.uniq & l2.sort.uniq\nend", "  s1 = Set.new(l1)\n \
    \ s2 = Set.new(l2)\n  (s1 & s2).to_a.sort\nend\ncall = lambda { |a, b| common(a,\
    \ b) }", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", "\t(l1 &\
    \ l2).sort.uniq\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend",
  "  l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", " \
    \ l1 & l2\nend", "  puts \">>> common.call(#{l1}, #{l2})\"\n  l1 = l1.split(',').map(&:to_i)\n\
    \  l2 = l2.split(',').map(&:to_i)\n  (l1 & l2).sort.uniq\nend", "\tl1 & l2\nend",
  "    (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\nend", "\t(l1 & l2).sort.uniq\n\
    end", "  l1.uniq.sort & l2.uniq.sort\nend", "  l1 & l2\nend", "  l1.to_set.intersection(l2.to_set).to_a.sort\n\
    end", "  r = l1 & l2\n  r.sort!\n  return r\nend", "  l1.uniq.sort & l2.uniq.sort\n\
    end", "  # Accepts two arrays and returns a new array with sorted common elements.\n\
    \  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "  l1 & l2\nend", "  l1 & l2\n\
    end", "  # l1.uniq.sort & l2.uniq.sort\n  l1.uniq.sort.each_with_object([]) do\
    \ |item, result|\n    result << item if l2.include?(item)\n  end\nend", "  l1\
    \ & l2\nend", "  (l1 & l2).sort.uniq\nend", "\tl1.sort.uniq & l2.sort.uniq\nend",
  "\treturn l1 & l2\nend", "  h1 = {}\n  h2 = {}\n  for l in l1\n    h1[l] = true\n\
    \  end\n  for l in l2\n    h2[l] = true\n  end\n  result = []\n  for key in h1.keys\n\
    \    if h2.has_key?(key)\n      result << key\n    end\n  end\n  result.sort()\n\
    end", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend",
  "  l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", " \
    \ (l1 & l2).sort\nend", "  l1 & l2\nend", "  l1.sort.uniq & l2.sort.uniq\nend",
  "  return l1 & l2\nend", "\treturn l1 & l2\nend", "    puts (l1 & l2).sort\nend\n\
    common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\ncommon([5, 3, 2,\
    \ 8], [3, 2])", "  l1.to_set.intersection(l2.to_set).to_a.sort\nend", "  (l1 &\
    \ l2).sort.uniq\nend", "    l1.uniq.sort & l2.uniq.sort\nend", "  (l1 & l2).sort.uniq\n\
    end", "    u = Hash.new(0)\n    res = []\n    if l1.length > l2.length\n     \
    \   l1.each { |i| u[i] += 1 }\n        l2.each { |i| u[i] += 1 }\n    else\n \
    \       l2.each { |i| u[i] += 1 }\n        l1.each { |i| u[i] += 1 }\n    end\n\
    \    u.each { |k, v| res << k if v == 2 }\n    res.sort\nend", "  (l1 & l2).sort.uniq\n\
    end", "  l1 & l2\nend", "    (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend",
  "  l1.select { |num| l2.include?(num) }.uniq.sort\nend", "  l1 & l2\nend", "  (l1\
    \ & l2).sort\nend", "    l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 &\
    \ l2).sort.uniq\nend", "  # 1,4,3,34,653,2,5\n  # 5,7,1,5,9,653,121\n  # [1,5,653]\n\
    \  # O(nlogn) + O(m(logm))\n  l1.sort.uniq & l2.sort.uniq\nend", "  l1.uniq.sort\
    \ & l2.uniq.sort\nend", "  puts \"common \" + (l1 & l2).sort.to_s\nend", "  #\
    \ Sorted uniqe common elements\n  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend",
  "  (l1 & l2).sort!\nend\ncommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n\
    common([5, 3, 2, 8], [3, 2])", "  (l1 & l2).sort\nend", "  l1.uniq.sort & l2.uniq.sort\n\
    end", "  l1.sort.uniq & l2.sort.uniq\nend", "  l1 & l2\nend", "  l1 & l2\nend",
  "  l1 & l2\nend", "  if l1.nil? || l2.nil?\n    return []\n  end\n  l1.sort!\n \
    \ l2.sort!\n  result = []\n  i = 0\n  j = 0\n  while i < l1.length && j < l2.length\n\
    \    while i < l1.length && l1[i] < l2[j]\n      i += 1\n    end\n    while j\
    \ < l2.length && l2[j] < l1[i]\n      j += 1\n    end\n    if i < l1.length &&\
    \ j < l2.length && l1[i] == l2[j]\n      result << l1[i]\n      i += 1\n     \
    \ j += 1\n    end\n  end\n  result\nend", "  (l1 & l2).sort.uniq\nend", "  l1\
    \ & l2\nend", "\tl1 & l2\nend", "  l1.sort.uniq & l2.sort.uniq\nend", "\tputs\
    \ \"common(#{l1}, #{l2})\"\n\t(l1 & l2).sort\nend", "  l1 & l2\nend", "  #l1 &\
    \ l2\n  l1.select { |el| l2.include?(el) }.uniq.sort\nend", "  return nil if l1.nil?\
    \ or l2.nil?\n  unless l1.is_a?(Array) and l2.is_a?(Array)\n    raise 'Wrong input\
    \ data! Inputs should be arrays.'\n  end\n  l1 & l2\nend", "  (l1 & l2).sort.uniq\n\
    end", "  (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\n\
    end", "  (l1 & l2).sort.uniq\nend", "  l1 & l2\nend", "  (l1 & l2).sort.uniq\n\
    end", "  (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\n\
    end", "  (l1 & l2).sort.uniq\nend", "  l1 & l2\nend", "  # Takes two lists and\
    \ returns a list of the common elements they share,\n  # sorted alphabetically,\
    \ as a string.", "  (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  # @calls\
    \ += 1\n  if (l1.size < l2.size)\n    common(l2, l1)\n  else\n    l1.uniq.select\
    \ { |e| l2.include?(e) }.sort\n  end\nend", "  (l1 & l2).sort.uniq\nend", "  (l1\
    \ & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\nend", " \
    \ (l1 & l2).sort\nend", "    l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", "  (l1\
    \ & l2).sort.uniq\nend", "  l1.uniq.sort & l2.uniq.sort\nend", "  array = l1 &\
    \ l2\n  array.sort\nend", "  (l1 & l2).sort.uniq\nend", "  # YOUR CODE HERE\n\
    end", "  (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\n\
    end", "  (l1 & l2).sort\nend", "  [l1, l2].min.uniq.select{|n| l1.include?(n)\
    \ && l2.include?(n)}\nend", "  a1 = l1.sort\n  a2 = l2.sort\n  a1.each do |n|\n\
    \    if a2.include?(n)\n      a2.delete(n)\n      a1.delete(n)\n      break\n\
    \    end\n  end\n  a1\nend", "  return [] if l1.empty? || l2.empty?\n  return\
    \ l1 & l2\nend", "  (l1 & l2).sort!\nend", "  s = l1 & l2\n  s.sort.uniq\nend",
  "  (l1 & l2).sort\nend", "  l1 & l2\nend", "  # write your code here\nend", "  (l1\
    \ & l2).sort\nend", "  return l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", " \
    \ l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", "  l1.uniq.sort & l2.uniq.sort\n\
    end", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", "  l1 & l2\n\
    end", "  l1 & l2\nend", "  l1.uniq.sort & l2.uniq.sort\nend", "  (l1 & l2).sort\n\
    end", "  l1 & l2\nend", "  # l1.each do |i|\n  #   puts i\n  # end\n  l1.uniq.sort\
    \ & l2.uniq.sort\nend", "\t(l1 & l2).sort\nend", "  l1.select { |i| l2.include?(i)\
    \ }.uniq.sort\nend", "    (l1 & l2).sort\nend", "  l1.select { |el| l2.include?(el)\
    \ }.uniq.sort\nend", "  l1 & l2\nend", "    return (l1 & l2).sort\nend", "  (l1\
    \ & l2).sort.uniq\nend", "  (l1 & l2).sort\nend", "  l1 & l2\nend", "  l1.sort.uniq\
    \ & l2.sort.uniq\nend", "  l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", "  (l1\
    \ & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", "  l1.uniq.sort & l2.uniq.sort\n\
    end", "  (l1 & l2).sort.uniq\nend", "  return nil if l1.length == 0 || l2.length\
    \ == 0\n  l1.sort.uniq & l2.sort.uniq\nend\np common([1, 4, 3, 34, 653, 2, 5],\
    \ [5, 7, 1, 5, 9, 653, 121])", "\tarr = []\n\tl1.each do |a|\n\t\tl2.each do |b|\n\
    \t\t\tif a == b\n\t\t\t\tarr << a\n\t\t\tend\n\t\tend\n\tend\n\treturn arr.uniq.sort\n\
    end", "  (l1 & l2).sort\nend", "  # TODO: Return the sorted unique common elements\n\
    \  (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\nend",
  "  l1 & l2\nend", "  l1.uniq.sort & l2.uniq.sort\nend", "  (l1 & l2).sort\nend",
  "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\n\
    end", "  l1.sort.uniq & l2.sort.uniq\nend", "    new_arr = []\n    l1.each do\
    \ |num|\n        if l2.include?(num)\n            new_arr << num\n        end\n\
    \    end\n    new_arr.uniq.sort\nend", "  (l1 & l2).sort.uniq\nend", "  l1 & l2\n\
    end", "  set1 = l1.to_set\n  set2 = l2.to_set\n  set1.intersection(set2).to_a.sort\n\
    end", "  l1 & l2\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
