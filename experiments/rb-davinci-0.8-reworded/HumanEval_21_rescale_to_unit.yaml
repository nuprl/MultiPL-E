name: HumanEval_21_rescale_to_unit
language: rb
prompt: "# Given array of numbers (of at least two elements), apply a linear transform\
  \ to that array,\n# such that the smallest number will become 0 and the largest\
  \ will become 1\n# >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0,\
  \ 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n\
  \    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0,\
  \ 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0,\
  \ 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\n\
  end\n"
completions: ["  max = numbers.max\n  min = numbers.min\n  new_numbers = []\n  numbers.each\
    \ do |number|\n    new_numbers << ((number - min) / (max - min))\n  end\n  new_numbers\n\
    end", "  max = numbers.max\n  numbers.map { |n| n / max }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |num| (num - min) / (max - min) }\nend",
  "  # TODO: implement this method\nend", "  largest = numbers.max\n  smallest = numbers.min\n\
    \  numbers.map do |n|\n    (n - smallest) / (largest - smallest)\n  end\nend",
  "  # raise NotImplementedError\n  (numbers.map{|x| x.to_f} - numbers.min).map{|x|\
    \ x / (numbers.max - numbers.min)}\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |n| (n - min).to_f / (max - min) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  scale = max - min\n  numbers.map { |number| (number -\
    \ min) / scale }\nend", "  # FIXME\nend", "  # TODO: implement\nend", "  min =\
    \ numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max - min)\
    \ }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n -\
    \ min) / (max - min) }\nend", "  min, max = numbers.minmax\n  numbers.map { |n|\
    \ (n - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |n| (n - min).to_f / (max - min) }\nend", "  [numbers.min, numbers.max].map\
    \ { |number| (number - numbers.min) / (numbers.max - numbers.min) }\nend", " \
    \ min = numbers.min.to_f\n  max = numbers.max.to_f\n  numbers.map { |n| (n - min)\
    \ / (max - min) }\nend", "  max = numbers.max.to_f\n  min = numbers.min.to_f\n\
    \  numbers.map{|n| (n - min) / (max - min)}\nend", "  max = numbers.max\n  min\
    \ = numbers.min\n  numbers.map { |n| (n - min) / (max - min) }\nend", "  return\
    \ [] if numbers.empty?\n  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |n| (n - min) / (max - min) }\nend", "  numbers.minmax.map { |number| (number\
    \ - numbers.min) / (numbers.max - numbers.min) }\nend", "  max_numbers = numbers.max\n\
    \  min_numbers = numbers.min\n  numbers.map { |item| (item - min_numbers) / (max_numbers\
    \ - min_numbers) }\nend", "    normalized = []\n    max = numbers.max\n    min\
    \ = numbers.min\n    numbers.each do |number|\n        normalized << (number -\
    \ min) / (max - min)\n    end\n    normalized\nend", "  arr = numbers.clone\n\
    \  arr.sort!\n  range = arr.last - arr.first\n  arr.map { |n| (n - arr.first).to_f\
    \ / range }\nend", "  # Find the minimum and maximum element\n  min = numbers.min\n\
    \  max = numbers.max", "  max = numbers.max\n  min = numbers.min\n  numbers.map\
    \ { |n| (n - min) / (max - min) }\nend", "  mi = numbers.min\n  ma = numbers.max\n\
    \  numbers.map { |x| (x - mi) / (ma - mi) }\nend", "  maximum = numbers.max\n\
    \  minimum = numbers.min\n  numbers.map { |number| ((number - minimum) / (maximum\
    \ - minimum)) }\nend", "  max_number = numbers.max\n  min_number = numbers.min\n\
    \  difference = max_number - min_number\n  if difference.nonzero?\n    numbers.map\
    \ { |number| (number - min_number) / difference }\n  else\n    Array.new(numbers.size,\
    \ 0.5)\n  end\nend", "  min, max = numbers.minmax\n  numbers.map { |n| (n - min).to_f\
    \ / (max - min) }\nend", "  numbers.map { |number| (number - numbers.min) / (numbers.max\
    \ - numbers.min) }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |x| (x - min) / (max - min) }\nend", "  min, max = numbers.minmax\n  numbers.map\
    \ { |x| (x.to_f - min) / (max - min) }\nend", "  minimum = numbers.min\n  maximum\
    \ = numbers.max\n  numbers.map { |n| (n - minimum).to_f / (maximum - minimum)\
    \ }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |number|\
    \ (number - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  # use the built-in map method to apply the same function to each item in the\
    \ array\n  numbers.map { |x| (x - min) / (max - min) }\nend", "  mi = numbers.min\n\
    \  ma = numbers.max\n  numbers.map{|x| (x - mi) / (ma - mi)}\nend", "  (numbers.min..numbers.max).step(1.0\
    \ / (numbers.size - 1)).to_a\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  len = numbers.length\n  numbers.map{|x| (x - min) / (max - min)}\nend", " \
    \ numbers.map do |number|\n    (number - numbers.min) / (numbers.max - numbers.min)\n\
    \  end\nend", "  raise ArgumentError.new(\"Array of numbers must contain at least\
    \ two elements\") if numbers.size < 2\n  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |number| (number - min) / (max - min) }\nend", "  (numbers.map\
    \ { |x| (x.to_f - numbers.min) / (numbers.max - numbers.min) }).tap { |x| puts\
    \ x }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map { |n| (n\
    \ - min) / (max - min) }\nend", "  numbers.map { |number| (number - numbers.min)\
    \ / (numbers.max - numbers.min) }\nend", "  min, max = numbers.minmax\n  numbers.map\
    \ { |n| (n - min) / (max - min) }\nend", "  max = numbers.max\n  min = numbers.min\n\
    \  numbers.map { |x| x = (x - min) / (max - min) }\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  numbers.map { |number| (number - min) / (max - min) }\n\
    end", "  array = []\n  numbers.each do |number|\n    array << (number - numbers.min)\
    \ / (numbers.max - numbers.min)\n  end\n  array\nend", "  raise \"Argument must\
    \ be an array\" unless numbers.is_a?(Array)\n  raise \"Argument must have at least\
    \ two elements\" unless numbers.length >= 2", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |n| (n - min) / (max - min) }\nend", "  max = numbers.max\n \
    \ min = numbers.min\n  numbers.map { |n| (n - min) / (max - min) }\nend", "  if\
    \ numbers.empty?\n    []\n  else\n    max = numbers.max\n    min = numbers.min\n\
    \    range = max - min\n    numbers.map { |n| (n - min) / range }\n  end\nend",
  "  numbers.map do |number|\n    (number - numbers.min) / (numbers.max - numbers.min)\n\
    \  end\nend", "  # compute the minimum and maximum of the input array\n  # then\
    \ rescale each number to 0..1\n  # return new array of rescaled numbers\n  min\
    \ = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max - min)\
    \ }\nend", "  normalized = normalize(numbers)\n  normalized.map { |num| num *\
    \ (1 - 0) + 0 }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |n| (n.to_f - min) / (max - min) }\nend", "  min, max = numbers.minmax\n \
    \ numbers.map { |x| (x - min) / (max - min) }\nend", "  return 0.0 if numbers.length\
    \ == 0\n  max = numbers.max\n  min = numbers.min\n  return numbers.map { |x| (x\
    \ - min) / (max - min) }\nend", "  min = numbers.min\n  range = numbers.max -\
    \ min\n  if range == 0\n    return numbers.map { |n| 0.0 }\n  end\n  numbers.map\
    \ { |n| (n - min) / range }\nend", "  min, max = numbers.minmax\n  numbers.map{|v|\
    \ v.to_f / (max - min) }\nend", "  min = numbers.min\n  scale = 1.0 / (numbers.max\
    \ - min)\n  numbers.map { |n| (n - min) * scale }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map{|x| (x - min) / (max - min)}\nend", "  old_min\
    \ = numbers.min\n  old_max = numbers.max\n  old_range = old_max - old_min\n  numbers.map\
    \ do |n|\n    (n - old_min) / old_range\n  end\nend", "    min = numbers.min\n\
    \    max = numbers.max\n    if max == min\n        numbers.each_with_index do\
    \ |number, index|\n            numbers[index] = 1.0\n        end\n    else\n \
    \       numbers.each_with_index do |number, index|\n            numbers[index]\
    \ = (number - min) / (max - min)\n        end\n    end\n    numbers\nend", " \
    \ min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max\
    \ - min) }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n|\
    \ (n - min).to_f / (max - min) }\nend", "  mx = numbers.max\n  mn = numbers.min\n\
    \  numbers.map { |n| (n - mn) / (mx - mn) }\nend", "  min = numbers.min\n  max\
    \ = numbers.max\n  numbers.map { |number| (number - min) / (max - min) }\nend",
  "  numbers.map { |n| n / numbers.max }\nend", "  min, max = numbers.minmax\n  numbers.map\
    \ { |num| (num - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  range = max - min\n  numbers.map { |x| (x - min) / range }\nend", "  min =\
    \ numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min).to_f / (max\
    \ - min) }\nend", "  return numbers.map { |i| (i - numbers.min) / (numbers.max\
    \ - numbers.min).to_f }\nend", "  max_number = numbers.max\n  min_number = numbers.min\n\
    \  numbers.map { |number| (number - min_number) / (max_number - min_number) }\n\
    end", "  numbers.map { |n| (n - numbers.min).to_f / (numbers.max - numbers.min)\
    \ }\nend", "  # YOUR CODE HERE\nend", "  numbers.map do |number|\n    (number\
    \ - numbers.min) / (numbers.max - numbers.min)\n  end\nend", "  min, max = numbers.minmax\n\
    \  numbers.map{|n| (n - min).to_f / (max - min)}\nend", "  numbers.map{|n| (n\
    \ - numbers.min) / (numbers.max - numbers.min)}\nend", "  # your code goes here\n\
    end", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min).to_f\
    \ / (max - min) }\nend", "    min = numbers.min\n    max = numbers.max\n    numbers.map\
    \ { |n| ((n - min) / (max - min)) }\nend", "  numbers = [numbers] unless numbers.is_a?(Array)\n\
    \  raise ArgumentError.new('A non-empty array of numbers is required') unless\
    \ numbers.is_a?(Array) && numbers.count > 0 && numbers.all? { |n| n.is_a?(Numeric)\
    \ }", "  numbers = numbers.clone\n  min = numbers.min\n  max = numbers.max\n \
    \ numbers.map! { |n| (n - min) / (max - min) }\nend", "  (numbers.min..numbers.max).step(0.00001).map\
    \ { |n| (numbers.min - n).abs }\nend", "  max = numbers.max\n  min = numbers.min\n\
    \  numbers.map { |n| (n - min).to_f / (max - min) }\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  delta = max - min\n  numbers.map { |number| (number -\
    \ min) / delta }\nend", "  numbers = numbers.dup\n  range = numbers.max - numbers.min\n\
    \  raise ArgumentError, \"numbers must have at least two elements\" if range ==\
    \ 0\n  numbers.map { |x| (x - numbers.min) / range }\nend", "  # TODO: implement!\n\
    end", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min)\
    \ / (max - min) }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map{|num|\
    \ (num - min) / (max - min)}\nend", "  numbers.map { |number| (number - numbers.min)\
    \ / (numbers.max - numbers.min) }\nend", "  linear_transform(numbers, 0.0, 1.0)\n\
    end", "  numbers.map { |n| (n - numbers.min) / (numbers.max - numbers.min) }\n\
    end", "  [numbers.min, numbers.max].tap do |values|\n    min = values.first\n\
    \    max = values.last\n    numbers.map! { |v| (v - min) / (max - min) }\n  end\n\
    end", "  minimum = numbers.min\n  maximum = numbers.max\n  numbers.map { |number|\
    \ (number - minimum).to_f / (maximum - minimum) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |number| (number - min) / (max - min) }\n\
    end", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |number| (number\
    \ - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |n| (n - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |number| (number - min) / (max - min) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |number| (number - min) / (max - min) }\n\
    end", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n.to_f -\
    \ min) / (max - min) }\nend", "  return numbers if numbers.nil?\n  return numbers\
    \ if numbers.size < 2\n  min, max = numbers.minmax\n  numbers.map { |number| (number\
    \ - min) / (max - min) }\nend", "  (numbers.min..numbers.max).step(0.01).map do\
    \ |x|\n    to_unit(x, numbers.min, numbers.max)\n  end\nend", "  puts \"will rescale\
    \ #{numbers} to unit-scale\"\n  min = numbers.min\n  max = numbers.max\n  puts\
    \ \"min: #{min}, max: #{max}\"\n  numbers.map do |number|\n    # calculate a number\
    \ between 0 and 1\n    ((number - min) / (max - min)).round(2)\n  end\nend", " \
    \ if numbers.length > 1\n    min = numbers.min\n    max = numbers.max\n    range\
    \ = max - min\n    numbers.map { |n| (n - min) / range }\n  else\n    numbers\n\
    \  end\nend", "  min, max = numbers.minmax\n  numbers.map { |n| (n - min) / (max\
    \ - min) }\nend", "  min, max = numbers.minmax\n  numbers.map { |n| (n - min)\
    \ / (max - min) }\nend", "  min = numbers.min\n  numbers.map { |n| (n.to_f - min)\
    \ / (numbers.max - min) }\nend", "  min, max = numbers.minmax\n  numbers.map {\
    \ |x| (x - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |n| (n - min) / (max - min) }\nend", "  max = numbers.max.to_f\n\
    \  min = numbers.min.to_f\n  numbers.map { |n| (n - min) / (max - min) }\nend",
  "  numbers.map { |number| number - numbers.min }.map { |number| number / numbers.max\
    \ }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map{|number| (number\
    \ - min) / (max - min)}\nend", "  numbers.map { |num| (num - numbers.min) / (numbers.max\
    \ - numbers.min) }\nend", "  min = numbers.min\n  max = numbers.max\n  delta =\
    \ max - min\n  return [] if delta == 0", "  lowest = numbers.min\n  highest =\
    \ numbers.max\n  diff = highest - lowest\n  numbers.map { |number| (number - lowest)\
    \ / diff }\nend", "  min = numbers.min\n  max = numbers.max\n  return numbers.map\
    \ { |n| (n - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |e| (e - min) / (max - min) }\nend", "  min = numbers.min\n \
    \ max = numbers.max\n  numbers.map { |x| (x - min) / (max - min) }\nend", "  top\
    \ = numbers.max.to_f\n  bottom = numbers.min.to_f\n  scale = 1.0 / (top - bottom)\n\
    \  numbers.map { |n| (n - bottom) * scale }\nend", "  numbers.map{|x| (x-numbers.min)/(numbers.max-numbers.min)}\n\
    end", "  min, max = numbers.minmax\n  numbers.map { |number|\n    (number - min)\
    \ / (max - min)\n  }\nend", "  max = numbers.max\n  min = numbers.min\n  return\
    \ numbers.map { |number| (number - min) / (max - min) }\nend", "  minimum = numbers.min\n\
    \  step = numbers.max - minimum\n  numbers.map { |number| (number - minimum) /\
    \ step }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |e|\
    \ (e - min).to_f / (max - min) }\nend", "  minimum = numbers.min\n  maximum =\
    \ numbers.max\n  numbers.map { |number| (number - minimum) / (maximum - minimum)\
    \ }\nend", "  numbers.map do |number|\n    rescale_to_unit_single(number, numbers.min,\
    \ numbers.max)\n  end\nend", "  numbers.map { |number| number.to_f / numbers.max\
    \ }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n -\
    \ min) / (max - min) }\nend", "  numbers.map { |n| n / numbers.max }\nend", " \
    \   max = numbers.max\n    min = numbers.min\n    range = max - min\n    return\
    \ numbers.map { |number| (number - min) / range }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |number| (number - min) / (max - min) }\n\
    end", "  numbers.map do |n|\n    (n - numbers.min) / (numbers.max - numbers.min)\n\
    \  end\nend", "  min, max = numbers.minmax\n  numbers.map { |number| (number -\
    \ min) / (max - min) }\nend", "  return numbers if numbers.min == numbers.max\n\
    \  numbers.map { |num| (num - numbers.min) / (numbers.max - numbers.min) }\nend",
  "  min = numbers.min\n  max = numbers.max\n  minmax = max - min\n  numbers.map {\
    \ |num| (num - min) / minmax }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |n| (n - min) / (max - min) }\nend", "  (numbers.min..numbers.max).step(numbers.max\
    \ - numbers.min).to_a\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |number| (number - min) / (max - min) }\nend", "  # your code here\nend",
  "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max\
    \ - min) }\nend", "  numbers.minmax.inject { |scale, number|\n    number.to_f\
    \ / scale\n  }.map { |number|\n    number.to_f / numbers.max\n  }\nend", "  max\
    \ = numbers.max\n  min = numbers.min\n  numbers.map { |number| (number - min)\
    \ / (max - min) }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map\
    \ { |i| (i - min) / (max - min) }\nend", "  return [] if numbers.nil? || numbers.empty?\n\
    \  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| n.to_f / max.to_f\
    \ }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |x| (x -\
    \ min) / (max - min) }\nend", "  numbers.map { |n| (n - numbers.min) / (numbers.max\
    \ - numbers.min) }\nend", "  numbers.map{|number| (number - numbers.min).to_f\
    \ / (numbers.max - numbers.min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |number| (number - min) / (max - min) }\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  delta = max - min\n  return numbers.map { |number| (number\
    \ - min) / delta }\nend", "  min, max = numbers.minmax\n  numbers.map { |i| (i\
    \ - min) / (max - min) }\nend", "  limits = [numbers.max, numbers.min]\n  numbers.map\
    \ do |number|\n    (number - limits[1]) / (limits[0] - limits[1])\n  end\nend",
  "  min, max = numbers.minmax\n  numbers.map { |n| (n - min) / (max - min) }\nend",
  "  numbers.map{|n| Float(n) / numbers.max}\nend", "  raise 'Not implemented'\nend",
  "  factor = 1.0 / (numbers.max - numbers.min)\n  numbers.map{|number| (number -\
    \ numbers.min) * factor}\nend", "  numbers.map do |number|\n    (number - numbers.min)\
    \ / (numbers.max - numbers.min)\n  end\nend", "  numbers.map { |num| (num - numbers.min)\
    \ / (numbers.max - numbers.min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |number| (number - min) / (max - min) }\nend", "  minimum = numbers.min\n\
    \  maximum = numbers.max\n  if maximum > minimum\n    delta = maximum - minimum\n\
    \    numbers.map { |number| (number - minimum) / delta }\n  else\n    numbers.map\
    \ { |number| 0.0 }\n  end\nend", "  max = numbers.max\n  min = numbers.min\n \
    \ numbers.map { |n| (n - min) / (max - min) }\nend", "  numbers.map { |number|\
    \ (number - numbers.min) / (numbers.max - numbers.min) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |n| (n - min) / (max - min) }\nend", " \
    \ maximum = numbers.max.to_f\n  minimum = numbers.min.to_f\n  numbers.map { |number|\
    \ (number - minimum) / (maximum - minimum) }\nend", "  min = numbers.min\n  max\
    \ = numbers.max\n  numbers.map { |n| (n - min) / (max - min) }\nend", "  min =\
    \ numbers.min\n  max = numbers.max\n  numbers.map{|num| (num - min) / (max - min)}\n\
    end", "  min = numbers.min\n  max = numbers.max\n  range = max - min\n  numbers.map\
    \ { |number| (number - min) / range }\nend", "  max = numbers.max\n  min = numbers.min\n\
    \  numbers.map { |n| (n - min) / (max - min) }\nend", "  max = numbers.max\n \
    \ numbers.map { |number| number.to_f / max }\nend", "  max_num = numbers.max\n\
    \  min_num = numbers.min\n  numbers.map { |number| (number - min_num) / (max_num\
    \ - min_num) }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map\
    \ { |x| (x - min) / (max - min) }\nend", "  # TODO: implement me!\nend", "  min\
    \ = numbers.min.to_f\n  max = numbers.max.to_f\n  numbers.map{|n| (n - min) /\
    \ (max - min)}\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |n| ((n - min) / (max - min)) }\nend", "  max_number = numbers.max\n  min_number\
    \ = numbers.min\n  numbers.map { |num| (num - min_number) / (max_number - min_number)\
    \ }\nend", "  MinMaxScaler.new(numbers).call\nend", "  max_value = numbers.max\n\
    \  numbers.map { |number| number / max_value }\nend", "  max = numbers.max\n \
    \ min = numbers.min\n  numbers.map { |number| (number - min) / (max - min) }\n\
    end", "  (numbers.min..numbers.max).step(numbers.max - numbers.min).to_a\nend",
  "  min = numbers.min\n  range = numbers.max - min\n  numbers.map { |i| i - min /\
    \ range }\nend", "  # your code here\nend", "  smallest = numbers.min\n  largest\
    \ = numbers.max\n  numbers.map { |n| (n - smallest) / (largest - smallest) }\n\
    end", "  numbers.map { |n| (n - numbers.min) / (numbers.max - numbers.min) }\n\
    end", "  numbers.minmax.reverse.reduce(numbers) do |result, number|\n    result.map\
    \ { |x| x == number ? 1.0 : x }\n  end\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |n| (n - min) / (max - min) }\nend", "  min = numbers.min\n \
    \ max = numbers.max\n  numbers.map { |n| (n - min).to_f / (max - min) }\nend",
  "  # TODO: implement this\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |number| (number - min) / (max - min) }\nend", "  min = numbers.min\n  max\
    \ = numbers.max\n  numbers.map { |n| (n - min) / (max - min) }\nend", "  #find\
    \ the max and min of the given array\n  min = numbers.min.to_f\n  max = numbers.max.to_f\n\
    \  #find the difference between the max and min\n  difference = max - min\n  #iterate\
    \ through each number in the given array\n  #find the new value by subtracting\
    \ the min from the number\n  #and dividing by the difference.  push the new value\
    \ to the new array\n  new_array = []\n  numbers.each do |n|\n    new_array <<\
    \ (n - min) / difference\n  end\n  #return the new array\n  new_array\nend", " \
    \ # Code goes here...\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |number| (number - min) / (max - min) }\nend", "  min = numbers.min\n  max\
    \ = numbers.max\n  numbers.map { |n| (n - min) / (max - min) }\nend", "  minimum\
    \ = numbers.min\n  maximum = numbers.max\n  numbers.map { |n| (n - minimum) /\
    \ (maximum - minimum) }\nend", "  min = numbers.min\n  max = numbers.max\n  rescaled\
    \ = []\n  numbers.each do |x|\n    rescaled << (x - min) / (max - min)\n  end\n\
    \  rescaled\nend", "  minimum = numbers.min\n  maximum = numbers.max\n  range\
    \ = maximum - minimum\n  return [] if range == 0\n  numbers.map{|n| (n - minimum)\
    \ / range}\nend", "  range = numbers.max - numbers.min\n  numbers.map { |n| (n\
    \ - numbers.min) / range }\nend", "  max = numbers.max\n  min = numbers.min\n\
    \  numbers.map{|number| (number - min)/(max - min)}\nend", "  max = numbers.max\n\
    \  numbers.map { |x| x / max }\nend", "  Array.new(numbers.length) do |index|\n\
    \    ((numbers[index] - numbers.min) / (numbers.max - numbers.min)).round(2)\n\
    \  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
