name: HumanEval_87_get_row
language: rb
prompt: "# You are given a 2 dimensional data, as a nested arrays,\n# which is similar\
  \ to matrix, however, unlike matrices,\n# each row may contain a different number\
  \ of columns.\n# Given lst, and integer x, find integers x in the array,\n# and\
  \ return array of arrays, [(x1, y1), (x2, y2) ...] such that\n# each array is a\
  \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially by\
  \ rows in ascending order.\n# Also, sort coordinates of the row by columns in descending\
  \ order.\n# Examples:\n# >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
  \ [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([],\
  \ 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst,\
  \ x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
  \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
  \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
  \ 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5,\
  \ 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0,\
  \ 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6,\
  \ 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
  \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
  \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
  \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
  \ [1, 2, 3]], 3))\n  end\nend\n"
completions: ["  res = []\n  lst.each_with_index do |a,i|\n    a.each_with_index do\
    \ |b,j|\n      res << [i,j] if b == x\n    end\n  end\n  res.sort_by!{|e| [e[0],\
    \ -e[1]]}\nend", "  # your code here\nend", "  lst.map.with_index { |x1, i| x1.map.with_index\
    \ { |x2, j| [i, j] if x2 == x } }.flatten(1).compact.sort_by { |x1, x2| [x1, -x2]\
    \ }\nend", "  x_indices = Hash.new\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      x_indices[[i, j]] = true if col == x\n    end\n  end\n  x_indices.keys.sort_by{|x,\
    \ y| [x, -y]}\nend", "  lst.each_with_index.map { |row, i| row.map { |item| [i,\
    \ row.index(item)] if item == x } }.flatten(1).compact.sort.reverse\nend", " \
    \ lst.flat_map.with_index { |xarr, idx| xarr.each_with_index.map { |el, idx2|\
    \ [idx, idx2] if el == x } }.compact.sort.sort_by { |el| -el[1] }\nend", "  (0...lst.size).map\
    \ do |i|\n    (0...lst[i].size).map do |j|\n      [i, j] if lst[i][j] == x\n \
    \   end\n  end.flatten(1).compact.sort do |a, b|\n    (a[0] <=> b[0]).nonzero?\
    \ || -(a[1] <=> b[1])\n  end\nend", "  coordinates = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |el, j|\n      coordinates << [i, j]\
    \ if el == x\n    end\n  end\n  coordinates.sort_by { |coord| coord[0] }.map do\
    \ |coord|\n    [coord[0], coord[1]]\n  end\nend", "    lst.map.with_index { |subarr,\
    \ subindex|\n        subarr.each_with_index.map { |element, index|\n         \
    \   [subindex, index] if element == x\n        }\n    }.flatten(1).select { |coords|\
    \ coords != nil }.sort { |coords1, coords2|\n        if coords1[0] == coords2[0]\n\
    \            coords2[1] <=> coords1[1]\n        else\n            coords1[0] <=>\
    \ coords2[0]\n        end\n    }\nend", "  lst.each_with_index.map do |arr, i|\n\
    \    arr.each_with_index.select { |e, j| e == x }.map { |e, j| [i, j] }\n  end.reject(&:empty?).flatten(1).sort_by\
    \ { |i, j| i }.reverse.sort_by { |i, j| j }\nend", "  result = []\n  lst.each_with_index\
    \ do |row, i|\n    j = row.index(x)\n    while j\n      result << [i, j]\n   \
    \   j = row.index(x, j + 1)\n    end\n  end\n  result.sort_by { |row, col| [row,\
    \ -col] }\nend", "  # your code here\nend", "  # your code here\nend", "  lst.map.with_index\
    \ { |e, i| e.map.with_index { |n, j| [i, j] if n == x }}\n    .flatten(1).compact.sort_by\
    \ { |e| [e[0], -e[1]] }\nend", "  pos = []\n  lst.each_with_index do |row, i|\n\
    \    row.each_with_index do |col, j|\n      pos << [i, j] if col == x\n    end\n\
    \  end\n  pos.sort_by { |x| [x[0], -x[1]] }\nend", "  row_idx = 0\n  result =\
    \ []\n  lst.each do |row|\n    col_idx = 0\n    row.each do |col|\n      if col\
    \ == x\n        result << [row_idx, col_idx]\n      end\n      col_idx += 1\n\
    \    end\n    row_idx += 1\n  end\n  result.sort_by{|a| [a[0], -a[1]]}\nend",
  "  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |element, col_index|\n      result << [row_index, col_index] if element ==\
    \ x\n    end\n  end\n  result.sort_by{|row_index, col_index| [row_index, -col_index]}\n\
    end", "  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, _column| row }.reverse\nend",
  "  res = []\n  lst.each_with_index do |val, index|\n    if val.index(x)\n      res\
    \ << [index, val.index(x)]\n    end\n  end\n  res.sort { |a, b| a.first <=> b.first\
    \ }\n  res.each do |pair|\n    pair.last.downto(0) do |i|\n      if lst[pair.first][i]\
    \ == x\n        pair.last = i\n        break\n      end\n    end\n  end\n  res\n\
    end", "\t(lst.map.with_index { |a, i| a.map.with_index { |e, j| [i, j] if e ==\
    \ x }}).flatten(1).sort_by { |i, j| [i, -j] }.reject { |a| a.nil? }\nend", " \
    \ lst.each_with_index.flat_map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }.compact\n  }.sort_by { |row, col| [-col, row] }\n\
    end", "  lst.flat_map.with_index do |row, y|\n    row.each_with_index.map { |el,\
    \ x| el == x ? [y, x] : nil }.compact\n  end.sort do |a, b|\n    if a[0] == b[0]\n\
    \      b[1] <=> a[1]\n    else\n      a[0] <=> b[0]\n    end\n  end\nend", " \
    \ row_lst = []\n  (0...lst.length).each do |row|\n    (0...lst[row].length).each\
    \ do |col|\n      row_lst << [row, col] if lst[row][col] == x\n    end\n  end\n\
    \  row_lst.sort_by { |(row, col)| [row, -col] }\nend", "  lst.each_with_index.map\
    \ do |a, i|\n    a.map.with_index { |e, j| [i, j] if e == x }.compact\n  end.flatten(1).sort_by\
    \ { |a| a[0] }.sort_by { |a| -a[1] }\nend", "  lst.map.with_index{|row, i| row.map.with_index{|e,\
    \ j| [i, j] if e == x}}.flatten(1).compact.sort.sort_by{|e| -e[1]}\nend", "  lst.each_with_index.with_object([])\
    \ do |(l, i), result|\n    l.each_with_index do |n, j|\n      result << [i, j]\
    \ if n == x\n    end\n  end.sort_by { |r, c| [r, -c] }\nend", "  rows = []\n \
    \ lst.each_with_index do |row, y|\n    row.each_with_index do |col, x1|\n    \
    \  rows << [y, x1] if x == col\n    end\n  end\n  rows.sort_by!{|x| [x[0], -x[1]]}\n\
    end", "  lst.map.with_index do |row, i|\n    row.map.with_index do |e, j|\n  \
    \    [i, j] if e == x\n    end\n  end.flatten(1).compact.sort_by do |i, j|\n \
    \   [i, -j]\n  end\nend", "  if !lst\n    return []\n  end\n  row_index = 0\n\
    \  res = []\n  lst.each do |row|\n    col_index = 0\n    row.each do |num|\n \
    \     if num == x\n        res << [row_index, col_index]\n      end\n      col_index\
    \ += 1\n    end\n    row_index += 1\n  end\n  res.sort\nend", "  lst.each_with_index.map\
    \ do |row, index|\n    row.each_with_index.map do |element, column|\n      element\
    \ == x ? [index, column] : nil\n    end\n  end.flatten(1).compact.sort_by { |row,\
    \ column| [row, -column] }\nend", "  length = lst.length\n  result = []\n  length.times\
    \ do |index|\n    position = 0\n    while position < lst[index].length\n     \
    \ if lst[index][position] == x\n        result << [index, position]\n      end\n\
    \      position += 1\n    end\n  end\n  result.sort_by!{|item| [item[0], -item[1]]}\n\
    end", "  # your code here\nend", "  lst.each_with_index.flat_map do |row, index|\n\
    \    row.each_with_index.map do |elem, index2|\n      elem == x ? [index, index2]\
    \ : nil\n    end.compact\n  end.sort_by { |elem| [elem[0], -elem[1]] }\nend",
  "  result = []\n  lst.each_with_index do |val, i|\n    val.each_with_index do |v,\
    \ j|\n      result << [i, j] if v == x\n    end\n  end\n  result.sort_by { |x|\
    \ [x[0], -x[1]] }\nend", "  lst.map.with_index { |sub, row| sub.map.with_index\
    \ { |e, col| [row, col] if e == x } }.flatten(1).compact.sort_by(&:first).reverse.sort_by(&:last)\n\
    end", "  res = []\n  lst.each_with_index do |row, i|\n    col = row.find_index(x)\n\
    \    res << [i, col] if col\n  end\n  res.sort\nend", "  if lst.empty?\n    []\n\
    \  else\n    lst.each_with_index.map do |e, i|\n      e.each_with_index.map do\
    \ |el, j|\n        if el == x\n          [i, j]\n        end\n      end\n    end.flatten(1).compact.sort_by{|a,\
    \ b| a}.reverse.sort_by{|a, b| b}\n  end\nend", "  if lst.size == 0\n    return\
    \ []\n  end\n  if x == nil\n    return lst\n  end\n  result = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |el, j|\n      if el == x\n        result\
    \ << [i, j]\n      end\n    end\n  end\n  result.sort! { |x, y| x[0] <=> y[0]\
    \ }\n  result.sort! { |x, y| y[1] <=> x[1] }\n  return result\nend", "  # your\
    \ code here\nend", "  list = lst.map.with_index { |i, index|\n    i.map.with_index\
    \ { |j, index2|\n      [index, index2] if j == x\n    }\n  }.flatten(1).compact\n\
    \  list.sort_by { |i| [i[0], -i[1]] }\nend", "  res = []\n  lst.each_with_index\
    \ do |el, i|\n    el.each_with_index do |el1, j|\n      res << [i, j] if el1 ==\
    \ x\n    end\n  end\n  res.sort_by { |el| [el[0], -el[1]] }\nend", "  # implement\
    \ your code here\nend", "  lst.map.with_index{|e,i| e.map.with_index{|e,j| [i,j]\
    \ if e == x}}.flatten(1).compact.sort_by{|i,j| [i, -j]}\nend", "  lst.map.with_index\
    \ { |sub_arr, i| sub_arr.map.with_index { |e, j| [i, j] if e == x } }.flatten(1).compact.sort_by\
    \ { |e| [e[0], -e[1]] }\nend", "  result = []\n  lst.each_with_index do |row,\
    \ i|\n    row.each_with_index do |num, j|\n      result << [i, j] if num == x\n\
    \    end\n  end\n  result.sort_by{|x, y| [x, -y]}\nend", "  lst.each_with_index.map\
    \ do |sub, i|\n    sub.each_with_index.map do |e, j|\n      [i, j] if e == x\n\
    \    end\n  end.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend", "  new_arr\
    \ = []\n  lst.each_with_index do |e, i|\n    e.each_with_index do |k, j|\n   \
    \   if k == x\n        new_arr << [i, j]\n      end\n    end\n  end\n  new_arr.sort.reverse\n\
    end", "  lst.each_with_index.map do |e, i|\n    e.each_with_index.map do |y, j|\n\
    \      [i, j] if y == x\n    end\n  end.flatten(1).compact.sort_by { |e| [e[0],\
    \ -e[1]] }\nend", "  # p lst\n  # p x\n  # your code goes here\n  result = []\n\
    \  lst.each_with_index do |y, yi|\n    # p \"y: #{y}\"\n    # p \"yi: #{yi}\"\n\
    \    y.each_with_index do |z, zi|\n      # p \"z: #{z}\"\n      # p \"zi: #{zi}\"\
    \n      if z == x\n        result << [yi, zi]\n      end\n    end\n  end\n  #\
    \ p result\n  result.sort_by { |x| [x[0], -x[1]] }\nend", "  r = []\n  lst.each_with_index\
    \ do |row, row_index|\n    row.each_with_index do |e, col_index|\n      r << [row_index,\
    \ col_index] if e == x\n    end\n  end\n  r.sort{|a, b| a.first == b.first ? b.last\
    \ <=> a.last : a.first <=> b.first}\nend", "  a = []\n  lst.each_with_index do\
    \ |y, i|\n    y.each_with_index do |f, e|\n      a << [i, e] if f == x\n    end\n\
    \  end\n  a.sort.reverse\nend", "  coordinates = []\n  lst.each_with_index do\
    \ |row, row_index|\n    row.each_with_index do |elem, col_index|\n      coordinates\
    \ << [row_index, col_index] if elem == x\n    end\n  end\n  coordinates.sort_by{|x|\
    \ [x[0], -x[1]]}\nend", "  result = []\n  lst.each_with_index do |row, i|\n  \
    \  row.each_with_index do |item, j|\n      result << [i, j] if item == x\n   \
    \ end\n  end\n  result.sort_by{|i| [-i[0], -i[1]]}\nend", "  result = []\n  lst.each_with_index\
    \ do |e, i|\n    e.each_with_index do |el, ii|\n      result << [i, ii] if el\
    \ == x\n    end\n  end\n  result.sort.reverse\nend", "  lst.map.with_index { |ary,\
    \ index| ary.map.with_index { |num, index2| [index, index2] if num == x } }.flatten(1).compact.sort_by\
    \ { |ary| [ary[0], -ary[1]] }\nend", "  lst.each_with_index.map { |row, index|\n\
    \    row.each_with_index.map { |item, i|\n      [index, i] if item == x\n    }\n\
    \  }.flatten(1).compact.sort_by { |a, b| [a, -b] }\nend", "  (0...lst.size).with_object([])\
    \ do |row, arr|\n    lst[row].each_with_index do |i, j|\n      arr << [row, j]\
    \ if i == x\n    end\n  end.sort_by { |l, i| [l, -i] }\nend", "  result = []\n\
    \  return result if lst.empty?\n  lst.each_with_index do |e, row|\n    e.each_with_index\
    \ do |e1, col|\n      result << [row, col] if e1 == x\n    end\n  end\n  result.sort_by!\
    \ { |e| [e[0], -e[1]] }\nend", "  lst.each_with_index.with_object([]) do |(item,\
    \ index), acc|\n    item.each_with_index do |inner_item, inner_index|\n      acc\
    \ << [index, inner_index] if inner_item == x\n    end\n  end.sort_by { |row, _column|\
    \ row }.map { |row, column| [row, -column] }.sort.map(&:reverse)\nend", "  # your\
    \ code here\nend", "  index_of_row = lst.map { |sub_array| sub_array.index(x)\
    \ }\n  row_columns = index_of_row.map.with_index { |column, index| index unless\
    \ column.nil? }.compact\n  column_indices = row_columns.map { |index| index_of_row[index]\
    \ }\n  row_columns.map.with_index { |row, index| [row, column_indices[index]]\
    \ }.sort.reverse\nend", "  res = []\n  lst.each_with_index do |sub_arr, i|\n \
    \   sub_arr.each_with_index do |val, j|\n      res << [i, j] if val == x\n   \
    \ end\n  end\n  res.sort_by { |a, b| [a, -b] }\nend", "  lst.map { |row| (0...row.size).select\
    \ { |i| row[i] == x }.map { |i| [lst.index(row), i] } }.flatten(1).sort_by { |a,\
    \ b| a }.reverse\nend", "  (0...lst.size).inject([]) do |a, row|\n    a + lst[row].each_with_index.map\
    \ do |el, col|\n      [row, col] if el == x\n    end.compact\n  end.sort.sort_by{|x|x[1]}.reverse\n\
    end", "  lst.each_with_index.map { |row, i|\n    row.map.with_index { |e, j|\n\
    \      [i, j] if e == x\n    }.compact\n  }.flatten(1).sort_by { |coord| [coord[0],\
    \ -coord[1]] }\nend", "  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |a| [a[0], -a[1]] }\nend", "  lst.map.with_index do |ary, i|\n    ary.map.with_index\
    \ do |e, j|\n      [i, j] if e == x\n    end\n  end.flatten(1).compact.sort {\
    \ |a, b| a[0] == b[0] ? b[1] <=> a[1] : a[0] <=> b[0] }\nend", "  result = []\n\
    \  i = 0\n  lst.each do |row|\n    j = 0\n    row.each do |item|\n      if item\
    \ == x\n        result << [i, j]\n      end\n      j += 1\n    end\n    i += 1\n\
    \  end\n  result.sort_by!{|coor| [coor[0], -coor[1]]}\nend", "  lst.each_with_index.map\
    \ do |sub_lst, sub_lst_i|\n    sub_lst.each_with_index.map do |sub_sub_lst, sub_sub_lst_i|\n\
    \      [sub_lst_i, sub_sub_lst_i] if sub_sub_lst == x\n    end\n  end.flatten(1).compact.sort.reverse\n\
    end", "  lst.each_with_index.inject([]) do |memo, (l, i)|\n    memo + l.each_with_index.select\
    \ { |e, j| e == x }.map { |e, j| [i, j] }\n  end.sort { |a, b| a.first == b.first\
    \ ? b.last <=> a.last : a.first <=> b.first }\nend", "  coords = []\n  lst.each_with_index\
    \ do |subarr, i|\n    subarr.each_with_index do |el, j|\n      coords << [i, j]\
    \ if el == x\n    end\n  end\n  coords.sort_by { |coord| [coord[0], -coord[1]]\
    \ }\nend", "  # your code here\nend", "  lst.map.with_index do |row, row_index|\n\
    \    row.map.with_index do |el, col_index|\n      el == x ? [row_index, col_index]\
    \ : nil\n    end\n  end.flatten(1).compact.sort_by do |row_index, col_index|\n\
    \    [row_index, -col_index]\n  end\nend", "  result = []\n  lst.each_with_index\
    \ do |x_lst, idx_row|\n    x_lst.each_with_index do |elem, idx_col|\n      result\
    \ << [idx_row, idx_col] if elem == x\n    end\n  end\n  result.sort_by { |a| [a[0],\
    \ -a[1]] }\nend", "  result = []\n  lst.each_with_index do |inner_lst, index|\n\
    \    inner_lst.each_with_index do |item, inner_index|\n      result << [index,\
    \ inner_index] if item == x\n    end\n  end\n  result.sort_by { |coord| [coord[0],\
    \ -coord[1]] }\nend", "  # your code here\nend", "  coordinates = []\n  i = 0\n\
    \  lst.each do |row|\n    row.each_with_index do |elem, index|\n      if elem\
    \ == x\n        coordinates << [i, index]\n      end\n    end\n    i += 1\n  end\n\
    \  coordinates.sort_by { |row, column| [row, -column] }\nend", "  lst.each_with_index.map\
    \ do |row, row_idx|\n    row.each_with_index.map do |el, col_idx|\n      [row_idx,\
    \ col_idx] if el == x\n    end\n  end.flatten(1).compact.sort do |a, b|\n    if\
    \ a[0] == b[0]\n      b[1] <=> a[1]\n    else\n      a[0] <=> b[0]\n    end\n\
    \  end\nend", "  # TODO\nend", "  lst.each_with_index.flat_map { |row, row_i|\n\
    \    row.each_with_index.map { |e, column_i|\n      [row_i, column_i] if e ==\
    \ x\n    }.compact\n  }.sort_by(&:reverse)\nend", "  results = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |num, j|\n      results << [i, j] if\
    \ num == x\n    end\n  end\n  results.sort_by { |x, y| x }.reverse\nend", "  lst.each_with_index.reduce([])\
    \ do |acc, (sub_lst, i)|\n    acc + sub_lst.each_with_index.select { |elem, _|\
    \ elem == x }.map { |_, j| [i, j] }\n  end.sort_by { |a, b| a }.reverse\nend",
  "  ys = (0...lst.size).each_with_object([]) do |y, object|\n    object << lst[y].each_with_index.select\
    \ { |n, _| n == x }.map { |_, i| [y, i] }\n  end\n  ys.flatten(1).sort { |a, b|\
    \ (a[0] == b[0]) ? b[1] <=> a[1] : a[0] <=> b[0] }\nend", "  result = []\n  for\
    \ i in 0..lst.length - 1\n    for j in 0..lst[i].length - 1\n      if lst[i][j]\
    \ == x\n        result << [i, j]\n      end\n    end\n  end\n  result\nend", " \
    \ if lst.empty? || !lst.flatten.include?(x)\n    []\n  else\n    arr = lst.map.with_index{|sub,\
    \ i| sub.map.with_index{|s, j| [i, j] if s == x}}.flatten(1).compact\n    arr.sort_by{|a|\
    \ [a[0], -a[1]]}\n  end\nend", "  lst.each_with_index.map { |arr, i|\n    arr.each_with_index.map\
    \ { |el, j|\n      [i, j] if el == x\n    }\n  }.flatten(1).compact.sort_by {\
    \ |a, b| [a, -b] }\nend", "  xs = []\n  lst.each_with_index do |a, i|\n    a.each_with_index\
    \ do |k, j|\n      xs << [i, j] if k == x\n    end\n  end\n  xs.sort{|a, b| [a[0],\
    \ -a[1]] <=> [b[0], -b[1]]}\nend", "  result = []\n  lst.each_with_index do |sub_array,\
    \ i|\n    sub_array.each_with_index do |value, j|\n      result << [i, j] if value\
    \ == x\n    end\n  end\n  result.sort_by { |x, y| y }.reverse.sort_by { |x, y|\
    \ x }\nend", "  # Write your code here.\nend", "  row_coordinates = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |value, j|\n      row_coordinates <<\
    \ [i, j] if value == x\n    end\n  end\n  row_coordinates.sort_by { |x, y| [x,\
    \ -y] }\nend", "  array = []\n  lst.each_with_index do |element, index|\n    if\
    \ element.include?(x)\n      element.each_with_index do |e, index2|\n        if\
    \ e == x\n          array << [index, index2]\n        end\n      end\n    end\n\
    \  end\n  array.sort!\n  array.each_with_index do |element, index|\n    array[index]\
    \ = array[index].reverse\n  end\n  array.sort!\n  array.each_with_index do |element,\
    \ index|\n    array[index] = array[index].reverse\n  end\n  return array\nend",
  "  result = []\n  lst.each_with_index do |row, r|\n    row.each_with_index do |column,\
    \ c|\n      result << [r, c] if column == x\n    end\n  end\n  result.sort_by\
    \ { |i| [i[0], -i[1]] }\nend", "  lst.each_with_index.map do |sub, i|\n    next\
    \ unless sub.include?(x)\n    sub.map.with_index { |e, j| [i, j] if e == x }.compact\n\
    \  end.flatten(1).sort_by { |i, j| i }.reverse.sort_by { |i, j| j }\nend", " \
    \ lst.each_with_index.map do |row, y|\n    row.map { |el| [y, row.size - 1 - row.index(el)]\
    \ if el == x }.compact\n  end.flatten(1).sort_by { |y, _| y }\nend", "  coordinates\
    \ = []\n  lst.each_with_index do |row, y|\n    row.each_with_index do |column,\
    \ x|\n      coordinates << [y, x] if column == x\n    end\n  end\n  coordinates.sort_by\
    \ { |coordinate| [coordinate[0], -coordinate[1]] }\nend", "  lst.each_with_index.with_object([])\
    \ do |(arr, idx), memo|\n    arr.each_with_index do |elem, inner_idx|\n      memo\
    \ << [idx, inner_idx] if elem == x\n    end\n  end.sort_by { |arr| arr[0] }.map\
    \ { |arr| arr.sort.reverse }\nend", "    lst.each_with_index.map do |arr, i|\n\
    \        arr.each_with_index.map do |num, j|\n            if num == x\n      \
    \          [i, j]\n            end\n        end\n    end.flatten(1).compact.sort_by\
    \ { |el| [el[0], -el[1]] }\nend", "  lst.each_with_index.reduce([]) do |acc,(a,\
    \ i)|\n    acc + a.each_with_index.reduce([]) do |acc,(b, j)|\n      b == x ?\
    \ acc + [[i, j]] : acc\n    end\n  end.sort do |a, b|\n    a[0] <=> b[0]\n  end.sort\
    \ do |a, b|\n    b[1] <=> a[1]\n  end\nend", "  puts get_row_help(lst, x).to_s\n\
    end", "  # Write your code here\nend", "  lst.each_with_index.map { |row, index|\n\
    \    row.each_with_index.map { |element, i|\n      [index, i] if element == x\n\
    \    }\n  }.flatten(1).compact.sort_by { |index, i| [index, -i] }\nend", "  (0...lst.size).each_with_object([])\
    \ do |row, result|\n    lst[row].each_with_index do |element, column|\n      result\
    \ << [row, column] if element == x\n    end\n  end.sort_by { |row, column| [row,\
    \ -column] }\nend", "  lst.map.with_index { |row, i| row.map.with_index { |col,\
    \ j| [i, j] if col == x } }.flatten(1).compact.sort\nend", "  lst.each_with_index.map\
    \ do |a, i|\n    a.each_with_index.select { |n, j| n == x }.map { |n, j| [i, j]\
    \ }\n  end.flatten(1).sort_by { |k, l| [k, -l] }\nend", "  # TODO: implement it\n\
    end", "  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |item, col_index|\n      result << [row_index, col_index] if item == x\n\
    \    end\n  end\n  result.sort { |r1, r2| r1[0] <=> r2[0] }.map { |row, col| [row,\
    \ -col] }\nend", "    x_count_hash = {}\n    for i in 0...lst.length\n       \
    \ for j in 0...lst[i].length\n            if lst[i][j] == x\n                if\
    \ x_count_hash[i]\n                    x_count_hash[i].push(j)\n             \
    \   else\n                    x_count_hash[i] = [j]\n                end\n   \
    \         end\n        end\n    end\n    sorted_x_count_hash = Hash[x_count_hash.sort]\n\
    \    answer = []\n    sorted_x_count_hash.each do |k, v|\n        for i in 0...v.length\n\
    \            if sorted_x_count_hash[k].sort.length > 1\n                answer.push([k,\
    \ sorted_x_count_hash[k].sort.pop])\n            else\n                answer.push([k,\
    \ sorted_x_count_hash[k].pop])\n            end\n        end\n    end\n    return\
    \ answer\nend", "  result = []\n  lst.each_with_index do |row, index|\n    row.each_with_index\
    \ do |num, index_col|\n      result << [index, index_col] if num == x\n    end\n\
    \  end\n  result.sort_by! { |a| [a[0], -a[1]] }\nend", "  # result = []\n  # lst.each_with_index\
    \ do |row, ind_row|\n  #   row.each_with_index do |num, ind_num|\n  #     result\
    \ << [ind_row, ind_num] if num == x\n  #   end\n  # end\n  # result.sort_by {\
    \ |coord| [coord[0], -coord[1]] }\n  lst.each_with_index.flat_map { |row, ind_row|\
    \ row.each_with_index.select { |num, ind_num| num == x }.map { |_, ind_num| [ind_row,\
    \ ind_num] } }.sort_by { |coord| [coord[0], -coord[1]] }\nend", "  coordinates\
    \ = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index do\
    \ |element, column_index|\n      coordinates << [row_index, column_index] if element\
    \ == x\n    end\n  end\n  coordinates.sort_by { |coordinate| coordinate[0] }.map\
    \ { |coordinate| coordinate.reverse }\nend", "  result = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |num, j|\n      result << [i, j] if\
    \ num == x\n    end\n  end\n  result.sort\nend", "  lst.each_with_index.with_object([])\
    \ do |(row, row_index), coords|\n    row.each_with_index do |element, col_index|\n\
    \      coords << [row_index, col_index] if element == x\n    end\n  end.sort_by\
    \ { |x, y| [x, -y] }\nend", "  coordinates = []\n  lst.each_with_index do |row,\
    \ i|\n    row.each_with_index do |col, j|\n      coordinates << [i, j] if col\
    \ == x\n    end\n  end\n  coordinates.sort_by { |c| [c[0], -c[1]] }\nend", " \
    \ list = []\n  lst.each_with_index do |i, j|\n    i.each_with_index do |k, l|\n\
    \      list << [j, l] if k == x\n    end\n  end\n  list.sort_by { |a, b| [a, -b]\
    \ }\nend", "  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |e| [e[0], -e[1]] }\nend", "  if lst.empty?\n    []\n  else\n    coordinates\
    \ = []\n    lst.each_with_index do |row, i|\n      row.each_with_index do |element,\
    \ j|\n        if element == x\n          coordinates << [i, j]\n        end\n\
    \      end\n    end\n    coordinates.sort{|a, b| a.first <=> b.first}.sort{|a,\
    \ b| b.last <=> a.last}\n  end\nend", "  lst.each_with_index.map { |arr, row|\
    \ arr.each_with_index.map { |elem, col| [row, col] if elem == x } }.flatten(1).compact.sort_by\
    \ { |(row, col)| [row, -col] }\nend", "  answer = []\n  lst.each_with_index do\
    \ |row,i|\n    row.each_with_index do |y,j|\n      answer << [i,j] if y == x\n\
    \    end\n  end\n  answer.sort_by{|i,j| [i, -j]}\nend", "  output = []\n  lst.each_with_index\
    \ do |row, row_num|\n    row.each_with_index do |cell, cell_num|\n      output\
    \ << [row_num, cell_num] if cell == x\n    end\n  end\n  output.sort_by { |row_num,\
    \ cell_num| [row_num, -cell_num] }\nend", "  lst.each_with_index.reduce([]) do\
    \ |res, (row, index)|\n    res + row.each_with_index.reduce([]) do |res, (elem,\
    \ ind)|\n      res << [index, ind] if elem == x\n      res\n    end\n  end.sort_by\
    \ { |el| [el[0], -el[1]] }\nend", "  # YOUR CODE HERE\nend", "  lst.each_with_index.map\
    \ { |row, idx|\n    row.each_with_index.map { |elem, idx2|\n      [idx, idx2]\
    \ if elem == x\n    }.compact\n  }.flatten(1).sort_by { |a, b|\n    [a, -b]\n\
    \  }\nend", "  # TODO\nend", "  lst.each_with_index.map do |sub_array, row|\n\
    \    sub_array.map.with_index { |int, col| [row, col] if int == x }\n  end.flatten(1).compact.sort_by\
    \ do |sub_array|\n    [sub_array[0], -sub_array[1]]\n  end\nend", "  rows = lst.map.with_index\
    \ do |arr, row|\n    [\n      row,\n      arr.find_all { |item| item == x }.map\
    \ { |item| arr.index(item) }\n    ]\n  end\n  rows.delete_if { |row| row[1].empty?\
    \ }\n  rows.sort_by! { |row| row[0] }\n  rows.map do |row|\n    row[1].map { |col|\
    \ [row[0], col] }\n  end.flatten(1)\nend", "  get_row = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |column, j|\n      get_row << [i, j]\
    \ if column == x\n    end\n  end\n  get_row.sort_by { |x| [x[0], -x[1]] }\nend",
  "  lst.map.with_index{|e, i| e.map.with_index{|e2, j| [i, j] if e2 == x}}.flatten(1).compact.sort_by{|e|\
    \ e.reverse}\nend", "  array = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |column, j|\n      array << [i, j] if column == x\n    end\n  end\n  array.sort_by\
    \ { |row, column| [row, -column] }\nend", "  (0...lst.size).map { |row|\n    lst[row].each_with_index.map\
    \ { |e, i|\n      [row, i] if e == x\n    }.compact\n  }.flatten(1).sort_by {\
    \ |row, col|\n    row * 100 + col\n  }.reverse\nend", "  lst\n    .map.with_index\
    \ { |row, r| row.map.with_index { |el, c| [r, c] if el == x } }\n    .flatten(1)\n\
    \    .compact\n    .sort_by(&:first)\n    .map { |row, col| row.downto(0).map\
    \ { |r| [r, col] } }\n    .flatten(1)\nend", "  res = []\n  lst.each_with_index\
    \ do |row, row_index|\n    row.each_with_index do |item, item_index|\n      res\
    \ << [row_index, item_index] if item == x\n    end\n  end\n  res.sort.map{|row,\
    \ column| [row, -column]}.sort\nend", "  i = 0\n  arr = []\n  while i < lst.length\n\
    \    j = 0\n    while j < lst[i].length\n      if lst[i][j] == x\n        arr\
    \ << [i, j]\n      end\n      j += 1\n    end\n    i += 1\n  end\n  arr\nend",
  "  puts\n  puts \"recurring\"\n  lst.map.with_index do |row, row_index|\n    row.map.with_index\
    \ do |el, el_index|\n      puts \"recurring #{row_index} #{el_index}\"\n     \
    \ if el == x\n        [row_index, el_index]\n      end\n    end\n  end.flatten(1).compact.sort_by{|el|\
    \ [el[0], -el[1]]}\nend", "  indexes = []\n  lst.each_with_index do |val, row|\n\
    \    if val.include?(x)\n      val.each_with_index do |cell, col|\n        indexes\
    \ << [row, col] if cell == x\n      end\n    end\n  end\n  indexes.sort_by { |row,\
    \ col| row }.reverse.map { |row, col| [col, row] }\nend", "  result = []\n  lst.each_with_index\
    \ do |row, index|\n    row.each_with_index do |col, i|\n      result << [index,\
    \ i] if col == x\n    end\n  end\n  result.sort_by { |x| [x[0], -x[1]] }\nend",
  "  # your code here\nend", "  lst.map.with_index do |row, row_index|\n    row.map.with_index\
    \ do |cell, cell_index|\n      [row_index, cell_index] if cell == x\n    end\n\
    \  end.flatten(1).compact.sort_by do |row_index, cell_index|\n    [row_index,\
    \ -cell_index]\n  end\nend", "    coordinates = []\n    lst.each_with_index do\
    \ |row, i|\n        row.each_with_index do |cell, j|\n            if cell == x\n\
    \                coordinates << [i, j]\n            end\n        end\n    end\n\
    \    coordinates.sort { |a, b|\n        if a[0] == b[0]\n            b[1] <=>\
    \ a[1]\n        else\n            a[0] <=> b[0]\n        end\n    }\nend", " \
    \ res = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |col, col_index|\n      res << [row_index, col_index] if col == x\n    end\n\
    \  end\n  res.sort { |x, y| x[0] <=> y[0] }.sort { |x, y| x[1] <=> y[1] }.reverse\n\
    end", "  index = 0\n  result = []\n  lst.each do |list|\n    list.each_with_index\
    \ do |l, i|\n      if l == x\n        result << [index, i]\n      end\n    end\n\
    \    index += 1\n  end\n  result.sort { |a, b| a[0] <=> b[0] }.map do |list|\n\
    \    list.sort { |a, b| b[1] <=> a[1] }\n  end\nend", "  # your solution here\n\
    end", "  lst.map.with_index { |row, index| row.map.with_index { |cell, i| [index,\
    \ i] if cell == x } }.flatten(1).compact.sort_by { |coordinate| [coordinate[0],\
    \ -coordinate[1]] }\nend", "  lst.map.with_index{|n, i|n.map.with_index{|m, j|[i,\
    \ j] if m == x}.compact}.flatten(1).sort_by{|n|n[0]}.reverse.sort_by{|n|n[1]}\n\
    end", "  # \nend", "  result = []\n  lst.each_with_index do |item, i|\n    item.each_with_index\
    \ do |inside_item, j|\n      result << [i, j] if inside_item == x\n    end\n \
    \ end\n  result.sort.reverse\nend", "  res = []\n  lst.each_with_index do |row,\
    \ i|\n    row.each_with_index do |el, j|\n      res << [i, j] if el == x\n   \
    \ end\n  end\n  res.sort! do |a, b|\n    if a[0] == b[0]\n      b[1] <=> a[1]\n\
    \    else\n      a[0] <=> b[0]\n    end\n  end\nend", "  row_idx = []\n  lst.each_with_index\
    \ { |val, idx| row_idx << [idx, val.index(x)] if val.include?(x) }\n  row_idx.sort_by\
    \ { |_, col| col }.reverse.sort_by { |row, _| row }\nend", end, "\tindices = []\n\
    \ti = 0\n\tlst.each do |subarr|\n\t\tindices << subarr.each_index.select{|i| subarr[i]\
    \ == x}\n\t\tindices[i].map!{|x| x + [i]}.flatten!\n\t\ti += 1\n\tend\n\t\n\t\
    indices.flatten!(1)\n\tindices.sort_by!{|a| [-a[1], a[0]]}\n\tindices\nend", " \
    \ lst.each_with_index.with_object([]) do |(arr, i), arr2|\n    arr.each_with_index\
    \ do |e, j|\n      arr2 << [i, j] if e == x\n    end\n  end.sort do |(a1, b1),\
    \ (a2, b2)|\n    if a1 == a2\n      b2 <=> b1\n    else\n      a1 <=> a2\n   \
    \ end\n  end\nend", "  new_arr = []\n  lst.each_with_index do |arr, index|\n \
    \   arr.each_with_index do |element, sub_index|\n      if element == x\n     \
    \   new_arr << [index, sub_index]\n      end\n    end\n  end\n  new_arr.sort_by\
    \ { |pair| [pair[0], -pair[1]] }\nend", "  row = []\n  lst.each_with_index do\
    \ |num, i|\n    num.each_with_index do |n, j|\n      row << [i, j] if n == x\n\
    \    end\n  end\n  row.sort.reverse\nend", "  len = lst.length\n  len.times do\
    \ |row|\n    col = lst[row].index(x)\n    if col\n      [[row, col]] + get_row(lst[row][col+1..-1],\
    \ x)\n    else\n      get_row(lst[row+1..-1], x)\n    end\n  end\nend", "  result\
    \ = []\n  # lst.each_with_index do |row, index|\n  #   row.each_with_index do\
    \ |num, i|\n  #     result << [index, i] if num == x\n  #   end\n  # end\n  lst.each_with_index\
    \ { |row, index| row.each_with_index { |num, i| result << [index, i] if num ==\
    \ x } }\n  result.sort_by { |e| [e[0], -e[1]] }\nend", "  result = []\n  lst.each_with_index\
    \ do |sublst, j|\n    sublst.each_with_index do |v, i|\n      result << [j, i]\
    \ if v == x\n    end\n  end\n  result.sort_by{|v| [v[0], -v[1]]}\nend", "  matrix\
    \ = lst.map do |row|\n    row.map do |elem|\n      [row.index(elem), lst.index(row)]\
    \ if elem == x\n    end\n  end.flatten(1).compact\n  matrix.sort_by { |row, col|\
    \ [row, -col] }\nend", "  lst.flat_map.with_index do |row, i|\n    row.map.with_index\
    \ do |y, j|\n      [i, j] if y == x\n    end\n  end.compact.sort_by do |a, b|\n\
    \    [a, -b]\n  end\nend", "  # wirte your code here\nend", "  res = lst.each_with_index.map\
    \ do |arr, i|\n    arr.each_with_index.map do |e, j|\n      [i, j] if e == x\n\
    \    end\n  end\n  res.flatten(1).compact.sort_by { |row, col| [row, -col] }\n\
    end", "  lst.map.with_index { |row, row_num| row.map.with_index { |val, col_num|\
    \ [row_num, col_num] if val == x } }.flatten(1).compact.sort.sort_by { |pair|\
    \ pair[1] }.reverse\nend", "  result = []\n  lst.each_with_index do |row, row_index|\n\
    \    row.each_with_index do |item, col_index|\n      result << [row_index, col_index]\
    \ if item == x\n    end\n  end\n  result.sort_by{|e| [e[0], -e[1]]}\nend", " \
    \ res = []\n  lst.each_with_index do |l, index|\n    l.each_with_index do |i,\
    \ ind|\n      res << [index, ind] if i == x\n    end\n  end\n  res.sort_by! {\
    \ |v| [v[0], -v[1]] }\nend", "  coordinates = []\n  lst.each_with_index do |row,\
    \ index_row|\n    row.each_with_index do |element, index_column|\n      coordinates\
    \ << [index_row, index_column] if element == x\n    end\n  end\n  coordinates.sort_by\
    \ { |coordinate| coordinate[0] }.reverse.sort_by { |coordinate| coordinate[1]\
    \ }\nend", "  res = []\n  lst.each_with_index do |e, i|\n    e.each_with_index\
    \ do |f, j|\n      res << [i, j] if f == x\n    end\n  end\n  res.sort_by { |e|\
    \ [e[0], -e[1]] }\nend", "  raise RuntimeError.new 'input error' if !lst.is_a?(Array)\
    \ || !x.is_a?(Integer)\n  result = []\n  lst.each_with_index do |row, row_index|\n\
    \    row.each_with_index do |elem, col_index|\n      result << [row_index, col_index]\
    \ if elem == x\n    end\n  end\n  result.sort.sort_by { |elem| elem[1] }.reverse\n\
    end", "  lst.map.with_index { |row, i| [i, row.index(x)] }.reject { |i, _| i.nil?\
    \ }.sort.map(&:reverse).map { |r, c| [r, c].compact }\nend", "  rows_with_x =\
    \ []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index do |element,\
    \ column_index|\n      rows_with_x << [row_index, column_index] if element ==\
    \ x\n    end\n  end\n  rows_with_x.sort.reverse\nend", "  lst.each_with_index.map\
    \ do |a, i|\n    a.each_with_index.map do |b, j|\n      [i, j] if b == x\n   \
    \ end\n  end.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend", "  result\
    \ = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n\
    \      result << [i, j] if cell == x\n    end\n  end\n  result.sort\nend\nget_row.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) #[[0, 0], [1, 4],\
    \ [1, 0], [2, 5], [2, 0]]\nget_row.call([], 1) #[]\nget_row.call([[], [1], [1,\
    \ 2, 3]], 3) #[[2, 2]]", "  result = []\n  lst.each_with_index do |row, row_idx|\n\
    \    row.each_with_index do |n, col_idx|\n      result << [row_idx, col_idx] if\
    \ n == x\n    end\n  end\n  result.sort_by { |pair| [pair[0], -pair[1]] }\nend",
  "  lst.map.with_index { |arr, i| arr.map.with_index { |a, j| [i, j] if a == x }\
    \ }.flatten(1).compact.sort.sort_by { |a| -a[1] }\nend", "  result = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      result << [i, j] if\
    \ col == x\n    end\n  end\n  result.sort_by { |r, c| [r, -c] }\nend", "  coord\
    \ = []\n  lst.each_with_index do |row, idx|\n    if row.include?(x)\n      i =\
    \ row.index(x)\n      coord << [idx, i]\n    end\n  end\n  coord.sort_by { |pair|\
    \ pair[0] }.sort_by { |pair| pair[1] }.reverse\nend", "  arr = []\n  lst.each_with_index\
    \ do |n, i|\n    n.each_with_index do |k, j|\n      arr << [i, j] if k == x\n\
    \    end\n  end\n  arr.sort_by do |x|\n    x[0]\n  end.sort_by do |x|\n    x[1]\n\
    \  end.reverse\nend", "\tlst.flat_map.with_index { |e, i| e.map.with_index { |e,\
    \ j| [i, j] if e == x } }.compact.sort { |a, b| a[0] != b[0] ? a[0] <=> b[0] :\
    \ b[1] <=> a[1] }\nend", "  lst.each_with_index.each_with_object([]) do |(arr,\
    \ idx), res|\n    arr.each_with_index { |e, i| res << [idx, i] if e == x }\n \
    \ end.sort_by { |a, b| a <=> b }.reverse\nend", "  coordinates = []\n  lst.each_with_index\
    \ do |row, index_row|\n    row.each_with_index do |value, index_column|\n    \
    \  if value == x\n        coordinates << [index_row, index_column]\n      end\n\
    \    end\n  end\n  coordinates.sort_by { |row, column| row }.reverse\nend", " \
    \ lst.each_with_index.with_object([]) do |(arr, index), acc|\n    arr.each_with_index\
    \ { |elem, sub_index| acc << [index, sub_index] if elem == x }\n  end.sort_by\
    \ { |arr| [arr[0], -arr[1]] }\nend", "  result = []\n  i = 0\n  lst.each do |array|\n\
    \    if array.include?(x)\n      result << [i, array.index(x)]\n    end\n    i\
    \ += 1\n  end\n  result.sort_by { |row, col| [-row, -col] }\nend", "  lst.map!.with_index\
    \ { |sub_arr, idx| sub_arr.map!.with_index { |sub_el, idx2| sub_el == x ? [idx,\
    \ idx2] : nil  }.compact }.reject!(&:empty?)\n  lst.sort_by! { |sub_arr| sub_arr[0][0]\
    \ }\n  lst.map! { |sub_arr| sub_arr.sort_by { |sub_el| sub_el[1] }.reverse }\n\
    \  lst.flatten(1)\nend", "  lst.each_with_index.map do |e, i|\n    e.map { |e1|\
    \ [i, e.size - e.find_index(e1) - 1] if e1 == x }\n  end.flatten(1).compact.sort_by(&:first).reverse\n\
    end", "  result = []\n  (0...lst.size).each do |i|\n    index = lst[i].index(x)\n\
    \    result << [i, index] if index\n  end\n  result.sort! { |a, b| a[0] == b[0]\
    \ ? b[1] <=> a[1] : a[0] <=> b[0] }\nend", end, "  lst.each_with_index.flat_map\
    \ do |row, row_index|\n    row.each_with_index.map do |value, col_index|\n   \
    \   if value == x\n        [row_index, col_index]\n      end\n    end\n  end.compact.sort_by\
    \ { |r, c| [r, -c] }\nend", "  result = []\n  i = 0\n  lst.each do |array|\n \
    \   j = 0\n    array.each do |element|\n      if element == x\n        result\
    \ << [i, j]\n      end\n      j += 1\n    end\n    i += 1\n  end\n  result.sort_by{|a|\
    \ a[0]}.sort_by{|a| -a[1]}\nend", "    res = []\n    lst.each_with_index do |arr,\
    \ idx|\n        arr.each_with_index do |num, i|\n            res << [idx, i] if\
    \ num == x\n        end\n    end\n    res.sort_by{|arr| [arr[0], -arr[1]]}\nend",
  "  (0...lst.size).map { |i| lst[i].each_with_index.with_object([]) { |(y, j), obj|\
    \ obj << [i, j] if y == x } }.reject(&:empty?).flatten(1).sort_by { |i, j| [i,\
    \ -j] }\nend", "  result = []\n  lst.each_with_index do |x_arr, i|\n    x_arr.each_with_index\
    \ do |number, j|\n      result << [i, j] if number == x\n    end\n  end\n  result.sort!\
    \ do |pair1, pair2|\n    res = pair1[0] <=> pair2[0]\n    res = pair2[1] <=> pair1[1]\
    \ if res == 0\n    res\n  end\nend", "  result = []\n  lst.each_with_index do\
    \ |row, index|\n    col = row.index(x)\n    result << [index, col] if col\n  end\n\
    \  result.sort_by { |point| [point[0], -point[1]] }\nend", "  # TODO: Implement\
    \ me\nend", "  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |item, j|\n      result << [i, j] if item == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend", "  lst.map.with_index{|a, i| [i, a.each_index.select{|j|\
    \ a[j] == x}]}.select{|i, j| !j.empty?}.map{|i, j| j.map{|k| [i, k]}}.flatten(1).sort.reverse\n\
    end", "  res = lst.each_with_index.map { |sub, i| sub.each_with_index.map { |e,\
    \ j| [i, j] if e == x } }.flatten(1).compact\n  res.sort_by { |y| [y[0], -y[1]]\
    \ }\nend", "  lst.each_with_index.map do |row, row_num|\n    row.each_with_index.map\
    \ do |col, col_num|\n      [row_num, col_num] if col == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |x| [x[0], -x[1]] }\nend", "  coordinates = []\n  lst.each_with_index do |row,\
    \ i|\n    if row.include?(x)\n      row.each_with_index do |el, j|\n        coordinates\
    \ << [i, j] if el == x\n      end\n    end\n  end\n  coordinates.sort_by { |coord|\
    \ [coord[0], -coord[1]] }\nend", "  lst.map.with_index { |a, i| a.map.with_index\
    \ { |e, j| [i, j] if e == x } }.flatten(1).compact.sort_by { |a| [a[0], -a[1]]\
    \ }\nend", "  result = lst.each_with_index.reduce([]) do |acc, (subarray, i)|\n\
    \    xs = subarray.each_with_index.reduce([]) do |a, (el, j)|\n      el == x ?\
    \ a.push([i, j]) : a\n    end\n    acc + xs\n  end\n  result.sort_by { |i, j|\
    \ [i, -j] }\nend", "  answer = []\n  (0...lst.length).each do |row|\n    answer\
    \ += lst[row].map.with_index { |el, ind| [row, ind] if el == x }.compact\n  end\n\
    \  answer.sort_by { |arr| arr[0] }.sort_by { |arr| -arr[1] }\nend", "  coordinates\
    \ = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do |element,\
    \ j|\n      if element == x\n        coordinates << [i, j]\n      end\n    end\n\
    \  end\n  coordinates.sort! { |a, b| (a[0] <=> b[0]).nonzero? || -(a[1] <=> b[1])\
    \ }\nend", "  lst.map.with_index{|a, i| a.map.with_index{|b, j| [i, j] if b ==\
    \ x}}.flatten(1).compact.sort_by{|x| [x[0], -x[1]]}\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
