name: HumanEval_87_get_row
language: rb
prompt: "# You are given a 2 dimensional data, as a nested arrays,\n# which is similar\
  \ to matrix, however, unlike matrices,\n# each row may contain a different number\
  \ of columns.\n# Given lst, and integer x, find integers x in the array,\n# and\
  \ return array of arrays, [(x1, y1), (x2, y2) ...] such that\n# each array is a\
  \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially by\
  \ rows in ascending order.\n# Also, sort coordinates of the row by columns in descending\
  \ order.\n# Examples:\n# >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
  \ [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([],\
  \ 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst,\
  \ x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
  \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
  \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
  \ 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5,\
  \ 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0,\
  \ 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6,\
  \ 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
  \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
  \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
  \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
  \ [1, 2, 3]], 3))\n  end\nend\n"
completions: ["  res = []\n  lst.each_with_index do |a,i|\n    a.each_with_index do\
    \ |b,j|\n      res << [i,j] if b == x\n    end\n  end\n  res.sort_by!{|e| [e[0],\
    \ -e[1]]}\nend", "  # your code here\nend", "  lst.map.with_index { |x1, i| x1.map.with_index\
    \ { |x2, j| [i, j] if x2 == x } }.flatten(1).compact.sort_by { |x1, x2| [x1, -x2]\
    \ }\nend", "  x_indices = Hash.new\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      x_indices[[i, j]] = true if col == x\n    end\n  end\n  x_indices.keys.sort_by{|x,\
    \ y| [x, -y]}\nend", "  lst.each_with_index.map { |row, i| row.map { |item| [i,\
    \ row.index(item)] if item == x } }.flatten(1).compact.sort.reverse\nend", " \
    \ lst.flat_map.with_index { |xarr, idx| xarr.each_with_index.map { |el, idx2|\
    \ [idx, idx2] if el == x } }.compact.sort.sort_by { |el| -el[1] }\nend", "  (0...lst.size).map\
    \ do |i|\n    (0...lst[i].size).map do |j|\n      [i, j] if lst[i][j] == x\n \
    \   end\n  end.flatten(1).compact.sort do |a, b|\n    (a[0] <=> b[0]).nonzero?\
    \ || -(a[1] <=> b[1])\n  end\nend", "  coordinates = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |el, j|\n      coordinates << [i, j]\
    \ if el == x\n    end\n  end\n  coordinates.sort_by { |coord| coord[0] }.map do\
    \ |coord|\n    [coord[0], coord[1]]\n  end\nend", "    lst.map.with_index { |subarr,\
    \ subindex|\n        subarr.each_with_index.map { |element, index|\n         \
    \   [subindex, index] if element == x\n        }\n    }.flatten(1).select { |coords|\
    \ coords != nil }.sort { |coords1, coords2|\n        if coords1[0] == coords2[0]\n\
    \            coords2[1] <=> coords1[1]\n        else\n            coords1[0] <=>\
    \ coords2[0]\n        end\n    }\nend", "  lst.each_with_index.map do |arr, i|\n\
    \    arr.each_with_index.select { |e, j| e == x }.map { |e, j| [i, j] }\n  end.reject(&:empty?).flatten(1).sort_by\
    \ { |i, j| i }.reverse.sort_by { |i, j| j }\nend", "  result = []\n  lst.each_with_index\
    \ do |row, i|\n    j = row.index(x)\n    while j\n      result << [i, j]\n   \
    \   j = row.index(x, j + 1)\n    end\n  end\n  result.sort_by { |row, col| [row,\
    \ -col] }\nend", "  # your code here\nend", "  # your code here\nend", "  lst.map.with_index\
    \ { |e, i| e.map.with_index { |n, j| [i, j] if n == x }}\n    .flatten(1).compact.sort_by\
    \ { |e| [e[0], -e[1]] }\nend", "  pos = []\n  lst.each_with_index do |row, i|\n\
    \    row.each_with_index do |col, j|\n      pos << [i, j] if col == x\n    end\n\
    \  end\n  pos.sort_by { |x| [x[0], -x[1]] }\nend", "  row_idx = 0\n  result =\
    \ []\n  lst.each do |row|\n    col_idx = 0\n    row.each do |col|\n      if col\
    \ == x\n        result << [row_idx, col_idx]\n      end\n      col_idx += 1\n\
    \    end\n    row_idx += 1\n  end\n  result.sort_by{|a| [a[0], -a[1]]}\nend",
  "  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |element, col_index|\n      result << [row_index, col_index] if element ==\
    \ x\n    end\n  end\n  result.sort_by{|row_index, col_index| [row_index, -col_index]}\n\
    end", "  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, _column| row }.reverse\nend",
  "  res = []\n  lst.each_with_index do |val, index|\n    if val.index(x)\n      res\
    \ << [index, val.index(x)]\n    end\n  end\n  res.sort { |a, b| a.first <=> b.first\
    \ }\n  res.each do |pair|\n    pair.last.downto(0) do |i|\n      if lst[pair.first][i]\
    \ == x\n        pair.last = i\n        break\n      end\n    end\n  end\n  res\n\
    end", "\t(lst.map.with_index { |a, i| a.map.with_index { |e, j| [i, j] if e ==\
    \ x }}).flatten(1).sort_by { |i, j| [i, -j] }.reject { |a| a.nil? }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
