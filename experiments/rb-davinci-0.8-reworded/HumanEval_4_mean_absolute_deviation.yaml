name: HumanEval_4_mean_absolute_deviation
language: rb
prompt: "# For a given array of input numbers, calculate Mean Absolute Deviation\n\
  # around the mean of this dataset.\n# Mean Absolute Deviation is the average absolute\
  \ difference between each\n# element and a centerpoint (mean in this case):\n# MAD\
  \ = average | x - x_mean |\n# >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])\n\
  # 1.0\ndef mean_absolute_deviation(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n\
  \    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0,\
  \ 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2,\
  \ candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"
completions: ["  mean = average(numbers)\n  absolute_deviations = numbers.map { |number|\
    \ (number - mean).abs }\n  average(absolute_deviations)\nend", "  mean = mean(numbers)\n\
    \  absolute_deviations = numbers.map { |n| (n - mean).abs }\n  mean(absolute_deviations)\n\
    end", "  mad = numbers.inject(0) { |sum, number| sum + (number - numbers.mean).abs\
    \ } / numbers.size\n  mad\nend", "  m = mean(numbers)\n  mad = 0\n  numbers.each\
    \ do |num|\n    mad += (num - m).abs\n  end\n  mad / numbers.length\nend", " \
    \ raise ArgumentError, 'Array cannot be empty' if numbers.empty?\n  return numbers.first\
    \ if numbers.length == 1", "  mean = mean(numbers)\n  sum = 0.0\n  numbers.each\
    \ do |n|\n    sum += (n - mean).abs\n  end\n  sum / numbers.size\nend", "  mean\
    \ = mean(numbers)\n  numbers.inject(0.0) { |sum, n| sum + (n - mean).abs } / numbers.size\n\
    end", "  mean_absolute_deviation = 0\n  numbers.each do |number|\n    mean_absolute_deviation\
    \ += (number - average(numbers)).abs\n  end\n  mean_absolute_deviation / numbers.size\n\
    end", "  mean = numbers.inject(0.0, :+) / numbers.length\n  mean_absolute_deviation\
    \ = numbers.inject(0.0) do |sum, num|\n    sum + (num - mean).abs\n  end\n  mean_absolute_deviation\
    \ / numbers.length\nend", "  return 0 if numbers.empty?\n  mean = mean(numbers)\n\
    \  average = numbers.map { |x| (x - mean).abs }.reduce(:+) / numbers.size\n  average\n\
    end", "  numbers = numbers.to_a\n  mean = mean(numbers)\n  difference = numbers.map\
    \ { |number| (number - mean).abs }\n  mean(difference)\nend", "  mean = mean(numbers)\n\
    \  sum = 0.0\n  num_numbers = numbers.size\n  numbers.each do |num|\n    sum +=\
    \ (num - mean).abs\n  end\n  (sum / num_numbers).round(4)\nend", "  # TODO: Return\
    \ the Mean Absolute Deviation of the numbers\n  m = mean(numbers)\n  l = numbers.length\n\
    \  absolute_number = []\n  numbers.each do |number|\n    absolute_number << (number\
    \ - m).abs\n  end\n  mean(absolute_number)\nend", "  raise 'numbers must be an\
    \ array' unless numbers.is_a?(Array)\n  raise 'numbers must have at least one\
    \ number' if numbers.length < 1\n  numbers.inject(0) { |sum, num| sum + (num -\
    \ mean(numbers)).abs } / numbers.length\nend", "  mean = calculate_mean(numbers)\n\
    \  absolute_deviations = numbers.map { |number| (number - mean).abs }\n  mean_of_absolute_deviations\
    \ = calculate_mean(absolute_deviations)\n  mean_of_absolute_deviations\nend",
  "  num_items = numbers.length\n  mean = numbers.reduce(:+) / num_items\n  absolute_deviations\
    \ = numbers.map { |x| (x - mean).abs }\n  mean_absolute_deviation = absolute_deviations.reduce(:+)\
    \ / num_items\n  return mean_absolute_deviation\nend", "  # No numbers - no deviation!\n\
    \  return 0 if numbers.length == 0", "  mean = numbers.reduce(:+) / numbers.length\n\
    \  numbers.map { |number| (number - mean).abs }.reduce(:+) / numbers.length\n\
    end", "  # TODO\nend", "  arr = numbers.is_a?(Array) ? numbers : [numbers]\n \
    \ arr.inject(0.0) { |sum, n| sum + (n - mean(arr)).abs } / arr.size\nend\nalias_method\
    \ :mad, :mean_absolute_deviation"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
