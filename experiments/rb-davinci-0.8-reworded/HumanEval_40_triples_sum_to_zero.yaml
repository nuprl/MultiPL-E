name: HumanEval_40_triples_sum_to_zero
language: rb
prompt: "# triples_sum_to_zero takes an array of integers as an input.\n# it returns\
  \ true if there are three distinct elements in the array that\n# sum to zero, and\
  \ false otherwise.\n# >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>>\
  \ triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1,\
  \ 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n\
  # >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n\
  \    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true,\
  \ candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2,\
  \ 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true,\
  \ candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n\
  \    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false,\
  \ candidate.call([100, 3, 5, -100]))\n  end\nend\n"
completions: ["    if l.length < 3\n        return false\n    end\n    sorted = l.sort\n\
    \    i = 0\n    while i < sorted.length - 2\n        a = sorted[i]\n        j\
    \ = i + 1\n        while j < sorted.length - 1\n            b = sorted[j]\n  \
    \          k = j + 1\n            while k < sorted.length\n                c =\
    \ sorted[k]\n                if a + b + c == 0\n                    return true\n\
    \                end\n                k += 1\n            end\n            j +=\
    \ 1\n        end\n        i += 1\n    end\n    return false\nend", "  return false\
    \ if l.length < 3\n  l.combination(3).any? { |a, b, c| a + b + c == 0 }\nend",
  "  n = l.length\n  if n < 3\n    return false\n  end\n  0.upto(n-3) do |x|\n   \
    \ (x+1).upto(n-2) do |y|\n      (y+1).upto(n-1) do |z|\n        if l[x] + l[y]\
    \ + l[z] == 0\n          return true\n        end\n      end\n    end\n  end\n\
    \  return false\nend\ntriples_sum_to_zero.call(ARGV[0].split(',').map(&:to_i))",
  "  l.each_with_index do |num1, i|\n    l.each_with_index do |num2, j|\n      l.each_with_index\
    \ do |num3, k|\n        return true if num1 + num2 + num3 == 0 && i != j && j\
    \ != k && i != k\n      end\n    end\n  end\n  false\nend", "  l.each_with_index\
    \ do |a, ai|\n    l.each_with_index do |b, bi|\n      l.each_with_index do |c,\
    \ ci|\n        if ai != bi && bi != ci && ai != ci\n          return true if a\
    \ + b + c == 0\n        end\n      end\n    end\n  end\n  false\nend", "  l.sort!\n\
    \  l.each_with_index do |el, i|\n    j = i + 1\n    k = l.length - 1\n    while\
    \ j < k\n      sum = el + l[j] + l[k]\n      return true if sum == 0\n      sum\
    \ > 0 ? k -= 1 : j += 1\n    end\n  end\n  false\nend", "  return false if l.size\
    \ < 3\n  l.sort!", "  for i in 0..l.length - 3\n    for j in i + 1..l.length -\
    \ 2\n      for k in j + 1..l.length - 1\n        if l[i] + l[j] + l[k] == 0\n\
    \          return true\n        end\n      end\n    end\n  end\n  return false\n\
    end", "  # return false if l.length < 3\n  #\n  # (0...l.length).each do |i|\n\
    \  #   (i+1...l.length).each do |j|\n  #     (j+1...l.length).each do |k|\n  #\
    \       if l[i] + l[j] + l[k] == 0\n  #         return true\n  #       end\n \
    \ #     end\n  #   end\n  # end\n  #\n  # false", "  l.each_with_index do |num,\
    \ idx|\n    l.each_with_index do |num2, idx2|\n      l.each_with_index do |num3,\
    \ idx3|\n        if (num + num2 + num3 == 0) && (idx != idx2) && (idx2 != idx3)\
    \ && (idx != idx3)\n          return true\n        end\n      end\n    end\n \
    \ end\n  return false\nend", "  l.each_with_index do |v1, i|\n    l.each_with_index\
    \ do |v2, j|\n      l.each_with_index do |v3, k|\n        return true if v1 +\
    \ v2 + v3 == 0 && i != j && j != k && i != k\n      end\n    end\n  end\n  false\n\
    end", "  l.each_with_index do |x, i|\n    (i+1..l.length-1).each do |j|\n    \
    \  (j+1..l.length-1).each do |k|\n        return true if x + l[j] + l[k] == 0\n\
    \      end\n    end\n  end\n  false\nend", "  l.length.times do |i|\n    ((i +\
    \ 1)...l.length).each do |j|\n      ((j + 1)...l.length).each do |k|\n       \
    \ if l[i] + l[j] + l[k] == 0\n          return true\n        end\n      end\n\
    \    end\n  end\n  false\nend", "  return false if l.length < 3\n  l.each_with_index\
    \ do |one, i|\n    ((i + 1)...l.length).each do |j|\n      ((j + 1)...l.length).each\
    \ do |k|\n        return true if one + l[j] + l[k] == 0\n      end\n    end\n\
    \  end\n  false\nend", "  l.each_with_index do |n1, i|\n    l.each_with_index\
    \ do |n2, j|\n      l.each_with_index do |n3, k|\n        if (i != j && j != k\
    \ && i != k) && (n1 + n2 + n3 == 0)\n          return true\n        end\n    \
    \  end\n    end\n  end\n  return false\nend", "  triple = l.each_cons(3).to_a\n\
    \  triple.any? { |arr| arr.sum == 0 }\nend", "  comb = l.combination(3).to_a\n\
    \  comb.each do |i|\n    if i.reduce(:+) == 0\n      return true\n    end\n  end\n\
    \  return false\nend", "\t#\nend", "  l.each_with_index do |ele1, i|\n    l.each_with_index\
    \ do |ele2, j|\n      l.each_with_index do |ele3, k|\n        return true if ele1\
    \ + ele2 + ele3 == 0 && (i != j && j != k && i != k)\n      end\n    end\n  end\n\
    \  false\nend", "  if l.length < 3\n    return false\n  else\n    for i in 0..l.length-3\n\
    \      for j in i+1..l.length-2\n        for k in j+1..l.length-1\n          if\
    \ l[i] + l[j] + l[k] == 0\n            return true\n          end\n        end\n\
    \      end\n    end\n  end\n  return false\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
