name: HumanEval_43_pairs_sum_to_zero
language: rb
prompt: "# pairs_sum_to_zero takes an array of integers as an input.\n# it returns\
  \ true if there are two distinct elements in the array that\n# sum to zero, and\
  \ false otherwise.\n# >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1,\
  \ 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>>\
  \ pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n\
  # false\ndef pairs_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n\
  \    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5,\
  \ 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true,\
  \ candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3,\
  \ 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n\
  \    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"
completions: ["  l.combination(2).to_a.each do |pair|\n    return true if pair.sum\
    \ == 0\n  end\n  false\nend", "  l.count == l.uniq.count ? false : true\nend",
  "  l.each_with_index do |item1, i|\n    l.each_with_index do |item2, j|\n      if\
    \ (item1 + item2 == 0) && (i != j)\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "    ans = false\n    l.each_with_index do |i, idx|\n\
    \        l.each_with_index do |j, jdx|\n            if (idx != jdx) and (i + j\
    \ == 0)\n                ans = true\n            end\n        end\n    end\n \
    \   return ans\nend", "    # need to move from the start of the array to the end\n\
    \    # do we need to start at the beginning?\n    # if we have a hash of seen\
    \ values\n    # can we keep track of values we have seen?\n    # if we have seen\
    \ an inverse to a value, we can return true\n    # if we haven't seen an inverse\
    \ of a value, add the value to the hash\n    # if the hash is empty, return false\n\
    \    # if we reach the end of the array, return false\n    # if we see a 0, return\
    \ true?\n    # need to know if the number is larger or smaller than 0\n    # need\
    \ to know if the number is + or -\n    # if the number we are looking at is larger\
    \ than 0\n    # if the number we are looking at is smaller than 0\n    # add the\
    \ number to the hash", "  raise NotImplementedError\nend", "  found = false\n\
    \  l.each_with_index do |e,i|\n    (i+1...l.length).each do |j|\n      if l[i]\
    \ + l[j] == 0\n        found = true\n      end\n    end\n  end\n  found\nend",
  "  i = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n      if\
    \ l[i] + l[j] == 0\n        return true\n      end\n      j += 1\n    end\n  \
    \  i += 1\n  end\n  return false\nend", "\tl.size.times do |i|\n\t\tl.size.times\
    \ do |j|\n\t\t\tif i != j && l[i] + l[j] == 0\n\t\t\t\treturn true\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn false\nend", "  tmp = []\n  l.each do |n|\n    if tmp.include?(-n)\n\
    \      return true\n    else\n      tmp << n\n    end\n  end\n  return false\n\
    end", "  ret = l.select { |e| l.include?(-e) && l.index(e) != l.index(-e) }\n\
    \  !ret.empty?\nend", "  # implement your method here, and return the appropriate\
    \ result\nend", "  # TODO: implement this\nend", "  # your code here!\nend", " \
    \ l.length.times do |i|\n    if l.include?(-l[i]) && i != l.index(-l[i])\n   \
    \   return true\n    end\n  end\n  return false\nend", "  negatives = Hash.new(0)\n\
    \  positives = Hash.new(0)\n  l.each do |i|\n    if i < 0\n      negatives[i]\
    \ += 1\n    else\n      positives[i] += 1\n    end\n  end\n  return false if negatives.empty?\
    \ || positives.empty?\n  negatives.each do |k,v|\n    return true if positives.has_key?(-k)\n\
    \  end\n  return false\nend", "  hash = {}\n  l.each_with_index do |e, i|\n  \
    \  hash[e] = true if e == 0\n    return true if hash[-e] && e != 0\n  end\n  false\n\
    end\npairs_sum_to_zero = MethodDefinition.new(:pairs_sum_to_zero, [:l], [\n  VariableAssignment.new(:hash,\
    \ HashObject.new),\n  Call.new(Variable.new(:l), :each_with_index, [\n    Block.new([:e,\
    \ :i], [\n      Call.new(Variable.new(:hash), :[]=, [Variable.new(:e), TrueClassObject.new]),\n\
    \      If.new(\n        BinaryOperation.new(Variable.new(:hash), :[], [BinaryOperation.new(Variable.new(:e),\
    \ :-, [IntegerObject.new(0)])]),\n        BinaryOperation.new(Variable.new(:e),\
    \ :!=, [IntegerObject.new(0)]),\n        Return.new(TrueClassObject.new)\n   \
    \   )\n    ])\n  ]),\n  FalseClassObject.new\n])\npairs_sum_to_zero.check_types(GLOBAL_CONTEXT)",
  "  l.map { |n| n if l.include?(-n) }.compact.uniq.size >= 2\nend", "  t = []\n \
    \ l.each do |x|\n    t += [x]\n    if t.include?(0-x)\n      return true\n   \
    \ end\n  end\n  return false\nend", "  for i in (0...l.length)\n    for j in (i+1...l.length)\n\
    \      if l[i] + l[j] == 0\n        return true\n      end\n    end\n  end\n \
    \ return false\nend", "  # Your Code Here\nend", "  l.each do |num1|\n    l.each\
    \ do |num2|\n      return true if num1 + num2 == 0 && num1 != num2\n    end\n\
    \  end\n  false\nend", "  # check if the array has more than one element and whether\
    \ it's an array\n  return false if l.length < 2 || !l.is_a?(Array)\n  # return\
    \ true if any two elements of the array sum to zero\n  l.combination(2).any? {\
    \ |a, b| a + b == 0 }\nend", "    if l.length == 1\n        return false\n   \
    \ end\n    for i in 0..l.length-1\n        for j in 0..l.length-1\n          \
    \  if (l[i] + l[j] == 0 && i != j)\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "  l.combination(2).to_a.each do\
    \ |c|\n    if c[0] + c[1] == 0\n      return true\n    end\n  end\n  return false\n\
    end", "  l.each_with_index do |x, i|\n    for j in (i+1)...l.length\n      return\
    \ true if x + l[j] == 0\n    end\n  end\n  return false\nend", "  pairs = l.combination(2).to_a.map\
    \ { |pair| pair.inject(:+) }\n  pairs.any? { |sum| sum == 0 }\nend", "  result\
    \ = false\n  l.each_with_index do |e, i|\n    if l.index(e * -1) != nil\n    \
    \  result = true\n    end\n  end\n  result\nend", "  pairs = []\n  l.each do |i|\n\
    \    l.each do |j|\n      if i + j == 0 && i != j\n        pairs << [i, j]\n \
    \     end\n    end\n  end\n  return true if pairs.count > 0\n  false\nend", " \
    \ i = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n      if\
    \ l[i] + l[j] == 0\n        return true\n      end\n      j += 1\n    end\n  \
    \  i += 1\n  end\n  return false\nend", "  l.each_with_index do |i, j|\n    l.each_with_index\
    \ do |m, n|\n      return true if i + m == 0 && j != n\n    end\n  end\n  false\n\
    end", "  # YOUR CODE HERE\n  l.each_with_index do |ele1, i|\n    l.each_with_index\
    \ do |ele2, j|\n      if ele1 + ele2 == 0\n        return true if i != j\n   \
    \   end\n    end\n  end\n  return false\nend", "  # TODO: implement this using\
    \ Ruby\n  false\nend", "  sum_pairs = []\n  l.each_with_index do |num1, i|\n \
    \   l.each_with_index do |num2, j|\n      if (num1 + num2 == 0) && i != j\n  \
    \      sum_pairs << num1 << num2\n      end\n    end\n  end\n  sum_pairs.uniq.length\
    \ == 2\nend", "  for i in 0..l.length - 1\n    for j in 0..l.length - 1\n    \
    \  return true if i != j && l[i] + l[j] == 0\n    end\n  end\n  return false\n\
    end", "    for i in 0..l.length-1\n        for j in i+1..l.length-1\n        \
    \    if l[i] + l[j] == 0\n                return true\n            end\n     \
    \   end\n    end\n    return false\nend", "  l.each do |i|\n    l.each do |j|\n\
    \      return true if i+j == 0 && i != j\n    end\n  end\n  false\nend", "  #\
    \ for each integer i in l,\n  # check if there exists an integer j in l where\
    \ j is not equal to i\n  # and i + j = 0\n  # if so, return true\n  # if none\
    \ of them satisfy this condition, return false\n  l.each_with_index do |i, idx|\n\
    \    l.each_with_index do |j, jdx|\n      next if idx == jdx\n      return true\
    \ if i + j == 0\n    end\n  end\n  false\nend", end, "  for n in l do\n    for\
    \ m in l do\n      if n+m == 0\n        return true\n      end\n    end\n  end\n\
    \  return false\nend\npairs_sum_to_zero.call([1, 3, 5, 0])\npairs_sum_to_zero.call([1,\
    \ 3, -2, 1])\npairs_sum_to_zero.call([1, 2, 3, 7])\npairs_sum_to_zero.call([2,\
    \ 4, -5, 3, 5, 7])\npairs_sum_to_zero.call([1])", "  check_array(l)\n  check_array_contents(l)\n\
    \  return false if l.length <= 1\n  d = {}\n  l.each do |el|\n    return true\
    \ if d[el]\n    d[-el] = true\n  end\n  false\nend", "  for i in 0..l.length-1\n\
    \    for j in i+1..l.length-1\n      if (l[i] + l[j]) == 0\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "    # for each element in the\
    \ array,\n    # check if the element's negative is also in the array\n    l.each\
    \ do |x|\n        return true if l.include?(-x)\n    end\n    false\nend", " \
    \ elements = {}\n  result = false\n  l.each do |e|\n    if elements[e * -1]\n\
    \      result = true\n      break\n    else\n      elements[e] = true\n    end\n\
    \  end\n  result\nend", "  (l.empty? || l.length == 1) ? false : l.combination(2).any?\
    \ { |x, y| x + y == 0 }\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      return true if x + y == 0 && i != j\n    end\n  end\n  false\n\
    end", "  return false if l.size < 2\n  (0...l.size).each do |i|\n    ((i+1)...l.size).each\
    \ do |j|\n      return true if l[i] + l[j] == 0\n    end\n  end\n  false\nend",
  "  left = 0\n  right = l.length - 1\n  while left < right\n    while left < right\
    \ && l[left] + l[right] > 0\n      right -= 1\n    end\n    if left < right &&\
    \ l[left] + l[right] == 0\n      return true\n    end\n    left += 1\n  end\n\
    \  return false\nend", "  # your code here\n  # l.length.times do |i|\n  #   l.length.times\
    \ do |j|\n  #     if i != j && l[i] + l[j] == 0\n  #       return true\n  #  \
    \   end\n  #   end\n  # end\n  # false\n  l.each_with_index do |num, i|\n    if\
    \ l.index(num * -1) != nil && l.index(num * -1) != i\n      return true\n    end\n\
    \  end\n  false\nend", "  n = l.length\n  for i in 0..n-1\n    for j in i+1..n-1\n\
    \      if l[i] + l[j] == 0\n        return true\n      end\n    end\n  end\n \
    \ return false\nend", "  nums = l.uniq\n  if nums.length <= 1\n    return false\n\
    \  else\n    if nums.include? 0\n      return true\n    else\n      return nums.combination(2).any?\
    \ { |pair| pair.sum == 0 }\n    end\n  end\nend", "  # iterate through the values\
    \ in the array\n  i = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n\
    \      # return true if there is a pair of values that sum to zero\n      if l[i]\
    \ + l[j] == 0\n        return true\n      end\n      j += 1\n    end\n    i +=\
    \ 1\n  end\n  return false\nend", '  return false if l.length < 2', "  # l.each\
    \ do |e|\n  #   l.each do |ee|\n  #     if e == ee\n  #       next\n  #     end\n\
    \  #     if e + ee == 0\n  #       return true\n  #     end\n  #   end\n  # end\n\
    \  # return false\n  # l.each do |e|\n  #   if l.include?(-e) && l.count(e) ==\
    \ 1\n  #     return true\n  #   end\n  # end\n  # return false\n  # l.combination(2).any?\
    \ { |a, b| a + b == 0 }\n  (l.count(0) >= 2) || l.combination(2).any? { |a, b|\
    \ a + b == 0 }\nend", "\tfor i in 0..l.length\n\t\tfor j in 0..l.length\n\t\t\t\
    if l[i] + l[j] == 0 && i != j\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn false\nend", "  # 1. find the index of the first zero\n  # 2. search\
    \ the array after that index to find a -0\n  #     - if found return true\n  #\
    \     - if not return false\n  l.each_with_index do |num, index|\n    return true\
    \ if num == 0 && l[index + 1..-1].include?(0)\n  end\n  false\nend", "  # YOUR\
    \ CODE HERE\nend", end, "\t# check for empty array\n\tif l.empty? \n\t\treturn\
    \ false\n\tend\n\t# iterate through all possible combinations of elements in array\n\
    \t# checking for sum to zero\n\tfor i in 0..l.length-1\n\t\tfor j in i+1..l.length-1\n\
    \t\t\tif l[i] + l[j] == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    # if no sum to zero was found, return false\n\treturn false\nend", "  h = {}\n\
    \  l.each do |e|\n    return true if h[-e]\n    h[e] = true\n  end\n  false\n\
    end", "  l.each_with_index do |num, i|\n    l.each_with_index do |num2, i2|\n\
    \      if i != i2\n        if num + num2 == 0\n          return true\n       \
    \ end\n      end\n    end\n  end\n  return false\nend", "  if l.length == 0\n\
    \    false\n  elsif l.length == 1\n    false\n  else\n    l.each do |i|\n    \
    \  l.each do |j|\n        if i+j == 0 && i != j\n          return true\n     \
    \   end\n      end\n    end\n    false\n  end\nend", "  l.combination(2).any?\
    \ { |a, b| a + b == 0 }\nend", "  h = Hash.new(0)\n  l.each { |item| h[item] +=\
    \ 1 }\n  l.each do |item|\n    if item == 0 && h[item] > 1\n      return true\n\
    \    elsif item != 0 && h[-item] > 0\n      return true\n    end\n  end\n  return\
    \ false\nend", "  l.each do |i|\n    if l.include?(-i)\n      return true\n  \
    \  end\n  end\n  return false\nend", "  # your code here\n  (0...l.length).each\
    \ do |i|\n    (i+1...l.length).each do |j|\n      return true if l[i] + l[j] ==\
    \ 0\n    end\n  end\n  false\nend", "  # your code here\n  count = Hash.new(0)\n\
    \  l.each do |i|\n    count[i] += 1\n  end\n  count.each do |k, v|\n    return\
    \ true if count[-k] > 0\n  end\n  false\nend", "  l.each do |num|\n    if l.include?(-num)\
    \ && num != 0\n      return true\n    end\n  end\n  return false\nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      return true if x + y == 0\
    \ and j > i\n    end\n  end\n  return false\nend", "  if l.length < 2\n    return\
    \ false\n  end\n  # if the length is 2, we can just check if they add to zero.\n\
    \  if l.length == 2\n    return l[0] + l[1] == 0\n  end\n  # If it's longer than\
    \ 2, we need to check all pairs.\n  # To do this, we can sort the array.\n  #\
    \ Then we can have a pointer for the front and back of the array.\n  # We can\
    \ compare these two numbers, and move our pointers accordingly.\n  # If the sum\
    \ is zero, we can return true.\n  # We can return false if we've reached the end\
    \ of the array.\n  l.sort!\n  left = 0\n  right = l.length - 1\n  while(left <\
    \ right)\n    sum = l[left] + l[right]\n    if sum == 0\n      return true\n \
    \   elsif sum < 0\n      left += 1\n    else\n      right -= 1\n    end\n  end\n\
    \  return false\nend", "  i = 0\n  while i < l.length - 1\n    j = i + 1\n   \
    \ while j < l.length\n      if l[i] + l[j] == 0\n        return true\n      end\n\
    \      j += 1\n    end\n    i += 1\n  end\n  return false\nend", "  set = {}\n\
    \  l.each do |i|\n    return true if set[-i]\n    set[i] = true\n  end\n  false\n\
    end", "  # write code here\nend", "  n_hash = Hash.new\n  l.each do |i|\n    n_hash[i]\
    \ = 1\n  end\n  l.each do |i|\n    return true if n_hash[-i] == 1\n  end\n  return\
    \ false\nend", "  # O(n)\n  zero_set = Set.new\n  l.each do |num|\n    return\
    \ true if zero_set.include?(-num)\n    zero_set.add(num)\n  end\n  false\nend",
  "  my_hash = Hash.new(0)\n  l.each { |i| my_hash[i] += 1 }\n  my_hash.keys.each\
    \ do |k|\n    my_hash[-k] += 1\n  end\n  my_hash.values.max > 1\nend", "  i =\
    \ 0\n  j = 1\n  while j < l.length\n    if l[i] + l[j] == 0\n      return true\n\
    \    end\n    i += 1\n    j += 1\n  end\n  return false\nend", "  h = Hash.new(0)\n\
    \  l.each { |e| h[e] += 1 }\n  h.each do |k, v|\n    if h[-k] != 0\n      return\
    \ true\n    end\n  end\n  return false\nend", "  l.each_with_index do |e1, i|\n\
    \    l.each_with_index do |e2, j|\n      return true if e1 + e2 == 0 and i !=\
    \ j\n    end\n  end\n  false\nend", "  if l.length < 2\n    return false\n  end\n\
    \  for i in 0..l.length - 1\n    for j in 0..l.length - 1\n      if i != j and\
    \ l[i] + l[j] == 0\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  l.each_with_index do |num1, i|\n    l.each_with_index do |num2, j|\n\
    \      if num1 != num2 && num1 + num2 == 0\n        return true\n      end\n \
    \   end\n  end\n  return false\nend", "  l.each_with_index do |num1, i|\n    l.each_with_index\
    \ do |num2, j|\n      return true if num1 + num2 == 0 and i != j\n    end\n  end\n\
    \  false\nend", "\tfor i in 0..l.length-1\n\t\tfor j in 0..l.length-1\n\t\t\t\
    if i != j\n\t\t\t\tif l[i] + l[j] == 0\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\
    \t\tend\n\t\tend\n\tend\n\treturn false\nend", "  @l = l.sort.uniq\n  @o = 0\n\
    \  @len = @l.length - 1\n  while @o <= @len\n    @i = @o + 1\n    while @i <=\
    \ @len\n      if @l[@o] + @l[@i] == 0\n        return true\n      end\n      @i\
    \ += 1\n    end\n    @o += 1\n  end\n  return false\nend", "  pos = Hash.new\n\
    \  neg = Hash.new\n  l.each do |x|\n    if x >= 0\n      pos[x] = pos[x] ? pos[x]\
    \ + 1 : 1\n    else\n      neg[x] = neg[x] ? neg[x] + 1 : 1\n    end\n  end\n\
    \  neg.each do |x, y|\n    if pos[-x]\n      return true\n    end\n  end\n  return\
    \ false\nend", "\tl.each do |i|\n\t\tl.each do |j|\n\t\t\tif i + j == 0\n\t\t\t\
    \treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", " \nend", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      if j > i\n        if x + y\
    \ == 0\n          return true\n        end\n      end\n    end\n  end\n  return\
    \ false\nend", "  pairs = l.combination(2).to_a\n  pairs.each do |pair|\n    if\
    \ pair[0] + pair[1] == 0\n      return true\n    end\n  end\n  return false\n\
    end", "  # TODO: implement me\nend", "  # set up a hash to store elements\n  dict\
    \ = {}\n  # iterate through the list, add elements to hash, then check if the\
    \ negative of the element is in the hash\n  l.each do |n|\n    dict[n] = true\n\
    \    return true if dict[-n]\n  end\n  false\nend", "  return true if l.size ==\
    \ 1\n  l.sort!\n  i = 0\n  j = l.size - 1\n  while i < j\n    if l[i] + l[j] ==\
    \ 0\n      return true\n    elsif l[i] + l[j] > 0\n      j -= 1\n    else\n  \
    \    i += 1\n    end\n  end\n  return false\nend", "  l.each do |e|\n    return\
    \ true if l.include?(-e)\n  end\n  false\nend", "  zero_pairs = false\n  l.each_with_index\
    \ do |val, idx|\n    if l.index(val*-1) != nil && l.index(val*-1) != idx\n   \
    \   zero_pairs = true\n    end\n  end\n  zero_pairs\nend", "  (0...l.length).each\
    \ do |a|\n    (a + 1...l.length).each do |b|\n      return true if l[a] + l[b]\
    \ == 0\n    end\n  end\n  false\nend", "  i = 0\n  while i < l.length\n    j =\
    \ i + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return true\n\
    \      end\n      j += 1\n    end\n    i += 1\n  end\n  return false\nend", "\t\
    # make a hash where keys = the numbers in the list, and the values = 0\n\t# iterate\
    \ through the hash\n\t# if the number + current_number == 0\n\t# return true",
  "  for i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] + l[j] ==\
    \ 0\n        return true\n      end\n    end\n  end\n  return false\nend", " \
    \ sorted = l.sort\n  low = 0\n  high = sorted.length - 1\n  while low < high\n\
    \    sum = sorted[low] + sorted[high]\n    if sum == 0\n      return true\n  \
    \  elsif sum < 0\n      low += 1\n    else\n      high -= 1\n    end\n  end\n\
    \  return false\nend", "  # TODO: implement this method!\nend", "  i = 0\n  while\
    \ i < l.length do\n    j = i + 1\n    while j < l.length do\n      if l[i] + l[j]\
    \ == 0\n        return true\n      end\n      j += 1\n    end\n    i += 1\n  end\n\
    \  return false\nend", "\tx = 0\n\twhile x < l.length\n\t\ty = 0\n\t\twhile y\
    \ < l.length\n\t\t\tif l[x] + l[y] == 0 && x != y\n\t\t\t\treturn true\n\t\t\t\
    end\n\t\t\ty += 1\n\t\tend\n\t\tx += 1\n\tend\n\treturn false\nend", "  @l = l\n\
    \  if @l.length < 2\n    return false\n  end\n  @l.combination(2).each do |pair|\n\
    \    if pair[0] + pair[1] == 0\n      return true\n    end\n  end\n  return false\n\
    end", "  for i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] +\
    \ l[j] == 0\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  # TODO\nend", "  l.combination(2).map{|x,y| x + y}.include?(0)\nend",
  "  i = 0\n  while i < l.length\n    if l.include?(-l[i])\n      return true\n  \
    \  end\n    i += 1\n  end\n  return false\nend", "  l.each_with_index do |val,\
    \ i|\n    i2 = i + 1\n    while i2 < l.length\n      if val + l[i2] == 0\n   \
    \     return true\n      end\n      i2 += 1\n    end\n  end\n  return false\n\
    end", "  l.size.times do |i|\n    (i+1...l.size).each do |j|\n      return true\
    \ if l[i] + l[j] == 0\n    end\n  end\n  false\nend", "    counter = 0\n    l.length.times\
    \ do |i|\n        l.length.times do |j|\n            if i != j\n             \
    \   counter += 1 if l[i] + l[j] == 0\n            end\n        end\n    end\n\
    \    counter > 0 ? true : false\nend", "  l.size == 1 ? false : l.each_with_index.any?\
    \ { |x, i| l.each_with_index.any? { |y, j| i != j && x + y == 0 }}\nend", "\t\
    if l.length < 2\n\t\treturn false\n\tend\n\tl.each do |num|\n\t\tif l.include?(-num)\
    \ && num != -num\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", " \
    \ if l.length > 1\n    x = l.sort\n    j = x.length - 1\n    i = 0\n    while\
    \ i < j\n      if x[i] + x[j] == 0\n        return true\n      elsif x[i] + x[j]\
    \ > 0\n        j -= 1\n      else\n        i += 1\n      end\n    end\n  end\n\
    \  return false\nend", "  # YOUR CODE HERE\nend", "  if l.length < 2\n    return\
    \ false\n  end\n  l.each_with_index do |n,i|\n    l.each_with_index do |n2,i2|\n\
    \      if n + n2 == 0 && i != i2\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  x = l.select { |n| l.include?(-n) }\n  y = x.uniq\n\
    \  y.size > 1\nend", "  # STEP 1:\n  # Sort the input list l.\n  l.sort!\n  #\
    \ STEP 2:\n  # Set a front pointer to the front of the list (at index 0)\n  #\
    \ and a back pointer to the end of the list (at index len(l)-1).\n  # STEP 3:\n\
    \  # As long as the front pointer is strictly less than the back pointer,\n  #\
    \ (a) compute the sum of the elements at the front and back pointers.\n  #   \
    \  if this sum is zero, return true.\n  # (b) if this sum is greater than zero,\
    \ move the back pointer to the left\n  #     (that is, toward the beginning of\
    \ the list).\n  # (c) if this sum is less than zero, move the front pointer to\
    \ the right.\n  #     (that is, toward the end of the list).\n  # (d) if the front\
    \ pointer and back pointer have converged, return false.\n  # HINT:\n  # The while\
    \ loop of step 3 will look very similar to\n  # the loop from the remove_duplicates\
    \ function in lecture.\n  front = 0\n  back = l.length - 1\n  while front < back\n\
    \    if l[front] + l[back] == 0\n      return true\n    elsif l[front] + l[back]\
    \ > 0\n      back -= 1\n    else\n      front += 1\n    end\n  end\n  return false\n\
    end", "  @l = l\n  @l.each_with_index do |x, i|\n    j = i + 1\n    while j <\
    \ @l.length\n      if (x + @l[j]) == 0\n        return true\n      end\n     \
    \ j += 1\n    end\n  end\n  return false\nend", "\treturn false if l.length <\
    \ 2\n\tl.each_with_index do |i, idx|\n\t\tl.each_with_index do |j, jdx|\n\t\t\t\
    next if jdx <= idx\n\t\t\treturn true if i + j == 0\n\t\tend\n\tend\n\tfalse\n\
    end", "  return false if l.length < 2\n  h = Hash.new(0)\n  l.each do |i|\n  \
    \  h[i] += 1\n  end\n  if h.keys.include?(0)\n    return true if h[0] > 1\n  end\n\
    \  h.keys.each do |key|\n    return true if h.keys.include?(-key)\n  end\n  false\n\
    end", "  !l.each_with_index.all? do |e, i|\n    l.each_with_index.none? do |e2,\
    \ i2|\n      e + e2 == 0 && i != i2\n    end\n  end\nend", "    # WRITE YOUR CODE\
    \ HERE\n    hash = {}\n    l.each do |ele|\n        hash[ele] = true\n    end\n\
    \    l.each do |ele|\n        if hash[-ele]\n            return true\n       \
    \ end\n    end\n    return false\nend", "    if l.length < 2\n        return false\n\
    \    end\n    l.each_with_index do |x, i|\n        break if i == l.length - 1\n\
    \        for j in i+1..l.length-1\n            if x + l[j] == 0\n            \
    \    return true\n            end\n        end\n    end\n    return false\nend",
  "  Hash[l.map { |n| [n, true] }].each do |n, _v|\n    # if (l.include?(-n) && !l.include?(n))\n\
    \    #   return true\n    # end\n    return true if Hash[l.map { |m| [m, true]\
    \ }].key?(-n) && n != -n\n  end\n  false\nend", "  l.sort!\n  left = 0\n  right\
    \ = l.length - 1\n  while left < right\n    if l[left] + l[right] == 0\n     \
    \ return true\n    elsif l[left] + l[right] < 0\n      left += 1\n    else\n \
    \     right -= 1\n    end\n  end\n  return false\nend", "  l.each_with_index do\
    \ |num, i|\n    sub_array = l[i+1..-1]\n    return true if sub_array.include?(-num)\n\
    \  end\n  false\nend", "  # write your code here\nend", "    visited = Hash.new(false)\n\
    \    l.each do |n|\n        if visited[-n] == true\n            return true\n\
    \        else\n            visited[n] = true\n        end\n    end\n    return\
    \ false\nend", "  l.each_with_index do |e,i|\n    l.each_with_index do |f,j|\n\
    \      if i < j && (e + f == 0)\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  l.each_with_index do |value1,index1|\n    l.each_with_index\
    \ do |value2,index2|\n      if index1<index2\n        return true if value1+value2==0\n\
    \      end\n    end\n  end\n  return false\nend", "  two_distinct = false\n  sum_zero\
    \ = false\n  elements = {}\n  l.each do |num|\n    if elements[num]\n      two_distinct\
    \ = true\n    else\n      elements[num] = true\n    end\n  end\n  elements.each\
    \ do |num, bool|\n    if elements[-num]\n      sum_zero = true\n    end\n  end\n\
    \  return two_distinct && sum_zero\nend", "  l.each_with_index do |n, i|\n   \
    \ i += 1\n    l[i..-1].each do |m|\n      return true if n + m == 0\n    end\n\
    \  end\n  false\nend", "  (0...l.length).each do |i|\n    (i+1...l.length).each\
    \ do |j|\n      return true if l[i] + l[j] == 0\n    end\n  end\n  false\nend",
  "  # Your code here\n  l.each_with_index do |num, i|\n    l.each_with_index do |num2,\
    \ j|\n      if i != j && num + num2 == 0\n        return true\n      end\n   \
    \ end\n  end\n  return false\nend", "  return false if l.nil? || l.empty? || l.length\
    \ < 2\n  hash = {}\n  l.each do |element|\n    if hash[element]\n      return\
    \ true\n    else\n      hash[-element] = true\n    end\n  end\n  false\nend",
  end, "    h = Hash.new(0)\n    l.each { |i| h[i] += 1 }\n    h.each do |k, v|\n\
    \        if v >= 2\n            return true if k == 0\n        end\n        if\
    \ h[-k] > 0\n            return true if k > 0\n        end\n    end\n    return\
    \ false\nend", "  l.each do |num|\n    if l.include?(-num) && l.index(num) !=\
    \ l.index(-num)\n      return true\n    end\n  end\n  return false\nend", "  l.length.times\
    \ do |i|\n    i.upto(l.length - 1) do |j|\n      return true if l[i] + l[j] ==\
    \ 0 && i != j\n    end\n  end\n  false\nend", "  i = 0\n  while (i < l.length)\n\
    \    j = i + 1\n    while (j < l.length)\n      if (l[i] + l[j] == 0)\n      \
    \  return true\n      end\n      j += 1\n    end\n    i += 1\n  end\n  return\
    \ false\nend", "  l.combination(2).map { |a, b| a + b }.any? { |x| x == 0 }\n\
    end", "  i = 0\n  while i < l.length - 1\n    j = i + 1\n    while j < l.length\n\
    \      if l[i] + l[j] == 0\n        return true\n      end\n      j += 1\n   \
    \ end\n    i += 1\n  end\n  return false\nend", "  #logic here\nend", "  (l.length\
    \ - 1).times do |i|\n    (i + 1).upto(l.length - 1) do |j|\n      return true\
    \ if l[i] + l[j] == 0\n    end\n  end\n  false\nend", "  l.uniq.each_with_index\
    \ do |elem, index|\n    l.each_with_index do |elem2, index2|\n      if (elem +\
    \ elem2) == 0 && index != index2\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  l.each_with_index do |x,x_i|\n    l.each_with_index\
    \ do |y,y_i|\n      if x+y == 0 && x_i != y_i\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "\treturn (l.combination(2).any? {|x, y|\
    \ x + y == 0})\nend", '  return false if l.empty?', "  l.each_with_index do |number,\
    \ index|\n    next if index == 0\n    l.each_with_index do |number2, index2|\n\
    \      next if index2 == 0\n      return true if (number + number2) == 0\n   \
    \ end\n  end\n  false\nend", "  # TODO\nend", "  l.each do |i|\n    if l.include?(-i)\
    \ && i != 0\n      return true\n    end\n  end\n  return false\nend", "\tif l.length\
    \ < 2\n\t\treturn false\n\tend\n\tabsorb_positive_numbers = Hash.new\n\tfor i\
    \ in 0...l.length\n\t\tif l[i] >= 0\n\t\t\tabsorb_positive_numbers[l[i]] = 1\n\
    \t\telse\n\t\t\tif absorb_positive_numbers.has_key?(-l[i])\n\t\t\t\treturn true\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "\tputs l.inspect\n\tfor i in\
    \ 0..l.length - 1\n\t\tfor j in i+1..l.length - 1\n\t\t\tputs \"#{l[i]} #{l[j]}\"\
    \n\t\t\tif l[i] + l[j] == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    return false\nend", "  # your code here\n  return false if l.length < 2", "  #\
    \ TODO\nend", "  return false if l.length <= 1\n  negs = Hash.new(0)\n  pos =\
    \ []\n  for i in 0...l.length\n    if l[i] < 0\n      negs[l[i]] += 1\n    else\n\
    \      pos << l[i]\n    end\n  end\n  for i in 0...pos.length\n    return true\
    \ if negs[-pos[i]] > 0\n  end\n  return false\nend\npairs_sum_to_zero.call([1,\
    \ 3, 5, 0])\npairs_sum_to_zero.call([1, 3, -2, 1])\npairs_sum_to_zero.call([1,\
    \ 2, 3, 7])\npairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\npairs_sum_to_zero.call([1])",
  "  left = 0\n  right = l.length - 1\n  while left < right\n    total = l[left] +\
    \ l[right]\n    if total == 0\n      return true\n    elsif total > 0\n      right\
    \ -= 1\n    else\n      left += 1\n    end\n  end\n  return false\nend", "   \
    \ l.each_with_index do |x, i|\n        l.each_with_index do |y, j|\n         \
    \   if (x + y == 0 && i != j)\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "    pairs = []\n    l.each_with_index\
    \ do |num, i|\n        if i == l.length - 1\n            break\n        end\n\
    \        for i2 in i+1..l.length-1\n            pairs << [num, l[i2]]\n      \
    \  end\n    end\n    pairs.each do |pair|\n        if pair[0] + pair[1] == 0\n\
    \            return true\n        end\n    end\n    return false\nend", "  # Write\
    \ your code here\nend", "  i = 0\n  while i < l.length\n    j = i + 1\n    while\
    \ j < l.length\n      if l[i] + l[j] == 0\n        return true\n      end\n  \
    \    j += 1\n    end\n    i += 1\n  end\n  return false\nend", "  # checks every\
    \ number in list against every other number in list.\n  # returns true if any\
    \ two pair to zero, false otherwise.\n  l.each do |i|\n    l.each do |j|\n   \
    \   if i + j == 0\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  l.map { |a| l.map { |b| return true if a + b == 0 && a != b } }\n  false\n\
    end", "  if l.length < 2\n    return false\n  end\n  i = 0\n  while i < l.length\n\
    \    j = i + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return\
    \ true\n      end\n      j += 1\n    end\n    i += 1\n  end\n  return false\n\
    end", "  if l.size<2\n    return false\n  end\n  l.each_with_index do |e,i|\n\
    \    l.each_with_index do |e2,i2|\n      if i2 > i && e+e2 == 0\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  if l.length < 2\n\
    \    return false\n  end\n  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      if i != j\n        if x + y == 0\n          return true\n \
    \       end\n      end\n    end\n  end\n  return false\nend", "  l.each do |e1|\n\
    \    l.each do |e2|\n      if e1 != e2 && e1 + e2 == 0\n        return true\n\
    \      end\n    end\n  end\n  return false\nend\npairs_sum_to_zero.call([2, 4,\
    \ -5, 3, 5, 7])", "\tl.each do |n|\n\t\tl.each do |m|\n\t\t\tif n != m && n +\
    \ m == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend",
  "  # TODO: return true if the list has two distinct elements that sum to zero, false\
    \ otherwise\n  # l.length.times do |i|\n  #   if l[i] + l[i+1] == 0\n  #     return\
    \ true\n  #   end\n  # end\n  # return false\n  #\n  # if l.length <= 1\n  # \
    \  return false\n  # end\n  #\n  # l.each do |num|\n  #   if l.include? (-num)\n\
    \  #     return true\n  #   end\n  # end\n  #\n  # return false", "  l.each do\
    \ |element|\n    if l.include?(-element) && l.count(element) == 1\n      return\
    \ true\n    end\n  end\n  return false\nend", "  temp = l.combination(2).to_a\n\
    \  temp.each do |sub_array|\n    return true if sub_array.reduce(:+) == 0\n  end\n\
    \  false\nend", "  z = Hash.new{|h,k| h[k] = []}\n  n = l.length\n  for i in 0...n\n\
    \    for j in i+1...n\n      if l[i] + l[j] == 0\n        z[l[i]] << l[j]\n  \
    \    end\n    end\n  end\n  if z.keys.length > 0\n    return true\n  else\n  \
    \  return false\n  end\nend", "  if l.length <= 1\n    return false\n  else\n\
    \    l.each_with_index do |element, index|\n      l.each_with_index do |element2,\
    \ index2|\n        if index2 != index\n          if element + element2 == 0\n\
    \            return true\n          end\n        end\n      end\n    end\n  end\n\
    \  return false\nend", "  # YOUR CODE HERE\nend", "  abs_to_count = Hash.new(0)\n\
    \  l.each do |i|\n    abs_to_count[i.abs] += 1\n  end\n  abs_to_count.each do\
    \ |key, val|\n    if val >= 2\n      return true if key == 0\n      if abs_to_count[key\
    \ * -1] > 0\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  len = l.length\n  my_hash = {}\n  for i in 0..len-1\n    if my_hash.key?(-l[i])\n\
    \      return true\n    else\n      my_hash[l[i]] = 0\n    end\n  end\n  return\
    \ false\nend", end, "  x = 0\n  while x < l.length\n    i = 0\n    while i < l.length\n\
    \      if x != i && l[x] + l[i] == 0\n        return true\n      end\n      i\
    \ += 1\n    end\n    x += 1\n  end\n  return false\nend", "  l.each_with_index\
    \ do |el, idx|\n    l.each_with_index do |other_el, other_idx|\n      if other_idx\
    \ > idx && el + other_el == 0\n        return true\n      end\n    end\n  end\n\
    \  false\nend", "  return false if l.length < 2\n  negatives = l.select { |x|\
    \ x < 0 }\n  positives = l.select { |x| x > 0 }\n  for i in (0...negatives.length)\n\
    \    for j in (0...positives.length)\n      return true if negatives[i] + positives[j]\
    \ == 0\n    end\n  end\n  return false\nend", "  l.each_with_index do |num, index|\n\
    \    (index+1).upto(l.length-1) do |index2|\n      return true if num + l[index2]\
    \ == 0\n    end\n  end\n  false\nend", "    hash = {}\n    l.each do |i|\n   \
    \     if hash[i]\n            return true\n        end\n        hash[-i] = true\n\
    \    end\n    return false\nend", "  l.uniq.combination(2).any? { |a, b| a + b\
    \ == 0 }\nend", "  l.each_with_index do |e,i|\n    (i+1...l.length).each do |j|\n\
    \      return true if l[i] + l[j] == 0\n    end\n  end\n  false\nend", "  # raise\
    \ NotImplementedError.new\n  arr = l.uniq\n  arr.each_with_index do |num,i|\n\
    \    arr.each_with_index do |num2,j|\n      if num+num2 == 0 && i != j\n     \
    \   return true\n      end\n    end\n  end\n  return false\nend", "\tl.combination(2).to_a.each\
    \ { |x| return true if x[0] + x[1] == 0 }\n\treturn false\nend", "  l.each do\
    \ |number|\n    l.each do |number2|\n      if number + number2 == 0\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  l = l.sort\n  (0...l.length-1).each\
    \ do |i|\n    (i+1...l.length).each do |j|\n      return true if l[i] + l[j] ==\
    \ 0\n    end\n  end\n  false\nend", "  # your code here\n  hash = Hash.new(0)\n\
    \  result = false\n  l.each do |x|\n    hash[x] = x if x.is_a? Integer\n  end\n\
    \  hash.each do |k, v|\n    if hash.has_key?(-k)\n      result = true\n    end\n\
    \  end\n  result\nend", "  l.each_with_index do |num1, index1|\n    l.each_with_index\
    \ do |num2, index2|\n      if index1 != index2 && num1 + num2 == 0\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  # You will need to\
    \ write this function.\n  # You may find the method .combination useful for this\
    \ problem.\n  # http://ruby-doc.org/core-2.1.1/Enumerable.html#method-i-combination\n\
    end", "\tres = false\n\tfor i in 0..l.length-1\n\t\tfor j in 0..l.length-1\n\t\
    \t\tif (i != j) and (l[i] + l[j] == 0)\n\t\t\t\tres = true\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn res\nend", "  # YOUR CODE HERE\n  l.combination(2).to_a.each do\
    \ |x|\n    if x[0] + x[1] == 0\n      return true\n    end\n  end\n  return false\n\
    end", "  l.each_with_index do |item, i|\n    if l.include?(-item) && i != l.index(-item)\n\
    \      return true\n    end\n  end\n  return false\nend", "  # return false if\
    \ l.length == 1\n  # l.each_with_index do |num, i|\n  #   l.each_with_index do\
    \ |num2, j|\n  #     return true if num + num2 == 0 && j > i\n  #   end\n  # end\n\
    \  # false\n  # OR\n  # numbers = l.combination(2).to_a\n  # numbers.any? { |pair|\
    \ pair.sum == 0 }\n  # OR\n  return false if l.length == 1\n  l.each_with_index\
    \ do |num, i|\n    l.each_with_index do |num2, j|\n      return true if num +\
    \ num2 == 0 && j > i\n    end\n  end\n  false\nend", "  l.each_with_index do |i,\
    \ index|\n    for j in (index + 1)...l.length\n      return true if i + l[j] ==\
    \ 0\n    end\n  end\n  false\nend", "  h = {}\n  l.each do |x|\n    return true\
    \ if h[-x]\n    h[x] = true\n  end\n  false\nend", "  # your code here\n  for\
    \ i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] + l[j] == 0\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  for\
    \ x in l do\n    for y in l do\n      if l.include?(-(x+y))\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  for i in 0..l.length\n  \
    \  for j in 0..l.length\n      if(i != j)\n        if(l[i] + l[j] == 0)\n    \
    \      return true\n        end\n      end\n    end\n  end\n  return false\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
