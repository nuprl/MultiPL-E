name: HumanEval_43_pairs_sum_to_zero
language: rb
prompt: "# pairs_sum_to_zero takes an array of integers as an input.\n# it returns\
  \ true if there are two distinct elements in the array that\n# sum to zero, and\
  \ false otherwise.\n# >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1,\
  \ 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>>\
  \ pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n\
  # false\ndef pairs_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n\
  \    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5,\
  \ 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true,\
  \ candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3,\
  \ 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n\
  \    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"
completions: ["  l.combination(2).to_a.each do |pair|\n    return true if pair.sum\
    \ == 0\n  end\n  false\nend", "  l.count == l.uniq.count ? false : true\nend",
  "  l.each_with_index do |item1, i|\n    l.each_with_index do |item2, j|\n      if\
    \ (item1 + item2 == 0) && (i != j)\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "    ans = false\n    l.each_with_index do |i, idx|\n\
    \        l.each_with_index do |j, jdx|\n            if (idx != jdx) and (i + j\
    \ == 0)\n                ans = true\n            end\n        end\n    end\n \
    \   return ans\nend", "    # need to move from the start of the array to the end\n\
    \    # do we need to start at the beginning?\n    # if we have a hash of seen\
    \ values\n    # can we keep track of values we have seen?\n    # if we have seen\
    \ an inverse to a value, we can return true\n    # if we haven't seen an inverse\
    \ of a value, add the value to the hash\n    # if the hash is empty, return false\n\
    \    # if we reach the end of the array, return false\n    # if we see a 0, return\
    \ true?\n    # need to know if the number is larger or smaller than 0\n    # need\
    \ to know if the number is + or -\n    # if the number we are looking at is larger\
    \ than 0\n    # if the number we are looking at is smaller than 0\n    # add the\
    \ number to the hash", "  raise NotImplementedError\nend", "  found = false\n\
    \  l.each_with_index do |e,i|\n    (i+1...l.length).each do |j|\n      if l[i]\
    \ + l[j] == 0\n        found = true\n      end\n    end\n  end\n  found\nend",
  "  i = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n      if\
    \ l[i] + l[j] == 0\n        return true\n      end\n      j += 1\n    end\n  \
    \  i += 1\n  end\n  return false\nend", "\tl.size.times do |i|\n\t\tl.size.times\
    \ do |j|\n\t\t\tif i != j && l[i] + l[j] == 0\n\t\t\t\treturn true\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn false\nend", "  tmp = []\n  l.each do |n|\n    if tmp.include?(-n)\n\
    \      return true\n    else\n      tmp << n\n    end\n  end\n  return false\n\
    end", "  ret = l.select { |e| l.include?(-e) && l.index(e) != l.index(-e) }\n\
    \  !ret.empty?\nend", "  # implement your method here, and return the appropriate\
    \ result\nend", "  # TODO: implement this\nend", "  # your code here!\nend", " \
    \ l.length.times do |i|\n    if l.include?(-l[i]) && i != l.index(-l[i])\n   \
    \   return true\n    end\n  end\n  return false\nend", "  negatives = Hash.new(0)\n\
    \  positives = Hash.new(0)\n  l.each do |i|\n    if i < 0\n      negatives[i]\
    \ += 1\n    else\n      positives[i] += 1\n    end\n  end\n  return false if negatives.empty?\
    \ || positives.empty?\n  negatives.each do |k,v|\n    return true if positives.has_key?(-k)\n\
    \  end\n  return false\nend", "  hash = {}\n  l.each_with_index do |e, i|\n  \
    \  hash[e] = true if e == 0\n    return true if hash[-e] && e != 0\n  end\n  false\n\
    end\npairs_sum_to_zero = MethodDefinition.new(:pairs_sum_to_zero, [:l], [\n  VariableAssignment.new(:hash,\
    \ HashObject.new),\n  Call.new(Variable.new(:l), :each_with_index, [\n    Block.new([:e,\
    \ :i], [\n      Call.new(Variable.new(:hash), :[]=, [Variable.new(:e), TrueClassObject.new]),\n\
    \      If.new(\n        BinaryOperation.new(Variable.new(:hash), :[], [BinaryOperation.new(Variable.new(:e),\
    \ :-, [IntegerObject.new(0)])]),\n        BinaryOperation.new(Variable.new(:e),\
    \ :!=, [IntegerObject.new(0)]),\n        Return.new(TrueClassObject.new)\n   \
    \   )\n    ])\n  ]),\n  FalseClassObject.new\n])\npairs_sum_to_zero.check_types(GLOBAL_CONTEXT)",
  "  l.map { |n| n if l.include?(-n) }.compact.uniq.size >= 2\nend", "  t = []\n \
    \ l.each do |x|\n    t += [x]\n    if t.include?(0-x)\n      return true\n   \
    \ end\n  end\n  return false\nend", "  for i in (0...l.length)\n    for j in (i+1...l.length)\n\
    \      if l[i] + l[j] == 0\n        return true\n      end\n    end\n  end\n \
    \ return false\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
