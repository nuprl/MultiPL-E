name: HumanEval_119_match_parens
language: rb
prompt: "# You are given an array of two strings, both strings consist of open\n#\
  \ parentheses '(' or close parentheses ')' only.\n# Your job is to check if it is\
  \ possible to concatenate the two strings in\n# some order, that the resulting string\
  \ will be good.\n# A string S is considered to be good if and only if all parentheses\
  \ in S\n# are balanced. For example: the string '(())()' is good, while the string\n\
  # '())' is not.\n# Return 'Yes' if there's a way to make a good string, and return\
  \ 'No' otherwise.\n# Examples:\n# >>> match_parens.call([\"()(\", \")\"])\n# \"\
  Yes\"\n# >>> match_parens.call([\")\", \")\"])\n# \"No\"\ndef match_parens(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_match_parens\n\
  \    candidate = method(:match_parens)\n    assert_equal(\"Yes\", candidate.call([\"\
  ()(\", \")\"]))\n    assert_equal(\"No\", candidate.call([\")\", \")\"]))\n    assert_equal(\"\
  No\", candidate.call([\"(()(())\", \"())())\"]))\n    assert_equal(\"Yes\", candidate.call([\"\
  )())\", \"(()()(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(())))\", \"\
  (()())((\"]))\n    assert_equal(\"No\", candidate.call([\"()\", \"())\"]))\n   \
  \ assert_equal(\"Yes\", candidate.call([\"(()(\", \"()))()\"]))\n    assert_equal(\"\
  No\", candidate.call([\"((((\", \"((())\"]))\n    assert_equal(\"No\", candidate.call([\"\
  )(()\", \"(()(\"]))\n    assert_equal(\"No\", candidate.call([\")(\", \")(\"]))\n\
  \    assert_equal(\"Yes\", candidate.call([\"(\", \")\"]))\n    assert_equal(\"\
  Yes\", candidate.call([\")\", \"(\"]))\n  end\nend\n"
completions: ["    open_parens = lst[0].count(\"(\")\n    close_parens = lst[1].count(\"\
    )\")\n    if open_parens == close_parens\n        \"Yes\"\n    else\n        \"\
    No\"\n    end\nend", "  (lst[0].count('(') - lst[0].count(')')) + (lst[1].count('(')\
    \ - lst[1].count(')')) == 0 ? 'Yes' : 'No'\nend", "  return \"No\" if lst.join.count(\"\
    )\") > lst.join.count(\"(\")\n  return \"Yes\" if lst.join.count(\")\") == lst.join.count(\"\
    (\")\n  open = 0\n  close = 0\n  lst.join.each_char do |char|\n    if char ==\
    \ \"(\"\n      open += 1\n    else\n      close += 1\n    end\n    return \"No\"\
    \ if close > open\n  end\n  \"Yes\"\nend", "  left, right = lst.first.scan(/\\\
    (/).size, lst.last.scan(/\\)/).size\n  left == right ? 'Yes' : 'No'\nend", " \
    \ s1, s2 = lst\n  stack1 = []\n  stack2 = []\n  s1.each_char do |c|\n    stack1\
    \ << c if c == '('\n    stack1.pop if c == ')'\n  end\n  s2.each_char do |c|\n\
    \    stack2 << c if c == '('\n    stack2.pop if c == ')'\n  end\n  return 'Yes'\
    \ if stack1.empty? && stack2.empty?\n  return 'No'\nend", "  arr = lst.map { |x|\
    \ x.chars }\n  left = arr[0].select { |x| x == \"(\" }\n  right = arr[1].select\
    \ { |x| x == \")\" }\n  if left.length != right.length\n    return \"No\"\n  end\n\
    \  left.length.times do |n|\n    arr[0].delete_at(arr[0].index(\"(\"))\n    arr[1].delete_at(arr[1].index(\"\
    )\"))\n  end\n  return \"Yes\"\nend", "  # your code here\nend", "  lst_str =\
    \ lst.join('')\n  if lst_str.count('(') == lst_str.count(')')\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend", "  s, t = lst[0], lst[1]\n  count_s = 0\n\
    \  count_t = 0\n  s.each_char do |c|\n    if c == '('\n      count_s += 1\n  \
    \  else\n      count_s -= 1\n    end\n    return 'No' if count_s < 0\n  end\n\
    \  t.each_char do |c|\n    if c == '('\n      count_t += 1\n    else\n      count_t\
    \ -= 1\n    end\n    return 'No' if count_t < 0\n  end\n  (count_s + count_t)\
    \ % 2 == 0 ? 'Yes' : 'No'\nend", "  lst[0].to_s + lst[1].to_s == '()' ? 'Yes'\
    \ : 'No'\nend", "  open_and_close = lst.join.split('')\n  while open_and_close.size\
    \ > 0\n    raise unless open_and_close.delete_at(0) == '('\n    open_and_close.delete_at(0)\n\
    \  end\n  'Yes'\nrescue\n  'No'\nend", "  open_count = lst.first.count('(')\n\
    \  close_count = lst.first.count(')')\n  if open_count == close_count\n    lst.first.concat(lst.last)\n\
    \    if  lst.first.scan(/\\(\\)/).size == lst.first.scan(/\\(\\)/).sum { |x| x.length\
    \ / 2 }\n      \"Yes\"\n    else\n      \"No\"\n    end\n  else\n    \"No\"\n\
    \  end\nend", "  s1, s2 = lst\n  return 'Yes' if s1.empty? && s2.empty?\n  return\
    \ 'No' unless s1.count('(') == s2.count(')')", "  str = lst.join\n  if str.count('(')\
    \ == str.count(')')\n    'Yes'\n  else\n    'No'\n  end\nend", "  return \"No\"\
    \ if lst.include?(\")\") && lst.include?(\"(\")\n  return \"Yes\" if lst.include?(\"\
    (\") || lst.include?(\")\")\n  return \"Yes\" if lst.flatten.size.odd?\n  \"No\"\
    \nend", "  # init new array 'total_parens' and fill with the arguments lst\n \
    \ total_parens = Array.new\n  total_parens.push(lst[0], lst[1])\n  # init new\
    \ array 'match_parens' and fill with all parentheses\n  match_parens = Array.new\n\
    \  total_parens.each do |str|\n    match_parens.push(str.scan(/[()]/))\n  end\n\
    \  # count the number of open and closed parentheses\n  num_open = match_parens.join.count('(')\n\
    \  num_close = match_parens.join.count(')')\n  # return 'Yes' if there are at\
    \ least as many open parens as close parens\n  # return 'No' otherwise\n  num_open\
    \ >= num_close ? \"Yes\" : \"No\"\nend", "  str = lst.join('')\n  balanced?(str)\
    \ ? 'Yes' : 'No'\nend", "  lst.join.chars.count(\"(\") == lst.join.chars.count(\"\
    )\") ? \"Yes\" : \"No\"\nend", "  open = []\n  lst.each do |str|\n    str.chars.each\
    \ do |ch|\n      if ch == '('\n        open << '('\n      else\n        return\
    \ 'No' if open.empty?\n        open.pop\n      end\n    end\n  end\n  open.empty?\
    \ ? 'Yes' : 'No'\nend", "  return 'Yes' if lst.empty?\n  dict = {\"(\": 1, \"\
    )\": -1}\n  check = -> str { str.each_char.reduce(0) { |acc, c| return false if\
    \ acc < 0; acc += dict[c.to_sym] } == 0 }\n  check.call(lst.join) ? 'Yes' : 'No'\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
