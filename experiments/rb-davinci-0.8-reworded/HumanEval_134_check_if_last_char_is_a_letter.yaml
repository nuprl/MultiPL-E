name: HumanEval_134_check_if_last_char_is_a_letter
language: rb
prompt: "# Create a function that returns true if the last character\n# of a given\
  \ string is an alphabetical character and is not\n# a part of a word, and false\
  \ otherwise.\n# Note: \"word\" is a group of characters separated by space.\n# Examples:\n\
  # >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\
  apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \"\
  )\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n\
  \    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false,\
  \ candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"\
  ))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"\
  A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false,\
  \ candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"\
  ))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false,\
  \ candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple\
  \ pi e \"))\n  end\nend\n"
completions: ["  return false if txt.length == 0\n  return txt[-1].match(/[a-zA-Z]/)\
    \ && txt[-2].match(/\\s/)\nend", "  return txt[-1] =~ /[a-zA-Z]/\nend", "  # your\
    \ code here\nend", "\tcheck_if_last_char_is_a_letter = lambda {|str| return str.split(\"\
    \ \").last.match(/[a-zA-Z]/) == nil ? false : true}\n\tputs \"Enter a string :\
    \ \"\n\ttxt = gets.chomp\n\tputs check_if_last_char_is_a_letter.call(txt)\nend",
  "  txt.match(/[a-zA-Z]\\s$/) ? true : false\nend", "  if ! txt.end_with?(\" \")\n\
    \    return true\n  else\n    return false\n  end\nend", "  txt[-1].scan(/[a-zA-Z]/).any?\
    \ && txt[-2].scan(/[a-zA-Z]/).none?\nend", "  txt_length = txt.length\n  if txt_length\
    \ == 0\n    false\n  elsif txt[txt_length - 1] =~ /[a-zA-Z]/\n    true\n  else\n\
    \    false\n  end\nend\ncheck_if_last_char_is_a_letter.call(\"apple pie\")\ncheck_if_last_char_is_a_letter.call(\"\
    apple pi e\")\ncheck_if_last_char_is_a_letter.call(\"apple pi e \")\ncheck_if_last_char_is_a_letter.call(\"\
    \")", "  # TODO: Implement this function that\n  # returns the correct value.\n\
    \  if txt == \"\"\n    return false\n  end\n  #if txt[-1] =~ /\\A[a-zA-Z]+\\z/\n\
    \    return txt[-1] =~ /\\A[a-zA-Z]+\\z/ && txt[-2] == \" \"\n  #end\nend", " \
    \ txt[-1] =~ /[a-zA-Z]/ && txt.split.last.size == 1\nend", '  return false if
    txt.empty?', "  if txt[-1] =~ /[a-zA-Z]/ && !txt[-1] =~ /[a-zA-Z]\\s/\n    puts\
    \ true\n  else\n    puts false\n  end\nend\ncheck_if_last_char_is_a_letter(\"\
    apple pie\")\ncheck_if_last_char_is_a_letter(\"apple pi e\")\ncheck_if_last_char_is_a_letter(\"\
    apple pi e \")\ncheck_if_last_char_is_a_letter(\"\")", "  return false if txt.empty?\n\
    \  # if txt[-1] =~ /\\w/ && txt[-2] =~ /\\s/\n  #   true\n  # else\n  #   false\n\
    \  # end\n  return true if txt[-1] =~ /\\w/ && txt[-2] =~ /\\s/\n  false\nend",
  "  txt[-1].match?(/[A-Za-z]/) && txt[-2].match?(/\\s/)\nend", "  return false if\
    \ txt.empty?\n  txt[-1] == \" \" || !(txt[-1] =~ /[[:alpha:]]/) ? false : true\n\
    end", "  # TODO: Your code here.\nend", "  r = txt.split(/ /)\n  r[-1].match(/\\\
    w+$/) ? true : false\nend", "  # Your code here\nend", "  s = txt.split(' ')\n\
    \  return false if s[-1].empty?\n  ('a'..'z').include?(s[-1][-1])\nend", "  txt[-1].match(/[a-zA-Z]/)\
    \ && !txt[-1].match(/\\S/) ? true : false\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
