name: HumanEval_42_incr_list
language: rb
prompt: "# Return array with elements incremented by 1.\n# >>> incr_list.call([1,\
  \ 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6,\
  \ 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n\
  \    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3,\
  \ 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\n\
  end\n"
completions: ["  l.map do |element|\n    element + 1\n  end\nend", "  l.map{|a| a+1}\n\
    end", "  l.map { |i| i + 1 }\nend", "  return l.map { |x| x + 1 }\nend", "  l.map\
    \ { |e| e + 1 }\nend", "  l.map { |item| item + 1 }\nend", "  l.map { |e| e +\
    \ 1 }\nend", "  l.map { |e| e + 1 }\nend", "\tl.map{|x| x + 1}\nend", "  new_list\
    \ = []\n  l.each do |num|\n    new_list << num + 1\n  end\n  new_list\nend", " \
    \ l.map { |i| i + 1 }\nend", "  l.map { |x| x+1 }\nend", "\treturn l.map { |e|\
    \ e + 1 }\nend", "\tl.map{|x| x+1}\nend", "  return l.map{|x| x + 1}\nend\nincr_list([1,\
    \ 2, 3])\nincr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])", "    l.map { |i| i + 1 }\n\
    end", "  ret=[]\n  l.each {|e| ret << e+1}\n  ret\nend", "  l.map { |i| i + 1\
    \ }\nend", "  l.map { |x| x+1 }\nend", "  l.map{|x| x + 1}\nend", "  l.map { |n|\
    \ n + 1 }\nend", "\t# l.map{|x| x + 1}\n\tl.map(&:succ)\nend", "  l.map { |x|\
    \ x + 1 }\nend", end, "  # your code here\nend", "  l.map{|i| i + 1}\nend", " \
    \ l.collect { |x| x+1 }\nend", "  l.map { |v| v + 1 }\nend", "  l.map { |e| e\
    \ + 1 }\nend", "  l.map{|i| i += 1}\nend", "  l.map{|x| x+1}\nend", end, "  l.map\
    \ { |x| x + 1 }\nend", "  l.map { |i| i + 1 }\nend", "  l.map { |i| i + 1 }\n\
    end", "  l.map { |e| e + 1 }\nend", "  incr_list_caller(l, 1)\nend", "  l.map\
    \ { |x| x + 1 }\nend", "  lambda do |func, input|\n    input.map { |i| func.call(i)\
    \ }\n  end.call(incr, l)\nend", "  l.map{|x| x+1}\nend", "    l.map { |e| e +\
    \ 1 }\nend", "    l.map { |i| i + 1 }\nend", "\tl.map { |i| i + 1 }\nend", " \
    \ l.map{|e| e + 1}\nend", "  l.map{|x| x+1}\nend", "\tfor i in 0..l.length-1\n\
    \t\tl[i] += 1\n\tend\n\treturn l\nend", "  l.map { |x| x + 1 }\nend", "  l.map{|x|\
    \ x+1}\nend", "  l.map { |e| e + 1 }\nend", "  l.map { |i| i + 1 }\nend", "  map(l)\
    \ { |e| e + 1 }\nend", "  return l.map { |x| x + 1 }\nend", "  l.map { |element|\
    \ element + 1 }\nend", "  l.map { |i| i + 1 }\nend", "  l.map { |i| i + 1 }\n\
    end", "  l.map { |n| n+1 }\nend", "  l.map { |x| x + 1 }\nend", "  l.map { |item|\
    \ item + 1 }\nend", "  # to be implemented\nend", "  l.map { |x| x + 1 }\nend",
  "  l.map { |e| e + 1 }\nend", "  l.map { |x| x+1 }\nend", "  # l.map { |x| x+1 }\n\
    \  l.map { |x| yield x }\nend", "    l.map { |e| e + 1 }\nend", "  l.map { |i|\
    \ i + 1 }\nend", "  raise ArgumentError unless l.class == Array\n  i = 0\n  while\
    \ i < l.length\n    l[i] += 1\n    i += 1\n  end\n  l\nend", "\tl.map { |e| e\
    \ + 1 }\nend", "\tl.map { |x| x + 1 }\nend", "  l.map { |x| x + 1 }\nend", " \
    \ l.map { |e| e + 1 }\nend", "  l.collect { |x| x + 1 }\nend", "  l.map { |x|\
    \ x + 1 }\nend", "  return l.map{|x| x+1}\nend", "  l.map { |x| x + 1 }\nend",
  "  l.map{|x| x+1}\nend", "  l.map { |i| i + 1 }\nend", "  l.map { |x| x + 1 }\n\
    end", "  l.map { |i| i + 1 }\nend", end, "    l.map { |x| x + 1 }\nend", "  l.map\
    \ { |x| x + 1 }\nend\nputs incr_list([1, 2, 3])\nputs incr_list([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])", "    for i in (0..l.length - 1)\n        l[i] += 1\n    end\n\
    \    return l\nend", "  l.map { |e| e + 1 }\nend", "  l.map { |n| n + 1 }\nend",
  "  l.collect{|x| x+1}\nend", "  l.map { |x| x + 1 }\nend", "  l.map { |n| n + 1\
    \ }\nend", "  l.map { |i| i + 1 }\nend", "    l.map { |e| e + 1 }\nend", "  return\
    \ (l.map { |i| i + 1 })\nend", "  res = []\n  l.each do |element|\n    res <<\
    \ element + 1\n  end\n  res\nend", "  l.map { |e| e+1 }\nend", end, "  l.map {\
    \ |i| i + 1 }\nend", "\tincr_arr = l.map { |e| e += 1 }\n\tputs incr_arr\nend\n\
    incr_list([1, 2, 3])\nincr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\nputs \"*\" * 80",
  "\treturn l.map{|x| x+1}\nend", "  arr = []\n  l.each do |a|\n    arr << a+1\n \
    \ end\n  arr\nend", "  l.map{|x| x+1}\nend", "  return_list = []\n  l.each do\
    \ |x|\n    return_list << x + 1\n  end\n  return_list\nend", "\tl.map { |x| x+1\
    \ }\nend", "\tl.map { |e| e+1 }\nend", "  l.map { |e| e + 1 }\nend", "\tl.map\
    \ { |x| x + 1 }\nend", "  l.map { |x| x + 1 }\nend", "  l.map { |x| x + 1 }\n\
    end", "  i = 0\n  while i < l.length\n    l[i] += 1\n    i += 1\n  end\n  l\n\
    end", "\treturn l.map{|i| i + 1}\nend", "  l.map { |e| e + 1 }\nend", "  l.map\
    \ { |e| e + 1 }\nend", "  if (l.empty?)\n    return []\n  else\n    return [l[0]\
    \ + 1] + incr_list(l[1..-1])\n  end\nend", "  l.map { |i| i + 1 }\nend", "   \
    \ return l.map { |num| num + 1 }\nend", "  l.map { |x| x + 1 }\nend", "  l.map\
    \ { |x| x + 1 }\nend", "  l.map { |n| n + 1 }\nend", "  l.map{|x| x + 1}\nend",
  "  l.map { |n| n + 1 }\nend", "    l.map { |x| x + 1 }\nend", "  l.map { |x| x +\
    \ 1 }\nend", "\treturn l.map { |x| x + 1 }\nend", "    l.map { |x| x + 1 }\nend",
  "  l.map { |i| i + 1 }\nend", "  l.map { |x| x + 1 }\nend", "  l.map { |n| n + 1\
    \ }\nend", "  l.map { |i| i + 1 }\nend", "  l.map { |x| x + 1 }\nend", "  l.map\
    \ { |i| i + 1 }\nend", "\tl.map { |element| element += 1 }\nend", "  l.map { |i|\
    \ i + 1 }\nend", "  # TODO: Implement it\nend", "  for i in 0..l.length-1\n  \
    \  l[i] += 1\n  end\n  return l\nend", "    l.map{|x| x += 1}\nend", "\tl.map\
    \ { |e| e + 1 }\nend", "  l.map do |n|\n    n + 1\n  end\nend", "  l.map{|i| i\
    \ + 1}\nend", "  l.map { |i| i + 1 }\nend", "  l.map { |i| i + 1 }\nend", "  \
    \  l.map { |v| v + 1 }\nend", "  l.map { |e| e + 1 }\nend", "  l.map { |e| e +\
    \ 1 }\nend", "  l.map { |num| num + 1 }\nend", "\tl.map{|x| x+1}\nend", "  l.map\
    \ { |e| e+1 }\nend", "\tl.map { |x| x + 1 }\nend", "  if l.length == 0\n    return\
    \ []\n  else\n    l.map { |i| i + 1 }\n  end\nend", '  # l.map { |e| e + 1 }',
  "  l.map { |e| e + 1 }\nend", "  l.map{|a| a+=1}\nend\nincr_list.call([1, 2, 3])\n\
    incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])", "    return l.map{|x| x+1}\nend",
  "  if l.is_a?(Array)\n    l.map { |e| e + 1 }\n  else\n    raise ArgumentError,\
    \ \"Argument is not an array\"\n  end\nend", "  l.map { |i| i + 1 }\nend", " \
    \ return Proc.new do |array|\n    array.map { |item| item + 1 }\n  end\nend",
  "  l.map{|e| e+1}\nend", "  l.map { |x| x + 1 }\nend", "  l.collect { |i| i + 1\
    \ }\nend", "  l.map { |el| el + 1 }\nend", "    l.map { |i| i + 1 }\nend", " \
    \ l.map { |x| x + 1 }\nend", "  arr = []\n  l.each do |n|\n    arr << n + 1\n\
    \  end\n  arr\nend", "    l.map { |x| x+1 }\nend", "    l.map { |i| i + 1 }\n\
    end", "  l.map { |x| x + 1 }\nend", "  l.map { |x| x + 1 }\nend", "  for i in\
    \ 0..l.length-1\n    l[i] = l[i] + 1\n  end\n  return l\nend", "  l.map { |i|\
    \ i + 1 }\nend", "  l.map { |e| e + 1 }\nend", "  l.map { |e| e + 1 }\nend", " \
    \ l.map{|e| e + 1}\nend", "  l.map { |x| x+1 }\nend", "  l.map { |x| x + 1 }\n\
    end", "  l.map { |e| e + 1 }\nend", "    l.map{|x| x + 1}\nend", "  l.map { |n|\
    \ n + 1 }\nend", "  l.collect { |i| i + 1 }\nend", "\tl.map { |e| e + 1 }\nend",
  "  # your code here\nend", "  l.collect { |num| num + 1 }\nend", "  l.map { |i|\
    \ i + 1 }\nend", "  return l.map{|e| e + 1}\nend", "  return l.map { |x| x + 1\
    \ }\nend", "  # write your code here\nend", "  l.map { |e| e + 1 }\nend", "  l.map{|x|\
    \ x+1}\nend", "    l.map do |e|\n        e + 1\n    end\nend", "\tl.map { |x|\
    \ x + 1 }\nend\nputs \"Exercise 2\"\nincr_list([1, 2, 3])", "  l.map { |i| i +\
    \ 1 }\nend", "  l.map { |i| i + 1 }\nend", "  l.map { |x| x + 1 }\nend", "  l.map\
    \ { |num| num + 1 }\nend", "\tl.map { |x| x + 1 }\nend", "  l.collect{|num| num\
    \ + 1}\nend", "  l.map { |e| e + 1 }\nend", "    l.map { |n| n + 1 }\nend", " \
    \ l.map{|i| i+1}\nend", "  l.map { |e| e + 1 }\nend", "  l.map { |e| e + 1 }\n\
    end", "  l.map { |i| i + 1 }\nend", "  l.map { |e| e + 1 }\nend", "  l.map{|e|\
    \ e + 1}\nend", "  l.map { |i| i + 1 }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
