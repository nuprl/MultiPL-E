name: HumanEval_10_make_palindrome
language: rb
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"\
  cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n\
  \    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\"\
  , candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n\
  \    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"
completions: ["  1.upto(string.length) do |postfix_length|\n    postfix = string[-postfix_length..-1]\n\
    \    prefix = string[0..-postfix_length-1]\n    return string + prefix.reverse\
    \ if postfix == postfix.reverse\n  end\n  return string\nend", "  longest_palindrome_suffix\
    \ = longest_palindrome_suffix(string)\n  suffix_index = string.length - longest_palindrome_suffix.length\n\
    \  prefix = string[0..suffix_index - 1]\n  prefix.reverse + string\nend", "  i\
    \ = (string.length - 1) / 2\n  while !is_palindrome?(string[0..i]) && i >= 0\n\
    \    i -= 1\n  end\n  string[(i + 1)..-1].reverse + string\nend", "  suffix_len\
    \ = max_palindrome_length(string)\n  return string if suffix_len == string.length\n\
    \  string + string[0..-suffix_len-1].reverse\nend", "  longest_palindrome_suffix\
    \ = (0..string.length - 1).map { |i| [i, string[i..-1]] }.max_by { |i, suffix|\n\
    \    (0..(suffix.length - 1)).reverse_each.take_while { |j| suffix[j] == suffix[-j\
    \ - 1] }.length\n  }[1]\n  string[0..-longest_palindrome_suffix.length - 1].reverse\
    \ + string\nend", "  palindrome = longest_palindrome_postfix(string)\n  prefix\
    \ = string[0..string.index(palindrome) - 1]\n  prefix + palindrome + prefix.reverse\n\
    end", "  return string if string.palindrome?\n  return \"#{string}#{string.reverse}\"\
    \ if string.chars.length == 1\n  palindrome_suffix = palindrome_suffix(string)\n\
    \  \"#{string[0...-palindrome_suffix.length]}#{palindrome_suffix}#{string[0...-palindrome_suffix.length].reverse}\"\
    \nend", "  return string if string.size == 0\n  postfix = longest_palindromic_suffix(string)\n\
    \  prefix = string[0, string.size - postfix.size]\n  prefix + postfix + prefix.reverse\n\
    end", "  return string if palindrome?(string)\n  longest_postfix_length = (1..string.length).each\
    \ do |length|\n    return string.length if palindrome?(string[string.length -\
    \ length..-1])\n  end\n  string << string[0...(string.length - longest_postfix_length)].reverse\n\
    end", "  string + string[0...find_longest_palindrome_prefix(string)].reverse\n\
    end", "  string.reverse + string[0..last_palindrome_index(string)].reverse\nend",
  "  suffix = longest_palindromic_suffix(string)\n  string + reverse(string[0...-suffix.length])\n\
    end", "  # find longest postfix that is a palindrome\n  found = false\n  string.chars.reverse.each_with_index\
    \ do |char, i|\n    if string[-i-1] == char\n      suffix = string[-i-1..-1]\n\
    \      prefix = string[0..-i-2]\n      found = true\n      break\n    end\n  end\n\
    \  return string if not found", "  reverse = string.reverse\n  return string if\
    \ string == reverse", "  palindrome_suffix = palindrome_suffix(string)\n  prefix\
    \ = string[0..-(palindrome_suffix.length + 1)]\n  palindrome_suffix + prefix.reverse\n\
    end", "  return string if string.size == 0\n  longest_postfix = string[0]\n  for\
    \ i in 1..string.size\n    longest_postfix = string[i..-1] if string[i..-1] ==\
    \ string[i..-1].reverse\n  end\n  preffix = string[0...string.size - longest_postfix.size]\n\
    \  string << preffix.reverse\nend", '  return string if string.empty?', "  return\
    \ string if string.length <= 1\n  suffix = find_suffix(string)\n  string + reverse(string[0..(string.length\
    \ - suffix.length - 1)])\nend", "  #check if string is already a palindrome\n\
    \  return string if is_palindrome(string)\n  #find the longest suffix that is\
    \ a palindrome\n  #there is no need to look beyond the string[1..-1] as the first\
    \ letter can't be part of the palindrome (by definition)\n  suffix = \"\"\n  (1..string.length).each\
    \ do |i|\n    suffix = string[i..-1]\n    break if is_palindrome(suffix)\n  end\n\
    \  string << reverse(string[0..-1-suffix.length])\nend", '  return string if string.size
    <= 1']
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
