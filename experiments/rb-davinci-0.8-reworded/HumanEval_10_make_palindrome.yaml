name: HumanEval_10_make_palindrome
language: rb
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"\
  cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n\
  \    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\"\
  , candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n\
  \    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"
completions: ["  1.upto(string.length) do |postfix_length|\n    postfix = string[-postfix_length..-1]\n\
    \    prefix = string[0..-postfix_length-1]\n    return string + prefix.reverse\
    \ if postfix == postfix.reverse\n  end\n  return string\nend", "  longest_palindrome_suffix\
    \ = longest_palindrome_suffix(string)\n  suffix_index = string.length - longest_palindrome_suffix.length\n\
    \  prefix = string[0..suffix_index - 1]\n  prefix.reverse + string\nend", "  i\
    \ = (string.length - 1) / 2\n  while !is_palindrome?(string[0..i]) && i >= 0\n\
    \    i -= 1\n  end\n  string[(i + 1)..-1].reverse + string\nend", "  suffix_len\
    \ = max_palindrome_length(string)\n  return string if suffix_len == string.length\n\
    \  string + string[0..-suffix_len-1].reverse\nend", "  longest_palindrome_suffix\
    \ = (0..string.length - 1).map { |i| [i, string[i..-1]] }.max_by { |i, suffix|\n\
    \    (0..(suffix.length - 1)).reverse_each.take_while { |j| suffix[j] == suffix[-j\
    \ - 1] }.length\n  }[1]\n  string[0..-longest_palindrome_suffix.length - 1].reverse\
    \ + string\nend", "  palindrome = longest_palindrome_postfix(string)\n  prefix\
    \ = string[0..string.index(palindrome) - 1]\n  prefix + palindrome + prefix.reverse\n\
    end", "  return string if string.palindrome?\n  return \"#{string}#{string.reverse}\"\
    \ if string.chars.length == 1\n  palindrome_suffix = palindrome_suffix(string)\n\
    \  \"#{string[0...-palindrome_suffix.length]}#{palindrome_suffix}#{string[0...-palindrome_suffix.length].reverse}\"\
    \nend", "  return string if string.size == 0\n  postfix = longest_palindromic_suffix(string)\n\
    \  prefix = string[0, string.size - postfix.size]\n  prefix + postfix + prefix.reverse\n\
    end", "  return string if palindrome?(string)\n  longest_postfix_length = (1..string.length).each\
    \ do |length|\n    return string.length if palindrome?(string[string.length -\
    \ length..-1])\n  end\n  string << string[0...(string.length - longest_postfix_length)].reverse\n\
    end", "  string + string[0...find_longest_palindrome_prefix(string)].reverse\n\
    end", "  string.reverse + string[0..last_palindrome_index(string)].reverse\nend",
  "  suffix = longest_palindromic_suffix(string)\n  string + reverse(string[0...-suffix.length])\n\
    end", "  # find longest postfix that is a palindrome\n  found = false\n  string.chars.reverse.each_with_index\
    \ do |char, i|\n    if string[-i-1] == char\n      suffix = string[-i-1..-1]\n\
    \      prefix = string[0..-i-2]\n      found = true\n      break\n    end\n  end\n\
    \  return string if not found", "  reverse = string.reverse\n  return string if\
    \ string == reverse", "  palindrome_suffix = palindrome_suffix(string)\n  prefix\
    \ = string[0..-(palindrome_suffix.length + 1)]\n  palindrome_suffix + prefix.reverse\n\
    end", "  return string if string.size == 0\n  longest_postfix = string[0]\n  for\
    \ i in 1..string.size\n    longest_postfix = string[i..-1] if string[i..-1] ==\
    \ string[i..-1].reverse\n  end\n  preffix = string[0...string.size - longest_postfix.size]\n\
    \  string << preffix.reverse\nend", '  return string if string.empty?', "  return\
    \ string if string.length <= 1\n  suffix = find_suffix(string)\n  string + reverse(string[0..(string.length\
    \ - suffix.length - 1)])\nend", "  #check if string is already a palindrome\n\
    \  return string if is_palindrome(string)\n  #find the longest suffix that is\
    \ a palindrome\n  #there is no need to look beyond the string[1..-1] as the first\
    \ letter can't be part of the palindrome (by definition)\n  suffix = \"\"\n  (1..string.length).each\
    \ do |i|\n    suffix = string[i..-1]\n    break if is_palindrome(suffix)\n  end\n\
    \  string << reverse(string[0..-1-suffix.length])\nend", '  return string if string.size
    <= 1', "  # Find the longest palindromic suffix of the string.\n  suffix = longest_palindromic_suffix(string)\n\
    \  # If we reached the end of the string and have not found a palindrome,\n  #\
    \ then the string itself is the longest palindromic suffix.\n  if suffix.nil?\n\
    \    suffix = string\n  end\n  # Otherwise, extract the substring that precedes\
    \ the palindromic suffix.\n  prefix = string[0...(string.length - suffix.length)]\n\
    \  # Append the reversed prefix to the end of the string.\n  prefix + string\n\
    end", "  index = string.size - 1\n  index -= 1 while index >= 0 && !palindrome?(string[index..-1])\n\
    \  string + string[0..index-1].reverse\nend", "  string + reverse(string[0..palindrome_suffix_size(string)-1])\n\
    end", '  return string if string.length <= 1', "  if string.empty?\n    return\
    \ string\n  end", "  return string if string.length == 0\n  return string * 2\
    \ if string.length == 1\n  return string * 2 if string.length == 2 && string[0]\
    \ == string[1]", "  longest_palindrome_suffix = find_longest_palindrome_suffix(string)\n\
    \  # reverse of the string before the longest palindrome suffix\n  prefix_reversed\
    \ = string[0..(string.length - longest_palindrome_suffix.length - 1)].reverse\n\
    \  string + prefix_reversed\nend", "  pre = ''\n  post = ''\n  (0..string.length-1).each\
    \ do |i|\n    pre = string[0..i]\n    post = string[i+1..-1]\n    if pre == post.reverse\n\
    \      return string+post.reverse\n    end\n  end\n  string+post.reverse\nend",
  "  suffix_length = longest_palindromic_suffix_length(string)\n  prefix = string[0...(string.length\
    \ - suffix_length)]\n  \"#{string}#{prefix.reverse}\"\nend", "  reverse = string.reverse\n\
    \  index_of_matching_prefix = string.index(reverse)\n  palindrome = string + reverse[index_of_matching_prefix.succ..-1]\n\
    end", "  longest_palindrome = find_longest_palindrome(string)\n  string + reverse(string[0...(string.length\
    \ - longest_palindrome.length)])\nend", "  max_palindrome_suffix_length = max_palindrome_length(string.split('').reverse.join)\n\
    \  string + string[0...string.length - max_palindrome_suffix_length].reverse\n\
    end", "  longest_palindrome = \"\"\n  (0..string.length).each do |i|\n    suffix\
    \ = string[i..-1]\n    if is_palindrome(suffix)\n      longest_palindrome = suffix\n\
    \      break\n    end\n  end\n  string.chop + string[0..string.length - 1 - longest_palindrome.length].reverse\
    \ + longest_palindrome\nend", "  string << string[0...longest_palindrome_suffix(string).size].reverse\n\
    end", "  index = 0\n  (0..string.length).each do |i|\n    index = i if is_palindrome?(string[i..-1])\n\
    \  end\n  return string + string[0..index-1].reverse\nend", "  return string if\
    \ palindrome?(string)\n  prefix = string[0..-1]\n  suffix = string[1..-1]\n  return\
    \ make_palindrome(suffix) + prefix.reverse\nend", "  return string if string.size\
    \ <= 1\n  palindrome_suffix = longest_palindrome_suffix(string)\n  if palindrome_suffix\
    \ == string\n    string.reverse\n  else\n    string[palindrome_suffix.size...string.size]\
    \ + string + string[0, palindrome_suffix.size].reverse\n  end\nend", "  longest_palindrome_length\
    \ = calc_longest_palindrome_length(string)\n  prefix = string[0, string.length\
    \ - longest_palindrome_length]\n  postfix = string[string.length - longest_palindrome_length,\
    \ string.length]\n  \"#{postfix}#{prefix.reverse}\"\nend", "  return \"\" if string.empty?\n\
    \  return string if palindrome?(string)\n  longest_prefix = expand_around_center(string)\n\
    \  prefix = string[0...(string.length - longest_prefix.length)]\n  palindrome\
    \ = longest_prefix + prefix.reverse\nend", "  reverse_string = string.reverse\n\
    \  (1..string.length).each do |i|\n    if string[0, i] == reverse_string[0, i]\n\
    \      return string + reverse_string[i..-1]\n    end\n  end\n  return string\
    \ + reverse_string\nend", "  return \"\" if string.nil? || string.empty?\n  return\
    \ string if string.length == 1", "  return \"\" if string.nil? || string.length\
    \ == 0\n  i = 0\n  j = string.length - 1\n  while i < j && string[i] == string[j]\n\
    \    i += 1\n    j -= 1\n  end\n  return string if i >= j\n  return make_palindrome(string[0..i])\
    \ + make_palindrome(string[i+1..-1])\nend", "  make_palindrome_recursive(string,\
    \ string.length)\nend", "  return string if string.length < 2\n  longest_palindrome_suffix_length\
    \ = 0\n  0.upto(string.length - 1) do |i|\n    if is_palindrome?(string[i..-1])\n\
    \      longest_palindrome_suffix_length = string.length - i\n      break\n   \
    \ end\n  end\n  reverse_suffix = string[0...string.length - longest_palindrome_suffix_length].reverse\n\
    \  string + reverse_suffix\nend", '  return string if string.length < 2', "  if\
    \ string.size == 0\n    \"\"\n  else\n    longest_palindromic_suffix(string) +\
    \ string.reverse.gsub(longest_palindromic_suffix(string).reverse, \"\")\n  end\n\
    end", "  raise \"Empty string can't be palindromized\" if string.nil? || string.empty?\n\
    \  palindrome_index = find_longest_palindrome_substring_index(string)\n  string\
    \ + string[0...palindrome_index].reverse\nend", '  return string if string.length
    < 2', "  lps = longest_palindromic_suffix(string)\n  string + reverse(string[0..-lps.length\
    \ - 1])\nend", "  return string if string.empty?\n  suffix = \"\"\n  (string.length-1).downto(0)\
    \ do |i|\n    suffix = string[i] + suffix\n    prefix = string[0...i]\n    return\
    \ string + reverse(prefix) if suffix == reverse(suffix)\n  end\n  nil\nend", " \
    \ string_length = string.length\n  return string if string_length == 0\n  longest_palin_suffix_length\
    \ = longest_palindromic_suffix_length(string)\n  prefix = string[0..-longest_palin_suffix_length\
    \ - 1]\n  prefix.reverse + string\nend", "  return string if string.length ==\
    \ 0\n  longest_suffix = longest_suffix_palindrome(string)\n  prefix = string[0...(string.length\
    \ - longest_suffix.length)]\n  prefix.reverse + string\nend", '  return string
    if string.empty?', "  return string if string.size < 2\n  prefix = string.chars.take_while\
    \ { |char| string[0] != char }.join\n  postfix = string.chars.drop(prefix.size).join\n\
    \  return string if prefix.size == 0\n  return string if prefix == postfix.reverse\n\
    \  reversed_prefix = prefix.reverse\n  find_longest_common_prefix(reversed_prefix,\
    \ postfix)\nend", '  return string if string.empty?', "  solution = string\n \
    \ for current_length in string.length..0\n    prefix = string[0..current_length]\n\
    \    if palindrome?(prefix)\n      solution = prefix + string[current_length+1..-1].reverse\n\
    \      break\n    end\n  end\n  solution\nend", "  # In case string is empty or\
    \ a single character\n  return string if string.length < 2", "  string_length\
    \ = string.length\n  return string if string_length == 0", "  len = string.length\n\
    \  return string if len <= 1\n  1.upto(len) do |i|\n    substring = string[0,\
    \ i]\n    return substring + make_palindrome(string[i, len - i]) if substring\
    \ == substring.reverse\n  end\nend", "  l = palindromic_length(string)\n  return\
    \ string if l == string.length\n  return string[0..l] + string[0..l-1].reverse\n\
    end", "  # First find the longest postfix of string that is a palindrome\n  #\
    \ by concatenating string with its reverse and then finding\n  # the longest common\
    \ prefix of resulting string with its reverse.\n  # That prefix is a longest postfix\
    \ of original string that is a palindrome.\n  reverse = string.reverse\n  candidate\
    \ = string + reverse\n  suffix = candidate.common_prefix(candidate.reverse)\n\
    \  # Then append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n  string + reverse[suffix.length, reverse.length\
    \ - suffix.length]\nend", "  return string if string.empty?\n  # Find the longest\
    \ postfix that is a palindrome.\n  longest_postfix = longest_substring_palindrome(string)\n\
    \  # Append to the string reverse of the prefix that precedes the postfix.\n \
    \ prefix = string[0, (string.length - longest_postfix.length)]\n  string << prefix.reverse\n\
    end", "  return \"\" if string.empty?\n  longest_palindrome_postfix(string) +\
    \ string.reverse[string.length - palindrome_length(string)..-1]\nend", "  (string.size\
    \ - 1).downto(0) do |index|\n    return string + string[0...index].reverse if\
    \ string[index..-1] == string[index..-1].reverse\n  end\n  string\nend", "  return\
    \ string if string.empty?\n  longest_suffix = longest_palindromic_suffix(string)\n\
    \  left_part = string[0..-longest_suffix.length - 1]\n  left_part + longest_suffix\
    \ + left_part.reverse\nend", "  puts string\n  # If a string is a palindrome,\
    \ return it, we are done.\n  if string.is_palindrome?\n    return string\n  end",
  "  prefix = string[0..string.length / 2 - 1]\n  reverse_prefix = prefix.reverse\n\
    \  suffix = string[prefix.length..-1]\n  suffix = suffix.reverse if suffix !=\
    \ suffix.reverse\n  prefix + suffix\nend", "  string.length.downto(0) do |i|\n\
    \    a = string[0, i]\n    b = string[i, string.length]\n    return b + a.reverse\
    \ if a == a.reverse\n  end\nend", "  p = 1\n  if string.empty?\n    return \"\"\
    \n  end\n  while !string[p..-1].nil? && !string[0..-p].nil? && string[p..-1] !=\
    \ string[0..-p].reverse\n    p += 1\n  end\n  string + string[0..-p].reverse\n\
    end", "  return string if string.size == 0\n  return string + string.reverse if\
    \ string.size == 1\n  return string + string[1..-1].reverse if string[0] == string[-1]",
  "  # Find the length of the longest palindromic suffix of the string\n  max_length\
    \ = 0\n  max_length = (1..string.length).each do |i|\n    break i - 1 if (string[i,\
    \ string.length] == string[i, string.length].reverse)\n  end", "  longest_suffix_palindrome\
    \ = longest_suffix_palindrome(string)\n  string[0..-longest_suffix_palindrome.length-1].reverse\
    \ + string\nend", "  # Find the longest palindromic suffix of the string.\n  result\
    \ = string.length.downto(0).find do |size|\n    suffix = string[-size..-1]\n \
    \   suffix == suffix.reverse\n  end", "  return string if string.length < 2\n\
    \  longest_palindrome_suffix = palindrome_suffix(string)\n  reverse_of_prefix\
    \ = string[0...(string.length - longest_palindrome_suffix.length)].reverse\n \
    \ string << reverse_of_prefix\nend", "  return string if palindrome?(string)\n\
    \  reverse_string = string.reverse\n  length = string.length\n  # Find the shortest\
    \ palindrome by finding a postfix that is a palindrome.\n  # It is guaranteed\
    \ to be a postfix since its reverse is also a prefix.\n  length.times do |index|\n\
    \    if palindrome?(string[index, length - index])\n      return string + reverse_string[0,\
    \ index]\n    end\n  end\nend", "  return string if string.empty?\n  string.prepend(string.reverse.chop)\n\
    end", '  return string if string.length <= 1', "  if string.size == 0\n    return\
    \ string\n  end", "  longest_palindrome = longest_palindrome_suffix(string)\n\
    \  return string if longest_palindrome == string\n  string + string[0..-longest_palindrome.length\
    \ - 1].reverse\nend", "  length = string.length\n  return \"\" if length.zero?\n\
    \  # Find the length of the longest palindromic suffix in the string.\n  # We\
    \ start with the assumption that there is no such suffix.\n  j = 0\n  # Now we\
    \ traverse the string until we find such palindromic suffix.\n  (0...length /\
    \ 2).each do |i|\n    # Find the next palindromic suffix.\n    until string[i]\
    \ == string[length - 1 - j]\n      j += 1\n    end\n    # Reverse the string prefix\
    \ that comes before the palindromic suffix.\n    return string + string[0...length\
    \ - j].reverse\n  end\n  # If we are here it means that the whole string is a\
    \ palindrome.\n  string\nend", "  return string if string.length <= 1\n  while\
    \ string.length > 0 do\n    return string + string[0...(string.length - 1)].reverse\
    \ if palindrome?(string)\n    string = string[0...(string.length - 1)]\n  end\n\
    end", "  palindrome = string\n  string.reverse.each_char do |char|\n    palindrome\
    \ << char\n    break if is_palindrome?(palindrome)\n  end\n  palindrome\nend",
  "  string << string[0..make_palindrome_suffix_length(string) - 1].reverse\nend",
  "  string << string[0...find_longest_palindrome_suffix(string)].reverse\nend", " \
    \ string_length = string.length\n  max_suffix_length = max_palindrome_suffix_length(string)\n\
    \  max_prefix_length = string_length - max_suffix_length\n  make_string(string[max_prefix_length,\
    \ max_suffix_length] + reverse(string[0, max_prefix_length]))\nend", "  if string.empty?\n\
    \    return string\n  end", "  string << string[0..find_palindrome_suffix(string,\
    \ string.length)].reverse\nend", "  return string if string.empty?\n  suffix =\
    \ find_longest_suffix_palindrome(string)\n  return string if suffix == string\n\
    \  prefix = string[0...-suffix.length]\n  prefix.reverse + string\nend", "  #\
    \ There are many approaches to find the longest palindromic suffix.\n  # 1. We\
    \ could use Manacher's algorithm. It's pretty expensive (O(n)) in terms of time\
    \ and space.\n  # 2. We could use suffix tree. It's more efficient (O(n) time\
    \ and O(n) space) than Manacher's algorithm,\n  #    but still not efficient enough\
    \ for the solution.\n  # 3. We could use KMP algorithm. It's more efficient (O(n)\
    \ time and O(1) space) than previous two algorithms,\n  #    but still not efficient\
    \ enough for the solution.\n  # 4. We could use brute force search. It's not efficient\
    \ enough for the solution.\n  # 5. We could use Dynamic Programming approach.\
    \ It's the most efficient (O(n) time and O(1) space).\n  # 6. We could find the\
    \ largest prefix of the string that is equal to the suffix of the string.\n  #\
    \    It's a bit more optimal (O(n) time and O(1) space) compared to DP and more\
    \ readable.\n  longest_palindromic_suffix_index = (0...string.length).find do\
    \ |index|\n    string[0...index] == string[string.length - index..-1]\n  end",
  "  string << reverse(string[0..(palindrome_suffix_length(string) - 1)])\nend", '  return
    string if string.empty?', "  suffix = suffix_as_palindrome(string)\n  if suffix\
    \ == string.length\n    string\n  else\n    string + reverse(string[0..(string.length\
    \ - suffix - 1)])\n  end\nend", "  longest_postfix = \"\"\n  i = 0\n  while i\
    \ < string.length\n    substr = string[i..-1]\n    if substr == substr.reverse\n\
    \      longest_postfix = substr\n      break\n    end\n    i += 1\n  end\n  string\
    \ + string[0...(string.length - longest_postfix.length)].reverse\nend", "  longest_postfix\
    \ = longest_palindromic_postfix(string)\n  prefix = string[0...-longest_postfix.length]\n\
    \  string + prefix.reverse\nend", "  return \"\" if string.empty?\n  longest_palindrome_suffix\
    \ = LongestPalindromeSuffix.call(string)\n  rest_of_string = string[0..(string.length\
    \ - longest_palindrome_suffix.length - 1)]\n  longest_palindrome_suffix + rest_of_string.reverse\n\
    end", "  (string.length-1).downto(0) do |i|\n    if is_palindrome?(string[i..-1])\n\
    \      return string + string[0...i].reverse\n    end\n  end\n  string + string.reverse\n\
    end", "  len = string.length\n  palindrome_length = len\n  len.times do |i|\n\
    \    if is_palindrome?(string[i..len])\n      palindrome_length = i\n      break\n\
    \    end\n  end\n  prefix = string[0..palindrome_length-1]\n  return string +\
    \ prefix.reverse\nend", "  return string if palindrome?(string)\n  longest_palindrome_suffix\
    \ = find_longest_palindrome_suffix(string)\n  suffix_end_index = string.length\
    \ - longest_palindrome_suffix.length\n  # Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n  string + string[0..suffix_end_index\
    \ - 1].reverse\nend", "  return \"\" if string.empty?\n  string.reverse!\n  string\
    \ << string.slice!(0..longest_palindromic_suffix(string))\nend", "  return string\
    \ if string.length == 0\n  palindrome_suffix = find_palindrome_suffix(string)\n\
    \  string_prefix = string[0, string.length - palindrome_suffix.length]\n  string_prefix.reverse\
    \ + string\nend", "  string + string[0...find_suffix_length(string)].reverse\n\
    end", "  lps = longest_palindromic_suffix(string)\n  string + reverse(string[0..(string.length\
    \ - lps - 1)])\nend", "  postfix = longest_palindromic_suffix(string)\n  postfix\
    \ << string[0..(string.length - postfix.length - 1)].reverse\nend", "  longest_palindrome\
    \ = \"\"\n  start_index = 0\n  end_index = 0\n  (0..string.length).each do |idx|\n\
    \    end_index = idx\n    sub_string = string[start_index..end_index]\n    longest_palindrome\
    \ = sub_string if is_palindrome?(sub_string)\n  end\n  (string.length - 1).downto(0).each\
    \ do |idx|\n    start_index = idx\n    sub_string = string[start_index..end_index]\n\
    \    longest_palindrome = sub_string if is_palindrome?(sub_string)\n  end\n  string\
    \ + reverse(string[0...longest_palindrome.length])\nend", "  j = 0\n  (string.length\
    \ - 1).downto(0) do |i|\n    break if string[i] == string[j]\n    j += 1\n  end\n\
    \  string.reverse[0..j] + string\nend", "  tail = find_longest_palindrome_tail(string)\n\
    \  return string if tail.nil?", "  string << string[0...(find_palindrome_suffix(string).size)].reverse\n\
    end", "  longest_palindrome_suffix(string)\n    .map(&:reverse)\n    .reduce(string)\
    \ { |acc, el| acc + el }\nend", "  string = string.to_s\n  string.gsub!(/(.*)(.*?)\\\
    2\\1/, '\\1\\2\\1')\n  string + string.reverse\nend", "  string + string[0...-find_palindrome_length(string)].reverse\n\
    end", "  s = string.dup\n  suffix = suffix_palindrome(s)\n  prefix = prefix_palindrome(s)\n\
    \  s + reverse(prefix)\nend", "  return string if palindrome?(string)\n  last_palindrome_index\
    \ = 0\n  1.upto(string.length - 1) do |i|\n    last_palindrome_index = i if palindrome?(string[i..-1])\n\
    \  end\n  string + string[0..-last_palindrome_index - 1].reverse\nend", "  for\
    \ i in (string.length - 1).downto(0)\n    if is_palindrome?(string[0..i])\n  \
    \    return string[0..i] + reverse(string[i+1..-1])\n    end\n  end\n  \"\"\n\
    end", "  return string if string.length <= 1\n  string + string[0...-1].reverse\n\
    end", "  return \"\" if string.empty?\n  return string if string.length == 1\n\
    \  # check if there are any palindromes that end on the last character\n  # note\
    \ that there can only be 0 or 1 palindromes that end on the last character\n \
    \ if palindrome_exists?(string[0..-2])\n    # string is already a palindrome\n\
    \    return string if string == string.reverse\n    string << string[0..-2].reverse\n\
    \  else\n    # find the biggest palindrome that ends on the second last character\n\
    \    palindrome_end_index = find_palindrome_end_index(string[0..-2])\n    string\
    \ << string[0..palindrome_end_index-1].reverse\n  end\n  string\nend", "  longest_palindrome_at_end\
    \ = (0..string.length).detect { |i| palindrome?(string.slice(i..-1)) }\n  string\
    \ + string.slice(0, string.length - longest_palindrome_at_end).reverse\nend",
  "  return string if string.length < 2\n  for i in 0..string.length-1\n    if is_palindrome?(string[i..-1])\n\
    \      return string + string[0...i].reverse\n    end\n  end\nend", "  i = 0\n\
    \  n = string.length\n  while (i < n / 2) && (string[i] == string[n - i - 1])\n\
    \    i += 1\n  end\n  string + string[0..n - i - 2].reverse\nend", "  postfix\
    \ = \"\"\n  (string.length).downto(0) do |i|\n    break if is_palindrome?(string[i..-1])\n\
    \    postfix = string[i..-1] + postfix\n  end\n  string + postfix.reverse\nend",
  "  postfix = longest_palindromic_suffix(string)\n  string + reverse(string.slice(0,\
    \ string.length - postfix.length))\nend", "  return string if string.size <= 1\n\
    \  string = string + string.reverse\n  suffix_pos = string.size - 1\n  longest_suffix_palindrome\
    \ = 0\n  i = string.size - 1\n  while i >= 0\n    longest_suffix_palindrome =\
    \ i if string[0, i + 1] == string[suffix_pos, suffix_pos - i + 1]\n    i -= 1\n\
    \  end\n  prefix = string[longest_suffix_palindrome, string.size - longest_suffix_palindrome]\n\
    \  string + prefix.reverse\nend", "  s = string.dup\n  lps = find_longest_palindromic_substring(s)\n\
    \  if lps == s.size\n    s\n  else\n    s << s[0..-lps-1].reverse\n  end\nend",
  "  # We will use this object to find the longest palindromic suffix.\n  palindrome_finder\
    \ = PalindromeFinder.new(string)\n  # Find the longest palindromic suffix.\n \
    \ longest_palindrome_suffix = palindrome_finder.longest_palindrome_suffix(0, string.length\
    \ - 1)\n  # Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n  string.concat(longest_palindrome_suffix.reverse)\n\
    end", "  suffix = suffix_palindrome(string)\n  prefix = string[0...string.length\
    \ - suffix.length]\n  prefix + suffix + prefix.reverse\nend", "  if string.length\
    \ == 0\n    return string\n  end", "  palindrome_suffix = string.suffix_longest_palindrome_part\n\
    \  \"#{string}#{string[0...palindrome_suffix.length].reverse}\"\nend", '  return
    string if string.empty?', '  return string if string.empty?', "  palindrome_suffix\
    \ = find_longest_palindrome_suffix(string)\n  prefix = string[0..-palindrome_suffix.length\
    \ - 1]\n  prefix.reverse + string\nend", "  # indices of palindromic substring\n\
    \  # by convention the first index is 0 and the second is 1\n  # (i.e. the empty\
    \ string is a palindrome)\n  # i.e. for \"cata\", the longest palindromic postfix\
    \ ends at index 4,\n  # and the longest palindromic prefix ends at index 2\n \
    \ # (note, we don't need the index of prefix start)\n  indices = string.each_char.reduce([[0,\
    \ 1]]) do |result, char|\n    # position of the preceding and the post-following\
    \ palindromic substring,\n    # if it exists\n    # i.e. for \"cata\", the preceding\
    \ palindromic substring is at index 2,\n    # and the post-following one is at\
    \ index 0\n    pos_prev, pos_post_following = result.last\n    # position of the\
    \ next post-following palindromic substring\n    # i.e. for \"cata\", we find\
    \ the post-following palindromic substring,\n    # which is the empty string,\
    \ and its position is at index 5\n    pos_next_post_following = pos_post_following\
    \ + 1\n    # position of the next preceding palindromic substring\n    # i.e.\
    \ for \"cata\", we find the preceding palindromic substring,\n    # which is \"\
    c\", and its position is at index 3\n    pos_next_prev = pos_next_post_following\
    \ - pos_prev - 2\n    # the next palindromic substring\n    # i.e. for \"cata\"\
    , it is \"cat\"\n    next_substring = string[pos_next_prev..pos_prev]\n    # a\
    \ new entry of the palindromic substring\n    # i.e. for \"cata\", it is the substring\
    \ \"cat\" and its positions\n    next_entry = [pos_next_prev, pos_next_post_following]\n\
    \    # if the next palindromic substring contains current character,\n    # we\
    \ add the next entry to the result\n    # otherwise, we return the result as is\n\
    \    next_substring.include?(char", '  strlen = string.length', '  return string
    if string.length <= 1', "  string_size = string.size\n  for i in 1..string_size\n\
    \    return string + string[0, string_size - i].reverse if string[i..-1] == string[i..-1].reverse\n\
    \  end\n  raise \"Can't make a palindrome.\"\nend", '  suffix_size = string.size
    - Palindrome.new(string).longest_suffix_size', "  suffix_palindrome = longest_postfix_palindrome(string)\n\
    \  return string if suffix_palindrome == string\n  reversed_prefix = string[0...(string.length\
    \ - suffix_palindrome.length)].reverse\n  string + reversed_prefix\nend", "  string\
    \ + string[0..suffix_prefix_length(string)].reverse\nend", "  (string + string.reverse[string.length..-1]).freeze\n\
    end", "  length = string.length\n  found = false\n  length.downto(0) do |i|\n\
    \    if is_palindrome?(string[i, length - i])\n      found = true\n      break\n\
    \    end\n  end\n  string + string[0, length - i].reverse if found\nend", "  i\
    \ = string.length - 1\n  while i >= 0\n    if is_palindrome?(string[i..-1])\n\
    \      return string + string[0...i].reverse\n    end\n    i -= 1\n  end\n  #\
    \ The string is already a palindrome.\n  string\nend", "  if string.length <=\
    \ 1\n    return string\n  end", "  reversed_prefix = string.chars.reverse.join\n\
    \  string + reversed_prefix[reversed_prefix.length - palindrome_prefix_length(string)..-1]\n\
    end", "  if string.empty?\n    return string\n  end", "  shortest_palindrome =\
    \ string.dup\n  string.length.downto(0) do |postfix_length|\n    if is_palindrome?(string[-postfix_length..-1])\n\
    \      shortest_palindrome << string[0..-(postfix_length + 1)].reverse\n     \
    \ break\n    end\n  end\n  shortest_palindrome\nend", "  long_suffix = ''\n  long_suffix\
    \ = find_palindrome_suffix(string)\n  return string if long_suffix.length > 0\n\
    \  string.reverse + string[0..(string.length - 2)]\nend", '  return string if
    string.length <= 1', "  # Find the longest postfix of supplied string that is\
    \ a palindrome.\n  # If the string is a palindrome - return it.\n  return string\
    \ if is_palindrome?(string)", "  postfix = string.find_longest_postfix_that_is_palindrome\n\
    \  postfix_length = postfix.length\n  reversed_prefix = string[0..-postfix_length\
    \ - 1].reverse\n  string + reversed_prefix\nend", "  return string if string.length\
    \ <= 1\n  return string if string == string.reverse", "  reversed_suffix = find_palindromic_suffix(string).reverse\n\
    \  reversed_suffix + string\nend", "  # Your code here\nend", "  s = string.clone\n\
    \  (s.length - 1).downto(0) do |i|\n    if string[0..i] == string[i..-1].reverse\n\
    \      s.insert(i + 1, string[0..i-1].reverse)\n      return s\n    end\n  end\n\
    \  s.insert(0, string.reverse)\n  s\nend", "  first_palindrome_index = (string.length\
    \ - 1).downto(0).find { |index| is_palindrome?(string[index..-1]) }\n  string\
    \ + string[0..first_palindrome_index-1].reverse\nend", "  return string if palindrome?(string)\n\
    \  longest_palindrome_postfix = compute_longest_palindrome_postfix(string)\n \
    \ string + reverse(string[0..-1-longest_palindrome_postfix.length])\nend", " \
    \ string.empty? ? string : string + reverse(find_postfix(string))\nend", "  string.empty?\
    \ ? string : string + string[0..-1].reverse\nend", "  length = string.length\n\
    \  0.upto(length - 1) do |i|\n    if string[0, length - i] == string[length -\
    \ i, length].reverse\n      return string + string[0, length - i].reverse\n  \
    \  end\n  end\n  # This never happens.\n  string\nend", "  return string if string.length\
    \ <= 1\n  raise TypeError, \"Supplied string is nil\" if string.nil?\n  raise\
    \ TypeError, \"Supplied string is not a string\" unless string.is_a?(String)\n\
    \  while !palindrome?(string)\n    prefix = string[0..-2]\n    string += reverse(prefix)\n\
    \  end\n  string\nend", "  return string if palindrome?(string)\n  suffix = find_suffix(string)\n\
    \  return suffix if suffix.length >= string.length\n  prefix = find_prefix(string,\
    \ suffix)\n  return string if prefix.length == string.length\n  string + reverse(prefix)\n\
    end", "  palindrome_suffix = find_palindrome_suffix(string)\n  palindrome_prefix\
    \ = palindrome_suffix.reverse\n  string + palindrome_prefix\nend", "  string.length.downto(0)\
    \ do |i|\n    return string + string[0..-i-1].reverse if is_palindrome?(string[-i..-1])\n\
    \  end\nend", "  suffix = suffix_palindrome(string)\n  (string[0..-(suffix.length\
    \ + 1)].reverse + string)\nend", "  longest_postfix = find_longest_postfix(string)\n\
    \  prefix = string[0..-longest_postfix.length-1]\n  prefix.reverse + string\n\
    end", "  return string if string.empty?\n  max_len, max_pos = lps(string)\n  prefix\
    \ = string[0...max_pos + 1 - max_len]\n  \"#{prefix}#{prefix.reverse}#{string[max_pos\
    \ + 1..-1]}\"\nend", "  end_at = string.length - 1\n  end_at.downto(0) do |i|\n\
    \    if is_palindrome?(string[i..end_at])\n      prefix = string[0..i - 1]\n \
    \     if prefix.length.zero?\n        return string\n      else\n        return\
    \ string + prefix.reverse\n      end\n    end\n  end\nend", "  if string.size\
    \ < 2\n    return string\n  end", '  input = string.dup', "  reversed_prefix =\
    \ string.reverse\n  # We skip the last char of the string because it is also the\
    \ first char of the string\n  # and we already have it in the reversed_prefix.\n\
    \  suffix = find_longest_palindromic_suffix(string.reverse[1..-1]).reverse\n \
    \ reversed_prefix + suffix\nend", "  return string if palindrome?(string)\n  (string.length\
    \ - suffix_length(string)).times do\n    string = string.chop + string\n  end\n\
    \  string\nend", "  max_length = find_max_palindrome_length(string)\n  string\
    \ + reverse(string[0..-max_length - 1])\nend", "  if string.length == 0\n    return\
    \ string\n  end", "  str_len = string.length\n  str_half_len = str_len / 2\n \
    \ postfix_len = 0\n  (0..str_half_len - 1).each do |i|\n    if string[str_len\
    \ - i - 1] == string[i]\n      postfix_len += 1\n    else\n      break\n    end\n\
    \  end\n  string + string[0, str_len - postfix_len].reverse\nend", '  return string
    if string.length < 2', "  return string if string.size == 0\n  longest_postfix\
    \ = string[1..-1].longest_palindromic_substring\n  prefix = string[0..-(longest_postfix.size\
    \ + 1)]\n  prefix + longest_postfix + prefix.reverse\nend", "  # Find the longest\
    \ postfix of supplied string that is a palindrome.\n  reversed_string = string.reverse\n\
    \  longest_suffix = 0\n  for i in (1..string.length)\n    if reversed_string[-i..-1]\
    \ == string[0..i-1]\n      longest_suffix = i\n    end\n  end\n  # Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n  string + reversed_string[0..-(longest_suffix+1)]\nend", "  longest_postfix\
    \ = longest_palindromic_postfix(string)\n  string_prefix = string[0...-longest_postfix.length]\n\
    \  string + string_prefix.reverse\nend", "  while string.size > 0\n    prefix,\
    \ postfix = string[0..string.size / 2 - 1], string[string.size / 2..-1]\n    break\
    \ if palindrome?(postfix)\n    string = string[0..-2]\n  end\n  string + string[0..string.size\
    \ / 2 - 1].reverse\nend", "  # base case\n  return string if palindrome?(string)",
  "  return string if string.empty?\n  longest_postfix = longest_palindromic_suffix(string)\n\
    \  string + string[0..string.length - longest_postfix.length - 1].reverse\nend",
  "  i = string.length - 1\n  while i >= 0\n    if is_palindrome?(string[i..string.length-1])\n\
    \      return string + string[0..i-1].reverse\n    end\n    i -= 1\n  end\n  string\n\
    end", "  if string.empty?\n    return string\n  end", "  string_length = string.length\n\
    \  reverse_string = string.reverse\n  string_length.times do |i|\n    prefix =\
    \ string[0, i]\n    # String#index returns nil if substring is not found\n   \
    \ if reverse_string.index(prefix)\n      return string + reverse_string[(i+1)..-1]\n\
    \    end\n  end\n  string + reverse_string[1..-1]\nend", "  postfix = find_longest_palindromic_postfix(string)\n\
    \  prefix = string[0..-(postfix.length + 1)]\n  prefix + postfix + prefix.reverse\n\
    end", "  return string if string.empty?\n  longest_palindrome_prefix_idx = longest_palindrome_prefix_idx(string)\n\
    \  return string + string[0...longest_palindrome_prefix_idx].reverse\nend", " \
    \ return string if string.length <= 1\n  return string if palindrome?(string)",
  '  return string if string.length <= 1', '  return string if string.length == 0',
  '  return string if string.size < 2', "  return string if string.length <= 1\n \
    \ # Find the longest palindromic suffix of the supplied string.\n  suffix = find_palindromic_suffix(string)\n\
    \  # Append to the end of the string reverse of a prefix that comes before the\
    \ palindromic suffix.\n  string + reverse(string[0..string.length - suffix.length\
    \ - 1])\nend", "  # Find the longest palindromic suffix\n  palindromic_suffix\
    \ = ''\n  (0..string.length).each do |i|\n    if is_palindrome?(string[i..-1])\n\
    \      palindromic_suffix = string[i..-1]\n      break\n    end\n  end", "  #\
    \ Find the longest postfix that is a palindrome.\n  length = string.length\n \
    \ length.downto(0) do |i|\n    if i > 0 && is_palindrome?(string[-i..-1])\n  \
    \    return string + string[0..-i-1].reverse\n    end\n  end\n  # There are no\
    \ palindromic postfixes.\n  return string + string.reverse\nend", '  return string
    if string.length <= 1', "  reverse = string.reverse\n  start = find_palindrome_prefix(string\
    \ + \"#\" + reverse)\n  reverse[0..start - 1] + string\nend", "  max_postfix_palindrome_len\
    \ = 0\n  string.length.times do |suffix_len|\n    if string[0..(suffix_len-1)]\
    \ == string[suffix_len..-1].reverse\n      max_postfix_palindrome_len = suffix_len\n\
    \    end\n  end\n  return string + string[0..-(max_postfix_palindrome_len+1)].reverse\n\
    end", "  (string.length / 2).downto(0) do |i|\n    if string[i] == string[-i-1]\n\
    \      return string + string[0..-i-2].reverse\n    end\n  end\n  string + string[0..-2].reverse\n\
    end", "  length = string.length\n  prefix_length = longest_palindrome_at_start(string).length\n\
    \  prefix = string[0, length - prefix_length]\n  prefix.reverse + string\nend",
  "  postfix = palindromic_postfix(string)\n  prefix = string[0...(string.length -\
    \ postfix.length)]\n  \"#{prefix}#{postfix.reverse}#{postfix}\"\nend", "  longest_postfix\
    \ = longest_palindromic_suffix(string)\n  str = string.sub(/^(.*)#{longest_postfix}$/,\
    \ '\\1')\n  str << string\nend", "  return \"\" if string.nil? || string.length\
    \ == 0\n  suffix = find_longest_palindromic_suffix(string)\n  prefix = reverse_prefix(string,\
    \ suffix)\n  string + prefix\nend", "  if string.nil?\n    raise Exception.new(\"\
    Supplied string is nil.\")\n  end\n  if string.empty?\n    return string\n  end\n\
    \  if is_palindrome?(string)\n    return string\n  end\n  suffix = find_palindromic_suffix(string)\n\
    \  return string + string[0..-1-suffix.length].reverse\nend", "  string + reverse(cut_palindrome_suffix(string))\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
