name: HumanEval_2_truncate_number
language: rb
prompt: "# Given a positive floating point number, it can be decomposed into\n# and\
  \ integer part (largest integer smaller than given number) and decimals\n# (leftover\
  \ part always smaller than 1).\n# Return the decimal part of the number.\n# >>>\
  \ truncate_number.call(3.5)\n# 0.5\ndef truncate_number(number)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n\
  \    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n\
  \    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n\
  \  end\nend\n"
completions: ["  return 0.0 if number.to_i == number\n  number.abs - number.to_i.abs\n\
    end", "  # MATHEMATICAL SOLUTION\n  # str_number = number.to_s\n  # str_number[str_number.index('.')..-1].to_f",
  "  number.to_i - number\nend", "  return number - number.to_i\nend", "  number.to_i\n\
    end", "  number % 1\nend", "  return 0\nend", "  # TODO: Implement this method.\n\
    end", "  # number.to_i.to_f\n  # number - number.to_i\n  number % 1\nend", " \
    \ (number - number.to_i).round(2)\nend", "  number.divmod(1).last\nend", "  [number.floor,\
    \ number - number.floor]\nend", "  # TODO: implement me\nend", "  return 0 if\
    \ number.nil?\n  return 0 if number == 0", "  # your code here\nend", "  if number\
    \ >= 0\n    number - number.floor\n  else\n    number.abs - number.abs.floor\n\
    \  end\nend", "  number.to_i.to_f\nend", end, "  # ...\nend", "  number.to_i ==\
    \ number ? 0 : number - number.to_i\nend", "  number.floor == number ? 0 : number\
    \ % 1\nend", "  number - number.to_i\nend", "  (number * 10) % 10\nend", "  number\
    \ - number.to_i\nend", "  # TODO: complete this function\nend", "  number.split(\"\
    .\").last.to_f\nend", "  # TODO: Return the decimal part of number, with a precision\
    \ of two digits\n  (number % number.to_i).round(2)\nend", "  (number - number.to_i).round(2)\n\
    end", "  raise ArgumentError.new(\"Number has to be positive\") if number < 0\n\
    \  integer_part = number.to_i\n  number - integer_part\nend", "  sprintf('%.1f',\
    \ number.to_f).split('.').last.to_f\nend", "  raise ArgumentError, \"Number must\
    \ be positive!\" if number < 0\n  return number % 1\nend", "  return number -\
    \ number.to_i\nend", "  (number - number.to_i).round(1)\nend", "  number.truncate\n\
    end", "  number.to_i\nend", "  (number - number.floor).round(2)\nend", "  number\
    \ -= number.to_i\nend", "  number.to_i - number\nend", "  # ...\nend", "  number.to_i\
    \ + (number - number.to_i)\nend", "  # TODO: implement the method\nend", "  number.to_i\
    \ == number ? 0 : number - number.to_i\nend", "  number % 1\nend", "  number -\
    \ number.to_i\nend", "  number - number.to_i\nend", "  return number - number.to_i\n\
    end", "  # your code here\nend", "  number.to_i - number\nend", end, "  return\
    \ number - number.to_i\nend", "  return number - number.to_i\nend", "  (number\
    \ - number.to_i).round(3)\nend", "  # number - number.to_i\n  '%.1f' % number\n\
    end", "  # TODO: return the decimal part\nend", "  return 0 if number.class !=\
    \ Float\n  return number % 1\nend", "  number.to_i + (number - number.to_i)\n\
    end", "  number.to_i\nend", "  # TODO\nend", "  #puts number\n  #puts number.round(2)\n\
    \  #puts number.round(2) - number.to_i\n  #puts (number.round(2) - number.to_i).round(2)\n\
    \  #puts ((number.round(2) - number.to_i) * 10).round\n  #puts (((number.round(2)\
    \ - number.to_i) * 10).round) / 10.0\n  (((number.round(2) - number.to_i) * 10).round)\
    \ / 10.0\nend", "  number - number.to_i\nend", "  # TODO: remove this line and\
    \ return correct value\n  number\nend", "  # Write your code here\nend", "  number\
    \ - number.to_i\nend", "  return number - number.floor\nend", "  # TODO\nend",
  "  return (number % 1).round(2)\nend", "  return 0 if number.zero?\n  return 1 if\
    \ number.to_i == number", "  number.floor\nend", "  number.to_i.to_f == number\
    \ ? 0 : number - number.to_i\nend", "  # TODO\nend", "  (number - number.floor).round(2)\n\
    end", "  (number - number.to_i).round(2)\nend", "  number.to_i\nend", "  # TODO:\
    \ implement me\nend", "  # TODO: Define the implementation of this method.\nend",
  "  number.floor\nend", "  number.to_i\nend", "  return number - number.floor\nend",
  "  # write the code\nend", "  number.to_i\nend", "  return number.to_i\nend", end,
  "  if number.is_a?(Float) || number.is_a?(Integer)\n    number -= number.to_i\n\
    \  else\n    raise ArgumentError, 'Expecting a number, got a String'\n  end\n\
    end", "  return number - number.to_i\nend", "  string = number.to_s\n  split =\
    \ string.split('.')\n  if split.size > 1\n    decimals = split[1]\n    decimal_string\
    \ = '0.' + decimals\n    decimal_string.to_f\n  else\n    0\n  end\nend", "  number.truncate.to_f\n\
    end", "  number -= number.floor\nend", "  number.ceil - number\nend", "  (number\
    \ - number.floor).round(2)\nend", "  # TODO: implement the method\nend", "  number\
    \ - number.to_i\nend", "  number - number.to_i\nend", "  # TODO: fix the code\
    \ so that it works\n  # number.class == Float ? number - (number / 1).to_i : nil\n\
    \  number.modulo(1)\nend", "  # TODO: program me\nend", "  return 0 if number\
    \ == number.to_i\n  number.to_s.split('.')[1].to_f\nend", "  number.to_i\nend",
  "  # TODO: your code here\nend", "  number.to_i\nend", "  number.to_i\nend", " \
    \ number.to_i\nend", "  # ...\nend", "  number.to_i\nend", "  number.to_i - number\n\
    end", "  number % 1\nend", "  return number.modulo(1)\nend", "  # number - number.floor\n\
    \  number.modulo(1)\nend", "  # number.abs.to_i.to_f\n  # number - number.to_i\n\
    \  # number % 1\n  # (number - number.to_i).abs\n  (number - number.to_i).abs.round(2)\n\
    end", "  number - number.to_i\nend", "  # Your solution here\nend", "  # ...\n\
    end", end, "  number.to_i\nend", "  # TODO: change this code\n  number -= number.to_i\n\
    end", "  number.to_i\nend", "  # TODO: implement this method\nend", "  number\
    \ % 1\nend", "  number - number.to_i\nend", "  # Your code goes here.\nend", " \
    \ # your code here\nend", "  number.to_i\nend", "  # return number - number.floor\
    \ \n  # # this is a floored number", "  (number * 10).to_i / 10.0\nend", "  number\
    \ % 1\nend", "  # Use floor method to truncate the number.\n  number - number.floor\n\
    end", "  number.to_i.to_f\nend", "  (number * 10) % 10\nend", "  # TODO: uncomment\
    \ line below, replace nil with good code\n  # number.truncate\nend", "  return\
    \ 0 if number.to_s.match /\\A\\d+\\.0\\z/\n  number.to_s.split('.').last.to_f\n\
    end", "  # TODO: implement me\nend", "  # FIXME\nend", "  return 0.0 if number.to_i\
    \ == number\n  number.to_s.split(\".\").last.to_f / 10.0**number.to_s.split(\"\
    .\").last.size\nend", "  # TODO\nend", "  return number % 1\nend", "  number %\
    \ 1\nend", "  raise_argument_error(number)\n  number.to_s.split('.').last.to_f\n\
    end", "  truncate_number = number.truncate\n  number - truncate_number\nend",
  "  return number.to_i == number ? 0 : number - number.to_i\nend", "  # TODO: implement\n\
    end", "  number.to_i < number ? number - number.to_i : 0\nend", "  # REVIEW:\n\
    \  # `number.to_i` returns the integer part of the number.\n  # `number % 1` returns\
    \ the decimal part.\n  # To learn more about how `%` works, check out the docs:\n\
    \  # https://ruby-doc.org/core-2.3.0/Fixnum.html#method-i-25\n  number % 1\nend",
  "  number.to_i - number\nend", "  number.to_i.to_f == number ? 0 : number - number.to_i\n\
    end", "  number.to_i.to_f\nend", "  number % 1\nend", "  # TODO: implement\nend",
  "  number = number.to_s.split('.')\n  number[1].to_f / 10 ** number[1].length\n\
    end", end, "  # number.to_i is the integer part, fdiv(1) is the remainder,\n \
    \ # that is, the decimal part\n  number.fdiv(1)\nend", "  return 0\nend", "  return\
    \ number - number.to_i\nend", "  number.round(2) - number.floor\nend", "  # fill\
    \ in the code\nend", "  number.to_i\nend", "  return number - number.floor\nend",
  "  number.to_i - number\nend", "  number % 1\nend", "  number.to_i\nend", "  return\
    \ number - number.floor\nend", "  # Your code goes here.\nend", "  number - number.to_i\n\
    end", "  number.to_i - number\nend", "  number.ceil - number\nend", "  number.to_i\n\
    end", "  number.floor - number\nend", "  number.to_i\nend", "  # your code here\n\
    end", "  # number % 1\n  number.modulo(1)\nend", "  decimal_part = number - number.to_i\n\
    \  decimal_part\nend", "  return 0 if number.nil? || number < 0\n  number.to_i\
    \ + (number % 1)\nend", "  # number.floor\n  number.truncate\nend", "  number.modulo(1)\n\
    end", "  number.to_i\nend", "  number - number.to_i\nend", "  number.to_i - number\n\
    end", "  number.to_i.to_f\nend", "  number.modulo(1)\nend", "  number.to_i\nend",
  "  number.to_i.digits.join.to_f\nend", "  return number % 1\nend", "  (number %\
    \ 1)\nend", "  # [1] Do not use a '!' bang, if you use it in a assignment, it\
    \ will return\n  # the assigned value.\n  # a = ['a']\n  # a.concat!(['b'])\n\
    \  # puts a\n  # [2] Array.fill() returns a new array, it does not mutate the\
    \ original array.\n  number.floor\nend", "  number -= number.to_i\nend", "  #\
    \ TODO: implemente me!\nend", "  # number.to_i\n  # number.to_i * (10 ** number.size)\n\
    \  number.to_i.to_f - number\nend", "  number - number.to_i\nend", "  number.to_i\
    \ % 1\nend", "  return number - number.floor\nend", "  # TODO: implement me\n\
    end", "  number % 1\nend", "  number.to_i - number\nend", "  # your code here\n\
    end", "  (number % 1)\nend", "  raise\nend", "  number.modulo(1)\nend", "  return\
    \ number.to_i\nend", "  return (number % 1).round(2)\nend", "  # TODO\nend", " \
    \ number -= number.floor\nend", "  number.round(4) - number.to_i\nend", "  integer_part\
    \ = number.to_i\n  integer_part == number ? 0 : number - integer_part\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
