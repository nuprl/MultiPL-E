name: HumanEval_156_int_to_mini_roman
language: rb
prompt: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n#\
  \ >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n\
  # \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
  \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
  \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
  \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
  \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
  \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
  \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
  \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
  \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
completions: ["  roman = \"\"\n  roman = roman + \"m\" * (number / 1000)\n  roman\
    \ = roman + \"c\" * ((number % 1000) / 100)\n  roman = roman + \"x\" * ((number\
    \ % 100) / 10)\n  roman = roman + \"i\" * (number % 10)\n  return roman\nend",
  "  raise ArgumentError.new(\"Invalid number\") if number > 1000 || number < 1\n\
    \  roman_numeral = []\n  ROMAN_NUMERALS.each do |numeral, num_value|\n    while\
    \ number >= num_value\n      roman_numeral << numeral\n      number -= num_value\n\
    \    end\n  end\n  roman_numeral.join.downcase\nend", "  str = \"\"\n  rom_hsh\
    \ = {1 => \"i\", 5 => \"v\", 10 => \"x\", 50 => \"l\", 100 => \"c\", 500 => \"\
    d\", 1000 => \"m\"}\n  digits = number.to_s.split(\"\").reverse.map!{|s| s.to_i}\n\
    \  digits.each_with_index do |digit, i|\n    factor = 10**i\n    if digit >= 1\
    \ && digit <= 3\n      str.prepend(rom_hsh[factor] * digit)\n    elsif digit ==\
    \ 4\n      str.prepend(rom_hsh[factor] + rom_hsh[factor * 5])\n    elsif digit\
    \ == 5\n      str.prepend(rom_hsh[factor * 5])\n    elsif digit >= 6 && digit\
    \ <= 8\n      str.prepend(rom_hsh[factor * 5] + rom_hsh[factor] * (digit - 5))\n\
    \    elsif digit == 9\n      str.prepend(rom_hsh[factor] + rom_hsh[factor * 10])\n\
    \    end\n  end\n  str\nend", "  number_str = number.to_s\n  digits = number_str.split('')\n\
    \  upper_limit = 3\n  if number >= 1000\n    upper_limit = 4\n  end\n  result\
    \ = ''\n  upper_limit.times do |digit|\n    result << roman_numeral_of_digit(digit,\
    \ digits)\n  end\n  result\nend", "  number = number.to_i\n  rom_num = ''\n  rom_num\
    \ = rom_num + 'm' * (number/1000)\n  rom_num = rom_num + 'd' * (number%1000/500)\n\
    \  rom_num = rom_num + 'c' * (number%500/100)\n  rom_num = rom_num + 'l' * (number%100/50)\n\
    \  rom_num = rom_num + 'x' * (number%50/10)\n  rom_num = rom_num + 'v' * (number%10/5)\n\
    \  rom_num = rom_num + 'i' * (number%5/1)\n  rom_num\nend", "  raise ArgumentError.new(\"\
    Argument must be a positive integer\") unless number.is_a?(Integer) && number\
    \ > 0\n  raise ArgumentError.new(\"Argument must be in range 1 <= num <= 1000\"\
    ) unless number >= 1 && number <= 1000", "  # Your code here\nend", "  roman =\
    \ \"\"\n  symbol = {\n            \"M\" => 1000,\n            \"D\" => 500,\n\
    \            \"C\" => 100,\n            \"L\" => 50,\n            \"X\" => 10,\n\
    \            \"V\" => 5,\n            \"I\" => 1\n            }\n    symbol.each\
    \ do |key, value|\n      roman += key * (number / value)\n      number = number\
    \ % value\n    end\n    return roman.downcase\nend", "  roman = []\n  roman_lookup\
    \ = {\n    1 => \"i\",\n    5 => \"v\",\n    10 => \"x\",\n    50 => \"l\",\n\
    \    100 => \"c\",\n    500 => \"d\",\n    1000 => \"m\"\n  }\n  decimal_values\
    \ = roman_lookup.keys.reverse\n  decimal_values.each do |decimal|\n    quotient,\
    \ number = number.divmod(decimal)\n    roman << roman_lookup[decimal] * quotient\n\
    \  end\n  return roman.join\nend", "  if number < 1 || number > 1000\n    raise\
    \ \"Number out of range\"\n  end\n  thousands = number / 1000\n  hundreds = (number\
    \ % 1000) / 100\n  tens = (number % 100) / 10\n  units = number % 10\n  result\
    \ = \"m\" * thousands\n  result += \"c\" * hundreds\n  result += \"x\" * tens\n\
    \  result += \"i\" * units\n  result\nend", "  symbols = {1 => 'i', 4 => 'iv',\
    \ 5 => 'v', 9 => 'ix', 10 => 'x', 40 => 'xl', 50 => 'l', 90 => 'xc', 100 => 'c',\
    \ 400 => 'cd', 500 => 'd', 900 => 'cm', 1000 => 'm'}\n  result = ''\n  while number\
    \ > 0\n    symbols.keys.reverse.each do |key|\n      if number >= key\n      \
    \  result << symbols[key]\n        number -= key\n        break\n      end\n \
    \   end\n  end\n  result\nend", "  # your code here\nend", "  raise NotImplementedError\n\
    end", "  i = 0\n  romans = {1000 => \"m\", 900 => \"cm\", 500 => \"d\", 400 =>\
    \ \"cd\", 100 => \"c\", 90 => \"xc\", 50 => \"l\", 40 => \"xl\", 10 => \"x\",\
    \ 9 => \"ix\", 5 => \"v\", 4 => \"iv\", 1 => \"i\"}\n  mini_roman = \"\"\n  while\
    \ number > 0\n    if number >= romans.keys[i]\n      mini_roman += romans.values[i]\n\
    \      number -= romans.keys[i]\n    else\n      i += 1\n    end\n  end\n  mini_roman\n\
    end", "  roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n  integers = [1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  result = \"\"\n  index = 0\n  while\
    \ number > 0\n    while number >= integers[index]\n      result << roman_numerals[index]\n\
    \      number -= integers[index]\n    end\n    index += 1\n  end\n  result\nend",
  "  # TODO: implement this method\nend", "    # convert number to string to get number\
    \ length\n    #   and grab each digit with index\n    num_string = number.to_s\n\
    \    num_length = num_string.length\n    # set up array to store roman numerals\n\
    \    roman_numeral = []\n    # set up array to store mini-roman symbols\n    symbols\
    \ = %w(i v x l c d m)\n    # set up hash to lookup symbol based on placement in\
    \ number\n    placement = { 1 => 0, 10 => 2, 100 => 4, 1000 => 6 }\n    # for\
    \ each digit in number, lookup symbol and placement\n    #   and build roman numeral\
    \ array\n    num_string.split('').each_with_index do |digit, index|\n        #\
    \ turn digit string into integer\n        digit = digit.to_i\n        # determine\
    \ symbol to use based on placement\n        symbol = symbols[placement[(10 **\
    \ (num_length - index - 1))]]\n        # determine mini-roman numeral\n      \
    \  numeral = mini_roman_numeral(digit, symbol)\n        # add numeral to roman\
    \ numeral array\n        roman_numeral << numeral\n    end\n    # convert roman\
    \ numeral array to string\n    #   and downcase\n    return roman_numeral.join('').downcase\n\
    end", "  roman_str = ''\n  int_to_mini_roman_map.each do |arabic, roman|\n   \
    \ while number >= arabic\n      roman_str << roman\n      number -= arabic\n \
    \   end\n  end\n  roman_str\nend", "  # Your code here\nend", "\tnum_hash = {\n\
    \t\t1 => \"i\",\n\t\t2 => \"ii\",\n\t\t3 => \"iii\",\n\t\t4 => \"iv\",\n\t\t5\
    \ => \"v\",\n\t\t6 => \"vi\",\n\t\t7 => \"vii\",\n\t\t8 => \"viii\",\n\t\t9 =>\
    \ \"ix\",\n\t\t10 => \"x\",\n\t\t20 => \"xx\",\n\t\t30 => \"xxx\",\n\t\t40 =>\
    \ \"xl\",\n\t\t50 => \"l\",\n\t\t60 => \"lx\",\n\t\t70 => \"lxx\",\n\t\t80 =>\
    \ \"lxxx\",\n\t\t90 => \"xc\",\n\t\t100 => \"c\",\n\t\t200 => \"cc\",\n\t\t300\
    \ => \"ccc\",\n\t\t400 => \"cd\",\n\t\t500 => \"d\",\n\t\t600 => \"dc\",\n\t\t\
    700 => \"dcc\",\n\t\t800 => \"dccc\",\n\t\t900 => \"cm\",\n\t\t1000 => \"m\"\n\
    \t}\n\tnum_arr = number.to_s.chars.reverse\n\troman_num = \"\"\n\tnum_arr.each_with_index\
    \ do |num, i|\n\t\tnum = num.to_i\n\t\troman_num.prepend(num_hash[num * (10 **\
    \ i)]) if num != 0\n\tend\n\troman_num\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
