name: HumanEval_160_do_algebra
language: rb
prompt: "# Given two arrays operator, and operand. The first array has basic algebra\
  \ operations, and \n# the second array is an array of integers. Use the two given\
  \ arrays to build the algebric \n# expression and return the evaluation of this\
  \ expression.\n# The basic algebra operations:\n# Addition ( + ) \n# Subtraction\
  \ ( - ) \n# Multiplication ( * ) \n# Floor division ( // ) \n# Exponentiation (\
  \ ** ) \n# Example:\n# operator['+', '*', '-']\n# array = [2, 3, 4, 5]\n# result\
  \ = 2 + 3 * 4 - 5\n# => result = 9\n# Note:\n# The length of operator array is equal\
  \ to the length of operand array minus one.\n# Operand is an array of of non-negative\
  \ integers.\n# Operator array has at least one operator, and operand array has at\
  \ least two operands.\ndef do_algebra(operator, operand)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n\
  \    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\"\
  , \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\"\
  , \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"//\", \"*\"], [7,\
  \ 3, 4]))\n  end\nend\n"
completions: ["  # @TODO: Your code here\nend", "  result = operand[0]\n  i = 0\n\
    \  while i < operator.length\n    if operator[i] == '+'\n      result += operand[i+1]\n\
    \    elsif operator[i] == '-'\n      result -= operand[i+1]\n    elsif operator[i]\
    \ == '*'\n      result *= operand[i+1]\n    elsif operator[i] == '//'\n      result\
    \ /= operand[i+1]\n    elsif operator[i] == '**'\n      result **= operand[i+1]\n\
    \    end\n    i += 1\n  end\n  result\nend\nputs do_algebra(['+', '*', '-'], [2,\
    \ 3, 4, 5])\nputs do_algebra(['+', '*', '//'], [1, 2, 3, 4])", "  # your code\
    \ here\nend", "    result = operand[0]\n    i = 0\n    while i < operator.length\n\
    \        result = result.send(operator[i], operand[i+1])\n        i += 1\n   \
    \ end\n    result\nend", "\tif operand.length == 2\n\t\tif operator == \"+\"\n\
    \t\t\treturn operand[0] + operand[1]\n\t\telsif operator == \"-\"\n\t\t\treturn\
    \ operand[0] - operand[1]\n\t\telsif operator == \"*\"\n\t\t\treturn operand[0]\
    \ * operand[1]\n\t\telsif operator == \"//\"\n\t\t\treturn operand[0] / operand[1]\n\
    \t\telsif operator == \"**\"\n\t\t\treturn operand[0] ** operand[1]\n\t\tend\n\
    \telse\n\t\tif operator[0] == \"*\" || operator[0] == \"//\" || operator[0] ==\
    \ \"**\"\n\t\t\treturn do_algebra(operator[0], [do_algebra(operator[1], operand[0..1]),\
    \ operand[2]])\n\t\telse\n\t\t\treturn do_algebra(operator[0], [operand[0], do_algebra(operator[1],\
    \ operand[1..2])])\n\t\tend\n\tend\nend", "    result = operand[0]\n    operand[1..-1].each_with_index\
    \ do |value, idx|\n        result = \n            case operator[idx]\n       \
    \     when '+' then result + value\n            when '-' then result - value\n\
    \            when '*' then result * value\n            when '//' then result /\
    \ value\n            when '**' then result ** value\n            end\n    end\n\
    \    result\nend", "    operator.each_with_index.reduce(operand[0]) do |result,\
    \ (op, i)|\n        result.send(op, operand[i + 1])\n    end\nend", "  answer\
    \ = operand[0]\n  operand.shift\n  operand.each_with_index do |num, idx|\n   \
    \ if operator[idx] == \"+\"\n      answer += num\n    elsif operator[idx] == \"\
    -\"\n      answer -= num\n    elsif operator[idx] == \"*\"\n      answer *= num\n\
    \    elsif operator[idx] == \"//\"\n      answer /= num\n    elsif operator[idx]\
    \ == \"**\"\n      answer **= num\n    end\n  end\n  answer\nend", "  expression\
    \ = \"\"\n  operand.each_with_index do |x, i|\n    expression += \"#{x} #{operator[i]}\"\
    \n  end\n  expression.gsub!(\"//\", \"/\")\n  expression += operand.last.to_s\n\
    \  expression.to_i\nend", "  operator.zip(operand.each_cons(2)).reduce(operand.first)\
    \ do |result, (op, args)|\n    result.send(op, *args)\n  end\nend", "  result\
    \ = operand[0]\n  i = 0\n  while i < operator.length\n    case operator[i]\n \
    \   when '+'\n      result += operand[i + 1]\n    when '-'\n      result -= operand[i\
    \ + 1]\n    when '*'\n      result *= operand[i + 1]\n    when '//'\n      result\
    \ /= operand[i + 1]\n    when '**'\n      result **= operand[i + 1]\n    end\n\
    \    i += 1\n  end\n  result\nend", "  result = 0\n  operator.each_with_index\
    \ do |op, i|\n    case op\n    when '+'\n      result += operand[i] + operand[i+1]\n\
    \    when '-'\n      result += operand[i] - operand[i+1]\n    when '*'\n     \
    \ result += operand[i] * operand[i+1]\n    when '//'\n      result += operand[i]\
    \ / operand[i+1]\n    when '**'\n      result += operand[i] ** operand[i+1]\n\
    \    end\n  end\n  result\nend", "  if operator.length != operand.length - 1\n\
    \    return \"operator and operand is not the same length\"\n  end\n  result =\
    \ 0\n  i = 0\n  while i < operator.length\n    if operator[i] == '+'\n      result\
    \ += operand[i] + operand[i+1]\n    elsif operator[i] == '-'\n      result +=\
    \ operand[i] - operand[i+1]\n    elsif operator[i] == '*'\n      result += operand[i]\
    \ * operand[i+1]\n    elsif operator[i] == '//'\n      result += operand[i] /\
    \ operand[i+1]\n    elsif operator[i] == '**'\n      result += operand[i] ** operand[i+1]\n\
    \    end\n    i += 1\n  end\n  return result\nend", "  operand = operand.map(&:to_i)\n\
    \  result = operand[0]\n  i = 0\n  operator.each do |op|\n    case op\n    when\
    \ '+'\n      result += operand[i+1]\n    when '-'\n      result -= operand[i+1]\n\
    \    when '*'\n      result *= operand[i+1]\n    when '//'\n      result /= operand[i+1]\n\
    \    when '**'\n      result **= operand[i+1]\n    end\n    i += 1\n  end\n  result\n\
    end", "  x = operand.shift\n  operand.each do |y|\n    x = x.send(operator.shift,\
    \ y)\n  end\n  x\nend\noperator = ['+', '*', '-']\narray = [2, 3, 4, 5]\nputs\
    \ do_algebra(operator, array)", "  result = operand[0]\n  (1...operand.length).each\
    \ { |i| result = result.send(operator[i-1], operand[i]) }\n  result\nend", " \
    \ a = operator.map.with_index { |e,i| e + operand[i+1].to_s }.join(operand[0].to_s)\n\
    \  eval(a)\nend", "    operation = operator[0] + operand[0].to_s + operand[1].to_s\n\
    \    1.upto(operator.length - 1) do |i|\n        operation = operation + operator[i]\
    \ + operand[i + 1].to_s\n    end\n    eval(operation)\nend", "  #your code here\n\
    end", "  new_array = []\n  operand.each_with_index do |ele, i|\n    if i == 0\n\
    \      new_array << ele\n    else\n      new_array << operator[i-1]\n      new_array\
    \ << ele\n    end\n  end\n  new_array.join.to_i\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
