name: HumanEval_47_median
language: rb
prompt: "# Return median of elements in the array l.\n# >>> median.call([3, 1, 2,\
  \ 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n\
  \    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4,\
  \ 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5,\
  \ candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7,\
  \ candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"
completions: ["  l.sort!\n  length = l.length\n  if length % 2 == 0\n    return (l[length/2\
    \ - 1] + l[length/2]) / 2.0\n  else\n    return l[length/2]\n  end\nend", "  \
    \  return l.sort![l.length/2]\nend", "  len = l.length\n  return l[len/2] if len\
    \ % 2 == 1\n  return (l[len/2] + l[len/2 - 1])/2.0\nend", "\t# Your code here\n\
    \tl.sort!\n\tif (l.length.even?)\n\t\treturn ((l[l.length/2-1] + l[l.length/2])\
    \ / 2.0)\n\telse\n\t\treturn l[l.length/2]\n\tend\nend", "  if l.length % 2 ==\
    \ 0\n    (l[l.length / 2] + l[l.length / 2 - 1]) / 2.0\n  else\n    l[l.length\
    \ / 2]\n  end\nend", "\tl.sort!\n\tmid = l.length / 2\n\tif l.length % 2 == 0\n\
    \t\treturn (l[mid] + l[mid - 1]) / 2.0\n\telse\n\t\treturn l[mid]\n\tend\nend",
  "  # YOUR CODE HERE\nend", "  # For testing\n  # puts \"l is #{l}\"\n  sorted_list\
    \ = l.sort\n  # For testing\n  # puts \"sorted_list is #{sorted_list}\"\n  length\
    \ = sorted_list.length\n  # For testing\n  # puts \"length is #{length}\"\n  if\
    \ length.odd?\n    median = sorted_list[length/2]\n  else\n    # for testing\n\
    \    # puts \"length/2 is #{length/2}\"\n    # puts \"length/2-1 is #{length/2-1}\"\
    \n    # puts \"sorted_list[length/2] is #{sorted_list[length/2]}\"\n    # puts\
    \ \"sorted_list[length/2-1] is #{sorted_list[length/2-1]}\"\n    median = (sorted_list[length/2].to_f\
    \ + sorted_list[length/2-1].to_f)/2\n  end\n  return median\nend", "  l.sort!\n\
    \  len = l.length\n  if len % 2 == 0\n    (l[len/2-1] + l[len/2]) / 2.0\n  else\n\
    \    l[len/2]\n  end\nend", end, "    l.sort!\n    if l.length % 2 == 0\n    \
    \    return (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n    else\n        return\
    \ l[l.length/2]\n    end\nend", '  sorted = l.sort', "  # TODO: implement me!\n\
    end", "  array = l.sort\n  length = array.length\n  # odd case\n  if length %\
    \ 2 == 1\n    return array[length / 2]\n  # even case\n  else\n    return (array[length\
    \ / 2 - 1] + array[length / 2]) / 2.0\n  end\nend", "  arr = l.sort\n  count =\
    \ l.count\n  if count.odd?\n    return arr[count/2]\n  else\n    return (arr[count/2]\
    \ + arr[count/2 - 1]) / 2.0\n  end\nend", "  # TODO\nend", "    l = l.sort\n \
    \   if l.length % 2 == 0\n        return (l[l.length/2] + l[l.length/2 - 1]) /\
    \ 2.0\n    else\n        return l[l.length/2]\n    end\nend", "  l = l.sort\n\
    \  if l.length % 2 == 0\n    return (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n\
    \  else\n    return l[l.length/2]\n  end\nend", "  l = l.sort\n  if l.length.odd?\n\
    \    l[l.length/2]\n  else\n    half = l.length/2\n    (l[half] + l[half-1])/2.0\n\
    \  end\nend", "  m = l.sort[l.length/2]\n  return m\nend", "  sorted = l.sort\n\
    \  mid = (sorted.length - 1) / 2.0\n  if sorted.length.odd?\n    sorted[mid]\n\
    \  else\n    (sorted[mid] + sorted[mid+1]) / 2.0\n  end\nend", "  l.sort!\n  if\
    \ l.length % 2 == 0\n    (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n  else\n \
    \   l[l.length/2]\n  end\nend", "  sorted = l.sort\n  mid = (sorted.length - 1)\
    \ / 2.0\n  if sorted.length.odd?\n    sorted[mid]\n  else\n    (sorted[mid] +\
    \ sorted[mid+1]) / 2.0\n  end\nend", "\tl.sort\n\treturn l[l.length/2] if l.length\
    \ % 2 == 1\n\treturn (l[l.length/2 - 1] + l[l.length/2]) / 2.0\nend", "  sorted\
    \ = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2])\
    \ / 2.0\nend\nputs median([3, 1, 2, 4, 5])\nputs median([-10, 4, 6, 1000, 10,\
    \ 20])", "  l.sort!\n  return l[l.length/2] if l.length % 2 == 1\n  return (l[l.length/2\
    \ - 1] + l[l.length/2]) / 2.0\nend", "  n = l.size\n  return nil if n.zero?\n\
    \  return l[0] if n == 1\n  l.sort!\n  if n.odd?\n    l[n / 2]\n  else\n    l[n\
    \ / 2 - 1] + l[n / 2] / 2.0\n  end\nend", "  sorted = l.sort\n  len = sorted.length\n\
    \  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  sorted = l.sort\n\
    \  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend",
  "  len = l.length\n  if len % 2 == 0\n    (l[len/2-1] + l[len/2]) / 2.0\n  else\n\
    \    l[len/2]\n  end\nend", "  l.sort!\n  if l.length.odd?\n    return l[l.length/2]\n\
    \  else\n    return (l[l.length/2] + l[l.length/2 - 1])/2.0\n  end\nend", "  sorted\
    \ = l.sort\n  mid = (sorted.length - 1) / 2.0\n  if sorted.length.odd?\n    sorted[mid]\n\
    \  else\n    (sorted[mid] + sorted[mid + 1]) / 2.0\n  end\nend", "  l.sort!\n\
    \  if l.length.odd?\n    return l[l.length/2]\n  else\n    return (l[l.length/2]\
    \ + l[l.length/2 - 1])/2.0\n  end\nend", "  l.sort!\n  median_pos = l.length /\
    \ 2\n  if (l.length%2 == 0)\n    return (l[median_pos-1] + l[median_pos]) / 2.0\n\
    \  else\n    return l[median_pos]\n  end\nend", "\tl.sort!\n\tif l.length % 2\
    \ == 0\n\t\t(l[l.length/2 - 1] + l[l.length/2]) / 2.0\n\telse\n\t\tl[l.length/2]\n\
    \tend\nend", "  if l.length.odd?\n    l.sort[l.length/2]\n  else\n    even = l.sort[l.length/2..l.length/2+1]\n\
    \    (even[0] + even[1])/2.0\n  end\nend", "  m = l.sort!\n  return m[m.length/2]\
    \ if m.length.odd?\n  (m[m.length/2] + m[m.length/2 - 1]) / 2.0\nend", "    if\
    \ l.length % 2 == 0\n        return (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n\
    \    else\n        return l[l.length/2]\n    end\nend", "  l.sort!\n  return ((l[l.length/2\
    \ - 1] + l[l.length/2]) / 2.0) if l.length.even?\n  return l[l.length/2]\nend",
  "  # Write your function here\nend", "\tl.sort!\n\tif l.length % 2 == 0\n\t\treturn\
    \ (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n\telse\n\t\treturn l[l.length/2]\n\
    \tend\nend", "  # TODO\nend", "  len = l.length\n  sorted = l.sort\n  (sorted[(len\
    \ - 1) / 2] + sorted[len / 2]) / 2.0\nend", "\tif(l.length % 2 == 0)\n\t\t(l[l.length/2-1]\
    \ + l[l.length/2])/2.0\n\telse\n\t\tl[l.length/2]\n\tend\nend", "  l.sort!\n \
    \ if l.length % 2 == 0\n    l[l.length/2-1..l.length/2].inject{|sum, x| sum +\
    \ x}.to_f / 2\n  else\n    l[l.length/2]\n  end\nend", "  # first part to do\n\
    \  puts \"Error\"\nend", "  return nil if l.empty?\n  # Sort the array\n  sorted\
    \ = l.sort\n  if sorted.length % 2 == 0\n    # Return the average of the two values\
    \ in the middle\n    (sorted[sorted.length / 2] + sorted[sorted.length / 2 - 1])\
    \ / 2.0\n  else\n    # Return the middle value\n    sorted[sorted.length / 2]\n\
    \  end\nend", "\treturn (l.sort[(l.length-1)/2] + l.sort[l.length/2])/2.0\nend",
  "  if l.length % 2 == 0\n    sum = l[l.length / 2] + l[l.length / 2 - 1]\n    return\
    \ sum / 2.0\n  else\n    return l[l.length / 2]\n  end\nend", end, "  l.sort!\n\
    \  sz = l.size\n  if sz % 2 == 0\n    (l[sz/2] + l[sz/2 - 1]) / 2.0\n  else\n\
    \    l[sz/2]\n  end\nend", "  return nil if l.empty?\n  len = l.length\n  return\
    \ (l[(len-1)/2] + l[len/2]) / 2.0 if len.odd?\n  l[len/2]\nend", "  l.length %\
    \ 2 == 0 ? (l[l.length / 2 - 1] + l[l.length / 2]) / 2.0 : l[l.length / 2]\nend",
  "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "    sorted = l.sort\n    len = sorted.length\n    (sorted[(len\
    \ - 1) / 2] + sorted[len / 2]) / 2.0\nend", end, "\tl.sort!\n\tif l.length % 2\
    \ == 0\n\t\treturn (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n\telse\n\t\treturn\
    \ l[l.length/2]\n\tend\nend", "  ll = []\n  if l.length == 0\n    nil\n  else\n\
    \    ll = l.sort\n    med = ll.length/2\n    if ll.length % 2 == 0\n      (ll[med-1]\
    \ + ll[med])/2.0\n    else\n      ll[med]\n    end\n  end\nend", "  sorted = l.sort\n\
    \  len = sorted.length\n  if len.even?\n    left = len / 2 - 1\n    right = len\
    \ / 2\n    (sorted[left] + sorted[right]) / 2.0\n  else\n    sorted[len / 2]\n\
    \  end\nend", "  l.sort!\n  length = l.length\n  if length.even?\n    return (l[length/2\
    \ - 1] + l[length/2]) / 2.0\n  else\n    return l[length/2]\n  end\nend", "  l.sort!\n\
    \  if l.length % 2 == 0\n    (l[l.length/2-1] + l[l.length/2]) / 2.0\n  else\n\
    \    l[l.length/2]\n  end\nend", "  l.sort!\n  mid = l.length / 2\n  l.length.odd?\
    \ ? l[mid] : (l[mid - 1] + l[mid]).to_f / 2\nend", "    # median.rb\n    return\
    \ nil if l.empty?\n    sorted = l.sort\n    middle = l.length / 2\n    return\
    \ l.length % 2 == 0 ? (sorted[middle] + sorted[middle - 1]) / 2.0 : sorted[middle]\n\
    end", "  # YOUR CODE HERE\nend", "  sorted = l.sort\n  len = sorted.length\n \
    \ if len.odd?\n    return sorted[len/2]\n  else\n    return (sorted[len/2] + sorted[len/2\
    \ - 1]) / 2.0\n  end\nend", "  l.sort!\n  if l.length.odd?\n    return l[l.length/2]\n\
    \  else\n    return (l[l.length/2] + l[l.length/2 - 1])/2.0\n  end\nend", "  #\
    \ compute median here\n  array = l.sort\n  len = array.length\n  if len % 2 ==\
    \ 0\n    (array[len/2 - 1] + array[len/2]) / 2.0\n  else\n    array[len/2]\n \
    \ end\nend", "  l.sort!\n  if l.length % 2 == 0\n    l[l.length/2] + l[l.length/2\
    \ - 1] / 2.0\n  else\n    l[l.length/2].to_f\n  end\nend", "  sorted = l.sort\n\
    \  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend",
  "    l.sort!\n    len = l.length\n    if len % 2 == 0\n        return (l[len/2]\
    \ + l[len/2 - 1]) / 2.0\n    else\n        return l[len/2]\n    end\nend", "\t\
    l = l.sort\n\tmedian = nil\n\tif l.length % 2 == 0\n\t\tmedian = (l[l.length/2]\
    \ + l[l.length/2 - 1]) / 2.0\n\telse\n\t\tmedian = l[l.length/2]\n\tend\n\treturn\
    \ median\nend", "  n = l.size\n  sorted = l.sort\n  (sorted[(n - 1) / 2] + sorted[n\
    \ / 2]) / 2.0\nend", "  return 0 if l.length == 0\n  l.sort!\n  if l.length %\
    \ 2 == 0\n    (l[l.length / 2 - 1] + l[l.length / 2]) / 2.0\n  else\n    l[l.length\
    \ / 2]\n  end\nend", "  mid = l.length / 2\n  l.sort!\n  if l.length % 2 == 0\n\
    \    (l[mid - 1] + l[mid]) / 2.0\n  else\n    l[mid]\n  end\nend", "  m = l.sort\n\
    \  return (m[(m.length / 2) - 1] + m[m.length / 2]) / 2.0 if m.length.even?\n\
    \  m[m.length / 2]\nend", "  return 0.0 if l.length == 0\n  # sort the array\n\
    \  l = l.sort\n  # return the median\n  # if the count is even, get the avg of\
    \ the two middle numbers\n  if l.length % 2 == 0\n    return (l[l.length / 2]\
    \ + l[l.length / 2 - 1]) / 2.0\n  else\n    return l[l.length / 2]\n  end\nend",
  "  sorted = l.sort\n  len = sorted.length\n  return (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "    sorted = l.sort\n    len = sorted.length\n    return\
    \ (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  l.sort!\n  length\
    \ = l.length\n  return nil if length.zero?\n  if length.odd?\n    l[length / 2]\n\
    \  else\n    (l[length / 2 - 1] + l[length / 2]) / 2.0\n  end\nend", "  l.sort!\n\
    \  if l.length.odd?\n    return l[l.length/2]\n  else\n    return (l[l.length/2\
    \ - 1] + l[l.length/2])/2.0\n  end\nend", "  sorted = l.sort\n  if sorted.length\
    \ % 2 == 0\n    (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) /\
    \ 2.0\n  else\n    sorted[sorted.length / 2]\n  end\nend", "  # Your code here\n\
    \  l = l.sort\n  if l.length % 2 == 0\n    (l[l.length/2-1] + l[l.length/2])/2.0\n\
    \  else\n    l[l.length/2]\n  end\nend", "\treturn 0 if l.empty?\n\treturn l[0]\
    \ if l.length == 1\n\tl.sort!\n\tif l.length.odd?\n\t\tl[l.length/2]\n\telse\n\
    \t\t(l[l.length/2-1] + l[l.length/2])/2.0\n\tend\nend", "  raise \"median called\
    \ with invalid array\" if l.nil?\n  sorted = l.sort\n  if sorted.length % 2 ==\
    \ 0\n    (sorted[sorted.length / 2] + sorted[sorted.length / 2 - 1]) / 2.0\n \
    \ else\n    sorted[sorted.length / 2]\n  end\nend", "  if l.length % 2 == 0\n\
    \    (l[l.length / 2] + l[l.length / 2 - 1]) / 2.0\n  else\n    l[l.length / 2]\n\
    \  end\nend", "  m = l.sort\n  n = m.length\n  if n % 2 == 0\n    (m[n/2] + m[n/2\
    \ - 1]) / 2.0\n  else\n    m[n/2]\n  end\nend", "  len = l.length\n  if len.odd?\n\
    \    return l.sort[len/2]\n  else\n    return (l.sort[len/2 - 1] + l.sort[len/2])\
    \ / 2.0\n  end\nend", "  if l.length % 2 == 0\n    return ((l[l.length/2-1] +\
    \ l[l.length/2]) / 2.0)\n  else\n    return l[l.length/2]\n  end\nend", "  sorted\
    \ = l.sort\n  len = sorted.length\n  return (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  return l.sort[l.length/2]\nend", "  l.sort!\n  if l.length.odd?\n\
    \    l[l.length/2]\n  else\n    (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n  end\n\
    end", "    l = l.sort\n    if l.length % 2 == 0\n        return (l[l.length/2\
    \ - 1] + l[l.length/2]) / 2.0\n    else\n        return l[l.length/2]\n    end\n\
    end", "  l.sort!\n  median = 0.0\n  if l.length % 2 == 0\n    n = l.length / 2\n\
    \    median = (l[n - 1] + l[n]) / 2.0\n  else\n    n = l.length / 2\n    median\
    \ = l[n]\n  end\n  median\nend", "  l.sort!\n  if l.length % 2 == 0\n    return\
    \ (l[l.length/2-1] + l[l.length/2])/2.0\n  else\n    return l[l.length/2]\n  end\n\
    end", "\tl.sort!\n\tif l.length % 2 == 0\n\t\treturn (l[l.length/2] + l[l.length/2\
    \ - 1]) / 2.0\n\telse\n\t\treturn l[l.length/2]\n\tend\nend", "\todd = 1\n\tl.sort!\n\
    \treturn l[l.length/2].to_f if l.length.odd?\n\tif odd == -1\n\t\treturn (l[l.length/2-1].to_f\
    \ + l[l.length/2].to_f)/2\n\tend\nend", "  (l.sort[l.length/2 - 1] + l.sort[l.length/2])\
    \ / 2.0\nend", "  return nil if l.empty?\n  return l[0] if l.length == 1\n  return\
    \ (l[l.length/2 - 1] + l[l.length/2]) / 2.0 if l.length.even?\n  l[l.length/2]\n\
    end", "  l.sort!\n  len = l.length\n  return (l[(len - 1) / 2] + l[len / 2]) /\
    \ 2.0\nend", "  # First we sort the array, then we find the middle index of the\
    \ array.\n  # If the length of the array is even, we return the average of the\
    \ two values\n  # in the middle. Otherwise, we return the value at the middle\
    \ index.\n  sorted = l.sort\n  mid = sorted.length / 2\n  return (sorted[mid -\
    \ 1] + sorted[mid]) / 2.0 if sorted.length.even?\n  sorted[mid]\nend", "\treturn\
    \ nil if l.nil?\n\treturn l[0] if l.length == 1\n\t\n\tl.sort!\n\tif l.length.odd?\n\
    \t\treturn l[l.length/2]\n\telse\n\t\treturn (l[l.length/2 - 1] + l[l.length/2])/2.0\n\
    \tend\nend", "  l = l.sort\n  len = l.length\n  if len.even?\n    (l[len/2 - 1]\
    \ + l[len/2]) / 2.0\n  else\n    l[len/2]\n  end\nend", "  l = l.sort\n  len =\
    \ l.length\n  if len % 2 == 0\n    m = (l[len/2] + l[len/2 - 1]) / 2.0\n  else\n\
    \    m = l[len/2]\n  end\n  m\nend", "  # Sorted array.\n  sorted = merge_sort(l)\n\
    \  len = sorted.length\n  if len.odd?\n    sorted[len / 2]\n  else\n    (sorted[len\
    \ / 2] + sorted[len / 2 - 1]) / 2.0\n  end\nend", "    return (l.reduce(:+)/(l.length*1.0))\n\
    end", end, "  return nil if l.empty?\n  array = l.sort\n  if array.size.odd?\n\
    \    array[array.size / 2]\n  else\n    array[array.size / 2] + array[array.size\
    \ / 2 - 1] / 2.0\n  end\nend", "  raise ArgumentError if l.nil? || l.empty?\n\
    \  # Sort and find the mid index\n  mid = (l.size - 1) / 2\n  # If the size is\
    \ even, take the average of the middle 2\n  l.sort!\n  if l.size.even?\n    (l[mid]\
    \ + l[mid + 1]) / 2.0\n  else\n    l[mid]\n  end\nend", "  l.sort!\n  len = l.length\n\
    \  if len % 2 == 0\n    (l[len/2-1] + l[len/2]) / 2.0\n  else\n    l[len/2]\n\
    \  end\nend", "  l.sort!\n  if l.length.odd?\n    l[l.length/2]\n  else\n    (l[l.length/2-1]+l[l.length/2])/2.0\n\
    \  end\nend", "  l.sort!\n  middle = l.length / 2\n  if l.length % 2 == 0\n  \
    \  (l[middle - 1] + l[middle]) / 2.0\n  else\n    l[middle]\n  end\nend", "  sorted\
    \ = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2])\
    \ / 2.0\nend", "  # TODO\nend", "  a = l.sort\n  if a.length % 2 == 0\n    return\
    \ (a[a.length/2] + a[a.length/2 - 1]) / 2.0\n  else\n    return a[a.length/2]\n\
    \  end\nend", "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1) /\
    \ 2] + sorted[len / 2]) / 2.0\nend\nputs \"median\"\nputs \"Checking for [3, 1,\
    \ 2, 4, 5] which should return 3: #{median([3, 1, 2, 4, 5])}\"\nputs \"Checking\
    \ for [-10, 4, 6, 1000, 10, 20] which should return 15.0: #{median([-10, 4, 6,\
    \ 1000, 10, 20])}\"\nputs \"\"", "  l = l.sort\n  if l.length % 2 == 0\n    med\
    \ = (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n  else\n    med = l[l.length/2]\n\
    \  end\n  return med\nend", "  #TODO: Implement this\nend", "  l.length.odd? ?\
    \ (s = l.sort; s[s.length / 2]) : ((s = l.sort; (s[s.length / 2] + s[s.length\
    \ / 2 - 1]) / 2.0))\nend", '  return "Input should be an array" unless l.is_a?(Array)',
  "    sorted = l.sort\n    len = sorted.length\n    (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  sorted = l.sort\n  median = l.length / 2\n  if l.length\
    \ % 2 == 0\n    return (sorted[median] + sorted[median - 1]) / 2.0\n  else\n \
    \   return sorted[median]\n  end\nend", "  return nil if l.nil?\n  m, n = l.size.divmod(2)\n\
    \  n == 0 ? ((l[m - 1] + l[m]) / 2.0) : l[m]\nend", "  l.sort!\n  n = l.length\n\
    \  if n % 2 == 0\n    (l[n/2] + l[n/2 - 1]) / 2.0\n  else\n    l[n/2]\n  end\n\
    end", "  return l.inject(:+) / l.length if l.length % 2 == 0\n  l.sort[l.length\
    \ / 2]\nend", "  # write your code here\nend", "  sorted = l.sort\n  len = sorted.length\n\
    \  return (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  l.sort!\n\
    \  len = l.length\n  return (l[(len - 1) / 2] + l[len / 2]) / 2.0\nend", "  len\
    \ = l.length\n  sorted = l.sort\n  sorted[(len - 1) / 2] + sorted[len / 2] / 2.0\n\
    end", "    #\n    # Your code goes here\n    #\nend", "  length = l.length\n \
    \ return l[0] if length == 1\n  return (l[length/2 - 1] + l[length/2]) / 2.0 if\
    \ length.even?\n  return l[length/2]\nend", "    return l.sort[l.length/2]\nend",
  "  #your code here\nend", "\tl = l.sort\n\tindex = l.length / 2\n\tif l.length %\
    \ 2 == 0\n\t\t(l[index] + l[index-1]) / 2.0\n\telse\n\t\tl[index]\n\tend\nend",
  "  l.size % 2 == 0 ? (l[l.size / 2] + l[l.size / 2 - 1]) / 2.0 : l[l.size / 2]\n\
    end", "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  l.sort!\n  if l.length % 2 == 0\n    n = l.length/2\n\
    \    m = (l[n] + l[n-1])/2.0\n  else\n    m = l[l.length/2]\n  end\n  return m\n\
    end", "\t# median is the middle element of the sorted array\n\t# handle even array\
    \ size\n\t# handle even array size\n\tsorted_l = l.sort\n\tn = sorted_l.length\n\
    \treturn (sorted_l[n/2] + sorted_l[n/2-1])/2.0 if n.even?\n\tsorted_l[n/2]\nend",
  "    l.sort!\n    if l.length % 2 == 0\n        return (l[l.length/2 - 1] + l[l.length/2])\
    \ / 2.0\n    else\n        return l[l.length/2]\n    end\nend", "  sorted = l.sort\n\
    \  if sorted.length.odd?\n    sorted[sorted.length / 2]\n  else\n    sorted[sorted.length\
    \ / 2 - 1, 2].inject(:+) / 2.0\n  end\nend", "    # TODO\n    if l.size%2==0\n\
    \    \treturn (l[l.size/2]+l[l.size/2-1])/2.0\n    else\n    \treturn l[l.size/2]\n\
    \    end\nend", "  l.sort!\n  half = l.length / 2\n  len % 2 == 0 ? (l[half] +\
    \ l[half - 1]) / 2.0 : l[half]\nend", "\tn = l.length\n\t# odd array\n\tif n%2\
    \ == 1\n\t\tl[n/2]\n\telse\n\t\tsum = l[n/2-1] + l[n/2]\n\t\tsum.to_f/2\n\tend\n\
    end", "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  x = l.sort\n  return (x[(x.length - 1) / 2] + x[x.length\
    \ / 2]) / 2.0\nend", "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len\
    \ - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  # Median of an odd set of numbers\
    \ is the midpoint of the numbers when sorted.\n  # Median of an even set of numbers\
    \ is the average of the two midpoints.\n  if l.length.odd?\n    midpoint = (l.length\
    \ / 2)\n    return l.sort[midpoint]\n  else\n    midpoint = (l.length / 2)\n \
    \   sum = l.sort[midpoint] + l.sort[midpoint - 1]\n    return sum / 2.0\n  end\n\
    end", "    l.sort!\n    if l.length.even?\n        return (l[l.length/2] + l[l.length/2\
    \ - 1])/2.0\n    else\n        return l[l.length/2]\n    end\nend", "    l.sort!\n\
    \    len = l.length", "  l = l.sort\n  if l.length % 2 == 0\n    (l[l.length/2-1]\
    \ + l[l.length/2]) / 2.0\n  else\n    l[l.length/2]\n  end\nend", "\tlen = l.length\n\
    \tcase len\n\twhen 0\n\t\treturn nil\n\twhen 1\n\t\treturn l[0]\n\telse\n\t\t\
    return l.sort[len/2]\n\tend\nend", "  l.sort!\n  m = l.length / 2\n  if l.length\
    \ % 2 == 0\n    (l[m-1] + l[m]) / 2.0\n  else\n    l[m]\n  end\nend", "  l = l.sort\n\
    \  (l[l.length/2] + l[(l.length - 1)/2]) / 2.0\nend", "  # l.sort!\n  # median\
    \ = 0\n  # if l.length % 2 == 0\n  #   median = (l[l.length/2 - 1] + l[l.length/2])\
    \ / 2.0\n  # else\n  #   median = l[l.length/2]\n  # end\n  # median\n  l.sort!\n\
    \  median = l.length % 2 == 0 ? (l[l.length/2 - 1] + l[l.length/2]) / 2.0 : l[l.length/2]\n\
    end", "\tm = l.length/2\n\tif l.length % 2 == 0\n\t\treturn (l[m-1] + l[m])/2.0\n\
    \telse\n\t\treturn l[m]\n\tend\nend", "  sorted = l.sort\n  len = sorted.length\n\
    \  return (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  sorted = l.sort\n\
    \  len = sorted.length\n  return ((sorted[(len - 1) / 2] + sorted[len / 2]) /\
    \ 2.0).to_f\nend", "  l.sort!\n  if l.length.even?\n    return ((l[l.length/2]\
    \ + l[l.length/2 - 1])/2.0)\n  else\n    return l[l.length/2]\n  end\nend", " \
    \ mid = (l.length + 1)/2\n  sorted = l.sort\n  if sorted.length%2==0\n    return\
    \ (sorted[mid-1]+sorted[mid])/2.0\n  else\n    return sorted[mid-1]\n  end\nend",
  "  sorted = l.sort\n  (sorted[l.length/2] + sorted[(l.length - 1)/2]).to_f / 2\n\
    end", "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len\
    \ - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  # Your code here\n  return l.sort[l.length/2]\n\
    end", "  # BEGIN (write your solution here)\n  if l.count % 2 == 0\n    l = l.sort\n\
    \    (l[l.count / 2] + l[l.count / 2 - 1]) / 2.0\n  else\n    l = l.sort\n   \
    \ l[l.count / 2]\n  end\n  # END\nend", "  l.sort! # Linear sort\n  if l.length.odd?\n\
    \    return l[l.length/2]\n  else\n    return (l[l.length/2] + l[l.length/2 -\
    \ 1]) / 2.0\n  end\nend", '    return false if l.empty?', "  l.sort! # sorts the\
    \ list in-place\n  len = l.length\n  if len == 0\n    return 0\n  elsif len %\
    \ 2 == 0\n    (l[len/2 - 1] + l[len/2]) / 2.0\n  else\n    l[len/2]\n  end\nend",
  "  a = l.sort\n  len = a.length\n  len%2==0 ? ((a[len/2].to_f+a[len/2-1].to_f)/2).to_f\
    \ : a[len/2]\nend", "  l.sort\n  len = l.length\n  if len.odd?\n    middle = len\
    \ / 2\n    return l[middle]\n  else\n    first = len / 2 - 1\n    second = len\
    \ / 2\n    return (l[first] + l[second]) / 2.0\n  end\nend", "  n = l.length\n\
    \  m = n / 2\n  return (l[m] + l[m - 1]) / 2.0 if n.even?\n  l[m]\nend", "  m\
    \ = l.size / 2\n  l.sort!\n  if l.size % 2 == 0\n    (l[m-1] + l[m]) / 2.0\n \
    \ else\n    l[m]\n  end\nend", "  l.sort!\n  if l.length % 2 == 0\n    (l[l.length/2]\
    \ + l[l.length/2 - 1]) / 2.0\n  else\n    l[l.length/2]\n  end\nend", "  l.sort!\n\
    \  if l.length % 2 == 0\n    return (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n\
    \  else\n    return l[l.length/2]\n  end\nend", "  l.sort!\n  if l.length % 2\
    \ == 0\n    return (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n  else\n    return\
    \ l[l.length/2]\n  end\nend", "  l.sort!\n  len = l.length\n  return (l[(len -\
    \ 1) / 2] + l[len / 2]) / 2.0\nend", "  return (l.sort[l.length/2].to_f + l.sort[l.length/2\
    \ - 1].to_f)/2 if l.length.even?\n  l.sort[l.length/2]\nend", "    l.sort!\n \
    \   m = l.length / 2\n    if l.length % 2 == 0\n        (l[m] + l[m-1]) / 2.0\n\
    \    else\n        l[m]\n    end\nend", "  l.sort!\n  mid = l.length / 2\n  l.length.odd?\
    \ ? l[mid] : (l[mid - 1] + l[mid]).to_f / 2\nend", "  raise ArgumentError if l.nil?\
    \ || l.empty?\n  return l.first if l.size == 1\n  sorted = l.sort", "\tsorted\
    \ = l.sort\n\tlen = sorted.length\n\treturn (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  len = l.length\n  s = l.sort\n  (s[(len - 1) / 2] + s[len\
    \ / 2]) / 2.0\nend", "  sorted = l.sort\n  mid = (sorted.length / 2.0).floor\n\
    \  (sorted[mid] + sorted[mid - 1]) / 2.0\nend", "  return (l.sort[l.length/2]\
    \ + l.sort[l.length/2 - 1]) / 2.0 if l.length.even?\n  l.sort[l.length/2]\nend",
  "  if l.length.odd?\n    return l.sort[l.length/2]\n  else\n    return (l.sort[l.length/2]\
    \ + l.sort[l.length/2 - 1])/2.0\n  end\nend", "  sorted = l.sort\n  #puts \"sorted\
    \ array = #{sorted}\"\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  if l.length == 0\n    return -1\n  end\n  if l.length\
    \ % 2 == 0\n    l.sort!\n    return (l[l.length/2] + l[l.length/2 - 1])/2.0\n\
    \  else\n    l.sort!\n    return l[l.length/2]\n  end\nend", "  # your code here\n\
    end", "\tl.sort!\n\tif l.length % 2 == 0\n\t\treturn (l[l.length/2] + l[l.length/2\
    \ - 1]) / 2.0\n\telse\n\t\treturn l[l.length/2]\n\tend\nend", "\tl.sort!\n\tn\
    \ = l.length\n\tif n % 2 == 0\n\t\t(l[n/2] + l[n/2 - 1]) / 2.0\n\telse\n\t\tl[n/2]\n\
    \tend\nend", "    l.sort!\n    n = l.length\n    if n.even?\n        return (l[n/2\
    \ - 1] + l[n/2]) / 2.0\n    else\n        return l[n/2]\n    end\nend", "  s =\
    \ l.sort\n  return (s[(s.length - 1) / 2] + s[s.length / 2]) / 2.0\nend", "  if\
    \ (l.length % 2 == 0)\n    length = l.length\n    l = l.sort\n    median = (l[length/2\
    \ - 1] + l[length/2]) / 2.0\n  else\n    length = l.length\n    l = l.sort\n \
    \   median = l[length/2]\n  end\n  return median\nend\nputs median([-10, 4, 6,\
    \ 1000, 10, 20])", "  s = l.sort\n  (s[(s.length - 1) / 2] + s[s.length / 2])\
    \ / 2.0\nend", "  l.sort!\n  if l.length % 2 == 0\n    (l[l.length/2 - 1] + l[l.length/2])\
    \ / 2.0\n  else\n    l[l.length/2]\n  end\nend", "\tl.sort!\n\tif l.length % 2\
    \ == 0\n\t\treturn ((l[l.length/2] + l[l.length/2 - 1])/2.0)\n\telse\n\t\treturn\
    \ l[l.length/2]\n\tend\nend", "  sorted = l.sort\n  length = sorted.length\n \
    \ if length % 2 == 0\n    (sorted[length / 2 - 1] + sorted[length / 2]) / 2.0\n\
    \  else\n    sorted[length / 2]\n  end\nend", "    l.sort!\n    if l.length %\
    \ 2 == 0\n        l[l.length/2-1]\n    else\n        l[l.length/2]\n    end\n\
    end", "  length = l.length\n  if length.odd?\n    sorted = l.sort\n    return\
    \ sorted[length/2]\n  else\n    sorted = l.sort\n    return (sorted[length/2]\
    \ + sorted[length/2 - 1]) / 2.0\n  end\nend", "  sorted = l.sort\n  len = sorted.length\n\
    \  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  sorted = l.sort\n\
    \  length = sorted.length\n  return nil if length == 0\n  mid = length / 2\n \
    \ return sorted[mid] if length.odd?\n  (sorted[mid] + sorted[mid - 1]) / 2.0\n\
    end", "  sorted = l.sort\n  len = sorted.length\n  return sorted[len/2] if len\
    \ % 2 != 0\n  (sorted[len/2-1] + sorted[len/2]).to_f / 2\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
