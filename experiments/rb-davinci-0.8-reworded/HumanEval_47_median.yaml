name: HumanEval_47_median
language: rb
prompt: "# Return median of elements in the array l.\n# >>> median.call([3, 1, 2,\
  \ 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n\
  \    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4,\
  \ 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5,\
  \ candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7,\
  \ candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"
completions: ["  l.sort!\n  length = l.length\n  if length % 2 == 0\n    return (l[length/2\
    \ - 1] + l[length/2]) / 2.0\n  else\n    return l[length/2]\n  end\nend", "  \
    \  return l.sort![l.length/2]\nend", "  len = l.length\n  return l[len/2] if len\
    \ % 2 == 1\n  return (l[len/2] + l[len/2 - 1])/2.0\nend", "\t# Your code here\n\
    \tl.sort!\n\tif (l.length.even?)\n\t\treturn ((l[l.length/2-1] + l[l.length/2])\
    \ / 2.0)\n\telse\n\t\treturn l[l.length/2]\n\tend\nend", "  if l.length % 2 ==\
    \ 0\n    (l[l.length / 2] + l[l.length / 2 - 1]) / 2.0\n  else\n    l[l.length\
    \ / 2]\n  end\nend", "\tl.sort!\n\tmid = l.length / 2\n\tif l.length % 2 == 0\n\
    \t\treturn (l[mid] + l[mid - 1]) / 2.0\n\telse\n\t\treturn l[mid]\n\tend\nend",
  "  # YOUR CODE HERE\nend", "  # For testing\n  # puts \"l is #{l}\"\n  sorted_list\
    \ = l.sort\n  # For testing\n  # puts \"sorted_list is #{sorted_list}\"\n  length\
    \ = sorted_list.length\n  # For testing\n  # puts \"length is #{length}\"\n  if\
    \ length.odd?\n    median = sorted_list[length/2]\n  else\n    # for testing\n\
    \    # puts \"length/2 is #{length/2}\"\n    # puts \"length/2-1 is #{length/2-1}\"\
    \n    # puts \"sorted_list[length/2] is #{sorted_list[length/2]}\"\n    # puts\
    \ \"sorted_list[length/2-1] is #{sorted_list[length/2-1]}\"\n    median = (sorted_list[length/2].to_f\
    \ + sorted_list[length/2-1].to_f)/2\n  end\n  return median\nend", "  l.sort!\n\
    \  len = l.length\n  if len % 2 == 0\n    (l[len/2-1] + l[len/2]) / 2.0\n  else\n\
    \    l[len/2]\n  end\nend", end, "    l.sort!\n    if l.length % 2 == 0\n    \
    \    return (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n    else\n        return\
    \ l[l.length/2]\n    end\nend", '  sorted = l.sort', "  # TODO: implement me!\n\
    end", "  array = l.sort\n  length = array.length\n  # odd case\n  if length %\
    \ 2 == 1\n    return array[length / 2]\n  # even case\n  else\n    return (array[length\
    \ / 2 - 1] + array[length / 2]) / 2.0\n  end\nend", "  arr = l.sort\n  count =\
    \ l.count\n  if count.odd?\n    return arr[count/2]\n  else\n    return (arr[count/2]\
    \ + arr[count/2 - 1]) / 2.0\n  end\nend", "  # TODO\nend", "    l = l.sort\n \
    \   if l.length % 2 == 0\n        return (l[l.length/2] + l[l.length/2 - 1]) /\
    \ 2.0\n    else\n        return l[l.length/2]\n    end\nend", "  l = l.sort\n\
    \  if l.length % 2 == 0\n    return (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n\
    \  else\n    return l[l.length/2]\n  end\nend", "  l = l.sort\n  if l.length.odd?\n\
    \    l[l.length/2]\n  else\n    half = l.length/2\n    (l[half] + l[half-1])/2.0\n\
    \  end\nend", "  m = l.sort[l.length/2]\n  return m\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
