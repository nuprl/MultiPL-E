name: HumanEval_65_circular_shift
language: rb
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12,\
  \ 2)\n# \"12\"\ndef circular_shift(x, shift)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n\
  \    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100,\
  \ 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\"\
  , candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"\
  11\", candidate.call(11, 101))\n  end\nend\n"
completions: ["  x = x.to_s.reverse\n  return x if shift > x.length\n  x.chars.rotate(shift).join('')\n\
    end", "  while shift > 0\n    shift -= 1\n    x = (\"#{x % 10}#{x / 10}\").to_i\n\
    \  end\n  x.to_s\nend", "  s = x.to_s\n  (s.size - shift..s.size - 1).each { |i|\
    \ s[i] = s[i - s.size + shift] }\n  (0..s.size - shift - 1).each { |i| s[i] =\
    \ s[i + shift] }\n  s\nend", "  str = x.to_s\n  (str[-shift..-1] + str[0..-shift-1]).reverse\n\
    end\ncircular_shift.bdd_define(:call, [Fixnum, Fixnum])", "  x = x.to_s.reverse\n\
    \  shift %= x.length\n  x[0...shift].reverse + x[shift..-1]\nend", "  new_shift\
    \ = shift % x.to_s.length\n  x.to_s.reverse.split('').rotate(new_shift).join\n\
    end", "  x.to_s.reverse.chars.rotate(shift).join.reverse\nend", "  str = x.to_s\n\
    \  shift.times do\n    temp = str[0]\n    str[0] = str[-1]\n    str[-1] = temp\n\
    \  end\n  str\nend", "  digits = x.digits.reverse\n  shift = shift % digits.length\n\
    \  digits.rotate(shift).join\nend", "    shift %= x.to_s.length\n    x.to_s.chars.rotate(shift).join\n\
    end", "  x = x.to_s\n  x = x[-shift..-1] + x[0..-shift-1] if shift < x.length\n\
    \  x = x.reverse if shift >= x.length\n  x\nend", "  s = x.to_s\n  n = s.length\n\
    \  shift %= n\n  (s[shift..-1] + s[0...shift]).reverse\nend", "  digits = []\n\
    \  while x > 0\n    digits << x % 10\n    x /= 10\n  end\n  while shift > 0\n\
    \    shift -= 1\n    digits << digits.shift\n  end\n  digits.join\nend", "  (x.to_s.split('').rotate(-shift).join).to_i\n\
    end", "  x = x.to_s\n  x.size == 1 ? (return x) : (return x[shift..-1] + x[0..shift-1])\n\
    end", "  (x.to_s.chars.rotate(-shift).join).to_i\nend", "  l = x.to_s.length\n\
    \  s = x.to_s\n  (1..l).each do |i|\n    temp = s[l-i]\n    s[l-i] = s[l-(i+shift)]\
    \ || s[i+shift-l]\n    s[l-(i+shift)] = temp\n  end\n  s\nend", "  # Convert int\
    \ to array of digits\n  digits = x.to_s.split('')\n  # Split array of digits into\
    \ two arrays\n  # The first array contains the digits that are going to be shifted\n\
    \  # The second array contains the digits that are not going to be shifted\n \
    \ digits, keep = digits.each_slice(shift).to_a\n  # Concatenate shifted digits\
    \ with digits that are not going to be shifted\n  (digits.unshift keep).join('')\n\
    end", "  digits = []\n  while x > 0\n    digits << x % 10\n    x /= 10\n  end\n\
    \  return digits.reverse.join if shift > digits.length\n  digits = digits.push(digits.shift)\
    \ until shift.zero?\n  digits.join\nend", "  (x.to_s.reverse + x.to_s).reverse[shift..-1]\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
