name: HumanEval_65_circular_shift
language: rb
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12,\
  \ 2)\n# \"12\"\ndef circular_shift(x, shift)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n\
  \    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100,\
  \ 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\"\
  , candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"\
  11\", candidate.call(11, 101))\n  end\nend\n"
completions: ["  x = x.to_s.reverse\n  return x if shift > x.length\n  x.chars.rotate(shift).join('')\n\
    end", "  while shift > 0\n    shift -= 1\n    x = (\"#{x % 10}#{x / 10}\").to_i\n\
    \  end\n  x.to_s\nend", "  s = x.to_s\n  (s.size - shift..s.size - 1).each { |i|\
    \ s[i] = s[i - s.size + shift] }\n  (0..s.size - shift - 1).each { |i| s[i] =\
    \ s[i + shift] }\n  s\nend", "  str = x.to_s\n  (str[-shift..-1] + str[0..-shift-1]).reverse\n\
    end\ncircular_shift.bdd_define(:call, [Fixnum, Fixnum])", "  x = x.to_s.reverse\n\
    \  shift %= x.length\n  x[0...shift].reverse + x[shift..-1]\nend", "  new_shift\
    \ = shift % x.to_s.length\n  x.to_s.reverse.split('').rotate(new_shift).join\n\
    end", "  x.to_s.reverse.chars.rotate(shift).join.reverse\nend", "  str = x.to_s\n\
    \  shift.times do\n    temp = str[0]\n    str[0] = str[-1]\n    str[-1] = temp\n\
    \  end\n  str\nend", "  digits = x.digits.reverse\n  shift = shift % digits.length\n\
    \  digits.rotate(shift).join\nend", "    shift %= x.to_s.length\n    x.to_s.chars.rotate(shift).join\n\
    end", "  x = x.to_s\n  x = x[-shift..-1] + x[0..-shift-1] if shift < x.length\n\
    \  x = x.reverse if shift >= x.length\n  x\nend", "  s = x.to_s\n  n = s.length\n\
    \  shift %= n\n  (s[shift..-1] + s[0...shift]).reverse\nend", "  digits = []\n\
    \  while x > 0\n    digits << x % 10\n    x /= 10\n  end\n  while shift > 0\n\
    \    shift -= 1\n    digits << digits.shift\n  end\n  digits.join\nend", "  (x.to_s.split('').rotate(-shift).join).to_i\n\
    end", "  x = x.to_s\n  x.size == 1 ? (return x) : (return x[shift..-1] + x[0..shift-1])\n\
    end", "  (x.to_s.chars.rotate(-shift).join).to_i\nend", "  l = x.to_s.length\n\
    \  s = x.to_s\n  (1..l).each do |i|\n    temp = s[l-i]\n    s[l-i] = s[l-(i+shift)]\
    \ || s[i+shift-l]\n    s[l-(i+shift)] = temp\n  end\n  s\nend", "  # Convert int\
    \ to array of digits\n  digits = x.to_s.split('')\n  # Split array of digits into\
    \ two arrays\n  # The first array contains the digits that are going to be shifted\n\
    \  # The second array contains the digits that are not going to be shifted\n \
    \ digits, keep = digits.each_slice(shift).to_a\n  # Concatenate shifted digits\
    \ with digits that are not going to be shifted\n  (digits.unshift keep).join('')\n\
    end", "  digits = []\n  while x > 0\n    digits << x % 10\n    x /= 10\n  end\n\
    \  return digits.reverse.join if shift > digits.length\n  digits = digits.push(digits.shift)\
    \ until shift.zero?\n  digits.join\nend", "  (x.to_s.reverse + x.to_s).reverse[shift..-1]\n\
    end", "  return x.to_s.reverse if shift > x.to_s.length\n  x.to_s.split('').rotate(shift).join('')\n\
    end", "  x_str = x.to_s.reverse\n  shift = shift % x_str.length\n  x_str = x_str[shift..-1]\
    \ + x_str[0..shift-1]\n  x_str.reverse\nend", "  s = x.to_s\n  if shift > s.length\n\
    \    s.reverse\n  else\n    s[shift..-1] + s[0..shift-1]\n  end\nend", "  str\
    \ = x.to_s\n  return str.reverse if shift > str.length\n  return str[-shift..-1]\
    \ + str[0..-shift-1]\nend", "    x.to_s.reverse.chars.rotate(shift).join.reverse\n\
    end", "  num_digits = x.to_s.size\n  reversed = x.to_s.reverse\n  (num_digits\
    \ - shift).times { reversed.insert(0, reversed.slice!(-1)) }\n  reversed\nend",
  "  s = x.to_s\n  d = s.length\n  if shift > d\n    s.reverse\n  else\n    s[d-shift..d]\
    \ + s[0..d-shift-1]\n  end\nend", "  digits = x.to_s.split('')\n  if digits.size\
    \ > shift\n    digits.rotate!(-shift)\n  else\n    digits.reverse!\n  end\n  digits.join('')\n\
    end", "  left = shift % x.to_s.length\n  right = x.to_s.length - left\n  x.to_s[left..-1]\
    \ + x.to_s[0..left-1]\nend", "  # note: Digits in binary format, max = 63 = 3_2\
    \ + 3_1 + 3_0 = (3 + 1 + 1) = 5\n  shift = shift % (Math.log2(x).to_i + 1)\n \
    \ return x.to_s if shift == 0\n  return sprintf(\"%b\", x).reverse if shift ==\
    \ 1\n  (sprintf(\"%b\", x) + sprintf(\"%b\", x)).chars.drop(shift).take(shift).join\n\
    end", "  digits = x.to_s.chars\n  digits_to_shift = digits.length - shift\n  digits[digits_to_shift..-1]\
    \ + digits[0...digits_to_shift]\nend", "  len = x.to_s.length\n  return x.to_s.reverse\
    \ if shift > len\n  return x.to_s.split('').rotate(len - shift).join\nend", " \
    \ digits = x.digits.reverse\n  return digits.join(\"\") if shift > digits.size\n\
    \  digits.unshift(digits.pop).join(\"\")\nend", "  chars = x.to_s.chars\n  (shift\
    \ > chars.length) ? chars.reverse.join :\n    (chars[shift..-1] + chars[0...shift]).join\n\
    end", "  digits = x.to_s.chars\n  length = digits.length\n  shift %= length\n\
    \  digits[-shift..-1] + digits[0..-shift-1]\nend", "  digits = x.to_s.split('')\n\
    \  (shift % digits.length).times do\n    digits.unshift(digits.pop)\n  end\n \
    \ digits.join\nend", "  size = x.to_s.size\n  return x.to_s.reverse if shift >\
    \ size\n  x.to_s[size - shift, size] + x.to_s[0, size - shift]\nend", "  shift\
    \ = shift % x.to_s.length\n  x.to_s.reverse.chars.rotate(shift).join.reverse\n\
    end", "  \"123456789\".reverse[0..-x.to_s.length].reverse[shift..-1].reverse +\
    \ x.to_s[shift..-1]\nend", "  num_digits = (Math.log10(x).floor + 1)\n  i = 0\n\
    \  res = \"\"\n  while i < num_digits do\n    res = ((x % 10 ** (i + 1)) / 10\
    \ ** i).to_s + res\n    i += 1\n  end\n  res = res[num_digits - shift, num_digits]\
    \ + res[0, num_digits - shift]\n  res\nend", "  a = x.to_s.chars\n  shift.times\
    \ { a.unshift(a.pop) }\n  a.join\nend", "  s = x.to_s\n  shift %= s.length\n \
    \ s.reverse.chars.rotate(shift).join\nend", "  if shift > x.to_s.length\n    return\
    \ x.to_s.reverse\n  end\n  res = x.to_s.split('')\n  res.rotate!(-shift)\n  res.join\n\
    end", "  return x.to_s.reverse if shift > x.to_s.length\n  x.to_s.last(shift)\
    \ + x.to_s.first(x.to_s.length - shift)\nend", "  x = x.to_s.chars\n  (x.length\
    \ - shift).times do\n    x << x.shift\n  end\n  x.join\nend", "  x.to_s.size >\
    \ shift ? x.to_s.split('').rotate(shift).join : x.to_s.reverse\nend", "  x = x.to_s.split('')\n\
    \  shift = shift - 1\n  if shift >= x.length\n    x.reverse.join\n  else\n   \
    \ x.rotate(shift).join\n  end\nend", "  return x.to_s.reverse if shift > x.to_s.length\n\
    \  x.to_s.concat(x.to_s).split('').last(x.to_s.length)[-shift..-1].join.concat(x.to_s.split('').first(x.to_s.length\
    \ - shift).join)\nend", "  str = x.to_s\n  if shift > str.length\n    str.reverse\n\
    \  else\n    str[shift, str.length] + str[0, shift]\n  end\nend", "  digits =\
    \ x.to_s.chars\n  shift = shift % digits.length\n  digits.rotate(-shift).join\n\
    end", "  (x.to_s * 2)[x.to_s.length - shift..-1]\nend", "  if x == 0\n    return\
    \ \"0\"\n  end\n  # We know we will be shifting right, so first reverse the string.\n\
    \  x_reversed = x.to_s.reverse\n  shift = shift % x_reversed.length\n  # Now use\
    \ a slice to return the desired circular shift.\n  return x_reversed[shift..-1]\
    \ + x_reversed[0..shift-1]\nend", "  x.to_s.reverse.chars.rotate(shift).join.reverse\n\
    end", "  s = x.to_s\n  (shift.modulo(s.length)).times { s.concat(s.slice!(0))\
    \ }\n  s\nend", "  string_x = x.to_s\n  shift = shift % string_x.length\n  string_x[shift..-1]\
    \ + string_x[0...shift]\nend", "  str = x.to_s\n  return str.reverse if shift\
    \ > str.length\n  str.slice(shift..-1) + str.slice(0, shift)\nend", "  shifted\
    \ = \"\"\n  digits = x.to_s.split('')\n  digits.reverse.each_with_index do |d,\
    \ i|\n    shifted += digits[(i - shift) % digits.length]\n  end\n  shifted\nend",
  "  digits = x.to_s.chars\n  shift.times { digits.unshift(digits.pop) }\n  digits.join\n\
    end", "  x = x.to_s.split('')\n  (x.size - shift).times {x.push(x.shift)}\n  x.join\n\
    end", "  x = x.to_s.split('')\n  x.rotate!(-shift)\n  x.join('')\nend", "  if\
    \ shift > x.to_s.length\n    return x.to_s.reverse\n  end\n  x_string = x.to_s\n\
    \  shift.times do\n    x_string = x_string[1..-1] + x_string[0]\n  end\n  x_string\n\
    end", "  string_x = x.to_s\n  if shift > string_x.length\n    string_x.reverse\n\
    \  else\n    string_x.slice(shift..-1) + string_x.slice(0..shift-1)\n  end\nend",
  "  shift = x.to_s.length if shift > x.to_s.length\n  x.to_s.reverse.chars.rotate(shift).join.reverse\n\
    end", "  return x.to_s.reverse if shift > x.to_s.length\n  x = x.to_s.split('')\n\
    \  for i in 1..shift\n    x.unshift(x.pop)\n  end\n  x.join('')\nend", "  x.to_s.reverse.chars.rotate(shift).join\n\
    end", "  digits = 0\n  tmp = x\n  while tmp > 0\n    tmp /= 10\n    digits +=\
    \ 1\n  end\n  shift = shift % digits\n  return x.to_s.reverse if shift == 0\n\
    \  (x.to_s.split('').rotate(-shift)).join\nend", "  len = x.to_s.length\n  shift\
    \ = shift % len\n  x.to_s[shift..-1] + x.to_s[0..shift-1]\nend", "  string = x.to_s\n\
    \  shift %= string.length\n  (string[-shift..-1] + string[0..-shift-1]).reverse\n\
    end", "  num_digits = Math.log10(x).floor + 1\n  if shift >= num_digits\n    shifted\
    \ = x.to_s.reverse.to_i\n  else\n    shifted = (x.to_s.slice(num_digits - shift,\
    \ shift) + x.to_s.slice(0, num_digits - shift)).to_i\n  end\n  shifted.to_s\n\
    end", "  x_string = x.to_s\n  return x_string.reverse if shift > x_string.length\n\
    \  x_string.slice(shift..-1) + x_string.slice(0..shift-1)\nend", "  x.to_s.reverse.chars.rotate(shift).join.reverse\n\
    end", "  x.to_s.reverse.chars.rotate(shift).join\nend\ncircular_shift = f(method(:circular_shift))",
  "  digits = x.to_s.chars\n  digits.unshift(digits.pop(shift)).join\nend", "  x =\
    \ x.to_s\n  shift = shift.to_i\n  if shift > x.length\n    x.reverse\n  else\n\
    \    x[-shift..-1] + x[0..-(shift + 1)]\n  end\nend", "  n = Math.log10(x).floor\
    \ + 1\n  x / (10 ** shift) + (x % (10 ** shift)) * (10 ** (n - shift))\nend",
  "  # make a copy of x so that we don't change it\n  temp = x\n  # get the number\
    \ of digits in x\n  digits = digits_of(x)\n  # if shift is more than the number\
    \ of digits, return a reversed string\n  return digits.reverse.to_s if shift >\
    \ digits\n  # split the digits into an array\n  digits = digits.to_s.split('')\n\
    \  # rotate the digits the specified amount\n  rotated = digits.rotate(shift)\n\
    \  # join the array into a string\n  rotated.join('')\nend", "  x_str = x.to_s\n\
    \  x_size = x_str.size\n  shift %= x_size\n  shifted_str = x_str[shift..-1] +\
    \ x_str[0..shift-1]\n  shifted_str\nend", "  shift = shift % x.to_s.length\n \
    \ (x.to_s[-shift..-1] + x.to_s[0..-shift-1]).to_i\nend", "  shift = shift % x.to_s.length\n\
    \  return x.to_s.reverse if shift == 0\n  x.to_s[shift..-1] + x.to_s[0..shift-1]\n\
    end", "  digits = x.to_s.chars\n  shifted = (shift > digits.length) ? digits.reverse\
    \ : digits.rotate(shift)\n  shifted.join\nend", "  (1..shift).each do |i|\n  \
    \  x = x.to_s.split('').rotate.join('').to_i\n  end\n  x.to_s\nend", "  s = x.to_s\n\
    \  return s.reverse if shift > s.length\n  return s[shift..-1] + s[0...shift]\n\
    end", "  x_as_str = x.to_s\n  if shift > x_as_str.length\n    x_as_str.reverse\n\
    \  else\n    x_as_str[shift..-1] + x_as_str[0..shift-1]\n  end\nend", "  digits\
    \ = x.to_s.chars\n  shift = shift % digits.size\n  (digits.rotate(shift) << digits).join\n\
    end", "  return x.to_s.reverse if shift > x.to_s.length\n  x.to_s.chars.rotate(shift).join\n\
    end", "  x_string = x.to_s\n  num_digits = x_string.length\n  shift %= num_digits\n\
    \  return x_string[num_digits - shift, shift] + x_string[0, num_digits - shift]\n\
    end", "  shift %= x.digits.length\n  x.digits.rotate(-shift).join.to_i\nend",
  "  return x.to_s.reverse if shift > x.to_s.length\n  length = x.to_s.length\n  (x.to_s[length\
    \ - shift, length] + x.to_s[0, length - shift]).to_i.to_s\nend", "  x = x.to_s\n\
    \  if x.length <= shift\n    return x.reverse\n  else\n    return (x[-shift..-1]\
    \ + x[0..-shift-1])\n  end\nend", "  result = (shift > x.to_s.length) ? x.to_s.reverse\
    \ : x.to_s\n  shift.times do\n    val = result.slice!(-1)\n    result = val +\
    \ result\n  end\n  result\nend", "  digit_string = x.to_s\n  if shift > digit_string.length\n\
    \    digit_string.reverse\n  else\n    digit_string.slice(shift..-1) + digit_string.slice(0..shift-1)\n\
    \  end\nend", "  digits = x.to_s.split('')\n  shift = shift % digits.length\n\
    \  digits.push(digits.shift(shift)).join\nend", "  return nil if x == nil || shift\
    \ == nil\n  return x.to_s if shift == 0", "    digits = x.to_s.chars\n    return\
    \ digits.reverse.join if shift > digits.length\n    digits.push(*digits.shift(shift)).join\n\
    end", "  digits = x.to_s.chars\n  (digits[-shift..-1] + digits[0..-shift-1]).join\n\
    end", "  digits = x.to_s.chars\n  shift %= digits.length\n  digits.rotate(shift).join\n\
    end", "  x = x.to_s\n  if x.length > shift\n    x[shift..-1] + x[0...shift]\n\
    \  else\n    x.reverse\n  end\nend", "  x.to_s.reverse.scan(/.{1,#{shift}}/).map(&:reverse).join\n\
    end", "  s = \"%d\" % x\n  n = s.length - shift\n  s[n..-1] + s[0..n-1]\nend",
  "  return x.to_s.reverse if shift > x.to_s.length\n  x.to_s.chars.rotate(shift).join\n\
    end", "  s = x.to_s\n  n = s.length\n  shift %= n\n  [s[shift..n], s[0...shift]].join('')\n\
    end", "  x_s = x.to_s\n  len = x_s.length\n  shift = shift % len\n  x_s.slice(shift,\
    \ len - shift) + x_s.slice(0, shift)\nend", "  if x < 0\n    '-' + circular_shift(-x,\
    \ shift)\n  else\n    x_s = x.to_s\n    if shift > x_s.length\n      x_s.reverse\n\
    \    else\n      x_s.slice(shift..-1) + x_s.slice(0..shift-1)\n    end\n  end\n\
    end", "  x_digits = x.to_s.chars\n  shift = shift % x_digits.length\n  (x_digits.rotate(-shift)\
    \ << (shift > 0 ? shift : '')).join\nend", "  x.to_s.reverse.chars.rotate(shift).join.reverse\n\
    end", "  x = x.to_s.reverse.scan(/./)\n  shifted = []\n  shift.times do |i|\n\
    \    x << x.shift\n  end\n  x.each do |element|\n    shifted << element\n  end\n\
    \  shifted.join\nend", "    x.to_s.split('').rotate(-shift).join('')\nend", " \
    \ digits = x.to_s.split('')\n  shift.times do\n    digit = digits.pop\n    digits.unshift(digit)\n\
    \  end\n  digits.join('')\nend", "  x = x.to_s.reverse\n  x[shift..-1] + x[0..shift-1]\n\
    end", "  digits = x.to_s.length\n  shift = shift % digits\n  x.to_s.reverse.slice(shift,\
    \ digits).reverse +\n    x.to_s.reverse.slice(0, shift).reverse\nend", "  n =\
    \ x.to_s.length\n  if n < shift\n    x.to_s.reverse\n  else\n    n.times do\n\
    \      x = x % 10 * 10 ** (n - 1) + x / 10\n    end\n    x.to_s\n  end\nend",
  "  return x.to_s.reverse if shift > x.to_s.length\n  x.to_s.split('').rotate(shift).join\n\
    end", "  x.to_s.reverse.chars.rotate(shift).join\nend", "  return x.to_s.reverse\
    \ if shift > x.to_s.length\n  (x.to_s[shift, x.to_s.length] + x.to_s[0, shift]).to_i.to_s\n\
    end", "  return x.to_s.reverse if shift > x.to_s.length\n  (x.to_s[shift..-1]\
    \ + x.to_s[0..shift-1]).to_i.to_s\nend", "  raise NotImplementedError(\"#{__FILE__}\
    \ #{__LINE__}\")\nend", "    x.to_s.chars.rotate(-shift).join\nend", "  x = x.to_s\n\
    \  if x.length <= shift\n    return x.reverse\n  else\n    shift.times do |i|\n\
    \      x.insert(0, x.slice!(-1))\n    end\n    return x\n  end\nend", "  digits\
    \ = x.to_s.length\n  if shift > digits\n    x.to_s.reverse\n  else\n    temp =\
    \ x.to_s\n    temp[0..shift-1] = x.to_s[shift..digits-1]\n    temp[shift..digits-1]\
    \ = x.to_s[0..shift-1]\n    temp\n  end\nend", "  x = x.to_s\n  return x.reverse\
    \ if shift > x.length\n  x[-shift..-1] + x[0..-shift-1]\nend", "    x = x.to_s.chars.reverse\n\
    \    return x.join if shift > x.length\n    x.rotate(shift).join\nend", "  digits\
    \ = x.to_s.split('')\n  shift = shift % digits.length\n  (digits.drop(shift) +\
    \ digits.take(shift)).join\nend", "  digits = []\n  number = x\n  len = 0\n  while\
    \ number > 0\n    digit = number % 10\n    digits << digit\n    number = number\
    \ / 10\n    len += 1\n  end\n  if len == 0\n    return \"0\"\n  end\n  # shift\
    \ might be > len, so we wrap around\n  shift = shift % len\n  shifted_digits =\
    \ digits[shift...len] + digits[0...shift]\n  shifted_digits.join\nend", "  shift\
    \ = shift % number_of_digits(x)\n  x.to_s.reverse.chars.rotate(shift).join\nend",
  "  x_str = x.to_s\n  x_str.slice(x_str.length - shift, shift) + x_str.slice(0, x_str.length\
    \ - shift)\nend", "  # determine if the shift is greater than the number of digits\n\
    \  if shift > Math.log10(x).floor + 1\n    # return the digits reversed if so\n\
    \    x.to_s.reverse\n  else\n    # if not, split the digits into an array, then\
    \ rotate and join them\n    x.to_s.split('').rotate(shift).join('')\n  end\nend",
  "  digits = Math.log10(x).floor + 1\n  shift = digits if shift > digits\n  str =\
    \ x.to_s\n  str = str[-shift..-1] + str[0..-shift-1]\n  return str\nend", "  digits\
    \ = digits_of(x)\n  shift %= digits.length\n  digits.slice!(digits.length - shift,\
    \ shift) + digits\nend", "  digits = x.to_s.split('')\n  shift = shift % digits.size\n\
    \  digits.rotate(shift).join\nend", "  x.to_s.reverse.chars.rotate(shift).join.reverse\n\
    end", "  digits = x.digits\n  shift_digits = digits.size < shift ? digits.reverse\
    \ : digits.rotate(-shift)\n  shift_digits.join\nend", "  s = x.to_s\n  res = \"\
    \"\n  if shift > s.length\n    res = s.reverse\n  else\n    res = s[shift..-1]\
    \ + s[0..shift-1]\n  end\n  res\nend", "  x = x.to_s\n  if shift < x.length\n\
    \    (x[shift..-1] + x[0...shift]).to_i\n  else\n    x.reverse.to_i\n  end\nend",
  "  if x < 1\n    raise \"Number must be positive\"\n  end\n  if shift < 1\n    raise\
    \ \"Shift must be positive\"\n  end\n  digits = Math.log10(x).to_i + 1\n  if shift\
    \ > digits\n    return x.to_s.reverse\n  end\n  return ((x % (10 ** shift)) *\
    \ (10 ** (digits - shift)) + (x / (10 ** shift))).to_s\nend", "  x = x.to_s\n\
    \  shift = shift % x.length\n  if shift == 0\n    x\n  else\n    (x.length - shift).times\
    \ do\n      x.prepend(x.slice!(-1))\n    end\n    x\n  end\nend", "  x_str = x.to_s\n\
    \  shift %= x_str.length\n  (x_str[shift..-1] + x_str[0...shift]).reverse\nend",
  "  digits = to_array(x)\n  (digits.length - shift).times do\n    digits.unshift(digits.pop)\n\
    \  end\n  digits.join\nend", "  (x.to_s.split('').rotate(shift).join)\nend", " \
    \ return x.to_s.reverse if shift > x.to_s.length\n  x.to_s.reverse.chars.rotate(shift).join.reverse\n\
    end", "  x.to_s.split('').rotate(-shift).join('')\nend", "  x_str = x.to_s\n \
    \ len = x_str.length\n  shift = shift % len\n  len.times do\n    x_str = x_str[1..-1]\
    \ + x_str[0]\n  end\n  x_str[-shift..-1] + x_str[0..-(shift + 1)]\nend", "  s\
    \ = x.to_s\n  (s[shift..-1] + s[0...shift]).reverse\nend", "  x.to_s.split('').map(&:to_i).rotate(-shift).join\n\
    end", "  x = x.to_s.split('')\n  y = x.slice!(0, shift)\n  x.concat(y).join('')\n\
    end", "  return x.to_s.reverse if shift > x.to_s.length\n  x.to_s.split('').rotate(shift).join('')\n\
    end", "  x.to_s.reverse.chars.rotate(shift).join.reverse\nend", "  x_arr = x.to_s.split('')\n\
    \  shift.times do\n    last_digit = x_arr.pop\n    x_arr.unshift(last_digit)\n\
    \  end\n  x_arr.join('')\nend", "  # your code here\nend", "  x_str = x.to_s\n\
    \  shift = shift % x_str.length\n  if shift == 0\n    x_str\n  else\n    x_str[-shift..-1]\
    \ + x_str[0..-shift-1]\n  end\nend", "    digits = []\n    x.to_s.split('').each\
    \ { |digit| digits << digit.to_i }\n    digits << digits.shift until digits.size\
    \ == shift", "  length = x.to_s.length\n  return x.to_s.reverse if shift > length\n\
    \  str = x.to_s.split('')\n  str.rotate!(-shift)\n  str.join\nend", "  str = x.to_s\n\
    \  res = str[-shift, shift] + str[0, str.length - shift]\n  res\nend", "  digits\
    \ = x.to_s.length\n  shift = shift % digits\n  x.to_s.reverse.slice(0, shift).reverse\
    \ + x.to_s.reverse.slice(shift, digits)\nend", "  len = x.to_s.length\n  shift\
    \ = shift % len\n  x.to_s[shift..-1] + x.to_s[0..shift-1]\nend", "  to_shift =\
    \ x.to_s.length - shift\n  to_shift < 0 ? x.to_s.reverse : x.to_s[to_shift..-1]\
    \ + x.to_s[0..to_shift-1]\nend", "  x = x.to_s\n  if shift > x.length\n    return\
    \ x.reverse\n  end\n  x.slice!(0, shift) + x\nend", "  digits = x.to_s.split('')\n\
    \  if shift < digits.length\n    digits.rotate(shift).join\n  else\n    digits.reverse.join\n\
    \  end\nend", "  num_len = x.to_s.length\n  if shift > num_len\n    x.to_s.reverse\n\
    \  else\n    last_n = x.to_s[num_len - shift, num_len]\n    first_n = x.to_s[0,\
    \ num_len - shift]\n    last_n + first_n\n  end\nend", "  (1..shift).each { x\
    \ = x.to_s.split('').reverse.join.to_i }\n  x.to_s\nend", "  x.to_s.chars.rotate(-shift).join.to_i\n\
    end", "  string_x = x.to_s\n  string_x.length > shift ? string_x.slice(shift..-1)\
    \ + string_x.slice(0, shift) : string_x.reverse\nend", "  shift = shift.modulo(x.to_s.length)\n\
    \  x.to_s.reverse.chars.rotate(shift).join\nend", "  length = x.to_s.length\n\
    \  while shift >= length\n    shift -= length\n  end\n  if shift == 0\n    x.to_s\n\
    \  else\n    x = x.to_s\n    x[length - shift..length - 1] + x[0..length - shift\
    \ - 1]\n  end\nend", "  num_digits = Math.log10(x).to_i + 1\n  shift %= num_digits\n\
    \  x.to_s.reverse[shift..-1].reverse + x.to_s.reverse[0...shift].reverse\nend",
  "  if shift == 0\n    x.to_s\n  else\n    if shift < x.to_s.length\n      x.to_s[-shift..-1]\
    \ + x.to_s[0..-(shift + 1)]\n    else\n      circular_shift(x, shift - x.to_s.length).reverse\n\
    \    end\n  end\nend", "  digits = x.to_s.split('')\n  (shift % digits.length).times\
    \ do\n    digits.unshift(digits.pop)\n  end\n  digits.join\nend", "  if shift\
    \ >= x.to_s.length\n    x.to_s.reverse\n  else\n    x.to_s[shift..-1] + x.to_s[0..shift-1]\n\
    \  end\nend", "  digits = x.to_s.chars\n  return digits.reverse.join if shift\
    \ > digits.size\n  digits[digits.size - shift, shift] + digits[0, digits.size\
    \ - shift]\nend", "  xs = x.to_s\n  xs.slice(-shift, xs.length) + xs.slice(0,\
    \ -shift)\nend", "  digits = x.to_s.chars\n  shift = shift.abs % digits.size\n\
    \  digits.rotate(-shift).join\nend", "  x_len = x.to_s.length\n  shift %= x_len\
    \ if x_len > shift\n  x.to_s.split('').rotate(shift).join\nend", "  x = x.to_s\n\
    \  return x.reverse if shift > x.length\n  x[x.length - shift..-1] + x[0..x.length\
    \ - shift - 1]\nend", "  number_of_digits = x.to_s.length\n  if shift >= number_of_digits\n\
    \    x.to_s.reverse\n  else\n    x.to_s[shift, number_of_digits] + x.to_s[0, shift]\n\
    \  end\nend", "  arr = x.to_s.split('')\n  (arr.length - shift).times { arr.unshift(arr.pop)\
    \ }\n  arr.join\nend", "  if x.is_a? String\n    x = x.to_i\n  end\n  digits =\
    \ x.to_s.split('')\n  len = digits.length\n  shift = shift.modulo(len)\n  digits.push(digits.shift(shift)).join\n\
    end", "  s = x.to_s\n  if shift > s.length\n    return s.reverse\n  end\n  s.slice(shift..-1)\
    \ + s.slice(0, shift)\nend", "  # How many digits are in the integer.\n  digits\
    \ = Math.log10(x).floor+1\n  if shift > digits\n    x.to_s.reverse\n  else\n \
    \   # The digit to drop off the end.\n    # The digit to drop off the beginning\
    \ and add to the end.\n    x = x.to_s.split('')\n    digit_to_drop = x.shift\n\
    \    x.push(digit_to_drop)\n    x.join('')\n  end\nend", "  str = x.to_s\n  (str\
    \ * 2)[str.length - shift, str.length]\nend", "  digits = x.to_s.size\n  shift\
    \ = shift % digits\n  ((x.to_s[shift..-1] || '') + (x.to_s[0..shift-1] || '')).to_i\n\
    end", "  digits = x.to_s.chars\n  shift = shift % digits.length\n  digits.rotate(shift).join\n\
    end", "  shift = shift % (Math.log10(x).to_i + 1)\n  circular_shift_by_digits(x,\
    \ shift)\nend", "  digits = x.to_s.chars\n  shift = shift % digits.length\n  digits.rotate(shift).join\n\
    end", "  return x.to_s.reverse! if shift > x.to_s.length\n  last = x.to_s.split('').last(shift)\n\
    \  first = x.to_s.split('')[0...-shift]\n  (last + first).join('')\nend", "  number_of_digits\
    \ = x.to_s.length\n  # return digits reversed if shift > number of digits\n  if\
    \ shift > number_of_digits\n    return x.to_s.reverse\n  else\n    # remove shift\
    \ number of digits from the right\n    # and append them to the front\n    return\
    \ (x.to_s[-shift..-1] + x.to_s[0..-shift-1])\n  end\nend\nputs \"circular_shift:\"\
    \nprint \"circular_shift.call(12, 1): \"\nputs circular_shift.call(12, 1)\nprint\
    \ \"circular_shift.call(12, 2): \"\nputs circular_shift.call(12, 2)\nprint \"\
    circular_shift.call(12, 3): \"\nputs circular_shift.call(12, 3)\nprint \"circular_shift.call(4321,\
    \ 1): \"\nputs circular_shift.call(4321, 1)\nprint \"circular_shift.call(4321,\
    \ 2): \"\nputs circular_shift.call(4321, 2)\nprint \"circular_shift.call(4321,\
    \ 3): \"\nputs circular_shift.call(4321, 3)", "  x.to_s.reverse.ljust(shift, '0').reverse.to_i.to_s\n\
    end", "  n = x.to_s.length\n  if shift >= n\n    x.to_s.reverse\n  else\n    x.to_s[shift,\
    \ n - shift] + x.to_s[0, shift]\n  end\nend", "    n = x.to_s.length\n    if n\
    \ <= shift\n        return x.to_s.reverse\n    else\n        return (x.to_s.reverse[shift..n-1]+x.to_s.reverse[0..shift-1]).reverse\n\
    \    end\nend", "  l = x.to_s.length\n  return x.to_s.reverse if shift > l\n \
    \ shift.times {x = (x % 10) * 10**(l-1) + x / 10}\n  x.to_s\nend", "    str =\
    \ x.to_s\n    len = str.length\n    return str if shift > len\n    str.reverse[0,\
    \ len - shift].reverse + str.reverse[len - shift, shift].reverse\nend", "  x =\
    \ x.to_s.split('')\n  x = x.rotate(-shift)\n  x.join\nend", "  arr = x.to_s.split('')\n\
    \  i = arr.size - shift\n  arr[i..-1] + arr[0...i]\nend", "  digits = x.to_s.length\n\
    \  s = x.to_s.split('')\n  shift.times { s << s.shift }\n  s.join\nend", "  x\
    \ = x.to_s.split('')\n  if shift > x.length\n    return x.reverse.join\n  else\n\
    \    return (x.pop(shift) + x).join\n  end\nend", "  x_str = x.to_s\n  str_len\
    \ = x_str.length\n  shift_modulo = shift % str_len\n  if shift_modulo == 0\n \
    \   x_str\n  else\n    x_str.slice(str_len - shift_modulo, str_len) + x_str.slice(0,\
    \ str_len - shift_modulo)\n  end\nend", "  max_shift = (x.to_s.length)\n  shift\
    \ = shift > max_shift ? max_shift : shift\n  (x.to_s[shift..max_shift - 1] + x.to_s[0..shift\
    \ - 1]).to_i\nend", "  x.to_s.reverse.chars.rotate(shift).join.reverse\nend",
  "  return x.to_s.reverse if shift > x.to_s.length\n  x = x.to_s.split('')\n  x.unshift(x.pop(shift))\n\
    \  x.join('')\nend", "  return \"0\" if x == 0\n  arr = x.to_s.split('')\n  shift.times\
    \ do |i|\n    arr.unshift(arr.pop)\n  end\n  arr.join\nend", "  digits = x.to_s.chars\n\
    \  shift %= digits.size\n  digits.rotate(shift).join\nend", "  # convert x to\
    \ a string\n  x = x.to_s"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
