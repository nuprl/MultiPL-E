name: HumanEval_104_unique_digits
language: rb
prompt: "# Given an array of positive integers x. return a sorted array of all \n\
  # elements that hasn't any even digit.\n# Note: Returned array should be sorted\
  \ in increasing order.\n# For example:\n# >>> unique_digits.call([15, 33, 1422,\
  \ 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef\
  \ unique_digits(x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n\
  \    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15,\
  \ 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n \
  \   assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31,\
  \ 135], candidate.call([135, 103, 31]))\n  end\nend\n"
completions: ["  x.select { |n| n.to_s.chars.all? { |c| c.to_i.odd? } }.sort\nend",
  "  x.select{|v| v.to_s.split('').all?{|v2| v2.to_i.odd?}}.sort\nend", "  # Solution\
    \ 1\n  # x.sort.delete_if { |n| n.to_s.length != n.to_s.chars.uniq.length }\n\
    \  # Solution 2\n  # x.sort.select { |n| n.to_s.length == n.to_s.chars.uniq.length\
    \ }\n  # Solution 3\n  x.sort.select { |n| n.to_s.chars.uniq.length == n.to_s.length\
    \ }\nend", "  # Your code goes here\nend", "    a = []\n    b = []\n    x.each\
    \ do |i|\n        if i.to_s.match(/2|4|6|8|0/)\n            a << i\n        else\n\
    \            b << i\n        end\n    end\n    return b.sort\nend", "  x.select\
    \ { |el| el.to_s.each_char.all? { |c| c.to_i.odd? } }.sort\nend", "  x.select\
    \ { |e| e.to_s.scan(/\\d/).all? { |d| d.to_i.odd? } }.sort\nend", "  all_numbers\
    \ = x.sort\n  all_numbers.map { |number| number unless number.to_s.include?(\"\
    2\") || number.to_s.include?(\"4\") || number.to_s.include?(\"6\") || number.to_s.include?(\"\
    8\") }.compact\nend", "  x.select{|i| i.to_s.each_char.map(&:to_i).none?(&:even?)}.sort\n\
    end", "    # x.each { |i| puts i.to_s.length == 1 ? i : \"\" }\n    x.each { |i|\
    \ puts i.to_s.chars.map(&:to_i).count.even? ? \"\" : i }\nend\nunique_digits([15,\
    \ 33, 1422, 1])\nunique_digits([152, 323, 1422, 10])", "  elements = []\n  x.each\
    \ do |i|\n    is_even = false\n    i.to_s.split('').each do |element|\n      if\
    \ element.to_i % 2 == 0\n        is_even = true\n      end\n    end\n    elements\
    \ << i if is_even == false\n  end\n  elements.sort\nend", "\teven_digits = []\n\
    \tx.each do |i|\n\t\ti = i.to_s.split('')\n\t\ti.each do |j|\n\t\t\tif j.to_i\
    \ % 2 == 0\n\t\t\t\teven_digits << i.join\n\t\t\tend\n\t\tend\n\tend\n\tunique_numbers\
    \ = x - even_digits.map(&:to_i)\n\tunique_numbers.sort\nend", "  x.select { |num|\
    \ (num.to_s.chars.map(&:to_i).map(&:even?)).all?(false) }.sort\nend", "  # TODO:\
    \ implement\nend", "  x.sort!\n  x.select do |n|\n    n.to_s.chars.map(&:to_i).all?\
    \ { |digit| digit.odd? }\n  end\nend", "\tx.select { |i| i.to_s.chars.all? { |j|\
    \ j.to_i.odd? } }.sort\nend", "  x.select { |num| num.to_s.chars.map(&:to_i).select\
    \ { |y| y.even? }.count == 0 }.sort\nend", "\tx.select { |i| i.to_s.length ==\
    \ i.to_s.split('').uniq.length}\nend", "  x.select { |x| x.to_s.chars.all? { |y|\
    \ y.to_i.odd? } }.sort\nend", "  result = []\n  x.each do |num|\n    if num.to_s.split('').map(&:to_i).select\
    \ { |n| n.even? }.length == 0\n      result << num\n    end\n  end\n  result.sort\n\
    end", "  unique_digits = []\n  x.each do |i|\n    unique_digits << i if (i.to_s.split('')\
    \ & ['0', '2', '4', '6', '8']).empty?\n  end\n  unique_digits.sort\nend", "  #\
    \ 1. Get all unique digits\n  # 2. For each unique digit check the number of occurance\n\
    \  # 3. Sort by their number of occurance\n  # 4. Return odd digits", "  @x =\
    \ x\n  @x.each do |i|\n    @i = i.to_s.split('')\n    @x.each do |i|\n      if\
    \ (i % 2) == 0\n        @x.delete(i)\n      end\n    end\n  end\n  @x.sort\nend",
  "    x.select{|n| n.to_s.delete(\"0\") == n.to_s.delete(\"2\").delete(\"4\").delete(\"\
    6\").delete(\"8\")}.sort\nend", "  x.select { |i| i.to_s.each_char.all? { |c|\
    \ c.to_i.odd? } }.sort\nend", "  x.select{|i| i.to_s.scan(/[2468]/).empty?}.sort\n\
    end", "  x.select { |i| !i.to_s.chars.any? { |n| n.to_i.even? } }.sort\nend",
  "  #selects all elements of array x that are not divisible by 2 and sorts them\n\
    \  x.select {|number| number % 2 != 0}.sort\nend", "  i = 0\n  result = []\n \
    \ loop do\n    break if i == x.length\n    result << x[i] if x[i].to_s.delete('0-9').length\
    \ == x[i].to_s.length\n    i += 1\n  end\n  result.sort\nend", end, "  x.delete_if\
    \ { |i| i.to_s.include?(\"2\") || i.to_s.include?(\"4\") || i.to_s.include?(\"\
    6\") || i.to_s.include?(\"8\") }.sort\nend", "  (1..9).to_a\nend", "  # Your Code\
    \ Here\nend", "    no_even_digits = []\n    odd_digits = ['1', '3', '5', '7',\
    \ '9']\n    x.each do |n|\n        no_even_digits << n.to_s.split('')\n    end\n\
    \    no_even_digits.delete_if { |arr| !arr.all? { |num| odd_digits.include?(num)\
    \ }}\n    no_even_digits.each do |arr|\n        arr.map! { |x| x.to_i }\n    end\n\
    \    no_even_digits.flatten.sort\nend", "  # TODO\nend", "  # x.inject([]) { |r,\
    \ n| n.to_s.each_char.map(&:to_i).all?(&:odd?) ? r << n : r }.sort\n  # x.select\
    \ { |n| n.to_s.each_char.map(&:to_i).all?(&:odd?) }.sort\n  x.select { |n| n.to_s.each_char.any?(&:odd?)\
    \ }.sort\nend", "    x.select { |i| i.to_s.match(/[02468]/).nil? }.sort\nend",
  "    array = []\n    x.each do |i|\n        # check if string has even digit\n \
    \       even_num = i.to_s.split('').any? { |num| num.to_i.even? }\n        array\
    \ << i if even_num == false\n    end\n    return array.sort\nend", "\tp x.select\
    \ {|num| num.to_s.chars.all? {|i| i.to_i.odd?}}.sort\nend\nunique_digits([152,\
    \ 323, 1422, 10])\nunique_digits([15, 33, 1422, 1])", "\tx.delete_if{|num| num.to_s.split('').join.match(/[02468]/)}\n\
    end", "  x.keep_if{|i| i.to_s.split('').map(&:to_i).all?{|j| j.odd?}}.sort\nend",
  "    # Your solution here\nend", "    x.select{|x| x.to_s.chars.all?{|y| y.to_i.odd?}}.sort\n\
    end", "  x.select { |y| y.to_s.split('').map(&:to_i).select(&:even?).empty? }.sort\n\
    end", "  x.delete_if{|i| i.to_s.chars.any? {|j| j.to_i.even?}}.sort\nend", " \
    \ x.select{|e| !e.to_s.match(/[2468]/)}.sort\nend\nputs \"Testing for unique_digits([15,\
    \ 33, 1422, 1])\"\nputs unique_digits([15, 33, 1422, 1]) == [1, 15, 33]\nputs\
    \ \"Testing for unique_digits([152, 323, 1422, 10])\"\nputs unique_digits([152,\
    \ 323, 1422, 10]) == []", "  x.reject{|num| num.to_s.scan(/[02468]/).count > 0}.sort\n\
    end", "  x.select { |i| i.to_s.match(/[02468]/).nil? }.sort\nend", "  (x.to_s.chars.map(&:to_i)\
    \ - [0,2,4,6,8]).sort\nend", "    array = x.select { |n| n.to_s.match(/[24680]/).nil?\
    \ }\n    array.sort\nend", "  x.select{|n| n.to_s.split('').uniq.length == n.to_s.length}.sort\n\
    end", "  x.each_with_object([]) do |element, results|\n    results << element\
    \ if unique_digit?(element)\n  end.sort\nend", "  #@TODO: implement me\nend",
  "  x.select { |num| !num.to_s.match(/\\d*[24680]\\d*/) }.sort\nend", "  x.select\
    \ { |n| n.to_s.split('').all? { |c| c.to_i.odd? } }.sort\nend", "  #x.map! { |num|\
    \ num.to_s.split('') }\n  #x.delete_if { |num| num.any? { |digit| digit.to_i.even?\
    \ } }\n  #x.map! { |num| num.join('').to_i }\n  #x.sort!\nend", "  x.each_with_object([])\
    \ do |n, r|\n    r << n unless n.to_s.include?('2') || n.to_s.include?('4') ||\n\
    \                n.to_s.include?('6') || n.to_s.include?('8')\n  end.sort\nend",
  "    # Your code here\nend", "  x.select { |i| i.to_s.each_char.all? { |c| c.to_i.odd?\
    \ } }.sort\nend", "  # your code here\nend", "  x.each do |i|\n    if i.digits.any?\
    \ { |d| d.even? }\n      x.delete(i)\n    end\n  end\n  x.sort\nend", "  x.select{|i|\
    \ i.to_s.split('').map(&:to_i).all?{|i| i.odd?}}.sort\nend", "  x.sort.uniq.select\
    \ { |n| n.to_s.split('').all? { |num| num.to_i.odd? } }\nend", "  (x.select {\
    \ |i| i.to_s.chars.all?(&:to_i.method(:odd?)) }).sort!\nend", "  x.select { |i|\
    \ i.to_s.split('').each { |j| j.to_i.odd? }.size == i.to_s.size }.sort\nend",
  end, "\tx.select { |num| num.to_s.scan(/\\d*[13579]\\d*/).join(\"\") == num.to_s\
    \ }.sort\nend", "  x.select { |i| i.to_s.match(/\\d*[02468]\\d*/).nil? }.sort\n\
    end", "  x.select { |num| num.to_s.split('').uniq.join.to_i % 2 != 0 }.sort\n\
    end", "  x.select { |x| /.*[13579]$/.match(x.to_s) }.sort\nend", "  x.select {\
    \ |e| e.to_s.chars.all? { |d| d.to_i.odd? } }.sort\nend", "  x.select { |element|\
    \ element.to_s.split('').map(&:to_i).select(&:even?).size == 0 }.sort\nend", " \
    \ x.select { |i| i.to_s.split('').none? { |i| i.to_i.even? } }.sort\nend", "\t\
    arr=[]\n\tx.each do |num|\n\t\tif num.to_s.split('').each{|y| break if y.to_i%2==0;return\
    \ nil}.nil? \n\t\t\tarr.push(num)\n\t\tend\n\tend\n\tarr.sort\nend", "\t# TODO:\
    \ Implement me\nend", "  x.sort.select{|i|i.to_s.split('').none?{|j| j.to_i.even?}}\n\
    end\nputs unique_digits([15, 33, 1422, 1])\nputs unique_digits([152, 323, 1422,\
    \ 10])\nputs unique_digits([15, 33, 1421, 1])", "  even_digits = %w(0 2 4 6 8)\n\
    \  x.select { |i| i.to_s.split('').all? { |j| !even_digits.include?(j) } }.sort\n\
    end", "  result = []\n  x.each do |num|\n    result << num if num.to_s.each_char.none?\
    \ { |d| d.to_i.even? }\n  end\n  result.sort\nend", "  # write your code here\n\
    end", "  x.sort.reject do |i|\n    i.to_s.scan(/\\d/).any? { |a| a.to_i.even?\
    \ }\n  end\nend", "  x.select{|i| i.to_s.chars.map(&:to_i).all?{|x| x.odd?}}.sort\n\
    end", "  x.select { |num| num.digits.all?(&:odd?) }.sort\nend", "    x.select\
    \ { |e| e.to_s.split('').map(&:to_i).all? { |e| e.odd? } }.sort\nend", "  x.select\
    \ { |i| i.to_s.split('').all? { |c| c.to_i.odd? } }.sort\nend", "  # x.select\
    \ { |num| num.to_s.split('').all? { |el| el.to_i.odd? } }.sort\n  # ^^ This works,\
    \ but the following is better\n  x.select { |num| num.to_s.split('').none? { |el|\
    \ el.to_i.even? } }.sort\nend", "  x.select { |item| item.to_s.split('').select\
    \ { |digit| digit.to_i.even? }.count.zero? }.sort\nend", "  array = []\n  x.each\
    \ do |n|\n    n = n.to_s.split('')\n    n.each do |n|\n      if n.to_i.even?\n\
    \        array << x\n      end\n    end\n  end\n  p array\nend", "  # Your code\
    \ here\nend", "\treturn x.to_s.each_char.sort.select{|i| i.to_i.odd?}\nend", " \
    \ x.map { |y| y.digits.all?(&:odd?) ? y : nil }.compact.sort\nend", "  new_arr\
    \ = x.select do |num|\n    unique_digits?(num)\n  end\n  new_arr.sort\nend", " \
    \ x.select { |int| int.to_s.chars.all? { |char| char.to_i.odd? } }.sort\nend",
  end, "\nend", "  x.select { |x| x.digits.all?(&:odd?) }.sort\nend", "  x.reject{|i|\
    \ i.to_s.match(/[24680]/)}.sort\nend", "  x.select { |val| val.to_s.chars.all?\
    \ { |digit| digit.to_i.odd? } }.sort\nend", "  x.select{|n| n.to_s.chars.any?{|d|\
    \ d.to_i.odd?}}.sort\nend", "    x.sort!\n    new_array = []\n    x.each do |i|\n\
    \        if i.to_s.split('').none? {|n| n.to_i % 2 == 0}\n            new_array\
    \ << i\n        end\n    end\n    new_array\nend", "  x.delete_if { |i| i.to_s.split('').any?\
    \ { |j| j.to_i.even? } }.sort\nend", "  x.select{|val| has_even_digit?(val) ==\
    \ false}.sort\nend", "\nend", "\nend", "    x.each_with_object([]) { |i, arr|\
    \ arr << i if (i.to_s =~ /[02468]/).nil? }.sort\nend", "  return [] if x.nil?\n\
    \  return [] if x.length == 0\n  even_digits = (0..9).to_a.select { |n| n.even?\
    \ }\n  x.select { |n| n.to_s.split('').map(&:to_i).none? { |i| even_digits.include?(i)\
    \ } }.sort\nend", "\tunique_digits = x.find_all { |i| !i.to_s.match(/\\d*[0,2,4,6,8]\\\
    d*/) }\n\treturn unique_digits.sort\nend", "\tx.select { |num| num.digits.count(&:even?)\
    \ == 0 }.sort\nend", "  x.select { |e| e.to_s.match(/\\d*[13579]\\d*/) }.sort\n\
    end", "    x.select{|y| y.to_s.split('').all?{|z| z.to_i.odd?}}.sort\nend", "\t\
    # your code here\nend", "  x.select { |i| i.to_s.split('').all? { |e| e.to_i.odd?\
    \ } }.sort\nend", "  x.delete_if { |num| num.to_s.include?(\"2\") || num.to_s.include?(\"\
    4\") || num.to_s.include?(\"6\") || num.to_s.include?(\"8\") }.sort\nend", " \
    \ x.select { |i| i.to_s.split('').map(&:to_i).none?(&:even?) }.sort\nend", " \
    \ x.select { |num| num.to_s.scan(/\\d/).map(&:to_i).all?(&:odd?) }.sort\nend",
  "\tx.select{|num| num.to_s.chars.all?{|i| i.to_i.odd?}}.sort\nend", "  x.reject\
    \ { |num| num.to_s.split('').any? { |n| n.to_i.even? } }.sort\nend", "  # Your\
    \ Code Here\nend", "  x.sort.select { |n| n.to_s.chars.all? { |c| c.to_i.odd?\
    \ } }\nend", "  x.select { |n| n.to_s.each_char.none? { |char| char.to_i.even?\
    \ } }.sort\nend", "  x.select{|i| i.to_s.split('').all?{|n| n.to_i.odd?}}.sort\n\
    end", "  final_arr = []\n  for i in 0..x.length-1\n    if x[i].to_s.include?(\"\
    2\") || x[i].to_s.include?(\"4\") || x[i].to_s.include?(\"6\") || x[i].to_s.include?(\"\
    8\") || x[i].to_s.include?(\"0\")\n      x[i] = -1\n    end\n  end\n  for i in\
    \ 0..x.length-1\n    if x[i] != -1\n      final_arr.push(x[i])\n    end\n  end\n\
    \  final_arr.sort!\nend", "  a=[]\n  x.each {|v| v.to_s.match(/[02468]/) ? ''\
    \ : a << v}\n  a.sort\nend", "\tx.map{|y| y.to_s.split('').map(&:to_i).map{|z|\
    \ z.even? ? y : \"even\"}.delete_if{|w| w == \"even\"}.reduce(:+)}.delete_if{|v|\
    \ v == nil}.sort\nend\np unique_digits([152, 323, 1422, 10])", "  x.select { |e|\
    \ e.to_s.chars.map(&:to_i).all?(&:odd?) }.sort\nend", "  arr = []\n  x.each do\
    \ |i|\n    if i.to_s.split('').map(&:to_i).all? { |a| a.odd? }\n      arr << i\n\
    \    end\n  end\n  arr.sort\nend", end, "    x.find_all { |y| y.to_s.split('').all?\
    \ { |z| z.to_i.odd? } }.sort\nend", "  x.select { |n| n.to_s.chars.map(&:to_i).all?(&:odd?)\
    \ }.sort\nend", "  x.reject{|i| i.to_s.chars.map(&:to_i).any?(&:even?)}.sort\n\
    end", "  x.select { |n| n.to_s.chars.none? { |c| c.to_i.even? } }.sort\nend",
  "  x.map { |i| i.to_s.chars.uniq }.select do |a|\n    a.none? { |i| i.to_i.even?\
    \ }\n  end.map(&:join).sort.map(&:to_i)\nend", "  x.select { |num| num.to_s.each_char.all?\
    \ { |digit| digit.to_i.odd? } }.sort\nend", "  x.select { |y| y.to_s.split('').none?\
    \ { |z| z.to_i.even? } }.sort\nend", "  x.delete_if { |num| num.to_s.split('').any?\
    \ { |num| num.to_i.even? } }.sort\nend", "  # Begin\n    x.select { |e| e.to_s.chars.all?\
    \ { |i| i.to_i.odd? } }.sort\n  # End\nend", "  x.select { |i| i.to_s.scan(/[02468]/).empty?\
    \ }.sort\nend", "  x.select { |num| num.to_s.chars.none? { |char| char.to_i.even?\
    \ } }.sort\nend", "  even_digits = { 0 => true, 2 => true, 4 => true, 6 => true,\
    \ 8 => true }\n  only_odd_digits = x.select do |num|\n    num.to_s.chars.all?\
    \ { |char| !even_digits[char.to_i] }\n  end\n  only_odd_digits.sort\nend", " \
    \ #Replace with your code\nend", "  x.select { |num| num.to_s.split('').all? {\
    \ |n| n.to_i.odd? } }.sort\nend", "  # TODO: Implement this\nend", "  x.reject\
    \ { |num| num.to_s.split('').any? { |d| d.to_i.even? } }.sort\nend", end, "  #\
    \ write your code here\nend", "  x.select { |i| i.to_s.split('').all?(&:to_i.odd?)\
    \ }.sort\nend", "  result = []\n  x.each do |y|\n    if y.to_s.split('').map {\
    \ |x| x.to_i }.select { |x| x.even? }.empty?\n      result << y\n    end\n  end\n\
    \  result.sort\nend", "    number = x.select { |e| e.to_s.chars.map(&:to_i).all?\
    \ { |e| e.odd?} }\n    number.sort\nend", "  x.sort.reject { |n| n.to_s.match(/[02468]/)\
    \ }\nend", "  # TODO\nend", "  x.select{|i| i.to_s.split('').all?{|i| i.to_i.odd?}}.sort\n\
    end", "  # Write your code here!\nend", "\t# Your code here\nend", "\t\n\tx.select\
    \ do |i| \n\t\ti.to_s.chars.to_a.all? { |i| i.to_i.odd? }\n\tend.sort", "  x.select{|n|\
    \ n.to_s.scan(/\\d*/).flatten.none?{|z| z.to_i.even?}}.sort\nend", "  x.select\
    \ { |y| y.to_s.chars.all? { |z| z.to_i.odd? } }.sort\nend", end, "    x.select\
    \ { |n| n.to_s.each_char.all? { |n| n.to_i.odd? } }.sort\nend", "  x.select {\
    \ |number| number.to_s.each_char.all? { |digit| digit.to_i.odd? } }.sort\nend",
  "  x.select{|n| !n.to_s.match(/[24680]/)}.sort\nend", "\tresult = []\n\tx.each do\
    \ |num|\n\t\tresult << num if (num.to_s.chars.map(&:to_i).select { |x| x.even?\
    \ }).empty?\n\tend\n\tresult.sort\nend", "  x.select { |i| no_even_digits?(i)\
    \ }.sort\nend", "  x.select{|i| i.to_s.chars.select{|j| j.to_i.even?}.count ==\
    \ 0}.sort\nend", "  x.select { |n| !n.to_s.split('').any?(&:even?) }.sort\nend",
  "\tx.select { |num| num.to_s.match(/\\d*[13579]\\d*/) }.sort\nend", "  # x.select{|y|\
    \ y.to_s.chars.map(&:to_i).map(&:odd?).all? }.sort\n  x.select { |y| y.to_s.chars.map(&:to_i).all?(&:odd?)\
    \ }.sort\nend", "\tx.select{|a| (a.to_s.split('').select{|d| d.to_i.even?}).empty?}.sort\n\
    end", "  x.select { |i| i.to_s.chars.all? { |c| c.to_i.odd? } }.sort\nend", "\t\
    x.each do |n|\n\t\ts = n.to_s\n\t\ty = s.scan(/[02468]/)\n\t\tx.delete(n) if y.any?\n\
    \tend\n\treturn x.sort\nend", "  sorted_numbers = x.sort_by { |num| num.to_s.length\
    \ }\n  numbers_without_even_digits = []\n  sorted_numbers.each do |num|\n    num_digits\
    \ = num.to_s.split('')\n    is_num_without_even_digits = true\n    num_digits.each\
    \ do |digit|\n      if digit.to_i.even?\n        is_num_without_even_digits =\
    \ false\n        break\n      end\n    end\n    numbers_without_even_digits <<\
    \ num if is_num_without_even_digits\n  end\n  numbers_without_even_digits\nend",
  "\nend", "\tx.sort.select { |num| num.to_s.split('').all? { |num_char| num_char.to_i.odd?\
    \ } }\nend", "  x.select { |e| e.to_s.chars.all?(&:to_i.method(:odd?)) }.sort\n\
    end", "  x.select{|n| n.to_s.chars.all?{|c| c.to_i.odd?}}.sort\nend", "\tresult\
    \ = []\n\tx.each do |num|\n\t\tresult << num if num.to_s.chars.all? { |c| c.to_i.odd?\
    \ }\n\tend\n\tresult.sort\nend", "  unique_numbers = x.select do |number|\n  \
    \  number.to_s.each_char.all? { |char| char.to_i.odd? }\n  end\n  unique_numbers.sort\n\
    end", "  x.select { |i| i.to_s.chars.map(&:to_i).all? { |i| i.odd? } }.sort\n\
    end", "    x.select { |a| a.to_s.split('').each { |b| b.to_i.odd? } }.sort\nend",
  "\t# easy way with built in functions\n\t#x.reject { |number| (number.to_s.split('')\
    \ & (0..9).to_a.even?).any? }.sort", "  x.select{|item| item.to_s.delete('02468').size\
    \ == item.to_s.size}.sort\nend\nputs \"unique_digits([15, 33, 1422, 1]) == [1,\
    \ 15, 33] (output from above): #{unique_digits([15, 33, 1422, 1]) == [1, 15, 33]}\"\
    \nputs \"unique_digits([152, 323, 1422, 10]) == [] (output from above): #{unique_digits([152,\
    \ 323, 1422, 10]) == []}\"", end, "  x.select { |x| x.to_s.split('').all? { |i|\
    \ i.to_i.odd? } }.sort\nend", "  arr = []\n  x.each do |val|\n    val.to_s.split('').each\
    \ do |v|\n      if v.to_i % 2 == 0\n        arr << val\n        break\n      end\n\
    \    end\n  end\n  return x - arr\nend", "  x.select { |n| n.to_s.chars.map(&:to_i).select(&:even?).empty?\
    \ }.sort\nend", "  x.select { |num| num.to_s.split('').select { |y| y.to_i.even?\
    \ }.size == 0 }.sort\nend", "  unique_numbers = []\n  numbers = x.sort\n  numbers.each\
    \ do |number|\n    if number.to_s.split('').select { |digit| digit.to_i.even?\
    \ }.empty?\n      unique_numbers << number\n    end\n  end\n  return unique_numbers\n\
    end", "  x.select { |a| !a.to_s.split('').any? { |b| b.to_i.even? } }.sort\nend",
  "  x.reject{|y| y.to_s.chars.any?{|z| z.to_i.even?}}.sort\nend", "  x.each_with_object([])\
    \ do |num, arr|\n    arr << num if num.to_s.split('').map(&:to_i).all?(&:odd?)\n\
    \  end.sort\nend", "\tx.select { |n| n.to_s.chars.all? { |c| c.to_i.odd? } }.sort\n\
    end", "  # TODO: Implement this method.\nend", end, "  x.select { |n| n.to_s.chars.all?\
    \ { |n| n.to_i.odd? } }.sort\nend", "  # your code here\nend", "  x.select { |i|\
    \ i.to_s.chars.map(&:to_i).all? { |i| i.odd? } }.sort\nend", "  x.delete_if {\
    \ |int| int.to_s.match(/\\d*[02468]\\d*/) }.sort\nend", "\nend", "    x.reject\
    \ { |num| num.to_s.split('').any? { |digit| digit.to_i.even? } }.sort\nend", "\n\
    end", "  x.select{|el| el.to_s.split('').all?{|i| i.to_i.odd?}}.sort\nend", "\t\
    # Rewrite the code below.\n\tresult = []\n\tx.each do |i|\n\t\tj = i.to_s.chars.map(&:to_i)\n\
    \t\tif j.include?(2) || j.include?(4) || j.include?(6) || j.include?(8)\n\t\t\t\
    result << i\n\t\tend\n\tend\n\tresult\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
