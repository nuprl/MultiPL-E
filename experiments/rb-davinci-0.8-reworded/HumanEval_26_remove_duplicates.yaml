name: HumanEval_26_remove_duplicates
language: rb
prompt: "# From an array of integers, remove all elements that occur more than once.\n\
  # Keep order of elements left the same as in the input.\n# >>> remove_duplicates.call([1,\
  \ 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n\
  \    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1,\
  \ 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"
completions: ["  #TODO: implement the method\n  (numbers & numbers).sort\nend", " \
    \ numbers.uniq\nend", "  numbers.select.with_index { |element, index| numbers.index(element)\
    \ == index }\nend", "  numbers.uniq\nend", "  x = numbers.uniq\n  return x\nend",
  "  numbers.uniq\nend", "  numbers.uniq\nend", "  numbers.uniq\nend", "  numbers.uniq\n\
    end", "  numbers.uniq\nend", "  numbers.uniq\nend", "  uniq = []\n  numbers.each\
    \ do |number|\n    uniq << number unless uniq.include?(number)\n  end\n  uniq\n\
    end", "    return numbers.reject { |x| numbers.count(x) > 1 }\nend", "  # TODO:\
    \ Write me\n  output = []\n  numbers.each do |n|\n    output << n unless output.include?(n)\n\
    \  end\n  output\nend", "  numbers.uniq\nend", "  numbers.find_all { |e| numbers.count(e)\
    \ == 1 }\nend", "  numbers.to_a.uniq\nend", "  numbers.uniq\nend", "    numbers.uniq\n\
    end", "  arr = []\n  numbers.each do |n|\n    if arr.include?(n)\n      arr.delete(n)\n\
    \    else\n      arr << n\n    end\n  end\n  arr\nend", "  arr = []\n  numbers.each\
    \ do |number|\n    arr << number unless arr.include?(number)\n  end\n  arr\nend",
  "  numbers.find_all { |e| numbers.count(e) == 1 }\nend", "  numbers.uniq\nend",
  "  seen = Hash.new(0)\n  numbers.inject([]) do |result, elem|\n    if seen[elem]\
    \ == 0\n      seen[elem] += 1\n      result << elem\n    end\n    result\n  end\n\
    end", "  numbers.select { |x| numbers.count(x) == 1 }\nend", "  # Do your work\
    \ here.\nend", "  result = []\n  numbers.each do |num|\n    result << num unless\
    \ result.include?(num)\n  end\n  result\nend", "  numbers.uniq\nend", "  # TODO:\
    \ implement me\n  numbers.uniq\nend", "  numbers.uniq\nend", "  unique_numbers\
    \ = []\n  numbers.each do |num|\n    unique_numbers << num unless unique_numbers.include?(num)\n\
    \  end\n  unique_numbers\nend", "  numbers.reverse.uniq.reverse\nend", "    unique_numbers\
    \ = []\n    numbers.each do |n|\n        unique_numbers << n unless unique_numbers.include?(n)\n\
    \    end\n    unique_numbers\nend", "  numbers & numbers\nend", "  # Your code\
    \ here\nend", "  numbers.select.with_index do |number, index|\n    numbers.index(number)\
    \ == index\n  end\nend", "  result = []\n  numbers.each do |number|\n    result\
    \ << number unless result.include?(number)\n  end\n  result\nend", "  numbers.reject\
    \ { |number| numbers.count(number) > 1 }\nend", "\tnumbers.uniq\nend", "  # TODO\n\
    end", "\tnumbers.uniq\nend", "  counter = Hash.new(0)\n  numbers.each do |num|\n\
    \    counter[num] += 1\n  end\n  counter.each_key.select { |key| counter[key]\
    \ == 1 }\nend", "  # You are free to implement this method\nend", "  @new_array\
    \ = []\n  @new_array = numbers.uniq!\n  puts @new_array\nend", "  #TODO: implement\n\
    \  numbers.uniq\nend", "  numbers.select{|i| numbers.count(i)==1}\nend", "  #\
    \ your code goes here\nend", "  numbers.each_with_object([]) do |e, r|\n    r\
    \ << e unless r.include?(e)\n  end\nend", "  result = []\n  numbers.each do |number|\n\
    \    result << number unless result.include?(number)\n  end\n  result\nend", " \
    \ if numbers == []\n    return []\n  end\n  counted = numbers.inject(Hash.new(0))\
    \ { |total, e| total[e] += 1 ;total}\n  counted.select {|k,v| v == 1}.keys\nend",
  "  numbers.uniq\nend", "  numbers.select.with_index { |x, i| numbers.index(x) ==\
    \ i }\nend", "  numbers.uniq\nend", "  numbers & numbers\nend", "\t# do not need\
    \ additional array to store\n\t# the new set of duplicates\n\tunique_numbers =\
    \ []\n\tnumbers.each do |number|\n\t\tif unique_numbers.include?(number)\n\t\t\
    \tunique_numbers.delete(number)\n\t\telse\n\t\t\tunique_numbers << number\n\t\t\
    end\n\tend\n\treturn unique_numbers\nend", "  unique_numbers = []\n  numbers.each\
    \ do |number|\n    unique_numbers << number unless unique_numbers.include?(number)\n\
    \  end\n  unique_numbers\nend\nputs remove_duplicates([1, 2, 3, 2, 4])", "  numbers.uniq\n\
    end", "  numbers.reject { |number| numbers.count(number) > 1 }\nend", "  number_count\
    \ = Hash.new(0)\n  numbers.each { |n| number_count[n] += 1 }\n  numbers.delete_if\
    \ { |n| number_count[n] > 1 }\nend", "  numbers.select.with_index { |number, index|\
    \ numbers.index(number) == index }\nend", "  numbers.uniq\nend", "  # I want to\
    \ keep track of the numbers that are in the array.  A Hash is\n  # perfect for\
    \ this because keys are unique.\n  #\n  # The values don't actually matter.  We\
    \ don't care how many times the\n  # number appears.  We just need a quick lookup\
    \ to determine if a number is\n  # already in the Hash.\n  counts = {}", "  numbers.select\
    \ { |num| numbers.count(num) == 1 }\nend", "  # numbers.uniq.each do |num|\n \
    \ #   if numbers.count(num) > 1\n  #     numbers.delete(num)\n  #   end\n  # end\n\
    \  # numbers\n  numbers.uniq\nend", "  numbers.uniq\nend", "  numbers.uniq\nend",
  "  number_count = {}\n  results = []\n  numbers.each do |number|\n    number_count[number]\
    \ = 0 unless number_count[number]\n    number_count[number] += 1\n  end\n  number_count.each\
    \ do |number, count|\n    results << number if count == 1\n  end\n  results\n\
    end", "  h = {}\n  results = []\n  numbers.each do |num|\n    h[num] ||= 0\n \
    \   h[num] += 1\n  end\n  h.each do |k, v|\n    results << k if v == 1\n  end\n\
    \  results\nend", "  numbers.select { |num| numbers.count(num) == 1 }\nend", " \
    \ # duplicates = []\n  # numbers.each do |number|\n  #   if numbers.count(number)\
    \ > 1\n  #     duplicates << number\n  #   end\n  # end\n  # duplicates.uniq!\n\
    \  # numbers - duplicates\n  uniq = []\n  numbers.each do |number|\n    uniq <<\
    \ number unless uniq.include?(number)\n  end\n  uniq\nend", "  numbers.uniq\n\
    end", "  numbers.inject([]) { |dupes, value| dupes.include?(value) ? dupes : dupes\
    \ << value }\nend", "  new_numbers = []\n  numbers.each do |number|\n    if !new_numbers.include?(number)\n\
    \      new_numbers << number\n    end\n  end\n  return new_numbers\nend", "  numbers.uniq\n\
    end", "\tnumbers.select.with_index { |x, i| numbers.index(x) == i }\nend", " \
    \ # Your code goes here\nend", "  # Answer code\nend", "  numbers.delete_if{|x|\
    \ numbers.count(x) > 1}.uniq\nend", "  new_array = []\n  numbers.each do |number|\n\
    \    new_array << number unless new_array.include?(number)\n  end\n  new_array\n\
    end", "  # your solution here\nend", "  numbers & numbers\nend", "  already_seen\
    \ = {}\n  unique_array = []\n  numbers.each do |i|\n    if already_seen[i] ==\
    \ nil\n      already_seen[i] = true\n      unique_array << i\n    end\n  end\n\
    \  return unique_array\nend", "  numbers.uniq\nend", "  unique_numbers = []\n\
    \  duplicates = []\n  numbers.each do |number|\n    if unique_numbers.include?(number)\n\
    \      duplicates << number\n    else\n      unique_numbers << number\n    end\n\
    \  end\n  unique_numbers - duplicates\nend", "  numbers.reverse.uniq.reverse\n\
    end", "  # numbers.uniq\n  num_occ = {}\n  numbers.each do |n|\n    if num_occ[n]\n\
    \      num_occ[n] += 1\n    else\n      num_occ[n] = 1\n    end\n  end\n  result\
    \ = []\n  num_occ.each do |k, v|\n    if v == 1\n      result << k\n    end\n\
    \  end\n  result\nend", "  numbers.uniq\nend", "  numbers.to_a.uniq\nend", " \
    \ numbers.find_all{|x| numbers.count(x) == 1}\nend", "  numbers.uniq\nend", " \
    \ numbers.uniq\nend", "  numbers.chunk(&:itself).select { |_, chunk| chunk.length\
    \ == 1 }.map(&:first)\nend", "  result = []\n  numbers.each do |n|\n    result\
    \ << n unless result.include?(n)\n  end\n  result\nend", "  numbers.group_by {\
    \ |element| element }.reject { |_, v| v.length > 1 }.keys\nend", "  new_array\
    \ = []\n  numbers.each { |i| new_array << i unless new_array.include?(i) }\n \
    \ new_array\nend\np remove_duplicates([1, 2, 3, 2, 4])", "  result = numbers.uniq\n\
    \  p result\nend", "  numbers.uniq\nend", "  # your solution here\nend", "  numbers.find_all\
    \ { |n| numbers.count(n) == 1 }\nend", "  output = []\n  numbers.each do |num|\n\
    \    output << num unless output.include?(num)\n  end\n  output\nend", "  numbers.uniq\n\
    end", "  numbers.select { |number| numbers.count(number) == 1 }\nend", "  numbers.uniq\n\
    end", "  numbers.uniq\nend", "  numbers.reject { |number| numbers.count(number)\
    \ > 1 }\nend", "  numbers.each_with_object(Hash.new(0)) { |key, result| result[key]\
    \ += 1 }.select { |key, value| value == 1 }.keys\nend", "  # your code here\n\
    end", "  numbers.uniq\nend", "  numbers.select.with_index { |number, index| numbers.index(number)\
    \ == index }\nend", "  # TODO: implement this\nend", "  numbers.find_all { |n|\
    \ numbers.count(n) == 1 }\nend", "  numbers.uniq\nend", "  hashy = {}\n  numbers.each\
    \ do |n|\n    if hashy[n]\n      hashy[n] += 1\n    else\n      hashy[n] = 1\n\
    \    end\n  end\n  hashy.select { |k, v| v == 1 }.keys\nend", "  numbers.uniq\n\
    end", "  numbers.select.with_index do |number, index|\n    numbers.index(number)\
    \ == index\n  end\nend", "  unique_array = []\n  numbers.each do |n|\n    unique_array\
    \ << n unless unique_array.include?(n)\n  end\n  unique_array\nend", "  uniq_numbers\
    \ = []\n  numbers.each do |num|\n    uniq_numbers << num unless uniq_numbers.include?(num)\n\
    \  end\n  uniq_numbers\nend", "  numbers.uniq\nend", "  numbers.uniq\nend", " \
    \ numbers.uniq\nend", "  numbers.uniq\nend", "  unique_elements = []\n  numbers.each\
    \ do |n|\n    unique_elements << n unless unique_elements.include?(n)\n  end\n\
    \  unique_elements\nend", "  numbers.uniq\nend", "  numbers.select { |num| numbers.count(num)\
    \ == 1 }\nend", "  numbers.to_enum.with_object([]) do |number, result|\n    result\
    \ << number unless result.include?(number)\n  end\nend", "  numbers.uniq\nend",
  "  numbers.uniq\nend", "  result = []\n  previous = nil\n  numbers.each do |number|\n\
    \    result << number unless previous == number\n    previous = number\n  end\n\
    \  result\nend", "  numbers.inject({}) { |h, v| h[v] = (h[v] || 0) + 1; h }.delete_if\
    \ { |_, v| v > 1 }.keys\nend", "  numbers.select.with_index { |num, i| numbers.index(num)\
    \ == i }\nend", "  uniq_numbers = []\n  numbers.each do |number|\n    if uniq_numbers.include?(number)\n\
    \      uniq_numbers.delete(number)\n    else\n      uniq_numbers << number\n \
    \   end\n  end\n  return uniq_numbers\nend", "  numbers.group_by{|i| i}.select{|k,v|\
    \ v.size == 1}.keys\nend", "  numbers.uniq\nend", "  numbers.uniq\nend", "  numbers.uniq\n\
    end", "  numbers.select { |number| numbers.count(number) == 1 }\nend", "\treturn\
    \ numbers.uniq\nend", "    result = []\n    numbers.each do |num|\n        result\
    \ << num unless result.include?(num)\n    end\n    result\nend", "  numbers.uniq\n\
    end", "  a = numbers.reverse.uniq\n  a.reverse\nend", "  numbers.uniq\nend", " \
    \ numbers.uniq\nend", "    numbers.select { |n| numbers.count(n) == 1 }\nend",
  "  uniqueness = {}\n  numbers.each do |num|\n    uniqueness[num] = 0\n  end\n  uniqueness.keys\n\
    end", "\tnumbers.uniq\nend", "  numbers.select { |number| numbers.count(number)\
    \ == 1 }\nend", "  numbers.uniq\nend", "  numbers.each_with_object([]) do |number,\
    \ array|\n    array << number unless array.include?(number)\n  end\nend", "  #\
    \ ... your code here ...\nend", "  numbers.find_all{|x| numbers.count(x) == 1}\n\
    end", "  numbers.uniq\nend", "  new_numbers = []\n  numbers.each do |number|\n\
    \    new_numbers << number unless new_numbers.include?(number)\n  end\n  new_numbers\n\
    end", "  # your code here\nend", "  numbers.uniq\nend", "  # Write your code here\n\
    end", "  numbers.uniq\nend", "  numbers.reject{|i| numbers.count(i) > 1 }\nend",
  "  hash = {}\n  numbers.each { |num| hash[num] = 0 }\n  numbers.each { |num| hash[num]\
    \ += 1 }\n  output = []\n  hash.each { |key, value| output << key if value ==\
    \ 1 }\n  output\nend", "  numbers.select { |number| numbers.count(number) == 1\
    \ }\nend", "  numbers.select { |n| numbers.count(n) == 1 }\nend", "  numbers.uniq\n\
    end", "  numbers.uniq\nend", "  numbers.each_with_object(Array.new) do |n, a|\n\
    \    a << n unless a.include?(n)\n  end\nend", "  numbers.uniq\nend", '  return
    numbers if numbers.empty?', "\tnumbers.uniq \nend", "  numbers.each_with_object([])\
    \ do |n, a|\n    a << n unless a.include?(n)\n  end\nend", "  # your code here\n\
    end", "  output = numbers.inject([]) do |array, n|\n    array << n unless array.include?(n)\n\
    \    array\n  end\n  output\nend", "  # count = {}\n  # numbers.each { |n| count[n]\
    \ = numbers.count(n) }\n  # count.delete_if { |k, v| v > 1 }.keys\n  numbers.select.with_index\
    \ { |num, i| numbers.count(num) == 1 }\nend", "  numbers & numbers\nend", "  #\
    \ TODO: implement me!\nend", "  numbers.inject({}) { |memo, num| memo[num] = 0;\
    \ memo }.keys\nend", "  # TODO: implement\nend", "  #\n  # your code here\n  #\n\
    end", "  numbers.select { |num| numbers.count(num) == 1 }\nend", "  numbers.uniq\n\
    end", "  num = []\n  numbers.each do |x|\n    if num.include?(x)\n      num.delete(x)\n\
    \    else\n      num << x\n    end\n  end\n  num\nend", "  # numbers.select {\
    \ |n| numbers.index(n) == numbers.rindex(n) }\n  # numbers.select { |n| numbers.count(n)\
    \ < 2 }\n  # numbers.uniq\n  numbers.uniq.sort\nend", "  # numbers.uniq\n  numbers.inject({})\
    \ { |h, e| h[e] = h[e].to_i + 1; h }.select { |_, v| v == 1 }.keys\nend", "  #\
    \ 1. create a new, empty array to contain the deduped numbers\n  # 2. loop through\
    \ the existing array\n  # 3. add each number to the new array UNLESS the number\
    \ is already in the new array\n  result = []\n  numbers.each do |number|\n   \
    \ if !result.include?(number)\n      result << number\n    end\n  end\n  result\n\
    end", "    numbers.uniq\nend", "  numbers.uniq\nend", "  # TODO: implement this\
    \ with an algorithm of your choice\n  h = Hash.new(0)\n  numbers.each do |x|\n\
    \  \th[x] += 1\n  end\n  h.each {|k,v| \n  \tif v >= 2\n  \t\tnumbers.delete(k)\n\
    \  \tend\n  }\n  numbers\nend", "  numbers.reverse.each do |number|\n    if numbers.count(number)\
    \ > 1\n      numbers.delete(number)\n    end\n  end\n  numbers.reverse\nend",
  "  unique_numbers = numbers.uniq\n  unique_numbers\nend", "  # no need to use fancy\
    \ methods here, just store seen elements and\n  # leave out the rest\n  seen =\
    \ []\n  result = []\n  numbers.each do |number|\n    if seen.include?(number)\n\
    \      next\n    else\n      seen << number\n      result << number\n    end\n\
    \  end\n  result\nend", "  numbers.select.with_index { |n, i| numbers.index(n)\
    \ == i }\nend", "  numbers.uniq\nend", "  numbers.each_with_object([]) do |n,\
    \ arr|\n    arr << n unless arr.include?(n)\n  end\nend", "  arr = numbers.uniq\n\
    \  # numbers.uniq!\n  puts \"arr #{arr}\"\n  # puts \"numbers #{numbers}\"\nend\n\
    remove_duplicates([1, 2, 3, 2, 4])", "  numbers.uniq\nend", "  numbers.uniq\n\
    end", "  # your code here\nend", "  uniq_numbers = []\n  numbers.each do |num|\n\
    \    uniq_numbers << num unless uniq_numbers.include?(num)\n  end\n  uniq_numbers\n\
    end", "  seen = {}\n  numbers.reject { |i| seen[i] ? seen[i] += 1 : seen[i] =\
    \ 1 }\nend", "  numbers.uniq\nend", "  numbers.select.with_index { |num, i| numbers.index(num)\
    \ == i }\nend", "  numbers.uniq\nend", "  unique_numbers = []\n  numbers.each\
    \ do |n|\n    unique_numbers << n unless unique_numbers.include?(n)\n  end\n \
    \ unique_numbers\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
