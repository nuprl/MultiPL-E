name: HumanEval_39_prime_fib
language: rb
prompt: "# prime_fib returns n-th number that is a Fibonacci number and it's also\
  \ prime.\n# >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n\
  # 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n\
  \    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n  \
  \  assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n\
  \    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n\
  \    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n\
  \    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n\
  \    assert_equal(433494437, candidate.call(10))\n  end\nend\n"
completions: ["  arr = [1,1]\n  fib = 2\n  prime = 2\n  while prime < n\n    fib =\
    \ (arr[0] + arr[1])\n    arr[0] = arr[1]\n    arr[1] = fib\n    if prime?(fib)\n\
    \      prime += 1\n    end\n  end\n  return fib\nend", "  raise ArgumentError\
    \ if n < 1\n  prime_fib_helper(n, 0, 1, 2)\nend", "  throw ArgumentError if n\
    \ < 1\n  prime_fib_helper(n, 1, 2, 3)\nend", "  i = 1\n  fibonacci = 0\n  prime_fib\
    \ = 0\n  fib_prime_counter = 0\n  while fib_prime_counter < n\n    fibonacci =\
    \ fibonacci(i)\n    if prime?(fibonacci)\n      prime_fib = fibonacci\n      fib_prime_counter\
    \ += 1\n    end\n    i += 1\n  end\n  return prime_fib\nend", "  i, count = 1,\
    \ 0\n  while count < n\n    fib = fibonacci(i)\n    if is_prime?(fib)\n      puts\
    \ fib\n      count += 1\n    end\n    i += 1\n  end\nend", "  counter = 1\n  current_prime_fib\
    \ = 1\n  current_fib = 1\n  prev_fib = 1\n  while counter < n\n    prev_fib =\
    \ current_fib\n    current_fib = current_prime_fib\n    current_prime_fib = prev_fib\
    \ + current_fib\n    if is_prime?(current_prime_fib)\n      counter += 1\n   \
    \ end\n  end\n  current_prime_fib\nend", "  Prime.each.lazy.select { |p| Fibonacci.is_fib?(p)\
    \ }.take(n).to_a.last\nend", "  return 2 if n == 1\n  return 3 if n == 2\n  i\
    \ = 0\n  fib = [2, 3]\n  num = 5\n  is_prime = true\n  while i <= n\n    while\
    \ is_prime\n      is_prime = false if fib.any? { |x| num % x == 0 }\n      fib\
    \ << num if is_prime\n      num += 2\n    end\n    is_prime = true\n    i += 1\n\
    \  end\n  fib[n - 1]\nend", "  fib_nums = Enumerator.new do |yielder|\n    i1,\
    \ i2 = 1, 1\n    loop do\n      yielder.yield i1\n      i1, i2 = i2, i1 + i2\n\
    \    end\n  end", "    fib_with_block(n) { |n| prime?(n) }\nend", "  fibs = [2,\
    \ 3]\n  (3..Float::INFINITY).each do |i|\n    # Fibonacci number is i-th number.\n\
    \    fib = fibs[i - 2] + fibs[i - 3]\n    # If it's prime, and if it's n-th, we\
    \ can return.\n    return fib if fib.prime? && fibs.size == n\n    fibs << fib\n\
    \  end\nend", "  return 2 if n == 1\n  return 3 if n == 2\n  return 5 if n ==\
    \ 3\n  return 13 if n == 4\n  return 89 if n == 5\n  return 144 if n == 6\n  return\
    \ 233 if n == 7\n  return 377 if n == 8\n  return 610 if n == 9\n  return 987\
    \ if n == 10\n  return 1597 if n == 11\n  return 2584 if n == 12\n  return 4181\
    \ if n == 13\n  return 6765 if n == 14\n  return 10946 if n == 15\n  return 17711\
    \ if n == 16\n  return 28657 if n == 17\n  return 46368 if n == 18\n  return 75025\
    \ if n == 19\n  return 121393 if n == 20\n  return 196418 if n == 21\n  return\
    \ 317811 if n == 22\n  return 514229 if n == 23\n  return 832040 if n == 24\n\
    \  return 1346269 if n == 25\n  return 2178309 if n == 26\n  return 3524578 if\
    \ n == 27\n  return 5702887 if n == 28\n  return 9227465 if n == 29\n  return\
    \ 14930352 if n == 30\n  return 24157817 if n == 31\n  return 39088169 if n ==\
    \ 32\n  return 63245986 if n == 33\n  return 102334155 if n == 34\n  return 165580141\
    \ if n == 35\n  return 267914296 if n == 36\n  return 433494437 if n == 37\n \
    \ return 701408733 if n == 38\n  return 1134903170 if n == 39\n  return 1836311903\
    \ if n == 40\n  return 2971215073 if n == 41\n  return 4807526976 if n == 42\n\
    \  return 7778742049 if n == 43\n  return 12586269025 if n == 44\n  return 20365011074\
    \ if n == 45\n  return 32951280099 if n == 46\n  return 53316291173 if n == 47\n\
    \  return 86267571272 if n == 48\n  return 139583862445 if n == 49\n  return 225851433717\
    \ if n == 50\n  return 365435296162 if n == 51", "  fib = Memo.new do |f,n|\n\
    \    if n <= 2\n      1\n    else\n      f.call(n-1) + f.call(n-2)\n    end\n\
    \  end", "  f = fib_num(n)\n  while f.prime? == false\n    f = fib_num(n)\n  \
    \  n += 1\n  end\n  return f\nend", "  (1..Float::INFINITY).lazy.select { |i|\
    \ Prime.prime?(i) && fib(i) }.first(n).last\nend", "  raise \"Not Implemented\"\
    \nend", "  (1..Float::INFINITY).each_with_index do |fib, i|\n    return fib if\
    \ is_prime?(fib) && i+1 == n\n  end\nend", "  @cache.fetch([:prime_fib, n]) do\n\
    \    # calculate fib[n] and keep it in the cache\n    fib(n)\n    # check if it's\
    \ prime\n    if prime?(fib(n))\n      @cache[[:prime_fib, n]] = fib(n)\n    else\n\
    \      prime_fib(n+1)\n    end\n  end\nend", "  raise ArgumentError, \"n must\
    \ be a positive integer\" unless n.is_a?(Integer) && n > 0\n  memo = {}\n  fib\
    \ = lambda { |k| return memo[k] if memo[k]\n              memo[k] = k < 2 ? k\
    \ : fib.call(k-1) + fib.call(k-2) }\n  k = 0\n  while n > 0\n    k += 1\n    n\
    \ -= 1 if is_prime?(fib.call(k))\n  end\n  fib.call(k)\nend", "    prime_fib =\
    \ Fibber.new\n    while true\n        num = prime_fib.next\n        if is_prime?(num)\n\
    \            n -= 1\n            return num if n == 0\n        end\n    end\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
