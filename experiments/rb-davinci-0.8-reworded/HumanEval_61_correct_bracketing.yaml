name: HumanEval_61_correct_bracketing
language: rb
prompt: "# brackets is a string of \"(\" and \")\".\n# return true if every opening\
  \ bracket has a corresponding closing bracket.\n# >>> correct_bracketing.call(\"\
  (\")\n# false\n# >>> correct_bracketing.call(\"()\")\n# true\n# >>> correct_bracketing.call(\"\
  (()())\")\n# true\n# >>> correct_bracketing.call(\")(()\")\n# false\ndef correct_bracketing(brackets)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n\
  \    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"\
  ()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true,\
  \ candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"\
  ))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false,\
  \ candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n  \
  \  assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\"\
  )\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false,\
  \ candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"\
  ()()(()())()))()\"))\n  end\nend\n"
completions: ["  #array to keep brackets\n  array = []\n  #check to see if the number\
    \ of brackets is even\n  if brackets.length.even?\n    #add brackets to the array\n\
    \    brackets.split(\"\").each do |bracket|\n      array << bracket\n    end\n\
    \    #delete the closing bracket if it is the first bracket\n    if array[0] ==\
    \ \")\"\n      array.delete_at(0)\n    end\n    #delete the opening bracket if\
    \ it is the last bracket\n    if array[-1] == \"(\"\n      array.delete_at(-1)\n\
    \    end\n    #delete brackets if there is an open and close in a row\n    (array.length\
    \ - 1).times do |n|\n      if array[n] == \"(\" && array[n + 1] == \")\"\n   \
    \     array.delete_at(n)\n        array.delete_at(n)\n      end\n    end\n   \
    \ #return true if array is empty\n    if array.empty?\n      return true\n   \
    \ else\n      return false\n    end\n  else\n    return false\n  end\nend", " \
    \ stack = []\n  brackets.each_char do |x|\n    if x == \"(\"\n      stack.push\
    \ x\n    elsif x == \")\"\n      stack.pop\n    end\n  end\n  stack.empty?\nend",
  "  brackets.chars.reduce(0) do |res, x|\n    if x == '('\n      res += 1\n    elsif\
    \ x == ')'\n      res -= 1\n    end\n    if res < 0\n      return false\n    end\n\
    \    res\n  end.zero?\nend", "  stack = []\n  brackets.each_char do |ch|\n   \
    \ if ch == '('\n      stack.push ch\n    elsif ch == ')'\n      return false if\
    \ stack.empty?\n      stack.pop\n    end\n  end\n  stack.empty?\nend", "  # YOUR\
    \ CODE HERE\nend", "  return false if brackets[0] == \")\"\n  return false if\
    \ brackets[-1] == \"(\"\n  return false if brackets.length.odd?\n  count = 0\n\
    \  brackets.each_char do |ch|\n    count += 1 if ch == \"(\"\n    count -= 1 if\
    \ ch == \")\"\n    return false if count < 0\n  end\n  count == 0\nend", "  stack\
    \ = []\n  bracket_map = {\n    ')' => '(',\n  }\n  brackets.each_char do |bracket|\n\
    \    case bracket\n    when '('\n      stack.push(bracket)\n    when ')'\n   \
    \   if stack.last == bracket_map[bracket]\n        stack.pop\n      else\n   \
    \     return false\n      end\n    end\n  end\n  stack.empty?\nend", "  # START\
    \ SOLUTION\n  count = 0\n  brackets.each_char do |char|\n    count += 1 if char\
    \ == \"(\"\n    count -= 1 if char == \")\"\n    return false if count < 0\n \
    \ end\n  count == 0\n  # END SOLUTION\nend", "\tleft = 0\n\tbrackets.each_char\
    \ do |x|\n\t\tleft += 1 if x == \"(\"\n\t\tleft -= 1 if x == \")\"\n\t\treturn\
    \ false if left < 0\n\tend\n\tleft == 0\nend", "  arr = []\n  brackets.each_char\
    \ do |char|\n    if char == \"(\"\n      arr << char\n    elsif char == \")\"\n\
    \      if arr.length == 0\n        return false\n      end\n      arr.pop\n  \
    \  end\n  end\n  arr.length == 0\nend", "  puts brackets.count(\"(\") == brackets.count(\"\
    )\")\nend", "  if brackets.length.odd?\n    false\n  else\n    c = 0\n    brackets.each_char\
    \ do |char|\n      c += 1 if char == \"(\"\n      c -= 1 if char == \")\"\n  \
    \    return false if c < 0\n    end\n    c == 0\n  end\nend", end, "    opening_brackets\
    \ = []\n    brackets.each_char do |c|\n        if c == \"(\"\n            opening_brackets.push(c)\n\
    \        elsif c == \")\"\n            if opening_brackets.empty?\n          \
    \      return false\n            else\n                opening_brackets.pop\n\
    \            end\n        end\n    end\n    return opening_brackets.empty?\nend",
  "  if brackets == nil\n    return false\n  end\n  opening_brackets = 0\n  closing_brackets\
    \ = 0\n  for i in 0..brackets.length-1\n    if brackets[i] == \"(\"\n      opening_brackets\
    \ += 1\n    elsif brackets[i] == \")\"\n      closing_brackets += 1\n    end\n\
    \  end\n  if opening_brackets == closing_brackets\n    return true\n  else\n \
    \   return false\n  end\nend", "  raise NotImplementedError\nend", "  brackets.split(\"\
    \").reduce(0) do |memo, char|\n    if memo < 0\n      return false\n    end\n\
    \    char == \"(\" ? memo + 1 : memo - 1\n  end == 0\nend", "  #this handles edge\
    \ cases of empty strings and strings with non-bracket characters\n  return false\
    \ if brackets.empty? || brackets.count(\"()\") != brackets.length\n  #this will\
    \ handle strings with brackets out of order\n  return false if brackets.scan(/\\\
    (/).length > brackets.scan(/\\)/).length\n  #otherwise the string is correctly\
    \ bracketed\n  true\nend", "  open_brackets = 0\n  brackets.chars.each do |bracket|\n\
    \    if bracket == \"(\"\n      open_brackets += 1\n    elsif bracket == \")\"\
    \n      open_brackets -= 1\n    end\n    return false if open_brackets < 0\n \
    \ end\n  open_brackets == 0\nend", "  open_brackets = 0\n  brackets.each_char\
    \ do |char|\n    if char == \"(\"\n      open_brackets += 1\n    elsif char ==\
    \ \")\"\n      open_brackets -= 1\n    end\n    return false if open_brackets\
    \ < 0\n  end\n  open_brackets == 0\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
