name: HumanEval_9_rolling_max
language: rb
prompt: "# From a given array of integers, generate an array of rolling maximum element\
  \ found until given moment\n# in the sequence.\n# >>> rolling_max.call([1, 2, 3,\
  \ 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n\
  \    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4,\
  \ 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100],\
  \ candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"
completions: ["  numbers.each_index.map { |i| numbers[0..i].max }\nend", "  max =\
    \ numbers.first\n  numbers.reduce([]) do |acc, num|\n    max = num if num > max\n\
    \    acc << max\n  end\nend", "  numbers.map.with_index do |_, index|\n    numbers[0..index].max\n\
    \  end\nend", "  numbers.each_with_index.reduce([]) do |acc, (number, i)|\n  \
    \  acc[i] = if i == 0\n               number\n             else\n            \
    \   [number, acc[i - 1]].max\n             end\n  end\nend", "  result = []\n\
    \  max = nil\n  numbers.each do |n|\n    max = n if !max || max < n\n    result\
    \ << max\n  end\n  result\nend", "  result = []\n  max = numbers[0]\n  numbers.each\
    \ do |n|\n    if n > max\n      max = n\n    end\n    result << max\n  end\n \
    \ result\nend", "  result = []\n  result << numbers.first\n  numbers[1..-1].each\
    \ do |n|\n    result << (n > result.last ? n : result.last)\n  end\n  result\n\
    end", "  # TODO: Your code here.\nend", "  numbers.each_with_index.map { |e, i|\n\
    \    numbers[0..i].max\n  }\nend", "  # YOUR CODE HERE\nend", "  numbers.each_with_index.reduce([])\
    \ do |result, (number, index)|\n    result << numbers[0..index].max\n  end\nend",
  "  #TODO\nend", "  result = []\n  max = 0\n  numbers.each do |number|\n    if number\
    \ > max\n      max = number\n    end\n    result << max\n  end\n  result\nend",
  "  numbers.map.with_index do |number, i|\n    numbers[0..i].max\n  end\nend", " \
    \ result = []\n  numbers.each do |number|\n    result << [number, result.last].compact.max\n\
    \  end\n  result\nend", "  numbers.each_with_index.map do |n, i|\n    numbers[0..i].max\n\
    \  end\nend", "  result = []\n  max = 0\n  numbers.each do |number|\n    if number\
    \ > max\n      max = number\n    end\n    result << max\n  end\n  result\nend",
  "  max = []\n  max[0] = numbers[0]\n  numbers.each_with_index do |n, i|\n    i.zero?\
    \ ? next : max[i] = [max[i - 1], n].max\n  end\n  max\nend", "  # TODO: implement\
    \ me\nend", "  current_max = 0\n  numbers.map do |number|\n    current_max = [current_max,\
    \ number].max\n  end\nend", "  numbers.inject([numbers.first]) do |memo, number|\n\
    \    memo << [memo.last, number].max\n  end\nend", "  n = numbers.size\n  result\
    \ = []\n  max = 0\n  for i in 0..n - 1\n    max = numbers[i] if numbers[i] > max\n\
    \    result[i] = max\n  end\n  result\nend", "  # TODO\nend", "  result = [numbers.first]\n\
    \  for i in 1..numbers.length-1\n    result << [result[i-1], numbers[i]].max\n\
    \  end\n  result\nend", "  numbers.size.times.map { |i| numbers[0..i].max }\n\
    end", "  max = numbers.first\n  numbers.map do |number|\n    max = number if number\
    \ > max\n    max\n  end\nend", "  result = []\n  max = numbers[0]\n  numbers.each\
    \ do |number|\n    if number > max\n      max = number\n    end\n    result <<\
    \ max\n  end\n  result\nend", "  arr = []\n  numbers.each_with_index do |x, i|\n\
    \    arr << numbers[0..i].max\n  end\n  arr\nend", "  numbers.each_with_index.map\
    \ { |e, i| numbers[0..i].max }\nend", "  (1..numbers.length).map do |i|\n    numbers[0...i].max\n\
    \  end\nend", "  numbers.map.with_index do |num, i|\n    numbers[0..i].max\n \
    \ end\nend", "  numbers.each_with_index.map do |_, i|\n    numbers[0..i].max\n\
    \  end\nend", "  # Write your code here.\nend", "  result = []\n  numbers.each\
    \ do |num|\n    result << [num, result.last.to_i].max\n  end\n  result\nend",
  "  numbers.map.with_index { |n, i| numbers[0..i].max }\nend", "  result = []\n \
    \ max = 0\n  numbers.each do |item|\n    max = item if item > max\n    result\
    \ << max\n  end\n  result\nend", "  # your code here\nend", "  numbers.each_with_index.map\
    \ do |_, index|\n    numbers[0..index].max\n  end\nend", "  numbers.each_with_index.reduce([])\
    \ do |result, (number, index)|\n    result << (index == 0 ? number : numbers[0..index].max)\n\
    \  end\nend", end, "  # TODO: implement this method\nend", "  rolling_maxes =\
    \ []\n  rolling_maxes << numbers.first\n  (1...numbers.length).each do |i|\n \
    \   rolling_maxes << [rolling_maxes.last, numbers[i]].max\n  end\n  rolling_maxes\n\
    end", "  numbers.reduce([]) do |acc, n|\n    if acc.empty?\n      acc << n\n \
    \   else\n      max = [acc.last, n].max\n      acc << max\n    end\n  end\nend",
  "  size = numbers.size\n  max_num = Array.new(size)", "  max = numbers.shift\n \
    \ numbers.map do |number|\n    max = [max, number].max\n  end.unshift(max)\nend",
  "  # use sliding window max of size 2, putting it into a new array\n  numbers.each_cons(2).map(&:max)\n\
    end", "  numbers.each_with_index.map { |e, i| numbers[0..i].max }\nend", "  maximums\
    \ = []\n  maximums << numbers.first\n  1.upto(numbers.size - 1) do |current_index|\n\
    \    maximums << [maximums.last, numbers[current_index]].max\n  end\n  maximums\n\
    end", "    rolling_max_array = []\n    current_max = numbers[0]\n    numbers.each\
    \ do |number|\n        if number > current_max\n            current_max = number\n\
    \        end\n        rolling_max_array << current_max\n    end\n    rolling_max_array\n\
    end", "  result = []\n  max = nil\n  numbers.each do |num|\n    max = num if max.nil?\
    \ || num > max\n    result << max\n  end\n  result\nend", "  (1..numbers.length\
    \ - 1).each do |i|\n    numbers[i] = [numbers[i], numbers[i - 1]].max\n  end\n\
    \  numbers\nend", "  numbers.map.with_index do |number, index|\n    numbers[0...index].max\
    \ || number\n  end\nend", "  rolling_max_numbers = []\n  numbers.each_with_index\
    \ do |number, index|\n    rolling_max_numbers[index] = (rolling_max_numbers[index\
    \ - 1] || 0)\n    rolling_max_numbers[index] = number if number > rolling_max_numbers[index]\n\
    \  end\n  rolling_max_numbers\nend", "  n = numbers.size\n  res = []\n  max =\
    \ numbers[0]\n  res << max\n  n.times do |i|\n    max = numbers[i] if numbers[i]\
    \ > max\n    res << max\n  end\n  res\nend", "  rolling_maxes = []\n  max = numbers.first\n\
    \  numbers.each do |number|\n    max = number if number > max\n    rolling_maxes\
    \ << max\n  end\n  rolling_maxes\nend", "  numbers.map.with_index do |_, index|\n\
    \    numbers[0..index].max\n  end\nend", "  ret = []\n  max = numbers[0]\n  numbers.each\
    \ do |num|\n    max = num if num > max\n    ret << max\n  end\n  ret\nend", " \
    \ result = []\n  numbers.each_with_index do |n, i|\n    result << numbers[0..i].max\n\
    \  end\n  result\nend", "  result = []\n  max = 0\n  numbers.each do |number|\n\
    \    max = [max, number].max\n    result << max\n  end\n  result\nend", "  max\
    \ = numbers.first\n  result = [max]\n  numbers[1..-1].each do |number|\n    if\
    \ number > max\n      max = number\n    end\n    result << max\n  end\n  result\n\
    end", "  numbers.each_with_index.map do |value, index|\n    if index == 0\n  \
    \    value\n    else\n      max_value = numbers[0..index].max\n      max_value\n\
    \    end\n  end\nend", "  rolling_max = []\n  numbers.each_with_index do |number,\
    \ index|\n    rolling_max << numbers[0..index].max\n  end\n  rolling_max\nend",
  "  result = [numbers.first]\n  numbers[1..-1].each do |number|\n    result << [number,\
    \ result.last].max\n  end\n  result\nend", "  result = []\n  numbers.each_with_index\
    \ do |num, i|\n    result << num if i == 0\n    result << result[i - 1] if i >\
    \ 0 && result[i - 1] > num\n    result << num if i > 0 && result[i - 1] <= num\n\
    \  end\n  result\nend", "  max_number = 0\n  numbers.map do |number|\n    max_number\
    \ = number if number > max_number\n    max_number\n  end\nend", "  new_array =\
    \ []\n  i = 0\n  numbers.each do |number|\n    if i == 0\n      new_array << number\n\
    \    else\n      if number > new_array[i-1]\n        new_array << number\n   \
    \   else\n        new_array << new_array[i-1]\n      end\n    end\n    i += 1\n\
    \  end\n  new_array\nend", "  max = numbers.first\n  1.upto(numbers.length - 1).map\
    \ do |i|\n    max = [max, numbers[i]].max\n  end\nend", "  numbers.map.with_index\
    \ { |number, index| numbers[0..index].max }\nend", "  i = 0\n  j = 1\n  len =\
    \ numbers.length\n  max = []\n  while i < len\n    if numbers[i] > numbers[j]\n\
    \      max.push(numbers[i])\n    else\n      max.push(numbers[j])\n    end\n \
    \   i += 1\n    j += 1\n  end\n  max\nend", "  new_array = []\n  index = 0\n \
    \ while index < numbers.length\n    if index == 0\n      new_array << numbers[index]\n\
    \    else\n      new_array << [numbers[index], new_array[index - 1]].max\n   \
    \ end\n    index += 1\n  end\n  new_array\nend", "  n = numbers.size\n  res =\
    \ []\n  n.times do |i|\n    res << numbers[0..i].max\n  end\n  res\nend", "  rolling_max\
    \ = []\n  max = 0\n  numbers.each do |n|\n    if n > max\n      max = n\n    end\n\
    \    rolling_max << max\n  end\n  rolling_max\nend", "  max_numbers = []\n  numbers.each\
    \ do |num|\n    if max_numbers.empty?\n      max_numbers << num\n    else\n  \
    \    max_numbers << [num, max_numbers.last].max\n    end\n  end\n  max_numbers\n\
    end", "  numbers.each_with_index.map { |n, i| numbers[0..i].max }\nend", "  max\
    \ = 0\n  nums = []\n  numbers.each do |num|\n    if num > max\n      max = num\n\
    \    end\n    nums << max\n  end\n  nums\nend", "  numbers.each_with_index.map\
    \ { |n, i| numbers[0..i].max }\nend", "  #Numbers is the array\n  #create an empty\
    \ array\n  #Loop through the array\n  #Push the maximum value into the new array",
  "  result = []\n  current_max = 0\n  numbers.each do |number|\n    if number > current_max\n\
    \      current_max = number\n    end\n    result << current_max\n  end\n  result\n\
    end", "  result = []\n  max = 0\n  numbers.each do |n|\n    max = n if n > max\n\
    \    result << max\n  end\n  result\nend", "  max = numbers.first\n  result =\
    \ [max]\n  numbers[1..-1].each do |number|\n    max = [max, number].max\n    result\
    \ << max\n  end\n  result\nend", "  (1..numbers.size).inject([]) do |acc, i|\n\
    \    acc << numbers[0..i-1].max\n  end\nend", "  result = []\n  for i in 0..numbers.size-1\n\
    \    result << numbers[0..i].max\n  end\n  result\nend", "  numbers.reduce([])\
    \ do |result, number|\n    result << [result.last || 0, number].max\n  end\nend",
  "  rolling_max = Array.new(numbers.length)\n  max = numbers[0]\n  rolling_max[0]\
    \ = max\n  numbers.each_with_index do |number, index|\n    next if index == 0\n\
    \    max = [max, number].max\n    rolling_max[index] = max\n  end\n  rolling_max\n\
    end", "  result = []\n  max = nil\n  numbers.each do |item|\n    max = item if\
    \ max.nil? || item > max\n    result << max\n  end\n  result\nend", "  result\
    \ = []\n  max = numbers[0]\n  numbers.each do |number|\n    if number > max\n\
    \      max = number\n    end\n    result << max\n  end\n  result\nend", "  numbers.map.with_index\
    \ { |v, i| numbers[0..i].max }\nend", "  # Write your code here.\nend", "  result\
    \ = []\n  max = numbers[0]\n  numbers.each do |number|\n    if number > max\n\
    \      max = number\n    end\n    result << max\n  end\n  result\nend", "  numbers.each_with_index.map\
    \ { |e, i| numbers[0..i].max }\nend", "  [].tap do |result|\n    numbers.each\
    \ do |el|\n      result << [el, result.last.to_i].max\n    end\n  end\nend", " \
    \ maximums = []\n  maximums << numbers.first\n  numbers[1..-1].each do |number|\n\
    \    maximums << [maximums.last, number].max\n  end\n  maximums\nend", "  result\
    \ = []\n  numbers.each_with_index do |num, index|\n    max = num\n    (index +\
    \ 1).times do |i|\n      max = numbers[i] if numbers[i] > max\n    end\n    result\
    \ << max\n  end\n  result\nend", "  results = []\n  max = numbers.first\n  numbers.each\
    \ do |number|\n    max = number if number > max\n    results << max\n  end\n \
    \ results\nend", "  raise 'You need to give me an array of numbers' unless numbers.is_a?(Array)",
  "  result = []\n  numbers.each_with_index do |num, index|\n    subarray = numbers[0..index]\n\
    \    max = 0\n    subarray.each do |i|\n      if i > max\n        max = i\n  \
    \    end\n    end\n    result << max\n  end\n  result\nend", "  numbers.map.with_index\
    \ do |_, i|\n    numbers[0..i].max\n  end\nend", "  numbers.inject([]) do |acc,\
    \ n|\n    acc << [n, acc.last&.max || n].max\n  end\nend", "  # Your solution\
    \ here\nend", end, "  result = []\n  max = numbers[0]\n  numbers.each do |n|\n\
    \    max = n if n > max\n    result << max\n  end\n  result\nend", "  # your code\
    \ here\nend", "  return numbers if numbers.size == 1\n  result = []\n  max = 0\n\
    \  numbers.each do |num|\n    max = num if num > max\n    result << max\n  end\n\
    \  result\nend", "  raise(NotImplementedError)\nend", "  result = []\n  max =\
    \ numbers[0]\n  numbers.each do |n|\n    if n > max\n      max = n\n    end\n\
    \    result << max\n  end\n  result\nend", end, "  max = numbers.shift\n  [max]\
    \ + numbers.map { |number| max = [max, number].max }\nend", "  max = numbers.first\n\
    \  numbers.map { |n| max = [max, n].max }\nend", "  # TODO: implement this function\n\
    end", "  result = []\n  max = 0\n  numbers.each do |number|\n    max = number\
    \ if number > max\n    result << max\n  end\n  result\nend", "  puts \"no implementation\
    \ yet\"\nend", "  result = []\n  numbers.each_with_index do |num, index|\n   \
    \ result[index] = numbers[0...index].max\n  end\n  result\nend", "  maxes = []\n\
    \  max = 0\n  numbers.each do |number|\n    max = number if number > max\n   \
    \ maxes << max\n  end\n  maxes\nend", "  numbers.each_with_index.map { |e, i|\
    \ numbers[0..i].max }\nend", "  numbers.each_with_index.map { |n, i| numbers[0..i].max\
    \ }\nend", "  results = []\n  numbers.each_with_index do |n, i|\n    results[i]\
    \ = numbers[0..i].max\n  end\n  results\nend", "  result = [numbers.first]\n \
    \ numbers[1..-1].each { |i| result << [i, result.last].max }\n  result\nend",
  "  result = []\n  max = numbers[0]\n  numbers.each do |n|\n    max = n if n > max\n\
    \    result << max\n  end\n  result\nend", "  numbers.each_with_index.reduce([])\
    \ do |memo, (number, index)|\n    memo[index] = [number, memo[index - 1]].compact.max\n\
    \    memo\n  end\nend", "  raise NotImplementedError\nend", "  max = 0\n  numbers.map\
    \ do |i|\n    max = i if i > max\n    max\n  end\nend", "  result = []\n  max\
    \ = nil\n  numbers.each do |number|\n    if max.nil? || number > max\n      max\
    \ = number\n    end\n    result << max\n  end\n  result\nend", "  numbers.map.with_index\
    \ do |number, index|\n    index == 0 ? number : [number, *numbers[0..index-1]].max\n\
    \  end\nend", "  # Put your code here\nend", "    # TODO: Implement method\nend",
  "  max = numbers.shift\n  maxes = [max]\n  numbers.each do |number|\n    max = number\
    \ if number > max\n    maxes << max\n  end\n  maxes\nend", "  rolling_max = []\n\
    \  numbers.each_with_index do |number, index|\n    last_max = rolling_max.last.nil?\
    \ ? 0 : rolling_max.last\n    if number > last_max\n      rolling_max[index] =\
    \ number\n    else\n      rolling_max[index] = last_max\n    end\n  end\n  rolling_max\n\
    end", "  numbers.each_with_index.map do |number, index|\n    numbers[0..index].max\n\
    \  end\nend", "  max_element = []\n  max_element.push(numbers[0])\n  i = 1\n \
    \ while i < numbers.length\n    max_element.push(numbers[i] > max_element[i -\
    \ 1] ? numbers[i] : max_element[i - 1])\n    i += 1\n  end\n  max_element\nend",
  "  max = []\n  numbers.each_with_index do |current, index|\n    prev_num = index\
    \ > 0 ? numbers[index - 1] : current\n    max[index] = [prev_num, current].max\n\
    \  end\n  max\nend", "  result = []\n  current_max = numbers.first\n  for number\
    \ in numbers\n    current_max = [current_max, number].max\n    result << current_max\n\
    \  end\n  result\nend", "  numbers.map.with_index do |_, i|\n    numbers[0..i].max\n\
    \  end\nend", "  maxes = []\n  maximum = numbers.first\n  numbers.each do |number|\n\
    \    maximum = number if number > maximum\n    maxes << maximum\n  end\n  maxes\n\
    end", "  result = []\n  current_max = numbers.first\n  numbers.each do |num|\n\
    \    current_max = [current_max, num].max\n    result << current_max\n  end\n\
    \  result\nend", "  result = []\n  numbers.each_with_index do |num, index|\n \
    \   result << numbers[0..index].max\n  end\n  result\nend", end, "  results =\
    \ []\n  numbers.each_with_index do |number, i|\n    results << get_max(numbers[0..i])\n\
    \  end\n  results\nend", "  rolling_max = []\n  numbers.each_with_index do |number,\
    \ index|\n    max = numbers[0..index].max\n    rolling_max << max\n  end\n  rolling_max\n\
    end", "  result = []\n  max = numbers[0]\n  numbers.each do |number|\n    if number\
    \ > max\n      max = number\n    end\n    result << max\n  end\n  result\nend",
  "  max_arr = []\n  max = numbers[0]\n  numbers.each do |num|\n    if num > max\n\
    \      max = num\n    end\n    max_arr << max\n  end\n  max_arr\nend", "  numbers.map.with_index\
    \ do |number, index|\n    numbers[0..index].max\n  end\nend", "  res = []\n  max\
    \ = numbers[0]\n  numbers.each do |num|\n    max = [max, num].max\n    res <<\
    \ max\n  end\n  res\nend", "  current_max = -1.0/0.0 # minimum float\n  numbers.map\
    \ do |number|\n    if number > current_max\n      current_max = number\n    end\n\
    \    current_max\n  end\nend", "  numbers.each_with_index.with_object([]) do |(number,\
    \ index), result|\n    result << numbers[0..index].max\n  end\nend", "  result\
    \ = [numbers.first]\n  numbers[1..-1].each do |number|\n    result << [result.last,\
    \ number].max\n  end\n  result\nend", "  result = []\n  numbers.each_with_index\
    \ do |num, i|\n    max = nil\n    for j in i...numbers.length\n      max = numbers[j]\
    \ if max.nil? || numbers[j] > max\n    end\n    result << max\n  end\n  result\n\
    end", "  numbers.inject([]) do |result, number|\n    result << (result.last ||\
    \ number)\n    result.last = number if number > result.last\n    result\n  end\n\
    end", "  rolling_max = []\n  numbers.each_with_index do |n, i|\n    rolling_max[i]\
    \ = numbers[0..i].max\n  end\n  rolling_max\nend", "  (0...numbers.size).map {\
    \ |i| numbers[0..i].max }\nend", "  numbers.reduce([]) do |rolling_max, number|\n\
    \    rolling_max << (rolling_max.last || number)\n    rolling_max[-1] = number\
    \ if number > rolling_max.last\n    rolling_max\n  end\nend", "    # return numbers\
    \ if numbers.length == 1\n    result = []\n    numbers.each do |number|\n    \
    \    result << numbers[0..numbers.index(number)].max\n    end\n    result\nend",
  "  result = [numbers.first]\n  numbers[1..-1].each { |num| result << (num > result.last\
    \ ? num : result.last) }\n  result\nend", "  numbers.each_with_index.map do |x,\
    \ i|\n    max = numbers[0..i].max\n    max || x\n  end\nend", "  raise ArgumentError,\
    \ 'argument must be an array' unless numbers.is_a?(Array)\n  numbers.map.with_index\
    \ { |_, i| numbers[0..i].max }\nend", "  result = []\n  roll_max = 0\n  numbers.each\
    \ do |number|\n    roll_max = [roll_max, number].max\n    result << roll_max\n\
    \  end\n  result\nend", "  max = 0\n  numbers.map do |number|\n    if number >\
    \ max\n      max = number\n    else\n      max\n    end\n  end\nend", "  max_numbers\
    \ = []\n  rolling_max = 0\n  numbers.each do |n|\n    if n > rolling_max\n   \
    \   rolling_max = n\n    end\n    max_numbers << rolling_max\n  end\n  max_numbers\n\
    end", "  numbers.size.times.with_object([]) do |index, array|\n    array << numbers[0..index].max\n\
    \  end\nend", "  max = numbers.first\n  numbers.map { |x|\n    max = x if x >\
    \ max\n    max\n  }\nend", "  numbers.reduce([numbers.first]) do |result, number|\n\
    \    max = [result.last, number].max\n    result.push(max)\n  end\nend", "  #\
    \ this is naive solution.\n  # you can use the solution from slide show\n  # or\
    \ you can use any data structure if you like.\n  rmax = []\n  rmax << numbers[0]\n\
    \  for i in 1..numbers.length-1\n    max = rmax[i-1]\n    max = numbers[i] if\
    \ numbers[i] > max\n    rmax << max\n  end\n  rmax\nend", "  max = []\n  numbers.each_with_index\
    \ do |number, index|\n    left_index = 0\n    right_index = index + 1\n    left_array\
    \ = numbers[left_index..right_index]\n    right_array = numbers[index..index]\n\
    \    max << [left_array.max, right_array.max].max\n  end\n  max\nend", "  numbers.each_index.with_object([])\
    \ do |i, out|\n    out << numbers[0..i].max\n  end\nend", "  max_num = 0\n  numbers.map\
    \ do |num|\n    if num > max_num\n      max_num = num\n    end\n    max_num\n\
    \  end\nend", "  max_value = 0\n  numbers.map do |num|\n    max_value = [max_value,\
    \ num].max\n  end\nend", "  number_of_elements = numbers.size\n  max_from_start\
    \ = Array.new(number_of_elements)\n  # TODO implement the method\n  max_from_start[0]\
    \ = numbers[0]\n  (1...number_of_elements).each do |index|\n    max_from_start[index]\
    \ = [max_from_start[index - 1], numbers[index]].max\n  end\n  max_from_start\n\
    end", "  result = [numbers.first]\n  numbers[1..-1].each do |number|\n    result\
    \ << (number > result.last ? number : result.last)\n  end\n  result\nend", " \
    \ if numbers.length == 0\n    return []\n  end\n  max_array = [numbers[0]]\n \
    \ for i in 1..numbers.length-1\n    max_array << [max_array[i-1], numbers[i]].max\n\
    \  end\n  return max_array\nend", "  output = []\n  max = numbers[0]\n  numbers.each\
    \ do |num|\n    max = num if num > max\n    output << max\n  end\n  output\nend",
  "  rolling_max = []\n  number_max = 0\n  numbers.each do |n|\n    number_max = n\
    \ if n > number_max\n    rolling_max << number_max\n  end\n  rolling_max\nend",
  "    if numbers.length == 0\n        return []\n    end\n    maximums = []\n   \
    \ maximums[0] = numbers[0]\n    (1..numbers.length-1).each do |i|\n        if\
    \ numbers[i] > maximums[i-1]\n            maximums[i] = numbers[i]\n        else\n\
    \            maximums[i] = maximums[i-1]\n        end\n    end\n    return maximums\n\
    end", "  numbers.map.with_index { |_, i| numbers[0..i].max }\nend", "  maxes =\
    \ []\n  max = numbers.first\n  numbers.each do |number|\n    max = number if number\
    \ > max\n    maxes << max\n  end\n  maxes\nend", "  # TODO: implement\nend", " \
    \ # your code goes here\nend", "  # write your code here\nend", "  (1..numbers.size).map\
    \ do |i|\n    numbers[0..i-1].max\n  end\nend", "    max_list = []\n    running_max\
    \ = 0\n    numbers.each do |number|\n        if number > running_max\n       \
    \     running_max = number\n        end\n        max_list.push(running_max)\n\
    \    end\n    return max_list\nend", "  result = []\n  max = numbers[0]\n  numbers.each\
    \ do |number|\n    max = number if number > max\n    result << max\n  end\n  result\n\
    end", "  numbers.map.with_index { |n, i| numbers[0..i].max }\nend", "  numbers.each_with_index.map\
    \ do |e, i|\n    if i == 0\n      e\n    else\n      [e, *numbers[0..i]].max\n\
    \    end\n  end\nend", "  max_array = []\n  current_max = 0\n  numbers.each do\
    \ |i|\n    if i > current_max\n      current_max = i\n    end\n    max_array <<\
    \ current_max\n  end\n  max_array\nend", "  numbers.each_with_index.map do |n,\
    \ index|\n    numbers[0..index].max\n  end\nend", "  numbers.map.with_index do\
    \ |number, index|\n    numbers[0..index].max\n  end\nend", "  numbers.each_with_index.map\
    \ do |_, i|\n    numbers[0..i].max\n  end\nend", "  (1..numbers.size).map { |i|\
    \ numbers[0..i].max }\nend", "  result = []\n  numbers.each_with_index do |num,\
    \ index|\n    max = num\n    (index..numbers.length - 1).each do |i|\n      if\
    \ numbers[i] > max\n        max = numbers[i]\n      end\n    end\n    result <<\
    \ max\n  end\n  result\nend", "  max_arr = []\n  max = numbers[0]\n  numbers.each\
    \ do |n|\n    max = n if n > max\n    max_arr << max\n  end\n  max_arr\nend",
  "  result = []\n  numbers.each_with_index do |number, i|\n    current_max = 0\n\
    \    numbers[0..i].each do |number|\n      current_max = number if number > current_max\n\
    \    end\n    result << current_max\n  end\n  result\nend", "  result = []\n \
    \ current_max = numbers.first\n  numbers.each do |number|\n    current_max = number\
    \ if number > current_max\n    result << current_max\n  end\n  result\nend", " \
    \ max = numbers.first\n  max_list = []\n  numbers.each do |number|\n    max =\
    \ number if number > max\n    max_list << max\n  end\n  max_list\nend", "  rolls\
    \ = Array.new(numbers.length)\n  rolls[0] = numbers[0]\n  (1...numbers.length).each\
    \ do |i|\n    rolls[i] = [rolls[i - 1], numbers[i]].max\n  end\n  rolls\nend",
  "  numbers.each_with_index.with_object([]) do |(number, index), result|\n    max\
    \ = index == 0 ? number : [number, result[index - 1]].max\n    result << max\n\
    \  end\nend", "  (1..numbers.size).map { |i| numbers[0..i].max }\nend", "  max\
    \ = 0\n  result = []\n  numbers.each do |number|\n    max = number if number >\
    \ max\n    result << max\n  end\n  result\nend", "  numbers.each_with_index.reduce([])\
    \ do |res, (x,i)|\n    res << (i.zero? ? x : [res.last, x].max)\n  end\nend",
  "  max_number = numbers.first\n  numbers.each_with_object([]) do |num, rolling_max|\n\
    \    max_number = num if num > max_number\n    rolling_max << max_number\n  end\n\
    end", "  rolling_max = []\n  max = numbers[0]\n  for i in 0..numbers.length\n\
    \    if max >= numbers[i]\n      rolling_max.push(max)\n    else\n      max =\
    \ numbers[i]\n      rolling_max.push(max)\n    end\n  end\n  return rolling_max\n\
    end", "  current_max = -Float::INFINITY\n  numbers.map do |number|\n    current_max\
    \ = number if number > current_max\n    current_max\n  end\nend", "  numbers.map.with_index\
    \ { |_, i| numbers[0..i].max }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
