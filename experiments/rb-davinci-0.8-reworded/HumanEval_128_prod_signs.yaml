name: HumanEval_128_prod_signs
language: rb
prompt: "# You are given an array arr of integers and you need to return\n# sum of\
  \ magnitudes of integers multiplied by product of all signs\n# of each number in\
  \ the array, represented by 1, -1 or 0.\n# Note: return nil for empty arr.\n# Example:\n\
  # >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n\
  # >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
  \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2,\
  \ 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1,\
  \ 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20,\
  \ candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1,\
  \ 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0,\
  \ candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
completions: ["  res = nil\n  if arr.size > 0\n    res = arr.map { |num| num <=> 0\
    \ }.reduce(:*)\n    res *= arr.map { |num| num.abs }.reduce(:+)\n  end\n  res\n\
    end", "  return nil if arr.empty?\n  prod = arr.inject(1) { |prod, x| prod * sign(x)\
    \ }\n  sum = arr.inject(0) { |sum, x| sum + x.abs }\n  prod * sum\nend", "  return\
    \ nil if arr.empty?\n  arr.map { |i| i.abs }.sum * arr.map { |i| i.sign }.reduce(:*)\n\
    end", "  arr.empty? ? nil : arr.map { |x| x <=> 0 }.reduce(:*) * arr.sum { |x|\
    \ x.abs }\nend", "  signs = arr.map { |n| n <=> 0 }.compact\n  return nil if signs.empty?\n\
    \  signs.reduce(:*) * arr.map(&:abs).reduce(:+)\nend", "  arr.map { |num| num.abs\
    \ }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend", "  return nil if arr.empty?\n\
    \  sum_abs = arr.reduce(0) { |sum, n| sum + n.abs }\n  sum_abs * arr.reduce(1)\
    \ { |prod, n| prod * n.positive? ? 1 : n }\nend", "  return nil if arr.empty?\n\
    \  arr.inject { |prod, num| prod * num.magnitude } *\n    arr.inject { |prod,\
    \ num| prod * num.sign }\nend", "  #TODO: Implement method\nend", "  #TODO: Implement\
    \ Me!\nend", "  arr.empty? ? nil : arr.map { |num| num.abs }.reduce(:+) * arr.map\
    \ { |num| num == 0 ? 0 : num / num.abs }.reduce(:*)\nend", "  abs_sum = 0\n  signed_prod\
    \ = 1\n  return nil if arr.empty?\n  arr.each do |i|\n    signed_prod *= i > 0\
    \ ? 1 : i < 0 ? -1 : 0\n    abs_sum += i.abs\n  end\n  abs_sum * signed_prod\n\
    end", "  arr.reduce(1, &:*) * arr.map(&:abs).reduce(:+)\nend", "  # Your code\
    \ goes here\nend", "  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum\
    \ * arr.map { |num| num <=> 0 }.reduce(:*)\nend", "  return nil if arr.empty?\n\
    \  signs = arr.map { |x| x <=> 0 }\n  signs.reduce(:*) * arr.reduce(0) { |sum,\
    \ n| sum + n.abs }\nend", "  if arr.empty?\n    nil\n  else\n    sign = 1\n  \
    \  magn_arr = arr.map { |num| num.abs }\n    magn_arr.each do |num|\n      sign\
    \ *= num <=> 0\n    end\n    magn_arr.reduce(:+) * sign\n  end\nend", "  arr.empty?\
    \ ? nil : arr.map { |i| i.abs }.inject(:+) * arr.map { |i| i <=> 0 }.inject(:*)\n\
    end", "  return nil if arr.empty?\n  arr.map { |n| (n == 0) ? 0 : n.abs }.reduce(:*)\
    \ *\n    arr.map { |n| (n == 0) ? 0 : n / n.abs }.reduce(:*)\nend", "  p arr.inject(0)\
    \ { |a, e| a + (e.zero? ? 0 : e < 0 ? -e : e) } *\n    arr.inject(1) { |a, e|\
    \ a * (e.zero? ? 1 : e < 0 ? -1 : 1) }\nend", "  return if arr.empty?\n  signs\
    \ = arr.map { |num| num <=> 0 }\n  signs.uniq.include?(0) ? 0 : signs.inject(:*)\
    \ * arr.map(&:abs).inject(:+)\nend", "  arr.reduce(1) { |a, e| a *= e.sign } *\
    \ arr.reduce(0) { |a, e| a += e.abs }\nend", "  # provide your code here\nend",
  "  return nil if arr.empty?\n  arr.map(&:abs).sum * arr.reject { |e| e.zero? }.map(&:sign).reduce(:*)\n\
    end", "  (arr.empty? ? nil : arr.map(&:abs).reduce(:+) * arr.map(&:sign).reduce(:*))\n\
    end", "  return nil if arr.empty?\n  # your code goes here\nend", "  return nil\
    \ if arr.empty?\n  return 0 if arr.include?(0)\n  arr.map { |num| num.abs }.reduce(:+)\
    \ * arr.reduce(:*)\nend", "  return nil if arr.empty?\n  arr.each_with_object([0,\
    \ 1]) do |n, (a, b)|\n    a += n.abs\n    b *= n <=> 0\n  end.reduce(:*)\nend",
  "  arr.empty? ? nil : arr.inject(1) { |m, n| n.abs * m }\nend", "  # TODO: find\
    \ the product of signs and sum of magnitudes\n  return nil if arr.empty?\n  prod\
    \ = arr.map{|n| Math.sign(n)}.reduce(:*)\n  sum = arr.map{|n| n.abs}.reduce(:+)\n\
    \  sum * prod\nend", "  return nil if arr.empty?\n  sum_of_magnitudes = arr.inject(0)\
    \ { |sum, num| sum + num.abs }\n  product_of_signs = arr.inject(1) { |product,\
    \ num| product * num.sign }\n  sum_of_magnitudes * product_of_signs\nend", " \
    \ return nil if arr.empty?\n  sign_prod = arr.inject(1) { |acc, elem| acc * sign(elem)\
    \ }\n  arr.inject(0) { |acc, elem| acc + magnitude(elem) } * sign_prod\nend",
  "  # sum of all numbers in arr\n  total = arr.reduce(:+)\n  # sum of all negative\
    \ numbers in arr\n  negatives = arr.select { |num| num < 0 }.reduce(:+)\n  # sum\
    \ of all positive numbers in arr\n  positives = arr.select { |num| num > 0 }.reduce(:+)\n\
    \  # 0 is the only number that is neither positive nor negative\n  return total\
    \ if total.zero?\n  # if all negative, negatives is positive. negatives is negative\
    \ if there are positive numbers in arr\n  return total if negatives > 0 && positives.nil?\n\
    \  # if the only negative number is 0, negatives is 0\n  return positives if negatives.zero?\n\
    \  # if the only positive number is 0, positives is 0\n  return negatives if positives.zero?\n\
    \  # if positives is nil, it will be 1 because we're multiplying.\n  # if negatives\
    \ is nil, it will be 1 because we're multiplying.\n  total + positives * negatives\n\
    end", "  return nil if arr.empty?\n  sign = arr.reduce(1) { |memo, item| memo\
    \ * (item <=> 0) }\n  prod = arr.reduce(1) { |memo, item| memo * item.abs }\n\
    \  prod * sign\nend", "  if arr.empty?\n    nil\n  else\n    arr.reduce(1) { |prod,\
    \ item| prod *= item <=> 0 }\n      .abs * arr.map(&:abs).reduce(:+)\n  end\n\
    end", "  # \u041F\u0443\u0441\u0442\u043E\u0439 \u043C\u0430\u0441\u0441\u0438\
    \u0432\n  return nil if arr.empty?\n  # \u0415\u0441\u043B\u0438 \u0432 \u043C\
    \u0430\u0441\u0441\u0438\u0432\u0435 \u0432\u0441\u0435 \u0447\u0438\u0441\u043B\
    \u0430 \u043F\u043E\u043B\u043E\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u044B\
    \u0435, \u0442\u043E \u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0434\u0435\u043D\
    \u0438\u0435 \u0437\u043D\u0430\u043A\u043E\u0432 \u0440\u0430\u0432\u043D\u043E\
    \ 1\n  return arr.sum if arr.min >= 0\n  # \u0415\u0441\u043B\u0438 \u0432 \u043C\
    \u0430\u0441\u0441\u0438\u0432\u0435 \u0432\u0441\u0435 \u0447\u0438\u0441\u043B\
    \u0430 \u043E\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043B\u044C\u043D\u044B\
    \u0435, \u0442\u043E \u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0434\u0435\u043D\
    \u0438\u0435 \u0437\u043D\u0430\u043A\u043E\u0432 \u0440\u0430\u0432\u043D\u043E\
    \ -1\n  return -arr.sum if arr.max <= 0\n  # \u0415\u0441\u043B\u0438 \u0432 \u043C\
    \u0430\u0441\u0441\u0438\u0432\u0435 \u0435\u0441\u0442\u044C \u043E\u0442\u0440\
    \u0438\u0446\u0430\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u0438 \u043F\u043E\
    \u043B\u043E\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u0447\u0438\
    \u0441\u043B\u0430, \u0442\u043E \u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0434\
    \u0435\u043D\u0438\u0435 \u0437\u043D\u0430\u043A\u043E\u0432 \u0440\u0430\u0432\
    \u043D\u043E 0\n  0\nend", "  unless arr.nil?\n    magnitude = 0\n    sign = 1\n\
    \    arr.each do |x|\n      magnitude += x.abs\n      sign *= x <=> 0\n    end\n\
    \    magnitude * sign\n  end\nend", "    arr.inject(1) { |sum, num| sum *= num.abs\
    \ }\nend", "  return nil if arr.size == 0\n  arr.inject(1) { |r, x| r *= x.abs\
    \ if x != 0; r } * arr.inject(1) { |r, x| r *= x > 0 ? 1 : (x < 0 ? -1 : 0) }\n\
    end", "  arr.empty? ? nil : arr.map { |a| a.abs }.inject(:+) * arr.map { |a| a\
    \ <=> 0 }.inject(:*)\nend", "  return nil if arr.empty?\n  arr_with_magnitude\
    \ = arr.map{|n| n.abs}\n  arr_with_sign = arr.map{|n| n <=> 0}\n  arr_with_magnitude.reduce(:+)\
    \ * arr_with_sign.reduce(:*)\nend", "    arr.empty? ? nil :\n    \t(arr.map {\
    \ |n| n.abs }.reduce(:+) *\n\t\tarr.map { |n| n > 0 ? 1 : n < 0 ? -1 : 0 }.reduce(:*))\n\
    end", "  arr.empty? ? nil : arr.reject { |num| num == 0 }.map(&:abs).reduce(:+)\
    \ * arr.inject(1) { |product, num| product * (num == 0 ? 1 : num / num.abs) }\n\
    end", "  arr.empty? ? nil : arr.sum { |x| x.abs * (x == 0 ? 1 : x / x.abs) }\n\
    end", "  arr.empty? ? nil : arr.sum(&:abs) * arr.count(0) * arr.count(1) * arr.count(-1)\n\
    end", "  return nil if arr.empty?\n  product = 1\n  sum = 0\n  arr.each do |n|\n\
    \    case n <=> 0\n    when -1 then product *= -1\n    when 1 then sum += n\n\
    \    when 0 then return 0\n    end\n  end\n  sum * product\nend", "  if arr.length\
    \ == 0\n    return nil\n  end\n  prod = 1\n  sum = 0\n  arr.each do |x|\n    sum\
    \ += x.abs\n    prod *= sign(x)\n  end\n  prod * sum\nend", "  #TODO: implement\
    \ me\nend", "  return nil if arr.empty?\n  signs = arr.map { |i| [1, -1, 0].include?(i)\
    \ ? i : i.sign }\n  arr.map(&:abs).sum * signs.inject(:*)\nend", "  return nil\
    \ if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e > 0 ? 1\
    \ : e < 0 ? -1 : 0 }.reduce(:*)\nend", "  product = nil\n  sum = 0\n  unless arr.empty?\n\
    \    arr.each do |e|\n      e <=> 0 < 0 ? product = -1 : e <=> 0 > 0 ? product\
    \ = 1 : product = 0\n      sum += e.abs\n    end\n    sum * product\n  end\nend",
  "  return nil if arr.empty?\n  sign_arr = arr.map { |e| e > 0 ? 1 : e == 0 ? 0 :\
    \ -1 }\n  sign_arr.inject(:*) * arr.map(&:abs).inject(:+)\nend", "  arr.reduce(1,\
    \ :*) unless arr.empty?\nend", "  return nil if arr.empty?\n  arr.each_with_object(1)\
    \ { |i, a| i.abs * a } * arr.map(&:sign).reduce(:*)\nend", "  return nil if arr.empty?\n\
    \  return 0 if arr.any? { |x| x == 0 }\n  arr_signs = arr.map { |x| x <=> 0 }\n\
    \  arr_magnitudes = arr.map { |x| x.abs }\n  magnitudes_sum = arr_magnitudes.reduce(:+)\n\
    \  signs_prod = arr_signs.reduce(:*)\n  signs_prod * magnitudes_sum\nend", " \
    \ return nil if arr.empty?\n  sign_prod = arr.map { |e| e > 0 ? 1 : (e < 0 ? -1\
    \ : 0) }.reduce(:*)\n  sign_prod * arr.map(&:abs).reduce(:+)\nend", "  return\
    \ nil if arr.empty?\n  arr.map(&:abs).reduce(:+) * arr.map { |i| i.positive? ?\
    \ 1 : -1 }.reduce(:*)\nend", "  return nil if arr.empty?\n  product = 1\n  array\
    \ = []\n  arr.each do |n|\n    if n > 0\n      product *= 1\n      array << n\n\
    \    elsif n < 0\n      product *= -1\n      array << n.abs\n    else\n      product\
    \ *= 0\n    end\n  end\n  sum = array.reduce(:+)\n  return sum * product\nend",
  "  return nil if arr.empty?\n  arr.map{|x| x.to_f.abs }.reduce(:*) *\n    arr.map{|x|\
    \ x > 0 ? 1 : (x < 0 ? -1 : 0) }.reduce(:*)\nend", "  # YOUR CODE HERE\nend",
  "  return nil if arr.empty?\n  arr.map(&:abs).reduce(:+) * arr.map { |i| i > 0 ?\
    \ 1 : i < 0 ? -1 : 0 }.reduce(:*)\nend", "  if arr.empty?\n    return nil\n  else\n\
    \    arr.each_with_index.inject(0) do |acc, (ele, i)|\n      (acc + (ele.abs *\
    \ (i * 0.5).round)).round\n    end\n  end\nend", "  return nil if arr.empty?\n\
    \  magnitudes = arr.map(&:abs)\n  signs = arr.map { |n| n == 0 ? 0 : n > 0 ? 1\
    \ : -1 }\n  magnitudes.sum * signs.inject(:*)\nend", "  prod = arr.inject { |prod,\
    \ i| prod *= i if i.positive? || i.negative? }\n  prod ? arr.map(&:abs).sum *\
    \ prod : nil\nend", "  return nil if arr.size == 0\n  arr_signs = arr.map { |e|\
    \ e <=> 0 }\n  arr_signs.inject(:*) * arr.map(&:abs).reduce(:+)\nend", "  return\
    \ nil if arr.empty?\n  prod = 1\n  arr.each do |num|\n    prod *= num >= 0 ? 1\
    \ : -1\n  end\n  arr.map(&:abs).reduce(:+) * prod\nend", "\tproduct = 1\n\tsum\
    \ = 0\n\tif arr.empty?\n\t\tnil\n\telse\n\t\tarr.each do |n|\n\t\t\tif n > 0\n\
    \t\t\t\tproduct *= 1\n\t\t\t\tsum += n\n\t\t\telsif n < 0\n\t\t\t\tproduct *=\
    \ -1\n\t\t\t\tsum += -n\n\t\t\telse\n\t\t\t\tproduct *= 0\n\t\t\tend\n\t\tend\n\
    \t\tsum * product\n\tend\nend", "  return nil if arr.empty?\n  # a = arr.each\
    \ { |e| e.sign }.inject(:*)\n  # arr.map { |e| e.abs }.inject(:+) * a\n  a = arr.map\
    \ { |e| e.sign }.inject(:*)\n  return arr.map { |e| e.abs }.inject(:+) * a\nend",
  "  arr.each do |v|\n    v = Integer(v)\n  rescue\n    raise TypeError, \"Array should\
    \ have integer elements\"\n  end\n  raise TypeError, \"Array should have integer\
    \ elements\" if arr.empty?\n  arr.map { |v| v.abs }.reduce(:+) * arr.map { |v|\
    \ v <=> 0 }.reduce(:*)\nend", "\treturn nil if arr.empty?\n\tvalues = []\n\tarr.each\
    \ do |num|\n\t\tif num < 0\n\t\t\tvalues << num.abs\n\t\telsif num > 0\n\t\t\t\
    values << num\n\t\tend\n\tend\n\tvalues.reduce(:+) * arr.reduce(:*)\nend", " \
    \ arr.inject(1) { |memo, i| memo * i } *\n    arr.inject(0) { |memo, i| memo +\
    \ i.abs }\nend", "  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+)\
    \ * arr.map { |e| e == 0 ? 0 : e > 0 ? 1 : -1 }.reduce(:*)\nend", "  return nil\
    \ if arr.empty?\n  signs = arr.map { |n| n <=> 0 }\n  signs.each_with_index.inject(0)\
    \ do |sum, (sign, i)|\n    sum + sign * arr[i].abs\n  end\nend", "  return if\
    \ arr.empty?\n  sgn = arr.map{|a| a <=> 0}.inject(:*)\n  arr.map{|a| a.abs}.inject(:+)\
    \ * sgn\nend", "  return nil if arr.empty?\n  arr.inject(0) { |sum, num| sum +\
    \ num.abs * arr.uniq.count { |x| x / x.abs } }\nend", "  return nil if arr.empty?\n\
    \  arr.map { |num| num <=> 0 }.inject(:*) * arr.sum\nend", "  arr.each_with_object([0,\
    \ 1]) do |val, (sum, prod)|\n    prod *= val == 0 ? 1 : (val < 0 ? -1 : 1)\n \
    \   sum += val.abs\n  end.reduce(:*)\nend", "  return nil if arr.size == 0\n \
    \ prod = 1\n  sum = 0\n  arr.each do |num|\n    if num > 0\n      prod *= 1\n\
    \      sum += num\n    elsif num < 0\n      prod *= -1\n      sum += -num\n  \
    \  else\n      prod *= 0\n    end\n  end\n  prod * sum\nend", "  return nil if\
    \ arr.empty?\n  arr.map { |el| el.abs }.reduce(:+) * arr.map { |el| el <=> 0 }.reduce(:*)\n\
    end", "  if arr.empty?\n    nil\n  else\n    product = arr.map { |x| x.abs }.reduce(:+)\n\
    \    product * arr.reduce(:*)\n  end\nend", "  return nil if arr.empty?\n  sum\
    \ = 0\n  product = 1\n  arr.each do |n|\n    sum += n.abs\n    if n == 0\n   \
    \   product = 0\n    else\n      product *= n <=> 0\n    end\n  end\n  sum * product\n\
    end", "  res = arr.reduce(0) { |acc, el| acc + el.abs }\n  return nil if res.zero?",
  "  # your code here\nend", "  return if arr.empty?\n  prod = arr.map { |x| x <=>\
    \ 0 }.reduce(:*)\n  arr.map(&:abs).reduce(:+) * prod\nend", "  if arr.empty?\n\
    \    nil\n  else\n    sum = 0\n    product = 1\n    arr.each do |i|\n      sum\
    \ += i.abs\n      if i.zero?\n        product = 0\n      else\n        product\
    \ *= i.positive? ? 1 : -1\n      end\n    end\n    sum * product\n  end\nend",
  "  # CODE HERE\nend", "  return nil if arr.empty?\n  arr.reject { |x| x == 0 }.map\
    \ { |x| x.abs }.inject(:*) * arr.map { |x| x <=> 0 }.inject(:*)\nend", "  # your\
    \ code here\nend", "  sum = 0\n  product = 1\n  return nil if arr.empty?\n  arr.each\
    \ do |num|\n    sum += num.abs\n    product *= [1, -1, 0].include?(num) ? num\
    \ : 1\n  end\n  sum * product\nend", "  return nil if arr.empty?\n  prod = 1\n\
    \  magnitudes = []\n  arr.each do |number|\n    prod *= number <=> 0\n    magnitudes\
    \ << number.abs\n  end\n  magnitudes.reduce(:+) * prod\nend", "  return nil if\
    \ arr.empty?\n  prod = 1\n  arr.each do |int|\n    prod *= int <=> 0\n  end\n\
    \  arr.reduce(0) { |sum, int| sum + int.abs } * prod\nend", "  # write your code\
    \ here\nend", "  arr.empty? ? nil : arr.map { |x| x.abs }.reduce(:+) * arr.map\
    \ { |x| x == 0 ? 0 : x / x.abs }.reduce(:*)\nend", "  return nil if arr.empty?\n\
    \  product = arr.reduce(1) { |a, e| a * sign(e) }\n  product == 0 ? 0 : product\
    \ * arr.reduce(0) { |a, e| a + e.abs }\nend", "    return nil if arr.empty?\n\
    \    arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.to_i }.reduce(:*)\nend",
  "  sum = 0\n  if arr.length == 0\n    return nil\n  else\n    arr.each do |num|\n\
    \      if num > 0\n        sum += num\n      elsif num < 0\n        sum -= num\n\
    \      else\n        sum += 0\n      end\n    end\n  end\n  sum\nend", "  return\
    \ nil if arr.empty?\n  arr.inject(0) { |sum, num| sum + num.abs * product_signs(arr)\
    \ }\nend", "  # Your code goes here\nend", "  return nil if arr.empty?\n  arr.reduce(1)\
    \ { |res, el| res * el.abs * (el == 0 ? 0 : el > 0 ? 1 : -1) }\nend", "  # your\
    \ code here\nend", "  arr.reduce(:*) * arr.map { |a| a.abs }.reduce(:+)\nend",
  "  raise NotImplementedError\nend", "  # nil if empty array\n  return nil if arr.empty?\n\
    \  # array of multiplied signs and magnitudes\n  arr_sign_magnitude = arr.map\
    \ { |num| [num.sign, num.abs] }\n  # product of the signs\n  prod_signs = arr_sign_magnitude.map\
    \ { |num| num[0] }.reduce(:*)\n  # sum of the magnitudes\n  sum_magnitudes = arr_sign_magnitude.map\
    \ { |num| num[1] }.reduce(:+)\n  # product of the signs multiplied by the sum\
    \ of the magnitudes\n  prod_signs * sum_magnitudes\nend", "  if arr.empty?\n \
    \   nil\n  else\n    signs = []\n    magnitudes = []\n    arr.each do |num|\n\
    \      signs << sign_num(num)\n      magnitudes << magnitude_num(num)\n    end\n\
    \    product_signs = signs.inject(:*)\n    sum_magnitudes = magnitudes.inject(:+)\n\
    \    product_signs * sum_magnitudes\n  end\nend", "  return nil if arr.empty?\n\
    \  magnitude = arr.map(&:abs).reduce(:+)\n  signs = arr.map(&:sign).reduce(:*)\n\
    \  magnitude * signs\nend", "  arr.reject { |e| e == 0 }.map(&:abs).reduce(:+)\
    \ *\n    arr.reject { |e| e > 0 }.map(&:abs).reduce(:*)\nend", "  return nil if\
    \ arr.empty?\n  sign = arr.reduce(1) { |acc, v| v <=> 0 } * arr.reduce(1) { |acc,\
    \ v| acc * (v <=> 0) }\n  arr.reduce(0) { |acc, v| acc + v.abs } * sign\nend",
  "  arr.empty? ? nil : arr.map(&:abs).reduce(:+) * arr.map { |el| el <=> 0 }.reduce(:*)\n\
    end", "  arr.map(&:abs).reduce(:+) * arr.map { |e| [1, -1, 0][e <=> 0] }.reduce(:*)\n\
    end", "\treturn nil if arr.empty?\n\tarr.map! { |x| x.abs }\n\tarr.reduce(:+)\
    \ * arr.reduce(:*)\nend", "  return nil if arr.empty?\n  arr.map{|x| x.abs}.sum\
    \ * arr.map{|x| x.zero? ? 0 : x / x.abs}.reduce(:*)\nend", "  return nil if arr.empty?\n\
    \  arr.map(&:abs).sum * arr.map { |e| e > 0 ? 1 : e < 0 ? -1 : 0 }.reduce(:*)\n\
    end", "  # write your code here\nend", "  return nil if arr.empty?\n  prod = arr.reduce(1)\
    \ { |acc, e| e < 0 ? acc * -1 : acc }\n  arr.reduce(0) { |acc, e| acc + e.abs\
    \ } * prod\nend", "  return nil if arr.empty?\n  res = arr.map{|x| x.abs}.inject(:+)\n\
    \  res *= arr.map{|x| x.sign}.inject(:*)\n  res\nend", "  arr.inject(0) { |acc,\
    \ elem| acc + elem.abs } * arr.inject(1) { |acc, elem| acc * elem.sign }\nend",
  "  return nil if arr.empty?\n  arr.map(&:abs).reduce(:+) * arr.select { |x| x.negative?\
    \ }.count\nend", "  return nil if arr.empty?\n  res = 1\n  arr.each do |num|\n\
    \    res *= case num <=> 0\n           when 1 then 1\n           when -1 then\
    \ -1\n           else 0\n           end\n  end\n  res * arr.map(&:abs).reduce(:+)\n\
    end", "  # your code here\nend", "  return nil if arr.empty?\n  arr.map { |num|\
    \ num.abs }.reduce(:+) * arr.select { |num| num != 0 }.map { |num| num.sign }.reduce(:*)\n\
    end", "  return nil if arr.empty?\n  arr.reduce(1) { |acc, el| acc *= el <=> 0\
    \ } * arr.reduce(0) { |acc, el| acc += el.abs }\nend", "  return nil if arr.empty?\n\
    \  sum_abs = arr.reduce(0) { |a, e| a + e.abs }\n  return 0 if arr.all?(&:zero?)\n\
    \  prod_signs = arr.map { |e| e <=> 0 }.reduce(:*)\n  sum_abs * prod_signs\nend",
  "  return nil if arr.empty?\n  signs = []\n  sum = 0\n  arr.each do |num|\n    sum\
    \ += num.abs\n    if num == 0\n      signs << 1\n    elsif num > 0\n      signs\
    \ << 1\n    else\n      signs << -1\n    end\n  end\n  sum * signs.inject(:*)\n\
    end", "  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map\
    \ { |num| num <=> 0 }.reduce(:*)\nend", "  arr.empty? ? nil : arr.map { |num|\
    \ num.positive? ? 1 : num.negative? ? -1 : 0 }.inject(:*) * arr.map(&:abs).inject(:+)\n\
    end", "  return nil if arr.empty?\n  res = 1\n  total = 0\n  arr.each do |num|\n\
    \    if num == 0\n      res = 0\n    elsif num > 0\n      res *= 1\n    else\n\
    \      res *= -1\n    end\n    total += num.abs\n  end\n  total * res\nend", " \
    \ return nil if arr.empty?\n  puts arr.map { |num| (num >= 0 ? 1 : -1) }.reduce(:*)\
    \ * arr.map(&:abs).reduce(:+)\nend", "  return nil if arr.empty?\n  product =\
    \ 1\n  sum = 0\n  arr.each do |n|\n    sum += n.abs\n    product *= n.zero? ?\
    \ 1 : n / n.abs\n  end\n  sum * product\nend", "  return nil if arr.empty?\n \
    \ product = arr.map { |num| num <=> 0 }.reduce(:*)\n  sum = arr.map { |num| num.abs\
    \ }.reduce(:+)\n  product * sum\nend", "  arr.empty? ? nil : arr.map { |x| x.abs\
    \ }.reduce(:*) * arr.reduce(:*)\nend", "  if arr.nil?\n    return nil\n  end\n\
    \  arr_sum = arr.sum\n  arr_prod = arr.reduce(:*)\n  p arr_sum * arr_prod\nend",
  "  if arr.empty?\n    nil\n  else\n    product = 1\n    arr.each do |num|\n    \
    \  product *= num/num.abs\n    end\n    sum = 0\n    arr.each do |num|\n     \
    \ sum += num.abs\n    end\n    sum * product\n  end\nend", "  return nil if arr.empty?\n\
    \  signs = arr.map { |num| num == 0 ? 0 : num / num.abs }\n  arr.map(&:abs).reduce(:+)\
    \ * signs.reduce(:*)\nend", "  arr.inject(1) { |s, n| n.zero? ? 0 : s * (n <=>\
    \ 0) } * arr.map(&:abs).reduce(:+)\nend", "  return nil if arr.empty?\n  arr_signs\
    \ = arr.map{|e| e <=> 0}\n  arr_magn = arr.map{|e| e.abs}\n  return arr_magn.reduce(:+)\
    \ * arr_signs.reduce(:*)\nend", "  total = 1\n  sign = 1\n  arr.each do |value|\n\
    \    if value == 0\n      sign = 1\n    elsif value > 0\n      sign *= 1\n   \
    \ else\n      sign *= -1\n    end\n    total += value.abs\n  end\n  total * sign\n\
    end", "  # your code\nend", "  arr = arr.map { |e| e.sign }\n  s = arr.reduce\
    \ { |acc, v| acc * v }\n  s.nil? ? nil : arr.map { |e| e.abs }.reduce(:+) * s\n\
    end", "  return nil if arr.empty?\n  prod = 1\n  arr.each do |n|\n    prod *=\
    \ n.sign unless n.zero?\n  end\n  arr.map(&:abs).sum * prod\nend", "  if arr.empty?\n\
    \    nil\n  else\n    sum = 0\n    prod = 1\n    arr.each do |i|\n      prod *=\
    \ (i <=> 0) unless i == 0\n      sum += i.abs\n    end\n    sum * prod\n  end\n\
    end", "  return nil if arr.empty?\n  prod = arr.inject(1) { |product, e| product\
    \ * e.sign }\n  sum = arr.inject(0) { |sum, e| sum + e.abs }\n  prod * sum\nend",
  "  unless arr.empty?\n    p arr.map { |e| e.sign * e.abs }.inject(:*)\n  end\nend",
  "    return nil if arr.empty?\n    pos_ints = []\n    neg_ints = []\n    zeros =\
    \ []\n    arr.each do |n|\n        if n < 0\n            neg_ints << n\n     \
    \   elsif n > 0\n            pos_ints << n\n        else\n            zeros <<\
    \ n\n        end\n    end\n    return 0 if (neg_ints.length + pos_ints.length)\
    \ < 1\n    if neg_ints.length % 2 == 0\n        neg_sign = 1\n    else\n     \
    \   neg_sign = -1\n    end\n    pos_sign = 1\n    pos_ints.each do |n|\n     \
    \   pos_sign *= n\n    end\n    neg_ints.each do |n|\n        neg_sign *= n\n\
    \    end\n    sign = pos_sign * neg_sign\n    sum = 0\n    arr.each do |n|\n \
    \       sum += n.abs\n    end\n    sign * sum\nend", "  if arr.empty?\n    return\
    \ nil\n  end\n  total = 0\n  product = 1\n  arr.each do |num|\n    if num < 0\n\
    \      total += num.abs\n      product *= -1\n    elsif num > 0\n      total +=\
    \ num.abs\n      product *= 1\n    else\n      total += num.abs\n      product\
    \ *= 0\n    end\n  end\n  total * product\nend", "  # your code here\nend", " \
    \ return nil if arr.empty?\n  pos = arr.select { |e| e > 0 }.map(&:abs).inject(:+)\n\
    \  neg = arr.select { |e| e < 0 }.map(&:abs).inject(:+)\n  prod = pos.nil? ||\
    \ neg.nil? ? 0 : pos * neg\n  prod * arr.map { |e| e > 0 ? 1 : (e < 0 ? -1 : 0)\
    \ }.inject(:*)\nend", "  return nil if arr.empty?\n  signs = arr.each_with_object([])\
    \ { |e, a| a << e.sign }\n  mags = arr.each_with_object([]) { |e, a| a << e.abs\
    \ }\n  mags.reduce(:+) * signs.reduce(:*)\nend", "  return nil if arr.empty?\n\
    \  sum = 0\n  product = 1\n  arr.each do |x|\n    sum += x.abs\n    product *=\
    \ x == 0 ? 1 : x / x.abs\n  end\n  sum * product\nend", "  # your code here\n\
    end", "  return if arr.empty?\n  arr.reduce(:*) * arr.reduce(0) { |s, n| s + n.abs\
    \ }\nend", "  return if arr.empty?\n  arr.map(&:abs).sum * arr.map(&:sign).reduce(:*)\n\
    end", "\tresult = 1\n\tarr.each do |item|\n\t\tif item > 0\n\t\t\tresult = result\
    \ * 1\n\t\telsif item < 0\n\t\t\tresult = result * -1\n\t\telsif item == 0\n\t\
    \t\tresult = result * 0\n\t\tend\n\tend\n\t\tif arr.length == 0\n\t\t\treturn\
    \ nil\n\t\telse\n\t\t\tarr.inject(0) { |sum, n| sum + n.abs } * result\n\t\tend\n\
    end", "  return nil if arr.empty?\n  sum = 0\n  product = 1\n  arr.each do |x|\n\
    \    if x == 0\n      product *= 1\n    elsif x > 0\n      product *= 1\n    \
    \  sum += x\n    else\n      product *= -1\n      sum += x.abs\n    end\n  end\n\
    \  sum * product\nend", "  return nil if arr.empty?\n  sum_magn = 0\n  prod_sign\
    \ = 1\n  arr.each do |num|\n    sum_magn += num.abs\n    prod_sign *= num <=>\
    \ 0\n  end\n  sum_magn * prod_sign\nend", "  return nil if arr.empty?\n  return\
    \ 0 if arr.all? { |x| x == 0 }\n  p = 1\n  arr.each { |i| p *= i.positive? ? 1\
    \ : -1 }\n  arr.map(&:abs).reduce(:+) * p\nend", "  return nil if arr.empty?\n\
    \  arr.map(&:abs).reduce(:+) * arr.map(&:positive?).product\nend", "  raise NotImplementedError\n\
    end", "  # your code here\nend", "  #YOUR CODE GOES HERE\nend", "  return nil\
    \ if arr.empty?\n  sum = 0\n  sign = 1\n  arr.each do |n|\n    sum += n.abs\n\
    \    sign *= n <=> 0\n  end\n  sum * sign\nend", end, "  return nil if arr.empty?\n\
    \  arr.each_with_object([1, 0]) do |e, a|\n    a[0] *= e.zero? ? 0 : e / e.abs\n\
    \    a[1] += e.abs\n  end.reduce(:*)\nend", "  nil if arr.empty?\n  arr.map {\
    \ |e| e.sign }.reduce(:*) * arr.reduce(0) { |sum, i| sum + i.abs }\nend", "  return\
    \ nil if arr.empty?\n  product = 1\n  sum = 0\n  arr.each do |x|\n    if x > 0\n\
    \      product *= 1\n      sum += x\n    elsif x < 0\n      product *= -1\n  \
    \    sum += x * -1\n    end\n  end\n  product * sum\nend", "  return if arr.empty?\n\
    \  arr.map { |el| el.abs }.reduce(:+) * arr.reduce(1) { |acc, el| acc * (el <=>\
    \ 0) }\nend", "  arr.empty? ? nil : arr.map(&:abs).sum * arr.map(&:sign).reduce(:*)\n\
    end", "  return nil if arr.empty?\n  return 0 if arr.uniq == [0]\n  arr.map {\
    \ |n| n.abs }.reduce(:+) * arr.map { |n| n == 0 ? 1 : n <=> 0 }.reduce(:*)\nend",
  "  sum = 0\n  sign = 1\n  unless arr.empty?\n    arr.each do |e|\n      if e > 0\n\
    \        sum += e\n      elsif e < 0\n        sum += e.abs\n        sign *= -1\n\
    \      end\n    end\n    return sum * sign\n  end\nend", "  sum_of_magnitude_by_product_of_signs(arr.sum{|x|\
    \ x.abs},\n                                       arr.map{|x| sign(x)}.inject(:*))\n\
    end", "  return nil if arr.empty?\n  return 0 if arr.all?(&:zero?)\n  sign_prod\
    \ = arr.inject(1) { |acc, i| acc *= i.positive? ? 1 : -1 }\n  sign_prod * arr.map(&:abs).inject(:+)\n\
    end", "  return nil if arr.empty?\n  signs = arr.map { |x| x <=> 0 }\n  signs.inject(:*)\
    \ * arr.map(&:abs).inject(:+)\nend", "  arr.inject(0) { |sum, n| sum + n.abs *\
    \ (n == 0 ? 1 : n.sign) }\nend", "  prod = arr.reduce(1) { |acc, elem| acc *=\
    \ (elem <=> 0) }\n  arr.reduce(0) { |acc, elem| acc += (elem.abs * prod) }\nend",
  "  # your code here\nend", "\tarr.inject(0) { |res, elem| res + elem.abs } * arr.inject(1)\
    \ { |res, elem| res * (elem == 0 ? 1 : elem / elem.abs) }\nend", "  # Your code\
    \ here\nend", "  if arr.length == 0\n    nil\n  else\n    summ = 0\n    product\
    \ = 1\n    arr.each do |num|\n      if num == 0\n        product *= 1\n      elsif\
    \ num > 0\n        product *= 1\n        summ += num\n      else\n        product\
    \ *= -1\n        summ += num.abs\n      end\n    end\n    summ * product\n  end\n\
    end", "  return nil if arr.empty?\n  return 0 if arr.all?(&:zero?)\n  arr.map(&:abs).reduce(:+)\
    \ * arr.map(&:sign).reduce(:*)\nend", "  return nil if arr.empty?\n  # \u0440\u0435\
    \u0448\u0435\u043D\u0438\u0435 \u043D\u0438\u0436\u0435 \u0432\u0430\u043B\u0438\
    \u0434\u043D\u043E \u0438 \u043D\u0435\u043F\u043B\u043E\u0445\u043E\u0435, \u043D\
    \u043E \u043D\u0435 \u043F\u0440\u043E\u0445\u043E\u0434\u0438\u0442 \u043F\u0440\
    \u043E\u0432\u0435\u0440\u043A\u0443 \u043D\u0430 codeabbey\n  # (\u043F\u043E\
    \u0447\u0435\u043C\u0443-\u0442\u043E \u043D\u0435 \u0432\u044B\u0447\u0438\u0441\
    \u043B\u044F\u0435\u0442\u0441\u044F \u043A\u043E\u0440\u0440\u0435\u043A\u0442\
    \u043D\u043E)\n  # arr.map { |item| item.abs }.reduce(:+) * arr.map { |item| item\
    \ > 0 ? 1 : item == 0 ? 0 : -1 }.reduce(:*)\n  numbers = []\n  signs = []\n  arr.each\
    \ do |item|\n    numbers << item.abs\n    signs << (item > 0 ? 1 : item == 0 ?\
    \ 0 : -1)\n  end\n  numbers.reduce(:+) * signs.reduce(:*)\nend", "  if arr.empty?\n\
    \    return nil\n  else\n    arr.map!{|x| x * sign(x)}\n    arr.inject(:+)\n \
    \ end\nend", "  return nil if arr.empty?\n  magnitudes = arr.map { |n| n.abs }\n\
    \  products = arr.reduce(1) { |sum, n| sum * n.sign }\n  magnitudes.reduce(:+)\
    \ * products\nend", "  arr.empty? ? nil : arr.map { |n| n.abs }.sum * arr.map\
    \ { |n| n <=> 0 }.inject(:*)\nend", "  if arr.empty?\n    return nil\n  end\n\
    \  all_sums = []\n  arr.each do |n|\n    if n > 0\n      sign = 1\n    elsif n\
    \ < 0\n      sign = -1\n    else\n      sign = 0\n    end\n    all_sums << sign\n\
    \  end\n  all_prods = all_sums.inject(:*)\n  if all_prods == 0\n    return 0\n\
    \  end\n  arr.map! { |n| n.abs }\n  arr.inject(:+) * all_prods\nend", "  arr.map\
    \ { |x| [x.zero? ? 0 : x.sign * x.abs, x.zero? ? 1 : x.sign] }\n      .reduce([0,\
    \ 1]) { |a, e| [a[0] + e[0], a[1] * e[1]] }\n      .inject(:*)\nend", "  arr.empty?\
    \ ? nil :\n    arr.map(&:abs).reduce(:+) *\n    arr.map { |e| e > 0 ? 1 : e <\
    \ 0 ? -1 : 0 }.reduce(:*)\nend", "  arr.empty? ? nil : arr.reduce(1) { |r, e|\
    \ r * e.abs * e.sign }\nend", "  arr.each do |n|\n    if n == 0\n      return\
    \ nil\n    elsif n < 0\n      return n * n\n    elsif n > 0\n      return n *\
    \ n\n    end\n  end\nend", "  # your code here\nend", "  return nil if arr.empty?\n\
    \  sum_signs = arr.map { |n| n > 0 ? 1 : n < 0 ? -1 : 0 }.reduce(:*)\n  arr.map\
    \ { |n| n.abs }.reduce(:+) * sum_signs\nend", "  if arr.empty?\n    return nil\n\
    \  else\n    arr.map { |i| i.abs }.reduce(:+) * arr.select { |i| i != 0 }.reduce(:*)\n\
    \  end\nend", "  prod = 1\n  arr.each do |x|\n    prod *= x / x.abs if x.abs !=\
    \ 0\n  end\n  return nil if arr.empty?\n  arr.reduce(0) { |sum, n| sum + n.abs\
    \ } * prod\nend", "  signs = arr.map { |i| i <=> 0 }\n  arr.map(&:abs).reduce(:+)\
    \ * signs.reduce(:*) unless arr.empty?\nend", "  arr.empty? ? nil : (1..arr.size).to_a.inject(:*)\
    \ * arr.inject(:+)\nend", "  if arr.empty?\n    return nil\n  else\n    sum =\
    \ 0\n    signs = 1\n    arr.each do |el|\n      sum += el.abs\n      if el > 0\n\
    \        signs *= 1\n      elsif el < 0\n        signs *= -1\n      else\n   \
    \     signs *= 0\n      end\n    end\n    return sum * signs\n  end\nend", "\t\
    arr.map { |x| x.abs }.reduce(:+) * (arr.map { |x| x >= 0 ? 1 : -1 }.reduce(:*)\
    \ || 1)\nend", "  arr.reduce(1, :*) * arr.map { |i| i.abs }.reduce(:+)\nend",
  "  # your code here\nend", "  return nil if arr.empty?\n  signs = arr.map { |num|\
    \ num <=> 0 }\n  magnitudes = arr.map(&:abs)\n  magnitudes.reduce(:+) * signs.reduce(:*)\n\
    end", "  # TODO: implement the method\nend", "  arr.empty? ? nil : prod_signs_iter(arr,\
    \ 1, 1)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
