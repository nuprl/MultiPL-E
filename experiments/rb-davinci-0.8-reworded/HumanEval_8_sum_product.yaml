name: HumanEval_8_sum_product
language: rb
prompt: "# For a given array of integers, return an array consisting of a sum and\
  \ a product of all the integers in an array.\n# Empty sum should be equal to 0 and\
  \ empty product should be equal to 1.\n# >>> sum_product.call([])\n# [0, 1]\n# >>>\
  \ sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n\
  \    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n\
  \    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0],\
  \ candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n\
  \    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"
completions: ["  if numbers.empty?\n    return [0, 1]\n  else\n    sum = numbers.reduce(:+)\n\
    \    product = numbers.reduce(:*)\n    return [sum, product]\n  end\nend", " \
    \ [\n    numbers.sum,\n    numbers.inject(:*) || 1\n  ]\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  total = numbers.sum\n  product = numbers.reduce(:*)\n\
    \  if product == nil\n    product = 1\n  end\n  [total, product]\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n    product *=\
    \ num\n  end\n  [sum, product]\nend", "  # [numbers.sum, numbers.inject(:*)]\n\
    end", "  if numbers.length == 0\n    return [0, 1]\n  else\n    sum = 0\n    product\
    \ = 1\n    numbers.each do |x|\n      sum += x\n      product *= x\n    end\n\
    \    return [sum, product]\n  end\nend", "  # numbers.inject([0, 1]) do |memo,\
    \ num|\n  #   memo[0] += num\n  #   memo[1] *= num\n  #   memo\n  # end\n  [numbers.reduce(0,\
    \ :+), numbers.reduce(1, :*)]\nend", "    sum = 0\n    product = 1\n    numbers.each\
    \ do |number|\n        sum += number\n        product *= number\n    end\n   \
    \ [sum, product]\nend\np sum_product([1, 2, 3, 4])", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  [numbers.sum, numbers.reduce(:*)]\n\
    end", "  numbers.inject([0, 1]) do |result, number|\n    [result[0] + number,\
    \ result[1] * number]\n  end\nend", "  numbers.reduce([0, 1]) { |sum_prod, num|\
    \ [sum_prod[0] + num, sum_prod[1] * num] }\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  numbers.empty? ? [0, 1] : [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.sum, numbers.reduce(:*)]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend\nputs sum_product([1, 2, 3, 4])"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
