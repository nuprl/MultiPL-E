name: HumanEval_8_sum_product
language: rb
prompt: "# For a given array of integers, return an array consisting of a sum and\
  \ a product of all the integers in an array.\n# Empty sum should be equal to 0 and\
  \ empty product should be equal to 1.\n# >>> sum_product.call([])\n# [0, 1]\n# >>>\
  \ sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n\
  \    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n\
  \    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0],\
  \ candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n\
  \    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"
completions: ["  if numbers.empty?\n    return [0, 1]\n  else\n    sum = numbers.reduce(:+)\n\
    \    product = numbers.reduce(:*)\n    return [sum, product]\n  end\nend", " \
    \ [\n    numbers.sum,\n    numbers.inject(:*) || 1\n  ]\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  total = numbers.sum\n  product = numbers.reduce(:*)\n\
    \  if product == nil\n    product = 1\n  end\n  [total, product]\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n    product *=\
    \ num\n  end\n  [sum, product]\nend", "  # [numbers.sum, numbers.inject(:*)]\n\
    end", "  if numbers.length == 0\n    return [0, 1]\n  else\n    sum = 0\n    product\
    \ = 1\n    numbers.each do |x|\n      sum += x\n      product *= x\n    end\n\
    \    return [sum, product]\n  end\nend", "  # numbers.inject([0, 1]) do |memo,\
    \ num|\n  #   memo[0] += num\n  #   memo[1] *= num\n  #   memo\n  # end\n  [numbers.reduce(0,\
    \ :+), numbers.reduce(1, :*)]\nend", "    sum = 0\n    product = 1\n    numbers.each\
    \ do |number|\n        sum += number\n        product *= number\n    end\n   \
    \ [sum, product]\nend\np sum_product([1, 2, 3, 4])", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  [numbers.sum, numbers.reduce(:*)]\n\
    end", "  numbers.inject([0, 1]) do |result, number|\n    [result[0] + number,\
    \ result[1] * number]\n  end\nend", "  numbers.reduce([0, 1]) { |sum_prod, num|\
    \ [sum_prod[0] + num, sum_prod[1] * num] }\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  numbers.empty? ? [0, 1] : [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.sum, numbers.reduce(:*)]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend\nputs sum_product([1, 2, 3, 4])", "  sum = 0\n \
    \ product = 1\n  numbers.each do |num|\n    sum += num\n    product *= num\n \
    \ end\n  [sum, product]\nend", end, "  [numbers.sum, numbers.product]\nend", " \
    \ sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n  if numbers.length\
    \ > 0\n    numbers.each do |number|\n      sum += number\n      product *= number\n\
    \    end\n  end\n  [sum, product]\nend", "  numbers.reduce([0, 1]) { |acc, n|\
    \ [acc[0] + n, acc[1] * n] }\nend", "  # TODO\nend", "  sum = 0\n  product = 1\n\
    \  numbers.each do |n|\n    sum += n\n    product *= n\n  end\n  [sum, product]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |n|\n    sum += n\n    product\
    \ *= n\n  end\n  [sum, product]\nend", "\treturn [0, 1] if numbers.empty?\n\t\
    [numbers.sum, numbers.inject(:*)]\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |number|\n    sum += number\n    product *= number\n  end\n  [sum, product]\n\
    end", "  product = 1\n  sum = 0\n  numbers.each do |number|\n    product *= number\n\
    \    sum += number\n  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n\
    \  numbers.each do |number|\n    sum += number\n    product *= number\n  end\n\
    \  return [sum, product]\nend", "    sum = 0\n    product = 1\n    numbers.each\
    \ do |i|\n        sum += i\n        product *= i\n    end\n    return [sum, product]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |n|\n    sum += n\n    product\
    \ *= n\n  end\n  [sum, product]\nend", "  product = 1\n  sum = 0\n  numbers.each\
    \ do |number|\n    product *= number\n    sum += number\n  end\n  [sum, product]\n\
    end", "  new_array = [0, 1]\n  if numbers.size > 0\n    new_array[0] = numbers.reduce(:+)\n\
    \    new_array[1] = numbers.reduce(:*)\n  end\n  new_array\nend", "  sum = 0\n\
    \  product = 1\n  numbers.each do |number|\n    sum += number\n    product *=\
    \ number\n  end\n  [sum, product]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  [sum, product]\nend", "  # sum = 0\n  # product\
    \ = 1\n  # numbers.each do |num|\n  #   sum += num\n  #   product *= num\n  #\
    \ end\n  # [sum, product]\n  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1,\
    \ :*)\n  [sum, product]\nend", "  {\n    sum: numbers.inject(0, :+),\n    product:\
    \ numbers.inject(1, :*)\n  }\nend", "  [numbers.sum, numbers.reduce(:*)]\nend",
  "  sum = 0\n  prod = 1\n  numbers.each do |i|\n    sum += i\n    prod *= i\n  end\n\
    \  [sum, prod]\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  return [sum, product]\nend",
  "  # TODO: calculate sum and product of numbers and return them in an array\n  numbers\
    \ = numbers.map { |n| n.to_i }\n  if numbers.empty?\n    sum = 0\n    product\
    \ = 1\n  else\n    sum = numbers.inject(:+)\n    product = numbers.inject(:*)\n\
    \  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each do |i|\n\
    \    sum += i\n    product *= i\n  end\n  [sum, product]\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  # your code here\nend", "  if numbers.empty?\n\
    \    [0, 1]\n  else\n    [numbers.sum, numbers.inject(:*)]\n  end\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n    product *=\
    \ num\n  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |number|\n    sum += number\n    product *= number\n  end\n  [sum, product]\n\
    end", "  sum = 0\n  product = 1\n  if numbers.count == 0\n    return [sum, product]\n\
    \  else\n    numbers.each do |i|\n      sum += i\n      product *= i\n    end\n\
    \    return [sum, product]\n  end\nend", "  [numbers.sum, numbers.inject(&:*)]\n\
    end", "  [numbers.sum, numbers.inject(:*)]\nend", "  total = numbers.reduce(0)\
    \ { |sum, x| sum + x }\n  product = numbers.reduce(1) { |product, x| product *\
    \ x }\n  [total, product]\nend", "  sum = 0\n  product = 1\n  numbers.each do\
    \ |number|\n    sum += number\n    product *= number\n  end\n  [sum, product]\n\
    end", "    #TODO: return an array containing the sum and product of all integers\
    \ in an array\n    [numbers.sum, numbers.inject(:*)]\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  return 0 if numbers.empty?\n  sum = numbers.reduce(:+)\n  product = numbers.reduce(:*)\n\
    \  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  [sum, product]\nend", "  numbers.empty?\
    \ ? [0, 1] : [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  return [0, 1]\
    \ if numbers.empty?\n  sum = numbers.reduce(:+)\n  product = numbers.reduce(:*)\n\
    \  [sum, product]\nend", "  numbers.empty? ? [0, 1] : [numbers.sum, numbers.reduce(:*)]\n\
    end", "  numbers.empty? ? [0, 1] : [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  [numbers.sum, numbers.reduce(:*)]\n\
    end", "  return [0, 1] if numbers.empty?\n  [numbers.sum, numbers.reduce(:*)]\n\
    end", "  [numbers.sum, numbers.reduce(:*)]\nend", "  product = numbers.inject(1,\
    \ :*)\n  product = 1 if product.nil?\n  sum = numbers.inject(0, :+)\n  sum = 0\
    \ if sum.nil?\n  [sum, product]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  if numbers.empty?\n    [0, 1]\n  else\n    [numbers.sum, numbers.inject(:*)]\n\
    \  end\nend", "  sum = 0\n  numbers.each do |number|\n    sum += number\n  end\n\
    \  product = 1\n  numbers.each do |number|\n    product *= number\n  end\n  [sum,\
    \ product]\nend", "  return [0, 1] if numbers.empty?\n  numbers.inject([0, 1])\
    \ { |result, value| [result[0] + value, result[1] * value] }\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  [sum, product]\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |number|\n    sum += number\n    product *= number\n  end\n  [sum, product]\n\
    end", "  total = numbers.sum\n  product = numbers.inject(:*)\n  [total, product]\n\
    end", "\treturn [0, 1] if numbers.empty?\n\tnumbers.reduce([0, 1]) do |acc, i|\n\
    \t\tacc[0] += i\n\t\tacc[1] *= i\n\t\tacc\n\tend\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "\tputs(numbers.reduce(:+)).to_s + \",\" + (numbers.reduce(:*)).to_s\n\
    end\nsum_product([1, 2, 3, 4])\nsum_product([])", "    [numbers.sum, numbers.inject(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  [sum, product]\nend\nputs 'Test for sum_product'\n\
    p sum_product([]) == [0, 1]\np sum_product([1, 2, 3, 4]) == [10, 24]", "  result\
    \ = []\n  result << numbers.sum\n  result << numbers.reduce(:*)\n  result\nend",
  "    sum = 0\n    product = 1\n    numbers.each do |n|\n        sum += n\n     \
    \   product *= n\n    end\n    return [sum, product]\nend", "\t[numbers.sum, numbers.inject(:*)]\n\
    end", "  numbers.reduce([0, 1]) { |memo, num| memo[0] += num; memo[1] *= num;\
    \ memo }\nend", "  [numbers.sum, numbers.reduce(:*)]\nend", "  # code here\nend",
  "    [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  sum = 0\n  product = 1\n\
    \  numbers.each do |x|\n    sum += x\n    product *= x\n  end\n  [sum, product]\n\
    end", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  p numbers.sum\n  p\
    \ numbers.inject { |product, n| product * n }\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  [numbers.sum, numbers.inject(:*)]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  numbers.empty? ? [0, 1] : [numbers.sum, numbers.reduce(:*)]\nend", " \
    \ return [0, 1] if numbers.empty?\n  [numbers.sum, numbers.reduce(:*)]\nend",
  "  numbers.inject([0, 1]) { |acc, num| [acc[0] + num, acc[1] * num] }\nend", " \
    \ sum = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n    product\
    \ *= num\n  end\n  [sum, product]\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  return [sum, product]\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  [numbers.sum, numbers.inject(:*)]\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |i|\n    sum += i\n    product *= i\n\
    \  end\n  [sum, product]\nend", "  if numbers.empty?\n    [0, 1]\n  else\n   \
    \ [numbers.sum, numbers.reduce(:*)]\n  end\nend", "  [numbers.sum, numbers.product]\n\
    end", "  [\n    numbers.inject(0) { |a, e| a + e },\n    numbers.inject(1) { |a,\
    \ e| a * e }\n  ]\nend", "  [sum(numbers), product(numbers)]\nend", '  # numbers
    = []', "    return [0, 1] if numbers.empty?\n    [numbers.sum, numbers.reduce(:*)]\n\
    end", "  [numbers.sum, numbers.inject(:*)]\nend", "    product = numbers.inject(1)\
    \ { |product, number| product * number }\n    sum = numbers.inject(0) { |sum,\
    \ number| sum + number }\n    [sum, product]\nend", "\tsum = 0\n\tproduct = 1\n\
    \tnumbers.each do |num|\n\t\tsum += num\n\t\tproduct *= num\n\tend\n\t[sum, product]\n\
    end", "  return [0, 1] if numbers.length == 0\n  sum = numbers.reduce(:+)\n  product\
    \ = numbers.reduce(:*)\n  [sum, product]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.sum, numbers.inject(:*)]\nend", "  sum = 0\n  product = 1\n\
    \  numbers.each do |number|\n    sum += number\n    product *= number\n  end\n\
    \  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each do |i|\n  \
    \  sum += i\n    product *= i\n  end\n  [sum, product]\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "\treturn [0, 1] if numbers.empty?\n\t[numbers.sum,\
    \ numbers.inject(:*)]\nend", "  return [0, 1] if numbers.empty?\n  numbers.inject([0,\
    \ 1]) do |memo, i|\n    [memo[0] + i, memo[1] * i]\n  end\nend", "  #your code\
    \ here\nend", "  sum = 0\n  product = 1\n  numbers.each do |n|\n    sum += n\n\
    \    product *= n\n  end\n  return [sum, product]\nend", "  [numbers.sum, numbers.reduce(:*)]\n\
    end", "  numbers.sum()\n  numbers.reduce(:*)\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  #1. The sum of the numbers\n  #2. The product of the numbers\n  # Sum\
    \ = 1+2+3+4\n  # Product = 1*2*3*4\n  sum = 0\n  product = 1\n  for i in numbers\n\
    \    sum += i\n    product *= i\n  end\n  return [sum, product]\nend", "  return\
    \ [0, 1] if numbers.empty?\n  numbers.reduce([0, 1]) do |memo, number|\n    memo[0]\
    \ += number\n    memo[1] *= number\n    memo\n  end\nend", "    [numbers.sum,\
    \ numbers.inject(:*)]\nend", "  [numbers.sum, numbers.inject(:*)]\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  [sum, product]\nend", "  return [0, 1] if numbers.empty?\n\
    \  sum = numbers.reduce(:+)\n  product = numbers.reduce(:*)\n  [sum, product]\n\
    end", "  if numbers.empty?\n    [0, 1]\n  else\n    [numbers.sum, numbers.reduce(:*)]\n\
    \  end\nend", "  sum = 0\n  prod = 1\n  numbers.each do |num|\n    sum += num\n\
    \    prod *= num\n  end\n  [sum, prod]\nend", "\tsum = 0\n\tnumbers.each { |n|\
    \ sum += n }\n\tproduct = 1\n\tnumbers.each { |n| product *= n }\n\treturn [sum,\
    \ product]\nend", "  sum = 0\n  prod = 1\n  numbers.each do |num|\n    sum +=\
    \ num\n    prod *= num\n  end\n  [sum, prod]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n   \
    \ product *= num\n  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n \
    \ numbers.each do |num|\n    sum += num\n    product *= num\n  end\n  [sum, product]\n\
    end", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend", "  sum = 0\n  prod = 1\n  numbers.each do |x|\n\
    \    sum += x\n    prod *= x\n  end\n  [sum, prod]\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each do |num|\n\
    \    sum += num\n    product *= num\n  end\n  [sum, product]\nend", "  sum = 0\n\
    \  product = 1\n  numbers.each do |number|\n    sum += number\n    product *=\
    \ number\n  end\n  [sum, product]\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "    n = numbers.size\n    if n == 0\n        return [0, 1]\n    else\n\
    \        sum = 0\n        product = 1\n        for i in 0..n-1\n            sum\
    \ += numbers[i]\n            product *= numbers[i]\n        end\n        return\
    \ [sum, product]\n    end\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  [numbers.sum, numbers.product]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  product = numbers.inject(1) { |result, number| result * number }\n  sum\
    \ = numbers.inject(0) { |result, number| result + number }\n  [sum, product]\n\
    end", "  return [0, 1] if numbers.empty?\n  [numbers.sum, numbers.reduce(:*)]\n\
    end", "  [numbers.sum, numbers.inject(&:*)]\nend", "  sum = 0\n  product = 1\n\
    \  numbers.each do |num|\n    sum += num\n    product *= num\n  end\n  [sum, product]\n\
    end", "  [numbers.sum, numbers.inject(:*)]\nend", "  #TODO: implement this!\n\
    \  [numbers.inject(0, :+), numbers.inject(1, :*)]\nend", "  # p numbers.inject(:*)\n\
    \  # p numbers.inject(:+)\n  [numbers.inject(:+), numbers.inject(:*)]\nend\np\
    \ sum_product([])\np sum_product([1, 2, 3, 4])", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  numbers.reduce([0, 1]) { |s_p, n| [s_p[0] + n, s_p[1] * n] }\nend", " \
    \ # YOUR CODE HERE\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  [sum, product]\nend", "  if\
    \ numbers.length == 0\n    return [0, 1]\n  end\n  sum = 0\n  product = 1\n  numbers.each\
    \ do |num|\n    sum += num\n    product *= num\n  end\n  return [sum, product]\n\
    end", "\t# your code here\n\tsum = 0\n\tproduct = 1\n\tnumbers.each do |num|\n\
    \t\tsum += num\n\t\tproduct *= num\n\tend\n\treturn [sum, product]\nend", "  [numbers.sum,\
    \ numbers.inject(:*)]\nend", "  [numbers.sum, numbers.inject(:*)]\nend", "  #\
    \ TODO: your code goes here\n  [numbers.reduce(:+), numbers.reduce(:*)]\nend",
  "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  numbers.reduce([0, 1]) { |(sum,\
    \ product), number| [sum + number, product * number] }\nend", "  numbers.inject([0,\
    \ 1]) { |result, n| result[0] += n; result[1] *= n; result }\nend", "  sum = 0\n\
    \  product = 1\n  numbers.each do |num|\n    sum += num\n    product *= num\n\
    \  end\n  [sum, product]\nend", "  [numbers.sum, numbers.reduce(:*)]\nend", " \
    \ [numbers.sum, numbers.reduce(:*)]\nend", "  # create a local variable sum to\
    \ store sum of numbers\n  sum = 0\n  # create a local variable product to store\
    \ product of numbers\n  product = 1\n  # loop through each number in numbers\n\
    \  numbers.each do |number|\n    # add each number to sum\n    sum += number\n\
    \    # multiply each number to product\n    product *= number\n  end\n  # return\
    \ array of sum and product\n  [sum, product]\nend", "  return [0, 1] if numbers.empty?\n\
    \  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  [numbers.sum, numbers.reduce(:*)]\n\
    end", "  raise ArgumentError if numbers.empty?\n  sum = numbers.reduce(:+)\n \
    \ product = numbers.reduce(:*)\n  [sum, product]\nend", "    sum = 0\n    product\
    \ = 1\n    for i in numbers\n        sum += i\n        product *= i\n    end\n\
    \    [sum, product]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend",
  "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  {\n    sum: numbers.sum,\n\
    \    product: numbers.reduce(:*)\n  }\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  return [0, 1] if numbers.empty?\n  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |n|\n    sum += n\n    product\
    \ *= n\n  end\n  [sum, product]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  if numbers.empty?\n    [0, 1]\n  else\n    [numbers.sum, numbers.reduce(:*)]\n\
    \  end\nend", "  [numbers.sum, numbers.inject(:*)]\nend", "  if numbers.empty?\n\
    \    [0, 1]\n  else\n    [numbers.sum, numbers.reduce(:*)]\n  end\nend", "\traise\
    \ NotImplementedError\nend", "  [numbers.sum, numbers.inject(:*)]\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  [sum, product]\nend", "  [numbers.sum, numbers.reduce(:*)]\n\
    end", "  [numbers.sum, numbers.product]\nend", "  {sum: numbers.inject(0) { |memo,\
    \ number| memo + number }, product: numbers.inject(1) { |memo, number| memo *\
    \ number }}\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n   \
    \ sum += number\n    product *= number\n  end\n  return [sum, product]\nend",
  "  numbers.empty? ? [0, 1] : [numbers.sum, numbers.reduce(:*)]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
