name: HumanEval_6_parse_nested_parens
language: rb
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\"\
  )\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n\
  \    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"\
  (()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"\
  () (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"\
  ))\n  end\nend\n"
completions: ["  paren_string.split(\" \").each_with_object([]) do |paren_group, levels|\n\
    \    levels << parse_parens(paren_group).map(&:length).max\n  end\nend", "  paren_string.split('\
    \ ').map { |paren_group| num_levels_of_nesting(paren_group) }\nend", "  # TODO:\
    \ Implement this!\nend", "  paren_string.split.map do |group|\n    paren_stack\
    \ = []\n    max_nest = 0\n    group.chars.each do |paren|\n      if paren == '('\n\
    \        paren_stack.push(paren)\n        max_nest = [max_nest, paren_stack.length].max\n\
    \      else\n        paren_stack.pop\n      end\n    end\n    max_nest\n  end\n\
    end", "  result = []\n  paren_string.split(\" \").each do |paren|\n    paren_stack\
    \ = []\n    count = 0\n    paren.each_char do |char|\n      if char == \"(\"\n\
    \        paren_stack.push(char)\n        count += 1\n      elsif char == \")\"\
    \n        paren_stack.pop\n        count += 1\n      end\n    end\n    result.push(count)\n\
    \  end\n  result\nend", "  max_level = 0\n  current_level = 0\n  result = []\n\
    \  paren_string.chars.each do |paren|\n    case paren\n    when '('\n      current_level\
    \ += 1\n      max_level = current_level if current_level > max_level\n    when\
    \ ')'\n      current_level -= 1\n    when ' '\n      result << max_level\n   \
    \   max_level = 0\n      current_level = 0\n    end\n  end\n  result << max_level\n\
    end", "  # paren_string is a string with the format like \"(()()) ((())) () ((())()())\"\
    \n  # splitting on spaces and map through each group\n  paren_string.split(\"\
    \ \").map do |group|\n    paren_count = 0\n    # loop through each char and increment\
    \ counter when \"(\"\n    # max value is the maximum value of paren_count\n  \
    \  group.chars.map { |char| paren_count += 1 if char == \"(\" }.max\n  end\nend",
  "  paren_string.split(' ').map { |group| find_max_nested_parens(group) }\nend",
  "  return [] if paren_string.nil?\n  num_of_parens = paren_string.scan(/\\(/).size\n\
    \  return [] if num_of_parens.zero?\n  # this hash will store depth of nestings\
    \ for each closing parentheses.\n  # We will use closing parens because they will\
    \ have to match an opening parenthesis before them.\n  # Only then we can say\
    \ that we have a valid match.\n  results = []\n  paren_hash = {}\n  paren_string.split(\"\
    \ \").each do |paren_substr|\n    depth = 0\n    paren_substr.chars.each do |ch|\n\
    \      if ch == \"(\"\n        depth += 1\n      elsif ch == \")\"\n        paren_hash[depth]\
    \ = (paren_hash[depth] || 0) + 1\n        depth -= 1\n      end\n    end\n   \
    \ results << paren_hash.keys.max || 0\n    paren_hash = {}\n  end\n  results\n\
    end", "  paren_string.split.map { |group|\n    nested_depth = 0\n    max_nested_depth\
    \ = 0\n    group.chars.each { |char|\n      nested_depth += 1 if char == '('\n\
    \      nested_depth -= 1 if char == ')'\n      max_nested_depth = nested_depth\
    \ if nested_depth > max_nested_depth\n    }\n    max_nested_depth\n  }\nend",
  "\t# Fill in your code here\nend", "  # TODO: Insert your solution here\nend\n```",
  "  paren_string.split(' ').map { |item| item.chars.select { |i| i == '(' }.size\
    \ }\nend", "  max_levels = paren_string.split(\" \").map do |parens|\n    parens.chars.reduce(0)\
    \ do |max_level, char|\n      if char == \"(\"\n        max_level += 1\n     \
    \ elsif char == \")\"\n        max_level\n      end\n    end\n  end\nend", " \
    \ # TODO: implement this method\nend", "  i = 0\n  parenthesis_depth = []\n  while\
    \ i < paren_string.length\n    depth = 0\n    if paren_string[i] == \"(\"\n  \
    \    depth += 1\n      i += 1\n      while i < paren_string.length\n        if\
    \ paren_string[i] == \"(\"\n          depth += 1\n        elsif paren_string[i]\
    \ == \")\"\n          depth -= 1\n        end\n        i += 1\n        break if\
    \ depth == 0\n      end\n    else\n      i += 1\n    end\n    parenthesis_depth\
    \ << depth\n  end\n  parenthesis_depth\nend", "  count = 0\n  curr_max = 0\n \
    \ output = []\n  string = paren_string.split(\" \")\n  for i in 0..string.length\
    \ - 1\n    for j in 0..string[i].length - 1\n      if string[i][j] == \"(\"\n\
    \        count += 1\n        curr_max = count if count > curr_max\n      elsif\
    \ string[i][j] == \")\"\n        count -= 1\n      end\n    end\n    output <<\
    \ curr_max\n    curr_max = 0\n    count = 0\n  end\n  return output\nend", "\t\
    paren_groups = paren_string.split(\" \")\n\tmax_depth = []\n\tparen_groups.each\
    \ do |group|\n\t\tdepth = 0\n\t\tmax_depth_current = 0\n\t\tgroup.each_char do\
    \ |character|\n\t\t\tif character == \"(\"\n\t\t\t\tdepth += 1\n\t\t\t\tmax_depth_current\
    \ = depth if depth > max_depth_current\n\t\t\telsif character == \")\"\n\t\t\t\
    \tdepth -= 1\n\t\t\tend\n\t\tend\n\t\tmax_depth << max_depth_current\n\tend\n\t\
    return max_depth\nend", "  deepest_nesting = paren_string.split.map do |group|\n\
    \    parse_nested_parens_helper(group, 0, 0)\n  end\n  deepest_nesting\nend",
  "  paren_string.split(\" \").map do |string|\n    string.chars.reduce(0) do |depth,\
    \ char|\n      char == \"(\" ? depth + 1 : depth - 1\n    end\n  end\nend", " \
    \ level_count = []\n  paren_string.split.each do |paren|\n    level_count << paren.scan(/\\\
    (/).count\n  end\n  level_count\nend", "  matches = paren_string.scan(/\\(([^()]*|[^()]*(\\\
    ([^()]*\\))*[^()]*)\\)/)\n  matches.map { |match| max_level(match[0]) }\nend",
  "  paren_string.split(' ').map do |paren_group|\n    paren_group.chars.reduce(0)\
    \ do |memo, char|\n      memo += 1 if char == '('\n      memo -= 1 if char ==\
    \ ')'\n      memo\n    end\n  end\nend", "  # create an array to hold our results\n\
    \  result = []\n  # split the string into an array of groups\n  paren_groups =\
    \ paren_string.split(\" \")\n  # iterate through each group\n  paren_groups.each\
    \ do |group|\n    # create counter variables to keep track of our nesting\n  \
    \  open_counter = 0\n    max_open = 0\n    # iterate through each character in\
    \ the group\n    group.each_char do |char|\n      # increment open_counter if\
    \ we have an open parenthesis\n      if char == \"(\"\n        open_counter +=\
    \ 1\n      # if we have a close parenthesis, decrement open_counter\n      # check\
    \ if this is the deepest level of nesting for this group\n      elsif char ==\
    \ \")\"\n        open_counter -= 1\n        if open_counter > max_open\n     \
    \     max_open = open_counter\n        end\n      end\n    end\n    # push our\
    \ current max nesting value to the result array\n    result.push(max_open)\n \
    \ end\n  # return our results\n  result\nend", "  # TODO\nend", "  paren_string.split(\"\
    \ \").each_with_object([]) do |paren_group, memo|\n    parse_parens(paren_group).each_with_object(0)\
    \ do |char, count|\n      memo << count if char == \")\"\n      count += 1 if\
    \ char == \"(\"\n    end\n  end\nend", "  paren_string.split.map { |paren_group|\
    \ paren_group.scan(/\\(/).size }\nend", "  # use a stack to keep track of parens\n\
    \  stack = []\n  # store levels of nested parentheses in an array\n  levels =\
    \ []\n  # a counter to count the current level\n  curr_level = 0\n  # iterate\
    \ through the paren_string string\n  paren_string.each_char do |char|\n    if\
    \ char == '('\n      # if we see an open paren, increment curr_level and push\
    \ it onto the stack\n      curr_level += 1\n      stack.push(char)\n    elsif\
    \ char == ')'\n      # if we see a close paren, push it onto the stack and decrement\
    \ curr_level\n      curr_level -= 1\n      stack.push(char)\n    end\n    # if\
    \ the stack size is 2, then we have a full level of parentheses\n    if stack.size\
    \ == 2\n      # decrement the size of the stack by 2 to remove the level of parentheses\n\
    \      # push the current level onto the levels array\n      # also, reset curr_level\
    \ to 0\n      stack.pop(2)\n      levels.push(curr_level)\n      curr_level =\
    \ 0\n    end\n  end\n  # return the levels array\n  levels\nend", "  paren_string.split.map\
    \ do |par_group|\n    max_nesting = 0\n    nesting = 0\n    par_group.each_char\
    \ do |char|\n      nesting += 1 if char == '('\n      nesting -= 1 if char ==\
    \ ')'\n      max_nesting = nesting if nesting > max_nesting\n    end\n    max_nesting\n\
    \  end\nend", "  paren_string.split.map { |s| find_max_parens(s) }\nend", "  paren_string.split('\
    \ ').map do |paren_group|\n    stack = []\n    max_depth = 0\n    paren_group.chars.each\
    \ do |ch|\n      case ch\n      when '('\n        stack.push(ch)\n        max_depth\
    \ = stack.length if stack.length > max_depth\n      when ')'\n        stack.pop\
    \ if stack.length > 0\n      end\n    end\n    max_depth\n  end\nend", "  paren_string.split.map\
    \ do |parens|\n    parens.chars.reduce(0) do |depth, char|\n      char == '('\
    \ ? depth + 1 : depth - 1\n    end\n  end\nend", "  max_depth = 0\n  current_depth\
    \ = 0\n  max_depths = []\n  paren_string.chars.each do |char|\n    if char ==\
    \ '('\n      current_depth += 1\n      max_depth = current_depth if current_depth\
    \ > max_depth\n    elsif char == ')'\n      current_depth -= 1\n    elsif char\
    \ == ' '\n      max_depths << max_depth\n      max_depth = 0\n      current_depth\
    \ = 0\n    end\n  end\n  max_depths << max_depth\n  max_depths\nend", "  # the\
    \ idea is to keep a current nesting level, and add +1 to it every time we\n  #\
    \ hit an opening parenthesis, then subtract -1 to it every time we hit a closing\n\
    \  # parenthesis.", "  i = 0\n  stack = []\n  paren_string.each_char do |c|\n\
    \    if c == '('\n      stack.push(c)\n    elsif c == ')'\n      stack.pop\n \
    \   end\n    i += 1\n  end\n  return []\nend", "  # YOUR CODE HERE\nend", "  paren_string.split.map\
    \ { |paren_group| paren_group.scan(/\\(/).count }\nend", "  # For each of the\
    \ groups, find the deepest level of nesting of parentheses.\n  # You may assume\
    \ there are no other non-parentheses characters in the string.\n  #\n  # Arguments:\n\
    \  #   paren_string (String): A string to parse.\n  #\n  # Returns:\n  #   (Array[Integer]):\
    \ An array of integers representing the maximum\n  #   depth of nesting for each\
    \ group.\n  #\n  # Example:\n  #   parse_nested_parens.call(\"(()()) ((())) ()\
    \ ((())()())\")\n  #   => [2, 3, 1, 3]\n  #\n  # Your code goes here.\n  depth\
    \ = 0\n  depth_set = []\n  (0...paren_string.length).each do |i|\n    case paren_string[i]\n\
    \    when '('\n      depth += 1\n    when ')'\n      depth -= 1\n    when ' '\n\
    \      depth_set << depth\n      depth = 0\n    end\n  end\n  depth_set << depth\n\
    \  depth_set\nend", "  paren_string.split(\" \").map do |parens|\n    level =\
    \ 0\n    max_level = 0\n    parens.chars.each do |c|\n      level += 1 if c ==\
    \ \"(\"\n      level -= 1 if c == \")\"\n      max_level = level if level > max_level\n\
    \    end\n    max_level\n  end\nend", "  max_levels = []\n  paren_string.split.each\
    \ do |group|\n    index = 0\n    level = 0\n    max_level = 0\n    while index\
    \ < group.length\n      if group[index] == '('\n        level += 1\n        max_level\
    \ = level if level > max_level\n      elsif group[index] == ')'\n        level\
    \ -= 1\n      end\n      index += 1\n    end\n    max_levels << max_level\n  end\n\
    \  max_levels\nend", "  parse_level = 0\n  max_level = 0\n  results = []\n  paren_string.each_char\
    \ do |c|\n    if c == '('\n      parse_level += 1\n      max_level = parse_level\
    \ if parse_level > max_level\n    elsif c == ')'\n      parse_level -= 1\n   \
    \ elsif c == ' '\n      results << max_level\n      max_level = 0\n      parse_level\
    \ = 0\n    end\n  end\n  results << max_level\nend", "  paren_string.split.map\
    \ { |str|\n    depth = 0\n    max_depth = 0\n    str.each_char { |char|\n    \
    \  if char == '('\n        depth += 1\n        max_depth = depth if depth > max_depth\n\
    \      elsif char == ')'\n        depth -= 1\n      end\n    }\n    max_depth\n\
    \  }\nend", "  count = 0\n  arr = []\n  paren_string.split(/\\s+/).each do |group|\n\
    \    count = 0\n    group.each_char do |c|\n      count += 1 if c == '('\n   \
    \   count -= 1 if c == ')'\n    end\n    arr << count\n  end\n  arr\nend", " \
    \   paren_string.split(\" \").map do |parens|\n        nesting_level = 0\n   \
    \     max_nesting_level = 0\n        parens.each_char do |paren|\n           \
    \ if paren == \"(\"\n                nesting_level += 1\n            elsif paren\
    \ == \")\"\n                nesting_level -= 1\n            end\n            max_nesting_level\
    \ = [max_nesting_level, nesting_level].max\n        end\n        max_nesting_level\n\
    \    end\nend", end, "  paren_string.scan(/\\(([^()]*)\\)/).map do |paren_group|\n\
    \    paren_group.first.scan(/\\(/).count\n  end\nend", "  max_levels = []\n  paren_string.split('\
    \ ').each do |paren_group|\n    max_levels << count_deepest_nesting(paren_group)\n\
    \  end\n  max_levels\nend", '  return [] if paren_string.nil?', "  paren_string.split.map\
    \ { |str| str.count('(') - str.count(')') }\nend", "  group_max_parens = []\n\
    \  paren_string.split(' ').each do |group|\n    max_parens = 0\n    current_parens\
    \ = 0\n    group.each_char do |char|\n      if char == '('\n        current_parens\
    \ += 1\n        max_parens = current_parens if current_parens > max_parens\n \
    \     elsif char == ')'\n        current_parens -= 1\n      end\n    end\n   \
    \ group_max_parens << max_parens\n  end\n  group_max_parens\nend", "  paren_string.split('\
    \ ').map do |group|\n    level = 0\n    max_level = 0\n    group.each_char do\
    \ |char|\n      if char == '('\n        level += 1\n        max_level = level\
    \ if level > max_level\n      elsif char == ')'\n        level -= 1\n      end\n\
    \    end\n    max_level\n  end\nend", "  result = []\n  paren_string.split.each\
    \ do |paren|\n    stack = []\n    stack_index = 0\n    max_stack_index = 0\n \
    \   paren.split('').each do |item|\n      if item == '('\n        stack << item\n\
    \        stack_index += 1\n        max_stack_index = stack_index if stack_index\
    \ > max_stack_index\n      elsif item == ')'\n        stack.pop\n        stack_index\
    \ -= 1\n      end\n    end\n    result << max_stack_index\n  end\n  result\nend",
  "  paren_string.split(' ').map do |parens|\n    count = 0\n    parens.chars.map\
    \ do |char|\n      case char\n      when '('\n        count += 1\n      when ')'\n\
    \        count -= 1\n      end\n    end\n    count.abs\n  end\nend", "  paren_string.scan(/[(].*?[)]/).map\
    \ do |group|\n    group.scan(/[(]/).count\n  end\nend", "  paren_string.split(\"\
    \ \").map do |paren_group|\n    paren_group.split(\"\").select { |char| char ==\
    \ \"(\" }.count\n  end\nend", "  paren_string.split.map do |group|\n    max_level\
    \ = 0\n    current_level = 0\n    group.each_char do |char|\n      if char ==\
    \ '('\n        current_level += 1\n        max_level = current_level if current_level\
    \ > max_level\n      elsif char == ')'\n        current_level -= 1\n      end\n\
    \    end\n    max_level\n  end\nend", "  parsed_parens = []\n  paren_string.split('\
    \ ').each do |paren|\n    deepest_level = 0\n    paren.split('').each do |char|\n\
    \      if char == '('\n        deepest_level += 1\n      elsif char == ')'\n \
    \       deepest_level -= 1\n      end\n    end\n    parsed_parens << deepest_level\n\
    \  end\n  parsed_parens\nend", "  parse_parens(paren_string, '()')\nend", "  arr\
    \ = paren_string.split(\" \")\n  open_parens = {'(' => 0}\n  deepest_parens =\
    \ []\n  arr.each do |substr|\n    substr.each_char do |c|\n      if c == '('\n\
    \        open_parens['('] += 1\n      elsif c == ')'\n        open_parens['(']\
    \ -= 1\n      end\n    end\n    deepest_parens << open_parens['(']\n  end\n  deepest_parens\n\
    end", "  (paren_string.split.map do |paren_group|\n    current_depth = 0\n   \
    \ max_depth = 0\n    paren_group.each_char do |char|\n      if char == '('\n \
    \       current_depth += 1\n        max_depth = current_depth if current_depth\
    \ > max_depth\n      elsif char == ')'\n        current_depth -= 1\n      end\n\
    \    end\n    max_depth\n  end)\nend", "  # TODO\nend", "  paren_string.split.map\
    \ { |group| parse_nested_parens_group(group) }\nend", '  raise ArgumentError unless
    paren_string.is_a?(String)', "  paren_string.split(\" \").map { |parens| parens.count(\"\
    (\") }\nend", "  paren_string.split(\" \").map { |parens| find_deepest_parens(parens)\
    \ }\nend", "    # Fill the array with the number of layers of parentheses.\n \
    \   stack = [0]\n    result = []\n    depth = 0\n    paren_string.split(\" \"\
    ).each do |x|\n        if x == \"(\"\n            stack << 0\n            depth\
    \ += 1\n        elsif x == \")\"\n            result << depth\n            depth\
    \ -= 1\n        end\n    end\n    result\nend", "  paren_string.split(' ').map\
    \ do |string|\n    if string.length == 1\n      0\n    else\n      string.chars.map.with_index\
    \ do |char, index|\n        if char == '('\n          index\n        elsif char\
    \ == ')'\n          (index - 1) * -1\n        end\n      end.compact.inject(:+)\n\
    \    end\n  end\nend", "  max_depth = 0\n  res = []\n  paren_string.each_char\
    \ do |char|\n    if char == '('\n      max_depth += 1\n    elsif char == ')'\n\
    \      res << max_depth\n      max_depth -= 1\n    end\n  end\n  res\nend", " \
    \ paren_string.split(\" \").map { |parens| parens.chars.map { |char| char == \"\
    (\" ? 1 : -1 }.reduce(:+) }\nend", "  stacks = []\n  output = []\n  paren_string.split.each\
    \ do |paren_group|\n    stacks.push []\n    chars = paren_group.chars\n    chars.each\
    \ do |char|\n      if char == '('\n        stacks.last.push char\n      else\n\
    \        stacks.last.pop\n      end\n    end\n    output.push stacks.last.size\n\
    \  end\n  output\nend", "  #first thought: string or array. array if it's already\
    \ split.\n  #split by space.\n  # check if a character is not an opening or closing.\n\
    \  # if it is closing, add to a new array that is holding the close.\n  # if it\
    \ is opening, add to a new array that is holding the open.\n  # for every close,\
    \ check if it is equal to the previous open.\n  #if equal, add to a third array\
    \ that counts the level.\n  # for every open, check if it is equal to the previous\
    \ close.\n  #if equal, add to a third array that counts the level.\n  # after\
    \ all the loops, the last level count should be the deepest level.\n  #return\
    \ the deepest level, the count.", "  output = []\n  paren_string.split(\" \").each\
    \ do |group|\n    output << max_nesting(group)\n  end\n  output\nend", "  paren_arr\
    \ = paren_string.split(' ')\n  paren_arr.map { |paren| max_nesting(paren) }\n\
    end", "  paren_string.scan(/\\((?!\\?)*\\)/).map { |match| match.count(\"(\")\
    \ }\nend", "  paren_string.split.map { |paren_group| process_group(paren_group)\
    \ }\nend", "  # your code here\nend", "  paren_string.split(' ').map { |group|\
    \ group.count('(') - group.count(')') }\nend", "  matches = paren_string.scan(/\\\
    (+\\)/)\n  matches.map{|match| match.length / 2}\nend", "  result = []\n  paren_string.split(\"\
    \ \").each do |chunk|\n    count = 0\n    cmax = 0\n    chunk.each_char do |c|\n\
    \      if c == \"(\"\n        count += 1\n        cmax = count if count > cmax\n\
    \      elsif c == \")\"\n        count -= 1\n      end\n    end\n    result <<\
    \ cmax\n  end\n  result\nend", "  group_strings = paren_string.split(\" \")\n\
    \  group_strings.map { |paren_group| parse_parens(paren_group) }\nend", "  max_lvl\
    \ = 0\n  current_lvl = 0\n  outputs = []\n  paren_string.each_char do |c|\n  \
    \  if c == '('\n      current_lvl += 1\n      max_lvl = current_lvl if current_lvl\
    \ > max_lvl\n    elsif c == ')'\n      outputs << max_lvl\n      current_lvl -=\
    \ 1\n      max_lvl = current_lvl\n    end\n  end\n  outputs\nend", "  paren_string.split('\
    \ ').map { |x| count_nested_parens(x) }\nend", "  arr = paren_string.split(' ')\n\
    \  levels = []\n  arr.each do |paren|\n    levels << depth(paren)\n  end\n  levels\n\
    end", "  paren_string.scan(/\\([^()]*\\)/).map { |pair| pair.count('(') }\nend",
  "  open_parens = 0\n  max_parens = 0\n  paren_string.split(' ').map do |group|\n\
    \    group.each_char do |paren|\n      if paren == '('\n        open_parens +=\
    \ 1\n        max_parens = open_parens if open_parens > max_parens\n      elsif\
    \ paren == ')'\n        open_parens -= 1\n      end\n    end\n    open_parens\
    \ = 0\n    max_parens\n  end\nend", "  paren_string.split.map do |paren_group|\n\
    \    paren_group.chars.each_with_object([0, 0]) do |char, (max_nest, curr_nest)|\n\
    \      max_nest = curr_nest if curr_nest > max_nest\n      curr_nest += 1 if char\
    \ == '('\n      curr_nest -= 1 if char == ')'\n    end.first\n  end\nend", " \
    \ # split_parens = paren_string.split(\" \")\n  max_count = 0\n  split_parens\
    \ = paren_string.scan(/\\(([^()]*)\\)/)\n  p split_parens\n  p split_parens.map\
    \ { |paren| paren.map{ |char| (char == \"(\") ? max_count += 1 : max_count -=\
    \ 1 } }", "  paren_string.split(' ').map do |parentheses|\n    parsing_state =\
    \ ParsingState.new\n    parentheses.each_char { |c| parsing_state.parse(c) }\n\
    \    parsing_state.max_nesting\n  end\nend", "  paren_string.split(\" \").each_with_object([])\
    \ do |item, result|\n    result << item.gsub(\"()\", \".\").count(\"(\")\n  end\n\
    end", "  # Split string by space\n  paren_groups = paren_string.split(/\\s+/)\n\
    \  # Get maximum nesting level of each group and store in a hash\n  paren_groups.map\
    \ { |s| s.chars.reduce(0) { |level, char| char == '(' ? level + 1 : level - 1\
    \ } }\nend", "  paren_string.split(\" \").map { |parens| calculate_paren_depth(parens)\
    \ }\nend", "  paren_string.split.map { |parens|\n    parens.split('').each_with_object([0,\
    \ 0]) { |char, (max, current)|\n      case char\n      when '('\n        current\
    \ += 1\n        max = current if current > max\n      when ')'\n        current\
    \ -= 1\n      end\n    }.first\n  }\nend", "  result = []\n  paren_string.split.each\
    \ do |paren|\n    result << max_nested_parentheses(paren)\n  end\n  result\nend",
  "\t# Write your code here.\nend", "  paren_string.split.map do |parens|\n    parens.chars.each_with_object([0,\
    \ 0]) do |c, (max, sum)|\n      sum += if c == '('\n               1\n       \
    \      else\n               -1\n             end\n      max = sum if sum > max\n\
    \    end.first\n  end\nend", "  groups = paren_string.split(\" \")\n  groups.map\
    \ { |str| max_nesting(str) }\nend", "  raise ArgumentError.new('string should\
    \ have at least one group') if paren_string.empty?\n  paren_string.scan(/\\(\\\
    (?\\(?\\)?\\)?/).map { |p| p.count('(') }\nend", "  deep_levels = []\n  paren_string.split(\"\
    \ \").each do |group|\n    deep_levels << find_deepest_level(group)\n  end\n \
    \ deep_levels\nend", "  paren_string.split.map { |group| group.chars.reduce(0)\
    \ { |max, c| max = c == '(' ? max + 1 : max - 1 } }\nend", "  paren_string.split(\"\
    \ \").map { |parens| parens.count(\"(\") - parens.count(\")\") }\nend", "  paren_groups\
    \ = paren_string.split(' ')\n  paren_groups.map { |group| count_nested_parens(group)\
    \ }\nend", "  paren_string.split(\" \").map { |paren_expr| parse_parens(paren_expr)\
    \ }\nend", "  paren_string.split.map { |parens| max_nesting(parens) }\nend", " \
    \ max_depth = 0\n  depth = 0\n  results = []\n  # Separate the string by spaces\
    \ and split each component.\n  # Handle each component individually and store\
    \ the max depth for each component.\n  paren_string.split(' ').each do |component|\n\
    \    component.split('').each do |char|\n      if char == '('\n        depth +=\
    \ 1\n        max_depth = depth if depth > max_depth\n      elsif char == ')'\n\
    \        depth -= 1\n      end\n    end\n    results << max_depth\n    max_depth\
    \ = 0\n    depth = 0\n  end\n  results\nend", "  # code\nend", "  # BEGIN (write\
    \ your solution here)\n  res = []\n  paren_string.split(\" \").each do |parens|\n\
    \    parens = parens.chars\n    counter = 0\n    max_counter = 0\n    parens.each\
    \ do |paren|\n      if paren == \"(\"\n        counter += 1\n      else\n    \
    \    counter -= 1\n      end\n      max_counter = counter if counter > max_counter\n\
    \    end\n    res << max_counter\n  end\n  res\n  # END\nend", "  paren_array\
    \ = paren_string.split(' ')\n  paren_array.map { |paren| parse_parens(paren) }\n\
    end", "  paren_arr = paren_string.split(\" \")\n  paren_arr.map { |paren| paren.count(\"\
    (\") }\nend", "  paren_string.split(\" \").map do |paren_group|\n    max_level\
    \ = 0\n    current_level = 0\n    paren_group.chars.each do |char|\n      if char\
    \ == \"(\"\n        current_level += 1\n        max_level = current_level if current_level\
    \ > max_level\n      elsif char == \")\"\n        current_level -= 1\n      end\n\
    \    end\n    max_level\n  end\nend", "  paren_string.split(' ').map do |paren_group|\n\
    \    paren_levels = paren_group.chars.reduce([0]) do |paren_levels, paren|\n \
    \     if paren == '('\n        paren_levels << paren_levels.last + 1\n      else\n\
    \        paren_levels.pop\n      end\n      paren_levels\n    end\n    paren_levels.max\n\
    \  end\nend", "  paren_string.split(\" \").map { |str|\n    # Replace all the\
    \ non parenthesis with a '.' so that we can split the \n    # string into substrings\
    \ of each parenthesis.\n    # Then we take the number of substrings - 1 to get\
    \ the number of levels of\n    # nesting of parenthesis.\n    str.gsub(/[^()]/,\
    \ '.').split(\".\").size - 1\n  }\nend", "\tparen_group = paren_string.split(\"\
    \ \")\n\tparen_group.map { |group| paren_depth(group) }\nend", "  paren_string.scan(/[()]+/).map\
    \ { |paren_group|\n    paren_group.scan(/[(]/).size\n  }\nend", "  paren_string.split(\"\
    \ \").map do |parens|\n    count = 0\n    index = 0\n    max_count = 0\n    while\
    \ index < parens.length\n      paren = parens[index]\n      if paren == \"(\"\n\
    \        count += 1\n      elsif paren == \")\"\n        count -= 1\n      end\n\
    \      max_count = count if count > max_count\n      index += 1\n    end\n   \
    \ max_count\n  end\nend", "  paren_string.split.map { |paren_group| max_nested_parens(paren_group)\
    \ }\nend", "  max_depth = []\n  current_depth = 0\n  paren_string.each_char do\
    \ |char|\n    if char == '('\n      current_depth += 1\n    elsif char == ')'\n\
    \      max_depth << current_depth\n      current_depth = 0\n    end\n  end\n \
    \ max_depth\nend", "  paren_string.split(\" \").map { |paren_group|\n    paren_group.chars.reduce(0)\
    \ { |acc, char|\n      acc += 1 if char == \"(\"\n      acc -= 1 if char == \"\
    )\"\n      acc\n    }\n  }\nend", "  paren_string.split(' ').map do |paren_group|\n\
    \    paren_group.count('(')\n  end\nend", "  # Add your code here.\n  paren_string.split(\"\
    \ \").map { |paren| paren.scan(\"(\").count }\nend", "  splitted_parens = paren_string.split('\
    \ ')\n  parse_nested_parens_helper(splitted_parens)\nend", "  return nil if paren_string.nil?\n\
    \  paren_string.split.map { |group| count_depth(group) }\nend", "  result = []\n\
    \  paren_string.split(\" \").each do |group|\n    deepest_level = 0\n    current_level\
    \ = 0\n    group.each_char do |char|\n      if char == \"(\"\n        current_level\
    \ += 1\n        deepest_level = current_level if current_level > deepest_level\n\
    \      elsif char == \")\"\n        current_level -= 1\n      end\n    end\n \
    \   result << deepest_level\n  end\n  result\nend", "  paren_string.split(\" \"\
    ).map do |parens|\n    parens.count(\"(\") - parens.count(\")\")\n  end\nend",
  "  groups = paren_string.split(\" \")\n  groups.map { |group| parse_parens(group)\
    \ }\nend", "  paren_string.split(\" \").map do |paren_group|\n    max_paren_level\
    \ = 0\n    paren_level = 0\n    paren_group.each_char do |paren|\n      if paren\
    \ == \"(\"\n        paren_level += 1\n        max_paren_level = paren_level if\
    \ paren_level > max_paren_level\n      elsif paren == \")\"\n        paren_level\
    \ -= 1\n      end\n    end\n    max_paren_level\n  end\nend", "  paren_string.split(\"\
    \ \").map { |paren_group|\n    paren_group.chars.reduce([0, 0]) { |max_level,\
    \ paren|\n      if paren == \"(\"\n        [max_level[0] + 1, max_level[1] + 1]\n\
    \      elsif paren == \")\"\n        [max_level[0] - 1, max_level[1]]\n      else\n\
    \        max_level\n      end\n    }[1]\n  }\nend", "  result = []\n  paren_string.scan(/\\\
    (.*?\\)/).each do |substring|\n    result << _nested_parens_helper(substring)\n\
    \  end\n  result\nend", "  paren_string.split.map do |group|\n    level = 0\n\
    \    max_level = 0\n    group.each_char do |char|\n      level += 1 if char ==\
    \ '('\n      level -= 1 if char == ')'\n      max_level = level if level > max_level\n\
    \    end\n    max_level\n  end\nend", "  # Store in array a number representing\
    \ the max depth of parentheses\n  paren_string.split(\" \").each_with_object([])\
    \ do |string, results|\n    left_parens = 0\n    right_parens = 0\n    max_depth\
    \ = 0\n    depth = 0\n    is_valid = true", "  paren_string.split(' ').map { |s|\
    \ calculate_nested_parens(s) }\nend", "  paren_string.split.map do |paren_group|\n\
    \    deepest_level(paren_group)\n  end\nend", "  paren_string.split(' ').map {\
    \ |group|\n    group.chars.inject(0) { |level, char|\n      if char == '('\n \
    \       level + 1\n      elsif char == ')'\n        level - 1\n      else\n  \
    \      level\n      end\n    }\n  }\nend", "  max_levels = []\n  # split the input\
    \ string on spaces\n  words = paren_string.split(\" \")\n  # for each of the words\
    \ in the input string\n  words.each do |word|\n    # use stack to find the deepest\
    \ level of nesting, then add it to array\n    max_levels << find_max_level(word)\n\
    \  end\n  # return the array of max level nesting\n  max_levels\nend", "  #  paren_string\
    \ = \"(()())\"\n  # TODO: implement this\n  # Copy the string to a new variable\
    \ so that I don't have to modify the original\n  paren_string_mod = paren_string\n\
    \  # Make sure there are no trailing or leading spaces\n  paren_string_mod.strip!\n\
    \  # Replace all sets of spaces with a single space\n  paren_string_mod.gsub!(/[\
    \ ]+/, \" \")\n  # Now split up the string on the single spaces\n  paren_string_mod\
    \ = paren_string_mod.split(\" \")\n  # Now we need to go through each group of\
    \ parentheses and calculate the maximum nesting level\n  # Create an array to\
    \ hold the maximum nesting levels\n  max_nesting_levels = []\n  # Go through each\
    \ group\n  paren_string_mod.each do |paren_string_group|\n    # Set the current\
    \ nesting level to zero\n    current_nesting_level = 0\n    # Set the maximum\
    \ nesting level to zero\n    max_nesting_level = 0\n    # Go through each character\
    \ in the group\n    paren_string_group.each_char do |character|\n      # If it's\
    \ an open paren, then increase the current nesting level\n      if character ==\
    \ \"(\"\n        current_nesting_level += 1\n      # If it's a close paren, then\
    \ decrease the current nesting level\n      elsif character == \")\"\n       \
    \ current_nesting_level -= 1\n      # Otherwise, leave the current nesting level\
    \ alone\n      end\n      # Check to see if the current nesting level is greater\
    \ than the maximum nesting level\n      # If it is, then set the maximum nesting\
    \ level to the current nesting level\n      if current_nesting_level > max_nesting_level\n\
    \        max_nesting_level = current_nesting_level\n      end\n    end\n    #\
    \ Now, add the maximum nesting level to the array of maximum nesting levels\n\
    \    max_nesting_levels.push(max_nesting_level)\n  end\n  # Return the array of\
    \ maximum nesting levels\n  return max_nesting_levels\nend", "  paren_string.split('\
    \ ').map do |group|\n    len = group.length\n    last_stack = [0]\n    last_diff\
    \ = 0\n    level = 0\n    (0...len).each do |i|\n      paren = group[i]\n    \
    \  if paren == '('\n        last_stack.push(i)\n      elsif paren == ')'\n   \
    \     last_diff = i - last_stack.pop()\n        level = [level, last_diff].max\n\
    \      end\n    end\n    level\n  end\nend", "  paren_string.split(\" \").map\
    \ { |paren_group|\n    paren_group.chars.reduce([0, 0]) { |(depth, max_depth),\
    \ char|\n      if char == \"(\"\n        [depth + 1, max_depth]\n      elsif char\
    \ == \")\"\n        [depth - 1, max_depth]\n      else\n        [depth, max_depth]\n\
    \      end\n    }[1]\n  }\nend", "  paren_string.gsub(/\\s+/, ' ').split.map {\
    \ |group| group.scan(/\\(/).count }\nend", "  paren_string.split(' ').map { |group|\
    \ group.scan(/\\(/).count }\nend", "  paren_string.split(\" \").map do |sub_string|\n\
    \    max_depth = 0\n    current_depth = 0\n    sub_string.chars.each do |char|\n\
    \      if char == \"(\"\n        current_depth += 1\n        max_depth = current_depth\
    \ if current_depth > max_depth\n      elsif char == \")\"\n        current_depth\
    \ -= 1\n      end\n    end\n    max_depth\n  end\nend", "  paren_string.split(\"\
    \ \").map { |parens| parens.count(\"(\") - parens.count(\")\") }\nend", "  nesting_levels\
    \ = []\n  paren_string.split(\" \").each do |group|\n    open = 0\n    max_open\
    \ = 0\n    group.split(\"\").each do |c|\n      if c == \"(\"\n        open +=\
    \ 1\n        max_open = open if open > max_open\n      elsif c == \")\"\n    \
    \    open -= 1\n      end\n    end\n    nesting_levels << max_open\n  end\n  nesting_levels\n\
    end", "  splitted_string = paren_string.split(\" \")\n  result = []\n  splitted_string.each\
    \ do |paren|\n    max_level = 0\n    level = 0\n    paren.split(\"\").each do\
    \ |char|\n      if char == \"(\"\n        level += 1\n      elsif char == \")\"\
    \n        level -= 1\n      end\n      max_level = level if level > max_level\n\
    \    end\n    result << max_level\n  end\n  result\nend", "  paren_array = paren_string.split(\"\
    \ \")\n  result = []\n  paren_array.each do |str|\n    num_left = 0\n    num_right\
    \ = 0\n    result << str.each_char.inject(0) do |max, c|\n      if c == \"(\"\n\
    \        num_left += 1\n        [max, num_left].max\n      elsif c == \")\"\n\
    \        num_right += 1\n        [max, num_right].max\n      else\n        max\n\
    \      end\n    end\n  end\n  result\nend", "  paren_string.split(' ').map do\
    \ |paren_group|\n    parse_nested_parens_helper(paren_group)\n  end\nend", " \
    \ paren_string.split.each_with_object([]) do |str, results|\n    results << str.scan(/\\\
    (/).count\n  end\nend", "  levels = []\n  paren_string.split(' ').each do |parens|\n\
    \    parens = parens.gsub('(', '(').gsub(')', ')')\n    levels << parens.scan(/[^()]|(\\\
    ()|(\\))/).count(nil) / 2\n  end\n  levels\nend", "  paren_string.split(' ').map\
    \ { |paren_group| get_deepest_level(paren_group) }\nend", "  # To be implemented\n\
    end", "  paren_string.split.map do |sub_string|\n    max_depth = 0\n    depth\
    \ = 0\n    sub_string.chars.each do |char|\n      depth += 1 if char == '('\n\
    \      depth -= 1 if char == ')'\n      max_depth = depth if depth > max_depth\n\
    \    end\n    max_depth\n  end\nend", "  paren_string.split(' ').map do |substring|\n\
    \    stack = []\n    max_count = 0\n    substring.each_char do |char|\n      if\
    \ char == '('\n        stack.push(char)\n        max_count = stack.size if stack.size\
    \ > max_count\n      elsif char == ')'\n        stack.pop\n      end\n    end\n\
    \    max_count\n  end\nend", "    result = []\n    paren_groups = paren_string.split(\"\
    \ \")\n    for paren_group in paren_groups\n        result.push(depth_of_nested_parens(paren_group))\n\
    \    end\n    return result\nend", "  count = paren_string.split(' ').map do |paren|\n\
    \    level = 0\n    max_level = 0\n    paren.chars.each do |char|\n      if char\
    \ == '('\n        level += 1\n        max_level = level if level > max_level\n\
    \      elsif char == ')'\n        level -= 1\n      end\n    end\n    max_level\n\
    \  end\n  count\nend", "  paren_string.split.map { |parens| parens.count('(')\
    \ - parens.count(')') }\nend", "    raise NotImplementedError, \"TODO: implement\
    \ this method\"\nend", "  # Remove all spaces from the paren string\n  paren_string.delete!('\
    \ ')\n  # Go through each character and keep track of the level at which the deepest\
    \ nesting of parentheses is\n  max_level = 0\n  curr_level = 0\n  paren_string.each_char\
    \ do |char|\n    if char == '('\n      curr_level += 1\n      max_level = curr_level\
    \ if curr_level > max_level\n    elsif char == ')'\n      curr_level -= 1\n  \
    \  end\n  end\n  # Return a list of the number of levels of nesting for each group\n\
    \  paren_string.split(')').map do |substring|\n    curr_level = 0\n    substring.each_char\
    \ do |char|\n      if char == '('\n        curr_level += 1\n      end\n    end\n\
    \    curr_level\n  end\nend", "  paren_string.split(\" \").map { |parens| parens.count(\"\
    (\") - parens.count(\")\") }\nend", "  groups = paren_string.split(' ')\n  results\
    \ = []\n  groups.each do |grp|\n    count = 0\n    max_count = 0\n    grp.each_char\
    \ do |char|\n      if char == '('\n        count += 1\n        max_count = count\
    \ if count > max_count\n      elsif char == ')'\n        count -= 1\n      end\n\
    \    end\n    results << max_count\n  end\n  results\nend", "  paren_string.split('\
    \ ').map { |group| group.scan(/\\(/).size }\nend", "  max_stack = 0\n  max_array\
    \ = []\n  stack = 0\n  arr = paren_string.split(' ')\n  arr.each do |i|\n    if\
    \ i == '('\n      stack += 1\n    else\n      if stack > max_stack\n        max_stack\
    \ = stack\n      end\n      max_array << max_stack\n      stack = 0\n    end\n\
    \  end\n  max_array\nend", "  max_depth = 0\n  curr_depth = 0\n  max_depths =\
    \ []\n  paren_string.chars.each do |char|\n    if char == '('\n      curr_depth\
    \ += 1\n      max_depth = curr_depth if curr_depth > max_depth\n    elsif char\
    \ == ')'\n      curr_depth -= 1\n    else\n      max_depths << max_depth\n   \
    \   max_depth = 0\n      curr_depth = 0\n    end\n  end\n  max_depths << max_depth\n\
    end", "  paren_string.split.map do |parens|\n    max_nested_parens = 0\n    nesting_count\
    \ = 0\n    parens.each_char do |char|\n      if char == '('\n        nesting_count\
    \ += 1\n        max_nested_parens = nesting_count if nesting_count > max_nested_parens\n\
    \      elsif char == ')'\n        nesting_count -= 1\n      end\n    end\n   \
    \ max_nested_parens\n  end\nend", "  paren_string.split.map { |parens| parse_parens(parens)\
    \ }\nend", "  paren_string.split.map do |s|\n    depth = 0\n    max_depth = 0\n\
    \    s.chars.each do |c|\n      depth += 1 if c == '('\n      depth -= 1 if c\
    \ == ')'\n      max_depth = depth if depth > max_depth\n    end\n    max_depth\n\
    \  end\nend", "  paren_string.scan(/\\(+\\)/).map { |paren| paren.scan(/\\(/).size\
    \ }\nend", "  paren_string.split(' ').map { |group| find_deepest_parens(group)\
    \ }\nend", "  paren_string.split.map do |parens|\n    parse_parens(parens)\n \
    \ end\nend", "  paren_string.split(' ').map do |paren_group|\n    parse_nested_parens_helper(paren_group,\
    \ 0, 0)\n  end\nend", "  paren_string.split.map do |parens|\n    level = 0\n \
    \   max_level = 0\n    parens.each_char do |ch|\n      if ch == '('\n        level\
    \ += 1\n        max_level = level if level > max_level\n      elsif ch == ')'\n\
    \        level -= 1\n      end\n    end\n    max_level\n  end\nend", "  paren_string.split(\"\
    \ \").map do |paren_group|\n    depth = 0\n    max_depth = 0\n    paren_group.each_char\
    \ do |char|\n      if char == \"(\"\n        depth += 1\n        max_depth = depth\
    \ if depth > max_depth\n      elsif char == \")\"\n        depth -= 1\n      end\n\
    \    end\n    max_depth\n  end\nend", "  paren_string.split(' ').map do |paren_group|\n\
    \    depth = 0\n    max_depth = 0\n    paren_group.chars.each do |c|\n      if\
    \ c == '('\n        depth += 1\n        max_depth = depth if depth > max_depth\n\
    \      elsif c == ')'\n        depth -= 1\n      end\n    end\n    max_depth\n\
    \  end\nend", "  paren_string.split.map { |group| group.count('(') - group.count(')')\
    \ }\nend", "  paren_string.split(' ').map { |group| group.chars.reduce(0) { |nest_level,\
    \ char| char == '(' ? nest_level + 1 : nest_level - 1 } }\nend", "  paren_string.split('\
    \ ').map do |paren_group|\n    max_nesting = 0\n    current_nesting = 0\n    paren_group.each_char\
    \ do |char|\n      if char == '('\n        current_nesting += 1\n        max_nesting\
    \ = current_nesting if current_nesting > max_nesting\n      elsif char == ')'\n\
    \        current_nesting -= 1\n      end\n    end\n    max_nesting\n  end\nend",
  end, "\tparen_string.split(' ').map { |group| count_parens(group) }\nend", "  max_depth\
    \ = 0\n  current_depth = 0\n  result = []\n  paren_string.each_char do |paren|\n\
    \    if paren == '('\n      current_depth += 1\n      max_depth = current_depth\
    \ if current_depth > max_depth\n    elsif paren == ')'\n      result << max_depth\n\
    \      current_depth -= 1\n      max_depth = current_depth\n    end\n  end\n \
    \ result\nend", "  arr = paren_string.split(\" \")\n  result = []\n  arr.each\
    \ do |paren|\n    count = 0\n    max = 0\n    paren.each_char do |char|\n    \
    \  if char == \"(\"\n        count += 1\n        max = count if count > max\n\
    \      elsif char == \")\"\n        count -= 1\n      end\n    end\n    result\
    \ << max\n  end\n  result\nend", "\tparen_string.split.map { |x| x.count('(')\
    \ - x.count(')') }\nend", "  paren_string.split(' ').map do |group|\n    max_depth\
    \ = 0\n    current_depth = 0\n    group.each_char do |c|\n      current_depth\
    \ += 1 if c == '('\n      current_depth -= 1 if c == ')'\n      max_depth = current_depth\
    \ if current_depth > max_depth\n    end\n    max_depth\n  end\nend", "  paren_string.split.map\
    \ do |parens|\n    nest_depth = 0\n    (0...parens.length).each do |i|\n     \
    \ nest_depth += 1 if parens[i] == '('\n      nest_depth -= 1 if parens[i] == ')'\n\
    \    end\n    nest_depth / 2\n  end\nend", "  paren_levels = []\n  paren_string.split(\"\
    \ \").each do |group|\n    paren_level = 0\n    max_paren_level = 0\n    group.each_char\
    \ do |char|\n      if char == \"(\"\n        paren_level += 1\n      elsif char\
    \ == \")\"\n        paren_level -= 1\n      end\n      max_paren_level = paren_level\
    \ if paren_level > max_paren_level\n    end\n    paren_levels << max_paren_level\n\
    \  end\n  paren_levels\nend", "  paren_string.split(\" \").map do |paren_group|\n\
    \    max_depth = 0\n    current_depth = 0\n    paren_group.each_char do |char|\n\
    \      if char == \"(\"\n        current_depth += 1\n        max_depth = current_depth\
    \ if current_depth > max_depth\n      elsif char == \")\"\n        current_depth\
    \ -= 1\n      end\n    end\n    max_depth\n  end\nend", "  results = []\n  paren_string.split('\
    \ ').each do |group|\n    left_stack = []\n    max_depth = 0\n    current_depth\
    \ = 0\n    group.each_char do |c|\n      if c == '('\n        left_stack.push(c)\n\
    \        current_depth += 1\n        max_depth = current_depth if current_depth\
    \ > max_depth\n      elsif c == ')'\n        raise \"Error. Unmatched ')'.\" if\
    \ left_stack.empty?\n        left_stack.pop\n        current_depth -= 1\n    \
    \  else\n        raise \"Error. Invalid characters used other than '(' and ')'.\"\
    \n      end\n    end\n    raise \"Error. Unmatched '('.\" unless left_stack.empty?\n\
    \    results.push(max_depth)\n  end\n  results\nend", "  paren_string.split.map\
    \ do |s|\n    count = 0\n    max_count = 0\n    s.chars.each do |c|\n      if\
    \ c == '('\n        count += 1\n        max_count = count if count > max_count\n\
    \      elsif c == ')'\n        count -= 1\n      end\n    end\n    max_count\n\
    \  end\nend", "  result = []\n  paren_string.split(' ').each do |group|\n    if\
    \ group.include? '('\n      # count the number of times the opening bracket '('\
    \ occurs\n      result << group.count('(')\n    else\n      result << 0\n    end\n\
    \  end\n  result\nend", "  parsed_array = paren_string.split(' ')\n  parsed_array.map\
    \ do |paren_group|\n    paren_group.chars.count('(')\n  end\nend", "  paren_arr\
    \ = paren_string.split(' ')\n  parsed_arr = []\n  paren_arr.each do |paren|\n\
    \    level = 0\n    paren.each_char do |char|\n      if char == '('\n        level\
    \ += 1\n      elsif char == ')'\n        level -= 1\n      end\n    end\n    parsed_arr\
    \ << level\n  end\n  parsed_arr\nend", "  paren_string.split(' ').map do |group|\n\
    \    parse_nested_parens_helper(group, 0, 0)\n  end\nend", "  # Write your code\
    \ here\n  deepest_level = []\n  paren_string.split.each do |str|\n    max_count\
    \ = 0\n    count = 0\n    str.each_char do |char|\n      if char == '('\n    \
    \    count += 1\n        max_count = count if count > max_count\n      elsif char\
    \ == ')'\n        count -= 1\n      end\n    end\n    deepest_level << max_count\n\
    \  end\n  deepest_level\nend", "\tstack = 0\n\tmax_nesting = 0\n\tparen_string.chars.each\
    \ do |paren|\n\t\tif paren == \"(\"\n\t\t\tstack += 1\n\t\telsif paren == \")\"\
    \n\t\t\tstack -= 1\n\t\t\tmax_nesting = stack if stack > max_nesting\n\t\tend\n\
    \tend\n\tmax_nesting\nend", "  # In case you're wondering, the code below is equivalent\
    \ to\n  # arr = paren_string.split(\" \")\n  # arr.map{|item| item.count('(')}\n\
    \  # ...but in a single line.\n  paren_string.split(\" \").map{|item| item.count('(')}\n\
    end", "  paren_string.split(\" \").map do |parens|\n    count_nested_parens(parens)\n\
    \  end\nend", "  paren_string.split.map { |p| p.count(\"(\") - p.count(\")\")\
    \ }\nend", "  paren_string.split.map { |group| group.count('(') - group.count(')')\
    \ }\nend", "    # put your code here\nend", "\treturn paren_string.split(\" \"\
    ).map { |p| p.chars.each_with_object(Hash.new(0)) { |c, c_count| c_count[c] +=\
    \ 1 }[\"(\"] }\nend", "  counter = 0\n  paren_arr = paren_string.split(/\\s+/)\n\
    \  paren_arr.each do |paren|\n    max_counter = 0\n    paren.split('').each do\
    \ |char|\n      if char == '('\n        counter += 1\n      elsif char == ')'\n\
    \        counter -= 1\n      end\n      max_counter = counter if counter > max_counter\n\
    \    end\n    paren_arr[paren_arr.index(paren)] = max_counter\n  end\n  return\
    \ paren_arr\nend", "  max_count = 0\n  results = []\n  count = 0\n  paren_string.each_char\
    \ do |c|\n    case c\n    when '('\n      count += 1\n      max_count = count\
    \ if count > max_count\n    when ')'\n      count -= 1\n    when ' '\n      results\
    \ << max_count\n      max_count = 0\n      count = 0\n    end\n  end\n  results\
    \ << max_count\n  results\nend", "  result = []\n  paren_string.split(' ').each\
    \ do |paren_group|\n    result << get_nested_parens_depth(paren_group)\n  end\n\
    \  result\nend", "  # Write your code here\n  count = 0\n  result = []\n  max_count\
    \ = 0\n  paren_string.each_char do |ch|\n    if ch == '('\n      count += 1\n\
    \      max_count = count if count > max_count\n    elsif ch == ')'\n      count\
    \ -= 1\n    elsif ch == ' '\n      result << max_count\n      max_count = 0\n\
    \      count = 0\n    end\n  end\n  result << max_count\n  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
