name: HumanEval_6_parse_nested_parens
language: rb
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\"\
  )\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n\
  \    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"\
  (()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"\
  () (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"\
  ))\n  end\nend\n"
completions: ["  paren_string.split(\" \").each_with_object([]) do |paren_group, levels|\n\
    \    levels << parse_parens(paren_group).map(&:length).max\n  end\nend", "  paren_string.split('\
    \ ').map { |paren_group| num_levels_of_nesting(paren_group) }\nend", "  # TODO:\
    \ Implement this!\nend", "  paren_string.split.map do |group|\n    paren_stack\
    \ = []\n    max_nest = 0\n    group.chars.each do |paren|\n      if paren == '('\n\
    \        paren_stack.push(paren)\n        max_nest = [max_nest, paren_stack.length].max\n\
    \      else\n        paren_stack.pop\n      end\n    end\n    max_nest\n  end\n\
    end", "  result = []\n  paren_string.split(\" \").each do |paren|\n    paren_stack\
    \ = []\n    count = 0\n    paren.each_char do |char|\n      if char == \"(\"\n\
    \        paren_stack.push(char)\n        count += 1\n      elsif char == \")\"\
    \n        paren_stack.pop\n        count += 1\n      end\n    end\n    result.push(count)\n\
    \  end\n  result\nend", "  max_level = 0\n  current_level = 0\n  result = []\n\
    \  paren_string.chars.each do |paren|\n    case paren\n    when '('\n      current_level\
    \ += 1\n      max_level = current_level if current_level > max_level\n    when\
    \ ')'\n      current_level -= 1\n    when ' '\n      result << max_level\n   \
    \   max_level = 0\n      current_level = 0\n    end\n  end\n  result << max_level\n\
    end", "  # paren_string is a string with the format like \"(()()) ((())) () ((())()())\"\
    \n  # splitting on spaces and map through each group\n  paren_string.split(\"\
    \ \").map do |group|\n    paren_count = 0\n    # loop through each char and increment\
    \ counter when \"(\"\n    # max value is the maximum value of paren_count\n  \
    \  group.chars.map { |char| paren_count += 1 if char == \"(\" }.max\n  end\nend",
  "  paren_string.split(' ').map { |group| find_max_nested_parens(group) }\nend",
  "  return [] if paren_string.nil?\n  num_of_parens = paren_string.scan(/\\(/).size\n\
    \  return [] if num_of_parens.zero?\n  # this hash will store depth of nestings\
    \ for each closing parentheses.\n  # We will use closing parens because they will\
    \ have to match an opening parenthesis before them.\n  # Only then we can say\
    \ that we have a valid match.\n  results = []\n  paren_hash = {}\n  paren_string.split(\"\
    \ \").each do |paren_substr|\n    depth = 0\n    paren_substr.chars.each do |ch|\n\
    \      if ch == \"(\"\n        depth += 1\n      elsif ch == \")\"\n        paren_hash[depth]\
    \ = (paren_hash[depth] || 0) + 1\n        depth -= 1\n      end\n    end\n   \
    \ results << paren_hash.keys.max || 0\n    paren_hash = {}\n  end\n  results\n\
    end", "  paren_string.split.map { |group|\n    nested_depth = 0\n    max_nested_depth\
    \ = 0\n    group.chars.each { |char|\n      nested_depth += 1 if char == '('\n\
    \      nested_depth -= 1 if char == ')'\n      max_nested_depth = nested_depth\
    \ if nested_depth > max_nested_depth\n    }\n    max_nested_depth\n  }\nend",
  "\t# Fill in your code here\nend", "  # TODO: Insert your solution here\nend\n```",
  "  paren_string.split(' ').map { |item| item.chars.select { |i| i == '(' }.size\
    \ }\nend", "  max_levels = paren_string.split(\" \").map do |parens|\n    parens.chars.reduce(0)\
    \ do |max_level, char|\n      if char == \"(\"\n        max_level += 1\n     \
    \ elsif char == \")\"\n        max_level\n      end\n    end\n  end\nend", " \
    \ # TODO: implement this method\nend", "  i = 0\n  parenthesis_depth = []\n  while\
    \ i < paren_string.length\n    depth = 0\n    if paren_string[i] == \"(\"\n  \
    \    depth += 1\n      i += 1\n      while i < paren_string.length\n        if\
    \ paren_string[i] == \"(\"\n          depth += 1\n        elsif paren_string[i]\
    \ == \")\"\n          depth -= 1\n        end\n        i += 1\n        break if\
    \ depth == 0\n      end\n    else\n      i += 1\n    end\n    parenthesis_depth\
    \ << depth\n  end\n  parenthesis_depth\nend", "  count = 0\n  curr_max = 0\n \
    \ output = []\n  string = paren_string.split(\" \")\n  for i in 0..string.length\
    \ - 1\n    for j in 0..string[i].length - 1\n      if string[i][j] == \"(\"\n\
    \        count += 1\n        curr_max = count if count > curr_max\n      elsif\
    \ string[i][j] == \")\"\n        count -= 1\n      end\n    end\n    output <<\
    \ curr_max\n    curr_max = 0\n    count = 0\n  end\n  return output\nend", "\t\
    paren_groups = paren_string.split(\" \")\n\tmax_depth = []\n\tparen_groups.each\
    \ do |group|\n\t\tdepth = 0\n\t\tmax_depth_current = 0\n\t\tgroup.each_char do\
    \ |character|\n\t\t\tif character == \"(\"\n\t\t\t\tdepth += 1\n\t\t\t\tmax_depth_current\
    \ = depth if depth > max_depth_current\n\t\t\telsif character == \")\"\n\t\t\t\
    \tdepth -= 1\n\t\t\tend\n\t\tend\n\t\tmax_depth << max_depth_current\n\tend\n\t\
    return max_depth\nend", "  deepest_nesting = paren_string.split.map do |group|\n\
    \    parse_nested_parens_helper(group, 0, 0)\n  end\n  deepest_nesting\nend",
  "  paren_string.split(\" \").map do |string|\n    string.chars.reduce(0) do |depth,\
    \ char|\n      char == \"(\" ? depth + 1 : depth - 1\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
