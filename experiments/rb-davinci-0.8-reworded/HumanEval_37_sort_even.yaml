name: HumanEval_37_sort_even
language: rb
prompt: "# This function takes an array l and returns an array l' such that\n# l'\
  \ is identical to l in the odd indicies, while its values at the even indicies are\
  \ equal\n# to the values of the even indicies of l, but sorted.\n# >>> sort_even.call([1,\
  \ 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n\
  \    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1,\
  \ 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5,\
  \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12,\
  \ 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\n\
  end\n"
completions: ["  l.each_index.map { |i| i.even? ? l[i..i+1].sort : l[i] }\nend", " \
    \ x = 0\n  y = 1\n  loop do\n    if y == l.length\n      break\n    end\n    if\
    \ l[x] > l[y]\n      temp = l[x]\n      l[x] = l[y]\n      l[y] = temp\n    end\n\
    \    x += 2\n    y += 2\n  end\n  l\nend", "    new_list = []\n    l.each_with_index\
    \ { |val, i| new_list << (i % 2 == 0 ? val : l[i, 2].sort!) }\n    new_list\n\
    end", "\teven_indicies = l.each_index.select{|i| i.even?}\n\teven_indicies.each\
    \ do |i|\n\t\tl[i] = l[i].sort\n\tend\n\treturn l\nend", "  even = l.select.with_index\
    \ { |_e, i| i.even? }\n  odd = l.select.with_index { |_e, i| i.odd? }\n  even.sort!\n\
    \  even.zip(odd).flatten\nend", "  even = l.select { |i| i.even? }.sort\n  odd\
    \ = l.select { |i| i.odd? }\n  even.zip(odd).flatten\nend", "  l.map.with_index\
    \ { |n, i| i.even? ? n.sort : n }\nend", "  l.map.with_index do |num, i|\n   \
    \ if i.even?\n      l[i..i+1].sort\n    else\n      num\n    end\n  end.flatten\n\
    end", "  (1..l.length).step(2).each do |i|\n    l[i..-1] = l[i..-1].sort\n  end\n\
    \  l\nend", "  l.each_with_index.map { |num, i| i.even? ? l[i, 2].sort : num }\n\
    end", "\todds = l.select.with_index { |val, i| i.odd? }\n\tevens = l.select.with_index\
    \ { |val, i| i.even? }.sort\n\todds.zip(evens).flatten\nend", "  l.each_with_index.inject([])\
    \ do |r, (e, i)|\n    r.push(e) and next r if i.odd?\n    r.push(l[i, l.size].select(&:even?).sort\
    \ + l[i, l.size].select(&:odd?))\n  end\nend", "  res = l.dup\n  even_indexes\
    \ = []\n  res.each_index { |i| even_indexes << i if i.even? }\n  even_indexes.each\
    \ { |i| res[i] = res[i].sort }\n  res\nend", "  l' = []\n  even_index_array =\
    \ []\n  odd_index_array = []\n  for i in (0..l.length - 1)\n    if i % 2 == 0\n\
    \      even_index_array.push(l[i])\n    else\n      odd_index_array.push(l[i])\n\
    \    end\n  end\n  even_index_array.sort!\n  for i in (0..even_index_array.length\
    \ - 1)\n    l'.push(even_index_array[i])\n    l'.push(odd_index_array[i])\n  end\n\
    \  l'\nend", "\teven = l.find_all {|x| l.index(x).even?}\n\todd = l.find_all {|x|\
    \ l.index(x).odd?}\n\teven.sort!\n\t(even + odd).flatten\nend", "\tl.each_index.map\
    \ do |i|\n\t\tif i % 2 == 0\n\t\t\tl[i]\n\t\telse\n\t\t\tl[i].sort\n\t\tend\n\t\
    end\nend", "  a = lambda { |l| (0...l.length).map { |i| i.even? ? l[i..i+1].sort\
    \ : l[i] } }\n  b = lambda { |a| a.take(a.length-1) }\n  b.call(a.call(l))\nend",
  "    # fill in this code\nend", "  l.map.with_index do |item, index|\n    index.even?\
    \ ? item.sort : item\n  end\nend", "  (0...l.length).map { |i| (i%2).zero? ? l[i..i+1].sort\
    \ : l[i] }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
