name: HumanEval_59_largest_prime_factor
language: rb
prompt: "# Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  # >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n\
  # 2\ndef largest_prime_factor(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n\
  \    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n\
  \    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n\
  \    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n\
  \  end\nend\n"
completions: ["  return -1 if n <= 1\n  return 2 if n == 2\n  return n if n.prime?",
  "  # This can be solved more efficiently\n  (2..n/2).each do |x|\n    return largest_prime_factor(n/x)\
    \ if n % x == 0\n  end\n  n\nend", "  highest_prime = 0\n  (2..n).each do |i|\n\
    \    if n % i == 0\n      prime = true\n      for j in 2..i-1\n        if i %\
    \ j == 0\n          prime = false\n          break\n        end\n      end\n \
    \     if prime\n        highest_prime = i\n      end\n    end\n  end\n  highest_prime\n\
    end", "  prime_divisors = []\n  if n < 1 || is_prime?(n)\n    puts \"Error. This\
    \ number is too small or is prime.\"\n  else\n    i = 2\n    while i <= Math.sqrt(n)\n\
    \      if is_prime?(i) && n % i == 0\n        prime_divisors << i\n      end\n\
    \      i += 1\n    end\n  end\n  if prime_divisors.length > 0\n    prime_divisors.max\n\
    \  else\n    0\n  end\nend", '  return 2 if n == 2', "  # Prime factors of n are\
    \ less than or equal to sqrt(n)\n  (2..Math.sqrt(n)).each do |factor|\n    return\
    \ largest_prime_factor(n / factor) if n % factor == 0\n  end\n  return n\nend",
  "  factors = prime_factors(n)\n  factors.max\nend", "  (1..n).select { |i| n % i\
    \ == 0 && prime?(i) }.max\nend", "  i = 1\n  while i <= Math.sqrt(n)\n    if n\
    \ % i == 0\n      n /= i\n    else\n      i += 1\n    end\n  end\n  n\nend", " \
    \ n.prime_division.last[0]\nend", "  # TODO: Write solution for largest_prime_factor\n\
    end", "\tif n <= 1\n\t\traise \"Invalid input. n must be > 1 and not a prime.\"\
    \n\tend", "  # Your code here\nend", "  # http://www.calculatorsoup.com/calculators/math/prime-factors.php\n\
    \  # http://www.robertfoster.info/2012/01/factoring-2048-into-primes.html\n  n\
    \ = n.abs\n  prime_factors = []\n  i = 2\n  while i < n\n    if n % i == 0\n \
    \     prime_factors << i\n      n = n / i\n    else\n      i += 1\n    end\n \
    \ end\n  prime_factors << n\n  prime_factors.max\nend", "  largest_factor = 1\n\
    \  factor = 2\n  while n > 1\n    while n % factor == 0\n      largest_factor\
    \ = factor\n      n /= factor\n    end\n    factor += 1\n  end\n  largest_factor\n\
    end", "  sqrt_n = Math.sqrt(n).to_i\n  (2..sqrt_n).each do |i|\n    if n % i ==\
    \ 0\n      return largest_prime_factor(n / i)\n    end\n  end\n  n\nend", "  get_factors(n).select\
    \ { |i| is_prime?(i) }.max\nend", "  i = 2\n  factors = []\n  while i <= n do\n\
    \    if n % i == 0\n      factors << i\n      n /= i\n    else\n      i += 1\n\
    \    end\n  end\n  factors.last\nend", "  res = [nil, nil]\n  p = 2\n  while p\
    \ * p <= n\n    while n % p == 0\n      res = [p, res.first].max\n      n /= p\n\
    \    end\n    p += 1\n  end\n  res[1] = n if n > 1\n  res.max\nend", "  divisor\
    \ = 2\n  largest_prime = 2\n  quotient = n / divisor\n  while quotient > 1\n \
    \   if n % divisor == 0\n      quotient = n / divisor\n      largest_prime = divisor\
    \ if is_prime(divisor)\n    end\n    divisor += 1\n  end\n  return largest_prime\n\
    end", "  i = 2\n  last_factor = 1\n  while i <= n\n    if n % i == 0\n      last_factor\
    \ = i\n      n /= i\n    else\n      i += 1\n    end\n  end\n  last_factor\nend",
  "  return n if n.prime?\n  possible_factors = (1..n).to_a.select { |num| num.prime?\
    \ }\n  possible_factors.reject! { |num| n % num != 0 }\n  possible_factors.max\n\
    end", "  max_prime = 0\n  (1..n).each do |i|\n    if n % i == 0 && prime?(i)\n\
    \      max_prime = i\n    end\n  end\n  max_prime\nend", "  prime_factors(n).max\n\
    end", "  # get all factors of n\n  # return the largest prime factor\n  largest_prime_factor\
    \ = 0\n  # iterate by 2's with a while loop.\n  (1..Math.sqrt(n)).each do |factor|\n\
    \    if n % factor == 0 && is_prime?(factor)\n      largest_prime_factor = factor\n\
    \    end\n  end\n  largest_prime_factor\nend", "  i = 2\n  largest_factor = 0\n\
    \  while i * i <= n\n    if n % i == 0\n      largest_factor = i\n      n /= i\n\
    \    else\n      i += 1\n    end\n  end\n  largest_factor = n if n > 1\n  largest_factor\n\
    end", "  # n = n / 2 while n % 2 == 0\n  # n = n / 3 while n % 3 == 0\n  # n =\
    \ n / 5 while n % 5 == 0\n  # n = n / 7 while n % 7 == 0\n  # n\n  factor_of(n).max\n\
    end", "  return n if n == 2\n  largest_prime_factor(n / 2)\nend", "  prime_factors(n).max\n\
    end", "  # Go through each number up to n to see if it is a factor\n  # Only check\
    \ up to sqrt(n) since if a number > sqrt(n)\n  # is a factor of n, then the other\
    \ factor must be < sqrt(n)\n  # and we must have already found it\n  max_factor\
    \ = Math.sqrt(n).to_i\n  (2..max_factor).each do |factor|\n    if n % factor ==\
    \ 0 && is_prime(factor)\n      return factor\n    end\n  end\nend", "  (1..n/2).each\
    \ do |i|\n    if n % i == 0\n      if is_prime(i)\n        return i\n      end\n\
    \    end\n  end\nend", "  divisor = 3\n  max_divisor = Math.sqrt(n).floor", " \
    \ primes = []\n  i = 2\n  while i < n\n    primes << i if is_prime(i) && n % i\
    \ == 0\n    i += 1\n  end\n  primes.last\nend", "  i = 3\n  while n > 1\n    if\
    \ n % i == 0\n      n /= i\n    else\n      i += 2\n    end\n  end\n  i\nend",
  "  primes(n).sort.last\nend", "  i = 2\n  while i * i <= n\n    if n % i == 0\n\
    \      n /= i\n    else\n      i += 1\n    end\n  end\n  n\nend", "  (2..n).each\
    \ do |i|\n    return largest_prime_factor(n / i) if n % i == 0\n  end\n  n\nend",
  "  if n % 2 == 0\n    max_prime = 2\n    n /= 2 while n % 2 == 0\n  else\n    max_prime\
    \ = 1\n  end", "  div = 2\n  while n > 1\n    while n % div == 0\n      n /= div\n\
    \    end\n    div += 1\n  end\n  div-1\nend", "  (2..Math.sqrt(n)).each do |p|\n\
    \    if n % p == 0\n      n /= p\n      n = n / p while n % p == 0\n    end\n\
    \  end\n  n\nend", "    prime_factors(n).max\nend", "    i = 2\n    while n >\
    \ 1\n        if n % i == 0\n            n /= i\n        else\n            i +=\
    \ 1\n        end\n    end\n    i\nend", "  # Solve the problem here\nend", " \
    \   i = 2\n    while (i * i <= n)\n        while (n % i == 0)\n            n /=\
    \ i\n        end\n        i += 1\n    end\n    return n\nend", "  i = 2\n  while\
    \ i <= n\n    if n % i == 0\n      n /= i\n    else\n      i += 1\n    end\n \
    \ end\n  i\nend", "  i = 2\n  while i * i <= n\n    if n % i == 0\n      n /=\
    \ i\n    else\n      i += 1\n    end\n  end\n  n\nend", "    # Write your code\
    \ here\nend", "  (n-1).downto(2) do |i|\n    if n % i == 0 && prime?(i)\n    \
    \  return i\n    end\n  end\nend", "  i = 2\n  largest_prime = 0\n  until n ==\
    \ 1 do\n    if n % i == 0\n      n /= i\n      largest_prime = i\n    else\n \
    \     i += 1\n    end\n  end\n  largest_prime\nend", "  raise if n <= 1 || prime?(n)\n\
    \  max = Math.sqrt(n).to_i\n  factors = (2..max).select { |x| n % x == 0 }.map\
    \ { |x| [x, n / x] }.flatten.uniq\n  largest_prime_factor = factors.select { |x|\
    \ prime?(x) }.max\n  largest_prime_factor\nend", "  i = 2\n  while i < n\n   \
    \ if n % i == 0\n      n /= i\n    else\n      i += 1\n    end\n  end\n  n\nend",
  "  if n.prime?\n    n\n  else\n    (1..n).to_a.reverse.each do |i|\n      if n %\
    \ i == 0 && i.prime?\n        return i\n      end\n    end\n  end\nend", "  #\
    \ The first factor will be the smallest prime factor of n, which is the smallest\n\
    \  # prime number that divides n. This can be found using the smallest_prime_factor\n\
    \  # function above.\n  smallest_prime_factor(n)", "  i = 2\n  factors = []\n\
    \  while i <= n\n    if n % i == 0\n      n /= i\n      factors << i\n    else\n\
    \      i += 1\n    end\n  end\n  factors.max\nend", "\ti = 2\n\twhile n != 1\n\
    \t\tif n % i == 0\n\t\t\tn /= i\n\t\telse\n\t\t\ti += 1\n\t\tend\n\tend\n\ti\n\
    end", "  prime_factors(n).max\nend", "  prime_factors(n).max\nend", "  factors\
    \ = prime_factors(n)\n  factors.last\nend", "  # Set 1st value, initial_value\
    \ to n\n  # Set 2nd value, factorial to 1\n  # Loop (While the factorial is less\
    \ than the initial_value)\n  # Set 3rd value, count to 2\n  # Set 4th value, prime_factor\
    \ to 1\n  # Iterate to next value (While the count is less than the square root\
    \ of the initial_value)\n  # If the initial_value divided by the count has no\
    \ remainder\n  # Set the prime_factor to the count\n  # End the iteration\n  #\
    \ End the iteration\n  # Set the factorial to the prime_factor\n  # End the loop\n\
    \  # Return the prime_factor\nend", "  prime_factors(n).last\nend", "  # your\
    \ code here\nend", "  i = 2\n  until n == 1\n    if n % i == 0\n      n /= i\n\
    \    else\n      i += 1\n    end\n  end\n  i\nend", "  return n if n.prime?\n\
    \  n.prime_division.flatten.max\nend", "  largest_prime = 0\n  for i in (1..n)\n\
    \    if n % i == 0\n      if is_prime(i)\n        largest_prime = i\n      end\n\
    \    end\n  end\n  largest_prime\nend", "  i = 2\n  while i < n\n    if n % i\
    \ == 0\n      n /= i\n    else\n      i += 1\n    end\n  end\n  n\nend", "  return\
    \ n if n < 2\n  factor = (2..Math.sqrt(n)).find { |x| n % x == 0 }\n  factor ?\
    \ largest_prime_factor(n / factor) : n\nend", "\t# Set current prime to the largest\
    \ prime factor of n (which is n itself)\n\t# Iterate from 2 up to n, checking\
    \ to see if each number is prime, and if it is, check to see if it is a factor\
    \ of n\n\t# Return the first prime that is a factor of n", "  (1..Math.sqrt(n)).each\
    \ do |num|\n    return n if n % num == 0 && prime?(n / num)\n  end\nend", "  \
    \  (2..Math.sqrt(n)).each do |x|\n        if n % x == 0\n            return largest_prime_factor(n\
    \ / x)\n        end\n    end\n    return n\nend", "  2.upto(n / 2) do |i|\n  \
    \  if (n % i == 0)\n      return [i, largest_prime_factor(n / i)].max\n    end\n\
    \  end\n  n\nend", "  return 1 if n == 1\n  (2..n).each do |i|\n    if n % i ==\
    \ 0\n      return [i, *largest_prime_factor(n / i)].max\n    end\n  end\nend",
  "  i = 2\n  while i * i <= n\n    if n % i == 0\n      n /= i\n    else\n      i\
    \ += 1\n    end\n  end\n  n\nend", "  max_factor = nil\n  n.downto(2) do |i|\n\
    \    if n % i == 0\n      if is_prime?(i)\n        max_factor = i\n        break\n\
    \      end\n    end\n  end\n  max_factor\nend", "  factors = []\n  i = 2\n  while\
    \ i <= n\n    factors << i if (n % i).zero?\n    i += 1\n  end\n  prime_factors\
    \ = factors.select { |x| is_prime?(x) }\n  prime_factors.max\nend", "  i = 2\n\
    \  while i < n\n    if n % i == 0\n      n /= i\n    else\n      i += 1\n    end\n\
    \  end\n  n\nend", "  last_factor = 1\n  factor = 2\n  while n > 1\n    if n %\
    \ factor == 0\n      last_factor = factor\n      n /= factor\n      while n %\
    \ factor == 0\n        n /= factor\n      end\n    end\n    factor += 1\n  end\n\
    \  last_factor\nend", "  p n\n  i = 1\n  factor = -1\n  loop do\n    i += 1\n\
    \    if n % i == 0\n      n /= i\n      factor = i\n    end\n    break if n ==\
    \ 1\n  end\n  factor\nend", "  n.downto(2) do |i|\n    if n % i == 0 && is_prime(i)\n\
    \      return i\n    end\n  end\nend", "  while n % 2 == 0\n    n /= 2\n  end\n\
    \  p = 3\n  while p <= n\n    while n % p == 0\n      n /= p\n    end\n    p +=\
    \ 2\n  end\n  n\nend", "  raise \"#{n} must be > 1\" if n <= 1\n  raise \"#{n}\
    \ is prime\" if n.prime?", "  primes = Prime.each(Math.sqrt(n)).to_a\n  primes.reverse.each\
    \ do |p|\n    return p if n % p == 0\n  end\nend", "  factor = 2\n  while factor\
    \ <= n\n    while n % factor == 0\n      n /= factor\n    end\n    factor += 1\n\
    \  end\n  factor - 1\nend", '  return 2 if n == 2', "  primes = []\n  # Odd numbers\
    \ cannot be divisible by 2\n  for i in 3..n do\n    break if i >= n\n    primes\
    \ << i if is_prime(i) && n % i == 0\n  end\n  primes.last\nend", "  # TODO\nend",
  "  (1..n).select { |x| prime?(x) && n % x == 0 }.max\nend", "  factors = primes_below(n)\n\
    \  factors.last\nend", "  i = 2\n  loop do\n    if n % i == 0\n      n /= i\n\
    \    else\n      i += 1\n    end\n    break if n <= i\n  end\n  n\nend", "  arr\
    \ = prime_factors(n)\n  arr[-1]\nend", "  @primes.take_while { |x| x <= n }.reverse.detect\
    \ { |x| n % x == 0 }\nend", "  m = n\n  i = 2\n  while i*i <= m\n    if m % i\
    \ == 0\n      m /= i\n    else\n      i += 1\n    end\n  end\n  m\nend", "  (2..n).each\
    \ do |d|\n    return d if n % d == 0 && prime?(d)\n  end\nend", "  factor = (2..n).find\
    \ { |f| n % f == 0 }\n  if factor == n\n    factor\n  else\n    largest_prime_factor(n\
    \ / factor)\n  end\nend", "  (2..n).each do |divisor|\n    if n % divisor == 0\n\
    \      n /= divisor\n      return largest_prime_factor(n)\n    end\n  end\n  n\n\
    end", '  # return if n <= 1', "  # n = n / i while n % i == 0\n  # n / i\n  factor\
    \ = 2\n  while factor <= n\n    if n % factor == 0\n      n = n / factor\n   \
    \ else\n      factor += 1\n    end\n  end\n  factor\nend", "  return false if\
    \ n < 2 || n == 3\n  return 2 if n == 4\n  n.downto(2) do |i|\n    return i if\
    \ (n % i).zero? && prime?(i)\n  end\nend", "  if n <= 1\n    raise \"Please provide\
    \ a number greater than 1\"\n  elsif is_prime?(n)\n    raise \"Please provide\
    \ a number which is not a prime\"\n  end", "  prime_factors(n).last\nend", " \
    \ i = 2\n  while i < n\n    while n % i == 0\n      n /= i\n    end\n    i +=\
    \ 1\n  end\n  n\nend", "  while n % 2 == 0\n    n /= 2\n  end\n  (3..Math.sqrt(n)).step(2)\
    \ do |i|\n    while n % i == 0\n      n /= i\n    end\n  end\n  n\nend", "  i\
    \ = 2\n  while i < n \n    if n % i == 0\n      prime = true\n      (2..Math.sqrt(i)).each\
    \ do |j|\n        if i % j == 0\n          prime = false\n          break\n  \
    \      end\n      end\n      return i if prime\n    end\n    i += 1\n  end\nend",
  "  i = 2\n  largest_prime = 0\n  while i <= n\n    if n % i == 0\n      largest_prime\
    \ = i\n      n /= i\n    else\n      i += 1\n    end\n  end\n  largest_prime\n\
    end", "  # Your code here\nend", "  max_prime = 0\n  (1..n).each do |num|\n  \
    \  if n % num == 0 && is_prime?(num)\n      max_prime = num\n    end\n  end\n\
    \  max_prime\nend", "  # returns the largest prime factor of n. Assume n > 1 and\
    \ is not a prime.\n  smallest_prime_factor(n)", "  factor = 0\n  i = 1\n  while\
    \ (i <= n)\n    if n % i == 0\n      if prime?(i)\n        factor = i\n      end\n\
    \    end\n    i += 1\n  end\n  return factor\nend", "  raise ArgumentError, \"\
    argument must be > 1\" if n <= 1\n  prime_factors(n).last\nend", "    # all prime\
    \ factors of n, then get the last one.\n    prime_factors(n).last\nend", "  nums\
    \ = (2..n).select { |i| n % i == 0 }\n  nums.reverse_each do |num|\n    if is_prime?(num)\n\
    \      return num\n    end\n  end\nend", "  max_prime = 1\n  (2..n).each do |i|\n\
    \    if n % i == 0\n      max_prime = i\n      n /= i\n    end\n  end\n  max_prime\n\
    end", "  return 1 if n < 2\n  factor = 2\n  while factor <= n\n    return n if\
    \ n == factor\n    n /= factor while n % factor == 0\n    factor += 1\n  end\n\
    end", "  factors = prime_factors(n)\n  factors.max\nend", "  factor = n - 1\n\
    \  while n % factor != 0\n    factor -= 1\n  end\n  factor\nend", "  max_pf =\
    \ 0\n  pf = 2\n  while pf <= n\n    if n % pf == 0\n      max_pf = pf\n      n\
    \ /= pf\n    else\n      pf += 1\n    end\n  end\n  max_pf\nend", "  for i in\
    \ (2..n/2)\n    if n % i == 0\n      return largest_prime_factor(n/i)\n    end\n\
    \  end\n  return n\nend", "  num = n\n  largest_prime = 2\n  while largest_prime\
    \ < num\n    if num % largest_prime == 0\n      num /= largest_prime\n    else\n\
    \      largest_prime += 1\n    end\n  end\n  largest_prime\nend", "  Prime.each(Math.sqrt(n).floor)\
    \ do |p|\n    return p if n % p == 0\n  end\nend", "  return n if n < 4\n  factors\
    \ = []\n  factor = 2\n  while factor < n\n    if n % factor == 0\n      factors\
    \ << factor\n      n /= factor\n    else\n      factor += 1\n    end\n  end\n\
    \  factors << n\n  factors.max\nend", "  factor = 2\n  while factor <= n\n   \
    \ if n % factor == 0\n      n /= factor\n    else\n      factor += 1\n    end\n\
    \  end\n  factor\nend", "  return n if prime?(n)\n  remainder = n\n  factor =\
    \ 2\n  prime_factors = []\n  while remainder > 1\n    if remainder % factor ==\
    \ 0\n      remainder /= factor\n      prime_factors << factor\n    else\n    \
    \  factor += 1\n    end\n  end\n  prime_factors.max\nend", "  max_prime = 1\n\
    \  (2..n).each do |i|\n    if (n % i == 0) && prime?(i)\n      max_prime = i\n\
    \    end\n  end\n  max_prime\nend", "  primes = []\n  (2..n).each do |x|\n   \
    \ primes << x if is_prime?(x)\n  end\n  primes.last\nend", "  i = 2\n  while i\
    \ <= n\n    if n % i == 0\n      n /= i\n    else\n      i += 1\n    end\n  end\n\
    \  i\nend", "  limit = Math.sqrt(n).floor\n  factor = 2\n  until factor > limit\n\
    \    # p \"#{factor} #{n}\"\n    n /= factor while n % factor == 0\n    factor\
    \ += 1\n  end\n  n\nend", "  prime_factors(n).last\nend", "  divisor = 2\n  while\
    \ n > 1\n    if n % divisor == 0\n      n /= divisor\n    else\n      divisor\
    \ += 1\n    end\n  end\n  divisor\nend", "  factor = 2\n  while factor < n\n \
    \   if n % factor == 0\n      n /= factor\n    else\n      factor += 1\n    end\n\
    \  end\n  factor\nend", "  # Recursion method\n  # if n <= 1\n  #   return n\n\
    \  # end\n  # # base case\n  # if n.prime?\n  #   return n\n  # end\n  # (2..n).each\
    \ do |d|\n  #   if n % d == 0\n  #     return largest_prime_factor(n / d)\n  #\
    \   end\n  # end\n  # nil", "  factors = prime_factors(n)\n  factors.last\nend",
  "  largest_prime = 1\n  if n < 2\n    return nil\n  end\n  for i in (2..n)\n   \
    \ if is_prime?(i)\n      if n % i == 0\n        largest_prime = i\n      end\n\
    \    end\n  end\n  return largest_prime\nend", "\ti = 2\n\twhile i <= n\n\t\t\
    if n % i == 0\n\t\t\tn /= i\n\t\telse\n\t\t\ti += 1\n\t\tend\n\tend\n\ti\nend",
  "  # Return largest prime factor of n. Assume n > 1 and is not a prime.\n  # >>>\
    \ largest_prime_factor.call(13195)\n  # 29\n  # >>> largest_prime_factor.call(2048)\n\
    \  # 2\n  largest_factor = 1\n  (2..n).each do |i|\n    while n % i == 0\n   \
    \   largest_factor = i\n      n /= i\n    end\n  end\n  largest_factor\nend",
  "  # TODO\nend", "  i = 2\n  while i < n\n    return largest_prime_factor(n / i)\
    \ if n % i == 0\n    i += 1\n  end\n  n\nend", "  factors = prime_factors(n)\n\
    \  factors.last\nend", "  # ...\nend", "  2.upto(n) do |factor|\n    if n % factor\
    \ == 0\n      n /= factor\n      n = n / factor while n % factor == 0\n    end\n\
    \  end\n  n\nend", "  factor = find_factor(n)\n  if prime?(factor)\n    factor\n\
    \  else\n    largest_prime_factor(factor)\n  end\nend", "  x = (2..Math.sqrt(n)).find\
    \ { |x| n % x == 0 }\n  x ? [x, largest_prime_factor(n / x)].max : n\nend", " \
    \ prime_factors(n).max\nend", "\t# Get the initial divisor\n\tdivisor = 2\n\t\
    n_original = n\n\t# Initialize the array of prime factors\n\tprime_factors = []\n\
    \tuntil n == 1\n\t\t# Break if n is a prime\n\t\tif is_prime?(n)\n\t\t\t# puts\
    \ \"Found the prime: #{n}\"\n\t\t\tprime_factors << n\n\t\t\tbreak\n\t\tend\n\t\
    \t# Get the largest prime factor from n_original / divisor\n\t\tif (n_original\
    \ / divisor) % divisor == 0\n\t\t\t# puts \"n_original is #{n_original} and divisor\
    \ is #{divisor}\"\n\t\t\t# puts \"n_original / divisor is #{n_original / divisor}\"\
    \n\t\t\tlargest_prime_factor = largest_prime_factor(n_original / divisor)\n\t\t\
    \t# puts \"The largest prime factor of #{n_original / divisor} is #{largest_prime_factor}\"\
    \n\t\t\tprime_factors << largest_prime_factor\n\t\t\t# Find n with n / largest_prime_factor\n\
    \t\t\tn = n / largest_prime_factor\n\t\t\t# puts \"n is now #{n}\"\n\t\tend\n\t\
    \t# Increment the divisor\n\t\tdivisor += 1\n\tend\n\t# Return the largest prime\
    \ factor\n\tprime_factors.max\nend", "  i = 1\n  while i <= n\n    if n % i ==\
    \ 0\n      n /= i\n    else\n      i += 1\n    end\n  end\n  i\nend", "  # go\
    \ through the numbers from 2 up to n\n  # if it's divisible, divide out that factor\n\
    \  # continue until you get a prime\n  i = 2\n  while i < n\n    if n % i == 0\n\
    \      n /= i\n    else\n      i += 1\n    end\n  end\n  return n\nend", "  #\
    \ current largest factor, increment until we find a prime factor\n  factor = 2\n\
    \  while (n > 1)\n    if (n % factor == 0)\n      # prime factor is factor, or\
    \ larger prime factor\n      # divide by this prime factor so we can test if n\
    \ is now prime\n      n /= factor\n    else\n      # n is not divisible by factor,\
    \ so increment factor\n      factor += 1\n    end\n  end\n  factor\nend", "  return\
    \ n unless n.even?\n  return 2 if n == 2", "  (1..n).select { |x| n % x == 0 }.select\
    \ { |x| is_prime(x) }.max\nend", "  factors = []\n  i = 2\n  while n > 1\n   \
    \ while n % i == 0\n      factors << i\n      n /= i\n    end\n    i += 1\n  end\n\
    \  factors.last\nend", "  # TODO: Implement the method\nend", "  i = 2\n  while\
    \ i <= n do\n    if n % i == 0\n      n /= i\n    else\n      i += 1\n    end\n\
    \  end\n  i\nend", "  div = 3\n  while n > 1\n    if n % div == 0\n      n /=\
    \ div\n    else\n      div += 2\n    end\n  end\n  div\nend", "  if (is_prime(n))\n\
    \    return n\n  end\n  factors = prime_factors(n)\n  return factors[factors.length\
    \ - 1]\nend", "  # n = n.to_i\n  # n = n.abs\n  l_prime = nil\n  (2..n).each do\
    \ |num|\n    if n % num == 0\n      if l_prime.nil?\n        l_prime = num\n \
    \     else\n        #print \"prime = #{num}\"\n        #print \" l_prime = #{l_prime}\"\
    \n        l_prime = prime_or_not(num, l_prime)\n        #print \" l_prime = #{l_prime}\"\
    \n        #print \"\\n\"\n      end\n    end\n  end\n  l_prime\nend", "  # http://en.wikipedia.org/wiki/Prime_number\n\
    \  # http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n  raise ArgumentError.new('n\
    \ must be an integer') unless n.is_a? Integer\n  raise ArgumentError.new('n must\
    \ be > 1') unless n > 1\n  primes = sieve_of_eratosthenes(n)\n  largest_prime\
    \ = 1\n  primes.each do |prime|\n    if n % prime == 0\n      largest_prime =\
    \ prime\n    end\n  end\n  largest_prime\nend", "  i = 2\n  while i * i <= n\n\
    \    if n % i == 0\n      n /= i\n    else\n      i += 1\n    end\n  end\n  n\n\
    end", "  max_factor = -1\n  (2..n-1).each do |i|\n    if n % i == 0\n      if\
    \ is_prime?(i)\n        max_factor = i\n      end\n    end\n  end\n  max_factor\n\
    end", "  i = 2\n  until n == i\n    n /= i while (n > i && n % i == 0)\n    i\
    \ += 1\n  end\n  n\nend", "  # base case.\n  return n if n.prime?", "  (2..n).find\
    \ { |i| n % i == 0 && prime?(i) }\nend", "    (1..n).reverse_each do |num|\n \
    \       next if num == 1\n        next if num == n\n        return num if prime?(num)\
    \ && n % num == 0\n    end\nend", "  # prime numbers\n  # can be divided evenly\
    \ only by 1 or itself\n  # and it must be a whole number greater than 1\n  # source\
    \ https://www.mathsisfun.com/prime-composite-numbers.html", "  factor = 2\n  while\
    \ factor <= n\n    if n % factor == 0\n      n /= factor\n    else\n      factor\
    \ += 1\n    end\n  end\n  factor\nend", "  factor = 2\n  while factor * factor\
    \ <= n\n    while n % factor == 0\n      n /= factor\n    end\n    factor += 1\n\
    \  end\n  return n\nend", "  # return 1 if n == 1\n  # return n if n.prime?\n\
    \  # largest_prime_factor(n / 2)", "  lpf = 1\n  (2..n).each do |i|\n    if n\
    \ % i == 0\n      lpf = i\n      n /= i\n      redo\n    end\n  end\n  lpf\nend",
  "  # Create a list of prime numbers.\n  primes = (1..n).select do |m|\n    [1,m].all?\
    \ do |x|\n      m % x == 0\n    end\n  end", "    # we don't need to check past\
    \ sqrt(n)\n    upper_bound = Math.sqrt(n).floor\n    (upper_bound).downto(2) do\
    \ |i|\n        if n % i == 0\n            return largest_prime_factor(i)\n   \
    \     end\n    end\n    return n\nend", "  (2..n).reverse_each do |i|\n    return\
    \ i if n % i == 0 && is_prime(i)\n  end\nend", "  i = 2\n  while i < n\n    if\
    \ n % i == 0\n      n /= i\n    else\n      i += 1\n    end\n  end\n  n\nend",
  "  # Error checking\n  return nil if n <= 1", "  n.downto(2) do |i|\n    return\
    \ i if n % i == 0 && prime?(i)\n  end\nend", "  prime_factors(n).last\nend", " \
    \ prime_factors(n).max\nend", "  # x is a prime factor of n\n  # x > n/2\n  #\
    \ n/x <= n/2\n  # x >= n/2\n  # if n is a prime, then return n\n  largest_factor\
    \ = n\n  (n/2).downto(2) do |i|\n    if is_factor?(n, i)\n      largest_factor\
    \ = i\n      break\n    end\n  end\n  largest_factor\nend", "  2.upto(n) do |i|\n\
    \    return i if n % i == 0 && is_prime?(i)\n  end\nend", "  primes_upto(n).reverse.each\
    \ do |prime|\n    if n % prime == 0\n      return prime\n    end\n  end\nend",
  "  # This is an efficient way to get primes, using the Sieve of Eratosthenes\n \
    \ # The algorithm is:\n  # Create a list of consecutive integers from 2 through\
    \ n: (2, 3, 4, ..., n).\n  # Initially, let p equal 2, the smallest prime number.\n\
    \  # Enumerate the multiples of p by counting to n from 2p in increments of p,\
    \ and mark them in the list (these will be 2p, 3p, 4p, ...; the p itself should\
    \ not be marked).\n  # Find the first number greater than p in the list that is\
    \ not marked. If there was no such number, stop. Otherwise, let p now equal this\
    \ new number (which is the next prime), and repeat from step 3.\n  # When the\
    \ algorithm terminates, the numbers remaining not marked in the list are all the\
    \ primes below n.\n  #\n  # See http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \  #\n  # But we don't need to get all primes, we just need the largest prime\
    \ factor of n.\n  # So we'll do some optimizations and just stop once we have\
    \ the largest prime factor\n  n = n.to_i\n  return nil if n <= 1\n  return n if\
    \ n.prime?", "  # look through factors of n and return the max prime factor\n\
    \  factor = n\n  # if factor is not prime, divide it by a prime until it is prime\
    \ and\n  # then return it\n  return factor if prime?(factor)\n  # otherwise, keep\
    \ dividing factor by a prime until we've reached\n  # 2, in which case return\
    \ 2", "  # If n is even we may as well discard it as a possibility.\n  n = n/2\
    \ while n.even?\n  # Now we can increment factor by 2 and still be odd.\n  factor\
    \ = 3\n  # Stop when we get to n/factor because if factor was a factor,\n  # we\
    \ would have found it by now.\n  while n > factor do\n    # If factor divides\
    \ n evenly, make n smaller by dividing it by\n    # factor.\n    if n % factor\
    \ == 0\n      n = n/factor\n    else\n      # Otherwise increment factor by 2.\n\
    \      factor += 2\n    end\n  end\n  return n\nend", "  if n == 2\n    return\
    \ 2\n  end\n  (1..n).select { |i| n % i == 0 && is_prime?(i) }.max\nend", "  if\
    \ n <= 3\n    return n\n  end", "  return nil if n < 1 || is_prime?(n)\n  primes\
    \ = []\n  current_divisor = 2\n  while current_divisor <= n / 2\n    primes <<\
    \ current_divisor if is_prime?(current_divisor) && n % current_divisor == 0\n\
    \    current_divisor += 1\n  end\n  primes.max\nend", "  # Your code here\nend",
  "  # You code here\nend", "  factors = prime_factors(n)\n  factors.max\nend", " \
    \ factors = factor_array(n)\n  largest_prime_factors(factors)\nend", "  # TODO\n\
    end", "  # https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic\n \
    \ # For any integer n > 1, there exists a unique factorization of n as a product\
    \ of prime numbers.\n  raise NotImplementedError\nend", "  factor = 2\n  max_factor\
    \ = 0\n  while n > 1\n    if n % factor == 0\n      max_factor = factor\n    \
    \  n /= factor\n      while n % factor == 0\n        n /= factor\n      end\n\
    \    end\n    factor += 1\n  end\n  max_factor\nend", "  # YOUR CODE HERE\nend",
  "  max_prime = 2\n  while n > 1\n    max_prime = n if n.prime?\n    n /= 2 while\
    \ n % 2 == 0\n    n /= 3 while n % 3 == 0\n    n /= 5 while n % 5 == 0\n    n\
    \ /= 7 while n % 7 == 0\n    n /= 11 while n % 11 == 0\n    n /= 13 while n %\
    \ 13 == 0\n    n /= 17 while n % 17 == 0\n    n /= 19 while n % 19 == 0\n    n\
    \ /= 23 while n % 23 == 0\n    n /= 29 while n % 29 == 0\n    n /= 31 while n\
    \ % 31 == 0\n    n /= 37 while n % 37 == 0\n    n /= 41 while n % 41 == 0\n  \
    \  n /= 43 while n % 43 == 0\n    n /= 47 while n % 47 == 0\n    n /= 53 while\
    \ n % 53 == 0\n    n /= 59 while n % 59 == 0\n    n /= 61 while n % 61 == 0\n\
    \    n /= 67 while n % 67 == 0\n    n /= 71 while n % 71 == 0\n    n /= 73 while\
    \ n % 73 == 0\n    n /= 79 while n % 79 == 0\n    n /= 83 while n % 83 == 0\n\
    \    n /= 89 while n % 89 == 0\n    n /= 97 while n % 97 == 0\n    n /= 101 while\
    \ n % 101 == 0\n    n /= 103 while n % 103 == 0\n    n /= 107 while n % 107 ==\
    \ 0\n    n /= 109 while n % 109 == 0\n    n /= 113 while n % 113 == 0\n    n /=\
    \ 127 while n % 127 == 0\n    n /= 131 while n % 131 == 0\n    n /= 137 while\
    \ n % 137 == 0\n    n /= 139 while n % 139 == 0\n    n /= 149 while n % 149 ==\
    \ 0\n    n /= 151 while n % 151 == 0\n    n /= 157 while n % 157 == 0\n    n /=\
    \ 163 while n % 163 == 0\n    n /= 167 while n % 167 == 0\n    n /= 173 while\
    \ n % 173 == 0\n    n /= 179 while", "  return if n < 2\n  largest_factor = (2..n).find\
    \ { |factor| n % factor == 0 }\n  largest_prime_factor(n / largest_factor) ||\
    \ largest_factor\nend", "  prime_factorization(n).last\nend", "  (1..n).select\
    \ { |i| n % i == 0 && prime?(i) }.max\nend", "  while n % 2 == 0\n    n /= 2\n\
    \  end\n  root = Math.sqrt(n).floor\n  (3..root).step(2) do |i|\n    while n %\
    \ i == 0\n      n /= i\n    end\n  end\n  n\nend", "  i = 2\n  while i < n\n \
    \   if n % i == 0\n      n /= i\n    else\n      i += 1\n    end\n  end\n  n\n\
    end", "  (1..n).find_all { |x| n % x == 0 && prime?(x) }.max\nend", "  return\
    \ n if n < 2\n  max_pf = 1\n  (2..Math.sqrt(n)).each do |f|\n    if n % f == 0\n\
    \      max_pf = [max_pf, largest_prime_factor(f)].max\n      max_pf = [max_pf,\
    \ largest_prime_factor(n / f)].max\n    end\n  end\n  max_pf\nend", "  # Note:\
    \ This is definitely not the most efficient way to solve this problem.\n  (1..n).select\
    \ { |x| n % x == 0 }.select { |x| prime?(x) }.max\nend", "  (n-1).downto(2) do\
    \ |i|\n    next if i.even?\n    return i if (n % i).zero? && prime?(i)\n  end\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
