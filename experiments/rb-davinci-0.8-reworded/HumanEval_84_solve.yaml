name: HumanEval_84_solve
language: rb
prompt: "# Given a positive integer N, return the total sum of its digits in binary.\n\
  # Example\n# >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n#\
  \ >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0\
  \ \u2264 N \u2264 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n\
  \    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n\
  \    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n\
  \  end\nend\n"
completions: ["  return \"0\" if n == 0\n  #\n  # the way to solve this problem is\
    \ to do the base 10 computation\n  # on the binary number\n  #\n  a = []\n  while\
    \ n > 0\n    a << n % 2\n    n /= 2\n  end\n  a.reverse.join\nend", "  '%b' %\
    \ n\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  #..\n  digits\
    \ = []\n  until n == 0\n    r = n % 2\n    digits.push(r)\n    n = n / 2\n  end\n\
    \  digits.reverse.join\nend", "  n.to_s(2).split('').map { |n| n.to_i }.inject(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  n.to_s(2).split('').inject(0)\
    \ { |sum, s| sum + s.to_i }.to_s\nend", "  # your code here\nend\n```", "  n.to_s(2).sum.to_s\n\
    end", "  binary = n.to_s(2)\n  binary_arr = binary.split('')\n  total = 0\n  binary_arr.each\
    \ do |str|\n    str = str.to_i\n    total += str\n  end\n  total.to_s\nend", " \
    \ n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  # result = n.to_s(2)\n  # result.split('').reduce(0) { |acc, elem| acc\
    \ + elem.to_i }.to_s\n  result = ''\n  n.times do |i|\n    result += (n%2).to_s\n\
    \    n /= 2\n  end\n  result.reverse.split('').reduce(0) { |acc, elem| acc + elem.to_i\
    \ }.to_s\nend", "    n.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\n\
    end", "  binary = n.to_s(2)\n  result = 0\n  binary.split('').each do |number|\n\
    \    result += number.to_i\n  end\n  result.to_s\nend", "  result = ''\n  if n\
    \ >= 0 && n <= 10000\n    n.to_s(2).chars.each do |i|\n      result += i\n   \
    \ end\n  end\n  result\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  (\"%b\" % n).count(\"1\")\nend", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).split('').map { |i| i.to_i }.inject(:+)\nend", "  str = \"\"\
    \n  while n != 0\n    str = (n % 2).to_s + str\n    n = n / 2\n  end\n  str\n\
    end", "  n.to_s(2).chars.map(&:to_i).inject(:+)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "\tsolve_rec(n)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend",
  "  return \"0\" if n == 0\n  n.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  # convert to binary\n  # split string into array\n  # sum elements\n\
    \  # return result\n  # use base convert to base 2\n  # split string into array\n\
    \  # sum elements\n  # return result\n  # return result.to_s(2)", "  # your code\
    \ here\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  # write\
    \ your code here\n  n.to_s(2)\nend", "  n.to_s(2).chars.map(&:to_i).inject(:+)\n\
    end", "  \"#{n.to_s(2)}\"\nend", "  puts \"#{n.to_s(2)}\"\nend", "    n.to_s(2)\n\
    end", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\nend", "    num = n.to_s(2)\n\
    \    binary = num.split('')\n    answer = binary.reduce(0) { |x,y| x + y.to_i\
    \ }\n    answer.to_s\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend",
  "  #your code here\nend", "  n.to_s(2).split('').inject(0) { |sum, i| sum += i.to_i\
    \ }.to_s\nend", "  n.to_s(2).count('1')\nend", "  require 'pry'\n  n.to_s(2)\n\
    end", "\tn.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend",
  "  return \"\" if n == 0\n  return \"1\" if n == 1\n  new_n = n / 2\n  bit = (n\
    \ % 2).to_s\n  return bit + solve(new_n)\nend\nputs solve(0)\nputs solve(1)\n\
    puts solve(1000)\nputs solve(150)\nputs solve(147)", "  # write your code here\n\
    \  n.to_s(2)\nend", "  b = []\n  while n > 0\n    if n % 2 == 0\n      b.unshift(0)\n\
    \    else\n      b.unshift(1)\n    end\n    n = n / 2\n  end\n  b.join('')\nend",
  "    number = n.to_s(2)\n    sum_num = 0\n    number.split('').each { |i| sum_num\
    \ += i.to_i }\n    sum_num.to_s\nend", "  binary_string = \"\"\n  while n > 0\n\
    \    binary_string = (n % 2).to_s + binary_string\n    n /= 2\n  end\n  binary_string\n\
    end", "  # your code\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend",
  "  sum = 0\n  n.to_s(2).split('').each do |e|\n    sum += e.to_i\n  end\n  return\
    \ sum.to_s\nend", "  '%b' % n\nend", "  string_number = n.to_s\n  binary_string\
    \ = n.to_s(2)\n  binary_string\nend\np solve(147)", "  return n.to_s(2)\nend",
  "  n.to_s(2).split('').inject(0) { |acc, el| acc += el.to_i }.to_s\nend", "  n.to_s(2).count(\"\
    1\")\nend\np solve(8)", "    # write your code here\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "    n.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend",
  "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\n\
    end", "  n.to_s(2).chars.inject(0) { |sum, i| sum + i.to_i }.to_s\nend", "  n.to_s(2).chars.inject(0)\
    \ { |sum, x| sum + x.to_i }.to_s\nend", '  # ', "\treturn n.to_s(2)\nend", " \
    \ return [n].pack('i').bytes.inject(0) { |sum, x| sum += x % 2 }.to_s\nend", " \
    \ # write your code here\n  binary_n = n.to_s(2)\n  binary_n.split('').map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).chars.map { |x| x.to_i }.reduce(:+)\nend", "  n.to_s(2).chars.map(&:to_i).inject(:+)\n\
    end", "  # (n.to_s(2)).chars.inject(0) { |acc,x| acc += x.to_i }.to_s\n  (n.to_s(2)).scan(/\\\
    d/).map(&:to_i).inject(:+)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  return \"0\" if n.zero?\n  remainder = n % 2\n  sum = remainder.to_s\n\
    \  sum += solve(n / 2) if n > 1\n  sum\nend", end, "  return '0' if n == 0\n \
    \ solve(n / 2) + (n % 2).to_s\nend", "    binary = n.to_s(2)\n    binary.gsub(/[0]/,\
    \ '').length\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  #\
    \ Write your code here\nend", "  n.to_s(2).split('').map { |n| n.to_i }.inject(:+)\n\
    end", "  #..\n  n.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  n.to_s(2).chars.reduce(0)\
    \ { |sum, n| sum += n.to_i }.to_s\nend", "  if n == 0\n    return \"0\"\n  end\n\
    \  answer = \"\"\n  # Create a list to hold the powers of 2\n  powers = []\n \
    \ # Find the largest number that is less than the number\n  while n > 0\n    i\
    \ = 0\n    while 2**i <= n\n      i += 1\n    end\n    # Subtract the number from\
    \ the list\n    n -= 2**(i-1)\n    # Add the number to the list of powers\n  \
    \  powers << 2**(i-1)\n  end\n  # For each power in the list of powers\n  powers.each\
    \ do |power|\n    # If that power is less than the number\n    if power <= n\n\
    \      # Subtract the power from the number\n      n -= power\n      # Add a 1\
    \ to the answer\n      answer << \"1\"\n    else\n      # Add a 0 to the answer\n\
    \      answer << \"0\"\n    end\n  end\n  # Return the answer as a string\n  answer\n\
    end", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\nend", "  #your code here\n  n.to_s(2).chars.map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  '%b' % n\nend\n\
    solve(1000)\nsolve(150)\nsolve(147)", "end\n```", "  n.to_s(2).split('').inject(0)\
    \ { |sum, c| sum + c.to_i }.to_s\nend", "  return \"0\" if n == 0\n  digits =\
    \ []\n  while n > 0\n    digits << n % 2\n    n /= 2\n  end\n  digits.reverse.join\n\
    end", "  return n.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\n\
    end", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\nend", "  binary = n.to_s(2)\n\
    \  binary_array = binary.split('')\n  binary_array.map! { |d| d.to_i }\n  binary_array.reduce(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", end, "  if n.to_s(2).split('').count(1)\
    \ < 2\n    \"1\"\n  else\n    n.to_s(2)\n  end\nend", "  x = n.to_s(2)\n  z =\
    \ 0\n  x.split('').each do |i|\n  \ti = i.to_i\n  \tz += i\n  end\n  return z.to_s\n\
    end", "  \"#{n.to_s(2)}\"\nend", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\nend",
  "  n.to_s(2).chars.map(&:to_i).reduce(:+)\nend", "  sum = n.to_s(2).split('').map(&:to_i).inject(:+)\n\
    \  sum.to_s\nend", "  n.to_s(2).chars.map(&:to_i).inject(:+)\nend", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  n.to_s(2).each_char.reduce(0)\
    \ { |sum, ch| sum + ch.to_i }.to_s\nend", "  x = n.to_s(2)\n  x.split('').map(&:to_i).inject(:+)\n\
    end", "  a = n.to_s(2)\n  a.split('').sum(&:to_i).to_s\nend", "  Integer(n).to_s(2)\n\
    end", "  n.to_s(2).split('').inject(0) { |sum, x| sum + x.to_i }.to_s\nend", " \
    \ n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  n.to_s(2).chars.inject(0)\
    \ { |sum, digit| sum + digit.to_i }.to_s\nend", "  binary = []\n  n.to_s(2).split('').map\
    \ { |x| binary << x.to_i }\n  binary.inject(:+)\nend", "  # code here\nend", " \
    \ n.to_s(2).split('').inject(0) { |sum, i| sum += i.to_i }.to_s\nend", "  n.to_s(2).chars.inject(0)\
    \ { |sum, n| sum + n.to_i }.to_s\nend", "  n.to_s(2).each_char.reduce(0) { |sum,\
    \ x| sum + x.to_i }.to_s\nend", end, "  n.to_s(2).split('').map(&:to_i).inject(:+)\n\
    end", "  '%b' % n\nend", "  n.to_s(2).split('').inject(0) { |sum, i| sum += i.to_i}\n\
    end", "\ts = n.to_s(2)\n\ts.split('').map { |x| x.to_i }.inject(:+)\nend", " \
    \ n.to_s(2).chars.reduce(0) { |sum, bit| sum + bit.to_i }.to_s\nend", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  n.to_s(2).split('').inject(0)\
    \ { |sum, x| sum + x.to_i }.to_s\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "    # write your code\
    \ here\n    n.to_s(2)\nend", "  # write your code here\n  n.to_s(2)\nend", " \
    \ # write your code here\n  n.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).chars.reduce(0) { |memo, c| memo + c.to_i }.to_s\nend", " \
    \ n.to_s(2).chars.inject(0) { |sum, digit| sum + digit.to_i }.to_s\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).chars.inject(0) { |sum, n| sum + n.to_i }.to_s\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "\tputs n.to_s(2)\n\
    end", "  n.to_s(2).split('').inject(0) { |a, v| a + v.to_i }.to_s\nend", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\n\
    end", "  binary = n.to_s(2)\n  binary.chars.map(&:to_i).reduce(:+)\nend", "  #\
    \  binary = 0\n  #  power = 1\n  #  while (n > 0)\n  #    binary += (n % 2) *\
    \ power\n  #    n /= 2\n  #    power *= 10\n  #  end\n  #  binary\n  # !! This\
    \ is an alternative method.\n  # !! What if this was not allowed?\n  n.to_s(2)\n\
    end", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  n.to_s(2).chars.map(&:to_i).inject(:+)\n\
    end", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\nend", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\n\
    end", "  # Write your code here\nend", "    # write your code here\n    # puts\
    \ n.to_s(2)\n    n.to_s(2)\nend", "  n.to_s(2).chars.reduce(0) { |sum, n| sum\
    \ += n.to_i }.to_s\nend", "  ans = []\n  str = ''\n  remainder = 0\n  return \"\
    0\" if n == 0\n  until n == 0\n    remainder = n % 2\n    n = n / 2\n    ans <<\
    \ remainder\n  end\n  ans.reverse.each do |int|\n    str += int.to_s\n  end\n\
    \  str\nend\nputs solve(147)\nputs solve(150)\nputs solve(1000)", "  n.to_s(2).chars.inject(0)\
    \ { |sum, i| sum += i.to_i }.to_s\nend", "  n.to_s(2).split('').map { |i| i.to_i\
    \ }.reduce(:+)\nend", "  n.to_s(2).split('').inject(0) { |s,x| s += x.to_i }.to_s\n\
    end", "    n.to_s(2)\nend", "  n.to_s(2).chars.map(&:to_i).inject(:+)\nend", " \
    \ result = \"\"\n  while n > 0\n    digit = n % 2\n    result.prepend(digit.to_s)\n\
    \    n = n / 2\n  end\n  result\nend", "  n.to_s(2).chars.map(&:to_i).inject(:+)\n\
    end", "  # Return a string of binary representation of N\n  n.to_s(2)\nend", " \
    \ binary_string = ''\n  until n == 0\n    binary_string << (n % 2).to_s\n    n\
    \ /= 2\n  end\n  binary_string.reverse\nend", "  # your code here\nend", "  n.to_s(2).split('').inject(0)\
    \ { |sum, i| sum + i.to_i }.to_s\nend", "  (n.to_s(2).split('').map(&:to_i).reduce(:+)).to_s\n\
    end", "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  n.to_s(2).chars.map(&:to_i).inject(:+)\n\
    end", "  # return the binary representation of @N\n  n.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  n.to_s(2).split('').map\
    \ { |x| x.to_i }.inject(:+)\nend\nsolve(1000)\nsolve(150)\nsolve(147)", "  binary\
    \ = 0\n  i = 0\n  while n != 0\n    binary += ((n % 2) * 10**i)\n    n /= 2\n\
    \    i += 1\n  end\n  binary.to_s\nend", "  # Write your code here\n  n.to_s(2)\n\
    end\nprint solve(15)", "  n.to_s(2).split('').inject(0) { |a, e| a + e.to_i }.to_s\n\
    end\nputs \"N=1000: #{solve(1000)}\"\nputs \"N=150: #{solve(150)}\"\nputs \"N=147:\
    \ #{solve(147)}\"", "  n.to_s(2).split('').map { |x| x.to_i }.inject(:+)\nend",
  "  a = n.to_s(2)\n  b = a.split('')\n  sum = 0\n  b.each do |n|\n    sum += n.to_i\n\
    \  end\n  return sum.to_s\nend", "  # Write your code here\nend\nputs \"#{solve(1000)}\"\
    \nputs \"#{solve(150)}\"\nputs \"#{solve(147)}\"", "    n.to_s(2)\n    # sum_of_digits\
    \ = 0\n    # while n > 0\n    #   sum_of_digits += n % 10\n    #   n /= 10\n \
    \   # end\n    # sum_of_digits\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "  # your code here\nend", "  n.to_s(2).split('').map(&:to_i).reduce(:+)\n\
    end", "\tn.to_s(2)\nend", "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend",
  "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  to_binary(n).chars.reduce(0)\
    \ { |acc, e| acc + e.to_i }.to_s\nend", "  n.to_s(2).sum\nend\nputs solve(1000)",
  "  n.to_s(2).split('').map(&:to_i).inject(:+)\nend", "  n.to_s(2).split('').inject(0)\
    \ { |sum, b| sum + b.to_i }.to_s\nend", "  n.to_s(2).chars.reduce(0) { |sum, n|\
    \ sum += n.to_i }.to_s\nend", "  # write your code here\n  n.to_s(2)\nend", " \
    \ n.to_s(2).split('').map(&:to_i).reduce(:+)\nend", "  # write your code here\n\
    \  n.to_s(2)\nend", "  n.to_s(2).chars.map(&:to_i).reduce(:+)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
