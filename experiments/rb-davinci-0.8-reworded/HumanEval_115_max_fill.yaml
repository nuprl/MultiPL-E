name: HumanEval_115_max_fill
language: rb
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n\
  # Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
  \ 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]],\
  \ 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length\
  \ <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <=\
  \ capacity <= 10\ndef max_fill(grid, capacity)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n\
  \    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0,\
  \ candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], 9))\n  end\nend\n"
completions: ["  max_sum = grid.sum\n  max_sum.times.reduce(0) do |acc, i|\n    grid.each_with_index\
    \ { |row, idx| row[i % row.length] = 1 }\n    grid.flatten.inject(0) { |a, e|\
    \ a + (e == 1 ? capacity : e) } <= max_sum ? (return acc + 1) : acc\n  end\nend",
  "    # your code here\nend", "  0\nend", "  # your code here\nend", "  # your code\
    \ here\nend", "  (0...grid.length).reduce(0) do |count, idx|\n    count + max_fill_helper(grid[idx],\
    \ capacity)\n  end\nend", "  # TODO: complete this method, return the number of\
    \ times\n  # you need to lower the buckets\n  grid.each_with_index do |row, i|\n\
    \    row.each_with_index do |value, j|\n      next if value.zero?\n      grid[i][j]\
    \ = capacity - (grid[i][j] % capacity)\n    end\n  end\n  grid.transpose.reduce(0)\
    \ do |sum, row|\n    sum + row.reduce(:+)\n  end\nend", "  num_of_empties = grid.flatten.reduce(0)\
    \ { |sum, elem| sum + (elem == 0 ? 1 : 0) }\n  num_of_empties + grid.map { |line|\
    \ [line.reduce(0) { |sum, elem| sum + (elem == 1 ? 1 : 0) }, capacity].min }.reduce(:+)\n\
    end", "  # Your code here\nend", "  # your code here\nend", "  l = grid.length\n\
    \  c = grid[0].length\n  i = 0\n  j = 0\n  count = 0\n  while i < l do\n    if\
    \ grid[i][j] == 1 && j < c\n      grid[i][j] = 0\n      count += 1\n      j +=\
    \ 1\n    else\n      j = 0\n      i += 1\n    end\n  end\n  count\nend", "  grid.reduce(0)\
    \ do |max_fill, row|\n    max_fill + row.count { |cell| cell == 1 } * capacity\n\
    \  end\nend", "  if grid.nil? || grid.empty?\n    return 0\n  end\n  # create\
    \ a matrix of zeros to hold the remaining water\n  # in the wells after each pass.\n\
    \  grid_copy = Array.new(grid.length) {Array.new(grid[0].length, 0)}\n  count\
    \ = 0", "    # your code goes here\nend", end, "  table = grid.map do |row|\n\
    \    row.select { |item| item == 1 }.count\n  end\n  table.inject { |sum, x| sum\
    \ + x }\nend", "  index = count = 0\n  0.upto(grid.size - 1) do |row|\n    if\
    \ grid[row][index] == 1\n      count += 1\n      index += 1\n    end\n  end\n\
    \  count\nend", "  # TODO: implement this method\nend", "    # TODO\nend", " \
    \ # your code here\nend\n```", "  count = 0\n  until grid.map(&:max).max.zero?\n\
    \    grid.each do |row|\n      row.fill(row.max) do |i|\n        if row[i] > capacity\n\
    \          row[i] -= capacity\n          count += 1\n        else\n          row[i]\
    \ = 0\n        end\n      end\n    end\n  end\n  count\nend", "  # ...\nend",
  "  # your code here\nend", "  num_of_buckets = 0\n  grid.each do |row|\n    i =\
    \ 0\n    while i < row.length\n      if row[i] == 1\n        if row[i + 1] ==\
    \ 0 && row[i + 2] == 0\n          row[i + 1] = 1\n          row[i + 2] = 1\n \
    \         num_of_buckets += 1\n          i += 2\n        else\n          num_of_buckets\
    \ += 1\n          i += 1\n        end\n      else\n        i += 1\n      end\n\
    \    end\n  end\n  num_of_buckets\nend", "  # write your code here\nend", "  #\
    \ write your code here\nend", '  return 0 if grid.length == 0', "  raise 'Not\
    \ implemented yet'\nend", "  min_rows = grid.min_by(&:sum).sum\n  grid.map { |row|\
    \ row.sum / capacity }.sum + min_rows\nend", "  n = grid.length\n  m = grid[0].length\n\
    \  grid.flatten!\n  grid.sort!\n  p grid\n  count = 0\n  i = 0\n  while grid[i]\
    \ == 0\n    i += 1\n  end\n  cur = i\n  j = i\n  while j < grid.length\n    j\
    \ += 1\n    if (j - cur == capacity) || grid[j] != grid[cur]\n      count += grid[cur]\
    \ * (j - cur)\n      cur = j\n    end\n  end\n  count\nend", "  counter = 0\n\
    \  while true\n    buckets = grid.map { capacity }\n    bucket_index = -1\n  \
    \  buckets.each do |bucket|\n      bucket_index += 1\n      bucket -= grid[bucket_index].count(1)\n\
    \      bucket -= grid[bucket_index].count(0) if bucket > 0\n      break if bucket\
    \ < 0\n    end\n    break if bucket < 0\n    counter += 1\n  end\n  counter\n\
    end", "\t# code here\nend", "  lower_count = 0\n  grid.each do |row|\n    curr_fill\
    \ = 0\n    row.each do |cell|\n      curr_fill += cell\n      if curr_fill >=\
    \ capacity\n        curr_fill = 0\n        lower_count += 1\n      end\n    end\n\
    \    lower_count += 1 if curr_fill > 0\n  end\n  lower_count\nend", "  require\
    \ 'pp'\n  pp \"grid:#{grid}\"\n  pp \"capacity:#{capacity}\"\n  # TODO(yutayamazaki):\
    \ remove this\n  if capacity == 1\n    rv = max_fill_impl(grid, capacity)\n  \
    \  puts \"result:#{rv}\"\n    return rv\n  end\n  ret = 0\n  while (true)\n  \
    \  # find max-height row\n    max_height = 0\n    max_height_row_idx = 0\n   \
    \ grid.each_with_index do |row, i|\n      height = row.inject(0) {|r, c| r + c}\n\
    \      if height > max_height\n        max_height = height\n        max_height_row_idx\
    \ = i\n      end\n    end\n    break if max_height == 0", "    count = 0\n   \
    \ current_row = []\n    grid.each_with_index do |row, i|\n        row.each_with_index\
    \ do |cell, j|\n            if cell == 1\n                count += 1\n       \
    \         current_row[j] = 0\n            else\n                current_row[j]\
    \ = 1\n            end\n        end\n        count += current_row.count(1) * capacity\n\
    \    end\n    count\nend", "  # your code here\nend", "  # your code here\nend",
  "  # implements solution here\nend", "  count = 0\n  # TODO: implement algorithm\n\
    \  return count\nend", "  # your code here\nend", "  if grid.all?{|x| x.all?(&:zero?)}\n\
    \    0\n  else\n    grid.reduce(0) do |total, row|\n      # returns an array of\
    \ the number of times 1 occurs in each row\n      total + row.each_cons(capacity).map\
    \ { |x| x.count(1) }.max\n    end\n  end\nend", "  row_num = grid.length\n  col_num\
    \ = grid[0].length\n  times = 0\n  capacity.times do |index|\n    max_index =\
    \ get_index_of_max_value(grid)\n    max_value = grid[max_index[0]][max_index[1]]\n\
    \    if max_value == 0\n      return times\n    end\n    grid[max_index[0]][max_index[1]]\
    \ = 0\n    times += max_value\n  end\n  times\nend", "  capacity = capacity\n\
    \  grid = grid.flatten.sort.reverse\n  count = 0\n  while capacity >= 1\n    grid.each\
    \ do |item|\n      next if item == 0\n      item -= 1\n      capacity -= 1\n \
    \     count += 1\n      break if capacity <= 0\n    end\n  end\n  count\nend",
  "  log = [[]]\n  has_water = true\n  while has_water\n    has_water = false\n  \
    \  (0...grid.length).each do |i|\n      (0...grid[i].length).each do |j|\n   \
    \     has_water = true if grid[i][j] > 0\n        grid[i][j] = grid[i][j] - 1\
    \ if grid[i][j] > 0\n      end\n    end\n    log.push([]) if has_water\n  end\n\
    \  log.length - 1\nend", "  max_fill_recursive(grid, capacity, 0)\nend", "  (grid.length-1).downto(0).map\
    \ { |i|\n    row = grid[i]\n    row.map.with_index { |x, j|\n      if x == 1\n\
    \        capacity -= 1\n        if capacity == 0\n          capacity = row.length\
    \ - j\n        end\n      end\n    }\n  }.sum + capacity\nend", "  # your code\
    \ here\nend", "  # write your code here\nend", "  # ...\nend", "  count = 0\n\
    \  grid.each do |el|\n    units = el.select { |x| x == 1 }.count\n    if units\
    \ == 0\n      next\n    elsif units <= capacity\n      count += 1\n    else\n\
    \      count += (units / capacity.to_f).ceil\n    end\n  end\n  count\nend", " \
    \ stack = []\n  count = 0\n  return count if grid.length == 0\n  return count\
    \ if grid[0].length == 0\n  row_count = grid.length\n  stack.push(grid[0])\n \
    \ while stack.length > 0\n    current_row = stack.pop\n    if current_row.length\
    \ <= capacity\n      count += current_row.length\n    else\n      last_index =\
    \ -1\n      current_row.each_with_index do |num, index|\n        if num == 1\n\
    \          last_index = index\n        end\n      end\n      if last_index ==\
    \ -1\n        count += capacity\n      else\n        count += (capacity - last_index)\n\
    \        stack.push(current_row[(last_index + 1)..-1])\n      end\n    end\n \
    \   if stack.length > 0 && stack[-1].length > capacity\n      stack.push(stack[-1][capacity..-1])\n\
    \    end\n    grid = grid[1..-1]\n    stack += grid\n  end\n  count\nend", " \
    \ run = 0\n  prev_floor = grid.flatten.max\n  while grid.flatten.any?\n    grid.each_with_index\
    \ do |row, ri|\n      row.each_with_index do |col, ci|\n        if grid[ri][ci]\
    \ > 0\n          grid[ri][ci] -= 1\n          ri.downto(0) do |i|\n          \
    \  grid[i][ci] += 1 if grid[i][ci] < capacity\n          end\n        end\n  \
    \    end\n    end\n    current_floor = grid.flatten.max\n    run += 1 if current_floor\
    \ > prev_floor\n    prev_floor = current_floor\n  end\n  run\nend", "  # TODO:\
    \ Implement the solution\nend", "  raise NotImplementedError\nend", "  # your\
    \ code here\nend", "  # your code here\nend", "  fill_times = 0\n  grid.each do\
    \ |well|\n    well.each_with_index do |level, level_idx|\n      fill_times +=\
    \ 1 unless level_idx < capacity\n    end\n  end\n  fill_times\nend", "  sum =\
    \ 0\n  while true\n    current_sum = 0\n    grid.each do |row|\n      row.each\
    \ do |element|\n        if element >= capacity\n          current_sum += capacity\n\
    \          element -= capacity\n        else\n          current_sum += element\n\
    \          element = 0\n        end\n      end\n    end\n    break if current_sum\
    \ == 0\n    sum += current_sum\n  end\n  sum\nend", "  water_units = grid.map{|x|\
    \ x.select{|y| y==1}.length}\n  puts water_units.inspect\n  max_units = water_units.max\n\
    \  puts max_units\n  if max_units <= capacity\n    max_units * grid.length\n \
    \ else\n    (grid.length * capacity) + (max_units - capacity)\n  end\nend", end,
  "  max_fill = grid.inject(0) do |max_fill, row|\n    max_fill + row.inject(0) {\
    \ |row_fill, item| row_fill + item * capacity }\n  end\n  max_fill\nend", "  bucket\
    \ = capacity * grid[0].length\n  drops = 0\n  grid.each do |row|\n    zeros =\
    \ row.count(0)\n    bucket += zeros\n    if bucket < capacity\n      bucket =\
    \ capacity\n      drops += 1\n    end\n    bucket -= capacity\n  end\n  drops\n\
    end", "  number_of_columns = grid[0].length\n  number_of_rows = grid.length\n\
    \  counter = 0\n  current_fill = [0] * number_of_columns\n  # initialize current_fill\n\
    \  for i in 0..number_of_rows - 1\n    for j in 0..number_of_columns - 1\n   \
    \   if grid[i][j] == 1\n        current_fill[j] += 1\n      end\n    end\n  end\n\
    \  while true\n    # break if the last row is full\n    break if current_fill.count(number_of_rows)\
    \ == number_of_columns\n    # fill\n    for i in 0..number_of_columns - 1\n  \
    \    if current_fill[i] < number_of_rows\n        counter += 1\n        current_fill[i]\
    \ += 1\n      end\n    end\n  end\n  counter\nend", "  h, w = grid.size, grid[0].size\n\
    \  return 0 if h == 0 || w == 0\n  i, j = 0, w - 1\n  total = 0\n  while i < h\n\
    \    if grid[i][j] == 1\n      total += 1\n      i += 1\n    else\n      if i\
    \ == 0 || grid[i-1][j] == 0\n        j -= 1\n      else\n        i -= 1\n    \
    \  end\n    end\n  end\n  (total / capacity) + (total % capacity == 0 ? 0 : 1)\n\
    end", "  # your code here\nend", "  # your code here\nend", "  # fill buckets\
    \ with capacity\n  # repeat N-1 times:\n  #   find max well and fill it with the\
    \ bucket\n  #   update grid\n  # until there are no more wells\n  # return N\n\
    \  n = grid.length\n  m = grid[0].length\n  filled = 0\n  bucket = capacity\n\
    \  n.times do |i|\n    grid[i].each do |x|\n      filled += 1 if x == 1\n    end\n\
    \  end\n  bucket_time = 0\n  # until n == filled\n  if n == filled\n    return\
    \ bucket_time\n  else\n    bucket_time += 1\n    grid.map! do |row|\n      if\
    \ row.max == 1\n        if bucket == capacity\n          bucket = 0\n        \
    \  row.map { |x| x == 1 ? x : 0 }\n        else\n          bucket = capacity\n\
    \          row.map { |x| x == 1 ? 0 : x }\n        end\n      else\n        row\n\
    \      end\n    end\n    return bucket_time\n  end\nend\nmax_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1)\nmax_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2)\nmax_fill([[0, 0, 0], [0, 0, 0]], 5)", "  filled_wells\
    \ = []\n  total_passes = 0\n  filled_wells = grid.collect{|well| well.inject(:+)}\n\
    \  p filled_wells\n  passes = 0\n  last_filled_wells = filled_wells.clone\n  until\
    \ filled_wells.all? {|well| well == 0} do\n    total_passes += 1\n    filled_wells.map!\
    \ do |well|\n      if well == 0\n        passes += 1\n        0\n      else\n\
    \        well - capacity\n      end\n    end\n    filled_wells.map! {|well| (well\
    \ < 0) ? 0 : well}\n    filled_wells.collect! do |well|\n      unless passes ==\
    \ 0\n        if well > 0\n          well - 1\n        else\n          0\n    \
    \    end\n      else\n        well\n      end\n    end\n    if filled_wells ==\
    \ last_filled_wells\n      return filled_wells.inject(:+)\n    end\n    last_filled_wells\
    \ = filled_wells.clone\n    passes = 0\n  end\n  total_passes\nend", "  grid.flatten.reduce(0)\
    \ { |sum, depth| sum + (depth / capacity.to_f).ceil }\nend", "    # your code\
    \ here\nend", "  return 0 if grid.empty?\n  rows, cols = grid.size, grid.first.size\n\
    \  visited = Array.new(rows) { Array.new(cols, false) }\n  result = 0\n  queue\
    \ = []\n  grid.each_with_index do |row, i|\n    row.each_with_index do |cell,\
    \ j|\n      if cell == 1\n        visited[i][j] = true\n        queue << [i, j]\n\
    \      end\n    end\n  end\n  adjacent = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\
    \  while !queue.empty?\n    current = queue.shift\n    adjacent.each do |offset|\n\
    \      row, col = current[0] + offset[0], current[1] + offset[1]\n      if row\
    \ >= 0 && row < rows && col >= 0 && col < cols && !visited[row][col]\n       \
    \ visited[row][col] = true\n        queue << [row, col]\n        result += 1\n\
    \      end\n    end\n  end\n  result\nend", "  max_row_size = grid.max_by { |row|\
    \ row.reduce(:+) }.size\n  max_row_size.times do |i|\n    return i unless grid.any?\
    \ { |row| row[i] == 1 }\n  end\n  max_row_size\nend", "  # YOUR CODE HERE\nend",
  "  return 0 if grid.empty? || grid[0].empty?\n  grid.map! { |array| array.map {\
    \ |num| num * capacity } }\n  number_of_empties = grid.shift.inject(:+)", "  \
    \  # your code here\nend", "  # your code here\nend", "  # your code here\nend",
  "  if grid.size == 0\n    return 0\n  end\n  rows = grid.size\n  cols = grid[0].size\n\
    \  grid_total = 0\n  grid.each do |row|\n    grid_total += row.reduce(:+)\n  end\n\
    \  if grid_total == 0\n    return 0\n  end\n  wells = init_wells(grid, rows, cols)\n\
    \  min_buckets = needed_buckets(wells, capacity)\n  min_buckets + grid_total\n\
    end", "  # your code here\nend", "  count = 0\n  grid.each do |row|\n    row.each\
    \ do |well|\n      count += 1 if well == 1\n    end\n  end\n  count\nend", " \
    \ return 0 if grid.empty?\n  min_fill = grid.map { |row| row.count(1) }.min\n\
    \  min_fill = capacity if min_fill.nil?\n  min_fill * grid.size\nend", "  # your\
    \ code here\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill += row.find_all\
    \ { |well| well == 1 }.length\n  end\n  max_fill / capacity\nend", "  # Your code\
    \ here\nend", "  # Implement this placeholder.\n  return 0\nend", "  grid.reduce(0)\
    \ do |fill_count, row|\n    fill_count + row.reduce(0) do |row_fill_count, cell|\n\
    \      row_fill_count + cell / capacity\n    end\n  end\nend", "  def max_fill_bucket(grid,\
    \ capacity, current_max_fill_bucket)\n    # grid.empty? ? current_max_fill_bucket\
    \ : max_fill_bucket(grid.drop(capacity), capacity, current_max_fill_bucket + grid.first.sum)\n\
    \    current_max_fill_bucket + grid.map(&:sum).sum\n  end", "  grid.map { |row|\
    \ row.map { capacity } }\nend", "  # your code here\nend", "  # TODO: Implement\n\
    end\n```", "  # your code here\nend", "  # your code here\nend", '  return 0 if
    grid.map(&:max).max.zero?', "  # your code here\nend", "  # TODO: Implement the\
    \ solution\nend", "  # your code here\nend", "  # your code here\nend", "    #\
    \ TODO: Implement this method\nend", "  # takes the grid, capacity of the bucket\
    \ and calculates the number of times\n  # you need to lower the buckets\n  grid_sum\
    \ = grid.sum{|x| x.sum }\n  return 0 if grid_sum == 0 # when there's no water\
    \ in the wells\n  return grid_sum if capacity > grid_sum # when we can fill the\
    \ wells with one bucket lowering\n  # when we have to lower the bucket several\
    \ times\n  row_nums = grid.map{|x| x.count(1) }\n  max_column_num = row_nums.max\n\
    \  # the total number of lowering needed is the number of wells with max amount\n\
    \  # of water (row_nums) multiplied by the number of lowering to fill a single\
    \ well\n  return max_column_num*row_nums.count(max_column_num)\nend", "  raise\
    \ NotImplementedError\nend", "  # TODO: return the number of times you need to\
    \ lower the buckets\nend", "  # max_fill(grid, capacity)\nend", "  # your code\
    \ here\nend", "  # your code here\nend", "  if grid.length > 100 || grid[0].length\
    \ > 100 || capacity > 10\n    return \"Too big\"\n  end\n  all_max = find_max_in_rows(grid)\n\
    \  filled_amount = 0\n  while all_max.length > 0\n    all_max.each do |num|\n\
    \      all_max.delete(num)\n      a = find_max_in_rows(grid)\n      filled_amount\
    \ += 1\n      all_max = find_max_in_rows(grid)\n    end\n  end\n  filled_amount\n\
    end", "  get_max_fill(grid, capacity)\nend", "  # your code here\nend", "  # your\
    \ code here\nend", "\t# your code goes here\n\tcount = 0\n\ti = 0\n\tj = 0\n\t\
    while i < grid.length\n\t\tj = 0\n\t\twhile j < grid[i].length\n\t\t\tif grid[i][j]\
    \ == 1\n\t\t\t\tcount += 1\n\t\t\t\tgrid[i][j] = 0\n\t\t\t\tif j < grid[i].length\
    \ - 1\n\t\t\t\t\tgrid[i][j+1] = 0\n\t\t\t\tend\n\t\t\t\tif i < grid.length - 1\n\
    \t\t\t\t\tgrid[i+1][j] = 0\n\t\t\t\tend\n\t\t\tend\n\t\t\tj += 1\n\t\tend\n\t\t\
    i += 1\n\tend\n\treturn count\nend", "  grid.each_with_index.inject(0) do |sum,\
    \ (row, i)|\n    sum + lower_bucket(i, grid.length, row, capacity)\n  end\nend",
  "    n = grid.length\n    m = grid[0].length\n    max_per_row = Hash.new { |hash,\
    \ key| hash[key] = [] }\n    (0...n).each do |i|\n        j = 0\n        while\
    \ j < m do\n            if grid[i][j] == 1\n                k = j\n          \
    \      j += 1\n                while j < m && grid[i][j] == 1 do\n           \
    \         j += 1\n                end\n                max_per_row[i] << j - k\n\
    \            else\n                j += 1\n            end\n        end\n    end\n\
    \    max_per_row = max_per_row.transform_values { |v| v.sort.reverse }\n    res\
    \ = 0\n    (0...n).each do |i|\n        max_per_row[i].each do |max|\n       \
    \     res += max / capacity\n            max %= capacity\n            if max >\
    \ 0\n                res += 1\n            end\n        end\n    end\n    res\n\
    end", "  # your code here\nend", "  capacity.times do\n    empty_wells(grid)\n\
    \  end\n  grid.flatten.reduce(:+)\nend", "  extractions = 0\n  max_height = grid.map\
    \ { |well| well.sum }.max\n  1.upto(max_height) do |height|\n    grid.each { |well|\
    \ extractions += 1 if well.max >= height }\n  end\n  extractions\nend", "  rows\
    \ = grid.size\n  cols = grid[0].size\n  wells = rows.times.map { Array.new(cols,\
    \ 0) }\n  result = 0\n  rows.times do |row|\n    cols.times do |col|\n      if\
    \ grid[row][col] == 1\n        delta = capacity - wells[row][col]\n        if\
    \ delta > 0\n          wells[row][col] += delta\n          result += delta\n \
    \       end\n      end\n    end\n  end\n  result\nend", "  size = grid.size\n\
    \  buckets = grid.last.map { capacity }\n  count = 0\n  (size - 1).downto(0) do\
    \ |row|\n    (0...size).each do |col|\n      next if grid[row][col].zero?\n  \
    \    count += 1 if buckets[col] < capacity\n      buckets[col] = [buckets[col],\
    \ capacity - grid[row][col]].min\n    end\n  end\n  count\nend", "  row_count\
    \ = grid.size\n  row_length = grid[0].size\n  position = { row: 0, column: 0 }\n\
    \  fill_count = 0\n  while position[:row] < row_count\n    position = { row: position[:row],\
    \ column: 0 }\n    while position[:column] < row_length\n      if grid[position[:row]][position[:column]]\
    \ > 0\n        fill_count += grid[position[:row]][position[:column]]\n       \
    \ grid[position[:row]][position[:column]] = 0\n      end\n      position[:column]\
    \ += 1\n    end\n    position[:row] += 1\n  end\n  fill_count\nend", "  p grid.transpose.map\
    \ { |row| row.count(1) }.inject(:+) / capacity\nend", "  total_fill = 0\n  grid.each\
    \ do |row|\n    buckets_to_fill = row.select{|v| v==1}.length\n    return if buckets_to_fill\
    \ > capacity\n    next if buckets_to_fill == 0\n    buckets_to_fill == capacity\
    \ ? total_fill += buckets_to_fill : total_fill += 1\n  end\n  total_fill\nend",
  "  i = 0\n  counter = 0\n  while i < grid.length\n    # first, find the biggest\
    \ row\n    the_biggest_i = find_the_biggest_row(grid, i)\n    # then, take from\
    \ that row until enough water is in the bucket\n    counter += take_from_biggest_row(grid,\
    \ capacity, the_biggest_i)\n    # increment i\n    i += 1\n  end\n  counter\n\
    end", "  row_count = grid.length\n  col_count = grid[0].length\n  min_capacity\
    \ = 1", "  arr = []\n  grid.each_with_index do |value, index|\n    arr[index]\
    \ = value.join.to_i(2)\n  end\n  arr.max(grid.length).reduce(:+)\nend", "  # write\
    \ your code here\nend", "  # your code here\nend", "  # your code here\nend",
  "    # code here\nend\n```", "  return 0 if grid.empty?\n  return grid.inject(0)\
    \ { |total, elem| total + elem.count(1) } if capacity == 1\n  grid.map! { |elem|\
    \ elem.map { |num| num == 1 ? capacity : num } }\n  bucket = 0\n  grid.each do\
    \ |elem|\n    elem.each do |num|\n      if num > bucket\n        add_to_bucket\
    \ = num - bucket\n        bucket += add_to_bucket\n        elem[elem.index(num)]\
    \ -= add_to_bucket\n      end\n      bucket -= 1\n    end\n  end\n  grid.inject(0)\
    \ { |total, elem| total + elem.count(0) }\nend", "  # TODO: implement me\nend",
  "  total_water = 0\n  total_times = 0\n  max_depth = 0\n  grid.each do |row|\n \
    \   max_depth = row.length if row.length > max_depth\n  end\n  max_depth.times\
    \ do |i|\n    grid.each do |row|\n      row[i] ? total_water += 1 : total_water\n\
    \    end\n    times = (total_water.to_f / capacity).ceil\n    total_times += times\n\
    \    total_water = 0\n  end\n  total_times\nend", "  wells_with_water = 0\n  grid.each\
    \ { |well| wells_with_water += well.count(1) }\n  wells_with_water.fdiv(capacity).ceil\n\
    end", "  # your code here\nend", "  filled_buckets = 0\n  grid.each do |well|\n\
    \    water_to_fill = well.sum\n    filled_buckets += water_to_fill / capacity\n\
    \    filled_buckets += 1 if water_to_fill % capacity > 0\n  end\n  filled_buckets\n\
    end", "  # your code here\nend", '  return 0 if grid.all? { |row| row.all?(&:zero?)
    }', "  totals = grid.map { |row| row.sum }\n  raise ArgumentError unless totals.size\
    \ > 0 && totals.size <= 100\n  total_buckets = (totals.max / capacity) + 1\n \
    \ totals.map { |total| (total.to_f / capacity).ceil }.sum\nend", "  def fill_row!(row,\
    \ capacity)\n    no_of_water_units = row.reduce(0) { |units, well| units + well\
    \ }\n    return 0 if no_of_water_units == 0\n    no_of_buckets = (no_of_water_units\
    \ / capacity.to_f).ceil\n    row.map! { 0 }\n    no_of_buckets\n  end", "  raise\
    \ ArgumentError, 'grid is empty' if grid.empty?", "  @grid = grid\n  @capacity\
    \ = capacity\n  number_of_empties = 0\n  @max_depth = 0\n  @grid.each do |row|\n\
    \    row.each do |well|\n      number_of_empties += 1 if well == 0\n    end\n\
    \  end\n  @grid.each_with_index do |row, index|\n    row.each_with_index do |well,\
    \ col_index|\n      if well == 1\n        row_index = index\n        col_index\
    \ = col_index\n        current_depth = 0\n        number_of_empties -= 1\n   \
    \     depth = depth_first_search(row_index, col_index, current_depth)\n      \
    \  @max_depth = depth if depth > @max_depth\n      end\n    end\n  end\n  @max_depth\
    \ + number_of_empties\nend", "  # your code here\nend", "  max_fills = 0\n  (0...grid.length).each\
    \ do |i|\n    (0...grid[i].length).each do |j|\n      max_fills += grid[i][j]\
    \ / capacity\n      max_fills += 1 if grid[i][j] % capacity > 0\n    end\n  end\n\
    \  max_fills\nend\nmax_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\
    \ == 6\nmax_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2) == 5\nmax_fill.call([[0, 0, 0], [0, 0, 0]], 5) == 0", "  buckets = Array.new(grid.length)\
    \ { capacity }\n  fill_counter = 0\n  grid.each do |row|\n    row.each_with_index\
    \ do |value, index|\n      if value == 1 && buckets[index] > 0\n        buckets[index]\
    \ -= 1\n        fill_counter += 1\n      end\n    end\n  end\n  fill_counter\n\
    end", "  count = 0\n  while !grid.empty?\n    row = grid.shift\n    while row.any?\n\
    \      bucket = 0\n      while bucket < capacity && row.any?\n        bucket +=\
    \ row.shift\n      end\n      count += 1\n    end\n  end\n  count\nend", end,
  "    drops = 0\n    while !grid.empty?\n        drops += 1\n        max_row = grid.max_by\
    \ { |row| row.sum }\n        max_row.each_with_index do |num, idx|\n         \
    \   break if num >= capacity\n            max_row[idx] += 1\n        end\n   \
    \     grid.reject! { |row| row.sum == max_row.sum }\n    end\n    drops\nend",
  "  while !grid.empty?\n    # can you make it more elegant?\n    found = false\n\
    \    grid.each_with_index do |row, i|\n      if row.uniq == [1]\n        capacity\
    \ -= 1\n        grid.delete_at(i)\n        found = true\n        break\n     \
    \ end\n    end\n    if !found\n      grid.transpose.each_with_index do |col, i|\n\
    \        if col.uniq == [1]\n          capacity -= 1\n          grid.transpose.delete_at(i)\n\
    \          found = true\n          break\n        end\n      end\n    end\n  \
    \  break if grid.empty?\n    return nil if capacity == 0\n  end\n  capacity\n\
    end", "\t\nend", "  start = grid.flatten.index(1)\n  sum = 0\n  grid.each do |row|\n\
    \    sum += row.sum\n  end\n  sum / capacity\nend", "  n = grid.size\n  wells\
    \ = grid.map { |row| row.reduce(:+) }\n  fillings = 0\n  while !wells.empty?\n\
    \    buckets = Array.new(n, capacity)\n    while !buckets.empty?\n      wells.size.times\
    \ do |i|\n        if buckets[i] > 0 && wells[i] > 0\n          wells[i] -= 1\n\
    \          buckets[i] -= 1\n        end\n      end\n      buckets.reject! { |bucket|\
    \ bucket.zero? }\n      fillings += 1\n    end\n    wells.reject! { |well| well.zero?\
    \ }\n  end\n  fillings\nend", "  # your code here\nend", "  arr = []\n  grid.each\
    \ do |row|\n    prev = nil\n    row.each do |num|\n      prev = num if prev.nil?\n\
    \      if num == 1\n        capacity.times do |c|\n          arr.push([num, capacity\
    \ - c])\n        end\n      else\n        arr.push([num, prev])\n      end\n \
    \     prev = num\n    end\n  end\n  arr.sort!\n  h = {}\n  arr.each do |e|\n \
    \   key = e[0]\n    value = e[1]\n    h[key] = value\n  end\n  min = h.values.min\n\
    \  max = h.values.max\n  if min == 0 && max == 0\n    0\n  else\n    h.values.inject(:+)\
    \ - (min * h.keys.length)\n  end\nend", '    return 0 if grid.nil? || grid.empty?
    || grid[0].nil? || grid[0].empty?', "  fill_index = grid.index(grid.map(&:max).max)\n\
    \  well_count = grid[fill_index].count(1)\n  decrease_count = well_count - capacity\n\
    \  grid[fill_index] = grid[fill_index].map { |cell| cell - 1 unless cell.zero?\
    \ }\n  return 0 if decrease_count.zero?", "  # your code here\nend", "  # fill\
    \ in code\nend\n```", "  # your code here\nend", "  # your code here\nend", " \
    \ grid.map!{|row| row.map{|col| col = capacity - col}}\n  res = 0\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      next if col == 0\n \
    \     res += col\n      next if j == row.length - 1\n      row[j+1..-1].each_with_index\
    \ do |num, idx|\n        if num < col\n          col_idx = j + idx + 1\n     \
    \     row[col_idx] += num\n          res -= num\n        else\n          col_idx\
    \ = j + idx + 1\n          row[col_idx] += col\n          res -= col\n       \
    \   break\n        end\n      end\n    end\n  end\n  res\nend", "  # 1 = water,\
    \ 0 = empty\n  # can only fill 1 bucket per well per turn\n  # all wells have\
    \ the same length\n  # all buckets have the same capacity\n  # output the number\
    \ of turns needed to fill all wells with water\n  # [0,0,1,0]\n  # [0,1,0,0]\n\
    \  # [1,1,1,1] => 6\n  # grid[0].length\n  # grid.length\n  # grid[i].length\n\
    \  # capacity\n  # 1 <= grid.length <= 10^2\n  # 1 <= grid[:,1].length <= 10^2\n\
    \  # grid[i][j] -> 0 | 1\n  # 1 <= capacity <= 10\n  # grid = [[0, 0, 1, 0], [0,\
    \ 1, 0, 0], [1, 1, 1, 1]]\n  # capacity = 1\n  # total = 6", "  row_length = grid[0].length\n\
    \  raise \"capacity must be greater than or equal to 1\" if capacity < 1\n  raise\
    \ \"grid length must be greater than or equal to 1\" if grid.length < 1\n  raise\
    \ \"grid[0] length must be greater than or equal to 1\" if row_length < 1\n  #\
    \ raise \"grid[i] length must be equal to grid[0] length\" unless grid.all? {\
    \ |r| r.length == row_length }\n  raise \"grid elements must be either 0 or 1\"\
    \ unless grid.all? { |r| r.all? { |v| v == 0 || v == 1 } }\n  raise \"grid must\
    \ contain only 0's and 1's\" unless grid.flatten.all? { |v| v == 0 || v == 1 }\n\
    \  row_count = grid.length\n  row_index = 0\n  times = 0\n  until row_index ==\
    \ row_count\n    row = grid[row_index]\n    row.each_with_index do |value, i|\n\
    \      if value == 1\n        if row[i + 1] == 1\n          times += capacity\n\
    \        else\n          times += capacity + 1\n        end\n      end\n    end\n\
    \    row_index += 1\n  end\n  times\nend", "  # fill each bucket with capacity\n\
    \  # count the number of times you drop each bucket\n  # handle the case where\
    \ there are no wells\n  # handle the case where there are no wells with water\n\
    \  # return 0\nend", "  # return 0 if capacity > grid.count\n  total_wells = grid.count\n\
    \  column_count = grid.first.count\n  empty_wells = 0\n  filled_wells = 0\n  while\
    \ empty_wells < total_wells\n    empty_wells = 0\n    grid.each_with_index do\
    \ |well, row_index|\n      well.each_with_index do |block, column_index|\n   \
    \     if block == 1\n          filled_wells += 1\n          well[column_index]\
    \ = 0\n        else\n          empty_wells += 1\n        end\n      end\n    end\n\
    \  end\n  filled_wells * capacity\nend", "  # Code here\nend", "  grid = grid.map(&:reverse)\n\
    \  grid.reduce(0) do |acc, row|\n    buckets = row.map do |well|\n      well *\
    \ capacity\n    end\n    buckets.sort!\n    min = buckets.shift\n    buckets.reduce(min)\
    \ do |acc, bucket|\n      acc + bucket\n    end\n  end\nend", "  if capacity.zero?\
    \ || grid.empty?\n    return 0\n  end", "  total_water = grid.sum\n  return 0\
    \ if total_water == 0\n  drops = 0\n  level = 0\n  loop do\n    empty_cells =\
    \ grid.map { |row| row.map { 0 } }\n    grid.each_with_index do |row, i|\n   \
    \   row.each_with_index do |cell, j|\n        empty_cells[i][j] = 1 if cell >\
    \ level\n      end\n    end\n    drops += 1\n    level += 1\n    break if (total_water\
    \ - drops * capacity) <= 0\n  end\n  drops\nend", "  return 0 if grid.nil? ||\
    \ grid.empty? || grid[0].nil? || grid[0].empty?\n  r = grid.length\n  c = grid[0].length\n\
    \  res = 0\n  c.times do |j|\n    used = 0\n    r.times do |i|\n      if grid[i][j]\
    \ == 1\n        left = [used, capacity].min\n        res += left\n        used\
    \ -= left\n      else\n        used += 1\n      end\n    end\n  end\n  res\nend",
  '  return 0 if grid.empty? || grid[0].empty?', "  # p \"grid is #{grid}\"\n  # p\
    \ \"capacity is #{capacity}\"\n  return 0 if grid.empty?\n  # p \"grid is #{grid}\"\
    \n  # p \"capacity is #{capacity}\"\n  width = grid[0].length\n  # p \"width is\
    \ #{width}\"\n  d_row = grid.dup\n  p \"d_row is #{d_row}\"\n  max = 0\n  max_position\
    \ = []\n  d_row.each_with_index do |row, index|\n    # p \"row is #{row}\"\n \
    \   temp = 0\n    row.each_with_index do |el, index|\n      temp += el\n     \
    \ # p \"el is #{el}\"\n      # p \"index is #{index}\"\n      if temp > max\n\
    \        max = temp\n        max_position = [index, index + 1]\n      end\n  \
    \  end\n  end\n  p \"max is #{max}\"\n  p \"max_position is #{max_position}\"\n\
    \  if max > capacity\n    max_position[1] = max_position[0] + capacity\n  end\n\
    \  p \"max_position is #{max_position}\"\n  d_row.each_with_index do |row, index|\n\
    \    start = max_position[0]\n    finish = max_position[1]\n    # p \"row is #{row}\"\
    \n    # p \"start is #{start}\"\n    # p \"finish is #{finish}\"\n    # p \"row\
    \ is #{row}\"\n    start.upto(finish) do |i|\n      # p \"row before is #{row}\"\
    \n      row[i] -= 1\n      # p \"row after is #{row}\"\n    end\n  end\n  p \"\
    d_row is #{d_row}\"\n  max_fill(d_row, capacity) + 1\nend", "  @grid = grid\n\
    \  @capacity = capacity\n  @initial_well_height = grid.flatten.select { |cell|\
    \ cell == 1 }.length\n  @current_well_height = @initial_well_height\n  @bucket_fills\
    \ = 0\n  @last_fill_row = 0\n  @last_fill_col = 0\n  fill_grid\n  @bucket_fills\n\
    end", "  lower_buckets = 0\n  while water_height(grid) > 0\n    lower_buckets\
    \ += 1\n    grid = remove_water(grid, capacity)\n  end\n  lower_buckets\nend",
  "  # code your solution here\nend", "  # TODO: implement this method\nend", "  if\
    \ grid.nil? || grid.empty?\n    raise ArgumentError.new('grid is required')\n\
    \  end", "  raise if grid.length < 1 || grid.length > 100\n  raise if grid[0].length\
    \ < 1 || grid[0].length > 100\n  raise if capacity < 1 || capacity > 10\n  raise\
    \ unless grid.all? { |row| row.all? { |c| [0, 1].include?(c) } }", "  b = Bucket.new(capacity)\n\
    \  water_filled = 0\n  water_needed = grid.sum\n  0.upto(grid.length - 1) do |i|\n\
    \    water_filled += b.fill(grid[i])\n    break if water_filled >= water_needed\n\
    \  end\n  water_filled\nend", "  # your code here\nend", "  max_fill_buckets =\
    \ 0\n  grid.each do |row|\n    max_fill_buckets += row.count(1)\n  end\n  max_fill_buckets\
    \ / capacity\nend", "  current_water = 0\n  total_water = 0\n  grid.each_with_index\
    \ do |well, row|\n    well.each_with_index do |cell, col|\n      if cell == 1\n\
    \        current_water += 1\n      else\n        if current_water > 0\n      \
    \    if current_water > capacity\n            total_water += capacity\n      \
    \    else\n            total_water += current_water\n          end\n         \
    \ current_water = 0\n        end\n      end\n    end\n    if current_water > 0\n\
    \      if current_water > capacity\n        total_water += capacity\n      else\n\
    \        total_water += current_water\n      end\n      current_water = 0\n  \
    \  end\n  end\n  total_water\nend", "  depth = grid.map(&:max).max\n  depth.times.reduce(0)\
    \ do |result, y|\n    width = grid.map { |r| r[y] }.select { |w| w > 0 }.size\n\
    \    result + (width.to_f / capacity).ceil\n  end\nend", "  x_length = grid.length\n\
    \  y_length = grid[0].length\n  x_length.times do |x|\n    y_length.times do |y|\n\
    \      if grid[x][y] == 1\n        # \u4E8C\u6B21\u5143\u914D\u5217\u306E\uFF11\
    \u304C\uFF11\u3064\u306E\u6C34\u305F\u307E\u308A\u306B\u76F8\u5F53\u3059\u308B\
    \n        start_x = x\n        end_x = x\n        start_y = y\n        end_y =\
    \ y\n        while start_x >= 0 && grid[start_x][y] == 1\n          start_x -=\
    \ 1\n        end\n        while end_x < x_length && grid[end_x][y] == 1\n    \
    \      end_x += 1\n        end\n        while start_y >= 0 && grid[x][start_y]\
    \ == 1\n          start_y -= 1\n        end\n        while end_y < y_length &&\
    \ grid[x][end_y] == 1\n          end_y += 1\n        end\n        if end_x - start_x\
    \ > end_y - start_y\n          # \u5E83\u3044\u65B9\u306B\u5408\u308F\u305B\u308B\
    \n          start_y = x\n          end_y = x\n        else\n          start_x\
    \ = y\n          end_x = y\n        end\n        (start_x..end_x).each do |x|\n\
    \          (start_y..end_y).each do |y|\n            grid[x][y] = 0\n        \
    \  end\n        end\n        return 1 + max_fill(grid, capacity)\n      end\n\
    \    end\n  end\n  0\nend", "  # your code here\nend", "  return 0 if capacity\
    \ == 0\n  res = 0\n  grid.each do |row|\n    res += _max_fill(row, capacity)\n\
    \  end\n  res\nend", "  # your code here\nend", "  return 0 if grid.empty?\n \
    \ wells = grid.map do |well|\n    count = 0\n    well.each { |i| count += 1 if\
    \ i == 1 }\n    count\n  end\n  wells.sort.inject(0) do |sum, x|\n    if x > capacity\n\
    \      sum += capacity\n    else\n      sum += x\n    end\n  end\nend", "  max_fill_helper(grid,\
    \ capacity)\nend", "  grid.map! do |well|\n    index = well.index 1\n    well.length.times.map\
    \ do |i|\n      i < index ? capacity : well[i]\n    end\n  end", "  count = 0\n\
    \  grid.each do |well|\n    count += (well.length / capacity)\n    count += 1\
    \ if well.length % capacity != 0\n  end\n  count\nend", "  grid.map! do |row|\n\
    \    row.each_with_index.map do |cell, idx|\n      {is_filled: false, capacity:\
    \ cell, index: idx}\n    end\n  end\n  count = 0\n  until grid.all? { |row| row.all?\
    \ { |cell| cell[:is_filled] == true } }\n    grid.each do |row|\n      fill_bucket(row,\
    \ capacity)\n    end\n    count += 1\n  end\n  count\nend", "  num_rows = grid.length\n\
    \  num_cols = grid[0].length\n  num_passes = 0\n  grid.each_with_index do |row,\
    \ row_idx|\n    row.each_with_index do |col, col_idx|\n      num_passes += 1 if\
    \ col > 0\n    end\n  end\n  result = 0\n  num_passes.times do |i|\n    i = 0\
    \ if i == num_passes\n    grid.each_with_index do |row, row_idx|\n      row.each_with_index\
    \ do |col, col_idx|\n        col_idx == num_cols - 1 ? result += row_idx + 1 :\
    \ result += row_idx\n      end\n    end\n  end\n  result\nend", "  # your code\
    \ here\nend", "  # your code goes here\nend", "    count = 0\n    until grid.all?\
    \ { |row| row.all?(0) }\n        count += 1\n        grid.map! do |row|\n    \
    \        row.map { |well| well - capacity }\n        end\n    end\n    count\n\
    end", "    # your code here\nend", "  # your code here\nend", "  num_rows = grid.length\n\
    \  num_columns = grid[0].length\n  # The idea is to find the highest cells in\
    \ each column and process them one by one.\n  # To find the highest cells we use\
    \ an array which stores the maximum values of the \n  # corresponding columns.\n\
    \  # Each time we process a cell we decrement its value and if it still has water\
    \ \n  # we store it in the same array. We decrement the cells of the adjacent\
    \ columns\n  # by the same amount.\n  highest_cells = []\n  num_columns.times\
    \ do |i|\n    h_cell = grid.map{|row| row[i]}.max\n    highest_cells << h_cell\n\
    \  end\n  num_of_steps = 0\n  until highest_cells.max == 0\n    highest_cells.each_with_index\
    \ do |h_cell, i|\n      if h_cell > 0\n        num_of_steps += h_cell\n      \
    \  highest_cells[i] = 0\n        if i > 0\n          highest_cells[i-1] -= h_cell\n\
    \        end\n        if i < num_columns - 1\n          highest_cells[i+1] -=\
    \ h_cell\n        end\n      end\n    end\n  end\n  num_of_steps\nend", "  # your\
    \ code goes here\nend", "    # your code here\n    buckets = capacity\n    fill\
    \ = 0\n    filled = {}\n    grid.length.times do |row|\n        grid[row].length.times\
    \ do |col|\n            if grid[row][col] == 1 && !filled[[row, col]]\n      \
    \          grid[row][col] = 0\n                fill += 1\n                buckets\
    \ -= 1\n                filled[[row, col]] = true\n            end\n         \
    \   if buckets == 0\n                buckets = capacity\n                fill\
    \ += 1\n            end\n        end\n    end\n    fill\nend", "  # YOUR CODE\
    \ HERE\nend", "\t# your code goes here\nend", "  # Fill here\nend\n```"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
