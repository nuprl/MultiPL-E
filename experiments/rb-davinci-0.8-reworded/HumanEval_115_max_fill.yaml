name: HumanEval_115_max_fill
language: rb
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n\
  # Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
  \ 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]],\
  \ 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length\
  \ <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <=\
  \ capacity <= 10\ndef max_fill(grid, capacity)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n\
  \    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0,\
  \ candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], 9))\n  end\nend\n"
completions: ["  max_sum = grid.sum\n  max_sum.times.reduce(0) do |acc, i|\n    grid.each_with_index\
    \ { |row, idx| row[i % row.length] = 1 }\n    grid.flatten.inject(0) { |a, e|\
    \ a + (e == 1 ? capacity : e) } <= max_sum ? (return acc + 1) : acc\n  end\nend",
  "    # your code here\nend", "  0\nend", "  # your code here\nend", "  # your code\
    \ here\nend", "  (0...grid.length).reduce(0) do |count, idx|\n    count + max_fill_helper(grid[idx],\
    \ capacity)\n  end\nend", "  # TODO: complete this method, return the number of\
    \ times\n  # you need to lower the buckets\n  grid.each_with_index do |row, i|\n\
    \    row.each_with_index do |value, j|\n      next if value.zero?\n      grid[i][j]\
    \ = capacity - (grid[i][j] % capacity)\n    end\n  end\n  grid.transpose.reduce(0)\
    \ do |sum, row|\n    sum + row.reduce(:+)\n  end\nend", "  num_of_empties = grid.flatten.reduce(0)\
    \ { |sum, elem| sum + (elem == 0 ? 1 : 0) }\n  num_of_empties + grid.map { |line|\
    \ [line.reduce(0) { |sum, elem| sum + (elem == 1 ? 1 : 0) }, capacity].min }.reduce(:+)\n\
    end", "  # Your code here\nend", "  # your code here\nend", "  l = grid.length\n\
    \  c = grid[0].length\n  i = 0\n  j = 0\n  count = 0\n  while i < l do\n    if\
    \ grid[i][j] == 1 && j < c\n      grid[i][j] = 0\n      count += 1\n      j +=\
    \ 1\n    else\n      j = 0\n      i += 1\n    end\n  end\n  count\nend", "  grid.reduce(0)\
    \ do |max_fill, row|\n    max_fill + row.count { |cell| cell == 1 } * capacity\n\
    \  end\nend", "  if grid.nil? || grid.empty?\n    return 0\n  end\n  # create\
    \ a matrix of zeros to hold the remaining water\n  # in the wells after each pass.\n\
    \  grid_copy = Array.new(grid.length) {Array.new(grid[0].length, 0)}\n  count\
    \ = 0", "    # your code goes here\nend", end, "  table = grid.map do |row|\n\
    \    row.select { |item| item == 1 }.count\n  end\n  table.inject { |sum, x| sum\
    \ + x }\nend", "  index = count = 0\n  0.upto(grid.size - 1) do |row|\n    if\
    \ grid[row][index] == 1\n      count += 1\n      index += 1\n    end\n  end\n\
    \  count\nend", "  # TODO: implement this method\nend", "    # TODO\nend", " \
    \ # your code here\nend\n```"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
