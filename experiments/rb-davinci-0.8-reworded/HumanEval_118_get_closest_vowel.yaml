name: HumanEval_118_get_closest_vowel
language: rb
prompt: "# You are given a word. Your task is to find the closest vowel that stands\
  \ between \n# two consonants from the right side of the word (case sensitive).\n\
  # Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n\
  # find any vowel met the above condition. \n# You may assume that the given string\
  \ contains English letter only.\n# Example:\n# >>> get_closest_vowel.call(\"yogurt\"\
  )\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"\
  quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n\
  \    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"\
  yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\
  \", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n\
  \    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"\
  bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\
  \", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"\
  ))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"\
  Above\"))\n  end\nend\n"
completions: ["  word.reverse.each_char.with_index do |c, index|\n    if vowel?(c)\n\
    \      return c if consonant?(word[-index - 2])\n    end\n  end\n  ''\nend", " \
    \ # Your code here\nend", "  vowels = \"aeiou\"\n  word.reverse.split(\"\").each_with_index\
    \ do |letter, index|\n    if vowels.include?(letter)\n      if word[-index-2].nil?\n\
    \        return word[-index-1]\n      elsif word[-index-2] == word[-index-2].downcase\n\
    \        word[-index-2] = word[-index-2].upcase\n      end\n      return word[-index-2]\
    \ if vowels.include?(word[-index-2])\n    end\n  end\n  \"\"\nend", "  vowels\
    \ = %w(a e i o u A E I O U)\n  i = -1\n  while i > -word.length\n    return word[i]\
    \ if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i\
    \ + 1])\n    i -= 1\n  end\n  ''\nend", "  if word.downcase =~ /[aeiou]/\n   \
    \ if word.downcase =~ /[^aeiou][aeiou][^aeiou]/\n      return word.scan(/[^aeiou][aeiou][^aeiou]/).last[1]\n\
    \    elsif word.downcase =~ /[^aeiou][aeiou]$/\n      return word.scan(/[^aeiou][aeiou]$/).last[1]\n\
    \    else\n      return \"\"\n    end\n  else\n    return \"\"\n  end\nend", " \
    \   word.reverse.each_char.with_index do |letter, index|\n        return word[word.length\
    \ - index - 1] if \"AEIOU\".include?(letter) && \"AEIOU\".include?(word[word.length\
    \ - index - 2])\n    end\n    \"\"\nend", "  vowels = word.scan(/[aeiou]/i)\n\
    \  vowels.last == word[-1] ? vowels[-2] : vowels.last\nend", "\tputs word\n\t\
    vowels = %w(A E I O U)\n\tword.split('').reverse.each_with_index do |char, index|\n\
    \t\tif (vowels.include?(char)) && ((vowels.include?(word[index - 1])) && (vowels.include?(word[index\
    \ + 1])))\n\t\t\treturn char\n\t\tend\n\tend\n\tputs \"Not a Valid String\"\n\
    end", "  word.chars.reverse.each_cons(3) do |right_three|\n    return right_three[1]\
    \ if right_three[0] =~ /[^aeiou]/i && right_three[2] =~ /[^aeiou]/i && right_three[1]\
    \ =~ /[aeiou]/i\n  end\n  \"\"\nend", "\tresult = \"\"\n\tword.split(\"\").reverse.each_with_index\
    \ do |letter, index|\n\t\tif letter.match(/[aeiou]/)\n\t\t\tresult = letter\n\t\
    \t\tbreak\n\t\telsif word[index + 1].match(/[aeiou]/)\n\t\t\tresult = word[index\
    \ + 1]\n\t\t\tbreak\n\t\tend\n\tend\n\tresult\nend", "\tif word.nil? || word.strip.empty?\n\
    \t\tputs \"Please provide valid input\"\n\t\treturn\n\tend\n\tvowels = %w(a e\
    \ i o u)\n\tword = word.strip.downcase.split(\"\")\n\tclosest_vowel = \"\"\n\t\
    if vowels.include?(word[0])\n\t\tclosest_vowel = word[0]\n\telsif vowels.include?(word[-1])\n\
    \t\tclosest_vowel = word[-1]\n\telse\n\t\tword.each_with_index do |c,i|\n\t\t\t\
    if(i!=0 && i!=word.length-1)\n\t\t\t\tif vowels.include?(c)\n\t\t\t\t\tif(word[i-1]!=word[i+1])\n\
    \t\t\t\t\t\tclosest_vowel = c\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\
    \t\t\tend\n\t\tend\n\tend\n\tputs closest_vowel\nend", "  words = word.gsub(/[aeiou]/,\
    \ \"aeiou\" => \"\")\n  return \"\" if words == word\n  words.reverse.each_char.with_index\
    \ do |c, i|\n    if c == \" \" && word[-(i+1)].match(/[aeiou]/)\n      return\
    \ word[-(i+1)]\n    end\n  end\nend", "\tlen = word.length\n\tidx = len - 1\n\t\
    while idx > 0 do\n\t\tif (word[idx].match /[AEIOU]/)\n\t\t\treturn word[idx]\n\
    \t\tend\n\t\tidx -= 1\n\tend\n\treturn \"\"\nend", "  word.reverse.match(/([^aeiou]+[aeiou]\\\
    w*[^aeiou]+)?/).to_s.reverse[-1]\nend", "  vowels = \"aeiou\"\n  vowels_regex\
    \ = /[aeiou]/\n  consonants_regex = /[^aeiou]/\n  word_reverse = word.reverse\n\
    \  if word_reverse.scan(vowels_regex).length > 0 &&\n    word_reverse.scan(consonants_regex).length\
    \ > 1\n    for i in 1..word_reverse.length - 1\n      if vowels.include?(word_reverse[i])\
    \ &&\n        vowels.include?(word_reverse[i - 1]) == false &&\n        vowels.include?(word_reverse[i\
    \ + 1]) == false\n        return word_reverse[i]\n      end\n    end\n  end\n\
    \  return \"\"\nend", "    return \"\" if word.length < 3\n    index = word.length\
    \ - 1\n    while index > 0 do\n        if (word[index] =~ /[aeiou]/i) && (word[index\
    \ - 1] =~ /[^aeiou]/i) && (word[index + 1] =~ /[^aeiou]/i)\n            return\
    \ word[index]\n        end\n        index -= 1\n    end\n    return \"\"\nend",
  "  vowels = \"aeiou\"\n  consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n  closest_vowel = \"\"\n  word.each_char.with_index do |ch, index|\n    break\
    \ if consonants.include?(ch) && vowels.include?(word[index + 1])\n    closest_vowel\
    \ = word[index + 1] if vowels.include?(word[index + 1])\n  end\n  closest_vowel\n\
    end", "  require 'pry'\n  word.reverse!\n  word.split('').each_with_index do |letter,\
    \ index|\n    if is_vowel?(letter)\n      if (index > 1) && (is_vowel?(word[index\
    \ - 1]) == false) && (is_vowel?(word[index - 2]) == false)\n        return letter\n\
    \      end\n    end\n  end\n  ''\nend", "  if word[-1] =~ /[aeiou]/\n    \"\"\n\
    \  else\n    vowels = word.reverse.scan(/[aeiou]/)\n    return vowels[0] if vowels.length\
    \ == 1\n    return vowels[0] if vowels[0] == vowels[1]\n    return vowels[1] if\
    \ word.reverse[0] =~ /[aeiou]/\n    return vowels[0]\n  end\nend\np get_closest_vowel(\"\
    yogurt\")\np get_closest_vowel(\"FULL\")\np get_closest_vowel(\"quick\")\np get_closest_vowel(\"\
    ab\")\np get_closest_vowel(\"b\")", "\tword = word.reverse\n\tfound = false\n\t\
    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tprev_c = \"\"\n\tprev_v = \"\"\
    \n\tword.each_char do |c|\n\t\tif vowels.include?(c)\n\t\t\tif found\n\t\t\t\t\
    return prev_v\n\t\t\telse\n\t\t\t\tprev_v = c\n\t\t\tend\n\t\telsif prev_c ==\
    \ \"\"\n\t\t\tprev_c = c\n\t\telse\n\t\t\tfound = true\n\t\tend\n\tend\n\treturn\
    \ \"\"\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
