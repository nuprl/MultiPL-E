name: HumanEval_70_strange_sort_list
language: rb
prompt: "# Given array of integers, return array in strange order.\n# Strange sorting,\
  \ is when you start with the minimum value,\n# then maximum of the remaining integers,\
  \ then minimum and so on.\n# Examples:\n# >>> strange_sort_list.call([1, 2, 3, 4])\n\
  # [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>>\
  \ strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n\
  \    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1,\
  \ 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n\
  \    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1,\
  \ 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5,\
  \ 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7,\
  \ 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2,\
  \ 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\n\
  end\n"
completions: ["  result = []\n  lst = lst.sort\n  while lst.size > 0\n    result <<\
    \ lst.shift\n    result << lst.pop\n  end\n  result\nend", "  if lst.length.even?\n\
    \    lst.sort!\n    half_length = lst.length / 2\n    left_list = lst[0..half_length\
    \ - 1]\n    right_list = lst[half_length..-1]\n    left_list.zip(right_list.reverse)\n\
    \  else\n    lst.sort!\n    half_length = lst.length / 2\n    left_list = lst[0..half_length\
    \ - 1]\n    right_list = lst[half_length..-1]\n    left_list.zip(right_list.reverse).flatten.drop(1)\n\
    \  end\nend", "  new_lst = []\n  while lst.length > 0\n    new_lst << lst.min\n\
    \    lst.delete(lst.min)\n    if lst.length > 0\n      new_lst << lst.max\n  \
    \    lst.delete(lst.max)\n    end\n  end\n  new_lst\nend", "  return lst if lst.length\
    \ <= 1\n  min_value = lst.min\n  lst.delete(min_value)\n  max_value = lst.max\n\
    \  lst.delete(max_value)\n  return [min_value, max_value] + strange_sort_list(lst)\n\
    end", "  sorted = lst.sort\n  max_i = sorted.length - 1\n  result = []\n  (0..max_i).each\
    \ do |i|\n    i.even? ? (result << sorted[i / 2]) : (result << sorted[max_i -\
    \ i / 2])\n  end\n  result\nend\nputs 'Strange sort'\nputs strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\nputs strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\nputs strange_sort_list([]) == []", "  lst.sort.partition.with_index{|_,i|\
    \ i.even?}.flatten\nend", "  lst.sort_by.with_index { |v, i| i.even? ? v : -v\
    \ }\nend", "  r = []\n  (0..lst.size - 1).step(2) do |i|\n    r << lst.slice!(lst.index(lst.min))\n\
    \    r << lst.slice!(lst.index(lst.max))\n  end\n  r\nend", "  lst.sort.each_slice(2).to_a.transpose.flatten.compact\n\
    end", "  odd = lst.select.with_index { |_, i| i.odd? }.sort\n  even = lst.select.with_index\
    \ { |_, i| i.even? }.sort.reverse\n  odd.zip(even).flatten.compact\nend", "  lst.sort_by.with_index\
    \ { |_, index| [index.even? ? :first : :last] }\nend", '  return lst if lst.empty?',
  "  return lst if lst.empty?\n  sorted = []\n  lst.sort!\n  i = 0\n  j = lst.length\
    \ - 1\n  while i <= j\n    sorted << lst[i]\n    sorted << lst[j] if i != j\n\
    \    i += 1\n    j -= 1\n  end\n  sorted\nend", "  return lst if lst.empty?\n\
    \  tmp_lst = lst.sort\n  result = []\n  while tmp_lst.length > 0\n    result <<\
    \ tmp_lst.shift\n    result << tmp_lst.pop unless tmp_lst.empty?\n  end\n  result\n\
    end", "  return lst if lst.empty?\n  max = lst.max\n  min = lst.min\n  i = lst.index(min)\n\
    \  j = lst.index(max)\n  lst[i] = max\n  lst[j] = min\n  strange_sort_list(lst)\n\
    end", "  even = lst.sort[0..(lst.length / 2 - 1)]\n  odd = lst.sort[(lst.length\
    \ / 2)..-1].reverse\n  even.each_with_index.map { |e, i| i.even? ? e : odd[i /\
    \ 2] }\nend", "  lst.sort!\n  new_lst = []\n  while lst.size != 0\n    new_lst\
    \ << lst.delete_at(0)\n    new_lst << lst.delete_at(-1)\n  end\n  new_lst\nend",
  "  min = lst.min\n  max = lst.max\n  min_el = min\n  max_el = max\n  sorted_list\
    \ = []\n  loop do\n    if sorted_list.length.even?\n      sorted_list << min_el\n\
    \      min_el += 1\n    else\n      sorted_list << max_el\n      max_el -= 1\n\
    \    end\n    break if sorted_list.length == lst.length\n  end\n  sorted_list\n\
    end", "  n = lst.length\n  res = Array.new(n)", "  lst.sort.sort_by.with_index{|_,i|\
    \ i.even? ? -1 : 1}.reverse\nend", "  idx = 0\n  lst.sort!.each_slice(2).map do\
    \ |group|\n    next group[0] if group.length == 1\n    next group[1] if idx.even?\n\
    \    next group[0] if idx.odd?\n    idx += 1\n  end\nend", "  if lst.length <\
    \ 2\n    return lst\n  end\n  sorted_array = []\n  remaining_values = lst.sort\n\
    \  while remaining_values.length > 0\n    sorted_array << remaining_values.shift\n\
    \    sorted_array << remaining_values.pop\n  end\n  sorted_array\nend", "  # write\
    \ your code here\nend", "  current_number = 0\n  current_index = 0\n  list_to_sort\
    \ = lst.clone\n  sorted_list = []\n  list_length = list_to_sort.length\n  return\
    \ list_to_sort if list_length.zero?\n  max_index = list_length - 1\n  min_index\
    \ = 0\n  # puts lst.inspect\n  # puts list_to_sort.inspect\n  while sorted_list.length\
    \ < list_length\n    unless current_number.zero?\n      if current_index.zero?\n\
    \        current_index = max_index\n      else\n        current_index = min_index\n\
    \      end\n    end\n    # puts \"current index: #{current_index}\"\n    list_to_sort.each_with_index\
    \ do |item, index|\n      unless index == current_index\n        # puts \"skipping\
    \ index: #{index}\"\n        next\n      end\n      # puts \"index: #{index}\"\
    \n      if current_number.zero?\n        current_number = item\n        list_to_sort.delete_at(index)\n\
    \        sorted_list << current_number\n        break\n      end\n      if item\
    \ > current_number\n        current_number = item\n        list_to_sort.delete_at(index)\n\
    \        sorted_list << current_number\n        break\n      end\n      if item\
    \ < current_number\n        current_number = item\n        list_to_sort.delete_at(index)\n\
    \        sorted_list << current_number\n        break\n      end\n    end\n  end\n\
    \  return sorted_list\nend", "  lst = lst.sort.each_slice(2).to_a\n  lst.first.zip(lst.last).flatten.compact\n\
    end", "  array_copy = lst.dup\n  sorted_list = []\n  max_index = array_copy.length\
    \ - 1\n  min_index = 0\n  while max_index >= min_index\n    sorted_list << array_copy.delete_at(min_index)\n\
    \    sorted_list << array_copy.delete_at(max_index)\n    max_index -= 1\n  end\n\
    \  sorted_list\nend", "  # your code here\nend", "  lst.minmax.reverse.reduce([])\
    \ { |a, i| a << i << a.shift }\nend", "  lst.sort!\n  lst_new = []\n  lst_new\
    \ << lst.shift\n  lst_new << lst.pop\n  until lst.length == 0\n    lst_new <<\
    \ lst.shift\n    lst_new << lst.pop\n  end\n  lst_new\nend", "  lst.sort!\n  i\
    \ = 0\n  res = []\n  while i < lst.size\n    res << lst[i]\n    res << lst[-i\
    \ - 1]\n    i += 1\n  end\n  res\nend", "  lst.sort[0...-1].zip(lst.sort[1..-1]).flatten.compact\n\
    end", "  # sort the array and initialize the final array with the first element\n\
    \  sorted_lst = lst.sort\n  res = [sorted_lst.first]\n  # pick the next element\
    \ from the sorted array either from the min or max\n  until sorted_lst.empty?\n\
    \    if res.size % 2 == 0\n      res << sorted_lst.min\n      sorted_lst.delete_at(sorted_lst.index(sorted_lst.min))\n\
    \    else\n      res << sorted_lst.max\n      sorted_lst.delete_at(sorted_lst.index(sorted_lst.max))\n\
    \    end\n  end\n  res\nend", "  lst.sort_by.with_index{|x,i| [i.even? ? x : -x,\
    \ x]}\nend", "  raise NotImplementedError\nend", "  return lst if lst.length <=\
    \ 1\n  res = []\n  lst = lst.sort\n  min = lst.shift\n  max = lst.pop\n  res <<\
    \ min\n  res << max\n  while lst.any?\n    res << lst.shift\n    res << lst.pop\n\
    \  end\n  res << lst.shift if lst.any?\n  res\nend", "  return lst if lst.empty?\n\
    \  result = []\n  left = lst.sort\n  right = left.reverse\n  loop do\n    break\
    \ if left.empty? && right.empty?\n    result << left.shift\n    result << right.shift\n\
    \  end\n  result\nend", "\tlength = lst.length\n\tif length == 0\n\t\treturn []\n\
    \tend\n\tif length == 1\n\t\treturn lst\n\tend\n\tif length == 2\n\t\treturn [lst[0],\
    \ lst[1]]\n\tend\n\t\n\tlst.sort!", "  sorted_list = []\n  list_size = lst.size\n\
    \  lst = lst.sort\n  until sorted_list.size == list_size\n    sorted_list << lst.shift\
    \ << lst.pop\n  end\n  sorted_list\nend", "  sorted_lst = []\n  while lst.size\
    \ > 0\n    max = lst.max\n    min = lst.min\n    lst.delete(max)\n    lst.delete(min)\n\
    \    sorted_lst << min\n    sorted_lst << max\n  end\n  sorted_lst\nend", "\t\
    if lst.empty?\n\t\treturn []\n\tend\n\tn = lst.size\n\tlst_sort = Array.new(n)\n\
    \teven_odd = 0\n\tfor i in 0..n/2-1\n\t\tlst_sort[even_odd] = lst.min\n\t\tlst.delete(lst.min)\n\
    \t\teven_odd += 2\n\tend\n\teven_odd = 1\n\tfor i in 0..n/2-1\n\t\tlst_sort[even_odd]\
    \ = lst.max\n\t\tlst.delete(lst.max)\n\t\teven_odd += 2\n\tend\n\treturn lst_sort\n\
    end", "  min_idx = lst.index(lst.min)\n  min_val = lst.delete_at(min_idx)\n  max_idx\
    \ = lst.index(lst.max)\n  max_val = lst.delete_at(max_idx)\n  lst.unshift(min_val,\
    \ max_val)\n  return lst\nend", "  sorted_list = []\n  1.upto(lst.size) do |number|\n\
    \    min = lst.min\n    lst.delete(min)\n    max = lst.max\n    lst.delete(max)\n\
    \    sorted_list << min\n    sorted_list << max if max\n  end\n  sorted_list\n\
    end", "  # your code here\nend", "  if lst.empty?\n    []\n  else\n    i = 0\n\
    \    max = lst.max\n    min = lst.min\n    a = []\n    a << min\n    a << max\n\
    \    lst.delete(min)\n    lst.delete(max)\n    while i < lst.size\n      min =\
    \ lst.min\n      max = lst.max\n      a << min\n      a << max\n      lst.delete(min)\n\
    \      lst.delete(max)\n      i += 1\n    end\n    a\n  end\nend", "  lst.select\
    \ { |i| i.odd? }.reverse + lst.select { |i| i.even? }\nend", "  #write your code\
    \ here\nend", "  lst.sort.each_slice(2).to_a.transpose.flatten.reject { |x| x.nil?\
    \ }\nend", "  i = 0\n  j = lst.size - 1\n  result = []\n  until i > j\n    if\
    \ lst[i] < lst[j]\n      result << lst[i]\n      i += 1\n    else\n      result\
    \ << lst[j]\n      j -= 1\n    end\n  end\n  result\nend", "    max, min = lst.max,\
    \ lst.min\n    sorted = []\n    until lst.empty?\n        if sorted.count.even?\n\
    \            sorted << min\n            lst.delete(min)\n            min = lst.min\n\
    \        else\n            sorted << max\n            lst.delete(max)\n      \
    \      max = lst.max\n        end\n    end\n    sorted\nend", "  return lst if\
    \ lst.empty?\n  result = []\n  min_index = lst.index(lst.min)\n  result << lst.delete_at(min_index)\n\
    \  while !lst.empty?\n    max_index = lst.index(lst.max)\n    result << lst.delete_at(max_index)\n\
    \    min_index = lst.index(lst.min)\n    result << lst.delete_at(min_index)\n\
    \  end\n  result\nend", "  max = lst.max\n  min = lst.min\n  n = lst.size", " \
    \ if lst.empty?\n    return []\n  end\n  result = []\n  while lst.size > 0\n \
    \   min = lst.min\n    max = lst.max\n    lst.delete(min)\n    lst.delete(max)\n\
    \    result << min\n    result << max\n  end\n  result\nend", "  # return empty\
    \ array if argument is empty\n  return [] if lst.empty?\n  # define a helper method\
    \ to grab min or max and remove\n  def min_or_max(lst, min_or_max)\n    min_or_max\
    \ == 'min' ? lst.min : lst.max\n  end\n  # define a helper method to find the\
    \ index of the min or max and remove\n  def find_and_remove(lst, min_or_max)\n\
    \    index = lst.index(min_or_max(lst, min_or_max))\n    lst.delete_at(index)\n\
    \  end\n  # define new array to store values as they are added\n  answer = []\n\
    \  # create a loop that will continue until all the values have been added to\
    \ the new array\n  while lst.length > 0\n    # odd number, min removed\n    answer\
    \ << find_and_remove(lst, 'min')\n    # even number, max removed\n    answer <<\
    \ find_and_remove(lst, 'max')\n  end\n  # sort the answer array in increasing\
    \ order\n  answer.sort\nend", "  return lst if lst.empty?\n  result = []\n  lst.sort!\n\
    \  lst << lst.shift\n  until lst.empty?\n    result << lst.shift\n    result <<\
    \ lst.pop\n  end\n  result\nend", "  lst.sort.each_slice(2).flat_map(&:reverse)\n\
    end", "  if lst.empty?\n    return []\n  end\n  result = []\n  result.push(lst.min)\n\
    \  until lst.length <= 1\n    if result.length.even?\n      result.push(lst.max)\n\
    \    else\n      result.push(lst.min)\n    end\n    lst.delete(result.last)\n\
    \  end\n  result\nend", "  max = lst.max\n  min = lst.min\n  i = 0\n  new = []\n\
    \  while i < lst.size\n    new << min\n    new << max\n    i += 2\n  end\n  new\n\
    end", "  if lst.empty?\n    []\n  else\n    x = lst.delete_at(lst.index(lst.min))\n\
    \    y = lst.delete_at(lst.index(lst.max))\n    strange_sort_list(lst) + [x, y]\n\
    \  end\nend", "  return lst if lst.empty?\n  sorted = lst.uniq.sort\n  result\
    \ = [sorted.shift]\n  loop do\n    break if sorted.empty?\n    result << sorted.pop\n\
    \    break if sorted.empty?\n    result << sorted.shift\n  end\n  result\nend",
  "  return lst if lst.empty?\n  min_val = min(lst)\n  max_val = max(lst)\n  new_lst\
    \ = []\n  while new_lst.size < lst.size\n    new_lst << min_val\n    new_lst <<\
    \ max_val\n  end\n  new_lst\nend", end, "  raise NotImplementedError\nend", " \
    \ lst.size > 1 ? [lst.min] + strange_sort_list(lst.select { |x| x != lst.min })\
    \ + strange_sort_list(lst.select { |x| x != lst.max }) + [lst.max] : lst\nend",
  "\tif lst.length % 2 == 0\n\t\tlst.sort!.reverse!\n\t\tlst.each_slice(2).to_a.transpose.flatten\n\
    \telse\n\t\tlst.sort!.reverse!\n\t\tlst[-1] = lst[-1]\n\t\tlst.each_slice(2).to_a.transpose.flatten\n\
    \tend\nend", "  lst.sort.partition.with_index { |_, index| index.even? }.flatten\n\
    end", "  s = lst.sort\n  i = 0\n  o = []\n  e = []\n  while i < s.length\n   \
    \ i.even? ? o << s[i] : e << s[i]\n    i += 1\n  end\n  o + e\nend", "  return\
    \ lst if lst.empty?\n  sorted = []\n  min_index = lst.find_index(lst.min)\n  lst.delete_at(min_index)\n\
    \  sorted << lst.min\n  sorted << lst.max\n  sorted << lst.min\n  sorted << lst.max\n\
    \  sorted.flatten!\n  lst << sorted.min\n  lst << sorted.max\n  lst << sorted.min\n\
    \  lst << sorted.max\n  lst.flatten!\n  lst\nend", "  res = []\n  while lst.size\
    \ > 0\n    res << lst.delete(lst.min)\n    res << lst.delete(lst.max)\n  end\n\
    \  res\nend", "  return lst if lst.empty?\n  res = [lst.min]\n  lst.delete(lst.min)\n\
    \  n = 1\n  while n < lst.length\n    n.even? ? res << lst.max : res << lst.min\n\
    \    n.even? ? lst.delete(lst.max) : lst.delete(lst.min)\n    n += 1\n  end\n\
    \  res << lst[0]\nend", "  lst.sort_by.with_index { |e, i| [(i + 1) % 2, e] }\n\
    end", "  lst.sort.each_slice(2).to_a.transpose.flatten.compact\nend", "  lst.sort.reverse.each_slice(2).to_a.transpose.flatten\n\
    end", "  lst.sort_by.with_index { |v, i| [i.even? ? v : -v, v] }\nend", "  if\
    \ lst.empty?\n    return []\n  end\n  lst = lst.uniq\n  sorted_list = []\n  while\
    \ lst.any?\n    sorted_list << lst.min\n    lst.delete(lst.min)\n    if lst.any?\n\
    \      sorted_list << lst.max\n      lst.delete(lst.max)\n    end\n  end\n  sorted_list\n\
    end", "  if lst.nil? || lst.empty?\n    []\n  else\n    lst.sort.reverse\n  end\n\
    end", "  return lst if lst.empty?\n  min = lst.delete_at(lst.index(lst.min))\n\
    \  max = lst.delete_at(lst.index(lst.max))\n  [min, max] + strange_sort_list(lst)\n\
    end", "  max_lst = []\n  min_lst = []\n  final_list = []\n  lst.sort.each_with_index\
    \ do |el, index|\n    if index.even?\n      max_lst << el\n    else\n      min_lst\
    \ << el\n    end\n  end\n  while max_lst.any? || min_lst.any?\n    if max_lst.any?\n\
    \      final_list << max_lst.shift\n    end\n    if min_lst.any?\n      final_list\
    \ << min_lst.pop\n    end\n  end\n  final_list\nend", "  # check for lists with\
    \ 0 or 1 elements\n  if lst.length <= 1\n    return lst\n  end", "  lst.sort_by\
    \ do |a|\n    [lst.index(a), lst.index(a)%2]\n  end\nend", "  sorted_list = []\n\
    \  sorted_list.push(lst.min)\n  sorted_list.push(lst.max)\n  lst.delete(lst.min)\n\
    \  lst.delete(lst.max)\n  sorted_list.push(lst.min)\n  sorted_list.push(lst.max)\n\
    \  lst.delete(lst.min)\n  lst.delete(lst.max)\n  sorted_list.push(lst.min)\n \
    \ sorted_list.push(lst.max)\n  lst.delete(lst.min)\n  lst.delete(lst.max)\n  sorted_list.push(lst.min)\n\
    \  sorted_list.push(lst.max)\n  lst.delete(lst.min)\n  lst.delete(lst.max)\n \
    \ sorted_list.push(lst.min)\n  sorted_list.push(lst.max)\n  lst.delete(lst.min)\n\
    \  lst.delete(lst.max)\n  sorted_list.push(lst.min)\n  sorted_list.push(lst.max)\n\
    \  lst.delete(lst.min)\n  lst.delete(lst.max)\n  sorted_list.push(lst.min)\n \
    \ sorted_list.push(lst.max)\n  lst.delete(lst.min)\n  lst.delete(lst.max)\n  sorted_list.push(lst.min)\n\
    \  sorted_list.push(lst.max)\n  lst.delete(lst.min)\n  lst.delete(lst.max)\n \
    \ sorted_list.push(lst.min)\n  sorted_list.push(lst.max)\n  lst.delete(lst.min)\n\
    \  lst.delete(lst.max)\n  sorted_list.push(lst.min)\n  sorted_list.push(lst.max)\n\
    \  lst.delete(lst.min)\n  lst.delete(lst.max)\n  sorted_list", "  min = lst.min\
    \ || lst\n  lst.reject! { |i| i == min }\n  max = lst.max || lst\n  lst.reject!\
    \ { |i| i == max }\n  lst.empty? ? [min, max] : [min, max] + strange_sort_list(lst)\n\
    end", "  raise 'Argument is not a list.' unless lst.is_a?(Array)\n  return lst\
    \ if lst.empty?\n  odd = []\n  even = []\n  lst.sort.each_with_index do |el, i|\n\
    \    i.even? ? even << el : odd << el\n  end\n  (odd + even).reject { |e| e.nil?\
    \ }\nend", "  # 1. Start with first index, which would be lowest value (min)\n\
    \  # 2. Select all items from the array besides the min\n  # 3. Select the max\
    \ of those items (max)\n  # 4. Push max to the array\n  # 5. Repeat steps 1-4\
    \ using all items minus the max\n  # 6. Return the new array", "    raise ArgumentError\
    \ if !lst.is_a?(Array)\n    lst.sort { |x, y| x <=> y }.each_slice(2).to_a.transpose.map(&:compact).flatten\n\
    end", "  res = []\n  while lst.any?\n    if lst.length == 1\n      res << lst.pop\n\
    \    else\n      res << lst.delete_at(lst.index(lst.min))\n      res << lst.delete_at(lst.index(lst.max))\n\
    \    end\n  end\n  res\nend", "  raise NotImplementedError\nend", "  lst.sort.reverse.map.with_index\
    \ do |element, i|\n    lst.insert(i * 2, element).delete_at(i * 2 + 1)\n  end\n\
    end", "\tlst.sort!\n\tnew_lst = []\n\tlst.each_with_index do |e, i|\n\t\tif i\
    \ == 0\n\t\t\tnew_lst << e\n\t\telse\n\t\t\tlst[i] < lst[i-1] ? new_lst.unshift(e)\
    \ : new_lst << e\n\t\tend\n\tend\n\tnew_lst\nend", "  new_lst = []\n  idx = 0\n\
    \  lst.length.times do\n    new_lst << lst.slice!(lst.index(lst.max) || idx)\n\
    \    new_lst << lst.slice!(lst.index(lst.min) || idx)\n  end\n  new_lst\nend",
  "  lst.sort_by.with_index { |x, i| x.to_s + i.to_s }\nend", "  return lst if lst.size\
    \ <= 1\n  lst.sort!\n  (0..lst.size/2).map { |idx| idx.zero? ? lst[idx] : lst[idx*2\
    \ - 1, 2].reverse }.flatten\nend", "  temp = lst.sort\n  (temp.length/2).times\
    \ do |i|\n    if i.even?\n      temp.insert(i, temp.delete_at(temp.length - 1))\n\
    \    else\n      temp.insert(i, temp.delete_at(0))\n    end\n  end\n  temp\nend",
  "  if lst.size == 0\n    return []\n  elsif lst.size == 1\n    return lst\n  else\n\
    \    min = lst.min\n    max = lst.max\n    new_lst = []\n    i = 1\n    new_lst.push(min)\n\
    \    while i < lst.size\n      if i % 2 == 0\n        new_lst.push(min)\n    \
    \  else\n        new_lst.push(max)\n      end\n      i += 1\n    end\n    new_lst\n\
    \  end\nend", "  lst.sort.partition.with_index { |_, i| i.even? }.flatten\nend",
  "  a,b=[],[]\n  if lst.size.even?\n    lst.each_with_index {|n,i| (i+1).odd? ? a<<n\
    \ : b<<n }\n    a.sort + b.sort\n  else\n    lst.each_with_index {|n,i| (i+1).odd?\
    \ ? a<<n : b<<n }\n    a.sort + b.sort.reverse\n  end\nend", "  return lst if\
    \ lst.empty?\n  lst = lst.sort\n  result = []\n  result.push(lst.shift)\n  lst.reverse!\n\
    \  result.push(lst.shift) until lst.empty?\n  result\nend", "  return lst if lst.empty?\n\
    \  (lst.size/2).times.each_with_object([]) do |_, new_lst|\n    new_lst << lst.min\n\
    \    new_lst << lst.max\n    lst.delete(lst.min)\n    lst.delete(lst.max)\n  end\n\
    end", "  lst.sort.each_slice(2).to_a.transpose.flatten.compact\nend", "  sorted_array\
    \ = []\n  while lst.length > 0\n    sorted_array << lst.min\n    lst.delete_at(lst.index(lst.min))\n\
    \    sorted_array << lst.max if lst.length > 0\n    lst.delete_at(lst.index(lst.max))\
    \ if lst.length > 0\n  end\n  sorted_array\nend", "  lst.sort!\n  lst.each_slice(2).to_a.reverse.flatten\n\
    end", "  return lst if lst.empty?\n  result = []\n  result << lst.min\n  result\
    \ << lst.max\n  lst.delete(lst.min)\n  lst.delete(lst.max)\n  until lst.empty?\n\
    \    result << lst.min\n    result << lst.max\n    lst.delete(lst.min)\n    lst.delete(lst.max)\n\
    \  end\n  result\nend", "  return lst if lst.empty?\n  [lst.min] + strange_sort_list(lst.max\
    \ ? lst.delete_at(lst.index(lst.max)) : [])\nend", "  lst.sort.zip(lst.sort.reverse).flatten.compact\n\
    end", "  if lst.empty?\n    lst\n  else\n    sort_and_flip(lst.sort)\n  end\n\
    end", "  lst.sort!\n  lst.delete_at(0)\n  lst.reverse!\n  lst.delete_at(0)\n \
    \ lst.reverse!\n  lst\nend", "  lst.sort_by.with_index { |_, i| [i.even? ? :first\
    \ : :last] }\nend", "  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n\
    \  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index\
    \ = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n\
    \  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index\
    \ = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n\
    \  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index\
    \ = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n\
    \  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index\
    \ = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n\
    \  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index\
    \ = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n\
    \  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index\
    \ = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n\
    \  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index\
    \ = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n\
    \  #index = 0\n  #index = 0\n  #index = 0\n  #index = 0\n ", "  lst.sort.reverse.each_slice(2).map(&:reverse).flatten\n\
    end", "  result = []\n  lst = lst.sort\n  while lst.length > 0\n    result <<\
    \ lst.shift\n    result << lst.pop if lst.length > 0\n  end\n  result\nend", " \
    \ return lst if lst.length <= 1\n  result = []\n  result << lst.min\n  lst.delete(lst.min)\n\
    \  while !lst.empty?\n    result << lst.max\n    lst.delete(lst.max)\n    result\
    \ << lst.min\n    lst.delete(lst.min)\n  end\n  result\nend\nputs strange_sort_list([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\nputs strange_sort_list([5, 5, 5, 5]) == [5, 5, 5,\
    \ 5]\nputs strange_sort_list([]) == []\nputs strange_sort_list([1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10]) == [1, 10, 2, 9, 3, 8, 4, 7, 5, 6]", "  lst.each_slice(2).flat_map\
    \ { |a, b| [a, b].compact.sort.reverse }\nend", "  return lst if lst.empty?\n\
    \  size = lst.size\n  result = []\n  s_lst = lst.sort\n  loop do\n    result.push(s_lst.shift)\n\
    \    result.push(s_lst.pop)\n    break if result.size == size\n  end\n  result\n\
    end", "  sorted = []\n  while lst.length != 0\n    sorted << lst.min\n    lst.delete_at(lst.index(lst.min))\n\
    \    sorted << lst.max\n    lst.delete_at(lst.index(lst.max))\n  end\n  sorted\n\
    end", "  # 1. we define two variables - one for minimum value and one for maximum\
    \ value\n  # 2. we iterate over the input list, and update those two variables\n\
    \  # 3. if we encounter a value that is bigger than the current maximum, we set\
    \ it to current maximum\n  # 4. if we encounter a value that is smaller than the\
    \ current minimum, we set it to current minimum\n  # 5. if we encounter a value\
    \ that is between the minimum and maximum, we remove it from the list\n  # 6.\
    \ we append the current minimum to our output list\n  # 7. we append the current\
    \ maximum to our output list\n  # 8. we remove the minimum and maximum from the\
    \ input list, since we appended them to the output list\n  # 9. we repeat from\
    \ step 1, with the remaining values from the input list\n  # 10. we stop iterating\
    \ when there are no more values in the input list\n  # 11. we return the output\
    \ list", "  if lst.empty?\n    lst\n  else\n    max = lst.max\n    min = lst.min\n\
    \    new_lst = []\n    while lst.size > 0\n      if new_lst.empty?\n        new_lst\
    \ << min\n        lst.delete(min)\n      else\n        new_lst << max\n      \
    \  lst.delete(max)\n      end\n      break if lst.empty?\n      new_lst << min\n\
    \      lst.delete(min)\n      break if lst.empty?\n      new_lst << max\n    \
    \  lst.delete(max)\n    end\n    new_lst\n  end\nend", "  sorted = []\n  while\
    \ lst.size > 0\n    sorted << lst.min\n    lst.delete_at(lst.index(lst.min))\n\
    \    sorted << lst.max if lst.size > 0\n    lst.delete_at(lst.index(lst.max))\
    \ if lst.size > 0\n  end\n  sorted\nend", "\ta = lst.sort\n\tlength = a.length\n\
    \tfirst, second = a.shift, a.pop\n\treturn [] if length == 0\n\treturn [first]\
    \ if length == 1\n\treturn [first, second] if length == 2\n\tx = 0\n\twhile x\
    \ < length\n\t\tif x == 0\n\t\t\tlst[x] = first\n\t\t\tx += 1\n\t\telsif x.even?\n\
    \t\t\tlst[x] = second\n\t\t\tx += 1\n\t\telsif x.odd?\n\t\t\tlst[x] = first\n\t\
    \t\tx += 1\n\t\tend\n\tend\n\tlst\nend", "  results = []\n  while lst.any?\n \
    \   results << lst.min\n    lst.delete_at(lst.index(lst.min))\n    results <<\
    \ lst.max\n    lst.delete_at(lst.index(lst.max))\n  end\n  results\nend", "  sorted\
    \ = []\n  lst.sort!\n  while lst.any?\n    sorted << lst.shift\n    sorted <<\
    \ lst.pop\n  end\n  sorted\nend", "  min_idx = (0...lst.size).min_by { |i| lst[i]\
    \ }\n  max_idx = (0...lst.size).max_by { |i| lst[i] }\n  res = []\n  while min_idx\
    \ != max_idx\n    res << lst[min_idx]\n    res << lst[max_idx]\n    min_idx +=\
    \ 1\n    max_idx -= 1\n  end\n  res << lst[min_idx] if min_idx == max_idx\n  res\n\
    end", "  lst.sort_by.with_index { |_, idx| idx.even? ? 1 : -1 }\nend", "\trv =\
    \ []\n\twhile !lst.empty?\n\t\trv << lst.min\n\t\tlst.delete_at(lst.index(lst.min))\n\
    \t\trv << lst.max\n\t\tlst.delete_at(lst.index(lst.max))\n\tend\n\trv\nend", " \
    \ raise StandardError, 'Invalid arguments' if !lst.is_a?(Array)\n  new_lst = []\n\
    \  lst.each do |elem|\n    raise StandardError, 'All elements must be integer'\
    \ if !elem.is_a?(Integer)\n  end\n  new_lst << lst.min\n  while new_lst.length\
    \ < lst.length\n    if new_lst.length % 2 == 1\n      new_lst << lst.reject {\
    \ |elem| new_lst.include?(elem) }.max\n    else\n      new_lst << lst.reject {\
    \ |elem| new_lst.include?(elem) }.min\n    end\n  end\n  new_lst\nend", "  lst.sort_by\
    \ { |x| [x.to_s(2).length, x] }\nend", "  return lst if lst.empty?\n  sorted =\
    \ []\n  increasing = true\n  until lst.empty?\n    if increasing\n      sorted\
    \ << lst.min\n      lst.delete_at(lst.index(lst.min))\n    else\n      sorted\
    \ << lst.max\n      lst.delete_at(lst.index(lst.max))\n    end\n    increasing\
    \ = !increasing\n  end\n  sorted\nend", "  lst.sort!\n  for i in 0..lst.length-1\n\
    \    if i % 2 == 0\n      lst.insert(i, lst.pop)\n    end\n  end\n  lst\nend\n\
    puts strange_sort_list([1, 2, 3, 4])\nputs strange_sort_list([5, 5, 5, 5])\nputs\
    \ strange_sort_list([])", "  min = lst.select{|i| i == lst.min}\n  max = lst.select{|i|\
    \ i == lst.max}\n  if lst.length.even?\n    min + max.reverse + strange_sort_list(lst\
    \ - min - max)\n  else\n    max + min.reverse + strange_sort_list(lst - min -\
    \ max)\n  end\nend", "  new_lst = []\n  min_num = 0\n  max_num = 0\n  until lst.empty?\n\
    \    if lst.length.even?\n      min_num = lst.min\n      new_lst << min_num\n\
    \      lst.delete(min_num)\n      max_num = lst.max\n      new_lst << max_num\n\
    \      lst.delete(max_num)\n    else\n      max_num = lst.max\n      new_lst <<\
    \ max_num\n      lst.delete(max_num)\n      min_num = lst.min\n      new_lst <<\
    \ min_num\n      lst.delete(min_num)\n    end\n  end\n  new_lst\nend", "  sort_list\
    \ = []\n  size = lst.size\n  while sort_list.size < size\n    sort_list << lst.min\n\
    \    lst.delete(lst.min)\n    sort_list << lst.max\n    lst.delete(lst.max)\n\
    \  end\n  sort_list\nend", "  # your code here\nend", "  raise NotImplementedError\n\
    end", "  raise ArgumentError if lst.class != Array\n  return lst if lst.empty?\n\
    \  res = []\n  i = 0\n  while lst.length > 0\n    res << lst.min\n    lst.delete_at(lst.index(lst.min))\n\
    \    break if lst.empty?\n    res << lst.max\n    lst.delete_at(lst.index(lst.max))\n\
    \  end\n  res\nend", "  new_list = []\n  while lst.length > 0\n    min = lst.min\n\
    \    max = lst.max\n    new_list << min\n    new_list << max\n    lst.delete(min)\n\
    \    lst.delete(max)\n  end\n  new_list\nend", "  new_lst = lst.dup\n  return\
    \ lst if lst.length == 0\n  max = new_lst.max\n  min = new_lst.min\n  index =\
    \ new_lst.index(min)\n  new_lst[index] = max\n  while index < new_lst.length\n\
    \    index += 1\n    new_lst[index] = min\n    min = new_lst.min\n    index =\
    \ new_lst.index(min)\n    new_lst[index] = max\n    max = new_lst.max\n  end\n\
    \  new_lst\nend", "  middle = lst.size / 2\n  new_list = []\n  lst.sort!\n  i\
    \ = 0\n  while new_list.size < lst.size\n    new_list << lst[i]\n    new_list\
    \ << lst[-i - 1]\n    i += 1\n  end\n  new_list\nend", '  return lst if lst.empty?',
  "  # Write your code here\nend", "  # lst.min(lst.length / 2).concat(lst.max(lst.length\
    \ / 2)).compact\n  a = b = []\n  lst.length.times do\n    a << lst.min\n    lst.delete(lst.min)\n\
    \    b << lst.max\n    lst.delete(lst.max)\n  end\n  a.concat(b).compact\nend",
  "  return lst if lst.empty?\n  res = []\n  max = lst.max\n  min = lst.min\n  while\
    \ !lst.empty?\n    res << min\n    lst.delete(min)\n    res << max\n    lst.delete(max)\n\
    \    max = lst.max\n    min = lst.min\n  end\n  res\nend", "  min = lst.min\n\
    \  max = lst.max\n  [min] + (lst - [min] - [max]).reverse + [max]\nend", "  return\
    \ lst if lst.size <= 1\n  sorted = lst.sort\n  [sorted.first] + strange_sort_list(sorted[1..-2])\
    \ + [sorted.last]\nend", "    n = lst.length\n    return lst if n == 0\n    sorted\
    \ = []\n    while lst.length > 0\n        sorted << lst.delete(lst.min)\n    \
    \    sorted << lst.delete(lst.max)\n    end\n    sorted\nend", "  lst.sort.reverse.each_slice(2).to_a.transpose.flatten\n\
    end", "  return lst if lst.empty?\n  lst.sort!\n  [lst.first] + strange_sort_list(lst[1..-2])\
    \ + [lst.last]\nend", "  return lst if lst.size == 0\n  min = lst.min\n  max =\
    \ lst.max\n  i = 0\n  flag = 0\n  j = 0\n  while i < lst.size\n    if flag ==\
    \ 0\n      min = lst.min\n      lst.delete_at(lst.index(min))\n      lst.insert(j,\
    \ min)\n      flag = 1\n    else\n      max = lst.max\n      lst.delete_at(lst.index(max))\n\
    \      lst.insert(j, max)\n      flag = 0\n    end\n    i += 1\n    j += 1\n \
    \ end\n  return lst\nend", "  (lst.min..lst.max).to_a.map { |n| [n, n * -1] }.flatten.map\
    \ { |n| lst.include?(n.abs) ? n.abs : nil }.compact\nend", "  lst.sort.each_slice(2).map(&:reverse).flatten\n\
    end", "  i = 0\n  result = []\n  x = lst.size\n  while i < x do\n    result <<\
    \ lst.min\n    lst.delete(lst.min)\n    result << lst.max\n    lst.delete(lst.max)\n\
    \    i += 1\n  end\n  result\nend", "  # \u043F\u0440\u043E\u0432\u0435\u0440\u043A\
    \u0430 \u043D\u0430 \u043F\u0443\u0441\u0442\u043E\u0439 \u043C\u0430\u0441\u0441\
    \u0438\u0432\n  return [] if lst.empty?\n  # \u0437\u0430\u043F\u043E\u043B\u043D\
    \u0435\u043D\u0438\u0435 \u0432\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\
    \u043C\u043E\u0433\u043E \u043C\u0430\u0441\u0441\u0438\u0432\u0430 \u043F\u0435\
    \u0440\u0432\u044B\u043C\u0438 \u0434\u0432\u0443\u043C\u044F \u044D\u043B\u0435\
    \u043C\u0435\u043D\u0442\u0430\u043C\u0438\n  # \u0438 \u0441\u043E\u0440\u0442\
    \u0438\u0440\u043E\u0432\u043A\u0430 \u0438\u0441\u0445\u043E\u0434\u043D\u043E\
    \u0433\u043E \u043C\u0430\u0441\u0441\u0438\u0432\u0430\n  result = [lst.min,\
    \ lst.max]\n  lst.sort!\n  # \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u0438\
    \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u0430 \u043F\u043E \u043F\u0440\u0430\
    \u0432\u0438\u043B\u0443 \u0441\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\
    \u0438\n  lst.each_with_index do |el, index|\n    next if [lst.min, lst.max].include?(el)\n\
    \    if index.even?\n      result << el\n    else\n      result.unshift(el)\n\
    \    end\n  end\n  result\nend", "  lst.sort!.inject([]) { |acc, v| acc << v <<\
    \ acc.shift }\nend", "\treturn lst if lst.size <= 1\n\tlst = lst.sort\n\tsize\
    \ = lst.size\n\t@result = []\n\ti = 0\n\twhile i < size\n\t\t@result << lst.slice!(0)\n\
    \t\tif lst.size > 0\n\t\t\t@result << lst.slice!(-1)\n\t\tend\n\t\ti += 1\n\t\
    end\n\t@result\nend", "\tsorted = lst.sort\n\tnew_lst = []\n\twhile !sorted.empty?\n\
    \t\tmin = sorted.shift\n\t\tnew_lst << min\n\t\tif !sorted.empty?\n\t\t\tmax =\
    \ sorted.pop\n\t\t\tnew_lst << max\n\t\tend\n\tend\n\treturn new_lst\nend", " \
    \ return lst if lst.size < 2\n  array = []\n  lowest = lst.min\n  array << lowest\n\
    \  max_remaining = lst.reject { |x| x == lowest }.max\n  array << max_remaining\n\
    \  array + strange_sort_list(lst.reject { |x| x == lowest || x == max_remaining\
    \ })\nend", '  return lst if lst.empty?', "  lst.sort_by { |v| [v, -v] }\nend",
  "  lst.sort.partition.with_index { |_, i| i.even? }.flatten\nend", "  lst.sort.rotate(lst.length/2)\n\
    end", "  min = lst.min\n  i = 0\n  while i < lst.length\n    if lst[i] == min\n\
    \      lst.delete_at(i)\n      lst.insert(i, min)\n      i += 1\n    end\n   \
    \ max = lst.max\n    if lst[i] == max\n      lst.delete_at(i)\n      lst.insert(i,\
    \ max)\n      i += 1\n    end\n  end\n  lst\nend", "  # Implement this one\nend",
  "  lst.sort.each_slice(2).to_a.map(&:reverse).flatten\nend", "  sorted = false\n\
    \  while !sorted\n    sorted = true\n    (0...lst.length-1).each do |i|\n    \
    \  if (i.even? && lst[i] > lst[i+1]) || (i.odd? && lst[i] < lst[i+1])\n      \
    \  lst[i], lst[i+1] = lst[i+1], lst[i]\n        sorted = false\n      end\n  \
    \  end\n  end\n  lst\nend", "  return lst if lst.empty?\n  result = []\n  result\
    \ << lst.min\n  lst.delete(lst.min)\n  until lst.empty?\n    result << lst.max\n\
    \    lst.delete(lst.max)\n    result << lst.min\n    lst.delete(lst.min)\n  end\n\
    \  result\nend", "  return lst if lst.empty?\n  res = [lst.min]\n  lst.delete(lst.min)\n\
    \  lst.size.times do\n    res << lst.max\n    res << lst.min\n    lst.delete(lst.max)\n\
    \    lst.delete(lst.min)\n  end\n  res\nend", "\treturn lst if lst.empty?\n\t\
    sorted_lst = []\n\tlst_length = lst.length\n\twhile !lst.empty?\n\t\tsorted_lst\
    \ << lst.min\n\t\tlst.delete(lst.min)\n\t\tif !lst.empty?\n\t\t\tsorted_lst <<\
    \ lst.max\n\t\t\tlst.delete(lst.max)\n\t\tend\n\tend\n\tsorted_lst\nend", "  min\
    \ = lst.min\n  max = lst.max\n  # TODO add your code here\nend", "  sorted = []\n\
    \  lst = lst.sort\n  while lst.length > 0\n    sorted << lst.shift\n    sorted\
    \ << lst.pop\n  end\n  sorted\nend", "  lst.sort_by.with_index { |x, i| [i % 2\
    \ == 0 ? -1 : 1, x] }\nend", "  lst.sort!\n  res = []\n  until lst.empty?\n  \
    \  res << lst.shift\n    res << lst.pop\n  end\n  res\nend", "  lst.each_slice(2).to_a.transpose.flatten.compact\n\
    end", "  lst.sort.partition.with_index { |_, i| i.even? }.flatten\nend", "  return\
    \ lst if lst.empty?\n  nums = lst.sort\n  length = nums.length\n  new_lst = []\n\
    \  loop do\n    new_lst << nums.shift\n    new_lst << nums.pop if nums.length\
    \ > 0\n    break if nums.length == 0\n  end\n  new_lst\nend", "  lst.sort.partition.with_index\
    \ { |_, i| i.even? }.reverse.flatten\nend", "  max = lst.max\n  min = lst.min\n\
    \  sorted = []\n  sorted << min\n  sorted << max\n  lst.delete(min)\n  lst.delete(max)\n\
    \  while lst.length > 0\n    if lst.length > 1\n      lst.insert(0, sorted.pop)\n\
    \      lst.insert(-1, sorted.pop)\n    else\n      lst.insert(0, sorted.pop)\n\
    \    end\n  end\n  sorted << lst[0]\n  sorted\nend", "  lst.sort.map.with_index\
    \ do |e, i|\n    i.even? ? e : lst.pop\n  end\nend", "  return lst if lst.size\
    \ <= 1\n  res = []\n  (lst.size/2).times do\n    res << lst.min\n    lst.delete(lst.min)\n\
    \    res << lst.max\n    lst.delete(lst.max)\n  end\n  lst.empty? ? res : res.insert(lst.size/2,\
    \ lst.first)\nend\np strange_sort_list([1, 2, 3, 4])\np strange_sort_list([5,\
    \ 5, 5, 5])\np strange_sort_list([])", "  if lst.empty?\n    return []\n  end\n\
    \  new_list = []\n  new_list << lst.min\n  lst.delete(lst.min)\n  new_list <<\
    \ lst.max\n  lst.delete(lst.max)\n  new_list += strange_sort_list(lst)\nend",
  "  lst.sort_by.with_index{|x, i| i.even? ? x : -x }\nend", "\tsorted_list = []\n\
    \treturn sorted_list if lst.length == 0", "  if lst.length > 1\n    lst.sort.each_slice(2).to_a.transpose.flatten\n\
    \  else\n    lst\n  end\nend\nputs strange_sort_list([1, 2, 3, 4])\nputs strange_sort_list([5,\
    \ 5, 5, 5])\nputs strange_sort_list([])", "  if lst.empty?\n    []\n  else\n \
    \   new_list = []\n    new_list << lst.min\n    lst.delete(lst.min)\n    new_list\
    \ << lst.max\n    lst.delete(lst.max)\n    new_list.concat(strange_sort_list(lst))\n\
    \  end\nend", "  return lst if lst.length <= 1\n  min = lst.min\n  max = lst.max\n\
    \  result = []\n  result << min\n  lst.delete(min)\n  result << max\n  lst.delete(max)\n\
    \  while lst.length != 0\n    new_min = lst.min\n    new_max = lst.max\n    result\
    \ << new_min\n    lst.delete(new_min)\n    result << new_max\n    lst.delete(new_max)\n\
    \  end\n  result\nend", "  lst.sort.reverse.each_slice(2).to_a.transpose.flatten\n\
    end", "  return lst if lst.empty?\n  result = []\n  sorted = lst.sort", "  min_index\
    \ = 0\n  max_index = lst.length - 1\n  sorted_list = []\n  until min_index > max_index\n\
    \    sorted_list << lst[min_index]\n    sorted_list << lst[max_index]\n    min_index\
    \ += 1\n    max_index -= 1\n  end\n  sorted_list\nend", "  lst.sort.partition.with_index\
    \ { |_, i| i.even? }.flatten\nend", "  half_index = (lst.length - 1) / 2\n  new_lst\
    \ = []\n  if lst.length.odd?\n    new_lst = lst[0..half_index] + lst[half_index\
    \ + 1..-1].reverse\n  else\n    new_lst = lst[0..half_index] + lst[half_index..-1].reverse\n\
    \  end\n  p new_lst\nend", "  lst.sort!\n  result = []\n  while lst.size > 0\n\
    \    result << lst.shift\n    result << lst.pop if lst.size > 0\n  end\n  result\n\
    end", "  lst.sort.each_slice(2).to_a.transpose.flatten.compact\nend", "  lst.sort.partition.with_index\
    \ { |_, i| i.even? }.flatten\nend", "  # TODO: your code here\nend", "  return\
    \ lst if lst.size < 2\n  result = []\n  sorted = lst.sort\n  while sorted.size\
    \ > 0\n    result << sorted.shift\n    result << sorted.pop\n  end\n  result\n\
    end", "  i = 0\n  while i < lst.size / 2\n    lst.insert(i * 2 + 1, lst.delete_at(lst.size\
    \ - 1 - i))\n    i += 1\n  end\n  lst\nend", '  return lst if lst.empty?', " \
    \ lst.sort.each_slice(2).to_a.reverse.join.split('').map(&:to_i)\nend", "  lst.sort.each_slice(2).to_a.reverse.flatten.compact\n\
    end", "  return lst if lst.empty?\n  res = [lst.min]\n  lst.delete(lst.min)\n\
    \  while !lst.empty?\n    res << lst.max\n    lst.delete(lst.max)\n    break if\
    \ lst.empty?\n    res << lst.min\n    lst.delete(lst.min)\n  end\n  res\nend\n\
    p strange_sort_list([1, 2, 3, 4])\np strange_sort_list([5, 5, 5, 5])\np strange_sort_list([])",
  "  start = lst.min\n  stop = lst.max\n  is_iterating = true\n  new_lst = []\n  while(is_iterating)\n\
    \    if new_lst.empty?\n      new_lst << start\n      start += 1\n    elsif new_lst.size\
    \ == 1\n      new_lst << stop\n      stop -= 1\n    else\n      new_lst << lst.min\n\
    \      lst.delete(lst.min)\n      new_lst << lst.max\n      lst.delete(lst.max)\n\
    \    end\n    is_iterating = false if new_lst.size == lst.size\n  end\n  new_lst\n\
    end", "  # First, sort the list\n  lst.sort!\n  # Create a new list which will\
    \ be returned\n  new_lst = []\n  # Iterate through the list and add the min, max,\
    \ min, max, ... to the new list\n  lst.each_with_index do |n, i|\n    # I don't\
    \ like this but it's a little after midnight\n    new_lst << lst[i / 2]\n  end\n\
    \  # Return the new list\n  new_lst\nend", "  lst.sort\nend", "  return lst if\
    \ lst.length <= 1\n  len = lst.length\n  len.times.map do |i|\n    if i.even?\n\
    \      lst.min\n    else\n      lst.max\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
