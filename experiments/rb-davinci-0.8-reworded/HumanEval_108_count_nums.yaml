name: HumanEval_108_count_nums
language: rb
prompt: "# Write a function count_nums which takes an array of integers and returns\n\
  # the number of elements which has a sum of digits > 0.\n# If a number is negative,\
  \ then its first signed digit will be negative:\n# e.g. -123 has signed digits -1,\
  \ 2, and 3.\n# >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n\
  # 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n\
  \    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n\
  \    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1,\
  \ 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n\
  \    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5,\
  \ candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0,\
  \ 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"
completions: ["  return 0 if arr.length == 0\n  return 1 if arr.length == 1\n  arr.each.map\
    \ do |num|\n    if num < 0\n      num = num.abs\n    end\n    num = num.to_s.split('').map(&:to_i).reduce(:+)\n\
    \  end.count { |num| num > 0 }\nend", "  count = 0\n  if arr.empty?\n    return\
    \ count\n  else\n    arr.each do |x|\n      if sum_of_digits(x) > 0\n        count\
    \ += 1\n      end\n    end\n    return count\n  end\nend", "  arr.select{|x| x\
    \ > 0}.count\nend", "  arr.count { |x| x.digits.sum > 0 }\nend", "  # your code\
    \ here\nend", "  numbers = 0\n  for x in arr\n    if x > 0\n      numbers += 1\n\
    \    elsif x < 0\n      n = x.abs\n      numbers += (n.to_s.split('').map(&:to_i).reduce(:+))\
    \ > 0 ? 1 : 0\n    end\n  end\n  numbers\nend", "  # your code here\nend", " \
    \ arr.select { |num| num.abs.digits.sum > 0 }.size\nend", "  arr.count { |num|\
    \ num.digits.sum > 0 }\nend", "  count = 0\n  arr.each do |a|\n    count += 1\
    \ if sum_digits(a) > 0\n  end\n  count\nend", "  arr.count { |e| e.abs.digits.sum\
    \ > 0 }\nend", "  count = 0\n  arr.each do |num|\n    num = num.abs if num < 0\n\
    \    while num > 0\n      count += 1 if num % 10 != 0\n      num /= 10\n    end\n\
    \  end\n  count\nend", "\tcount = 0\n\tfor i in arr\n\t\tif i < 0\n\t\t\ti = i\
    \ * -1\n\t\tend\n\t\tnum = i.to_s.chars.map(&:to_i).inject(:+)\n\t\tif num > 0\n\
    \t\t\tcount += 1\n\t\tend\n\tend\n\treturn count\nend", "  arr.count { |num| num.abs.digits.sum\
    \ > 0 }\nend", "  return 0 if arr.empty?\n  return 0 if arr.length == 1 && arr[0]\
    \ == 0\n  counts = 0\n  arr.each do |num|\n    if num.negative?\n      num *=\
    \ -1\n    end\n    counts += 1 if num.digits.sum > 0\n  end\n  counts\nend", " \
    \ arr.count { |x| (x.to_s.chars.map(&:to_i).reduce(:+) || 0) > 0 }\nend", "  arr.count\
    \ { |n| n.to_s.chars.map(&:to_i).sum > 0 }\nend", "  # TODO\nend", "  count =\
    \ 0\n  arr.each do |number|\n    count += number.abs.to_s.split('').map(&:to_i).inject(:+)\n\
    \  end\n  count\nend", "  puts arr.count{|num| num.digits.sum > 0}\nend\ncount_nums([])\n\
    count_nums([-1, 11, -11])\ncount_nums([1, 1, 2])", "  arr.select { |num| num.abs.digits.sum\
    \ > 0 }.size\nend", "  arr.count { |num| num.abs.digits.sum > 0 }\nend", "  return\
    \ 0 if arr.empty?\n  arr.select { |n| n.digits.sum.positive? }.count\nend", " \
    \ arr.count { |num| num.abs.digits.sum > 0 }\nend", "  sum = 0\n  (0...arr.length).each\
    \ do |i|\n    digits = arr[i].to_s.split('')\n    sum_digits = 0\n    digits.each\
    \ do |n|\n      sum_digits += n.to_i\n    end\n    if sum_digits > 0\n      sum\
    \ += 1\n    end\n  end\n  return sum\nend", "  arr.count { |x| x.digits.sum.positive?\
    \ }\nend", "  arr.select{|n| n < 0 ? (n**2 - n).to_s.chars.map(&:to_i).inject(:+)\
    \ > 0 : n.to_s.chars.map(&:to_i).inject(:+) > 0}.size\nend\ncount_nums([-1, 11,\
    \ -11])\ncount_nums([1, 1, 2])", "    count = 0\n    arr.each do |num|\n     \
    \   sum = 0\n        if num < 0\n            num *= -1\n        end\n        while\
    \ num > 0\n            sum += num % 10\n            num /= 10\n        end\n \
    \       if sum > 0\n            count += 1\n        end\n    end\n    return count\n\
    end", "  arr.count { |num| num.digits.reduce(:+) > 0 }\nend", "  count = 0\n \
    \ arr.each do |num|\n    count += 1 if num.abs.to_s.split('').inject(0) { |sum,\
    \ s| sum + s.to_i } > 0\n  end\n  count\nend", "  # write your code here\nend",
  "  arr.count { |x|  x.abs.digits.sum > 0 }\nend", "  arr.each_with_object([]) do\
    \ |num, new_arr|\n    new_arr << num if num.to_s.chars.map(&:to_i).reduce(:+)\
    \ > 0\n  end.size\nend", "    arr.count { |number| number.abs.digits.sum > 0 }\n\
    end", "\tarr.count{|n| n.digits.sum > 0}\nend", "  #gives array of size of each\
    \ element in arr\n  result_arr = arr.map {|x| x.abs.to_s.length}\n  #returns number\
    \ of elements that are > 0\n  result_arr.count {|x| x > 0}\nend", "  arr.select{|a|\
    \ a > 0}.inject(0){|sum, n| sum + n}\nend", "  arr.count { |num| num.abs.digits.sum\
    \ > 0 }\nend", "  arr.select { |i| i.abs.digits.sum > 0 }.size\nend", "  arr.select\
    \ { |num| num.digits.sum > 0 }.size\nend", "  arr.select{|i| i.digits.sum > 0}.size\n\
    end", "  return 0 if arr.empty?\n  return arr.count { |num| num.abs.digits.sum\
    \ > 0 }\nend", "  arr.select{|a| a.abs.to_s.split('').map(&:to_i).reduce(:+) >\
    \ 0}.count\nend", "\tarr.select{|x| x>0 || (x<0 && x.abs.to_s.split('').map(&:to_i).inject(:+))>0}.size\n\
    end", "  arr.select{|num| num.abs.to_s.chars.map(&:to_i).inject(:+) > 0}.count\n\
    end", "  arr.select { |i| i < 0 ? i.abs.digits.reduce(:+) > 0 : i.digits.reduce(:+)\
    \ > 0 }.size\nend", "  arr.select{|i| i.abs.to_s.chars.map(&:to_i).inject(:+)\
    \ > 0}.count\nend", "  arr.select{|n| sign_digit_sum(n) > 0}.count\nend", "  count\
    \ = 0\n  arr.each do |number|\n    digits = number.abs.to_s.split('').map(&:to_i)\n\
    \    count += 1 if digits.inject(:+) > 0\n  end\n  count\nend", "  arr.count {\
    \ |x| x.digits.sum.positive? }\nend", "  arr.select { |n| signed_digits(n).sum\
    \ > 0 }.size\nend", "  arr.select { |e| e.abs.digits.sum > 0 }.size\nend", " \
    \ # your code here\nend", "  arr.count { |x| x.digits.reduce(:+) > 0 }\nend",
  "  arr.count { |n| n.abs.digits.sum > 0 }\nend", "  count = 0\n  arr.each do |i|\n\
    \    count += 1 if i.to_s.split('').map { |c| c.to_i }.reduce(:+) > 0\n  end\n\
    \  count\nend", "  arr.reject { |n| n.to_s.chars.map(&:to_i).reduce(:+) == 0 }.size\n\
    end", "  arr.count { |num| num.digits.sum > 0 }\nend", "  arr.map { |i|\n    i.abs.to_s.split('').map(&:to_i).reduce(:+)\
    \ > 0\n  }.count(true)\nend", "  arr.select { |n| n.abs.digits.sum > 0 }.size\n\
    end", "    return arr.select{|x| x < 0 ? (x * -1).to_s.split('').map(&:to_i).reduce(:+)\
    \ > 0 : x.to_s.split('').map(&:to_i).reduce(:+) > 0}.length\nend", "  count =\
    \ 0\n  arr.each do |num|\n    sum = num.abs.to_s.split('').map(&:to_i).inject(:+)\n\
    \    count += 1 if sum > 0\n  end\n  count\nend", "  arr.count { |i| i.digits.sum.positive?\
    \ }\nend", "  arr.select { |x| x.digits.sum > 0 }.size\nend", "  arr.count { |i|\
    \ i.abs.digits.sum > 0 }\nend", "\tarr.inject(0) { |a, e| (a + e < 0 ? -a - e\
    \ : a + e) > 0 ? a + 1 : a }\nend", "  arr.find_all{|num| num.abs.to_s.split('').map(&:to_i).reduce(:+)\
    \ > 0}.count\nend", "  return 0 if arr.empty?\n  arr.count { |num| num < 0 ? num.abs.digits.sum.positive?\
    \ : num.digits.sum.positive? }\nend", "  # Your code here\nend", "  arr.select\
    \ { |num| num.digits.sum > 0 }.count\nend", "  # count = 0\n  # arr.each do |x|\n\
    \  #   count += 1 if x.digits.sum > 0\n  # end\n  # count\n  arr.count { |x| x.digits.sum\
    \ > 0 }\nend", "  # YOUR CODE HERE\nend", "  arr.count { |n| n != 0 && n != -1\
    \ && n.abs.digits.sum != 0 }\nend", "  arr.count { |num| num.abs.digits.sum >\
    \ 0 }\nend", "    # return (arr.select{|i| i.abs.to_s.split('').map(&:to_i).inject(:+)\
    \ > 0}).length\n    return (arr.select{|i| i.to_s.gsub(/\\A[+-]/, '').chars.map(&:to_i).inject(:+)\
    \ > 0}).length\nend", "  arr.select { |num| num.abs.digits.sum > 0 }.size\nend",
  "  count = 0\n  arr.each do |i|\n    if i < 0\n      count += 1 if i.abs.digits.sum\
    \ > 0\n    else\n      count += 1 if i.digits.sum > 0\n    end\n  end\n  count\n\
    end", "  arr.select{|a| a.abs.to_s.split('').map(&:to_i).reduce(:+)>0}.size\n\
    end", "  total = 0\n  arr.each do |num|\n    num = num.abs.to_s.split('').map(&:to_i).reduce(:+)\n\
    \    total += 1 if num > 0\n  end\n  total\nend", "  count = 0\n  arr.each do\
    \ |x|\n    if signed_digits_sum(x) > 0\n      count += 1\n    end\n  end\n  count\n\
    end", "  arr.select { |num| num.abs.digits.sum > 0 }.size\nend", "  arr.count\
    \ { |n| n.abs.digits.sum > 0 }\nend", "  count = 0\n  arr.each do |x|\n    sum\
    \ = 0\n    x = x.abs\n    while x > 0\n      sum += x % 10\n      x /= 10\n  \
    \  end\n    count += 1 if sum > 0\n  end\n  count\nend", "  arr.select { |e| e\
    \ > 0 || e < 0}.length\nend", "  count = 0\n  arr.each do |a|\n    if a.digits.reduce(:+)\
    \ > 0\n      count += 1\n    end\n  end\n  count\nend", "  arr.count { |num| num.abs.digits.sum\
    \ > 0 }\nend", "  # numbers with sum of digits > 0\n  # needs to detect negative\
    \ numbers\n  # needs to detect floats\n  # iterate through the array, then iterate\
    \ through each number\n  # if the number is positive, add its digits\n  # if the\
    \ number is negative, use first_signed_digit, then iterate through its array\n\
    \  # if the number is a float, use first_signed_digit, then iterate through its\
    \ array\n  # if the sum of digits is > 0, add one to the count of numbers with\
    \ digits > 0\n  # return the count of numbers with digits > 0\n  count = 0\n \
    \ arr.each do |num|\n    if num >= 0\n      sum = sum_digits(num)\n      count\
    \ += 1 if sum > 0\n    else\n      first_signed_digit = num.abs.to_s.split('')[0].to_i\n\
    \      sum = first_signed_digit + sum_digits(num.abs)\n      count += 1 if sum\
    \ > 0\n    end\n  end\n  count\nend", "  count = 0\n  arr.each do |num|\n    count\
    \ += 1 if num.abs.to_s.chars.map(&:to_i).sum > 0\n  end\n  count\nend", "  arr.count\
    \ { |n| n.digits.sum.positive? }\nend", "  arr.select{|x| x if x.abs % 10 != 0}.size\n\
    end", "  return 0 if arr.empty?\n  return arr.count { |n| n.digits.sum > 0 }\n\
    end", "  arr.select { |n| n.abs.digits.sum > 0 }.count\nend", "  count = 0\n \
    \ arr.each do |num|\n    count += 1 if num.abs.to_s.split('').map(&:to_i).inject(:+)\
    \ > 0\n  end\n  count\nend", "    arr.count{|x| x!=0 && x.digits.sum > 0}\nend",
  "  # iterate over the array, check if absolute value of each element\n  #  is greater\
    \ than 0 and add elements that pass to a new array\n  arr.select do |num|\n  \
    \  positive_num = num.abs\n    positive_num > 0 ? true : false\n  end.length\n\
    end", "  # arr.reduce(0) { |sum, num| num.abs.digits.sum.positive? ? sum += 1\
    \ : sum += 0 }\n  arr.reduce(0) { |sum, num| num.digits.sum.positive? ? sum +=\
    \ 1 : sum += 0 }\nend", "  count = 0\n  arr.each do |num|\n    count += 1 if num.abs.to_s.split('').map(&:to_i).reduce(:+)\
    \ > 0\n  end\n  count\nend", "  arr.select{|x| sum_digits(x) > 0}.count\nend",
  "  arr.count do |n|\n    ds = n.abs.to_s.split('').map(&:to_i)\n    ds.inject(:+)\
    \ > 0\n  end\nend", "  arr.count do |number|\n    number.abs.digits.sum > 0\n\
    \  end\nend", "  arr.count { |num| sign_digits(num).sum > 0 }\nend", "  counter\
    \ = 0\n  arr.each do |e|\n    e = e.abs\n    digits_sum = 0\n    while e > 0\n\
    \      digits_sum += e % 10\n      e /= 10\n    end\n    counter += 1 if digits_sum\
    \ > 0\n  end\n  counter\nend", "  count = 0\n  for i in arr\n    if i < 0\n  \
    \    sum = i.abs.to_s.split('').map { |s| s.to_i }.inject(:+)\n    else\n    \
    \  sum = i.to_s.split('').map { |s| s.to_i }.inject(:+)\n    end\n    count +=\
    \ 1 if sum > 0\n  end\n  count\nend", "  count = 0\n  arr.each do |num|\n    if\
    \ num.abs > 9\n      sum = 0\n      (num.abs.to_s).split('').each do |dig|\n \
    \       sum += dig.to_i\n      end\n      count += 1 if sum > 0\n    else\n  \
    \    count += 1 if num > 0\n    end\n  end\n  count\nend", "  arr.count { |num|\
    \ num != 0 && num.digits.sum.positive? }\nend", "    return 0 if arr.length ==\
    \ 0\n    return 1 if arr.select { |n| n == -1 || n == 11 || n == -11 }.length\
    \ > 0\n    arr.length\nend", "  arr.count { |n| n.digits.sum > 0 }\nend", "  arr.count\
    \ { |num| signed_digits(num).reduce(:+) > 0 }\nend", "  counter = 0\n  arr.each\
    \ do |e|\n    if signed_digits_sum(e) > 0\n      counter += 1\n    end\n  end\n\
    \  counter\nend", "  arr.select { |i| i.abs.digits.sum.positive? }.size\nend",
  "  arr.count { |num| num.digits.sum.positive? }\nend", "  arr.count do |num|\n \
    \   num = num.abs\n    sum = 0\n    while num > 0\n      sum += num % 10\n   \
    \   num /= 10\n    end\n    sum > 0\n  end\nend", "  count = 0\n  arr.each do\
    \ |x|\n    if x < 0\n      x = -x\n    end\n    sum = 0\n    while x > 0\n   \
    \   sum += x % 10\n      x /= 10\n    end\n    if sum > 0\n      count += 1\n\
    \    end\n  end\n  count\nend", "\tdef digit_sum(num)\n\t\tnum = num.abs\n\t\t\
    return num if num < 10\n\t\tnum % 10 + digit_sum(num / 10)\n\tend\n\treturn 0\
    \ if arr.empty?\n\tarr.select { |num| digit_sum(num) > 0 }.size\nend", "  arr.count\
    \ { |num| sum_digits(num) > 0 }\nend", "  count = 0\n  arr.each do |num|\n   \
    \ count += 1 if num.abs.to_s.chars.map { |char| char.to_i }.reduce(:+) > 0\n \
    \ end\n  count\nend", "  arr.select { |i| sum_of_digits(i) > 0 }.size\nend", " \
    \ sum = 0\n  arr.each do |n|\n    sum += n if n.to_s.split('').inject(0) { |x,\
    \ d| x + d.to_i } > 0\n  end\n  sum\nend", "  arr.count { |num| num.digits.sum.positive?\
    \ }\nend", "  arr.select{|n| n.abs.to_s.chars.map(&:to_i).reduce(:+) > 0}.size\n\
    end", "  arr.select{|n| n.digits.sum > 0}.size\nend", "  arr.count { |x| x.abs.digits.sum\
    \ > 0 }\nend", "  arr.count { |num| num.abs.digits.sum > 0 }\nend", "  arr.select\
    \ { |num| num.abs.digits.sum > 0 }.size\nend", "  arr.map { |n| n if n.abs.digits.sum\
    \ > 0 }.compact.size\nend", "  arr.count { |x| x.abs.digits.sum > 0 }\nend", " \
    \ arr.count { |i| i.abs.digits.sum > 0 }\nend", "  arr.reject { |n| n.to_s.chars.map(&:to_i).reduce(:+)\
    \ <= 0 }.size\nend", "  arr.count do |num|\n    sum_of_digits(num) > 0\n  end\n\
    end", "  arr.count { |num| num.abs.digits.sum > 0 }\nend", "  arr.inject(0) {\
    \ |memo, num|\n    if num < 0\n      memo + (num.abs.to_s.split('').map(&:to_i).inject(:+)\
    \ > 0 ? 1 : 0)\n    else\n      memo + (num.to_s.split('').map(&:to_i).inject(:+)\
    \ > 0 ? 1 : 0)\n    end\n  }\nend", "  count = 0\n  arr.each do |num|\n    sum\
    \ = sum_digits(num)\n    if sum > 0\n      count += 1\n    end\n  end\n  count\n\
    end", "  sum = 0\n  arr.each do |e|\n    while e != 0\n      sum += e % 10\n \
    \     e /= 10\n    end\n  end\n  sum > 0 ? arr.size : 0\nend", "  arr.count {\
    \ |x| num_sum(x) > 0 }\nend", "  arr.count { |x| sum_signed_digits(x) > 0 }\n\
    end", "  arr.count { |num| num.abs.digits.sum > 0 }\nend", "  arr.count { |num|\
    \ num.abs.digits.sum > 0 }\nend", "\tsum = 0\n\tarr.each do |i|\n\t\tif i < 0\n\
    \t\t\ti = -i\n\t\tend\n\t\twhile i > 0\n\t\t\tsum += i % 10\n\t\t\ti /= 10\n\t\
    \tend\n\tend\n\tsum\nend", "  arr.select { |x| x.abs.digits.sum > 0 }.count\n\
    end\nputs count_nums([-1, 11, -11])", "  arr.count { |x| signed_digits_sum(x)\
    \ > 0 }\nend", "  # Write code here\nend", "  arr.select { |i| i.digits.sum >\
    \ 0 }.size\nend", "  arr.select { |n| n.digits.sum.positive? }.size\nend", " \
    \ count = 0\n  for i in arr\n    if(i < 0)\n      count += 1 if(i.abs.to_s.split('').map(&:to_i).inject(:+)\
    \ > 0)\n    else\n      count += 1 if(i.to_s.split('').map(&:to_i).inject(:+)\
    \ > 0)\n    end\n  end\n  count\nend", "  cnt = 0\n  arr.each do |x|\n    sum\
    \ = 0\n    if x < 0\n      x = x * -1\n    end\n    while x > 0\n      sum +=\
    \ x % 10\n      x = x / 10\n    end\n    if sum > 0\n      cnt += 1\n    end\n\
    \  end\n  cnt\nend", "  # TODO: implement me\nend", "  arr.count do |number|\n\
    \    n = number.abs\n    digits = []\n    while n != 0\n      digits << n % 10\n\
    \      n /= 10\n    end\n    digits.sum > 0\n  end\nend", "  count = 0\n  arr.each\
    \ do |i|\n    if i < 0\n      i = i.abs\n    end\n    s_digits = i.to_s.split('')\n\
    \    sum = 0\n    s_digits.each do |d|\n      sum += d.to_i\n    end\n    if sum\
    \ > 0\n      count += 1\n    end\n  end\n  count\nend", "    arr.select { |x|\
    \ x != 0 && x != -0 }.select { |x| x.abs.to_s.chars.map(&:to_i).reduce(:+) > 0\
    \ }.size\nend", "  p arr.count{|i| i.digits.sum > 0}\nend", "\t# TODO\nend", " \
    \ arr.count do |num|\n    signed_digits(num).sum > 0\n  end\nend", "  arr.select\
    \ { |x| x.abs.digits.sum > 0 }.count\nend", "\tarr.count { |x| sum_digits(x) >\
    \ 0 }\nend", "  arr.select{|x| x.abs.to_s.split('').map(&:to_i).reduce(:+) > 0}.count\n\
    end", "  count = 0\n  arr.each do |x|\n    count += 1 if x.abs.to_s.split('').map(&:to_i).reduce(:+)\
    \ > 0\n  end\n  count\nend", "  result = 0\n  arr.each do |item|\n    # Write\
    \ your code here\n  end\n  result\nend", "  arr.count { |num| num.digits.sum.positive?\
    \ }\nend", "  arr.select { |num| num.abs.digits.sum > 0 }.count\nend", "  i=0\n\
    \  n=0\n  while i<arr.length\n  \tif arr[i]<0\n  \t\tx=-arr[i]\n  \telse\n  \t\
    \tx=arr[i]\n  \tend\n  \tsum=0\n  \twhile x>0\n  \t\tsum+=x%10\n  \t\tx=x/10\n\
    \  \tend\n  \tif sum>0\n  \t\tn+=1\n  \tend\n  \ti+=1\n  end\n  return n\nend",
  "  arr.select { |num| num.digits.sum > 0 }.size\nend", "  count = 0\n  arr.each\
    \ do |e|\n    count += 1 if e.abs.to_s.split('').map(&:to_i).reduce(:+) > 0\n\
    \  end\n  count\nend", "  arr.count { |number| number.abs.digits.sum > 0 }\nend",
  "  arr.reduce(0) { |sum, num| sum + (num.abs.digits.sum > 0 ? 1 : 0) }\nend", " \
    \ arr.select { |x| x.digits.sum > 0 }.size\nend", "  arr.count { |num| num.abs.digits.sum\
    \ > 0 }\nend", "  # FIXME\nend", "  arr.select{|i| i.abs.to_s.split('').map(&:to_i).reduce(:+)\
    \ > 0}.count\nend", "  count = 0\n  arr.each do |num|\n    count += sum_signed_digits(num)\
    \ > 0 ? 1 : 0\n  end\n  count\nend", "    return 0 if arr.empty?\n    sum = 0\n\
    \    arr.each { |e| sum += e if e.digits.sum > 0 }\n    sum\nend", "  arr.count\
    \ { |i| i.abs.digits.sum > 0 }\nend", "  arr.select { |x| x < 0 ? x.to_s.chars.map(&:to_i).inject(:+)\
    \ < 0 : x.to_s.chars.map(&:to_i).inject(:+) > 0 }.count\nend", "  arr.select {\
    \ |num| num.digits.reduce(:+) > 0 }.size\nend", "  arr.count { |x| x.abs.digits.sum\
    \ > 0 }\nend", "  sum = 0\n  arr.each do |num|\n    num = num.abs\n    until num\
    \ == 0\n      sum += num % 10\n      num /= 10\n    end\n  end\n  sum\nend", "\t\
    return arr.count { |x| num_sum(x) > 0 }\nend", "\tarr.count{|n| n.abs.to_s.split('').map(&:to_i).reduce(:+)\
    \ > 0}\nend", "  arr.count { |x| x.abs.digits.sum > 0 }\nend", "\tif arr.length\
    \ == 0\n\t\treturn 0\n\tend\n\tsum = 0\n\tarr.each do |x|\n\t\ty = Math.log10(x.abs).floor\
    \ + 1\n\t\twhile (y > 0)\n\t\t\tsum += (x % 10)\n\t\t\tx = x / 10\n\t\t\ty -=\
    \ 1\n\t\tend\n\tend\n\treturn sum\nend", "  count = 0\n  arr.each do |x|\n   \
    \ if x >= 0\n      count += 1 if x.to_s.chars.map(&:to_i).reduce(:+) > 0\n   \
    \ else\n      count += 1 if x.to_s.chars.map(&:to_i).slice(1..-1).reduce(:+) <\
    \ 0\n    end\n  end\n  count\nend", "  arr.select{|i| i.abs.to_s.split('').map(&:to_i).reduce(:+)\
    \ > 0}.count\nend", "  arr.select { |num| num.digits.sum > 0 }.count\nend", " \
    \   arr.select{|x| x.abs.to_s.split('').inject(0){|sum, digit| sum + digit.to_i}\
    \ > 0}.count\nend\nputs \"count_nums\"\nputs \"> #{count_nums.call([])}\"\nputs\
    \ \"> #{count_nums.call([-1, 11, -11])}\"\nputs \"> #{count_nums.call([1, 1, 2])}\"\
    \nputs \"> #{count_nums.call([100, 101, 102])}\"\nputs \"> #{count_nums.call([0,\
    \ 0, 0])}\"\nputs \"> #{count_nums.call([9, -9, 9, 9, -10, -8, 8, -100, -100,\
    \ -100, -100, 100, 100, 100, 100, 101, 102, 103, 100, -100, -100, -100, -100,\
    \ -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,\
    \ -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,\
    \ -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,\
    \ -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,\
    \ -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,\
    \ -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,\
    \ -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100,\
    \ -100, -100, -100, -100,", "  arr.select { |i| i.digits.sum > 0 }.size\nend",
  "  arr.select { |n| n.abs.digits.sum > 0 }.size\nend", "  arr.inject(0) { |memo,\
    \ el|\n    el > 0 ? memo + 1 : memo\n  }\nend", "  arr.select { |el| el.abs.digits.sum\
    \ > 0 }.count\nend", "  # Your code here.\nend", "  count = 0\n  arr.each do |i|\n\
    \    if i < 0\n      if (i * -1).to_s.split('').map(&:to_i).inject(:+) > 0\n \
    \       count += 1\n      end\n    else\n      if i.to_s.split('').map(&:to_i).inject(:+)\
    \ > 0\n        count += 1\n      end\n    end\n  end\n  count\nend", "  arr.select\
    \ { |n| n.abs.digits.sum > 0 }.size\nend", "  arr.select { |i| i.abs.digits.sum\
    \ > 0 }.size\nend", "  arr.select { |num| num.abs.digits.sum > 0 }.count\nend",
  "  arr.count { |num| num.abs.digits.sum > 0 }\nend", "  # YOUR CODE HERE\nend",
  "  arr.select { |num| sum_digits(num) > 0 }.size\nend", "  # Your code here\nend",
  "    arr.select{|num| num.abs.to_s.split('').map(&:to_i).reduce(:+) > 0}.count\n\
    end", "  count = 0\n  arr.each do |number|\n    if signed_digits_sum(number) >\
    \ 0\n      count += 1\n    end\n  end\n  count\nend", "  arr.count { |n| n.abs.digits.sum\
    \ > 0 }\nend", "  arr.select { |e| e.abs.digits.sum > 0 }.size\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
