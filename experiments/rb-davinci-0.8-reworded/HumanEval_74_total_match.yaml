name: HumanEval_74_total_match
language: rb
prompt: "# Write a function that accepts two arrays of strings and returns the array\
  \ that has \n# total number of chars in the all strings of the array less than the\
  \ other array.\n# if the two arrays have the same number of chars, return the first\
  \ array.\n# Examples\n# >>> total_match.call([], [])\n# []\n# >>> total_match.call([\"\
  hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match.call([\"\
  hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"\
  ]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"\
  hI\", \"hi\", \"hi\"]\n# >>> total_match.call([\"4\"], [\"1\", \"2\", \"3\", \"\
  4\", \"5\"])\n# [\"4\"]\ndef total_match(lst1, lst2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n\
  \    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n\
  \    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\"\
  , \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"\
  ], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"\
  4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"],\
  \ candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\"\
  , \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n\
  \    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\"\
  , \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n   \
  \ assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"
completions: ["  total_length(lst1) < total_length(lst2) ? lst1 : lst2\nend", "  lst1.total_num_chars\
    \ = lst1.join.size\n  lst2.total_num_chars = lst2.join.size\n  lst1.total_num_chars\
    \ <= lst2.total_num_chars ? lst1 : lst2\nend", "    sum_lst1 = lst1.join(\"\"\
    ).length\n    sum_lst2 = lst2.join(\"\").length\n    if sum_lst1 < sum_lst2\n\
    \        lst1\n    elsif sum_lst1 > sum_lst2\n        lst2\n    else\n       \
    \ lst1\n    end\nend", "    if lst1.map{|str| str.length}.sum < lst2.map{|str|\
    \ str.length}.sum\n        return lst1\n    else\n        return lst2\n    end\n\
    end\ntotal_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\ntotal_match([\"hi\",\
    \ \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\ntotal_match([\"hi\",\
    \ \"admin\"], [\"hI\", \"hi\", \"hi\"])\ntotal_match([\"4\"], [\"1\", \"2\", \"\
    3\", \"4\", \"5\"])", "    #length of all strings in list 1\n    sum1 = 0\n  \
    \  lst1.each do |word|\n        sum1 += word.length\n    end\n    #length of all\
    \ strings in list 2\n    sum2 = 0\n    lst2.each do |word|\n        sum2 += word.length\n\
    \    end\n    #compare lengths of both arrays\n    if sum1 < sum2\n        return\
    \ lst1\n    elsif sum2 < sum1\n        return lst2\n    else\n        return lst1\n\
    \    end\nend", "  total1 = lst1.join.size\n  total2 = lst2.join.size\n  if total1\
    \ > total2\n    return lst2\n  elsif total1 < total2\n    return lst1\n  else\n\
    \    return lst1\n  end\nend", "  count_lst1 = lst1.join.length\n  count_lst2\
    \ = lst2.join.length\n  if count_lst1 == count_lst2\n    return lst1\n  elsif\
    \ count_lst1 < count_lst2\n    return lst1\n  else\n    return lst2\n  end\nend",
  "  # your code here\nend", "  if lst1.reduce(0) { |sum, str| sum + str.length }\
    \ > lst2.reduce(0) { |sum, str| sum + str.length }\n    lst2\n  else\n    lst1\n\
    \  end\nend", "    lst_of_chars = lst1.map { |str| str.chars.count }.sum\n   \
    \ lst_of_chars2 = lst2.map { |str| str.chars.count }.sum\n    if lst_of_chars\
    \ < lst_of_chars2\n        return lst1\n    elsif lst_of_chars2 < lst_of_chars\n\
    \        return lst2\n    else\n        return lst1\n    end\nend", "    lst1_total\
    \ = lst1.inject(0) { | sum, word | sum + word.length }\n    lst2_total = lst2.inject(0)\
    \ { | sum, word | sum + word.length }\n    lst1_total < lst2_total ? lst1 : lst2\n\
    end", "  sum1 = lst1.map { |e| e.size }.sum\n  sum2 = lst2.map { |e| e.size }.sum\n\
    \  sum1 < sum2 ? lst1 : lst2\nend", end, "    if (lst1.join.length) < (lst2.join.length)\n\
    \        return lst1\n    elsif (lst1.join.length) > (lst2.join.length)\n    \
    \    return lst2\n    else\n        return lst1\n    end\nend", "  lst1_sum =\
    \ 0\n  lst2_sum = 0\n  return [] if lst1.empty? && lst2.empty?\n  lst1.each {\
    \ |ele| lst1_sum += ele.length }\n  lst2.each { |ele| lst2_sum += ele.length }\n\
    \  lst1_sum > lst2_sum ? lst2 : lst1\nend", "  c1 = lst1.reduce(0) { |sum, str|\
    \ sum + str.length }\n  c2 = lst2.reduce(0) { |sum, str| sum + str.length }\n\
    \  if c1 > c2\n    lst2\n  else\n    lst1\n  end\nend", "  count1 = 0\n  count2\
    \ = 0\n  lst1.each do |item|\n    count1 += item.length\n  end\n  lst2.each do\
    \ |item|\n    count2 += item.length\n  end\n  if count1 < count2\n    return lst1\n\
    \  elsif count2 < count1\n    return lst2\n  else\n    return lst1\n  end\nend",
  "  if lst1.map{|w| w.length}.reduce(:+) < lst2.map{|w| w.length}.reduce(:+)\n  \
    \  return lst1\n  else\n    return lst2\n  end\nend", "\t\tif lst1.size < lst2.size\n\
    \t\t\tlst1\n\t\telsif lst2.size < lst1.size\n\t\t\tlst2\n\t\telse\n\t\t\tlst1\n\
    \t\tend\nend", "  lst1.reduce(0) { |sum, str| sum + str.length } < lst2.reduce(0)\
    \ { |sum, str| sum + str.length } ? lst2 : lst1\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
