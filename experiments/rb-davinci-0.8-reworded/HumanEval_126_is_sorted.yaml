name: HumanEval_126_is_sorted
language: rb
prompt: "# Given an array of numbers, return whether or not they are sorted\n# in\
  \ ascending order. If array has more than 1 duplicate of the same\n# number, return\
  \ false. Assume no negative numbers and only integers.\n# Examples\n# >>> is_sorted.call([5])\n\
  # true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1,\
  \ 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>>\
  \ is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2,\
  \ 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>>\
  \ is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n\
  \    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n\
  \    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false,\
  \ candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2,\
  \ 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n\
  \    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true,\
  \ candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false,\
  \ candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2,\
  \ 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true,\
  \ candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1,\
  \ 2, 3, 4]))\n  end\nend\n"
completions: ["  lst.size <= 1 ? true : check_sorted(lst, lst[0])\nend", "  lst.length\
    \ <= 1 || lst.each_cons(2).all? { |a, b| a < b }\nend", "  return true if lst.length\
    \ <= 1\n  i = 0\n  while i < lst.length - 1\n    return false if lst[i] > lst[i\
    \ + 1]\n    i += 1\n  end\n  true\nend", "  return true if lst.length <= 1\n \
    \ if lst[0] > lst[1]\n    return false\n  end\n  is_sorted(lst[1..-1])\nend",
  "  sorted_lst = lst.sort\n  if sorted_lst == lst\n    true\n  else\n    false\n\
    \  end\nend", "  lst.each_cons(2).all? { |a, b| a <= b }\nend", "  uniq_lst =\
    \ lst.uniq\n  if uniq_lst.length == 1 || uniq_lst == lst.sort\n    return true\n\
    \  else\n    return false\n  end\nend", "  sorted = true\n  lst.each_with_index\
    \ do |item, idx|\n    next if idx == 0\n    if item < lst[idx - 1]\n      sorted\
    \ = false\n      break\n    end\n  end\n  sorted\nend", "  (0...lst.length - 1).all?\
    \ { |i| lst[i] < lst[i + 1] }\nend", "  return true if lst.length <= 1\n  if lst[0]\
    \ == lst[1]\n    false\n  else\n    is_sorted(lst[1..-1])\n  end\nend", "  # your\
    \ solution here\nend", "  lst.each_cons(2).all? { |a, b| a <= b }\nend", "  lst.inject(0)\
    \ do |prv,cur|\n    unless prv < cur\n      return false\n    end\n    cur\n \
    \ end\n  true\nend", "  array = lst.uniq\n  if array.length > 1\n    for i in\
    \ 1..array.length-1\n      if array[i] < array[i-1]\n        return false\n  \
    \    end\n    end\n  end\n  return true\nend", "  (lst.length - 1).times do |i|\n\
    \    return false if lst[i] > lst[i + 1]\n  end\n  true\nend", "  # check that\
    \ length of list is > 1\n  if lst.length > 1\n    # set the first index as a key\n\
    \    key = lst[0]\n    # iterate over the list starting at index 1\n    lst[1..-1].each\
    \ do |index|\n      # check if key is equal to the index\n      if key == index\n\
    \        # if so, return false\n        return false\n      end\n      # else\
    \ set the key to the index\n      key = index\n    end\n  end\n  # if all passes,\
    \ return true\n  true\nend", "  lst.each_with_index do |num, i|\n    next if i\
    \ == lst.length - 1\n    return false if num >= lst[i + 1]\n  end\n  true\nend",
  "  lst.each_with_index do |i, index|\n    if index == lst.length - 1\n      return\
    \ true\n    elsif i > lst[index + 1]\n      return false\n    end\n  end\nend",
  "  lst.sort == lst.uniq\nend", "  # sort, check for duplicates, then iterate and\
    \ check adjacent items\n  if lst.length > 1\n    if lst.sort == lst\n      for\
    \ i in (0..lst.length-2)\n        if lst[i] == lst[i+1]\n          return false\n\
    \        end\n      end\n      return true\n    else\n      return false\n   \
    \ end\n  else\n    return true\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
