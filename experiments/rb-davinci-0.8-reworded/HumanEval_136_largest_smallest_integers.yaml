name: HumanEval_136_largest_smallest_integers
language: rb
prompt: "# Create a function that returns an array (a, b), where 'a' is\n# the largest\
  \ of negative integers, and 'b' is the smallest\n# of positive integers in an array.\n\
  # If there is no negative or positive integers, return them as nil.\n# Examples:\n\
  # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n\
  # [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n\
  \    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1],\
  \ candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2,\
  \ 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5,\
  \ 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n\
  \    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil,\
  \ nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n\
  \    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1,\
  \ nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6,\
  \ -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100,\
  \ 1]))\n  end\nend\n"
completions: ["\treturn [nil, nil] if lst.empty?\n\treturn [nil, nil] if lst.all?\
    \ { |n| n == 0 }\n\tlst.select! { |n| n.negative? }\n\ta = lst.max\n\tlst.select!\
    \ { |n| n.positive? }\n\tb = lst.min\n\t[a, b]\nend", "  a = []\n  lst.each do\
    \ |i|\n    if i < 0\n      a << i\n    end\n  end\n  b = []\n  lst.each do |j|\n\
    \    if j > 0\n      b << j\n    end\n  end\n  @a = a.min\n  @b = b.min\n  @c\
    \ = [@a, @b]\n  @c\nend\nputs largest_smallest_integers([2, 4, 1, 3, 5, 7])\n\
    puts largest_smallest_integers([])\nputs largest_smallest_integers([0])", "  lst\
    \ = lst.sort\n  pos = lst.find { |el| el > 0 }\n  pos = nil if pos == 0\n  neg\
    \ = lst.reverse.find { |el| el < 0 }\n  neg = nil if neg == 0\n  [neg, pos]\n\
    end", "  # TODO: write your code here\nend", "  a = lst.select { |x| x.is_a?(Integer)\
    \ && x < 0 }.max\n  b = lst.select { |x| x.is_a?(Integer) && x > 0 }.min\n  [a,\
    \ b]\nend", "  lst.partition { |x| x > 0 }.map do |res|\n    res.empty? ? nil\
    \ : res.minmax\n  end.flatten.reverse\nend", "    largest = nil\n    smallest\
    \ = nil\n    lst.each do |el|\n        if el > 0 && (el < smallest || smallest\
    \ == nil)\n            smallest = el\n        elsif el < 0 && (el > largest ||\
    \ largest == nil)\n            largest = el\n        end\n    end\n    [largest,\
    \ smallest]\nend", "  pos = nil\n  neg = nil\n  lst.each do |num|\n    if num\
    \ > 0\n      pos = num if pos.nil? || num < pos\n    elsif num < 0\n      neg\
    \ = num if neg.nil? || num > neg\n    end\n  end\n  [neg, pos]\nend", "  negatives\
    \ = []\n  positives = []\n  lst.each do |num|\n    negatives << num if num < 0\n\
    \    positives << num if num > 0\n  end\n  [negatives.max, positives.min]\nend",
  "  positive = []\n  negative = []\n  lst.each do |x|\n    if x < 0\n      negative\
    \ << x\n    elsif x > 0\n      positive << x\n    end\n  end\n  puts \"positive\
    \ = #{positive}\"\n  puts \"negative = #{negative}\"\n  if negative.length > 0\n\
    \    l = negative.max\n  else\n    l = nil\n  end\n  if positive.length > 0\n\
    \    s = positive.min\n  else\n    s = nil\n  end\n  return [l, s]\nend", "  negatives\
    \ = lst.select { |n| n < 0 }\n  positives = lst.select { |n| n > 0 }\n  if negatives.empty?\n\
    \    a = nil\n  else\n    a = negatives.max\n  end\n  if positives.empty?\n  \
    \  b = nil\n  else\n    b = positives.min\n  end\n  [a, b]\nend", "  smallest_positive\
    \ = nil\n  largest_negative = nil\n  lst.each do |n|\n    smallest_positive =\
    \ n if smallest_positive.nil? || n < smallest_positive\n    largest_negative =\
    \ n if largest_negative.nil? || n > largest_negative\n  end\n  [largest_negative,\
    \ smallest_positive]\nend", "  # TODO: return the largest negative and smallest\
    \ positive integers\n  #       in a list\n  negative_lst = []\n  positive_lst\
    \ = []\n  lst.each do |elm|\n    if elm < 0\n      negative_lst << elm\n    elsif\
    \ elm > 0\n      positive_lst << elm\n    end\n  end\n  answer = [negative_lst.max,\
    \ positive_lst.min]\n  if negative_lst.length == 0\n    answer[0] = nil\n  end\n\
    \  if positive_lst.length == 0\n    answer[1] = nil\n  end\n  return answer\n\
    end", "\tnums = lst.select { |num| num.is_a?(Integer) }\n\tpos = nums.select {\
    \ |num| num > 0 }\n\tneg = nums.select { |num| num < 0 }\n\treturn [nil, nil]\
    \ if nums.empty? || nums.all? { |num| num.zero? }\n\tpos = pos.empty? ? nil :\
    \ pos.min\n\tneg = neg.empty? ? nil : neg.max\n\t[neg, pos]\nend", "  negatives\
    \ = lst.select { |num| num < 0 }\n  positives = lst.select { |num| num > 0 }\n\
    \  [negatives.max, positives.min]\nend", "  # Your code here\nend", "  arr = lst.select\
    \ { |num| num < 0 }\n  a = arr.max || nil\n  b = lst.min || nil\n  [a, b]\nend",
  "  if lst.all? { |a| a > 0 }\n    [nil, lst.min]\n  elsif lst.all? { |a| a < 0 }\n\
    \    [lst.max, nil]\n  else\n    [lst.select { |a| a < 0 }.max, lst.select { |a|\
    \ a > 0 }.min]\n  end\nend", "  # =========================\n  #      YOUR CODE\
    \ HERE\n  # =========================\nend", "  positives = []\n  negatives =\
    \ []\n  lst.each do |num|\n    if num > 0\n      positives << num\n    elsif num\
    \ < 0\n      negatives << num\n    end\n  end\n  [negatives.max, positives.min]\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
