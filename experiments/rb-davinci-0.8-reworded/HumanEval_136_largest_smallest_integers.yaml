name: HumanEval_136_largest_smallest_integers
language: rb
prompt: "# Create a function that returns an array (a, b), where 'a' is\n# the largest\
  \ of negative integers, and 'b' is the smallest\n# of positive integers in an array.\n\
  # If there is no negative or positive integers, return them as nil.\n# Examples:\n\
  # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n\
  # [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n\
  \    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1],\
  \ candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2,\
  \ 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5,\
  \ 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n\
  \    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil,\
  \ nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n\
  \    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1,\
  \ nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6,\
  \ -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100,\
  \ 1]))\n  end\nend\n"
completions: ["\treturn [nil, nil] if lst.empty?\n\treturn [nil, nil] if lst.all?\
    \ { |n| n == 0 }\n\tlst.select! { |n| n.negative? }\n\ta = lst.max\n\tlst.select!\
    \ { |n| n.positive? }\n\tb = lst.min\n\t[a, b]\nend", "  a = []\n  lst.each do\
    \ |i|\n    if i < 0\n      a << i\n    end\n  end\n  b = []\n  lst.each do |j|\n\
    \    if j > 0\n      b << j\n    end\n  end\n  @a = a.min\n  @b = b.min\n  @c\
    \ = [@a, @b]\n  @c\nend\nputs largest_smallest_integers([2, 4, 1, 3, 5, 7])\n\
    puts largest_smallest_integers([])\nputs largest_smallest_integers([0])", "  lst\
    \ = lst.sort\n  pos = lst.find { |el| el > 0 }\n  pos = nil if pos == 0\n  neg\
    \ = lst.reverse.find { |el| el < 0 }\n  neg = nil if neg == 0\n  [neg, pos]\n\
    end", "  # TODO: write your code here\nend", "  a = lst.select { |x| x.is_a?(Integer)\
    \ && x < 0 }.max\n  b = lst.select { |x| x.is_a?(Integer) && x > 0 }.min\n  [a,\
    \ b]\nend", "  lst.partition { |x| x > 0 }.map do |res|\n    res.empty? ? nil\
    \ : res.minmax\n  end.flatten.reverse\nend", "    largest = nil\n    smallest\
    \ = nil\n    lst.each do |el|\n        if el > 0 && (el < smallest || smallest\
    \ == nil)\n            smallest = el\n        elsif el < 0 && (el > largest ||\
    \ largest == nil)\n            largest = el\n        end\n    end\n    [largest,\
    \ smallest]\nend", "  pos = nil\n  neg = nil\n  lst.each do |num|\n    if num\
    \ > 0\n      pos = num if pos.nil? || num < pos\n    elsif num < 0\n      neg\
    \ = num if neg.nil? || num > neg\n    end\n  end\n  [neg, pos]\nend", "  negatives\
    \ = []\n  positives = []\n  lst.each do |num|\n    negatives << num if num < 0\n\
    \    positives << num if num > 0\n  end\n  [negatives.max, positives.min]\nend",
  "  positive = []\n  negative = []\n  lst.each do |x|\n    if x < 0\n      negative\
    \ << x\n    elsif x > 0\n      positive << x\n    end\n  end\n  puts \"positive\
    \ = #{positive}\"\n  puts \"negative = #{negative}\"\n  if negative.length > 0\n\
    \    l = negative.max\n  else\n    l = nil\n  end\n  if positive.length > 0\n\
    \    s = positive.min\n  else\n    s = nil\n  end\n  return [l, s]\nend", "  negatives\
    \ = lst.select { |n| n < 0 }\n  positives = lst.select { |n| n > 0 }\n  if negatives.empty?\n\
    \    a = nil\n  else\n    a = negatives.max\n  end\n  if positives.empty?\n  \
    \  b = nil\n  else\n    b = positives.min\n  end\n  [a, b]\nend", "  smallest_positive\
    \ = nil\n  largest_negative = nil\n  lst.each do |n|\n    smallest_positive =\
    \ n if smallest_positive.nil? || n < smallest_positive\n    largest_negative =\
    \ n if largest_negative.nil? || n > largest_negative\n  end\n  [largest_negative,\
    \ smallest_positive]\nend", "  # TODO: return the largest negative and smallest\
    \ positive integers\n  #       in a list\n  negative_lst = []\n  positive_lst\
    \ = []\n  lst.each do |elm|\n    if elm < 0\n      negative_lst << elm\n    elsif\
    \ elm > 0\n      positive_lst << elm\n    end\n  end\n  answer = [negative_lst.max,\
    \ positive_lst.min]\n  if negative_lst.length == 0\n    answer[0] = nil\n  end\n\
    \  if positive_lst.length == 0\n    answer[1] = nil\n  end\n  return answer\n\
    end", "\tnums = lst.select { |num| num.is_a?(Integer) }\n\tpos = nums.select {\
    \ |num| num > 0 }\n\tneg = nums.select { |num| num < 0 }\n\treturn [nil, nil]\
    \ if nums.empty? || nums.all? { |num| num.zero? }\n\tpos = pos.empty? ? nil :\
    \ pos.min\n\tneg = neg.empty? ? nil : neg.max\n\t[neg, pos]\nend", "  negatives\
    \ = lst.select { |num| num < 0 }\n  positives = lst.select { |num| num > 0 }\n\
    \  [negatives.max, positives.min]\nend", "  # Your code here\nend", "  arr = lst.select\
    \ { |num| num < 0 }\n  a = arr.max || nil\n  b = lst.min || nil\n  [a, b]\nend",
  "  if lst.all? { |a| a > 0 }\n    [nil, lst.min]\n  elsif lst.all? { |a| a < 0 }\n\
    \    [lst.max, nil]\n  else\n    [lst.select { |a| a < 0 }.max, lst.select { |a|\
    \ a > 0 }.min]\n  end\nend", "  # =========================\n  #      YOUR CODE\
    \ HERE\n  # =========================\nend", "  positives = []\n  negatives =\
    \ []\n  lst.each do |num|\n    if num > 0\n      positives << num\n    elsif num\
    \ < 0\n      negatives << num\n    end\n  end\n  [negatives.max, positives.min]\n\
    end", "  # enter your code here\nend", "  smallest = nil\n  largest = nil\n  if\
    \ lst.length == 0\n    return [nil, nil]\n  end\n  lst.each do |num|\n    if num\
    \ > 0 && num < smallest || smallest == nil\n      smallest = num\n    elsif num\
    \ < 0 && num > largest || largest == nil\n      largest = num\n    end\n  end\n\
    \  return [largest, smallest]\nend", "  a, b = nil, nil\n  lst.each do |n|\n \
    \   if n > 0\n      b = n if !b || n < b\n    elsif n < 0\n      a = n if !a ||\
    \ n > a\n    end\n  end\n  [a, b]\nend", "  # your code here\nend", "  # TODO:\
    \ Write your code here.\n  [lst.select{|x| x < 0}.max, lst.select{|x| x > 0}.min]\n\
    end", "  pos = lst.select { |x| x > 0 }.min\n  neg = lst.select { |x| x < 0 }.max\n\
    \  [neg, pos]\nend", "  smallest = nil\n  largest = nil\n  lst.each do |i|\n \
    \   if i < 0\n      if smallest.nil? || i > smallest\n        smallest = i\n \
    \     end\n    elsif i > 0\n      if largest.nil? || i < largest\n        largest\
    \ = i\n      end\n    end\n  end\n  [smallest, largest]\nend", "  # ADD CODE HERE\n\
    end", "\tnegative = lst.select { |i| i < 0 }\n\tpositive = lst.select { |i| i\
    \ > 0 }\n\tlargest_negative = negative.sort[-1]\n\tsmallest_positive = positive.sort[0]\n\
    \t[largest_negative, smallest_positive]\nend", "    neg = lst.select{|num| num\
    \ < 0}.sort.last\n    pos = lst.select{|num| num > 0}.sort.first\n    return [neg,\
    \ pos]\nend", "  pos = lst.find_all { |v| v > 0 }\n  neg = lst.find_all { |v|\
    \ v < 0 }\n  return [nil, nil] if pos.empty? && neg.empty?\n  [neg.max, pos.min]\n\
    end", "\tmin_value = nil\n\tmax_value = nil\n\t\n\tlst.each do |num|\n\t\tif num\
    \ < 0\n\t\t\tif max_value == nil || num > max_value\n\t\t\t\tmax_value = num\n\
    \t\t\tend\n\t\telsif num > 0\n\t\t\tif min_value == nil || num < min_value\n\t\
    \t\t\tmin_value = num\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn [max_value, min_value]\n\
    end", "  # TODO: Write your implementation here.\n  lst.sort!\n  return [nil,\
    \ nil] if lst.length == 0\n  return [nil, nil] if lst.last < 0\n  return [nil,\
    \ nil] if lst.first > 0\n  a = lst.select { |n| n < 0 }.max\n  b = lst.select\
    \ { |n| n > 0 }.min\n  [a, b]\nend", "  if lst.empty?\n    [nil, nil]\n  else\n\
    \    max_neg = lst.max_by { |num| num < 0 ? num : 0 }\n    min_pos = lst.min_by\
    \ { |num| num > 0 ? num : 10**8 }\n    [max_neg, min_pos]\n  end\nend", "  [\n\
    \    lst.select{|x| x<0}.max,\n    lst.select{|x| x>0}.min\n  ]\nend", "  negatives\
    \ = []\n  positives = []\n  lst.each do |x|\n    negatives << x if x < 0\n   \
    \ positives << x if x > 0\n  end\n  [negatives.max, positives.min]\nend", "  res\
    \ = [nil, nil]\n  lst.each do |x|\n    if x < 0 && x > res[0]\n      res[0] =\
    \ x\n    elsif x > 0 && (res[1].nil? || x < res[1])\n      res[1] = x\n    end\n\
    \  end\n  res\nend", end, "  # TODO: Write your solution here\n  num = lst.sort\n\
    \  puts \" #{num} \"\n  a = 0\n  b = 0\n  lst.each { |x|\n    if x < 0\n     \
    \ if a == 0\n        a = x\n      elsif x > a\n        a = x\n      end\n    elsif\
    \ x > 0\n      if b == 0\n        b = x\n      elsif x < b\n        b = x\n  \
    \    end\n    end\n  }\n  return [a, b]\nend", "  a = nil\n  b = nil\n  i = 0\n\
    \  while i < lst.length\n    if lst[i] < 0 && (lst[i] > a || a == nil)\n     \
    \ a = lst[i]\n    elsif lst[i] > 0 && (lst[i] < b || b == nil)\n      b = lst[i]\n\
    \    end\n    i += 1\n  end\n  [a, b]\nend", "  positive = []\n  negative = []\n\
    \  result = []\n  lst.each do |i|\n    if i < 0\n      negative << i\n    elsif\
    \ i > 0\n      positive << i\n    end\n  end\n  if negative.empty?\n    result\
    \ << nil\n  else\n    result << negative.max\n  end\n  if positive.empty?\n  \
    \  result << nil\n  else\n    result << positive.min\n  end\n  result\nend", " \
    \ negs = []\n  poss = []\n  lst.each do |n|\n    if n < 0\n      negs << n\n \
    \   elsif n > 0\n      poss << n\n    end\n  end\n  [negs.max, poss.min]\nend",
  "  positives = []\n  negatives = []\n  largest_integer = -1.0/0.0\n  smallest_integer\
    \ = 1.0/0.0\n  lst.each do |x|\n    if x > 0\n      positives << x\n    elsif\
    \ x < 0\n      negatives << x\n    end\n  end\n  negatives.each do |y|\n    if\
    \ y > largest_integer\n      largest_integer = y\n    end\n  end\n  positives.each\
    \ do |y|\n    if y < smallest_integer\n      smallest_integer = y\n    end\n \
    \ end\n  [largest_integer, smallest_integer]\nend", "  negatives = lst.select\
    \ { |n| n < 0 }\n  negatives = negatives.max\n  positives = lst.select { |n| n\
    \ > 0 }\n  positives = positives.min\n  [negatives, positives]\nend", "  smallest_integer\
    \ = nil\n  largest_integer = nil\n  lst.each do |el|\n    if el < 0\n      if\
    \ smallest_integer.nil? || el > smallest_integer\n        smallest_integer = el\n\
    \      end\n    elsif el > 0\n      if largest_integer.nil? || el < largest_integer\n\
    \        largest_integer = el\n      end\n    end\n  end\n  [smallest_integer,\
    \ largest_integer]\nend", "  b = nil\n  a = nil\n  positive = []\n  negative =\
    \ []\n  lst.each do |n|\n    if n > 0\n      positive << n\n    elsif n < 0\n\
    \      negative << n\n    end\n  end\n  a = negative.max unless negative.empty?\n\
    \  b = positive.min unless positive.empty?\n  [a, b]\nend", "  lst = lst.sort\n\
    \  return [nil, nil] if lst.all? { |x| x == 0 }\n  return [nil, lst.first] if\
    \ lst.all? { |x| x < 0 }\n  return [lst.last, nil] if lst.all? { |x| x > 0 }\n\
    \  largest_negative = lst.first(lst.index(0)).last\n  smallest_positive = lst.last(lst.length\
    \ - lst.index(0) - 1).first\n  [largest_negative, smallest_positive]\nend", " \
    \ # Begin coding here.\nend", "  max = nil\n  min = nil\n  lst.each do |i|\n \
    \   if i > 0\n      min = i if min.nil? || i < min\n    elsif i < 0\n      max\
    \ = i if max.nil? || i > max\n    end\n  end\n  [max, min]\nend", "  [\n    lst.select\
    \ { |i| i < 0 }.max,\n    lst.select { |i| i > 0 }.min\n  ]\nend", "    a = b\
    \ = nil\n    lst.each do |v|\n        if v > 0 && (b.nil? || v < b)\n        \
    \    b = v\n        elsif v < 0 && (a.nil? || v > a)\n            a = v\n    \
    \    end\n    end\n    [a, b]\nend", "    new_lst = lst.select { |num| num !=\
    \ 0 }\n    if new_lst.empty?\n        [nil, nil]\n    else\n        negative_lst\
    \ = new_lst.select { |num| num < 0 }\n        positive_lst = new_lst.select {\
    \ |num| num > 0 }\n        a = negative_lst.max\n        b = positive_lst.min\n\
    \        [a, b]\n    end\nend\nputs \"-\" * 20\nputs largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]) == [nil, 1]\nputs largest_smallest_integers([]) == [nil, nil]\n\
    puts largest_smallest_integers([0]) == [nil, nil]", "  # TODO: Implement the function\
    \ here\nend", "  if lst.empty?\n    [nil, nil]\n  else\n    negatives = lst.select\
    \ { |num| num < 0 }\n    positives = lst.select { |num| num > 0 }\n    neg_max\
    \ = negatives.max\n    pos_min = positives.min\n    [neg_max, pos_min]\n  end\n\
    end", "  largest = lst.select { |item| item < 0 }.max\n  smallest = lst.select\
    \ { |item| item > 0 }.min\n  [largest, smallest]\nend", "  if lst.any? { |n| n\
    \ < 0 } && lst.any? { |n| n > 0 }\n    return [lst.select { |n| n < 0 }.max, lst.select\
    \ { |n| n > 0 }.min]\n  else\n    return [nil, nil]\n  end\nend\nputs largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\nputs largest_smallest_integers([])\nputs largest_smallest_integers([0])",
  "  max = -Float::INFINITY\n  min = Float::INFINITY\n  lst.each do |i|\n    if i\
    \ < 0\n      max = i if i > max\n    else\n      min = i if i < min\n    end\n\
    \  end\n  return [max == -Float::INFINITY ? nil : max, min == Float::INFINITY\
    \ ? nil : min]\nend", "  a = lst.select{|x| x < 0 }.max\n  b = lst.select{|x|\
    \ x > 0 }.min\n  return [a, b]\nend", "    smallest = nil\n    largest = nil\n\
    \    lst.each do |item|\n        if item > 0\n            if smallest == nil\n\
    \                smallest = item\n            elsif item < smallest\n        \
    \        smallest = item\n            end\n        elsif item < 0\n          \
    \  if largest == nil\n                largest = item\n            elsif item >\
    \ largest\n                largest = item\n            end\n        end\n    end\n\
    \    return [largest, smallest]\nend", "  lst.minmax\nend", "  negative_integers\
    \ = lst.select { |n| n < 0 }\n  positive_integers = lst.select { |n| n > 0 }\n\
    \  [negative_integers.max, positive_integers.min]\nend", "  neg_max = lst.select\
    \ { |e| e < 0 }.max\n  pos_min = lst.select { |e| e > 0 }.min\n  [neg_max, pos_min]\n\
    end", "  negative_numbers = lst.select { |num| num < 0 }\n  positive_numbers =\
    \ lst.select { |num| num > 0 }\n  [negative_numbers.max, positive_numbers.min]\n\
    end", "  max = lst.max\n  min = lst.min\n  return [nil, nil] if lst.empty?\n \
    \ return [nil, min] if min >= 0\n  return [max, nil] if max <= 0\n  return [max,\
    \ min]\nend", "  if lst.empty?\n    return [nil, nil]\n  elsif lst.include?(0)\n\
    \    return [nil, nil]\n  elsif lst.max < 0\n    return [lst.max, nil]\n  elsif\
    \ lst.min > 0\n    return [nil, lst.min]\n  else\n    return [lst.minmax.first,\
    \ lst.minmax.last]\n  end\nend", "  raise ArgumentError, 'Argument is not an array'\
    \ unless lst.is_a?(Array)\n  lst.select! { |x| x.is_a?(Integer) }\n  negative_ints\
    \ = lst.select { |x| x < 0 }\n  positive_ints = lst.select { |x| x > 0 }\n  [negative_ints.min,\
    \ positive_ints.min]\nend", "  a = nil\n  b = nil\n  if lst.size > 0\n    lst.each\
    \ do |i|\n      if i < 0\n        if a == nil\n          a = i\n        elsif\
    \ i > a\n          a = i\n        end\n      elsif i > 0\n        if b == nil\n\
    \          b = i\n        elsif i < b\n          b = i\n        end\n      end\n\
    \    end\n  end\n  return [a, b]\nend", "  pos = neg = nil\n  lst.each do |n|\n\
    \    pos = n if n > 0\n    neg = n if n < 0\n  end\n  [neg, pos]\nend", "  positive\
    \ = lst.select { |n| n > 0 }.min\n  negative = lst.select { |n| n < 0 }.max\n\
    \  [negative, positive]\nend", "  neg = []\n  pos = []\n  max_neg = nil\n  min_pos\
    \ = nil\n  lst.each do |e|\n    if e < 0\n      neg << e\n    elsif e > 0\n  \
    \    pos << e\n    end\n  end\n  max_neg = neg.max\n  min_pos = pos.min\n  [max_neg,\
    \ min_pos]\nend", "  lst.delete_if { |n| n == 0 }\n  lst.sort!", "    largest_negative\
    \ = -1.0/0\n    smallest_positive = 1.0/0\n    lst.each do |num|\n        if num\
    \ >= 0 && num < smallest_positive\n            smallest_positive = num\n     \
    \   elsif num < 0 && num > largest_negative\n            largest_negative = num\n\
    \        end\n    end\n    p [largest_negative, smallest_positive]\nend\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\nlargest_smallest_integers([])\nlargest_smallest_integers([0])",
  "  lst = lst.select { |num| num > 0 }.sort\n  [lst.first, lst.last]\nend", "  if\
    \ lst.empty?\n    [nil, nil]\n  else\n    min_number = lst.min\n    max_number\
    \ = lst.max\n    [min_number, max_number]\n  end\nend", "  biggest_neg = lst.find\
    \ { |num| num < 0 }\n  smallest_pos = lst.find { |num| num > 0 }\n  res = [biggest_neg,\
    \ smallest_pos]\n  res.each_with_index do |num, i|\n    res[i] = nil if num.nil?\n\
    \  end\n  res\nend", "\treturn [nil, nil] if lst.empty?\n\tlst.delete(0)\n\treturn\
    \ [nil, nil] if lst.empty?\n\tonly_positive = lst.select{|n| n > 0}\n\tonly_negative\
    \ = lst.select{|n| n < 0}\n\t[only_negative.max, only_positive.min]\nend", " \
    \ lst_positive = lst.select { |n| n > 0 }\n  lst_negative = lst.select { |n| n\
    \ < 0 }\n  p [lst_negative.max, lst_positive.min]\nend\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\nlargest_smallest_integers([])\nlargest_smallest_integers([0])",
  "  pos_min = nil\n  neg_max = nil\n  lst.each do |x|\n    if pos_min == nil && x\
    \ > 0\n      pos_min = x\n    elsif x > 0 && x < pos_min\n      pos_min = x\n\
    \    end\n    if neg_max == nil && x < 0\n      neg_max = x\n    elsif x < 0 &&\
    \ x > neg_max\n      neg_max = x\n    end\n  end\n  return [neg_max, pos_min]\n\
    end", "  p = lst.select { |n| n > 0 }.min\n  n = lst.select { |n| n < 0 }.max\n\
    \  [n, p]\nend", "\tnegatives = []\n\tpositives = []\n\tlst.each do |num|\n\t\t\
    if num < 0\n\t\t\tnegatives << num\n\t\telsif num > 0\n\t\t\tpositives << num\n\
    \t\tend\n\tend\n\treturn [negatives.max, positives.min]\nend", "  neg = lst.select\
    \ { |e| e < 0 }.max\n  pos = lst.select { |e| e > 0 }.min\n  return [neg, pos]\n\
    end", "  negative = nil\n  positive = nil\n  lst.each do |num|\n    if negative.nil?\
    \ && num < 0\n      negative = num\n    elsif negative && num < 0 && num > negative\n\
    \      negative = num\n    end\n    if positive.nil? && num > 0\n      positive\
    \ = num\n    elsif positive && num > 0 && num < positive\n      positive = num\n\
    \    end\n  end\n  [negative, positive]\nend", "\tsmallest = nil\n\tlargest =\
    \ nil\n\tlst.each do |i|\n\t\tif i > 0 && (smallest == nil || i < smallest)\n\t\
    \t\tsmallest = i\n\t\telsif i < 0 && (largest == nil || i > largest)\n\t\t\tlargest\
    \ = i\n\t\tend\n\tend\n\t[largest, smallest]\nend", "  lst.partition { |x| x <\
    \ 0 }.\n      map { |x| x.empty? ? nil : x.minmax.reverse }\nend", "  pos = lst.select\
    \ { |x| x > 0 }.min\n  neg = lst.select { |x| x < 0 }.max\n  [neg, pos]\nend",
  "  return [] if lst.empty?\n  smallest_positive_int = nil\n  largest_negative_int\
    \ = nil\n  lst.each do |int|\n    if int < 0\n      largest_negative_int = int\
    \ if largest_negative_int.nil? || int > largest_negative_int\n    else\n     \
    \ smallest_positive_int = int if smallest_positive_int.nil? || int < smallest_positive_int\n\
    \    end\n  end\n  [largest_negative_int, smallest_positive_int]\nend", "  positive_lst\
    \ = lst.select { |l| l >= 0 }\n  negative_lst = lst.select { |l| l < 0 }\n  [negative_lst.max,\
    \ positive_lst.min]\nend", "\tmax = lst.find_all{|x| x < 0}.max\n\tmin = lst.find_all{|x|\
    \ x > 0}.min\n\tmax = max ? max : nil\n\tmin = min ? min : nil\n\treturn [max,\
    \ min]\nend", "  positive_lst = lst.select { |i| i > 0 }\n  negative_lst = lst.select\
    \ { |i| i < 0 }\n  return [negative_lst.max, positive_lst.min]\nend", "  sorted\
    \ = lst.sort_by { |x| x.abs }\n  left = sorted.select { |x| x < 0 }.last\n  right\
    \ = sorted.select { |x| x > 0 }.first\n  [left, right]\nend", "  if lst.empty?\n\
    \    return [nil, nil]\n  end\n  a = lst.select { |i| i < 0 }.max\n  b = lst.select\
    \ { |i| i > 0 }.min\n  return [a, b]\nend\np largest_smallest_integers([2, 4,\
    \ 1, 3, 5, 7]) # [nil, 1]\np largest_smallest_integers([]) # [nil, nil]\np largest_smallest_integers([0])\
    \ # [nil, nil]", "  positive_integers = lst.select { |i| i > 0 }\n  negative_integers\
    \ = lst.select { |i| i < 0 }\n  return [nil, nil] if positive_integers.empty?\
    \ && negative_integers.empty?\n  [negative_integers.max, positive_integers.min]\n\
    end", "  neg_lst = lst.select{|num| num < 0}.sort!\n  pos_lst = lst.select{|num|\
    \ num > 0}.sort!\n  a = neg_lst.last\n  b = pos_lst.first\n  if a == nil || b\
    \ == nil\n    return [nil, nil]\n  else\n    return [a, b]\n  end\nend", "  #\
    \ your code here\nend", "  negative = lst.select { |x| x < 0 }.max\n  positive\
    \ = lst.select { |x| x > 0 }.min\n  [negative, positive]\nend", "\tlst = lst.sort{|a,b|\
    \ b <=> a}\n\t(lst.select{|x| x < 0}[0]).nil? ? a = nil : a = lst.select{|x| x\
    \ < 0}[0]\n\t(lst.select{|x| x > 0}[0]).nil? ? b = nil : b = lst.select{|x| x\
    \ > 0}[0]\n\t[a,b]\nend", "    return [nil, nil] if lst.all? { |e| e == 0 }\n\
    \    negatives = lst.select { |e| e < 0 }\n    positives = lst.select { |e| e\
    \ > 0 }\n    return [negatives.max, positives.min]\nend", end, "  if lst.empty?\n\
    \    return [nil, nil]\n  end\n  pos = nil\n  neg = nil\n  lst.each do |i|\n \
    \   if i > 0\n      if pos == nil\n        pos = i\n      elsif i < pos\n    \
    \    pos = i\n      end\n    elsif i < 0\n      if neg == nil\n        neg = i\n\
    \      elsif i > neg\n        neg = i\n      end\n    end\n  end\n  [neg, pos]\n\
    end", '  lst_pos, lst_neg = lst.partition { |x| x > 0 }', "  neg = lst.select\
    \ { |el| el < 0 }.max\n  pos = lst.select { |el| el > 0 }.min\n  [neg, pos]\n\
    end", "  max_neg = nil\n  min_pos = nil\n  lst.each do |i|\n    next if i == 0\n\
    \    if i > 0\n      min_pos = i if !min_pos || i < min_pos\n    else\n      max_neg\
    \ = i if !max_neg || i > max_neg\n    end\n  end\n  [max_neg, min_pos]\nend",
  "    return [nil, nil] if lst.nil? || lst.empty?\n    max_negative, min_positive\
    \ = nil, nil\n    lst.each do |i|\n        if i < 0\n            max_negative\
    \ = i if max_negative.nil? || i > max_negative\n        else\n            min_positive\
    \ = i if min_positive.nil? || i < min_positive\n        end\n    end\n    [max_negative,\
    \ min_positive]\nend", "  # lst.select { |e| e < 0 }.max\n  pos_lst = lst.select\
    \ { |e| e > 0 }\n  neg_lst = lst.select { |e| e < 0 }\n  [neg_lst.max, pos_lst.min]\n\
    end", "  negatives = lst.select { |num| num < 0 }\n  positives = lst.select {\
    \ |num| num > 0 }\n  smallest_positive = positives.min\n  largest_negative = negatives.max\n\
    \  if smallest_positive.nil? && largest_negative.nil?\n    [nil, nil]\n  elsif\
    \ smallest_positive.nil?\n    [largest_negative, nil]\n  elsif largest_negative.nil?\n\
    \    [nil, smallest_positive]\n  else\n    [largest_negative, smallest_positive]\n\
    \  end\nend", "  [lst.select{|i| i<0}.max, lst.select{|i| i>0}.min]\nend", "\t\n\
    end", "  negs = lst.select { |i| i < 0 }\n  pos = lst.select { |i| i > 0 }\n \
    \ return [negs.max, pos.min]\nend", "  max_neg = nil\n  min_pos = nil\n  lst.each\
    \ do |n|\n    if n < 0\n      max_neg = n if max_neg.nil? || n > max_neg\n   \
    \ elsif n > 0\n      min_pos = n if min_pos.nil? || n < min_pos\n    end\n  end\n\
    \  [max_neg, min_pos]\nend", "  negatives = lst.select { |e| e < 0 }\n  positives\
    \ = lst.select { |e| e > 0 }\n  [negatives.max, positives.min]\nend", "  # TODO:\
    \ return a tuple: [largest_negative, smallest_positive]\n  largest_negative =\
    \ nil\n  smallest_positive = nil\n  lst.each do |num|\n    if num < 0\n      if\
    \ largest_negative.nil? || num > largest_negative\n        largest_negative =\
    \ num\n      end\n    elsif num > 0\n      if smallest_positive.nil? || num <\
    \ smallest_positive\n        smallest_positive = num\n      end\n    end\n  end\n\
    \  return [largest_negative, smallest_positive]\nend", "  smallest_pos = nil\n\
    \  largest_neg = nil\n  lst.each do |num|\n    if num.is_a? Integer\n      if\
    \ num < 0\n        if largest_neg.nil? || num > largest_neg\n          largest_neg\
    \ = num\n        end\n      else\n        if smallest_pos.nil? || num < smallest_pos\n\
    \          smallest_pos = num\n        end\n      end\n    end\n  end\n  [largest_neg,\
    \ smallest_pos]\nend", "  neg, pos = nil, nil\n  lst.each do |el|\n    if el <\
    \ 0\n      neg = el if neg.nil?\n      neg = el if el > neg\n    elsif el > 0\n\
    \      pos = el if pos.nil?\n      pos = el if el < pos\n    end\n  end\n  [neg,\
    \ pos]\nend", "  if lst.length == 0\n    [nil, nil]\n  else\n    negative_max\
    \ = lst.max { |x, y| x <=> y }\n    positive_min = lst.min { |x, y| x <=> y }\n\
    \    [negative_max, positive_min]\n  end\nend", "  # ------------------\n  # Your\
    \ code here.\n  # ------------------\nend", "    negatives = lst.select { |num|\
    \ num < 0 }\n    positives = lst.select { |num| num > 0 }\n    [(negatives.max\
    \ if negatives.length > 0), (positives.min if positives.length > 0)]\nend", " \
    \ map_hash = lst.each_with_object({}){|num, hash| hash[num] = num.zero? ? 0 :\
    \ num > 0 ? 1 : -1}\n  arr = [map_hash.key(1), map_hash.key(-1)]\n  return [nil,\
    \ nil] if arr.include?(nil)\n  arr\nend", "    sort = lst.sort\n    pos = []\n\
    \    neg = []\n    result = []\n    sort.each do |num|\n        if num < 0\n \
    \           neg << num\n        elsif num > 0\n            pos << num\n      \
    \  end\n    end\n    result << neg.max\n    result << pos.min\n    result\nend",
  "  # nil if lst.empty?\n  # return nil, nil if lst.empty?\n  a = b = nil\n  lst.each\
    \ do |num|\n    if num > 0\n      b = num if b.nil? || num < b\n    elsif num\
    \ < 0\n      a = num if a.nil? || num > a\n    end\n  end\n  [a, b]\nend", " \
    \ new_list = lst.select { |n| n.negative? || n.positive? }\n  a = new_list.select\
    \ { |n| n.negative? }.max\n  b = new_list.select { |n| n.positive? }.min\n  return\
    \ [a, b]\nend", "  max_negative, min_positive = nil\n  lst.each do |x|\n    if\
    \ x < 0\n      max_negative = x if max_negative.nil? || x > max_negative\n   \
    \ elsif x > 0\n      min_positive = x if min_positive.nil? || x < min_positive\n\
    \    end\n  end\n  [max_negative, min_positive]\nend", "  max_negative, min_positive\
    \ = nil, nil\n  lst.each do |x|\n    if x < 0\n      max_negative = x if max_negative.nil?\
    \ || x > max_negative\n    elsif x > 0\n      min_positive = x if min_positive.nil?\
    \ || x < min_positive\n    end\n  end\n  [max_negative, min_positive]\nend", " \
    \ a = lst.select { |i| i < 0 }.max\n  b = lst.select { |i| i > 0 }.min\n  [a,\
    \ b]\nend", "  negative_integers = lst.select { |n| n < 0 }\n  positive_integers\
    \ = lst.select { |n| n > 0 }\n  [negative_integers.max, positive_integers.min]\n\
    end", "  min, max = nil, nil\n  lst.each do |n|\n    min = n if min.nil? || (n\
    \ > 0 && n < min)\n    max = n if max.nil? || (n < 0 && n > max)\n  end\n  [max,\
    \ min]\nend", "  return [nil, nil] if lst.empty?\n  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \  sorted = lst.sort { |a, b| a <=> b }\n  negatives = sorted.select { |i| i <\
    \ 0 }\n  positives = sorted.select { |i| i > 0 }\n  return [negatives.last, positives.first]\n\
    end", "  min_positive_number = lst.select { |number| number > 0 }.min\n  max_negative_number\
    \ = lst.select { |number| number < 0 }.max\n  [max_negative_number, min_positive_number]\n\
    end", "  negatives = lst.select { |n| n < 0 }\n  negatives.empty? ? a = nil :\
    \ a = negatives.max\n  positives = lst.select { |n| n > 0 }\n  positives.empty?\
    \ ? b = nil : b = positives.min\n  [a, b]\nend", "  return [nil, nil] if lst.size.zero?\n\
    \  positives = lst.select { |x| x > 0 }\n  negatives = lst.select { |x| x < 0\
    \ }\n  [negatives.max, positives.min]\nend", "  p lst.select{|n| n<0}.max, lst.select{|n|\
    \ n>0}.min\nend", "  negative_list = []\n  positive_list = []\n  lst.each do |i|\n\
    \    if i > 0\n      positive_list << i\n    elsif i < 0\n      negative_list\
    \ << i\n    end\n  end\n  negative_list.max ||= nil\n  positive_list.min ||= nil\n\
    \  return [negative_list.max, positive_list.min]\nend", "  a = lst.select{|x|\
    \ x < 0}.max\n  b = lst.select{|x| x > 0}.min\n  a.nil? ? [nil, b] : b.nil? ?\
    \ [a, nil] : [a, b]\nend\nlargest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n\
    largest_smallest_integers.call([])\nlargest_smallest_integers.call([0])", "  #\
    \ fill out\nend", "  if lst.all? { |x| x.class == Fixnum }\n    largest_negative\
    \ = lst.select { |x| x < 0 }.max\n    smallest_positive = lst.select { |x| x >\
    \ 0 }.min\n    return [largest_negative, smallest_positive]\n  else\n    return\
    \ [nil, nil]\n  end\nend", "  if lst.empty?\n    [nil, nil]\n  else\n    positives\
    \ = lst.select{|v| v > 0}.sort\n    negatives = lst.select{|v| v < 0}.sort.reverse\n\
    \    [negatives.first, positives.first]\n  end\nend", "  positive = lst.find_all\
    \ { |n| n > 0 }\n  negative = lst.find_all { |n| n < 0 }\n  positive = positive.min\n\
    \  negative = negative.max\n  positive = nil if positive == 0\n  negative = nil\
    \ if negative == 0\n  [negative, positive]\nend", "  # TODO: Implement\nend",
  "  a = nil\n  b = nil\n  lst.each do |x|\n    if x > 0\n      b = x if b.nil? ||\
    \ x < b\n    elsif x < 0\n      a = x if a.nil? || x > a\n    end\n  end\n  [a,\
    \ b]\nend", "  # Find the largest negative integer, 'a' and the smallest positive\n\
    \  # integer, 'b' in 'lst'\n  a = b = nil\n  lst.each do |e|\n    if e > 0\n \
    \     b = e if b.nil? || e < b\n    elsif e < 0\n      a = e if a.nil? || e >\
    \ a\n    end\n  end\n  [a, b]\nend", "  if lst.size == 0\n    return [nil, nil]\n\
    \  end\n  mx = mn = nil\n  lst.each do |item|\n    mx = item if item > 0 and (mx.nil?\
    \ or item < mx)\n    mn = item if item < 0 and (mn.nil? or item > mn)\n  end\n\
    \  [mn, mx]\nend", "  n = lst.delete_if { |x| x == 0 }\n  puts n\n  neg = n.delete_if\
    \ { |x| x > 0 }\n  pos = n.delete_if { |x| x < 0 }\n  return [neg.max, pos.min]\n\
    end", "  smallest_positive_integer = nil\n  largest_negative_integer = nil\n \
    \ lst.each do |item|\n    if item > 0\n      if smallest_positive_integer.nil?\
    \ || item < smallest_positive_integer\n        smallest_positive_integer = item\n\
    \      end\n    elsif item < 0\n      if largest_negative_integer.nil? || item\
    \ > largest_negative_integer\n        largest_negative_integer = item\n      end\n\
    \    end\n  end\n  return [largest_negative_integer, smallest_positive_integer]\n\
    end", "    arr = []\n    arr << (lst.select { |i| i < 0 }.max) if lst.any? { |i|\
    \ i < 0 }\n    arr << (lst.select { |i| i > 0 }.min) if lst.any? { |i| i > 0 }\n\
    \    arr\nend", "  largest_smallest_integers = [nil, nil]\n  lst.each do |el|\n\
    \    if el > 0\n      largest_smallest_integers[1] = el if largest_smallest_integers[1].nil?\
    \ || largest_smallest_integers[1] > el\n    else\n      largest_smallest_integers[0]\
    \ = el if largest_smallest_integers[0].nil? || largest_smallest_integers[0] <\
    \ el\n    end\n  end\n  largest_smallest_integers\nend", "  b, a = nil, nil\n\
    \  lst.each do |item|\n    next if item.zero?\n    b = item if b.nil?\n    a =\
    \ item if a.nil?\n    a = item if item < a && item.negative?\n    b = item if\
    \ item < b && item.positive?\n  end\n  [a, b]\nend", "  neg_max = lst.select {\
    \ |i| i < 0 }.max\n  pos_min = lst.select { |i| i > 0 }.min\n  [neg_max, pos_min]\n\
    end", "  neg = lst.select { |x| x < 0 }.max\n  pos = lst.select { |x| x > 0 }.min\n\
    \  neg ? [neg, pos] : [nil, nil]\nend", "  # Create an empty result array.\n \
    \ result = []\n  # Check if the array is empty.\n  if lst.empty?\n    # If yes,\
    \ return the result as [nil, nil].\n    return result << nil << nil\n  else\n\
    \    # If no, get the smallest integer from the list.\n    smallest = lst.min\n\
    \    # Check if all elements are positive integers.\n    if smallest >= 0\n  \
    \    # If yes, return the result as [nil, smallest].\n      return result << nil\
    \ << smallest\n    else\n      # If no, get the largest integer from the list.\n\
    \      largest = lst.max\n      # Check if all elements are negative integers.\n\
    \      if largest <= 0\n        # If yes, return the result as [largest, nil].\n\
    \        return result << largest << nil\n      else\n        # If no, return\
    \ the result as [largest, smallest].\n        return result << largest << smallest\n\
    \      end\n    end\n  end\nend", "  return [nil, nil] if lst.empty? || lst.all?\
    \ { |num| num == 0 }\n  lst.select! { |num| num > 0 || num < 0 }\n  [lst.max,\
    \ lst.min]\nend", "  pst = lst.reject { |x| x < 0 }\n  ngt = lst.reject { |x|\
    \ x > 0 }\n  return nil, nil if ngt.empty? || pst.empty?\n  [ngt.max, pst.min]\n\
    end", "  # Code here\nend", "  max = nil\n  min = nil\n  lst.each do |i|\n   \
    \ if i < 0 && max.nil? || i < max\n      max = i\n    end\n    if i > 0 && min.nil?\
    \ || i < min\n      min = i\n    end\n  end\n  [max, min]\nend", "  positives\
    \ = lst.select { |x| x >= 0 }\n  negatives = lst.select { |x| x < 0 }\n  [negatives.min,\
    \ positives.max]\nend", "  lst.sort_by!{|n| n.abs}\n  largest_negative = lst.find\
    \ {|n| n < 0}\n  smallest_positive = lst.find {|n| n > 0}\n  [largest_negative,\
    \ smallest_positive]\nend", "  new_list = []\n  negative_number = lst.select {\
    \ |x| x < 0 }\n  positive_number = lst.select { |x| x > 0 }\n  if negative_number.empty?\
    \ || positive_number.empty?\n    return [nil, nil]\n  else\n    new_list << negative_number.max\n\
    \    new_list << positive_number.min\n  end\n  new_list\nend", "  if lst.size\
    \ == 0\n    [nil, nil]\n  elsif lst.size == 1\n    lst[0] == 0 ? [nil, nil] :\
    \ [nil, lst[0]]\n  else\n    positive_integers = lst.select { |e| e > 0 }\n  \
    \  negative_integers = lst.select { |e| e < 0 }\n    [negative_integers.max, positive_integers.min]\n\
    \  end\nend", "  sorted = lst.sort_by { |val| val.abs }\n  [sorted.last, sorted.first]\n\
    end", "\tif lst.size == 0\n\t\treturn [nil, nil]\n\tend\n\tlargest_negative =\
    \ nil\n\tsmallest_positive = nil\n\tlst.each do |i|\n\t\tif i < 0\n\t\t\tif largest_negative\
    \ == nil\n\t\t\t\tlargest_negative = i\n\t\t\telsif i > largest_negative\n\t\t\
    \t\tlargest_negative = i\n\t\t\tend\n\t\telsif i > 0\n\t\t\tif smallest_positive\
    \ == nil\n\t\t\t\tsmallest_positive = i\n\t\t\telsif i < smallest_positive\n\t\
    \t\t\tsmallest_positive = i\n\t\t\tend\n\t\tend\n\tend\n\treturn [largest_negative,\
    \ smallest_positive]\nend", "\tpositive_numbers = []\n\tnegative_numbers = []\n\
    \tlst.each do |i|\n\t\tif i > 0\n\t\t\tpositive_numbers << i\n\t\telsif i < 0\n\
    \t\t\tnegative_numbers << i\n\t\tend\n\tend\n\treturn [negative_numbers.max, positive_numbers.min]\n\
    end", "  if lst.empty?\n    [nil, nil]\n  else\n    pos = lst.select { |x| x >\
    \ 0 }\n    neg = lst.select { |x| x < 0 }\n    [neg.max, pos.min]\n  end\nend",
  "  # TODO: implement this\nend", "  max_negative, min_positive = nil, nil\n  lst.each\
    \ do |num|\n    if num.is_a?(Numeric) && num > 0\n      min_positive = num if\
    \ min_positive.nil? || num < min_positive\n    elsif num.is_a?(Numeric) && num\
    \ < 0\n      max_negative = num if max_negative.nil? || num > max_negative\n \
    \   end\n  end\n  [max_negative, min_positive]\nend", "  # Collect negative and\
    \ positive numbers from the array\n  negs = lst.select{|e| e < 0}\n  pos = lst.select{|e|\
    \ e > 0}\n  # Sort negative numbers in descending order and sort positive numbers\
    \ in ascending order\n  negs.sort!.reverse!\n  pos.sort!\n  # Return the largest\
    \ negative number and the smallest positive number as an array\n  if negs == []\
    \ or pos == []\n    [nil, nil]\n  else\n    [negs[0], pos[0]]\n  end\nend", " \
    \ negative_integers = (lst.select { |n| n < 0 })\n  positive_integers = (lst.select\
    \ { |n| n > 0 })\n  if negative_integers.empty?\n    negative_integers = nil\n\
    \  end\n  if positive_integers.empty?\n    positive_integers = nil\n  end\n  [negative_integers.max,\
    \ positive_integers.min]\nend", "  pos = lst.select { |num| num > 0 }.min\n  neg\
    \ = lst.select { |num| num < 0 }.max\n  [neg, pos]\nend", "    neg_array = []\n\
    \    pos_array = []\n    lst.each do |num|\n        if num < 0\n            neg_array\
    \ << num\n        elsif num > 0\n            pos_array << num\n        end\n \
    \   end\n    neg_array.empty? ? [nil, pos_array.min] : [neg_array.max, pos_array.min]\n\
    end", "  if lst.empty?\n    return [nil, nil]\n  end\n  [lst.select { |e| e.negative?\
    \ }.max, lst.select { |e| e.positive? }.min]\nend", "  lst = lst.select{|a| a.is_a?\
    \ Integer}\n  if lst.any?\n    [lst.select{|a| a < 0}.max, lst.select{|a| a >\
    \ 0}.min]\n  else\n    [nil, nil]\n  end\nend", "end\n```", "  is_pos = []\n \
    \ is_neg = []\n  lst.each do |num|\n    if num > 0\n      is_pos << num\n    elsif\
    \ num < 0\n      is_neg << num\n    end\n  end\n  is_pos.sort!\n  is_neg.sort!\n\
    \  min = is_pos.min\n  max = is_neg.max\n  if min == nil\n    min = nil\n  end\n\
    \  if max == nil\n    max = nil\n  end\n  return [max, min]\nend", "  lst = lst.sort\n\
    \  largest_negative_integer = nil\n  smallest_positive_integer = nil\n  while\
    \ lst.length > 0\n    if lst[0] < 0\n      largest_negative_integer = lst[0]\n\
    \      lst.shift\n    elsif lst[0] > 0\n      smallest_positive_integer = lst[0]\n\
    \      lst.shift\n    else\n      lst.shift\n    end\n  end\n  [largest_negative_integer,\
    \ smallest_positive_integer]\nend", "  min, max = [], []\n  lst.each do |num|\n\
    \    if num > 0\n      min << num\n    elsif num < 0\n      max << num\n    end\n\
    \  end\n  if max.empty? || min.empty?\n    return [nil, nil]\n  else\n    return\
    \ [max.max, min.min]\n  end\nend", "  [lst.select{|e| e < 0}.max, lst.select{|e|\
    \ e > 0}.min]\nend", "  out_a = nil\n  out_b = nil\n  lst.each do |n|\n    if\
    \ n < 0\n      out_a = n if out_a.nil? || n > out_a\n    else\n      out_b = n\
    \ if out_b.nil? || n < out_b\n    end\n  end\n  [out_a, out_b]\nend", "  # Your\
    \ code goes here\nend", "  return [nil, nil] if lst.size == 0\n  negatives = lst.select\
    \ { |i| i < 0 }\n  negatives = [nil] if negatives.size == 0\n  positives = lst.select\
    \ { |i| i > 0 }\n  positives = [nil] if positives.size == 0\n  [negatives.max,\
    \ positives.min]\nend", "  a, b = nil, nil\n  lst.each do |i|\n    if i < 0\n\
    \      a = i unless a\n      a = i if i > a\n    else\n      b = i unless b\n\
    \      b = i if i < b\n    end\n  end\n  [a, b]\nend", "  a = lst.select { |x|\
    \ x < 0 }.max\n  b = lst.select { |x| x > 0 }.min\n  return [a, b]\nend", "  b\
    \ = a = nil\n  lst.each do |e|\n    if e.positive?\n      b = e if b.nil? || e\
    \ < b\n    elsif e.negative?\n      a = e if a.nil? || e > a\n    end\n  end\n\
    \  [a, b]\nend", "  positives = lst.select { |n| n > 0 }\n  negatives = lst.select\
    \ { |n| n < 0 }\n  biggest_negative = negatives.max\n  smallest_positive = positives.min\n\
    \  smallest_positive = nil if smallest_positive.nil?\n  biggest_negative = nil\
    \ if biggest_negative.nil?\n  [biggest_negative, smallest_positive]\nend", " \
    \ lst = lst.select { |e| e != 0}\n  return [nil, nil] if lst.empty?\n  lst.select!\
    \ { |e| e < 0 }\n  a = lst.max\n  lst.select! { |e| e > 0 }\n  b = lst.min\n \
    \ [a, b]\nend", "  a = b = nil\n  lst.each do |e|\n    if e < 0 && (a.nil? ||\
    \ e > a)\n      a = e\n    elsif e > 0 && (b.nil? || e < b)\n      b = e\n   \
    \ end\n  end\n  [a, b]\nend", "  unless lst.select { |x| x < 0 }.empty?\n    a\
    \ = lst.select { |x| x < 0 }.max\n  else\n    a = nil\n  end\n  unless lst.select\
    \ { |x| x > 0 }.empty?\n    b = lst.select { |x| x > 0 }.min\n  else\n    b =\
    \ nil\n  end\n  [a, b]\nend", "  if lst.empty?\n    return [nil, nil]\n  end\n\
    \  result = lst.partition{|x| x < 0}\n  sorted = result.map{|x| x.sort}\n  if\
    \ sorted[0].empty?\n    sorted[0] = nil\n  end\n  if sorted[1].empty?\n    sorted[1]\
    \ = nil\n  end\n  sorted\nend", "  return [nil, nil] if lst.empty?\n  [lst.select{|x|\
    \ x < 0}.max, lst.select{|x| x > 0}.min]\nend", "  largest_negative = nil\n  smallest_positive\
    \ = nil\n  lst.each do |num|\n    if num < 0\n      if largest_negative.nil? ||\
    \ num > largest_negative\n        largest_negative = num\n      end\n    elsif\
    \ num > 0\n      if smallest_positive.nil? || num < smallest_positive\n      \
    \  smallest_positive = num\n      end\n    end\n  end\n  [largest_negative, smallest_positive]\n\
    end", "    # Write your code here\n    (a, b) = [lst.max, lst.min]\n    return\
    \ nil if a.nil? || b.nil?\n    [a, b]\nend", "  positif = lst.select { |number|\
    \ number > 0 }\n  negatif = lst.select { |number| number < 0 }\n  [negatif.max,\
    \ positif.min]\nend\np largest_smallest_integers([2, 4, 1, 3, 5, 7])\np largest_smallest_integers([])\n\
    p largest_smallest_integers([0])", "  a = lst.select { |number| number < 0 }.max\n\
    \  b = lst.select { |number| number > 0 }.min\n  [a, b]\nend", "  lst = lst.sort\n\
    \  pos = []\n  neg = []\n  lst.each do |x|\n    if x < 0\n      neg << x\n   \
    \ elsif x > 0\n      pos << x\n    end\n  end\n  neg = neg.sort\n  pos = pos.sort\n\
    \  neg = neg.last\n  pos = pos.first\n  if neg == nil\n    neg = nil\n  elsif\
    \ pos == nil\n    pos = nil\n  end\n  [neg, pos]\nend", "  return [nil, nil] if\
    \ lst.empty?\n  lst.select! { |e| e > 0 || e < 0 }\n  return [nil, nil] if lst.empty?\n\
    \  [lst.max, lst.min]\nend", "  a = lst.select { |x| x < 0 }.max\n  b = lst.select\
    \ { |x| x > 0 }.min\n  a = nil if a.nil? || a.zero?\n  b = nil if b.nil? || b.zero?\n\
    \  [a, b]\nend", "  neg, pos = nil, nil\n  lst.each do |val|\n    next if val\
    \ == 0\n    if neg.nil?\n      neg = val if val < 0\n    else\n      neg = val\
    \ if val < 0 && val > neg\n    end\n    if pos.nil?\n      pos = val if val >\
    \ 0\n    else\n      pos = val if val > 0 && val < pos\n    end\n  end\n  [neg,\
    \ pos]\nend", "  return [nil, nil] if lst.empty?\n  max = lst.max\n  min = lst.min\n\
    \  return [max, min] if max > 0 && min < 0\n  return [nil, min] if max < 0\n \
    \ return [max, nil] if min > 0\n  [nil, nil]\nend", "  lst = lst.reject { |x|\
    \ x.zero? }\n  return [nil, nil] if lst.empty?\n  [lst.select { |x| x < 0 }.max,\
    \ lst.select { |x| x > 0 }.min]\nend", '    # write your solution here', "  largest_neg\
    \ = nil\n  smallest_pos = nil\n  lst.each do |x|\n    if x < 0 && (largest_neg.nil?\
    \ || x > largest_neg)\n      largest_neg = x\n    elsif x > 0 && (smallest_pos.nil?\
    \ || x < smallest_pos)\n      smallest_pos = x\n    end\n  end\n  [largest_neg,\
    \ smallest_pos]\nend", "  positive_numbers = []\n  negative_numbers = []\n  largest_negative\
    \ = nil\n  smallest_positive = nil\n  lst.each do |num|\n    if num < 0\n    \
    \  negative_numbers << num\n    elsif num > 0\n      positive_numbers << num\n\
    \    end\n  end\n  largest_negative = negative_numbers.sort[0] if negative_numbers.any?\n\
    \  smallest_positive = positive_numbers.sort[-1] if positive_numbers.any?\n  [largest_negative,\
    \ smallest_positive]\nend", "  neg_sort = lst.select { |num| num < 0 }.sort\n\
    \  pos_sort = lst.select { |num| num > 0 }.sort\n  if neg_sort == []\n    neg_sort\
    \ = nil\n  else\n    neg_sort = neg_sort[-1]\n  end\n  if pos_sort == []\n   \
    \ pos_sort = nil\n  else\n    pos_sort = pos_sort[0]\n  end\n  return [neg_sort,\
    \ pos_sort]\nend", "  # TODO: Implement your code here.\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
