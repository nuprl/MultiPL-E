name: HumanEval_93_encode
language: rb
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\n# >>> encode.call(\"test\")\n# \"TGST\"\
  \n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n\
  \    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"\
  ))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"\
  ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"\
  This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"\
  I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"
completions: ["    alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('')\n    message\
    \ = message.split('')\n    encoded_message = message.map do |letter|\n       \
    \ if alphabet.include?(letter.downcase)\n            if letter == letter.upcase\n\
    \                encoding_letter = alphabet[(alphabet.index(letter.downcase) +\
    \ 2) % 26].upcase\n            else\n                encoding_letter = alphabet[(alphabet.index(letter)\
    \ + 2) % 26]\n            end\n        else\n            encoding_letter = letter\n\
    \        end\n    end\n    encoded_message.join\nend", "  vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n  encoded_message = []\n  message.split(\"\").each\
    \ do |letter|\n    if letter == letter.upcase\n      encoded_message << letter.downcase\n\
    \    else\n      encoded_message << letter.upcase\n    end\n    if vowels.include?(letter.downcase)\n\
    \      index = vowels.index(letter.downcase)\n      encoded_message.pop\n    \
    \  if index < 4\n        encoded_message << vowels[index + 2]\n      else\n  \
    \      encoded_message << vowels[0]\n      end\n    end\n  end\n  encoded_message.join(\"\
    \")\nend\nputs encode(\"test\")\nputs encode(\"This is a message\")", "\tmessage.gsub(/[aeiou]/i)\
    \ { |vowel|\n\t\tnew_vowel = vowel.next.next\n\t\tnew_vowel.upcase! if vowel ==\
    \ vowel.upcase\n\t\tnew_vowel\n\t}\nend", "  # YOUR CODE HERE\nend", "  message\
    \ = message.downcase.split(\"\")\n  message.each_with_index do |char, index|\n\
    \    if vowel?(char)\n      message[index] = char.next\n      message[index] =\
    \ message[index].next\n    end\n  end\n  message.join.upcase\nend", "  vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  message = message.split(\"\")\n  vowels.each\
    \ do |vowel|\n    i = 0\n    while i < message.length do\n      if message[i]\
    \ == vowel\n        message[i] = (vowel.ord + 2).chr\n      end\n      i += 1\n\
    \    end\n  end\n  message.map! do |char|\n    if char.ord > 96 && char.ord <\
    \ 123\n      char = (char.ord - 32).chr\n    elsif char.ord > 64 && char.ord <\
    \ 91\n      char = (char.ord + 32).chr\n    else\n      char\n    end\n  end\n\
    \  message.join(\"\")\nend", "\tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \talpha = \"abcdefghijklmnopqrstuvwxyz\"\n\tword = message.downcase\n\tword.each_char\
    \ do |c|\n\t\tif c =~ /[a-z]/\n\t\t\tif vowels.include?(c)\n\t\t\t\tpos = alpha.index(c)\n\
    \t\t\t\tword[word.index(c)] = alpha[pos + 2]\n\t\t\telse\n\t\t\t\tword[word.index(c)]\
    \ = c.swapcase\n\t\t\tend\n\t\tend\n\tend\n\treturn word\nend", "\talphabet =\
    \ ('a'..'z').to_a\n\tvowels = ['a', 'e', 'i', 'o', 'u']\n\tmessage.each_char do\
    \ |c|\n\t\tif vowels.include?(c)\n\t\t\tidx = alphabet.index(c)\n\t\t\tc = alphabet[idx\
    \ + 2]\n\t\tend\n\t\tc.swapcase!\n\tend\nend", "  alphabet = (\"a\"..\"z\").to_a\n\
    \  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  l_message = message.downcase.split(\"\
    \").map do |char|\n    if vowels.include?(char)\n      char = alphabet[alphabet.index(char)\
    \ + 2]\n    elsif vowels.include?(alphabet[alphabet.index(char) + 1])\n      char\
    \ = alphabet[alphabet.index(char) + 3]\n    else\n      char = alphabet[alphabet.index(char)\
    \ + 1]\n    end\n  end\n  l_message.join.upcase\nend", "    @encoded = \"\"\n\
    \    message.each_char { |char|\n        if /[A-Z]/.match(char)\n            char\
    \ = char.downcase\n        elsif /[a-z]/.match(char)\n            char = char.upcase\n\
    \        end\n        if /[aeiou]/.match(char)\n            char = char.ord +\
    \ 2\n            char = char.chr\n        end\n        @encoded << char\n    }\n\
    \    return @encoded\nend", "  encode_message = \"\"\n  message.each_char do |char|\n\
    \    # find the index of the char\n    if char == char.downcase\n      new_index\
    \ = (char.ord - \"a\".ord + 2) % 26\n      encode_message += (new_index + \"a\"\
    .ord).chr\n    else\n      new_index = (char.ord - \"A\".ord + 2) % 26\n     \
    \ encode_message += (new_index + \"A\".ord).chr\n    end\n  end\n  encode_message\n\
    end", "  message.each_char.map { |c|\n    ascii = c.ord\n    if ascii >= 97 and\
    \ ascii <= 122\n      ascii -= 32\n    elsif ascii >= 65 and ascii <= 90\n   \
    \   ascii += 32\n    end\n    c = ascii.chr\n    case c\n    when 'A', 'E', 'I',\
    \ 'O', 'U'\n      c = (ascii + 2).chr\n    when 'a', 'e', 'i', 'o', 'u'\n    \
    \  c = (ascii - 2).chr\n    end\n    c\n  }.join\nend", "  # /[aeiou]/\n  characters\
    \ = message.split(\"\")\n  encrypted_message = \"\"\n  characters.each do |c|\n\
    \    if c.match(/[aeiou]/)\n      encrypted_message << find_next_vowel(c)\n  \
    \  elsif c.match(/[A-Z]/)\n      encrypted_message << find_next_vowel(c.downcase).upcase\n\
    \    else\n      encrypted_message << c\n    end\n  end\n  encrypted_message\n\
    end", "  message.downcase.tr(\"a-y\", \"c-zab\").tr(\"aeiou\", \"eioua\").upcase\n\
    end", "\t# Decode message with key (1)\n\tdecoded_message = \"\"\n\tindex = 0\n\
    \tmessage.length.times do\n\t\tcharacter = message[index]\n\t\tif character ==\
    \ character.upcase\n\t\t\tdecoded_message << character.downcase\n\t\telse\n\t\t\
    \tdecoded_message << character.upcase\n\t\tend\n\t\tindex += 1\n\tend\n\t# Encode\
    \ message with key (2)\n\tencoded_message = \"\"\n\tindex = 0\n\tdecoded_message.length.times\
    \ do\n\t\tcharacter = decoded_message[index]\n\t\tif is_vowel?(character)\n\t\t\
    \tencoded_message << decode_vowel(character)\n\t\telse\n\t\t\tencoded_message\
    \ << character\n\t\tend\n\t\tindex += 1\n\tend\n\tencoded_message\nend", "  encoder\
    \ = 'abcdefghijklmnopqrstuvwxyz'.split('')\n  new_message = ''\n  message.each_char\
    \ do |char|\n    if char == char.upcase\n      new_char = encoder[(encoder.index(char.downcase)\
    \ + 2) % 26].upcase\n    else\n      new_char = encoder[(encoder.index(char) +\
    \ 2) % 26]\n    end\n    new_message += new_char\n  end\n  return new_message\n\
    end", "    result = []\n    alphabet = (\"a\"..\"z\").to_a\n    vowels = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n    message.each_char do |char|\n        if char.match(/[a-zA-Z]/)\n\
    \            # swap case\n            char.upcase! if char == char.downcase\n\
    \            char.downcase! if char == char.upcase\n            # if vowel\n \
    \           if vowels.include?(char)\n                current_index = alphabet.index(char)\n\
    \                new_index = current_index + 2\n                if new_index >\
    \ alphabet.length - 1\n                    new_index = new_index - alphabet.length\n\
    \                end\n                char = alphabet[new_index]\n           \
    \ end\n        end\n        result << char\n    end\n    result.join\nend", " \
    \   message.split(\"\").map{|letter| \n        if letter.upcase == letter \n \
    \           letter.downcase\n        else\n            letter.upcase\n       \
    \ end\n    }.join(\"\")\nend\nputs encode(\"test\")\nputs encode(\"This is a message\"\
    )", "  message = message.downcase.split(\"\")\n  result = []\n  vowels = %w(a\
    \ e i o u)\n  message.each do |letter|\n    if vowels.include?(letter)\n     \
    \ case letter\n      when \"a\"\n        result << \"c\"\n      when \"e\"\n \
    \       result << \"g\"\n      when \"i\"\n        result << \"k\"\n      when\
    \ \"o\"\n        result << \"m\"\n      when \"u\"\n        result << \"q\"\n\
    \      end\n    else\n      result << letter.upcase\n    end\n  end\n  result.join\n\
    end", "  vowels = \"aeiouAEIOU\"\n  encoded_msg = \"\"\n  alpha = (\"a\"..\"z\"\
    ).to_a\n  message.split(\"\").each do |char|\n    if vowels.include?(char)\n \
    \     index = alpha.index(char.downcase)\n      if index + 2 > 25\n        index\
    \ = (index + 2) - 26\n      else\n        index += 2\n      end\n      encoded_msg\
    \ += alpha[index]\n    elsif char == char.upcase\n      encoded_msg += char.downcase\n\
    \    else\n      encoded_msg += char.upcase\n    end\n  end\n  encoded_msg\nend",
  "    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = []\n    message.each_char\
    \ do |char|\n        if vowels.include?(char.downcase)\n            i = vowels.index(char.downcase)\n\
    \            i = (i + 2) % 5\n            result << vowels[i].upcase if char ==\
    \ char.upcase\n            result << vowels[i].downcase if char == char.downcase\n\
    \        else\n            result << char.upcase if char == char.downcase\n  \
    \          result << char.downcase if char == char.upcase\n        end\n    end\n\
    \    result.join\nend", "  # TODO: your code here\nend", "  alpha = (\"a\"..\"\
    z\").to_a\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  new_message = \"\"\
    \n  message.split(\"\").each do |letter|\n    if alpha.include?(letter)\n    \
    \  if letter == \"z\"\n        new_message << \"B\"\n      elsif letter == \"\
    Z\"\n        new_message << \"b\"\n      elsif letter == letter.upcase\n     \
    \   new_message << alpha[alpha.index(letter.downcase) + 2].upcase\n      elsif\
    \ vowels.include?(letter)\n        new_message << alpha[alpha.index(letter) +\
    \ 2]\n      else\n        new_message << letter\n      end\n    else\n      new_message\
    \ << letter\n    end\n  end\n  new_message\nend", "  message = message.split('')\n\
    \  message.map! do |char|\n    if char.match(/[aeiou]/i)\n      char = char.next.next\n\
    \    elsif char.match(/[a-z]/i)\n      char = char.next\n    else\n      char\n\
    \    end\n  end\n  message.join('')\nend", "\t\n\tmessage.each_char do |char|\n\
    \t\tif char.ord >= 65 && char.ord <= 90\n\t\t\tencoded_char = char.ord + 2\n\t\
    \t\tif encoded_char > 90\n\t\t\t\tencoded_char = 65 + (encoded_char - 91)\n\t\t\
    \tend\n\t\t\tprint encoded_char.chr\n\t\telsif char.ord >= 97 && char.ord <= 122\n\
    \t\t\tencoded_char = char.ord + 2\n\t\t\tif encoded_char > 122\n\t\t\t\tencoded_char\
    \ = 97 + (encoded_char - 123)\n\t\t\tend\n\t\t\tprint encoded_char.chr\n\t\telse\n\
    \t\t\tprint char\n\t\tend\n\tend\n\t\nend", "  message.downcase!\n  alpha = ('a'..'z').to_a\n\
    \  message.split('').map do |char|\n    letter = char\n    if alpha.include?(char)\n\
    \      if char == 'z'\n        letter = 'b'\n      elsif char == 'y'\n       \
    \ letter = 'a'\n      else\n        letter = alpha[alpha.index(char) + 2]\n  \
    \    end\n    end\n    char == char.upcase ? letter.upcase : letter\n  end.join('')\n\
    end", "\tmessage = message.split(\"\")\n\tmessage.each do |char|\n\t\tcase char.downcase\n\
    \t\twhen \"a\"\n\t\t\tchar.replace \"c\"\n\t\twhen \"e\"\n\t\t\tchar.replace \"\
    g\"\n\t\twhen \"i\"\n\t\t\tchar.replace \"k\"\n\t\twhen \"o\"\n\t\t\tchar.replace\
    \ \"q\"\n\t\twhen \"u\"\n\t\t\tchar.replace \"s\"\n\t\telse\n\t\t\tif char.ord\
    \ <= 122 && char.ord >= 97\n\t\t\t\tchar.replace (char.ord+2).chr\n\t\t\tend\n\
    \t\tend\n\tend\n\tmessage.join\nend", "  message.split.map do |word|\n    word.split('').map\
    \ { |char| (char.ord.between?(65,90) || char.ord.between?(97,122)) ? ((char.ord\
    \ + 2) % 122 % 90 % 65).chr : char }.join\n  end.join(' ')\nend", "  letters =\
    \ ('a'..'z').to_a\n  alphabet = ('a'..'z').to_a\n  vowels = %w[a e i o u]\n  encoded_message\
    \ = ''\n  message.split('').each do |char|\n    if vowels.include?(char.downcase)\n\
    \      letter_index = alphabet.index(char.downcase)\n      encoded_message +=\
    \ letters[letter_index + 2]\n    else\n      letter_index = alphabet.index(char.downcase)\n\
    \      encoded_message += letters[letter_index].upcase\n    end\n  end\n  encoded_message\n\
    end", "    letters = message.split(\"\")\n    letters.map! do |letter|\n     \
    \   if letter.downcase == \"a\"\n            \"c\"\n        elsif letter.downcase\
    \ == \"e\"\n            \"g\"\n        elsif letter.downcase == \"i\"\n      \
    \      \"k\"\n        elsif letter.downcase == \"o\"\n            \"q\"\n    \
    \    elsif letter.downcase == \"u\"\n            \"y\"\n        elsif letter.match(/[a-z]/)\n\
    \            shift_letter(letter)\n        else\n            letter\n        end\n\
    \    end\n    return letters.join(\"\")\nend", "\tvowels = \"AEIOUaeiou\"\n\t\
    char_array = message.split(\"\")\n\tmessage = \"\"\n\tchar_array.each do |char|\n\
    \t\tif vowels.include?(char)\n\t\t\tif char == \"z\"\n\t\t\t\tmessage << \"b\"\
    \n\t\t\telsif char == \"Z\"\n\t\t\t\tmessage << \"B\"\n\t\t\telsif char == \"\
    u\"\n\t\t\t\tmessage << \"w\"\n\t\t\telsif char == \"U\"\n\t\t\t\tmessage << \"\
    W\"\n\t\t\telse\n\t\t\t\tmessage << (char.ord + 2).chr\n\t\t\tend\n\t\telsif char\
    \ == char.upcase\n\t\t\tmessage << char.downcase\n\t\telsif char == char.downcase\n\
    \t\t\tmessage << char.upcase\n\t\telse\n\t\t\tmessage << char\n\t\tend\n\tend\n\
    \tmessage\nend", "  char_array = message.downcase.split('')\n  swap_array = char_array.map\
    \ do |char|\n    if char == \"a\"\n      char = \"c\"\n    elsif char == \"e\"\
    \n      char = \"g\"\n    elsif char == \"i\"\n      char = \"k\"\n    elsif char\
    \ == \"o\"\n      char = \"q\"\n    elsif char == \"u\"\n      char = \"s\"\n\
    \    else\n      char\n    end\n  end\n  swap_array.join.upcase\nend", "  # Define\
    \ a hash of vowels to replace (and their replacement)\n  vowel_hash = { \"a\"\
    \ => \"c\", \"e\" => \"g\", \"i\" => \"k\", \"o\" => \"q\", \"u\" => \"w\" }\n\
    \  # Define the alphabet in an array\n  alpha = (\"a\"..\"z\").to_a\n  encoded_message\
    \ = \"\"\n  message.downcase.each_char do |char|\n    if alpha.include?(char)\n\
    \      if vowel_hash.include?(char)\n        encoded_message << vowel_hash[char]\n\
    \      else\n        encoded_message << char\n      end\n    else\n      encoded_message\
    \ << char\n    end\n  end\n  return encoded_message.swapcase\nend", "\tputs message.gsub(/[aeiou]/i,\
    \ {\n\t\t\"a\" => \"c\",\n\t\t\"e\" => \"g\",\n\t\t\"i\" => \"k\",\n\t\t\"o\"\
    \ => \"q\",\n\t\t\"u\" => \"w\",\n\t\t\"A\" => \"C\",\n\t\t\"E\" => \"G\",\n\t\
    \t\"I\" => \"K\",\n\t\t\"O\" => \"Q\",\n\t\t\"U\" => \"W\"\n\t\t})\nend", "  alphabet\
    \ = ('a'..'z').to_a\n  vovwels = %w[a e i o u]\n  result = ''\n  message.split('').each\
    \ do |char|\n    if vovwels.include?(char.downcase)\n      pos = alphabet.index(char.downcase)\n\
    \      result += alphabet[pos + 2]\n    else\n      result += char.swapcase\n\
    \    end\n  end\n  result\nend", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ]\n  alphabet = (\"a\"..\"z\").to_a\n  result = \"\"\n  message.split(\"\").each\
    \ do |char|\n    if char.match(/[a-zA-Z]/)\n      if char == char.upcase\n   \
    \     char = char.downcase\n      else\n        char = char.upcase\n      end\n\
    \      if vowels.include?(char)\n        i = vowels.index(char)\n        if (i+2)\
    \ < 5\n          char = vowels[i+2]\n        else\n          char = vowels[(i+2)-5]\n\
    \        end\n      end\n    end\n    result += char\n  end\n  puts result\nend",
  "  alphabet = ('a'..'z').to_a\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  encoded_msg\
    \ = \"\"\n  message.each_char do |char|\n    if alphabet.include?(char)\n    \
    \  if vowels.include?(char)\n        encoded_msg += alphabet[(alphabet.index(char)\
    \ + 2) % alphabet.size]\n      else\n        encoded_msg += char.upcase\n    \
    \  end\n    else\n      encoded_msg += char\n    end\n  end\n  encoded_msg\nend",
  "  my_vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  message.each_char do |char|\n\
    \    if my_vowels.include?(char)\n      puts \"vowel\"\n    else\n      puts \"\
    consonant\"\n    end\n  end\nend", "  vowels = %w(a e i o u)\n  # .chars = .split(\"\
    \")\n  message.chars.map do |letter|\n    # if \"a\" or \"e\" or \"i\" or \"o\"\
    \ or \"u\" (is a vowel)\n    if vowels.include?(letter.downcase)\n      # find\
    \ next vowel 2 over\n      # put your code here\n      # \"HI\".index(\"I\") =>\
    \ 2\n      # \"HI\".index(\"Z\") => nil\n      # next_vowel(\"H\") => \"J\"\n\
    \      # \"HI\".index(\"J\") => 1\n      # \"HI\".index(\"H\") => 0\n      # \"\
    HI\".index(\"J\") => 1\n      next_vowel(letter)\n    else\n      # .next = .succ\
    \ = .chr + 1 \n      # (ASCII)\n      letter.swapcase\n    end\n  end.join(\"\"\
    )\nend", "    message.split(\"\").map do |letter|\n        if vowel?(letter)\n\
    \            letter = vowel_shift(letter)\n        else\n            letter.upcase\
    \ == letter ? letter.downcase : letter.upcase\n        end\n    end.join(\"\"\
    )\nend", "\tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tresult = \"\"\n\t\
    message.each_char do |letter|\n\t\tif vowels.include?(letter.downcase)\n\t\t\t\
    replacement = letter.downcase\n\t\t\tif replacement == \"u\"\n\t\t\t\treplacement\
    \ = \"a\"\n\t\t\telse\n\t\t\t\treplacement = vowels[vowels.index(replacement)\
    \ + 1]\n\t\t\tend\n\t\t\treplacement = replacement.upcase if letter.upcase ==\
    \ letter\n\t\t\tresult += replacement\n\t\telse\n\t\t\tif letter.upcase == letter\n\
    \t\t\t\tresult += letter.downcase\n\t\t\telse\n\t\t\t\tresult += letter.upcase\n\
    \t\t\tend\n\t\tend\n\tend\n\tresult\nend", "  alphabet = ('a'..'z').to_a\n  vowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n  coded_message = ''\n  message.each_char do |char|\n\
    \    if vowels.include?(char.downcase)\n      shifted_index = alphabet.index(char.downcase)\
    \ + 2\n      new_letter = alphabet[shifted_index % 26]\n      coded_message +=\
    \ new_letter\n    else\n      coded_message += char.swapcase\n    end\n  end\n\
    \  coded_message\nend", "  vowels = \"aeiou\"\n  alphabet = (\"a\"..\"z\").to_a\n\
    \  new_message = \"\"\n  message.each_char do |c|\n    if vowels.include?(c.downcase)\n\
    \      new_message += alphabet[(alphabet.index(c.downcase) + 2) % 26]\n    else\n\
    \      new_message += c.swapcase\n    end\n  end\n  new_message\nend", "\tvowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n\tencoded_message = \"\"\n\tmessage.each_char do\
    \ |char|\n\t\tif vowels.include?(char.downcase)\n\t\t\tnew_letter = char.next\n\
    \t\t\tnew_letter = new_letter.next\n\t\t\tencoded_message += new_letter\n\t\t\
    else\n\t\t\tencoded_message += char.swapcase\n\t\tend\n\tend\n\tencoded_message\n\
    end", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  encoded_message = \"\"\
    \n  message.chars.each do |letter|\n    if letter == letter.upcase\n      if vowels.include?(letter.downcase)\n\
    \        encoded_message += (vowels[(vowels.index(letter.downcase) + 2) % 5]).upcase\n\
    \      else\n        encoded_message += letter.downcase\n      end\n    else\n\
    \      if vowels.include?(letter)\n        encoded_message += vowels[(vowels.index(letter)\
    \ + 2) % 5]\n      else\n        encoded_message += letter.upcase\n      end\n\
    \    end\n  end\n  encoded_message\nend", "  output = \"\"\n  swap = { \"a\" =>\
    \ \"c\", \"e\" => \"g\", \"i\" => \"k\", \"o\" => \"q\", \"u\" => \"w\", \"y\"\
    \ => \"a\", \"b\" => \"d\", \"c\" => \"e\", \"d\" => \"f\", \"f\" => \"h\", \"\
    g\" => \"j\", \"h\" => \"l\", \"j\" => \"n\", \"k\" => \"p\", \"l\" => \"r\",\
    \ \"m\" => \"t\", \"n\" => \"v\", \"p\" => \"x\", \"q\" => \"z\", \"r\" => \"\
    b\", \"s\" => \"d\", \"t\" => \"f\", \"v\" => \"h\", \"w\" => \"j\", \"x\" =>\
    \ \"l\", \"z\" => \"n\" }\n  message.each_char do |char|\n    if swap.include?(char.downcase)\n\
    \      output << swap[char.downcase]\n    else\n      output << char\n    end\n\
    \  end\n  output\nend", "  new_message = []\n  message.split('').each do |letter|\n\
    \    if letter == letter.upcase\n      new_message << letter.downcase\n    else\n\
    \      new_message << letter.upcase\n    end\n  end\n  new_message.join\nend",
  "\tencoded_message = \"\"\n\tmessage.downcase.each_char do |char|\n\t\tif char ==\
    \ \" \"\n\t\t\tencoded_message << \" \"\n\t\telsif char == \"z\"\n\t\t\tencoded_message\
    \ << \"b\"\n\t\telsif char == \"a\"\n\t\t\tencoded_message << \"c\"\n\t\telsif\
    \ char == \"e\"\n\t\t\tencoded_message << \"g\"\n\t\telsif char == \"i\"\n\t\t\
    \tencoded_message << \"k\"\n\t\telsif char == \"o\"\n\t\t\tencoded_message <<\
    \ \"q\"\n\t\telsif char == \"u\"\n\t\t\tencoded_message << \"w\"\n\t\telse\n\t\
    \t\tencoded_message << char.next\n\t\tend\n\tend\n\tencoded_message.upcase\nend",
  "\tarr = message.split(\"\")\n\ta = 'a'.ord\n\tz = 'z'.ord\n\tA = 'A'.ord\n\tZ =\
    \ 'Z'.ord\n\tarr.each_with_index do |char,index|\n\t\tif char == 'e' || char ==\
    \ 'E'\n\t\t\tchar.replace 'g'\n\t\telsif char == 'a' || char == 'A'\n\t\t\tchar.replace\
    \ 'c'\n\t\telsif char == 'i' || char == 'I'\n\t\t\tchar.replace 'k'\n\t\telsif\
    \ char == 'o' || char == 'O'\n\t\t\tchar.replace 'm'\n\t\telsif char == 'u' ||\
    \ char == 'U'\n\t\t\tchar.replace 'q'\n\t\telsif char == 'y' || char == 'Y'\n\t\
    \t\tchar.replace 'a'\n\t\telsif a <= char.ord && char.ord <= z\n\t\t\tchar.replace\
    \ ((char.ord + 2).chr)\n\t\telsif A <= char.ord && char.ord <= Z\n\t\t\tchar.replace\
    \ ((char.ord + 2).chr)\n\t\tend\n\tend\n\treturn arr.join\nend", "    vowels =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    encoded_message = \"\"\n    message.each_char\
    \ do |char|\n        if vowels.include?(char.downcase)\n            if char.upcase\
    \ == char\n                if char == \"U\"\n                    encoded_message\
    \ += \"A\"\n                else\n                    encoded_message += (char.ord\
    \ + 2).chr.upcase\n                end\n            else\n                if char\
    \ == \"u\"\n                    encoded_message += \"a\"\n                else\n\
    \                    encoded_message += (char.ord + 2).chr\n                end\n\
    \            end\n        elsif char.upcase == char\n            encoded_message\
    \ += char.downcase\n        else\n            encoded_message += char.upcase\n\
    \        end\n    end\n    return encoded_message\nend", "  encoded_message =\
    \ \"\"\n  message.split(\"\").each do |char|\n    if char.match(/[A-Z]/)\n   \
    \   encoded_message << char.downcase\n    elsif char.match(/[a-z]/)\n      encoded_message\
    \ << char.upcase\n    else\n      encoded_message << char\n    end\n  end\n  encoded_message\n\
    end", "  replace_case(message)\n  replace_vowels(message)\nend", "  cypher = message.downcase.gsub(/[aeiou]/,\
    \ 'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 's')\n  cypher.tr('a-z',\
    \ 'b-za')\nend", "  new_message = \"\"\n  message.split(\"\").each do |letter|\n\
    \    if /[[:lower:]]/.match(letter)\n      if letter == \"z\"\n        new_message\
    \ << \"b\"\n      elsif letter == \"x\"\n        new_message << \"d\"\n      elsif\
    \ letter == \"y\"\n        new_message << \"e\"\n      else\n        new_message\
    \ << (letter.ord + 2).chr\n      end\n    elsif /[[:upper:]]/.match(letter)\n\
    \      if letter == \"Z\"\n        new_message << \"B\"\n      elsif letter ==\
    \ \"X\"\n        new_message << \"D\"\n      elsif letter == \"Y\"\n        new_message\
    \ << \"E\"\n      else\n        new_message << (letter.ord + 2).chr\n      end\n\
    \    else\n      new_message << letter\n    end\n  end\n  new_message\nend", "\t\
    text = message.split(\"\")\n\t\n\tletters = [\"a\", \"b\", \"c\", \"d\", \"e\"\
    , \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n\tvowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\t\n\ttext.each_with_index do |l, index|\n\
    \t\tif l == l.upcase\n\t\t\tl.downcase!\n\t\telse\n\t\t\tl.upcase!\n\t\tend\n\t\
    \tif vowels.include?(l)\n\t\t\ttext[index] = letters[letters.index(l) + 2]\n\t\
    \tend\n\tend\n\treturn text.join(\"\")\nend", "\tencode_message = \"\"\n\tvowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n\talphabet = ('a'..'z').to_a\n\t\n\tmessage.chars.each\
    \ do |letter|\n\t\tif alphabet.include?(letter)\n\t\t\tif vowels.include?(letter)\n\
    \t\t\t\tswapped_vowel = vowels[(vowels.index(letter) + 2) % 5]\n\t\t\t\tif vowel.lowercase?\n\
    \t\t\t\t\tencode_message += swapped_vowel.upcase\n\t\t\t\telse\n\t\t\t\t\tencode_message\
    \ += swapped_vowel.downcase\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif letter.lowercase?\n\
    \t\t\t\t\tencode_message += letter.upcase\n\t\t\t\telse\n\t\t\t\t\tencode_message\
    \ += letter.downcase\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tencode_message +=\
    \ letter\n\t\tend\n\tend\n\tencode_message\nend", "  message = message.split(\"\
    \ \").join(\"\")\n  message = message.split(\"\")\n  result = message.map do |letter|\n\
    \    if letter.upcase == letter\n      letter.downcase\n    else\n      letter.upcase\n\
    \    end\n  end\n  result = result.join(\"\")\n  result = result.split(\"\")\n\
    \  final = result.map do |letter|\n    if \"aeiou\".include?(letter)\n      num\
    \ = letter.ord + 2\n      num.chr\n    else\n      letter\n    end\n  end\n  final.join(\"\
    \")\nend", "  message.split(\"\").each_with_index do |char, i|\n    if char ==\
    \ char.downcase\n      message[i] = char.upcase\n    else\n      message[i] =\
    \ char.downcase\n    end\n    if [\"a\", \"e\", \"i\", \"o\", \"u\"].include?(message[i].downcase)\n\
    \      if message[i].downcase == \"u\"\n        message[i] = \"a\"\n      else\n\
    \        message[i] = message[i].next.next\n      end\n    end\n  end\n  message\n\
    end", "  # your code here\nend", "\tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ]\n\tmessage.each_char.map do |letter|\n\t\tif vowels.include?(letter.downcase)\n\
    \t\t\tindex = vowels.index(letter.downcase)\n\t\t\tindex = (index + 2) % 5\n\t\
    \t\tletter = vowels[index]\n\t\tend\n\t\tletter.downcase == letter ? letter.upcase\
    \ : letter.downcase\n\tend.join\nend", "    # code here\n    vowels = \"aeiou\"\
    \n    message.tr(\"A-Za-z\", \"N-ZA-Mn-za-m\").tr(vowels, vowels.chars.rotate(2).join)\n\
    end", "  # your code here\nend", "  message.downcase!\n  alphabet = ('a'..'z').to_a\n\
    \  new_message = \"\"\n  message.each_char do |char|\n    index = alphabet.index(char)\n\
    \    if index\n      index += 2\n      if index > alphabet.length\n        index\
    \ -= alphabet.length\n      end\n      new_message += alphabet[index]\n    else\n\
    \      new_message += char\n    end\n  end\n  new_message.upcase!\nend", "  a_to_z\
    \ = ('a'..'z').to_a\n  vowels = %w[a e i o u]\n  message.split('').map do |char|\n\
    \    if vowels.include?(char.downcase)\n      a_to_z[(a_to_z.index(char.downcase)\
    \ + 2) % 26]\n    else\n      char\n    end\n  end.join('')\nend", "  vowels =\
    \ \"AEIOUaeiou\"\n  encoded_message = []\n  message.split(\"\").each do |letter|\n\
    \    if vowels.include?(letter)\n      letter_index = vowels.index(letter)\n \
    \     encoded_message << vowels[letter_index + 2]\n    else\n      encoded_message\
    \ << letter\n    end\n  end\n  return encoded_message.join(\"\").swapcase\nend\n\
    puts encode(\"This is a message\")", "  characters = message.split(\"\")\n  encoding\
    \ = []\n  characters.each do |character|\n    if character == character.downcase\n\
    \      encoding << character.upcase\n    else\n      encoding << character.downcase\n\
    \    end\n  end\n  encoding.join(\"\")\nend", "  key = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n  result = \"\"\n  message.downcase.split(\"\").each do |letter|\n\
    \    if key.include?(letter)\n      code = key.index(letter) + 2\n      if code\
    \ < key.length\n        result += key[code]\n      else\n        result += key[0]\n\
    \      end\n    else\n      result += letter\n    end\n  end\n  result.upcase\n\
    end", "  alpha = ('a'..'z').to_a\n  alpha.index('a')\n  alpha.index('b')\n  alpha.index('c')\n\
    \  alpha.index('d')\n  alpha.index('e')\n  alpha.index('f')\n  alpha.index('g')\n\
    \  alpha.index('h')\n  alpha.index('i')\n  alpha.index('j')\n  alpha.index('k')\n\
    \  alpha.index('l')\n  alpha.index('m')\n  alpha.index('n')\n  alpha.index('o')\n\
    \  alpha.index('p')\n  alpha.index('q')\n  alpha.index('r')\n  alpha.index('s')\n\
    \  alpha.index('t')\n  alpha.index('u')\n  alpha.index('v')\n  alpha.index('w')\n\
    \  alpha.index('x')\n  alpha.index('y')\n  alpha.index('z')\n  vowels = ['a',\
    \ 'e', 'i', 'o', 'u']\n  encoded_message = ''\n  message.each_char do |char|\n\
    \    if alpha.include?(char)\n      if char == char.upcase\n        encoded_message\
    \ << char.downcase\n      else\n        encoded_message << char.upcase\n     \
    \ end\n    elsif vowels.include?(char)\n      alpha.index(char) + 2\n      alpha[alpha.index(char)\
    \ + 2]\n      encoded_message << alpha[alpha.index(char) + 2]\n    else\n    \
    \  encoded_message << char\n    end\n  end\n  encoded_message\nend", "  vowels\
    \ = 'aeiou'\n  new_string = ''\n  message.chars.each do |letter|\n    if letter\
    \ == letter.upcase\n      new_string << letter.downcase\n    else\n      new_string\
    \ << letter.upcase\n    end\n  end\n  new_string.tr(vowels, vowels[2, vowels.length]\
    \ + vowels[0, 2])\nend", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowels_hash\
    \ = {\n    \"a\" => \"c\",\n    \"e\" => \"g\",\n    \"i\" => \"k\",\n    \"o\"\
    \ => \"q\",\n    \"u\" => \"y\"\n  }\n  words = message.split(\" \")\n  new_words\
    \ = []\n  words.each do |word|\n    new_word = \"\"\n    word.each_char do |char|\n\
    \      if vowels.include?(char.downcase)\n        new_word += vowels_hash[char.downcase]\n\
    \      elsif char == char.upcase\n        new_word += char.downcase\n      else\n\
    \        new_word += char.upcase\n      end\n    end\n    new_words << new_word\n\
    \  end\n  new_words.join(\" \")\nend", "\t# Your Code Here\nend", "  consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n  vowels = \"aeiouAEIOU\"\n\
    \  new_message = \"\"\n  message.each_char do |character|\n    if consonants.include?(character)\n\
    \      new_message += character.swapcase\n    elsif vowels.include?(character)\n\
    \      new_message += vowels[(vowels.index(character) + 2) % vowels.length]\n\
    \    else\n      new_message += character\n    end\n  end\n  new_message\nend",
  "  vowels = \"aeiou\"\n  message.chars.map { |c|\n    if vowels.include?(c.downcase)\n\
    \      idx = vowels.index(c.downcase)\n      new_vowel = vowels[(idx + 2) % 5]\n\
    \      c.upcase == c ? new_vowel.upcase : new_vowel\n    else\n      c.upcase\
    \ == c ? c.downcase : c.upcase\n    end\n  }.join\nend\nputs encode(\"test\")\n\
    puts encode(\"This is a message\")", "  vowels = [\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"]\n  encoded_message = []\n  message.each_char do |c|\n    encoded_message\
    \ << (vowels.include?(c.downcase) ? letter_shift(c) : letter_shift(c).upcase)\n\
    \  end\n  encoded_message.join(\"\")\nend", "  letters = message.split(\"\")\n\
    \  numbers = letters.map { |l| l.ord }\n  swapped_case_numbers = numbers.map do\
    \ |n|\n    if n > 90\n      n - 32\n    elsif n > 64\n      n + 32\n    else\n\
    \      n\n    end\n  end\n  swapped_case_letters = swapped_case_numbers.map {\
    \ |n| n.chr }\n  vowels = %w(a e i o u)\n  encoded_letters = swapped_case_letters.map\
    \ do |l|\n    if vowels.include?(l)\n      vowels[(vowels.index(l) + 2) % 5]\n\
    \    else\n      l\n    end\n  end\n  encoded_letters.join(\"\")\nend", "\tvowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tnew_message = \"\"\n\tmessage.split(\"\
    \").each do |l|\n\t\tif vowels.include?(l.downcase)\n\t\t\tif l == \"u\"\n\t\t\
    \t\tnew_message << \"A\"\n\t\t\telsif l == \"U\"\n\t\t\t\tnew_message << \"A\"\
    \n\t\t\telse\n\t\t\t\tnew_message << vowels[vowels.index(l.downcase) + 2].upcase\
    \ if l == l.upcase\n\t\t\t\tnew_message << vowels[vowels.index(l.downcase) + 2]\
    \ if l == l.downcase\n\t\t\tend\n\t\telse\n\t\t\tif l == l.upcase\n\t\t\t\tnew_message\
    \ << l.downcase\n\t\t\telse\n\t\t\t\tnew_message << l.upcase\n\t\t\tend\n\t\t\
    end\n\tend\n\tnew_message\nend", "  # your code here\nend\n```", "\tmessage.split('').map\
    \ { |c| encode_char(c) }.join('')\nend", "  message.tr(\"a-zA-Z\", \"b-zaB-ZA\"\
    ).tr(\"aeiouAEIOU\", \"eouaiEOUAI\")\nend", "  message.downcase!\n  encoded_message\
    \ = \"\"\n  message.each_char do |character|\n    if character =~ /[a-z]/\n  \
    \    if character == \"z\"\n        encoded_message << \"b\"\n      elsif character\
    \ == \"y\"\n        encoded_message << \"a\"\n      else\n        encoded_message\
    \ << (character.ord + 2).chr\n      end\n    else\n      encoded_message << character\n\
    \    end\n  end\n  encoded_message.swapcase!\nend", "  message.tr(\"a-zA-Z\",\
    \ \"C-ZA-Bc-za-b\")\nend", "\talphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n\tvowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tmessage = message.split(\"\")\n\tencoded_message\
    \ = \"\"\n\tmessage.each do |letter|\n\t\tif alphabet.include?(letter)\n\t\t\t\
    if alphabet.index(letter) == 25\n\t\t\t\tletter = alphabet[0]\n\t\t\telsif alphabet.index(letter)\
    \ == 24\n\t\t\t\tletter = alphabet[1]\n\t\t\telse\n\t\t\t\tletter = alphabet[alphabet.index(letter)\
    \ + 2]\n\t\t\tend\n\t\t\tencoded_message << letter\n\t\telse\n\t\t\tencoded_message\
    \ << letter\n\t\tend\n\tend\n\tencoded_message\nend", "\tmessage.chars.map { |letter|\
    \ letter.next }.join('')\nend", "  #TODO write your code here\nend", "\tmessage.swapcase.tr(\"\
    aeiou\", \"eioua\")\nend", "  vowels = [ 'a', 'e', 'i', 'o', 'u' ]\n  encoding\
    \ = []\n  message.chars.each do |char|\n    if vowels.include?(char.downcase)\n\
    \      encoding << char.next.next.next\n    else\n      encoding << char.next\n\
    \    end\n  end\n  encoding.join.swapcase\nend", "  alpha = (\"a\"..\"z\").to_a\n\
    \  encoded_msg = []\n  message.split(\"\").each do |letter|\n    if letter ==\
    \ letter.upcase\n      letter = letter.downcase\n      letter = alpha[alpha.index(letter)\
    \ + 2].upcase\n    else\n      letter = alpha[alpha.index(letter) + 2]\n    end\n\
    \    encoded_msg << letter\n  end\n  encoded_msg.join(\"\")\nend", "\tencoded_message\
    \ = ''\n\tvowels = ['a', 'e', 'i', 'o', 'u']\n\tmessage.each_char do |c|\n\t\t\
    if vowels.include?(c.downcase)\n\t\t\tencoded_message << encode_vowel(c)\n\t\t\
    else\n\t\t\tencoded_message << encode_letter(c)\n\t\tend\n\tend\n\treturn encoded_message\n\
    end", "  counter = 0\n  encoded_message = \"\"\n  message.each_char do |char|\n\
    \    if char == char.upcase\n      encoded_message += char.downcase\n    else\n\
    \      encoded_message += char.upcase\n    end\n    if [\"a\", \"e\", \"i\", \"\
    o\", \"u\"].include?(char.downcase)\n      encoded_message[counter] = char.next.next\n\
    \    end\n    counter += 1\n  end\n  encoded_message\nend", "\t\n\tmessage.chars.each_with_index\
    \ do |char, index|\n\t\tif char == char.upcase\n\t\t\tmessage[index] = char.downcase\n\
    \t\telse\n\t\t\tmessage[index] = char.upcase\n\t\tend\n\tend", "\talphabet = (\"\
    a\"..\"z\").to_a\n\tvowels = %w(a e i o u)\n\twords = message.split(\" \")\n\t\
    # p words\n\twords.map! do |word|\n\t\tword.split(\"\").map! do |letter|\n\t\t\
    \t# p alphabet.index(letter)\n\t\t\t# p alphabet.length\n\t\t\tif vowels.include?(letter)\n\
    \t\t\t\tif alphabet.index(letter) + 2 > alphabet.length - 1\n\t\t\t\t\tletter\
    \ = alphabet[alphabet.index(letter) + 2 - alphabet.length]\n\t\t\t\telse\n\t\t\
    \t\t\tletter = alphabet[alphabet.index(letter) + 2]\n\t\t\t\tend\n\t\t\telse\n\
    \t\t\t\tletter\n\t\t\tend\n\t\tend\n\t\tword.join(\"\")\n\tend\n\twords.join(\"\
    \ \")\nend\np encode(\"this is a message\")", "\t# split the message into an array\
    \ of characters\n\t# map each character to its replacement character\n\t# return\
    \ the new string\n\tmessage.split('').map { |c| encode_char(c) }.join\nend", " \
    \ output = \"\"\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  message.each_char do\
    \ |letter|\n    if vowels.include?(letter.downcase)\n      case letter.downcase\n\
    \      when 'a'\n        letter = 'c'\n      when 'e'\n        letter = 'g'\n\
    \      when 'i'\n        letter = 'k'\n      when 'o'\n        letter = 'q'\n\
    \      when 'u'\n        letter = 'y'\n      end\n    end\n    output += letter.swapcase\n\
    \  end\n  output\nend", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    vowels\
    \ = \"aeiou\"\n    result = \"\"\n    message.each_char do |char|\n        if\
    \ vowels.include?(char.downcase)\n            index = alphabet.index(char.downcase)\n\
    \            result += alphabet[index + 2]\n        elsif alphabet.include?(char.downcase)\n\
    \            result += char.swapcase\n        else\n            result += char\n\
    \        end\n    end\n    result\nend", "  letters = (\"a\"..\"z\").to_a\n  vowels\
    \ = %w[a e i o u]\n  answer = []\n  message.split(\"\").each do |letter|\n   \
    \ if vowels.include?(letter.downcase)\n      if letters.index(letter.downcase)\
    \ + 2 < letters.length - 1\n        answer << letters[letters.index(letter.downcase)\
    \ + 2]\n      else\n        answer << letters[letters.index(letter.downcase) -\
    \ 24]\n      end\n    else\n      answer << letter.upcase\n    end\n  end\n  answer.join\n\
    end", "  message = message.downcase.split(\"\")\n  vowels = %w[a e i o u]\n  message.each_with_index\
    \ do |letter, index|\n    if vowels.include?(letter)\n      message[index] = (letter.ord\
    \ + 2).chr\n    end\n  end\n  message.join(\"\").upcase\nend", "\tmessage.swapcase.tr('A-Za-z',\
    \ 'CDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ')\nend", "\talphabet = 'abcdefghijklmnopqrstuvwxyz'.split('')\n\
    \tvowels = %w(a e i o u)\n\tvowels = vowels.map do |vowel|\n\t\tvowel.next.next\n\
    \tend\n\tresult = []\n\tmessage.each_char do |letter|\n\t\tif vowels.include?(letter.downcase)\n\
    \t\t\tresult << vowels[vowels.index(letter.downcase)]\n\t\telsif alphabet.include?(letter.downcase)\n\
    \t\t\tresult << alphabet[alphabet.index(letter.downcase)].next\n\t\telse\n\t\t\
    \tresult << letter\n\t\tend\n\tend\n\tresult.join\nend", "  alphabet = (\"a\"\
    ..\"z\").to_a\n  encrypted_message = message.downcase.split(\"\").map do |letter|\n\
    \    if !alphabet.include?(letter)\n      letter\n    elsif letter == \"z\"\n\
    \      \"b\"\n    elsif letter == \"y\"\n      \"a\"\n    else\n      alphabet[alphabet.index(letter)\
    \ + 2]\n    end\n  end\n  encrypted_message.join(\"\").upcase\nend", "  message\
    \ = message.chars.map do |letter|\n    if (\"a\"..\"z\").include?(letter)\n  \
    \    letter.next.next\n    elsif (\"A\"..\"Z\").include?(letter)\n      letter.next.next.upcase\n\
    \    else\n      letter\n    end\n  end\n  message.join\nend", "  new_message\
    \ = []\n  message.each_char do |letter|\n    if ('a'..'z').include?(letter)\n\
    \      if ('aeiou').include?(letter)\n        letter = letter.next.next\n    \
    \  else\n        letter = letter.next\n      end\n    elsif ('A'..'Z').include?(letter)\n\
    \      if ('AEIOU').include?(letter)\n        letter = letter.next.next\n    \
    \  else\n        letter = letter.next\n      end\n    end\n    new_message <<\
    \ letter\n  end\n  new_message.join\nend", "\tmessage.downcase.tr('a-z', 'c-za-b')\n\
    end", "  alphabet = ('a'..'z').to_a\n  new_message = \"\"\n  message.each_char\
    \ do |c|\n    if alphabet.include?(c.downcase)\n      index = alphabet.index(c.downcase)\n\
    \      new_index = index + 2\n      new_index -= 26 if new_index > 25\n      if\
    \ 'aeiou'.include?(c.downcase)\n        new_message += alphabet[new_index].upcase\n\
    \      else\n        new_message += alphabet[new_index]\n      end\n    else\n\
    \      new_message += c\n    end\n  end\n  new_message\nend", "  message = message.split(\"\
    \")\n  message.map! do |letter|\n    if letter.match(/[^a-zA-Z]/)\n      letter\n\
    \    elsif letter.upcase == letter\n      letter.downcase\n    else\n      letter.upcase\n\
    \    end\n  end\n  message.map! do |letter|\n    if letter.match(/[aeiou]/)\n\
    \      vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n      index = vowels.index(letter)\n\
    \      if index < 4\n        vowels[index + 2]\n      else\n        vowels[0]\n\
    \      end\n    else\n      letter\n    end\n  end\n  return message.join(\"\"\
    )\nend", "\tvowels = \"aeiou\"\n\tnew_message = \"\"\n\tmessage.downcase.each_char\
    \ do |char|\n\t\tif vowels.include?(char)\n\t\t\tindex = vowels.index(char)\n\t\
    \t\tnew_message += vowels[(index + 2) % 5]\n\t\telse\n\t\t\tnew_message += char\n\
    \t\tend\n\tend\n\treturn new_message.upcase\nend", "  message = message.upcase.split(\"\
    \")\n  vowels = %w[A E I O U]\n  result = \"\"\n  message.each do |letter|\n \
    \   case letter\n    when 'A'\n      result += 'C'\n    when 'E'\n      result\
    \ += 'G'\n    when 'I'\n      result += 'K'\n    when 'O'\n      result += 'Q'\n\
    \    when 'U'\n      result += 'S'\n    else\n      result += letter\n    end\n\
    \  end\n  result\nend", "  vowels = \"aeiouAEIOU\"\n  alpha = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  hash = {}\n  alpha.each_char.with_index do |letter, index|\n    hash[letter]\
    \ = index\n  end\n  result = []\n  message.each_char do |letter|\n    if vowels.include?(letter)\n\
    \      result << alpha[(hash[letter] + 2) % 26]\n    else\n      result << letter.swapcase\n\
    \    end\n  end\n  result.join(\"\")\nend", "  return message.gsub(/[a-zA-Z]/,\
    \ \n    \"a\" => \"c\", \"A\" => \"C\", \n    \"e\" => \"g\", \"E\" => \"G\",\
    \ \n    \"i\" => \"k\", \"I\" => \"K\", \n    \"o\" => \"q\", \"O\" => \"Q\",\
    \ \n    \"u\" => \"s\", \"U\" => \"S\", \n    \"y\" => \"a\", \"Y\" => \"A\",\
    \ \n    \"b\" => \"d\", \"B\" => \"D\", \n    \"c\" => \"e\", \"C\" => \"E\",\
    \ \n    \"d\" => \"f\", \"D\" => \"F\", \n    \"f\" => \"h\", \"F\" => \"H\",\
    \ \n    \"g\" => \"i\", \"G\" => \"I\", \n    \"h\" => \"j\", \"H\" => \"J\",\
    \ \n    \"j\" => \"l\", \"J\" => \"L\", \n    \"k\" => \"m\", \"K\" => \"M\",\
    \ \n    \"l\" => \"n\", \"L\" => \"N\", \n    \"m\" => \"o\", \"M\" => \"O\",\
    \ \n    \"n\" => \"p\", \"N\" => \"P\", \n    \"p\" => \"r\", \"P\" => \"R\",\
    \ \n    \"q\" => \"t\", \"Q\" => \"T\", \n    \"r\" => \"u\", \"R\" => \"U\",\
    \ \n    \"s\" => \"v\", \"S\" => \"V\", \n    \"t\" => \"w\", \"T\" => \"W\",\
    \ \n    \"v\" => \"x\", \"V\" => \"X\", \n    \"w\" => \"y\", \"W\" => \"Y\",\
    \ \n    \"x\" => \"z\", \"X\" => \"Z\", \n    \"z\" => \"b\", \"Z\" => \"B\")\n\
    end", "\tmessage.downcase.gsub(/[aeiou]/, 'a' => 'c', 'e' => 'g', 'i' => 'k',\
    \ 'o' => 'q', 'u' => 's').upcase\nend", "\t\t\n\t\t#let's setup a hash that stores\
    \ the vowels in English alphabet\n\t\tvowels = {\"a\" => \"c\", \"e\" => \"g\"\
    , \"i\" => \"k\", \"o\" => \"q\", \"u\" => \"y\"}\n\t\tencoded_message = \"\"\n\
    \t\t# loop through message string\n\t\tmessage.each_char do |char|\n\t\t\t# check\
    \ if the character is alphabetic\n\t\t\tif char.match(/[a-zA-Z]/)\n\t\t\t\t# check\
    \ if the character is a vowel\n\t\t\t\tif vowels.include?(char.downcase)\n\t\t\
    \t\t\t# take the character from the vowels hash, swap case, push to new string\n\
    \t\t\t\t\tencoded_message << vowels[char.downcase].swapcase\n\t\t\t\telse\n\t\t\
    \t\t\t# swap case and push to new string\n\t\t\t\t\tencoded_message << char.swapcase\n\
    \t\t\t\tend\n\t\t\telse\n\t\t\t\t# char is not alphabetic and should not be changed,\
    \ push to new string\n\t\t\t\tencoded_message << char\n\t\t\tend\n\t\tend\n\t\t\
    # return new string\n\t\tencoded_message\nend", "\tmessage = message.upcase\n\t\
    vowels = %w(A E I O U)\n\tnew_string = ''\n\tmessage.each_char do |char|\n\t\t\
    if vowels.include?(char)\n\t\t\tnew_string += encode_vowel(char)\n\t\telse\n\t\
    \t\tnew_string += char\n\t\tend\n\tend\n\treturn new_string\nend", "    letters\
    \ = message.split(\"\")\n    alphabet = (\"a\"..\"z\").to_a\n    vowels = ['a',\
    \ 'e', 'i', 'o', 'u']\n    encoded_message = \"\"\n    letters.each do |letter|\n\
    \        if vowels.include?(letter)\n            encoded_message += alphabet[alphabet.index(letter)\
    \ + 2]\n        elsif letter == letter.upcase\n            if vowels.include?(letter.downcase)\n\
    \                encoded_message += alphabet[alphabet.index(letter.downcase) +\
    \ 2].upcase\n            else\n                encoded_message += letter.downcase\n\
    \            end\n        else\n            encoded_message += letter.upcase\n\
    \        end\n    end\n    encoded_message\nend", "  message.tr('a-zA-Z', 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n\
    end", "  lowercase = (\"a\"..\"z\").to_a\n  uppercase = (\"A\"..\"Z\").to_a\n\
    \  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  message = message.split(\"\"\
    )\n  new_message = \"\"\n  message.each do |letter|\n    if lowercase.include?(letter)\n\
    \      index = lowercase.index(letter)\n      if letter == \"z\"\n        new_message\
    \ << \"b\"\n      elsif letter == \"y\"\n        new_message << \"a\"\n      elsif\
    \ vowels.include?(letter)\n        new_message << vowels[index+2]\n      else\n\
    \        new_message << lowercase[index+2]\n      end\n    elsif uppercase.include?(letter)\n\
    \      index = uppercase.index(letter)\n      if letter == \"Z\"\n        new_message\
    \ << \"B\"\n      elsif letter == \"Y\"\n        new_message << \"A\"\n      elsif\
    \ vowels.include?(letter.downcase)\n        new_message << vowels[index+2].upcase\n\
    \      else\n        new_message << uppercase[index+2]\n      end\n    else\n\
    \      new_message << letter\n    end\n  end\n  new_message\nend", "  alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  new_string = \"\"\n  message.each_char do\
    \ |char|\n    if alphabet.include?(char.downcase)\n      new_string << encode_char(char,\
    \ alphabet)\n    else\n      new_string << char\n    end\n  end\n  new_string\n\
    end", "  # your code here\nend", "  swaped_case = ''\n  (0...message.length).each\
    \ do |i|\n    if message[i] =~ /[a-z]/\n      swaped_case << message[i].upcase\n\
    \    elsif message[i] =~ /[A-Z]/\n      swaped_case << message[i].downcase\n \
    \   else\n      swaped_case << message[i]\n    end\n  end\n  (0...swaped_case.length).each\
    \ do |i|\n    if 'aeiou'.include?(swaped_case[i])\n      swaped_case[i] = ('a'..'z').to_a[(('a'..'z').to_a.index(swaped_case[i])\
    \ + 2) % 26]\n    end\n  end\n  swaped_case\nend", "  i = 0\n  new = []\n  message.split('').each\
    \ do |letter|\n    if vowel?(letter)\n      new << letter.next.next\n    else\n\
    \      new << letter\n    end\n  end\n  return new.join.upcase.gsub('{', 'a').gsub('|',\
    \ 'e').gsub('}', 'i').gsub('~', 'o').gsub('@', 'u')\nend", "  swap_case(vowel_shift(message))\n\
    end", " \nend", "  vowels = \"aeiouAEIOU\"\n  alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  encoded_message = \"\"\n  message.each_char do |character|\n    if alphabet.include?(character)\n\
    \      if vowels.include?(character)\n        index = alphabet.index(character)\n\
    \        index += 2\n        encoded_message += alphabet[index]\n      else\n\
    \        index = alphabet.index(character)\n        if index <= 50\n         \
    \ encoded_message += alphabet[index + 26]\n        else\n          encoded_message\
    \ += alphabet[index - 26]\n        end\n      end\n    else\n      encoded_message\
    \ += character\n    end\n  end\n  encoded_message\nend", "  result = ''\n  lower_vowels\
    \ = %w[a e i o u]\n  upper_vowels = %w[A E I O U]\n  message.each_char do |char|\n\
    \    if lower_vowels.include?(char)\n      upper_vowels.each_with_index do |lower_vowel,\
    \ index|\n        if char == lower_vowel\n          result += upper_vowels[index\
    \ + 2]\n        end\n      end\n    elsif upper_vowels.include?(char)\n      lower_vowels.each_with_index\
    \ do |upper_vowel, index|\n        if char == upper_vowel\n          result +=\
    \ lower_vowels[index + 2]\n        end\n      end\n    elsif char.downcase ==\
    \ char\n      result += char.upcase\n    else\n      result += char.downcase\n\
    \    end\n  end\n  result\nend", "    message.chars.map { |letter| \n        if\
    \ %w(a e i o u).include?(letter.downcase)\n            shift_letter(letter)\n\
    \        else\n            letter.swapcase\n        end\n    }.join\nend", "\t\
    encoded_message = \"\"\n\tup_letters = (\"A\"..\"Z\").to_a\n\tdown_letters = (\"\
    a\"..\"z\").to_a\n\tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tmessage.split(\"\
    \").each do |char|\n\t\tif up_letters.include?(char)\n\t\t\tencoded_message <<\
    \ down_letters[up_letters.index(char)]\n\t\telsif down_letters.include?(char)\n\
    \t\t\tencoded_message << up_letters[down_letters.index(char)]\n\t\telsif vowels.include?(char)\n\
    \t\t\tencoded_message << vowels[vowels.index(char) + 2]\n\t\telse\n\t\t\tencoded_message\
    \ << char\n\t\tend\n\tend\n\treturn encoded_message\nend", "  alphabet = (\"a\"\
    ..\"z\").to_a + (\"A\"..\"Z\").to_a\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n  message.chars.map do |char|\n    if !alphabet.include?(char)\n      char\n\
    \    elsif vowels.include?(char.downcase)\n      char = alphabet[alphabet.index(char)\
    \ + 2]\n    else\n      char = alphabet[alphabet.index(char) + 26]\n    end\n\
    \  end.join\nend", "  message.downcase.tr('aeiou', 'eioua')\nend", "  encoded_message\
    \ = []\n  # convert message to upcase array\n  message.upcase.split(\"\").each\
    \ do |char|\n    # check for vowels\n    if char =~ /[AEIOU]/\n      # get next\
    \ 2 chars\n      char = char.next.next\n    end\n    # add to encoded_message\
    \ array\n    encoded_message << char\n  end\n  # return encoded_message\n  encoded_message.join\n\
    end", "  # Grab the index of the letter in the alphabet\n  # Look up two characters\
    \ ahead in the alphabet\n  # Replace that letter with the new one\n  array = ('a'..'z').to_a\n\
    \  result = \"\"\n  message.downcase.each_char do |c|\n    current_letter = array.index(c)\n\
    \    if current_letter == nil\n      result += c\n    else\n      if current_letter\
    \ == (array.length - 2)\n        result += array[0]\n      elsif current_letter\
    \ == (array.length - 1)\n        result += array[1]\n      else\n        result\
    \ += array[current_letter + 2]\n      end\n    end\n  end\n  result.upcase\nend",
  "  characters = message.split(\"\")\n  encoded_message = []\n  characters.each do\
    \ |c|\n    if c.upcase == c\n      encoded_message << c.downcase\n    else\n \
    \     encoded_message << c.upcase\n    end\n  end\n  encoded_message.join(\"\"\
    )\nend", "  vowels = %w(A E I O U)\n  alphabet = ('A'..'Z').to_a\n  message.upcase.chars.map\
    \ do |letter|\n    alphabet_idx = alphabet.index(letter)\n    if vowels.include?(letter)\n\
    \      alphabet[alphabet_idx + 2]\n    else\n      letter\n    end\n  end.join\n\
    end", "  new_message = message.split(\"\").map do |char|\n    if char.ord >= 65\
    \ && char.ord <= 90 # upper case\n      char = (char.ord - 64) % 26 + 64\n   \
    \ elsif char.ord >= 97 && char.ord <= 122 # lower case\n      char = (char.ord\
    \ - 96) % 26 + 96\n    else # not a letter\n      char = char\n    end\n  end\n\
    \  new_message.join(\"\")\nend", "  # your code here\nend", "  encoded_message\
    \ = \"\"\n  vowels = \"aeiou\"\n  message.each_char do |ch|\n    if vowels.include?(ch.downcase)\n\
    \      if ch == \"u\"\n        encoded_message += \"a\"\n      else\n        encoded_message\
    \ += vowels[vowels.index(ch.downcase) + 2]\n      end\n    elsif ch == ch.upcase\n\
    \      encoded_message += ch.downcase\n    else\n      encoded_message += ch.upcase\n\
    \    end\n  end\n  encoded_message\nend", "\nend", "  vowels = 'aeiou'\n  message.split('').map\
    \ { |letter|\n    if letter == letter.upcase\n      letter.downcase\n    elsif\
    \ letter == letter.downcase\n      letter.upcase\n    elsif vowels.include?(letter)\n\
    \      vowels[(vowels.index(letter) + 2) % 5]\n    else\n      letter\n    end\n\
    \  }.join('')\nend", "  alphabet = ('a'..'z').to_a\n  coded_message = \"\"\n \
    \ message.split(\"\").each do |letter|\n    if alphabet.include?(letter.downcase)\n\
    \      encoded_letter = encode_letter(letter)\n      coded_message += encoded_letter\n\
    \    else\n      coded_message += letter\n    end\n  end\n  coded_message\nend",
  "\treturn message.downcase.tr(vowels + consonants, consonants + vowels).upcase\n\
    end", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  message.downcase.chars.map do |letter|\n\
    \    if vowels.include?(letter)\n      vowels[(vowels.index(letter) + 2) % 5]\n\
    \    else\n      letter.upcase\n    end\n  end.join\nend", "  message.each_char.map\
    \ do |char|\n    if char =~ /[aeiou]/i\n      encode_vowel(char)\n    else\n \
    \     swap_case(char)\n    end\n  end.join\nend", "  message.downcase!\n  encoded_message\
    \ = \"\"\n  message.each_char do |char|\n    if char == \"a\"\n      encoded_message\
    \ << \"c\"\n    elsif char == \"e\"\n      encoded_message << \"g\"\n    elsif\
    \ char == \"i\"\n      encoded_message << \"k\"\n    elsif char == \"o\"\n   \
    \   encoded_message << \"q\"\n    elsif char == \"u\"\n      encoded_message <<\
    \ \"y\"\n    elsif char == \"z\"\n      encoded_message << \"b\"\n    elsif char\
    \ == \"y\"\n      encoded_message << \"a\"\n    else\n      encoded_message <<\
    \ char.next\n    end\n  end\n  encoded_message.capitalize!\nend", "  message =\
    \ message.split(\"\")\n  new_message = []\n  alpha = ('a'..'z').to_a\n  alpha.map!{|x|\
    \ x.upcase}\n  message.each do |x|\n    if alpha.include?(x) == false\n      new_message\
    \ << x\n    elsif x == \"z\"\n      new_message << \"b\"\n    elsif x == \"Z\"\
    \n      new_message << \"B\"\n    elsif alpha.index(x) > 21\n      new_message\
    \ << alpha[alpha.index(x) - 4]\n    elsif alpha.index(x) > 13\n      new_message\
    \ << alpha[alpha.index(x) - 2]\n    else\n      new_message << alpha[alpha.index(x)\
    \ + 2]\n    end\n  end\n  return new_message.join(\"\")\nend", "\talphabet = ('a'..'z').to_a",
  "\t\n\tnew_message = \"\"\n\tnew_message = message.upcase\n\t\t\n\t\n\ti = 0\n\t\
    while i < new_message.length do\n\t\t\t\n\t\tif new_message[i] == \"A\"\n\t\t\t\
    new_message[i] = \"C\"\n\t\telsif new_message[i] == \"E\"\n\t\t\tnew_message[i]\
    \ = \"G\"\n\t\telsif new_message[i] == \"I\"\n\t\t\tnew_message[i] = \"K\"\n\t\
    \telsif new_message[i] == \"O\"\n\t\t\tnew_message[i] = \"Q\"\n\t\telsif new_message[i]\
    \ == \"U\"\n\t\t\tnew_message[i] = \"S\"\n\t\telsif new_message[i] == \"Y\"\n\t\
    \t\tnew_message[i] = \"A\"\n\t\tend\n\t\t\n\t\ti += 1\n\tend\n\t\n\treturn new_message\n\
    end", "  new_message = []\n  alpha = 'abcdefghijklmnopqrstuvwxyz'\n  vowels =\
    \ 'aeiou'\n  message.each_char do |i|\n    if alpha.include?(i)\n      if i ==\
    \ i.upcase\n        ind = alpha.index(i.downcase)\n        if ind == -1\n    \
    \      new_message << i\n        else\n          if vowels.include?(i.downcase)\n\
    \            if ind > 20\n              new_message << alpha[ind - 5].upcase\n\
    \            else\n              new_message << alpha[ind + 2].upcase\n      \
    \      end\n          else\n            new_message << alpha[ind].upcase\n   \
    \       end\n        end\n      else\n        ind = alpha.index(i)\n        if\
    \ ind == -1\n          new_message << i\n        else\n          if vowels.include?(i)\n\
    \            if ind > 20\n              new_message << alpha[ind - 5]\n      \
    \      else\n              new_message << alpha[ind + 2]\n            end\n  \
    \        else\n            new_message << alpha[ind]\n          end\n        end\n\
    \      end\n    else\n      new_message << i\n    end\n  end\n  new_message.join('')\n\
    end", "    letters = ('a'..'z').to_a + ('A'..'Z').to_a\n    message = message.chars.map\
    \ do |char|\n        if !letters.include?(char)\n            char\n        elsif\
    \ char == 'z'\n            'B'\n        elsif char == 'Z'\n            'b'\n \
    \       elsif char.upcase == char\n            (letters[letters.index(char.downcase)\
    \ + 2]).upcase\n        else\n            letters[letters.index(char) + 2]\n \
    \       end\n    end\n    message.join\nend", "  alphabet = ('a'..'z').to_a +\
    \ ('A'..'Z').to_a\n  vowels = 'aeiouAEIOU'\n  alph_index = 0\n  encoded_message\
    \ = []\n  encrypted_message = ''\n  message.each_char do |letter|\n    if vowels.include?(letter)\n\
    \      alph_index = (alphabet.index(letter) + 2) % 52\n      encoded_message <<\
    \ alphabet[alph_index]\n    elsif alphabet.include?(letter)\n      alph_index\
    \ = (alphabet.index(letter) + 2) % 52\n      encoded_message << alphabet[alph_index].upcase\n\
    \    else\n      encoded_message << letter\n    end\n  end\n  encoded_message.each\
    \ do |letter|\n    encrypted_message << letter\n  end\n  puts encrypted_message\n\
    end\nencode('Hello World!')\nencode('This is a message')\nencode('test')", "\t\
    encoded_message = \"\"\n\tmessage.each_char do |char|\n\t\tif char == char.upcase\n\
    \t\t\tencoded_message += char.downcase\n\t\telse\n\t\t\tencoded_message += char.upcase\n\
    \t\tend\n\tend\n\tencoded_message.tr(\"aeiou\", \"cegik\")\nend", "    # write\
    \ your code here\nend", "  encoded_message = \"\"\n  alphabet = (\"a\"..\"z\"\
    ).to_a\n  vowels = %w(a e i o u)\n  message.each_char do |char|\n    if alphabet.include?(char)\n\
    \      char_index = alphabet.index(char)\n      if char == char.upcase\n     \
    \   if vowels.include?(char.downcase)\n          encoded_message << alphabet[(char_index\
    \ + 2) % 26].upcase\n        else\n          encoded_message << alphabet[char_index\
    \ % 26].upcase\n        end\n      else\n        if vowels.include?(char)\n  \
    \        encoded_message << alphabet[(char_index + 2) % 26]\n        else\n  \
    \        encoded_message << alphabet[char_index % 26]\n        end\n      end\n\
    \    else\n      encoded_message << char\n    end\n  end\n  encoded_message\n\
    end", "  result = []\n  message.each_char do |letter|\n    if letter =~ /[a-z]/i\n\
    \      if letter =~ /[aeiou]/i\n        letter = vowels.index(letter.downcase)\
    \ + 2\n        result << vowels[letter]\n      else\n        result << letter.swapcase\n\
    \      end\n    else\n      result << letter\n    end\n  end\n  result.join\n\
    end", "  e_message = message.upcase.split(\"\")\n  e_message.each_with_index do\
    \ |ch, idx|\n    if ch =~ /[AEIOU]/\n      e_message[idx] = VOWELS[ch]\n    end\n\
    \  end\n  e_message.join(\"\")\nend", "    #Take in a string message\n    #Iterate\
    \ through the string\n    #if it is a letter do something\n    #if it is a vowel\
    \ do something\n    #if it is a consonant do something\n    #if it is a capital\
    \ do something\n    #if it is lowercase do something\n    #if it is whitespace\
    \ do something\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    consonants\
    \ = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \   letters = (\"a\"..\"z\").to_a\n    message.downcase!\n    message.split(\"\
    \").map do |letter|\n        if vowels.include?(letter)\n            letters[letters.index(letter)\
    \ + 2]\n        elsif consonants.include?(letter)\n            letters[letters.index(letter)\
    \ - 2]\n        elsif letter == \" \"\n            \" \"\n        end\n    end.join\n\
    end", "\tencoded_message = message.chars.map do |char|\n\t\tif char =~ /[a-z]/\n\
    \t\t\tif char == \"z\"\n\t\t\t\t\"b\"\n\t\t\telsif char == \"y\"\n\t\t\t\t\"a\"\
    \n\t\t\telse\n\t\t\t\t(char.ord + 2).chr\n\t\t\tend\n\t\telsif char =~ /[A-Z]/\n\
    \t\t\tif char == \"Z\"\n\t\t\t\t\"B\"\n\t\t\telsif char == \"Y\"\n\t\t\t\t\"A\"\
    \n\t\t\telse\n\t\t\t\t(char.ord + 2).chr\n\t\t\tend\n\t\telse\n\t\t\tchar\n\t\t\
    end\n\tend\n\tencoded_message.join\nend", "  vowels = 'aeiou'\n  encoded_message\
    \ = ''\n  message.each_char do |char|\n    if vowels.include?(char.downcase)\n\
    \      index = vowels.index(char.downcase)\n      encoded_message += vowels[(index\
    \ + 2) % 5]\n    else\n      encoded_message += char\n    end\n  end\n  encoded_message.swapcase\n\
    end", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  @message = message.gsub(/[A-Z]/,\
    \ &:downcase)\n  @new_message = \"\"\n  @message.each_char do |char|\n    if char\
    \ == \" \"\n      @new_message << \" \"\n    elsif alphabet.index(char) == 24\n\
    \      @new_message << alphabet[1]\n    elsif alphabet.index(char) == 25\n   \
    \   @new_message << alphabet[2]\n    elsif alphabet.index(char) == nil\n     \
    \ @new_message << char\n    else\n      @new_message << alphabet[alphabet.index(char)\
    \ + 2]\n    end\n  end\n  if message == message.capitalize\n    return @new_message.capitalize\n\
    \  else\n    return @new_message\n  end\nend", "  # implement me\nend", "  vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  result = \"\"\n  message.each_char\
    \ do |ch|\n    if vowels.include?(ch.downcase)\n      idx = vowels.index(ch.downcase)\n\
    \      next_idx = (idx + 2) % vowels.length\n      result += vowels[next_idx].upcase\
    \ if ch == ch.upcase\n      result += vowels[next_idx] if ch == ch.downcase\n\
    \    else\n      if ch == ch.upcase\n        result += ch.downcase\n      else\n\
    \        result += ch.upcase\n      end\n    end\n  end\n  result\nend", "\t\n\
    \t#get the message\n\tmessage = gets.chomp\n\t\n\t#get the message in array format\n\
    \tarray = message.split('')\n\t\n\t#create and array for the alphabet\n\talphabet\
    \ = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \t\n\t#create an array for the vowels\n\tvowels = ['a','e','i','o','u']\n\t\n\t\
    #create an empty array for the encoded message\n\tencoded_message = []\n\t\n\t\
    #iterate through the message array\n\tarray.each do |char|\n\t\t#find the index\
    \ of the char in the alphabet\n\t\tindex = alphabet.index(char)\n\t\t#check if\
    \ the char is in the alphabet\n\t\tif index\n\t\t\t#check if the char is uppercase\n\
    \t\t\tif char == char.upcase\n\t\t\t\t#if the char is in the vowels array\n\t\t\
    \t\tif vowels.include?(char.downcase)\n\t\t\t\t\t#check if the char is u\n\t\t\
    \t\t\tif char.downcase == 'u'\n\t\t\t\t\t\t#set the char to the next vowel\n\t\
    \t\t\t\t\tchar = 'a'.upcase\n\t\t\t\t\telse\n\t\t\t\t\t\t#set the char to the\
    \ next vowel\n\t\t\t\t\t\tchar = alphabet[index + 2].upcase\n\t\t\t\t\tend\n\t\
    \t\t\t#if the char is not in the vowels array\n\t\t\t\telse\n\t\t\t\t\t#check\
    \ if the char is z\n\t\t\t\t\tif char == 'Z'\n\t\t\t\t\t\t#set the char to the\
    \ next letter in the alphabet\n\t\t\t\t\t\tchar = 'A'\n\t\t\t\t\telse\n\t\t\t\t\
    \t\t#set the char to the next letter in the alphabet\n\t\t\t\t\t\tchar = alphabet[index\
    \ + 1].upcase\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t", "  swap_case(message).chars.map\
    \ do |letter|\n    if vowel?(letter)\n      encode_vowel(letter)\n    else\n \
    \     letter\n    end\n  end.join\nend", "\tvowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n\tletters = (\"a\"..\"z\").to_a\n\tencoded_message = \"\"\n\tmessage.downcase.each_char\
    \ do |c|\n\t\tif vowels.include?(c)\n\t\t\tvowel_index = letters.index(c)\n\t\t\
    \tvowel_index = (vowel_index + 2) % 26\n\t\t\tencoded_message += letters[vowel_index]\n\
    \t\telse\n\t\t\tencoded_message += c\n\t\tend\n\tend\n\tencoded_message.upcase\n\
    end", "  swap_case = message.downcase.tr(\"a-z\", \"A-Z\")\n  encode_vowels =\
    \ swap_case.tr(\"aeiou\", \"cfjoqu\")\n  encode_vowels\nend", "\tswap_case = []\n\
    \tvowels = []\n\tsplit_message = message.split(\"\")\n\tsplit_message.each do\
    \ |letter|\n\t\tif letter == letter.downcase\n\t\t\tswap_case << letter.upcase\n\
    \t\telse\n\t\t\tswap_case << letter.downcase\n\t\tend\n\tend\n\tswap_case.each\
    \ do |swap_letter|\n\t\tif swap_letter == \"A\"\n\t\t\tvowels << \"C\"\n\t\telsif\
    \ swap_letter == \"E\"\n\t\t\tvowels << \"G\"\n\t\telsif swap_letter == \"I\"\n\
    \t\t\tvowels << \"K\"\n\t\telsif swap_letter == \"O\"\n\t\t\tvowels << \"Q\"\n\
    \t\telsif swap_letter == \"U\"\n\t\t\tvowels << \"Y\"\n\t\telsif swap_letter ==\
    \ \"a\"\n\t\t\tvowels << \"c\"\n\t\telsif swap_letter == \"e\"\n\t\t\tvowels <<\
    \ \"g\"\n\t\telsif swap_letter == \"i\"\n\t\t\tvowels << \"k\"\n\t\telsif swap_letter\
    \ == \"o\"\n\t\t\tvowels << \"q\"\n\t\telsif swap_letter == \"u\"\n\t\t\tvowels\
    \ << \"y\"\n\t\telse\n\t\t\tvowels << swap_letter\n\t\tend\n\tend\n\tvowels.join\n\
    end", "\tnew_message = \"\"\n\tmessage.each_char do |char|\n\t\tif char.match(/[aeiou]/i)\n\
    \t\t\tnew_message += alphabet[alphabet.index(char.downcase) + 2]\n\t\telse\n\t\
    \t\tnew_message += char\n\t\tend\n\tend\n\tnew_message.swapcase\nend", "  message.chars.map\
    \ do |c|\n    if c =~ /[aeiou]/i\n      c = c.ord.next.next\n    else\n      c\
    \ = c.ord\n    end\n    c = c.ord.next.next if c =~ /[A-Z]/\n    c.chr\n  end.join\n\
    end", "  lc_chars = ('a'..'z').to_a\n  uc_chars = ('A'..'Z').to_a\n  vowels =\
    \ ['a', 'e', 'i', 'o', 'u']\n  encoded_message = ''\n  message.each_char do |char|\n\
    \    if vowels.include?(char.downcase)\n      if char == char.upcase\n       \
    \ encoded_message << uc_chars[(uc_chars.index(char)+2)%26]\n      else\n     \
    \   encoded_message << lc_chars[(lc_chars.index(char)+2)%26]\n      end\n    elsif\
    \ char == char.upcase\n      encoded_message << lc_chars[lc_chars.index(char.downcase)].upcase\n\
    \    else\n      encoded_message << uc_chars[uc_chars.index(char.upcase)].downcase\n\
    \    end\n  end\n  encoded_message\nend", "  vowels = 'aeiouAEIOU'\n  alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  result = ''\n  message.each_char\
    \ do |char|\n    if vowels.include?(char)\n      next_vowel_index = alphabet.index(char)\
    \ + 2\n      result += alphabet[next_vowel_index]\n    else\n      result += char\n\
    \    end\n  end\n  result.swapcase\nend", "\tmessage.downcase!\n\tencoded_message\
    \ = \"\"\n\tmessage.each_char do |letter|\n\t\tif letter.ord.between?(97, 119)\n\
    \t\t\tletter = (letter.ord + 2).chr\n\t\telsif letter.ord.between?(120, 122)\n\
    \t\t\tletter = (letter.ord - 24).chr\n\t\tend\n\t\tencoded_message << letter\n\
    \tend\n\tencoded_message.upcase!\nend", "    vowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n    answer = \"\"\n    message.split(\"\").each do |char|\n     \
    \   if vowels.include?(char.downcase)\n            char = vowels[(vowels.index(char.downcase)\
    \ + 2) % 5]\n        end\n        if char == char.upcase\n            char = char.downcase\n\
    \        else\n            char = char.upcase\n        end\n        answer <<\
    \ char\n    end\n    return answer\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  message.tr(alphabet, alphabet.reverse)\nend", "  message.gsub(/[aeiou]/i,\
    \ 'aeiou'.chars.map{|vowel| ('a'..'z').to_a[('a'..'z').to_a.index(vowel) + 2]}.join).swapcase\n\
    end", "  result = \"\"\n  vowels = \"aeiou\"\n  message.each_char do |c|\n   \
    \ result += encode_char(c, vowels)\n  end\n  result\nend", "  consonants = \"\
    bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n  vowels = \"aeiouAEIOU\"\n  new_message\
    \ = \"\"\n  message.each_char do |c|\n    if vowels.include?(c)\n      new_message\
    \ += v_swap(c)\n    elsif consonants.include?(c)\n      new_message += c_swap(c)\n\
    \    else\n      new_message += c\n    end\n  end\n  new_message\nend", "  alphabet\
    \ = (\"a\"..\"z\").to_a.join\n  message.split(\"\").map { |l|\n    if l.match(/[a-z]/i)\n\
    \      if l.match(/[aeiou]/i)\n        alphabet[(alphabet.index(l.downcase) +\
    \ 2) % 26]\n      else\n        alphabet[(alphabet.index(l.downcase) + 13) % 26]\n\
    \      end\n    else\n      l\n    end\n  }.join(\"\")\nend", "  alphabet = ('a'..'z').to_a\n\
    \  vowels = %w(a e i o u)\n  message = message.downcase\n  result = []\n  message.each_char\
    \ do |letter|\n    if vowels.include?(letter)\n      index = (alphabet.index(letter)\
    \ + 2) % 26\n      result << alphabet[index]\n    else\n      result << letter\n\
    \    end\n  end\n  result.join('').upcase\nend", "\tswappedCase = message.swapcase\n\
    \tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tanswer = []\n\tmessage.each_char\
    \ do |char|\n\t\tif vowels.include?(char.downcase)\n\t\t\tanswer << (char.ord\
    \ + 2).chr\n\t\telse\n\t\t\tanswer << char\n\t\tend\n\tend\n\tanswer.join\nend",
  "  encoded_str = \"\"\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  message.each_char\
    \ do |char|\n    if vowels.include?(char.downcase)\n      index = vowels.index(char.downcase)\n\
    \      index += 2\n      encoded_str += vowels[index % 5].upcase\n    else\n \
    \     encoded_str += char.upcase\n    end\n  end\n  encoded_str\nend", "  message.each_char.map\
    \ { |i| encode_letter(i) }.join\nend", "\t#your code here\nend", "\tnew_message\
    \ = []\n\tindex = 0\n\tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tmessage\
    \ = message.split(\"\")\n\tmessage.each do |char|\n\t\tnew_char = char.downcase\n\
    \t\tif new_char == \"z\"\n\t\t\tnew_char = \"b\"\n\t\telsif new_char == \"y\"\n\
    \t\t\tnew_char = \"a\"\n\t\telsif vowels.include?(new_char)\n\t\t\tnew_char =\
    \ vowels[vowels.index(new_char)+2]\n\t\telse\n\t\t\tnew_char = new_char.next\n\
    \t\tend\n\t\tif char == char.upcase\n\t\t\tnew_char = new_char.upcase\n\t\tend\n\
    \t\tnew_message[index] = new_char\n\t\tindex += 1\n\tend\n\treturn new_message.join(\"\
    \")\nend", "  letters = message.chars.map do |char|\n    if char =~ /[a-z]/i\n\
    \      if char =~ /[aeiou]/i\n        upper = char == char.upcase\n        char\
    \ = (char.downcase.next.next)\n        upper ? char.upcase : char\n      else\n\
    \        upper = char == char.upcase\n        char = char.downcase\n        char\
    \ = char.next.next\n        upper ? char.upcase : char\n      end\n    else\n\
    \      char\n    end\n  end\n  letters.join\nend\nputs encode(\"This is a message\"\
    )", "\talphabet = ('a'..'z').to_a\n\tvowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n\tnew = message.split(\"\").map do |letter|\n\t\tif vowels.include?(letter)\n\
    \t\t\tindex = alphabet.index(letter)\n\t\t\tletter = alphabet[index + 2]\n\t\t\
    elsif alphabet.include?(letter)\n\t\t\tindex = alphabet.index(letter)\n\t\t\t\
    letter = alphabet[index - 2]\n\t\telse\n\t\t\tletter\n\t\tend\n\tend\n\tnew.join(\"\
    \")\nend", "\ta = message.split(\"\")\n\tvowels = \"aeiou\"\n\ta.each do |x|\n\
    \t\tif (x.match(/[A-Z]/))\n\t\t\tx.downcase!\n\t\telse\n\t\t\tx.upcase!\n\t\t\
    end\n\t\tif (vowels.include?(x))\n\t\t\tif (x.ord == 'u'.ord)\n\t\t\t\tx.ord =\
    \ 'a'.ord\n\t\t\telse\n\t\t\t\tx.ord = x.ord + 2\n\t\t\tend\n\t\tend\n\tend\n\t\
    a.join(\"\")\nend", "\tvowels = ['a', 'e', 'i', 'o', 'u']\n\tmessage = message.downcase\n\
    \tmessage = message.chars.map! { |ch|\n\t\tch_index = vowels.index(ch)\n\t\tif\
    \ vowels.include?(ch)\n\t\t\tif ch_index == 4\n\t\t\t\tvowels[0]\n\t\t\telse\n\
    \t\t\t\tvowels[ch_index + 2]\n\t\t\tend\n\t\telse\n\t\t\tch\n\t\tend\n\t}\n\t\n\
    \tmessage.join(\"\").upcase\nend", "\talphabet = ('a'..'z').to_a\n\tvowels = [\"\
    a\", \"e\", \"i\", \"o\", \"u\"]\n\toutput = \"\"\n\tmessage.each_char do |char|\n\
    \t\tif vowels.include?(char.downcase)\n\t\t\tnew_index = alphabet.index(char.downcase)\
    \ + 2\n\t\t\tnew_char = alphabet[new_index]\n\t\t\tif char == char.upcase\n\t\t\
    \t\toutput << new_char.upcase\n\t\t\telse\n\t\t\t\toutput << new_char\n\t\t\t\
    end\n\t\telsif alphabet.include?(char.downcase)\n\t\t\tnew_index = alphabet.index(char.downcase)\
    \ + 13\n\t\t\tnew_char = alphabet[new_index]\n\t\t\tif char == char.upcase\n\t\
    \t\t\toutput << new_char.upcase\n\t\t\telse\n\t\t\t\toutput << new_char\n\t\t\t\
    end\n\t\telse\n\t\t\toutput << char\n\t\tend\n\tend\n\toutput\nend", "\tencoded_message\
    \ = message.upcase.tr(\"AEIOU\", \"CGFKQ\")\n\tencoded_message.tr(\"BCDFGHJKLMNPQRSTVWXYZ\"\
    , \"AEIOUBCDFGHJKLMNPQRSTVWXYZ\")\nend\nputs encode(\"This is a message\")", "\t\
    alphabet = (\"a\"..\"z\").to_a\n\tmessage.downcase.each_char do |letter|\n\t\t\
    if alphabet.include?(letter)\n\t\t\tif letter == \"z\"\n\t\t\t\treturn \"a\"\n\
    \t\t\telsif alphabet.index(letter) % 2 == 0\n\t\t\t\treturn alphabet[alphabet.index(letter)\
    \ + 2]\n\t\t\telse\n\t\t\t\treturn alphabet[alphabet.index(letter) + 1]\n\t\t\t\
    end\n\t\tend\n\tend\nend", "\tnew_message = \"\"\n\tvowels = [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n\tmessage.split(\"\").each do |letter|\n\t\tif vowels.include?(letter.downcase)\n\
    \t\t\tcase letter.downcase\n\t\t\twhen \"a\"\n\t\t\t\tnew_message += \"c\"\n\t\
    \t\twhen \"e\"\n\t\t\t\tnew_message += \"g\"\n\t\t\twhen \"i\"\n\t\t\t\tnew_message\
    \ += \"k\"\n\t\t\twhen \"o\"\n\t\t\t\tnew_message += \"m\"\n\t\t\twhen \"u\"\n\
    \t\t\t\tnew_message += \"q\"\n\t\t\tend\n\t\telse\n\t\t\tnew_message += letter.swapcase\n\
    \t\tend\n\tend\n\tnew_message\nend", "  result = \"\"\n  alphabet = ('a'..'z').to_a\n\
    \  message.each_char do |char|\n    index = alphabet.index(char.downcase)\n  \
    \  if index.nil?\n      result << char\n    else\n      index += 2\n      index\
    \ = index % 26\n      if char.upcase == char\n        result << alphabet[index].upcase\n\
    \      else\n        result << alphabet[index]\n      end\n    end\n  end\n  result\n\
    end", "    vowels = \"aeiouAEIOU\"\n    res = \"\"\n    message.each_char do |char|\n\
    \        if vowels.include?(char)\n            res += (char.ord + 2).chr\n   \
    \     else\n            res += char\n        end\n    end\n    res.swapcase\n\
    end", "    # Code here\n    # Use helper functions", "  letters = message.chars\n\
    \  letters.map! do |letter|\n    if /[a-z]/ =~ letter\n      letter = letter.downcase\n\
    \      index = ('a'..'z').to_a.index(letter)\n      letter = ('a'..'z').to_a[index\
    \ + 2]\n    elsif /[A-Z]/ =~ letter\n      letter = letter.downcase\n      index\
    \ = ('a'..'z').to_a.index(letter)\n      letter = ('a'..'z').to_a[index + 2].upcase\n\
    \    else\n      letter\n    end\n  end\n  letters.join\nend", "\tmessage = message.split(\"\
    \ \")\n\t#message.each do |word|\n\t#\tword = word.swapcase.tr(\"aeiou\", \"cfjpv\"\
    )\n\t#end\n\t#message.join(\" \")\n\tmessage.map {|word| word.swapcase.tr(\"aeiou\"\
    , \"cfjpv\")}.join(\" \")\nend", "    # Using the .ord method, convert the string\
    \ to ASCII numbers\n    # Loop through the message and compare each letter to\
    \ the english alphabet \n    # and if the letter is upper case \n    # Change\
    \ it to lower case\n    # If the letter is a vowel, change the letter to the next\
    \ one in the alphabet\n    # If the letter is lower case, change it to upper case\n\
    \    # Convert the ASCII numbers back to letters \n    # Use the .chr method to\
    \ do this", "  s = message.split(\"\")\n  vowels = ['a', 'e', 'i', 'o', 'u']\n\
    \  vowels2 = ['c', 'f', 'j', 'n', 'r']\n  res = []\n  s.each do |x|\n    if x\
    \ == x.upcase\n      res << x.downcase\n    else\n      res << x.upcase\n    end\n\
    \  end\n  res.map! do |y|\n    if vowels.include?(y)\n      y = vowels2[vowels.index(y)]\n\
    \    else\n      y\n    end\n  end\n  res.join\nend", "  alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \  vowels = %w(a e i o u)\n  new_message = \"\"\n  message.split(\"\").each do\
    \ |letter|\n    if alphabet.include?(letter.downcase)\n      if vowels.include?(letter.downcase)\n\
    \        if alphabet.index(letter.downcase) + 2 > alphabet.length\n          new_message\
    \ += alphabet[alphabet.index(letter.downcase) + 2 - alphabet.length].upcase\n\
    \        else\n          new_message += alphabet[alphabet.index(letter.downcase)\
    \ + 2].upcase\n        end\n      else\n        new_message += letter.swapcase\n\
    \      end\n    else\n      new_message += letter\n    end\n  end\n  new_message\n\
    end", "\talphabet = (\"a\"..\"z\").to_a\n\tvowels = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n\tmessage.split(\"\").map do |letter|\n\t\tletter.downcase!\n\t\tif\
    \ letter == \"z\"\n\t\t\tletter = \"b\"\n\t\telsif letter == \"y\"\n\t\t\tletter\
    \ = \"a\"\n\t\telsif vowels.include?(letter)\n\t\t\tletter = alphabet[alphabet.index(letter)\
    \ + 2]\n\t\telsif alphabet.include?(letter)\n\t\t\tletter = alphabet[alphabet.index(letter)\
    \ + 1]\n\t\tend\n\t\tletter.upcase!\n\tend.join(\"\")\nend", "    vowels = \"\
    AEIOU\"\n    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    n = 0\n    message.each_char\
    \ do |char|\n        if vowels.include?(char.upcase)\n            n = alphabet.index(char.upcase)\
    \ + 2\n            char.upcase!\n            char = alphabet[n]\n        elsif\
    \ alphabet.include?(char.upcase)\n            char.upcase!\n        end\n    end\n\
    \    return message\nend", "  message.chars.map do |char|\n    if char =~ /[A-Z]/\n\
    \      char.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next",
  "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    new_message = \"\"\n    alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    message.each_char.with_index do |x,i|\n\
    \        if vowels.include? x.downcase\n            char_index = alphabet.index(x.downcase)\n\
    \            if char_index == 24\n                new_message += alphabet[1].upcase\n\
    \            elsif char_index == 25\n                new_message += alphabet[2].upcase\n\
    \            else\n                new_message += alphabet[char_index + 2].upcase\n\
    \            end\n        elsif x == x.upcase\n            new_message += x.downcase\n\
    \        else\n            new_message += x.upcase\n        end\n    end\n   \
    \ new_message\nend", "  new_message = \"\"\n  message.each_char do |letter|\n\
    \    if (letter.ord.between?(65, 90))\n      letter = letter.ord + 2 \n      letter\
    \ = letter > 90 ? letter - 26 : letter\n      new_message += letter.chr\n    elsif\
    \ (letter.ord.between?(97, 122))\n      letter = letter.ord + 2 \n      letter\
    \ = letter > 122 ? letter - 26 : letter\n      new_message += letter.chr\n   \
    \ else\n      new_message += letter\n    end\n  end\n  new_message\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
