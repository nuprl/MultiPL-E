name: HumanEval_93_encode
language: rb
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\n# >>> encode.call(\"test\")\n# \"TGST\"\
  \n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n\
  \    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"\
  ))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"\
  ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"\
  This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"\
  I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"
completions: ["    alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('')\n    message\
    \ = message.split('')\n    encoded_message = message.map do |letter|\n       \
    \ if alphabet.include?(letter.downcase)\n            if letter == letter.upcase\n\
    \                encoding_letter = alphabet[(alphabet.index(letter.downcase) +\
    \ 2) % 26].upcase\n            else\n                encoding_letter = alphabet[(alphabet.index(letter)\
    \ + 2) % 26]\n            end\n        else\n            encoding_letter = letter\n\
    \        end\n    end\n    encoded_message.join\nend", "  vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n  encoded_message = []\n  message.split(\"\").each\
    \ do |letter|\n    if letter == letter.upcase\n      encoded_message << letter.downcase\n\
    \    else\n      encoded_message << letter.upcase\n    end\n    if vowels.include?(letter.downcase)\n\
    \      index = vowels.index(letter.downcase)\n      encoded_message.pop\n    \
    \  if index < 4\n        encoded_message << vowels[index + 2]\n      else\n  \
    \      encoded_message << vowels[0]\n      end\n    end\n  end\n  encoded_message.join(\"\
    \")\nend\nputs encode(\"test\")\nputs encode(\"This is a message\")", "\tmessage.gsub(/[aeiou]/i)\
    \ { |vowel|\n\t\tnew_vowel = vowel.next.next\n\t\tnew_vowel.upcase! if vowel ==\
    \ vowel.upcase\n\t\tnew_vowel\n\t}\nend", "  # YOUR CODE HERE\nend", "  message\
    \ = message.downcase.split(\"\")\n  message.each_with_index do |char, index|\n\
    \    if vowel?(char)\n      message[index] = char.next\n      message[index] =\
    \ message[index].next\n    end\n  end\n  message.join.upcase\nend", "  vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  message = message.split(\"\")\n  vowels.each\
    \ do |vowel|\n    i = 0\n    while i < message.length do\n      if message[i]\
    \ == vowel\n        message[i] = (vowel.ord + 2).chr\n      end\n      i += 1\n\
    \    end\n  end\n  message.map! do |char|\n    if char.ord > 96 && char.ord <\
    \ 123\n      char = (char.ord - 32).chr\n    elsif char.ord > 64 && char.ord <\
    \ 91\n      char = (char.ord + 32).chr\n    else\n      char\n    end\n  end\n\
    \  message.join(\"\")\nend", "\tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \talpha = \"abcdefghijklmnopqrstuvwxyz\"\n\tword = message.downcase\n\tword.each_char\
    \ do |c|\n\t\tif c =~ /[a-z]/\n\t\t\tif vowels.include?(c)\n\t\t\t\tpos = alpha.index(c)\n\
    \t\t\t\tword[word.index(c)] = alpha[pos + 2]\n\t\t\telse\n\t\t\t\tword[word.index(c)]\
    \ = c.swapcase\n\t\t\tend\n\t\tend\n\tend\n\treturn word\nend", "\talphabet =\
    \ ('a'..'z').to_a\n\tvowels = ['a', 'e', 'i', 'o', 'u']\n\tmessage.each_char do\
    \ |c|\n\t\tif vowels.include?(c)\n\t\t\tidx = alphabet.index(c)\n\t\t\tc = alphabet[idx\
    \ + 2]\n\t\tend\n\t\tc.swapcase!\n\tend\nend", "  alphabet = (\"a\"..\"z\").to_a\n\
    \  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  l_message = message.downcase.split(\"\
    \").map do |char|\n    if vowels.include?(char)\n      char = alphabet[alphabet.index(char)\
    \ + 2]\n    elsif vowels.include?(alphabet[alphabet.index(char) + 1])\n      char\
    \ = alphabet[alphabet.index(char) + 3]\n    else\n      char = alphabet[alphabet.index(char)\
    \ + 1]\n    end\n  end\n  l_message.join.upcase\nend", "    @encoded = \"\"\n\
    \    message.each_char { |char|\n        if /[A-Z]/.match(char)\n            char\
    \ = char.downcase\n        elsif /[a-z]/.match(char)\n            char = char.upcase\n\
    \        end\n        if /[aeiou]/.match(char)\n            char = char.ord +\
    \ 2\n            char = char.chr\n        end\n        @encoded << char\n    }\n\
    \    return @encoded\nend", "  encode_message = \"\"\n  message.each_char do |char|\n\
    \    # find the index of the char\n    if char == char.downcase\n      new_index\
    \ = (char.ord - \"a\".ord + 2) % 26\n      encode_message += (new_index + \"a\"\
    .ord).chr\n    else\n      new_index = (char.ord - \"A\".ord + 2) % 26\n     \
    \ encode_message += (new_index + \"A\".ord).chr\n    end\n  end\n  encode_message\n\
    end", "  message.each_char.map { |c|\n    ascii = c.ord\n    if ascii >= 97 and\
    \ ascii <= 122\n      ascii -= 32\n    elsif ascii >= 65 and ascii <= 90\n   \
    \   ascii += 32\n    end\n    c = ascii.chr\n    case c\n    when 'A', 'E', 'I',\
    \ 'O', 'U'\n      c = (ascii + 2).chr\n    when 'a', 'e', 'i', 'o', 'u'\n    \
    \  c = (ascii - 2).chr\n    end\n    c\n  }.join\nend", "  # /[aeiou]/\n  characters\
    \ = message.split(\"\")\n  encrypted_message = \"\"\n  characters.each do |c|\n\
    \    if c.match(/[aeiou]/)\n      encrypted_message << find_next_vowel(c)\n  \
    \  elsif c.match(/[A-Z]/)\n      encrypted_message << find_next_vowel(c.downcase).upcase\n\
    \    else\n      encrypted_message << c\n    end\n  end\n  encrypted_message\n\
    end", "  message.downcase.tr(\"a-y\", \"c-zab\").tr(\"aeiou\", \"eioua\").upcase\n\
    end", "\t# Decode message with key (1)\n\tdecoded_message = \"\"\n\tindex = 0\n\
    \tmessage.length.times do\n\t\tcharacter = message[index]\n\t\tif character ==\
    \ character.upcase\n\t\t\tdecoded_message << character.downcase\n\t\telse\n\t\t\
    \tdecoded_message << character.upcase\n\t\tend\n\t\tindex += 1\n\tend\n\t# Encode\
    \ message with key (2)\n\tencoded_message = \"\"\n\tindex = 0\n\tdecoded_message.length.times\
    \ do\n\t\tcharacter = decoded_message[index]\n\t\tif is_vowel?(character)\n\t\t\
    \tencoded_message << decode_vowel(character)\n\t\telse\n\t\t\tencoded_message\
    \ << character\n\t\tend\n\t\tindex += 1\n\tend\n\tencoded_message\nend", "  encoder\
    \ = 'abcdefghijklmnopqrstuvwxyz'.split('')\n  new_message = ''\n  message.each_char\
    \ do |char|\n    if char == char.upcase\n      new_char = encoder[(encoder.index(char.downcase)\
    \ + 2) % 26].upcase\n    else\n      new_char = encoder[(encoder.index(char) +\
    \ 2) % 26]\n    end\n    new_message += new_char\n  end\n  return new_message\n\
    end", "    result = []\n    alphabet = (\"a\"..\"z\").to_a\n    vowels = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n    message.each_char do |char|\n        if char.match(/[a-zA-Z]/)\n\
    \            # swap case\n            char.upcase! if char == char.downcase\n\
    \            char.downcase! if char == char.upcase\n            # if vowel\n \
    \           if vowels.include?(char)\n                current_index = alphabet.index(char)\n\
    \                new_index = current_index + 2\n                if new_index >\
    \ alphabet.length - 1\n                    new_index = new_index - alphabet.length\n\
    \                end\n                char = alphabet[new_index]\n           \
    \ end\n        end\n        result << char\n    end\n    result.join\nend", " \
    \   message.split(\"\").map{|letter| \n        if letter.upcase == letter \n \
    \           letter.downcase\n        else\n            letter.upcase\n       \
    \ end\n    }.join(\"\")\nend\nputs encode(\"test\")\nputs encode(\"This is a message\"\
    )", "  message = message.downcase.split(\"\")\n  result = []\n  vowels = %w(a\
    \ e i o u)\n  message.each do |letter|\n    if vowels.include?(letter)\n     \
    \ case letter\n      when \"a\"\n        result << \"c\"\n      when \"e\"\n \
    \       result << \"g\"\n      when \"i\"\n        result << \"k\"\n      when\
    \ \"o\"\n        result << \"m\"\n      when \"u\"\n        result << \"q\"\n\
    \      end\n    else\n      result << letter.upcase\n    end\n  end\n  result.join\n\
    end", "  vowels = \"aeiouAEIOU\"\n  encoded_msg = \"\"\n  alpha = (\"a\"..\"z\"\
    ).to_a\n  message.split(\"\").each do |char|\n    if vowels.include?(char)\n \
    \     index = alpha.index(char.downcase)\n      if index + 2 > 25\n        index\
    \ = (index + 2) - 26\n      else\n        index += 2\n      end\n      encoded_msg\
    \ += alpha[index]\n    elsif char == char.upcase\n      encoded_msg += char.downcase\n\
    \    else\n      encoded_msg += char.upcase\n    end\n  end\n  encoded_msg\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
