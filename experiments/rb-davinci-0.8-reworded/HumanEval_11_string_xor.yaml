name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor.call(\"\
  010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  a = a.reverse.split('')\n  b = b.reverse.split('')\n  result = \"\
    \"\n  a.each_with_index do |num, index|\n    if a[index] == b[index]\n      result\
    \ += \"0\"\n    else\n      result += \"1\"\n    end\n  end\n  result.reverse\n\
    end", "  xor = 0\n  short, long = [a, b].sort_by(&:length)\n  (short.length -\
    \ 1).downto(0) do |i|\n    xor = xor << 1\n    xor += (short[i].to_i ^ long[i].to_i)\n\
    \  end\n  xor = xor << (long.length - short.length) if long.length > short.length\n\
    \  xor.to_s(2)\nend", "  a.chars.zip(b.chars).map { |a, b| a.to_i ^ b.to_i }.join\n\
    end", "  # Using the XOR operator, ^\n  # a ^ b\n  # .to_s(2) converts from base\
    \ 10 to base 2\n  # .rjust(3, '0') pads the string with zeros so that the length\
    \ is 3", "  b.chars.each_with_index.map { |char, index| char == a[index] ? \"\
    0\" : \"1\" }.join(\"\")\nend", "  # raise NotImplementedError, \"TODO: string_xor\"\
    \n  a_array = a.split('')\n  b_array = b.split('')\n  a_array.zip(b_array).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a_bin = a.split('').map { |s|\
    \ s.to_i }\n  b_bin = b.split('').map { |s| s.to_i }\n  a_bin.zip(b_bin).map {\
    \ |x, y| (x ^ y).to_s }.join\nend", "  (a.to_i(2) ^ b.to_i(2)).to_s(2)\nend",
  "  # Perform XOR on each pair of characters from a and b\n  # and build a new string\
    \ from the result\n  #\n  # The new character is 1 if a_char and b_char are not\
    \ equal, 0 otherwise\n  # This is equivalent to XOR of two bits\n  result = []\n\
    \  a.chars.zip(b.chars).each do |a_char, b_char|\n    result << (a_char == b_char\
    \ ? '0' : '1')\n  end\n  result.join('')\nend", "  result = \"\"\n  i = 0\n  while\
    \ i < a.length do\n    result += (a[i].to_i ^ b[i].to_i).to_s\n    i += 1\n  end\n\
    \  result\nend", "  byte_array_xor(string_to_byte_array(a), string_to_byte_array(b)).pack(\"\
    C*\")\nend", "  xor = a.to_i(2) ^ b.to_i(2)\n  xor.to_s(2)\nend", "  a_int = a.to_i(2)\n\
    \  b_int = b.to_i(2)\n  xor_int = a_int ^ b_int\n  xor_int.to_s(2)\nend", "  result\
    \ = \"\"\n  a.length.times do |index|\n    result << (a[index] == b[index] ? \"\
    0\" : \"1\")\n  end\n  result\nend", "    a_bin = to_bin(a)\n    b_bin = to_bin(b)\n\
    \    result = String.new", "  result = ''\n  j = 0\n  while a[j]\n    if a[j]\
    \ == b[j]\n      result += '0'\n    else\n      result += '1'\n    end\n    j\
    \ += 1\n  end\n  result\nend", "  a.hex ^ b.hex\nend", "  a = a.split('')\n  b\
    \ = b.split('')\n  result = []\n  for i in 0..a.length-1\n    result << (a[i].to_i\
    \ ^ b[i].to_i).to_s\n  end\n  result.join('')\nend", "  raise NotImplementedError\n\
    end", "  # TODO\nend", "  puts \"a=#{a} b=#{b}\"\n  res = []\n  for i in 0..a.length-1\n\
    \    res << (a[i].to_i ^ b[i].to_i).to_s\n  end\n  res.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  result = ''\n  for i in 0..(a.length\
    \ - 1)\n    result += a[i] == b[i] ? '0' : '1'\n  end\n  result\nend", "  result\
    \ = \"\"\n  a.size.times do |i|\n    if a[i] == b[i]\n      result << \"0\"\n\
    \    else\n      result << \"1\"\n    end\n  end\n  result\nend", "  #TODO: implement\
    \ as described above\n  a_bin = a.to_i(2)\n  b_bin = b.to_i(2)\n  (a_bin ^ b_bin).to_s(2)\n\
    end", "  a.chars.zip(b.chars).map { |a, b| (a.to_i ^ b.to_i).to_s }.join\nend",
  "  a = a.chars.map(&:to_i)\n  b = b.chars.map(&:to_i)\n  (0...a.length).map { |i|\
    \ (a[i] + b[i]) % 2 }.join\nend", "  a_b = []\n  b_a = []\n  (0..(a.length - 1)).each\
    \ do |i|\n    a_b << a[i] == b[i] ? \"0\" : \"1\"\n  end\n  (0..(a.length - 1)).each\
    \ do |i|\n    b_a << a[i] == b[i] ? \"0\" : \"1\"\n  end\n  a_b.join(\"\")\nend",
  "  raise 'Wrong argument!' unless a.is_a?(String) && b.is_a?(String)\n  raise 'Arguments\
    \ are with different length!' unless a.length == b.length\n  result = []\n  a.chars.each_with_index\
    \ do |val, index|\n    if val == b[index]\n      result << '0'\n    else\n   \
    \   result << '1'\n    end\n  end\n  result.join\nend", "  a.each_char.with_index.map\
    \ do |char, i|\n    char.to_i ^ b[i].to_i\n  end.join\nend", "  binary = { \"\
    0\" => \"0\", \"1\" => \"1\" }\n  result = \"\"\n  a.chars.each_with_index do\
    \ |char, index|\n    result << binary[char] ^ binary[b[index]]\n  end\n  result\n\
    end", "\t# TODO: add code here\nend", "  (a.to_i(2) ^ b.to_i(2)).to_s(2)\nend",
  "  # See if you can use string.bytes first to get an array of the integer values\
    \ of each character.\n  # Then map over the array and perform your xor logic on\
    \ each element.\n  # Finally, see if you can use string.chr to go back to a string\
    \ representation of your result.\n  # You may have to be creative in how you use\
    \ string.chr.\n  a_bytearray = a.bytes\n  b_bytearray = b.bytes\n  xored_a_bytearray\
    \ = a_bytearray.map.with_index { |byte, index| byte ^ b_bytearray[index] }\n \
    \ xored_a_bytearray.map { |e| e.chr }.join\nend", "  a = a.chars.map(&:to_i)\n\
    \  b = b.chars.map(&:to_i)\n  result = []\n  a.each_with_index do |bit, index|\n\
    \    if bit == b[index]\n      result << 0\n    else\n      result << 1\n    end\n\
    \  end\n  result.join\nend", "  binary_xor(a.to_i(2), b.to_i(2)).to_s(2)\nend",
  "  result = ''\n  # Loop through the strings\n  (0..a.length - 1).each do |i|\n\
    \    # If they are the same character, append 0\n    if a[i] == b[i]\n      result\
    \ += '0'\n    else\n      # Otherwise append 1\n      result += '1'\n    end\n\
    \  end\n  # Return the result\n  result\nend", "  a_bin = a.chars.map { |char|\
    \ char.to_i(2) }\n  b_bin = b.chars.map { |char| char.to_i(2) }\n  out = []\n\
    \  a_bin.each_with_index do |char, i|\n    out << (char ^ b_bin[i])\n  end\n \
    \ out.join\nend", "  result = \"\"\n  # For each character in the String\n  a.chars.each_with_index\
    \ do |char, index|\n    # Store the XOR result of the character in the two strings\
    \ in result string\n    result << (char.to_i ^ b[index].to_i).to_s\n  end\n  result\n\
    end", "  a_arr = a.split('')\n  b_arr = b.split('')\n  result = []\n  a_arr.zip(b_arr).each\
    \ do |a, b|\n    if a == b\n      result << '0'\n    else\n      result << '1'\n\
    \    end\n  end\n  result.join('')\nend", "  a.chars.zip(b.chars).map { |c1, c2|\
    \ (c1.to_i ^ c2.to_i).to_s }.join\nend", "  puts 'hello'\n  (0..a.length-1).each\
    \ do |i|\n    puts a[i]\n    if a[i] != b[i]\n      a[i] = '1'\n    else\n   \
    \   a[i] = '0'\n    end\n  end\n  a\nend", "  result = \"\"\n  # Transform into\
    \ array of integers\n  a.each_char.with_index do |char, index|\n    if char ==\
    \ \"1\" && b[index] == \"0\"\n      result += \"1\"\n    elsif char == \"0\" &&\
    \ b[index] == \"1\"\n      result += \"1\"\n    else\n      result += \"0\"\n\
    \    end\n  end\n  result\nend", "  # Your code here\nend", "  a.to_i(2) ^ b.to_i(2)\n\
    end", "  a = a.split('')\n  b = b.split('')\n  a.zip(b).map { |a, b| a == b ?\
    \ '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? \"0\"\
    \ : \"1\" }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? \"0\" :\
    \ \"1\" }.join\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |i, j| (i.to_i ^ j.to_i).to_s }.join\nend", "  r = []\n  0.upto(a.length -\
    \ 1) do |i|\n    if a[i] == b[i]\n      r << '0'\n    else\n      r << '1'\n \
    \   end\n  end\n  r.join\nend", "  a.bytes.zip(b.bytes).map { |(a, b)| (a ^ b).chr\
    \ }.join\nend", "    if a.length != b.length\n        puts \"The two strings must\
    \ be of equal length\"\n        return\n    end\n    retval = \"\"\n    (0..a.length-1).each\
    \ do |i|\n        a_int = a[i].to_i\n        b_int = b[i].to_i\n        if (a_int\
    \ == 0 && b_int == 0) || (a_int == 1 && b_int == 1)\n            retval = retval\
    \ + \"0\"\n        else\n            retval = retval + \"1\"\n        end\n  \
    \  end\n    return retval\nend", "  raise ArgumentError, \"Expected strings of\
    \ length 1\" unless a.length == 1 && b.length == 1\n  raise ArgumentError, \"\
    Expected strings of digits 0 or 1\" unless a.match(/[01]/) && b.match(/[01]/)\n\
    \  (a.to_i ^ b.to_i).to_s\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  # todo\nend",
  "  bytes = []\n  (0..a.size - 1).each do |i|\n    bytes[i] = (a[i].to_i ^ b[i].to_i).to_s\n\
    \  end\n  bytes.join\nend", "  output = \"\"\n  i = 0\n  while i < a.length\n\
    \    output << ((a[i].to_i ^ b[i].to_i).to_s)\n    i += 1\n  end\n  output\nend",
  "  res = ''\n  [a.length, b.length].max.times do |i|\n    res += (a[i].to_i ^ b[i].to_i).to_s\n\
    \  end\n  res\nend", "  result = \"\"\n  a.length.times do |index|\n    result\
    \ += (a[index].to_i ^ b[index].to_i).to_s\n  end\n  result\nend", "  raise \"\
    TODO\"\nend", "  a.each_char.zip(b.each_char).map { |x, y| (x ^ y).to_s }.join\n\
    end", "  a = a.chars.map(&:to_i)\n  b = b.chars.map(&:to_i)\n  new_string = []\n\
    \  a.each_with_index do |num, i|\n    new_string << (num ^ b[i])\n  end\n  new_string.join('')\n\
    end", "  a = a.to_i(2)\n  b = b.to_i(2)\n  (a ^ b).to_s(2)\nend", "  # Your code\
    \ here\nend", "  a = a.to_i(2)\n  b = b.to_i(2)\n  output = a ^ b\n  output.to_s(2)\n\
    end", "  xor_strings(a, b)\nend", "  # ...\nend", "  a.split('').zip(b.split('')).map{|x,y|\
    \ x != y ? '1' : '0'}.join\nend", "  result = []\n  a.split('').zip(b.split('')).each\
    \ do |a_char, b_char|\n    if a_char == b_char\n      result << '0'\n    else\n\
    \      result << '1'\n    end\n  end\n  result.join('')\nend", "  raise \"Given\
    \ input is not a string: '#{a}'\" unless a.is_a?(String)\n  raise \"Given input\
    \ is not a string: '#{b}'\" unless b.is_a?(String)\n  a = \"0#{a}\" if a.length.odd?\n\
    \  b = \"0#{b}\" if b.length.odd?\n  raise \"Given input has invalid length: '#{a}'\"\
    \ unless a.length == b.length\n  string_xor_mongo(a, b)\nend", "  a = a.split('')\n\
    \  b = b.split('')\n  result = []\n  a.zip(b).each do |pair|\n    result << (pair[0].to_i\
    \ ^ pair[1].to_i).to_s\n  end\n  result.join\nend", "  raise ArgumentError if\
    \ a.length != b.length\n  result = \"\"\n  i = 0\n  while i < a.length\n    result\
    \ << (a[i] == b[i] ? \"0\" : \"1\")\n    i += 1\n  end\n  result\nend", "  (a.to_i(2)\
    \ ^ b.to_i(2)).to_s(2)\nend", "  #write your code here\n  result = \"\"\n  a.length.times\
    \ do |i|\n    if a[i] == b[i]\n      result += \"0\"\n    else\n      result +=\
    \ \"1\"\n    end\n  end\n  result\nend", "  a.bytes.zip(b.bytes).map{|a,b| a ^\
    \ b}.map(&:chr).join\nend", "    (a.to_i(2) ^ b.to_i(2)).to_s(2)\nend", "  a.length.times\
    \ do |i|\n    if a[i] == b[i]\n      a[i] = \"0\"\n    else\n      a[i] = \"1\"\
    \n    end\n  end\n  a\nend", "  a.chars.zip(b.chars).map { |x, y| (x == y) ? '0'\
    \ : '1' }.join\nend", "  # a = a.chars.map(&:to_i)\n  # b = b.chars.map(&:to_i)\n\
    \  # c = []\n  # a.each_with_index do |item, index|\n  #   if item != b[index]\n\
    \  #     c << \"1\"\n  #   else\n  #     c << \"0\"\n  #   end\n  # end\n  # c.join(\"\
    \")\n  (a.to_i(2) ^ b.to_i(2)).to_s(2)\nend", "  a, b = [a, b].sort_by(&:length)\n\
    \  b.chars.map.with_index { |c,i| c == a[i] ? '0' : '1' }.join\nend", "  if a.length\
    \ != b.length\n    fail \"Arguments must be of equal length\"\n  end\n  result\
    \ = \"\"\n  a.chars.each_with_index do |x, i|\n    if x != b[i]\n      result\
    \ << \"1\"\n    else\n      result << \"0\"\n    end\n  end\n  result\nend", " \
    \ string_to_integer(a) ^ string_to_integer(b)\nend", "  bit_array_to_string(bit_array_xor(bit_string_to_array(a),\
    \ bit_string_to_array(b)))\nend", "  result = \"\"\n  0.upto(a.length-1) do |i|\n\
    \    result << a[i].to_i ^ b[i].to_i\n  end\n  result\nend", "    i = 0\n    while\
    \ i < a.length\n        if a[i] == b[i]\n            a[i] = \"0\"\n        else\n\
    \            a[i] = \"1\"\n        end\n        i += 1\n    end\n    return a\n\
    end", "  a.chars.zip(b.chars).map { |c1, c2| (c1.to_i ^ c2.to_i).to_s }.join\n\
    end", "  a = a.to_i(2)\n  b = b.to_i(2)\n  r = a ^ b\n  r.to_s(2)\nend", "  a_bin\
    \ = a.to_i(2)\n  b_bin = b.to_i(2)\n  (a_bin ^ b_bin).to_s(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |a, b| a.to_i ^ b.to_i }.join\nend", "  # your code here\nend", "  # TODO:\
    \ implement me!\nend", "  raise NotImplementedError\nend", "  (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    end", "  a.to_i(2) ^ b.to_i(2)\nend", "  output = ''\n  a.length.times do |i|\n\
    \    if a[i] == b[i]\n      output << '0'\n    else\n      output << '1'\n   \
    \ end\n  end\n  output\nend", "  bin_a = a.to_i(2)\n  bin_b = b.to_i(2)\n  result\
    \ = bin_a ^ bin_b\n  result.to_s(2)\nend", "  # Your code here\nend", "\t[a, b].transpose.map{|a,\
    \ b| a ^ b}.join\nend", "  # TODO: implement me!\nend", "  # Write your function\
    \ body here.\n  # `a` and `b` are strings consisting of the characters \"0\" and\
    \ \"1\".\n  # The result should also be a string.\n  result = \"\"\n  a.length.times\
    \ do |i|\n    result += (a[i] == b[i]) ? \"0\" : \"1\"\n  end\n  result\nend",
  "  xor_string = ''\n  a.chars.each_with_index do |char, index|\n    xor_string <<\
    \ (char.to_i ^ b[index].to_i).to_s\n  end\n  xor_string\nend", "  result = ''\n\
    \  if a.length < b.length\n    s1 = a\n    s2 = b\n  else\n    s1 = b\n    s2\
    \ = a\n  end\n  s1.chars.each_with_index do |c, i|\n    if s2[i] == c\n      result\
    \ << '0'\n    else\n      result << '1'\n    end\n  end\n  result + s2[s1.length..-1]\n\
    end", "  # TODO: Perform XOR and return the result as a string\n  result = String.new\n\
    \  a.chars.each_with_index do |c, i|\n    if c == b[i]\n      result << \"0\"\n\
    \    else\n      result << \"1\"\n    end\n  end\n  result\nend", "  result =\
    \ \"\"\n  a.size.times do |i|\n    if a[i] == b[i]\n      result << \"0\"\n  \
    \  else\n      result << \"1\"\n    end\n  end\n  result\nend", "  a_split = a.split('')\n\
    \  b_split = b.split('')\n  result = ''\n  a_split.each_with_index do |a_char,\
    \ index|\n    b_char = b_split[index]\n    result += xor(a_char, b_char)\n  end\n\
    \  result\nend", "  i = 0\n  result = ''\n  loop do\n    break if i >= a.length\n\
    \    result += (a[i].to_i ^ b[i].to_i).to_s\n    i += 1\n  end\n  result\nend",
  "\ti = 0\n\tresult = \"\"\n\twhile i < a.length\n\t\tif (a[i] == b[i])\n\t\t\tresult\
    \ += \"0\"\n\t\telse\n\t\t\tresult += \"1\"\n\t\tend\n\t\ti += 1\n\tend\n\treturn\
    \ result\nend", "  len = a.length\n  res = ''\n  for i in 0..len - 1\n    if (a[i]\
    \ == '1' && b[i] == '0') || (a[i] == '0' && b[i] == '1')\n      res += '1'\n \
    \   else\n      res += '0'\n    end\n  end\n  res\nend", "  result = ''\n  if\
    \ a.length > b.length\n    a, b = b, a\n  end\n  for i in 0..(a.length - 1)\n\
    \    if a[i] == b[i]\n      result = result + '0'\n    else\n      result = result\
    \ + '1'\n    end\n  end\n  result + b[(a.length)..(b.length - 1)]\nend", "  a.chars.zip(b.chars).map\
    \ { |a, b| a == b ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |a,\
    \ b| (a.to_i ^ b.to_i).to_s }.join\nend", "  # Your code here\nend", "  raise\
    \ \"Invalid input\" if (a.size != b.size)\n  result = \"\"\n  i = 0\n  while i\
    \ < a.size\n    # result << (a[i] ^ b[i]).to_s\n    result << ((a[i] - b[i]).abs).to_s\n\
    \    i += 1\n  end\n  result\nend", "  # TODO: Implement me!\nend", "  a = a.to_i(2)\n\
    \  b = b.to_i(2)\n  c = a ^ b\n  c.to_s(2)\nend", "  ################################################################\n\
    \  # No need to touch anything below this line.\n  ################################################################\n\
    \  raise ArgumentError, \"One or more arguments is not a string.\" unless (a.is_a?\
    \ String and b.is_a? String)\n  return a ^ b\nend", "  a = a.to_i(2)\n  b = b.to_i(2)\n\
    \  (a ^ b).to_s(2)\nend", "  result = \"\"\n  a.chars.zip(b.chars).each do |char_a,\
    \ char_b|\n    result << (char_a.to_i ^ char_b.to_i).to_s\n  end\n  result\nend",
  "    if a.length != b.length\n        raise ArgumentError.new(\"Two strings should\
    \ have the same length\")\n    end\n    (0...a.length).each do |i|\n        if\
    \ a[i] != '0' && a[i] != '1'\n            raise ArgumentError.new(\"The string\
    \ should consist only of 1s and 0s\")\n        end\n        if b[i] != '0' &&\
    \ b[i] != '1'\n            raise ArgumentError.new(\"The string should consist\
    \ only of 1s and 0s\")\n        end\n    end\n    result = \"\"\n    (0...a.length).each\
    \ do |i|\n        if a[i] == b[i]\n            result << '0'\n        else\n \
    \           result << '1'\n        end\n    end\n    result\nend", "  if a ==\
    \ b\n    return \"0\"\n  else\n    return \"1\"\n  end\nend", "  a.chars.zip(b.chars).map{|x,y|\
    \ (x.to_i ^ y.to_i).to_s}.join\nend", "  result = \"\"\n  (0..(a.length - 1)).each\
    \ do |i|\n    result += ((a[i].to_i ^ b[i].to_i).to_s)\n  end\n  result\nend",
  "  # TODO: write this function\n  a_array = a.chars\n  b_array = b.chars\n  difference\
    \ = a_array.length - b_array.length\n  if difference < 0\n    length = a_array.length\n\
    \    a_array = a_array.fill(0,a_array.length, difference.abs)\n  else\n    length\
    \ = b_array.length\n    b_array = b_array.fill(0,b_array.length, difference.abs)\n\
    \  end\n  result = []\n  length.times do |i|\n    if a_array[i] == b_array[i]\n\
    \      result.push(0)\n    else\n      result.push(1)\n    end\n  end\n  result.join\n\
    end", "  a_bits = a.chars.map(&:to_i)\n  b_bits = b.chars.map(&:to_i)\n  xor_bits\
    \ = a_bits.zip(b_bits).map { |a, b| a ^ b }\n  xor_bits.join\nend", "  c = a.split('').map(&:to_i)\n\
    \  d = b.split('').map(&:to_i)\n  i = 0\n  result = []\n  while i < a.length\n\
    \    if c[i] == d[i]\n      result.push(0)\n    else\n      result.push(1)\n \
    \   end\n    i += 1\n  end\n  result.join('')\nend", "  (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    end", "  # TODO: implement this\nend", "  binary_xor(a.to_i(2), b.to_i(2)).to_s(2)\n\
    end", "  a.length < b.length ? xor(a, b) : xor(b, a)\nend", "  a.bytes.zip(b.bytes).map{|a,b|\
    \ a^b}.pack('c*')\nend", "  if a.length > b.length\n    a = a[0...b.length]\n\
    \  elsif b.length > a.length\n    b = b[0...a.length]\n  end\n  a.length.times.map{|i|\
    \ a[i] ^ b[i]}.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  raise ArgumentError unless a.length == b.length\n  result =\
    \ \"\"\n  a.length.times do |i|\n    result += (a[i] == b[i]) ? \"0\" : \"1\"\n\
    \  end\n  result\nend", "  a.each_char.with_index.reduce(\"\") do |acc, (char,\
    \ i)|\n    acc << (char.to_i ^ b[i].to_i).to_s\n  end\nend", "  (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    end", "  a = a.split('')\n  b = b.split('')\n  a_xor_b = []\n  a.each_with_index\
    \ do |val, ind|\n    if val == b[ind]\n      a_xor_b << \"0\"\n    else\n    \
    \  a_xor_b << \"1\"\n    end\n  end\n  a_xor_b.join\nend", "  a_bytes = a.unpack('B*')[0].chars\n\
    \  b_bytes = b.unpack('B*')[0].chars\n  a_bytes.zip(b_bytes).map{|a,b| a.to_i\
    \ ^ b.to_i}.join\nend", "  answer = \"\"\n  a.length.times do |i|\n    if a[i]\
    \ == b[i]\n      answer += \"0\"\n    else\n      answer += \"1\"\n    end\n \
    \ end\n  answer\nend", "  raise ArgumentError, \"a and b must be the same length\"\
    \ unless a.length == b.length\n  result = \"\"\n  a.length.times do |i|\n    result\
    \ += (a[i] == b[i]) ? \"0\" : \"1\"\n  end\n  result\nend", "  a.zip(b).map {\
    \ |a, b| a.to_i ^ b.to_i }.join\nend", "  a.unpack('C*').zip(b.unpack('C*')).map\
    \ { |x, y| x ^ y }.pack('C*')\nend", "\tar_a = a.split('')\n\tar_b = b.split('')\n\
    \tar_res = []\n\tar_a.each_with_index do |bit, idx|\n\t\tar_res << (bit.to_i ^\
    \ ar_b[idx].to_i).to_s\n\tend\n\tar_res.join('')\nend", "  ai = a.to_i(2)\n  bi\
    \ = b.to_i(2)\n  ci = ai ^ bi\n  c = ci.to_s(2)\n  # puts \"#{a} (#{ai}) ^ #{b}\
    \ (#{bi}) = #{c} (#{ci})\"\n  c\nend", "  raise ArgumentError, \"Arguments need\
    \ to be strings\" unless a.class == String && b.class == String\n  raise ArgumentError,\
    \ \"Arguments need to be valid binary strings\" unless a.split('').all? { |x|\
    \ x == '0' || x == '1' } && b.split('').all? { |x| x == '0' || x == '1' }\n  raise\
    \ ArgumentError, \"Arguments need to be of equal length\" unless a.length == b.length\n\
    \  c = \"\"\n  if a.split('').zip(b.split('')).all? { |x, y| x != y }\n    a.split('').zip(b.split('')).each\
    \ do |x, y|\n      c << \"1\"\n    end\n  else\n    a.split('').zip(b.split('')).each\
    \ do |x, y|\n      if x == y\n        c << \"0\"\n      else\n        c << \"\
    1\"\n      end\n    end\n  end\n  c\nend", "  raise \"Invalid string size\" if\
    \ a.size != b.size\n  a.size.times.map { |i| a[i] == b[i] ? '0' : '1' }.join\n\
    end", "  a_bytes = a.bytes\n  b_bytes = b.bytes\n  output = ''\n  for i in 0..a_bytes.length\
    \ - 1\n    output << (a_bytes[i] ^ b_bytes[i]).to_s\n  end\n  output\nend", " \
    \ result = \"\"\n  i = 0\n  while i < a.length\n    if a[i] == b[i]\n      result\
    \ += \"0\"\n    else\n      result += \"1\"\n    end\n    i += 1\n  end\n  result\n\
    end", "  if a.length != b.length\n    puts \"XOR only takes strings of equal length.\"\
    \n    return nil\n  end\n  output = \"\"\n  (0...a.length).each do |i|\n    output\
    \ += (a[i].to_i ^ b[i].to_i).to_s\n  end\n  output\nend", "\traise \"wrong usage\"\
    \ if a.size != b.size\n\ts = a.size\n\tresult = \"\"\n\t(0...s).each do |i|\n\t\
    \tresult << ((a[i]==b[i]) ? \"0\" : \"1\")\n\tend\n\tresult\nend", "  (a.to_i(2)\
    \ ^ b.to_i(2)).to_s(2)\nend", "  (a.to_i(2) ^ b.to_i(2)).to_s(2)\nend", '  raise
    "Invalid input" if a.length != b.length', "  a_arr = a.split('')\n  b_arr = b.split('')\n\
    \  arr = []\n  i = 0\n  while i < a_arr.length\n    if a_arr[i] == b_arr[i]\n\
    \      arr.push('0')\n    else\n      arr.push('1')\n    end\n    i += 1\n  end\n\
    \  arr.join\nend", "  #https://www.codewars.com/kata/56f695399400f5d9ef000af5/train/ruby\n\
    \  a.hex ^ b.hex\nend", "  res = \"\"\n  for i in 0..a.length\n    if (a[i] ==\
    \ b[i])\n      res += \"0\"\n    else\n      res += \"1\"\n    end\n  end\n  res\n\
    end", "  # TODO: Refactor\n  # return (a.to_i(2) ^ b.to_i(2)).to_s(2)\n  result\
    \ = \"\"\n  a.size.times do |i|\n    result += \"#{a[i].to_i ^ b[i].to_i}\"\n\
    \  end\n  result\nend", "  a.chars.zip(b.chars).map{|x,y| x.to_i ^ y.to_i}.join\n\
    end", "  a.chars.zip(b.chars).map { |ac, bc| (ac.to_i ^ bc.to_i).to_s }.join\n\
    end", "  # TODO: Implement this method\n  return nil\nend", "  out = \"\"\n  for\
    \ i in 0..a.length - 1\n    if a[i] == b[i]\n      out += \"0\"\n    else\n  \
    \    out += \"1\"\n    end\n  end\n  out\nend", "  res = ''\n  (0..(a.length-1)).each\
    \ do |idx|\n    aa = a[idx]\n    bb = b[idx]\n    res << ((aa == bb) ? '0' : '1')\n\
    \  end\n  res\nend", "  # your code here\nend", "  # The idea is to have a temporary\
    \ string where we will be storing our\n  # resulting string. We will also be keeping\
    \ a track of the index at which\n  # we have to insert the character in this temporary\
    \ string.\n  #\n  # We will loop from 0 to the length of the smaller string and\
    \ insert characters\n  # in the temporary string based on our understanding of\
    \ XOR.\n  #\n  # If both the characters of the string at position i are the same,\
    \ we will\n  # insert a '0' in the temporary string at the ith position.\n  #\n\
    \  # If both the characters of the string at position i are different, we will\n\
    \  # insert a '1' in the temporary string at the ith position.\n  #\n  # We will\
    \ return this temporary string once we have iterated over the smaller\n  # string.",
  "  # TODO\nend", "  result = []\n  i = 0\n  while i < a.length\n    if a[i] == b[i]\n\
    \      result << \"0\"\n    else\n      result << \"1\"\n    end\n    i += 1\n\
    \  end\n  result.join\nend", "\ta.to_i(2) ^ b.to_i(2)\nend", "  a.to_i(2) ^ b.to_i(2)\n\
    end", "    i = 0\n    if a.length != b.length\n        puts 'strings must be same\
    \ length'\n        return\n    end\n    output = ''\n    while i < a.length\n\
    \        output << (a[i].to_i ^ b[i].to_i).to_s\n        i += 1\n    end\n   \
    \ return output\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  a, b = [a, b].sort_by(&:length)\n\
    \  b[0...a.length].chars.zip(a.chars).map{|x, y| (x.to_i ^ y.to_i).to_s }.join\n\
    end", "  a = a.split('')\n  b = b.split('')\n  result = []\n  a.each_with_index\
    \ do |x, i|\n    if x == b[i]\n      result << '0'\n    else\n      result <<\
    \ '1'\n    end\n  end\n  result.join('')\nend", "  b.to_i(2) ^ a.to_i(2)\nend",
  "  a_to_i = a.to_i(2)\n  b_to_i = b.to_i(2)\n  result = a_to_i ^ b_to_i\n  result.to_s(2)\n\
    end", "  a.chars.zip(b.chars).map{|a,b| a ^ b }.join('')\nend", "  str_xor = a.chars.map.with_index\
    \ { |c, i| c ^ b[i] }.join\nend", "  a.each_char.map.with_index { |n, i| n.to_i\
    \ ^ b[i].to_i }.join\nend", "  raise \"not implemented\"\nend", "  a = a.split('')\n\
    \  b = b.split('')\n  result = []\n  a.each_with_index do |element, index|\n \
    \   result.push((a[index].to_i ^ b[index].to_i).to_s)\n  end\n  result.join('')\n\
    end", "  @params.update(\n    :a => a,\n    :b => b\n  )\n  @a = @params[:a]\n\
    \  @b = @params[:b]\n  xor = ''\n  @a.size.times do |i|\n    xor << (@a[i].to_i\
    \ ^ @b[i].to_i).to_s\n  end\n  xor\nend", "  raise NotImplementedError\nend",
  "  a.chars.zip(b.chars).map { |(x, y)| (x.to_i ^ y.to_i).to_s }.join\nend", "  (a.to_i(2)\
    \ ^ b.to_i(2)).to_s(2)\nend", "  a = a.split('')\n  b = b.split('')\n  result\
    \ = []\n  a.each_with_index do |_, i|\n    result << (a[i].to_i ^ b[i].to_i).to_s\n\
    \  end\n  result.join\nend", '  a, b = b, a if a.length > b.length', "  a.split('').map.with_index\
    \ { |x, i| x == b[i] ? 0 : 1 }.join\nend", "  if a.length != b.length\n    raise\
    \ ArgumentError, \"a and b should have the same length\"\n  end", "  a.bytes.zip(b.bytes).map\
    \ { |i, j| (i ^ j).chr }.join\nend", "  result = \"\"\n  (0..(a.length-1)).each\
    \ do |i|\n    if (a[i] == \"1\" && b[i] == \"0\") || (a[i] == \"0\" && b[i] ==\
    \ \"1\")\n      result += \"1\"\n    else\n      result += \"0\"\n    end\n  end\n\
    \  result\nend", "  result = String.new\n  return result if a.length != b.length\n\
    \  a.chars.each_with_index do |c, i|\n    result << ((c.to_i == b[i].to_i) ? '0'\
    \ : '1')\n  end\n  result\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  binary_xor(a.to_i(2),\
    \ b.to_i(2)).to_s(2)\nend", "  raise ArgumentError, \"Arguments must be the same\
    \ length\" unless a.length == b.length\n  (0...a.length).map { |i| a[i] == b[i]\
    \ ? \"0\" : \"1\" }.join\nend", "  a = a.split('')\n  b = b.split('')\n  z = []\n\
    \  (0..a.length-1).each do |i|\n    z[i] = a[i].to_i ^ b[i].to_i\n  end\n  return\
    \ z.join\nend", "  a.length.times.map { |i| ((a[i].to_i ^ b[i].to_i) & 1).to_s\
    \ }.join\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  a_bin = a.chars.map(&:to_i)\n\
    \  b_bin = b.chars.map(&:to_i)\n  c_bin = a_bin.zip(b_bin).map { |x, y| x ^ y\
    \ }.join\nend", "  (a.to_i(2) ^ b.to_i(2)).to_s(2)\nend", "  a = a.split('')\n\
    \  b = b.split('')\n  result = []\n  # p a\n  # p b\n  length = a.length\n  length.times\
    \ do |i|\n    # p i\n    if a[i] == b[i]\n      result << '0'\n    else\n    \
    \  result << '1'\n    end\n  end\n  result.join\nend", "  raise StandardError.new(\"\
    inputs not same length\") if a.length != b.length\n  (0...a.length).inject(\"\"\
    ) do |result, i|\n    result << ((a[i] == b[i]) ? \"0\" : \"1\")\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
