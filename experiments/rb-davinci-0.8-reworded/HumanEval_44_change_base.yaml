name: HumanEval_44_change_base
language: rb
prompt: "# Change numerical base of input number x to base.\n# return string representation\
  \ after the conversion.\n# base numbers are less than 10.\n# >>> change_base.call(8,\
  \ 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7,\
  \ 2)\n# \"111\"\ndef change_base(x, base)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n\
  \    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8,\
  \ 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\"\
  , candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n\
  \    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7,\
  \ 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3,\
  \ 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5,\
  \ 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7,\
  \ 8))\n  end\nend\n"
completions: ["  s = \"\"\n  number = x\n  until number == 0\n    s << (number % base).to_s\n\
    \    number /= base\n  end\n  s.reverse\nend", "  # Fill your code here.\nend",
  "  # TODO: Your code here\nend", "  change_base_recursive(x, base, \"\")\nend",
  "  raise ArgumentError.new \"Base must be less than 10\" if base > 10\n  stack =\
    \ Stack.new\n  while x > 0\n    stack.push(x % base)\n    x /= base\n  end\n \
    \ result = \"\"\n  while stack.size > 0\n    result += stack.pop.to_s\n  end\n\
    \  result\nend", "  if x == 0\n    0\n  else\n    x%base + change_base(x/base,\
    \ base).to_s\n  end\nend", "  return x.to_s(base)\nend", "  # TODO: find the string\
    \ representation of x in base\n  # num = nil\n  # num = \"...\"\n  # return num\n\
    \  # i = 10\n  # y = base**i\n  # z = (x.to_f/y).to_i\n  # #z = (x.to_f/base).to_i\n\
    \  # if z > 0\n  #   z.to_s + change_base(x - z*y, base)\n  # elsif z == 0\n \
    \ #   z.to_s + change_base(x, base)\n  # else \n  #   z.to_s\n  # end\n  # return\
    \ x.to_s\n  output = ''\n  mod = 0\n  while x != 0\n    mod = x % base\n    x\
    \ = x / base\n    output = output + mod.to_s\n  end\n  output.reverse\nend", '  raise
    ArgumentError if base > 10', "  if x / base == 0\n    x.to_s\n  else\n    change_base(x\
    \ / base, base) + (x % base).to_s\n  end\nend", end, "  # base = 3\n  # 111 ->\
    \ 22\n  # x = 7\n  # [1, 2, 3] = [0, 1, 2]\n  # [0, 1, 2] = [1, 2, 3]\n  # return\
    \ \"22\"\n  #return \"111\"\n  #return \"1000\"\n  return x.to_s if base <= 10\n\
    \  digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')\n  result = ''\n\
    \  while x > 0\n    remainder = x % base\n    result = digits[remainder] + result\n\
    \    x = x / base\n  end\n  result\nend", end, "  x.divmod(base).inject do |left,right|\n\
    \    left.to_s + right.to_s\n  end\nend", "  # TODO: Your code here.\nend", " \
    \ change_base_recursive(x, base, \"\")\nend", "  q = x\n  ans = \"\"\n  while\
    \ q > 0\n    q, r = q.divmod(base)\n    ans = r.to_s + ans\n  end\n  ans\nend",
  "  digits = []\n  while x > 0\n    digits << x % base\n    x /= base\n  end\n  digits.reverse.join('')\n\
    end", "  x.to_s(base)\nend", "  # convert number to base 10 from base\n  # convert\
    \ number to base from base 10\n  # return string representation\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
