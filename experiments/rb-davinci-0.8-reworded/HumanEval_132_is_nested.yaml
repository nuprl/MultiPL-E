name: HumanEval_132_is_nested
language: rb
prompt: "# Create a function that takes a string as input which contains only square\
  \ brackets.\n# The function should return true if and only if there is a valid subsequence\
  \ of brackets \n# where at least one bracket in the subsequence is nested.\n# >>>\
  \ is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n#\
  \ false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n\
  # false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\"\
  )\n# true\ndef is_nested(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n\
  \    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"\
  ))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false,\
  \ candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n \
  \   assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"\
  []]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false,\
  \ candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n \
  \   assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"\
  [[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false,\
  \ candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"\
  ))\n  end\nend\n"
completions: ["  return false if string.length % 2 != 0\n  stack = []\n  string.each_char\
    \ do |char|\n    case char\n    when \"[\"\n      stack.push(char)\n    when \"\
    ]\"\n      return false if stack.empty?\n      stack.pop\n    end\n  end\n  stack.empty?\n\
    end", "  stack = []\n  result = true\n  string.each_char do |char|\n    if char\
    \ == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n      if stack.empty?\n\
    \        result = false\n        break\n      else\n        stack.pop\n      end\n\
    \    end\n  end\n  result && stack.empty?\nend\nis_nested = method(:is_nested)",
  "  count = 0\n  string.each_char do |i|\n    if i == \"[\"\n      count += 1\n \
    \   elsif i == \"]\"\n      count -= 1\n    end\n    return false if count < 0\n\
    \  end\n  count > 0 ? false : true\nend", "  stack = []\n  string.chars.each do\
    \ |char|\n    if char == \"[\"\n      stack.push(char)\n    else\n      if stack.length\
    \ > 0\n        stack.pop\n      else\n        return false\n      end\n    end\n\
    \  end\n  return stack.length > 0\nend", "  return false if string.count(\"[\"\
    ) != string.count(\"]\")\n  return false if string.match(/\\[\\]/) == nil\n  true\n\
    end", "  count = 0\n  (0...string.length).each do |i|\n    break if count == -1\n\
    \    count += 1 if string[i] == \"[\"\n    count -= 1 if string[i] == \"]\"\n\
    \  end\n  count == 0\nend", "  return true if string.gsub(/[^[]/,\"\").length\
    \ == 0\n  return false if string.gsub(/[^[]/,\"\").length == 1\n  return false\
    \ if string.gsub(/[^\\]]/,\"\").length == 1\n  return false if string.gsub(/[^\\\
    ]]/,\"\").length > string.gsub(/[^[]/,\"\").length", "  substrings = []\n  string.chars.each_with_index\
    \ do |char, index|\n    if index != string.length - 1\n      substrings << string[index..index\
    \ + 1]\n    end\n  end\n  substrings.any? { |string| string == \"[]\" }\nend",
  "  array = string.split(\"\")\n  return false if string.count(\"]\") > string.count(\"\
    [\")\n  return false if string.count(\"[\") % 2 != 0\n  return false if string.count(\"\
    ]\") % 2 != 0\n  nested = false\n  until array.length == 0\n    if array[0] ==\
    \ \"[\" && array[1] == \"[\"\n      nested = true\n      array.shift(2)\n    elsif\
    \ array[0] == \"[\" && array[1] == \"]\"\n      array.shift(2)\n    elsif array[0]\
    \ == \"]\" && array[1] == \"]\"\n      array.shift(2)\n    elsif array[0] == \"\
    ]\" && array[1] == \"[\"\n      array.shift(2)\n    end\n  end\n  nested\nend",
  "  string.gsub(/\\[{2,}|\\]{2,}/,\"\")\nend", "  open_brackets = 0\n  string.each_char\
    \ do |bracket|\n    open_brackets += 1 if bracket == \"[\"\n    open_brackets\
    \ -= 1 if bracket == \"]\"\n    return false if open_brackets < 0\n  end\n  return\
    \ true if open_brackets == 0\n  false\nend", "  balanced_brackets?(string) &&\
    \ !unbalanced_brackets?(string)\nend", '    count = 0', "\t# Your code goes here\n\
    \tcount_left = 0\n\tcount_right = 0\n\tfinal_count = 0\n\tif string.empty?\n\t\
    \tfalse\n\telsif string.length == 1\n\t\tfalse\n\telse\n\t\tstring.split(\"\"\
    ).each do |bracket|\n\t\t\tif bracket == \"[\"\n\t\t\t\tcount_left += 1\n\t\t\t\
    elsif bracket == \"]\"\n\t\t\t\tcount_right += 1\n\t\t\tend\n\t\tend\n\t\tfinal_count\
    \ = count_left - count_right\n\t\tif final_count < 0\n\t\t\tfalse\n\t\telsif final_count\
    \ > 0\n\t\t\ttrue\n\t\telse\n\t\t\tfalse\n\t\tend\n\tend\nend", "    bracket_hash\
    \ = Hash.new\n    string.split(\"\").each do |element|\n        bracket_hash[element]\
    \ ? bracket_hash[element] += 1 : bracket_hash[element] = 1\n    end\n    (bracket_hash[\"\
    [\"] && bracket_hash[\"]\"]) && (bracket_hash[\"[\"] > bracket_hash[\"]\"]) ?\
    \ true : false\nend", "\tstring.scan(/\\[\\]/).empty?\nend", "  # string = [[]]\n\
    \  # string = []\n  # string = [[][]]\n  # string = [][]\n  # string = [[]]\n\
    \  # string = []]]]]]][[[[[]\n  # string = [][]\n  # string = []\n  # string =\
    \ [[][]]\n  # string = [[]][[\n  \n  # iterate through the string\n  # we need\
    \ to keep track of our open_brackets\n  # we need to keep track of our close_brackets\n\
    \  # we need to keep track of our last_open\n  # we need to keep track of our\
    \ last_close\n  # we need to look for [[ or ][\n  \n  # open_brackets = 0\n  #\
    \ close_brackets = 0\n  # last_open = nil\n  # last_close = nil\n  \n  # string.each_char\
    \ do |char|\n  #   if char == \"[\"\n  #     open_brackets += 1\n  #     last_open\
    \ = char\n  #   elsif char == \"]\"\n  #     close_brackets += 1\n  #     last_close\
    \ = char\n  #   end\n  # end\n  \n  # if open_brackets == close_brackets && last_open\
    \ == \"[\" && last_close == \"]\"\n  #   true\n  # else\n  #   false\n  # end\n\
    \  \n  open_brackets = 0\n  close_brackets = 0\n  last_open = nil\n  last_close\
    \ = nil\n  \n  string.each_char do |char|\n    if char == \"[\"\n      open_brackets\
    \ += 1\n      last_open = char\n    elsif char == \"]\"\n      close_brackets\
    \ += 1\n      last_close = char\n    end\n  end\n  \n  # if open_brackets > close_brackets\
    \ && last_open == \"[\" && last_close == \"]\"\n  #   true\n  # else\n  #   false\n\
    \  # end\n  \n  # if open_brackets < close_brackets && last_open == \"[\" && last_close\
    \ == \"]\"\n  #   true\n  # else\n  #   false\n  # end\n  ", "  # TODO: implement\
    \ this method\nend", "  if string.count(\"[\") != string.count(\"]\")\n    return\
    \ false\n  else\n    stack = []\n    string.each_char do |char|\n      if char\
    \ == \"[\"\n        stack.push(char)\n      else\n        if stack.last == \"\
    [\"\n          stack.pop\n        else\n          return false\n        end\n\
    \      end\n    end\n    return true\n  end\nend", "  nested_brackets = 0\n  string.chars.each\
    \ do |char|\n    if char == \"[\" && nested_brackets == 0\n      nested_brackets\
    \ += 1\n    elsif char == \"[\" && nested_brackets > 0\n      return true\n  \
    \  elsif char == \"]\" && nested_brackets > 0\n      nested_brackets -= 1\n  \
    \  end\n  end\n  false\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
