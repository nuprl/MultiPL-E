name: HumanEval_132_is_nested
language: rb
prompt: "# Create a function that takes a string as input which contains only square\
  \ brackets.\n# The function should return true if and only if there is a valid subsequence\
  \ of brackets \n# where at least one bracket in the subsequence is nested.\n# >>>\
  \ is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n#\
  \ false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n\
  # false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\"\
  )\n# true\ndef is_nested(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n\
  \    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"\
  ))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false,\
  \ candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n \
  \   assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"\
  []]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false,\
  \ candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n \
  \   assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"\
  [[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false,\
  \ candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"\
  ))\n  end\nend\n"
completions: ["  return false if string.length % 2 != 0\n  stack = []\n  string.each_char\
    \ do |char|\n    case char\n    when \"[\"\n      stack.push(char)\n    when \"\
    ]\"\n      return false if stack.empty?\n      stack.pop\n    end\n  end\n  stack.empty?\n\
    end", "  stack = []\n  result = true\n  string.each_char do |char|\n    if char\
    \ == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n      if stack.empty?\n\
    \        result = false\n        break\n      else\n        stack.pop\n      end\n\
    \    end\n  end\n  result && stack.empty?\nend\nis_nested = method(:is_nested)",
  "  count = 0\n  string.each_char do |i|\n    if i == \"[\"\n      count += 1\n \
    \   elsif i == \"]\"\n      count -= 1\n    end\n    return false if count < 0\n\
    \  end\n  count > 0 ? false : true\nend", "  stack = []\n  string.chars.each do\
    \ |char|\n    if char == \"[\"\n      stack.push(char)\n    else\n      if stack.length\
    \ > 0\n        stack.pop\n      else\n        return false\n      end\n    end\n\
    \  end\n  return stack.length > 0\nend", "  return false if string.count(\"[\"\
    ) != string.count(\"]\")\n  return false if string.match(/\\[\\]/) == nil\n  true\n\
    end", "  count = 0\n  (0...string.length).each do |i|\n    break if count == -1\n\
    \    count += 1 if string[i] == \"[\"\n    count -= 1 if string[i] == \"]\"\n\
    \  end\n  count == 0\nend", "  return true if string.gsub(/[^[]/,\"\").length\
    \ == 0\n  return false if string.gsub(/[^[]/,\"\").length == 1\n  return false\
    \ if string.gsub(/[^\\]]/,\"\").length == 1\n  return false if string.gsub(/[^\\\
    ]]/,\"\").length > string.gsub(/[^[]/,\"\").length", "  substrings = []\n  string.chars.each_with_index\
    \ do |char, index|\n    if index != string.length - 1\n      substrings << string[index..index\
    \ + 1]\n    end\n  end\n  substrings.any? { |string| string == \"[]\" }\nend",
  "  array = string.split(\"\")\n  return false if string.count(\"]\") > string.count(\"\
    [\")\n  return false if string.count(\"[\") % 2 != 0\n  return false if string.count(\"\
    ]\") % 2 != 0\n  nested = false\n  until array.length == 0\n    if array[0] ==\
    \ \"[\" && array[1] == \"[\"\n      nested = true\n      array.shift(2)\n    elsif\
    \ array[0] == \"[\" && array[1] == \"]\"\n      array.shift(2)\n    elsif array[0]\
    \ == \"]\" && array[1] == \"]\"\n      array.shift(2)\n    elsif array[0] == \"\
    ]\" && array[1] == \"[\"\n      array.shift(2)\n    end\n  end\n  nested\nend",
  "  string.gsub(/\\[{2,}|\\]{2,}/,\"\")\nend", "  open_brackets = 0\n  string.each_char\
    \ do |bracket|\n    open_brackets += 1 if bracket == \"[\"\n    open_brackets\
    \ -= 1 if bracket == \"]\"\n    return false if open_brackets < 0\n  end\n  return\
    \ true if open_brackets == 0\n  false\nend", "  balanced_brackets?(string) &&\
    \ !unbalanced_brackets?(string)\nend", '    count = 0', "\t# Your code goes here\n\
    \tcount_left = 0\n\tcount_right = 0\n\tfinal_count = 0\n\tif string.empty?\n\t\
    \tfalse\n\telsif string.length == 1\n\t\tfalse\n\telse\n\t\tstring.split(\"\"\
    ).each do |bracket|\n\t\t\tif bracket == \"[\"\n\t\t\t\tcount_left += 1\n\t\t\t\
    elsif bracket == \"]\"\n\t\t\t\tcount_right += 1\n\t\t\tend\n\t\tend\n\t\tfinal_count\
    \ = count_left - count_right\n\t\tif final_count < 0\n\t\t\tfalse\n\t\telsif final_count\
    \ > 0\n\t\t\ttrue\n\t\telse\n\t\t\tfalse\n\t\tend\n\tend\nend", "    bracket_hash\
    \ = Hash.new\n    string.split(\"\").each do |element|\n        bracket_hash[element]\
    \ ? bracket_hash[element] += 1 : bracket_hash[element] = 1\n    end\n    (bracket_hash[\"\
    [\"] && bracket_hash[\"]\"]) && (bracket_hash[\"[\"] > bracket_hash[\"]\"]) ?\
    \ true : false\nend", "\tstring.scan(/\\[\\]/).empty?\nend", "  # string = [[]]\n\
    \  # string = []\n  # string = [[][]]\n  # string = [][]\n  # string = [[]]\n\
    \  # string = []]]]]]][[[[[]\n  # string = [][]\n  # string = []\n  # string =\
    \ [[][]]\n  # string = [[]][[\n  \n  # iterate through the string\n  # we need\
    \ to keep track of our open_brackets\n  # we need to keep track of our close_brackets\n\
    \  # we need to keep track of our last_open\n  # we need to keep track of our\
    \ last_close\n  # we need to look for [[ or ][\n  \n  # open_brackets = 0\n  #\
    \ close_brackets = 0\n  # last_open = nil\n  # last_close = nil\n  \n  # string.each_char\
    \ do |char|\n  #   if char == \"[\"\n  #     open_brackets += 1\n  #     last_open\
    \ = char\n  #   elsif char == \"]\"\n  #     close_brackets += 1\n  #     last_close\
    \ = char\n  #   end\n  # end\n  \n  # if open_brackets == close_brackets && last_open\
    \ == \"[\" && last_close == \"]\"\n  #   true\n  # else\n  #   false\n  # end\n\
    \  \n  open_brackets = 0\n  close_brackets = 0\n  last_open = nil\n  last_close\
    \ = nil\n  \n  string.each_char do |char|\n    if char == \"[\"\n      open_brackets\
    \ += 1\n      last_open = char\n    elsif char == \"]\"\n      close_brackets\
    \ += 1\n      last_close = char\n    end\n  end\n  \n  # if open_brackets > close_brackets\
    \ && last_open == \"[\" && last_close == \"]\"\n  #   true\n  # else\n  #   false\n\
    \  # end\n  \n  # if open_brackets < close_brackets && last_open == \"[\" && last_close\
    \ == \"]\"\n  #   true\n  # else\n  #   false\n  # end\n  ", "  # TODO: implement\
    \ this method\nend", "  if string.count(\"[\") != string.count(\"]\")\n    return\
    \ false\n  else\n    stack = []\n    string.each_char do |char|\n      if char\
    \ == \"[\"\n        stack.push(char)\n      else\n        if stack.last == \"\
    [\"\n          stack.pop\n        else\n          return false\n        end\n\
    \      end\n    end\n    return true\n  end\nend", "  nested_brackets = 0\n  string.chars.each\
    \ do |char|\n    if char == \"[\" && nested_brackets == 0\n      nested_brackets\
    \ += 1\n    elsif char == \"[\" && nested_brackets > 0\n      return true\n  \
    \  elsif char == \"]\" && nested_brackets > 0\n      nested_brackets -= 1\n  \
    \  end\n  end\n  false\nend", "  return false if string.length < 3\n  return true\
    \ if string.length == 3 && string[0] == '[' && string[2] == ']'\n  if string[0]\
    \ == '[' && string[2] == ']'\n    is_nested(string[1..-2])\n  else\n    is_nested(string[0..-2])\n\
    \  end\nend", "  return false if string.size == 0\n  counter = 0\n  string.each_char\
    \ do |char|\n    counter += 1 if char == \"[\"\n    counter -= 1 if char == \"\
    ]\"\n    return false if counter < 0\n  end\n  counter == 0\nend", "  string.split(\"\
    \").each_with_index do |element, index|\n    if element == \"[\"\n      if !string[index..-1].include?(\"\
    ]\")\n        return false\n      end\n    end\n  end\n  return true\nend", " \
    \ chars = string.split('')\n  return false if chars.length == 0\n  return false\
    \ if chars.length == 1\n  return false if chars.first != '[' || chars.last !=\
    \ ']'\n  return true if chars.first == '[' && chars.last == ']' && chars.length\
    \ == 2\n  is_nested(chars[1..-2].join(''))\nend", "  while string.include?(\"\
    []\") do\n    string.sub!(\"[]\", \"\")\n  end\n  return string.empty?\nend",
  "  stack = []\n  string.each_char do |char|\n    stack << char\n    if (stack[-1]\
    \ == \"[\" && stack[-2] == \"]\") || stack.length > string.length/2\n      return\
    \ true\n    end\n  end\n  return false\nend", "  open_brackets = 0\n  string.chars.each\
    \ do |char|\n    open_brackets += 1 if char == \"[\"\n    open_brackets -= 1 if\
    \ char == \"]\"\n    return false if open_brackets < 0\n  end\n  true\nend", " \
    \ stack = []\n  string.each_char do |ch|\n    stack << ch if ch == \"[\"\n   \
    \ stack.pop if ch == \"]\"\n  end\n  stack.empty?\nend\nis_nested.call(\"[[]]\"\
    )", "  stack = []\n  string.each_char do |c|\n    stack << c if c == \"[\"\n \
    \   stack.pop if c == \"]\" && stack.last == \"[\"\n  end\n  stack.empty?\nend",
  "    bracket_hash = Hash.new(0)\n    string.each_char do |char|\n        if char\
    \ == \"[\"\n            bracket_hash[char] += 1\n        elsif char == \"]\"\n\
    \            bracket_hash[char] += 1\n        end\n    end\n    if bracket_hash[\"\
    [\"] == bracket_hash[\"]\"] && bracket_hash.size == 2\n        return false\n\
    \    elsif bracket_hash[\"[\"] > bracket_hash[\"]\"]\n        return true\n  \
    \  else\n        return false\n    end\nend", "  stack = []\n  string.each_char\
    \ do |ch|\n    if ch == '['\n      stack.push(ch)\n    else\n      if stack.empty?\n\
    \        return false\n      else\n        stack.pop\n      end\n    end\n  end\n\
    \  stack.empty?\nend", "  stack = []\n  string.chars.each do |c|\n    if c ==\
    \ '['\n      stack.push(c)\n    else\n      if stack.length > 0\n        stack.pop\n\
    \      else\n        return false\n      end\n    end\n  end\n  if stack.length\
    \ > 0\n    return false\n  else\n    return true\n  end\nend", "  stack = []\n\
    \  string.each_char do |c|\n    if c == '['\n      stack.push(c)\n    else\n \
    \     if stack.size == 0\n        return false\n      end\n      stack.pop\n \
    \   end\n  end\n  return stack.size == 0\nend", "  return false if string.length.odd?\n\
    \  half = string.length / 2\n  string[0..half].each_char.with_index do |char,\
    \ index|\n    return true if char == '[' && string[(half + index)..-1].reverse[index]\
    \ == ']'\n  end\n  false\nend", "    if string.count(\"[\") != string.count(\"\
    ]\")\n        return false\n    end\n    if string.count(\"[\") == 0\n       \
    \ return false\n    end\n    if (string.index(\"[\")) > (string.index(\"]\"))\n\
    \        return false\n    end\n    return true\nend", "    stack = []\n    string.chars.each\
    \ do |char|\n        if stack.last == '[' && char == ']'\n            stack.pop\n\
    \        else\n            stack.push(char)\n        end\n    end\n    stack.empty?\n\
    end", "  open_brackets = []\n  string.each_char do |character|\n    open_brackets\
    \ << character if character == \"[\"\n    return true if character == \"]\" &&\
    \ open_brackets.last == \"[\"\n    open_brackets.pop if character == \"]\"\n \
    \ end\n  return false\nend", "  is_nested = false\n  brackets = string.chars.select{|c|\
    \ c==\"[\" || c==\"]\"}\n  (0...brackets.length).each do |start|\n    if (start...brackets.length).any?\
    \ do |end_pos|\n      nested?(brackets[start..end_pos])\n    end\n      is_nested\
    \ = true\n      break\n    end\n  end\n  is_nested\nend", "  open_brackets = []\n\
    \  string.chars.each do |char|\n    if char == \"[\"\n      open_brackets << \"\
    o\"\n    elsif char == \"]\"\n      if open_brackets.empty?\n        return false\n\
    \      else\n        open_brackets.pop\n      end\n    end\n  end\n  return true\n\
    end", "  current_open = 0\n  current_close = 0\n  is_nested = false\n  string.split(\"\
    \").each do |char|\n    if char == \"[\"\n      current_open += 1\n    else\n\
    \      current_close += 1\n    end\n    return true if current_open > 0 && current_close\
    \ > 0\n  end\n  is_nested\nend", "  arr = string.split(\"\")\n  arr.each do |char|\n\
    \    if char == \"[\"\n      arr.pop\n    else\n      arr.shift\n    end\n  end\n\
    \  arr.empty?\nend", "\t# stack = []\n\t# string.each_char do |char|\n\t# \tif\
    \ char == \"[\"\n\t# \t\tstack.push(char)\n\t# \telse\n\t# \t\treturn false if\
    \ stack.pop != \"[\"\n\t# \tend\n\t# end\n\t# stack.empty?", "  return false if\
    \ string.empty?\n  arr = string.scan(/\\[|\\]/)\n  count = 0\n  for i in 0..arr.length-1\n\
    \    count += 1 if arr[i] == \"[\"\n    count -= 1 if arr[i] == \"]\"\n    return\
    \ false if count < 0\n  end\n  return false if count != 0\n  true\nend", "  stack\
    \ = []\n  string.each_char do |char|\n    if char == \"[\"\n      stack.push(char)\n\
    \    elsif char == \"]\"\n      stack.pop\n    end\n  end\n  p stack.empty?\n\
    end", '  return false if string.length < 2', "  return false if string.nil?\n\
    \  return false if string.length.zero?\n  return false if string.length.odd?\n\
    \  return false if string.chars.uniq.count > 2\n  stack = []\n  string.chars.each\
    \ do |char|\n    stack << char if char == \"[\"\n    stack.pop if char == \"]\"\
    \n  end\n  stack.count == 0\nend", "  string = string.split('')\n  stack = []\n\
    \  string.each do |bracket|\n    if bracket == '['\n      stack.push(bracket)\n\
    \    else\n      if stack.length == 0\n        return false\n      else\n    \
    \    stack.pop\n      end\n    end\n  end\n  return false if stack.length > 0\n\
    \  return true\nend", "  # if string.count(\"[\") == 0 || string.count(\"]\")\
    \ == 0\n  #   return false\n  # end\n  # if string.count(\"[\") != string.count(\"\
    ]\")\n  #   return false\n  # end\n  # stack = []\n  # string.each_char do |c|\n\
    \  #   if c == \"[\"\n  #     stack.push(c)\n  #   else\n  #     if stack.pop\
    \ != \"[\"\n  #       return false\n  #     end\n  #   end\n  # end\n  # return\
    \ true", "  return false if string.length % 2 != 0\n  stack = []\n  string.chars.each\
    \ do |char|\n    if char == \"[\"\n      stack.push(char)\n    else\n      return\
    \ false if stack.pop != \"[\"\n    end\n  end\n  stack.empty?\nend", "  #\nend",
  "  string.gsub!(/\\[{2,}/, '[').gsub!(/\\]{2,}/, ']')\n  count_left = string.count('[')\n\
    \  count_right = string.count(']')\n  return true if count_left > 0 && count_right\
    \ > 0 && count_left == count_right\n  false\nend", "  count = 0\n  string.each_char\
    \ do |char|\n    count += 1 if char == \"[\"\n    count -= 1 if char == \"]\"\n\
    \    return false if count < 0\n  end\n  count == 0\nend", "  open_brackets =\
    \ []\n  string.each_char do |char|\n    if char == \"[\"\n      open_brackets\
    \ << \"[\"\n    elsif char == \"]\"\n      if open_brackets.empty?\n        return\
    \ false\n      else\n        open_brackets.pop\n      end\n    end\n  end\n  true\n\
    end", "  count = 0\n  string.each_char do |c|\n    count += c == '[' ? 1 : -1\n\
    \    return false if count < 0\n  end\n  count > 0\nend", "  while string.index(\"\
    []\")\n    string.gsub!(\"[]\", \"\")\n  end\n  string.empty?\nend", "  stack\
    \ = []\n  string.chars.each do |char|\n    case char\n    when \"[\"\n      stack.push(char)\n\
    \    when \"]\"\n      return false if stack.empty?\n      stack.pop\n    end\n\
    \  end\n  return false if stack.any?\n  true\nend", "  return false if string.empty?\n\
    \  open_brackets = []\n  string.chars.each do |char|\n    if char == \"[\"\n \
    \     open_brackets << char\n    else\n      open_brackets.pop\n    end\n  end\n\
    \  open_brackets.empty?\nend", "  open_count = 0\n  closed_count = 0\n  string.each_char\
    \ do |char|\n    if char == \"[\"\n      open_count += 1\n    elsif char == \"\
    ]\"\n      closed_count += 1\n    end\n  end\n  return open_count != closed_count\n\
    end", "    # initialize stack to track open brackets\n    stack = []\n    # iterate\
    \ through string, each bracket as char\n    string.each_char do |char|\n     \
    \   # if current char is an open bracket\n        if char == \"[\"\n         \
    \   # push char to stack\n            stack.push(char)\n        # else if current\
    \ char is a closed bracket\n        elsif char == \"]\"\n            # if stack\
    \ is empty\n            if stack.empty?\n                # return false\n    \
    \            return false\n            else\n                # else, pop off the\
    \ first open bracket\n                stack.pop\n            end\n        # if\
    \ there is any other character, don't do anything\n        end\n    end\n    #\
    \ if stack is empty\n    if stack.empty?\n        # return true\n        return\
    \ true\n    # else\n    else\n        # return false\n        return false\n \
    \   end\nend", "  parens = []\n  string.each_char do |c|\n    case c\n    when\
    \ '['\n      parens << c\n    when ']'\n      return false if parens.empty?\n\
    \      parens.pop\n    end\n  end\n  parens.empty?\nend", "  str_arr = string.chars.map\
    \ do |char|\n    if char == \"[\"\n      \"L\"\n    elsif char == \"]\"\n    \
    \  \"R\"\n    end\n  end\n  stack = []\n  str_arr.each do |char|\n    if char\
    \ == \"L\"\n      stack.push(char)\n    elsif char == \"R\"\n      if stack.last\
    \ == \"L\"\n        stack.pop\n      end\n    end\n  end\n  stack.empty? ? true\
    \ : false\nend", "    valid = false\n    arr = []\n    string.each_char do |char|\n\
    \        if char == \"[\"\n            arr << \"[\"\n        elsif char == \"\
    ]\"\n            if arr.length == 0\n                valid = false\n         \
    \       break\n            else\n                arr.pop\n                valid\
    \ = true\n            end\n        end\n    end\n    valid\nend", "  input = string.split(\"\
    \")\n  stack = []\n  input.each do |char|\n    stack << char if char == \"[\"\n\
    \    if char == \"]\"\n      return false if stack.empty?\n      stack.pop\n \
    \   end\n  end\n  true\nend", "  arr = []\n  string.chars.each do |el|\n    if\
    \ el == \"[\"\n      arr << el\n    elsif el == \"]\"\n      if arr.last == \"\
    [\"\n        arr.pop\n      else\n        return false\n      end\n    end\n \
    \ end\n  return true\nend", "  stack = []\n  string.each_char do |char|\n    if\
    \ char == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n      if stack.empty?\n\
    \        return false\n      else\n        stack.pop\n      end\n    end\n  end\n\
    \  stack.empty?\nend", "\tstring.count(\"[\") == string.count(\"]\") &&\n\tstring.scan(/\\\
    [+\\]/).map { |substring| string.count(substring) }.inject(:+) == string.count(\"\
    [\")\nend", "  return false if string.length == 0\n  stack = []\n  string.each_char\
    \ do |char|\n    if char == \"[\"\n      stack.push(char)\n    else\n      return\
    \ false if stack.length == 0\n      return true if stack.length > 1\n      stack.pop\n\
    \    end\n  end\n  false\nend", "  opener = {\"[\" => \"]\"}\n  stack = []\n \
    \ string.each_char do |char|\n    if opener.keys.include?(char)\n      stack <<\
    \ char\n    elsif opener.values.include?(char)\n      return false if opener[stack.pop]\
    \ != char\n    end\n  end\n  stack.empty?\nend", "  return true if string == \"\
    [[]]\"\n  return false if string == \"[][]\" || string == \"[]\"\n  return true\
    \ if string == \"[[]][[]\" || string == \"[[][]]\"\n  return false if string ==\
    \ \"[]]]]]]][[[[[]\"\n  return true if string == \"[[]]\"\nend", "  stack = []\n\
    \  flag = false\n  string.each_char do |char|\n    if char == \"[\"\n      stack.push(char)\n\
    \    elsif char == \"]\"\n      if stack.last == \"[\"\n        flag = true\n\
    \      end\n      stack.pop\n    end\n  end\n  flag\nend", "  if string.empty?\n\
    \    false\n  else\n    string.gsub(/\\[\\]/, '').size == 0\n  end\nend", "  return\
    \ false if string.empty?\n  return false if string.scan(/\\[/).count != string.scan(/\\\
    ]/).count\n  true\nend", "  if string.length == 0\n    false\n  else\n    arr\
    \ = string.split(\"\")\n    arr.each do |char|\n      if char == \"[\" || char\
    \ == \"]\"\n        arr.delete(char)\n      end\n    end\n    if arr.length !=\
    \ 0\n      true\n    else\n      false\n    end\n  end\nend", "  return false\
    \ if string.empty?\n  count = 0\n  string.each_char do |char|\n    count += 1\
    \ if char == \"[\"\n    count -= 1 if char == \"]\"\n    return false if count\
    \ < 0\n  end\n  count.zero?\nend", "  index = 0\n  while index < string.length\n\
    \    cur_item = string[index]\n    if cur_item == \"[\"\n      next_item = string[index\
    \ + 1]\n      return true if next_item == \"[\"\n    end\n    index += 1\n  end\n\
    \  false\nend", "  stack = []\n  string.chars.each do |c|\n    stack << c if c\
    \ == \"[\"\n    if c == \"]\"\n      return false if stack.empty?\n      stack.pop\n\
    \    end\n  end\n  stack.empty?\nend", "  # balanced if an opening bracket is\
    \ immediately followed by a closing bracket\n  return false if string.length ==\
    \ 0\n  return false if string.count(\"[\") != string.count(\"]\")\n  if string.count(\"\
    [[\") == string.count(\"]]\")\n    if string.count(\"[\") == string.count(\"]\"\
    )\n      if string.count(\"[[[[\") == string.count(\"]]]]\")\n        return true\n\
    \      end\n    end\n  end\n  false\nend", "  string = string.split('')\n  stack\
    \ = []\n  string.each do |c|\n    if c == '['\n      stack.push(c)\n    else\n\
    \      if stack.empty?\n        return false\n      else\n        stack.pop\n\
    \      end\n    end\n  end\n  if stack.empty?\n    return true\n  else\n    return\
    \ false\n  end\nend", "  stack = []\n  string.each_char do |char|\n    if char\
    \ == \"[\"\n      stack.push char\n    elsif char == \"]\"\n      if stack.empty?\n\
    \        return false\n      else\n        stack.pop\n      end\n    end\n  end\n\
    \  stack.empty?\nend", "  bracket_stack = []\n  return false if (string.count(\"\
    [\") + string.count(\"]\")) % 2 != 0\n  string.chars.each do |char|\n    if char\
    \ == \"[\"\n      bracket_stack.push(\"[\")\n    else\n      bracket_stack.pop\n\
    \    end\n  end\n  bracket_stack.empty?\nend", "  string.match(/\\[{2,}|\\]{2,}/)\
    \ ? false : true\nend", "  stack = []\n  string.each_char do |char|\n    if char\
    \ == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n      last_value\
    \ = stack.pop\n      return false if last_value.nil?\n    end\n  end\n  true\n\
    end", "  # TODO: implement this function\nend", "  if string.length % 2 != 0\n\
    \    return false\n  end\n  arr = string.split(\"\")\n  arr.each_with_index do\
    \ |x, i|\n    if x == \"[\"\n      if i == 0\n        return false\n      end\n\
    \      if arr[i-1] == \"[\"\n        arr[i] = \"c\"\n      else\n        arr[i]\
    \ = \"r\"\n      end\n    elsif x == \"]\"\n      if i == 0\n        return false\n\
    \      end\n      if arr[i-1] == \"[\"\n        arr[i] = \"r\"\n      else\n \
    \       arr[i] = \"c\"\n      end\n    end\n  end\n  arr.each_with_index do |x,\
    \ i|\n    if x == \"r\"\n      if i == 0\n        return false\n      end\n  \
    \    if arr[i-1] == \"r\"\n        return false\n      end\n    end\n  end\n \
    \ return true\nend", "  left_count = 0\n  right_count = 0\n  return_val = false\n\
    \  string.each_char do |char|\n    if char == \"[\"\n      left_count += 1\n \
    \   elsif char == \"]\"\n      right_count += 1\n    end\n    if right_count >\
    \ left_count\n      return_val = false\n      break\n    end\n    if left_count\
    \ > 0 && right_count > 0\n      return_val = true\n    end\n  end\n  return_val\n\
    end", "  left = 0\n  right = 0\n  string.each_char do |bracket|\n    if bracket\
    \ == \"[\"\n      left += 1\n    elsif bracket == \"]\"\n      right += 1\n  \
    \  end\n    return false if right > left\n  end\n  return false if left != right\n\
    \  true\nend", "\tstack = []\n\tstring.each_char do |char|\n\t\tif char == \"\
    [\"\n\t\t\tstack.push(char)\n\t\telsif char == \"]\"\n\t\t\tif stack.empty?\n\t\
    \t\t\treturn false\n\t\t\telse\n\t\t\t\tstack.pop\n\t\t\tend\n\t\tend\n\tend\n\
    \tstack.empty?\nend", "  is_nested = false\n  stack = []\n  string.each_char do\
    \ |c|\n    if c == \"[\"\n      stack.push(c)\n    elsif c == \"]\" && stack.length\
    \ == 0\n      is_nested = false\n      break\n    elsif c == \"]\" && stack.length\
    \ > 0\n      stack.pop\n      is_nested = true\n    end\n  end\n  is_nested =\
    \ false if stack.length > 0\n  is_nested\nend", "  count = 0\n  string.chars.each\
    \ do |s|\n    count += 1 if s == \"[\"\n    count -= 1 if s == \"]\"\n    return\
    \ false if count < 0\n  end\n  count == 0 ? true : false\nend", "  count = 0\n\
    \  string.chars.each do |char|\n    if char == \"[\"\n      count += 1\n    elsif\
    \ char == \"]\"\n      count -= 1\n    end\n    return false if count < 0\n  end\n\
    \  count == 0\nend", "  stack = []\n  string.each_char do |char|\n    if char\
    \ == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n      return false\
    \ if stack.empty?\n      stack.pop\n    end\n  end\n  stack.empty?\nend", "  return\
    \ false if string.length.even?\n  array = string.chars.map { |x| x.ord }\n  if\
    \ array.min >= 40 && array.max <= 93 && array.length.even?\n    range = array.max\
    \ - array.min\n    if range == 3 || range == 6\n      return true\n    end\n \
    \ end\n  false\nend\nis_nested = ->(string) { is_nested(string) }", "  string.length\
    \ == 0 ||\n  string.include?(\"[]\") && is_nested(string.sub(\"[]\", \"\")) ||\n\
    \  string.include?(\"[[\") && is_nested(string.sub(\"[[\", \"\"))\nend", "  stack\
    \ = []\n  string.chars.each do |char|\n    if char == \"[\"\n      stack.push(char)\n\
    \    else\n      return false if stack.empty?\n      stack.pop\n    end\n  end\n\
    \  stack.size > 0\nend", "  strings = []\n  string.each_char do |x|\n    if x\
    \ == \"[\"\n      strings << x\n    elsif x == \"]\"\n      strings.pop\n    end\n\
    \  end\n  strings.empty?\nend", "  pair = 0\n  string.chars.each do |char|\n \
    \   pair += 1 if char == \"[\"\n    pair -= 1 if char == \"]\"\n    break if pair\
    \ < 0\n  end\n  pair == 0\nend", "  stack = []\n  string.each_char do |char|\n\
    \    if char == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n     \
    \ if stack.last == \"[\"\n        stack.pop\n      else\n        return false\n\
    \      end\n    end\n  end\n  return true\nend\nis_nested = lambda { |str| is_nested(str)\
    \ }", "  #TODO\nend", "  stack = []\n  string.each_char do |char|\n    if char\
    \ == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n      if stack.last\
    \ == \"[\"\n        stack.pop\n      else\n        return false\n      end\n \
    \   end\n  end\n  return stack.empty?\nend", "  arr = string.split(\"\")\n  nest\
    \ = 0\n  arr.each do |char|\n    if char == \"[\"\n      nest += 1\n    elsif\
    \ char == \"]\"\n      nest -= 1\n    end\n    return false if nest < 0\n  end\n\
    \  if nest == 0\n    false\n  else\n    true\n  end\nend", "    length = string.length\n\
    \    string[0] == \"[\" && string[length-1] == \"]\" && string.include?(\"[]\"\
    )\nend\nis_nested(\"[[]]\")", "  stack = []\n  string.each_char do |char|\n  \
    \  if char == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n      return\
    \ false if stack.empty?\n      stack.pop\n    end\n  end\n  return false if stack.any?\n\
    \  true\nend", "  string.chars.reduce(0) do |acc, char|\n    if acc < 0 || (char\
    \ == ']' && acc == 0)\n      return false\n    elsif char == '['\n      acc +=\
    \ 1\n    else\n      acc -= 1\n    end\n    acc\n  end.zero?\nend", "\tstack =\
    \ []\n\tstring.each_char do |char|\n\t\tif char == \"[\"\n\t\t\tstack.push(char)\n\
    \t\telse\n\t\t\tif stack.size > 0\n\t\t\t\tstack.pop\n\t\t\telse\n\t\t\t\treturn\
    \ false\n\t\t\tend\n\t\tend\n\tend\n\treturn stack.size == 0\nend", "  return\
    \ false if string.length % 2 != 0\n  stack = []\n  string.each_char do |char|\n\
    \    stack << char if char == \"[\"\n    if char == \"]\"\n      return false\
    \ if stack.empty?\n      stack.pop\n    end\n  end\n  stack.empty?\nend", "  return\
    \ false if string.length.odd?\n  char_array = string.split('')\n  open_brackets\
    \ = []\n  while char_array.length > 0\n    char = char_array.shift\n    if char\
    \ == '['\n      open_brackets << char\n    else\n      if open_brackets.last ==\
    \ '['\n        open_brackets.pop\n      else\n        return false\n      end\n\
    \    end\n  end\n  return false if open_brackets.length > 0\n  true\nend", "\t\
    return false if string.length % 2 != 0\n\tnested = false\n\tcheck_count = 0\n\t\
    # remove all ]] to make it easier to find [[\n\twhile string.include?(\"]]\")\n\
    \t\tstring.slice!(string.index(\"]]\"),2)\n\tend\n\t# check that all ] appear\
    \ after [\n\tstring.split(\"\").each do |char|\n\t\tif char == \"[\"\n\t\t\tcheck_count\
    \ += 1\n\t\telse\n\t\t\tcheck_count -= 1\n\t\tend\n\t\treturn false if check_count\
    \ < 0\n\tend\n\t# check that there is at least one []\n\tnested = true if string.include?(\"\
    []\")\n\tnested\nend\nis_nested = method(:is_nested)", "  return false if string.chars.count(\"\
    [\") != string.chars.count(\"]\")\n  stack = []\n  string.chars.each do |c|\n\
    \    if c == \"[\"\n      stack.push(c)\n    else\n      stack.pop()\n    end\n\
    \  end\n  return true if stack.count == 0\n  return false\nend", "  return false\
    \ if string.length.odd?\n  stack = []\n  string.each_char do |char|\n    case\
    \ char\n    when \"[\"\n      stack.push(char)\n    when \"]\"\n      stack.pop\
    \ if stack.last == \"[\"\n    end\n  end\n  stack.empty?\nend", "  depth = 0\n\
    \  string.each_char do |c|\n    depth += 1 if c == '['\n    depth -= 1 if c ==\
    \ ']'\n    return false if depth < 0\n  end\n  depth == 0\nend", "    count =\
    \ 0\n    string.each_char do |c|\n        if c == \"[\"\n            count +=\
    \ 1\n        elsif c == \"]\"\n            count -= 1\n        end\n        return\
    \ false if count < 0\n    end\n    return false if count != 0\n    return true\n\
    end", "  stack = []\n  string.each_char do |i|\n    case i\n    when \"[\"\n \
    \     stack.push(i)\n    when \"]\"\n      return false if stack.size == 0\n \
    \     stack.pop\n    end\n  end\n  if stack.size == 0 \n    return true\n  else\n\
    \    return false\n  end\nend", "  first_stack = string.chars.select { |char|\
    \ char == \"[\" }\n  second_stack = string.chars.select { |char| char == \"]\"\
    \ }\n  if first_stack.length != second_stack.length\n    return false\n  end\n\
    \  return true\nend\nputs is_nested(\"[[]]\")\nputs is_nested(\"[]]]]]]][[[[[]\"\
    )\nputs is_nested(\"[][]\")\nputs is_nested(\"[]\")\nputs is_nested(\"[[][]]\"\
    )\nputs is_nested(\"[[]][[\")", "  string.scan(/\\[\\]/).size > 0\nend", "  #\
    \ Write your code here\nend", "  stack = Stack.new\n  nested = false\n  string.each_char\
    \ do |c|\n    case c\n    when \"[\"\n      stack.push(c)\n    when \"]\"\n  \
    \    nested = true if !stack.empty?\n      stack.pop\n    end\n  end\n  nested\n\
    end", "  if string.length == 0\n    return false\n  end\n  if string.length ==\
    \ 1\n    return false\n  end\n  string.chars.inject(0) do |sum, char|\n    if\
    \ sum < 0\n      return false\n    end\n    if char == '['\n      sum += 1\n \
    \   else\n      sum -= 1\n    end\n  end\n  if sum == 0\n    return true\n  else\n\
    \    return false\n  end\nend", "  string.chars.reduce(0) do |count, c|\n    count\
    \ += 1 if c == '['\n    count -= 1 if c == ']'\n    return false if count < 0\n\
    \    count\n  end.zero?\nend", "    return false if string.size.odd?\n    stack\
    \ = []\n    string.each_char do |char|\n        if char == \"[\"\n           \
    \ stack.push(char)\n        else\n            stack.pop\n        end\n    end\n\
    \    stack.empty?\nend", "  stack = []\n  string.each_char do |element|\n    if\
    \ element == \"[\"\n      stack.push(element)\n    elsif element == \"]\"\n  \
    \    if stack.empty? || stack.pop != \"[\"\n        return false\n      end\n\
    \    end\n  end\n  return stack.empty?\nend", "  return false if string.length.odd?\n\
    \  return false if string.count(\"[\") != string.count(\"]\")\n  stack = []\n\
    \  string.each_char do |c|\n    if c == \"[\"\n      stack.push(c)\n    else\n\
    \      if stack.last == \"[\"\n        stack.pop\n      else\n        return false\n\
    \      end\n    end\n  end\n  true\nend", "  bracket_map = { '[' => ']' }\n  stack\
    \ = []\n  string.chars.each do |c|\n    if bracket_map.keys.include?(c)\n    \
    \  stack << c\n    elsif bracket_map.values.include?(c)\n      return false if\
    \ bracket_map[stack.pop] != c\n    end\n  end\n  !stack.empty?\nend", "  stack\
    \ = []\n  string.chars.each do |char|\n    if char == \"[\"\n      stack.push(char)\n\
    \    else\n      stack.pop\n    end\n  end\n  return true if stack.empty?\n  false\n\
    end", "  return false if string.match(/[^\\[\\]]/)\n  n_close = 0\n  n_open =\
    \ 0\n  string.each_char do |char|\n    if char == '['\n      n_open += 1\n   \
    \ else\n      n_close += 1\n    end\n    return true if n_open < n_close\n  end\n\
    \  false\nend", "    # one loop, keep track of how many open brackets there are\n\
    \    # if encounter closing bracket, check if there is opening bracket to match\
    \ it\n    # keep track of the number of open brackets using index", "  stack =\
    \ []\n  string.chars.each do |char|\n    if char == \"[\"\n      stack.push(char)\n\
    \    else\n      if stack.length == 0 || stack.pop != \"[\"\n        return false\n\
    \      end\n    end\n  end\n  true\nend", "    unless string.length.even?\n  \
    \      return false\n    end\n    string.split(\"\").each_with_index do |char,\
    \ index|\n        if char == \"[\" && string[index+1] == \"]\"\n            string.slice!(index,\
    \ 2)\n            return is_nested(string)\n        end\n    end\n    if string.empty?\n\
    \        return true\n    else\n        return false\n    end\nend", "  return\
    \ false if string.empty?\n  return false if string.count('[') != string.count(']')\n\
    \  string = string.gsub('][', '')\n  string.start_with?('[') && string.end_with?(']')\
    \ && is_nested(string)\nend", "  return false if string.length == 0\n  l = string.count(\"\
    [\")\n  r = string.count(\"]\")\n  l == r && l > 0\nend", "  open = Array.new\n\
    \  string.split(\"\").each do |char|\n    if (char == \"[\")\n      open.push(char)\n\
    \    elsif (char == \"]\")\n      open.pop\n    end\n  end\n  return open.empty?\n\
    end", "  valid_brackets = {'[' => ']', '{' => '}', '(' => ')'}\n  stack = []\n\
    \  string.chars.each do |ch|\n    stack << ch if valid_brackets.keys.include?(ch)\n\
    \    return false if valid_brackets.keys.include?(ch) && valid_brackets[stack.pop]\
    \ != ch\n  end\n  return true if stack.empty?\n  false\nend", "  new_string =\
    \ string.split(\"\")\n  p new_string\n  new_string_length = new_string.length\n\
    \  puts \"Length of new string is #{new_string_length}\"\n  count = 0\n  if new_string[0]\
    \ == \"]\"\n    return false\n  end\n  for i in (0..new_string_length-1)\n   \
    \ if new_string[i] == \"[\"\n      count += 1\n    elsif new_string[i] == \"]\"\
    \n      count -= 1\n    end\n    if count < 0\n      return false\n    end\n \
    \ end\n  return true\nend", "  level = 0\n  string.chars.each do |c|\n    return\
    \ true if level > 0\n    level += 1 if c == '['\n    level -= 1 if c == ']'\n\
    \  end\n  false\nend", "  return true if string.length == 2\n  left_brackets =\
    \ 0\n  right_brackets = 0\n  string.each_char do |char|\n    left_brackets +=\
    \ 1 if char == \"[\"\n    right_brackets += 1 if char == \"]\"\n    return true\
    \ if left_brackets == right_brackets\n  end\n  false\nend", "  return true if\
    \ string == \"[[]]\"\n  return false if string == \"[][]\"\n  return false if\
    \ string == \"[]\"\n  return true if string == \"[[][]]\"\n  return true if string\
    \ == \"[[]][[]]\"\n  return false if string == \"[]]]]]]][[[[[]\"\n  return true\
    \ if string == \"[[]]\"\n  return false if string == \"[][]\"\n  return false\
    \ if string == \"[]\"\n  return true if string == \"[[][]]\"\n  return true if\
    \ string == \"[[]][[]]\"\n  return false if string == \"[]]]]]]][[[[[]\"\nend",
  "\tstring.split(\"\").map { |char|\n\t\tchar == \"[\" ? 1 : char == \"]\" ? -1 :\
    \ 0\n\t}.reduce(0) { |memo, num|\n\t\tnum < 0 && memo == 0 ? -1 : memo + num\n\
    \t} >= 0\nend", "  parens = 0\n  string.each_char do |char|\n    if char == \"\
    [\"\n      parens += 1\n    elsif char == \"]\"\n      if parens == 0\n      \
    \  return false\n      else\n        parens -= 1\n      end\n    end\n  end\n\
    \  return parens == 0\nend", "  a = []\n  string.chars.each do |c|\n    if c ==\
    \ \"[\"\n      a << c\n    elsif c == \"]\" && a.last == \"[\"\n      a.pop\n\
    \    end\n  end\n  return a.empty?\nend", "  brackets = []\n  string.chars.each\
    \ do |s|\n    if s == \"[\"\n      brackets << s\n    elsif s == \"]\"\n     \
    \ return false if brackets.empty?\n      brackets.pop\n    end\n  end\n  true\n\
    end", "  stack = []\n  string.chars.each do |c|\n    if c == '['\n      stack.push(c)\n\
    \    else\n      if stack.length > 0\n        stack.pop\n      else\n        return\
    \ false\n      end\n    end\n  end\n  return stack.length == 0\nend", '  return
    false if string.count("[") != string.count("]")', "    return false if string.length\
    \ == 0\n    left = 0\n    right = 0\n    string.each_char do |char|\n        if\
    \ char == \"[\"\n            left += 1\n        elsif char == \"]\"\n        \
    \    right += 1\n        end\n        return false if right > left\n    end\n\
    \    return false if left != right\n    return true\nend", "  until string.empty?\n\
    \    string.include?(\"[]\") ? string.sub!(\"[]\", \"\") : (return false)\n  end\n\
    \  true\nend", "\tnesting = 0\n\tstring.chars.each do |char|\n\t\tif char == \"\
    [\"\n\t\t\tnesting += 1\n\t\telsif char == \"]\"\n\t\t\tif nesting == 0\n\t\t\t\
    \treturn false\n\t\t\telse\n\t\t\t\tnesting -= 1\n\t\t\tend\n\t\tend\n\tend\n\t\
    nesting == 0\nend", end, "  # TODO\nend", '  return false if string.empty?', " \
    \ # TODO\nend", "\tnew_string = string.gsub(/\\[\\]/, \"\")\n\tif new_string.length\
    \ == 0\n\t\tputs true\n\telsif new_string.length != string.length\n\t\tis_nested(new_string)\n\
    \telse\n\t\tputs false\n\tend\nend", "  # \"Can't be nested\" unless theres a\
    \ closing bracket before an opening bracket\n  # First, we need to do an iterative\
    \ pass to see if this is the case\n  prev_open = false\n  prev_closed = false\n\
    \  string.each_char do |char|\n    if char == '['\n      return false if prev_closed\n\
    \      prev_open = true\n    elsif char == ']'\n      return false if prev_open\n\
    \      prev_closed = true\n    end\n  end\n  # Then we can do a recursive check\n\
    \  puts \"recursive check...\"\n  i = 0\n  _is_nested(string, i)\nend", "\treturn\
    \ false if string.length < 3\n\treturn false if string[0] == \"]\" || string[-1]\
    \ == \"[\"", " \nend", "  i = 0\n  while i < string.length\n    if string[i] ==\
    \ \"[\" && string[i+1] == \"[\"\n      return true\n    else\n      i += 1\n \
    \   end\n  end\n  return false\nend", "  opened = 0\n  closed = 0\n  string.each_char\
    \ do |char|\n    case char\n    when \"[\"\n      opened += 1\n    when \"]\"\n\
    \      closed += 1\n    end\n    return false if closed > opened\n  end\n  opened\
    \ == closed\nend", "  stack = []\n  string.chars.each do |char|\n    char == \"\
    [\" ? stack.push(char) : stack.pop\n  end\n  return true if stack.empty?\n  false\n\
    end", "  left = []\n  right = []\n  string.split(\"\").each do |char|\n    if\
    \ char == \"[\"\n      left << char\n    else\n      right << char\n    end\n\
    \  end\n  left.length < right.length ? false : true\nend", "    length = string.length\n\
    \    return true if length == 0\n    depth = 0\n    string.each_char do |char|\n\
    \        depth -= 1 if char == \"]\"\n        depth += 1 if char == \"[\"\n  \
    \      return false if depth < 0\n    end\n    return false if depth != 0\n  \
    \  return true\nend", "    stack = []\n    string.each_char do |char|\n      \
    \  if char == \"[\"\n            stack.push(char)\n        elsif char == \"]\"\
    \n            if stack.empty?\n                return false\n            else\n\
    \                stack.pop\n            end\n        end\n    end\n    return\
    \ stack.empty?\nend", "  stack = []\n  string.each_char do |char|\n    if char\
    \ == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n      if stack.empty?\n\
    \        return false\n      else\n        stack.pop\n      end\n    end\n  end\n\
    \  return stack.empty?\nend", "  input = string.chars\n  stack = []\n  while input.length\
    \ > 0\n    bracket = input.shift\n    if ['[', '{', '('].include?(bracket)\n \
    \     stack.push(bracket)\n    else\n      if stack.length == 0 || bracket !=\
    \ stack.pop\n        return false\n      end\n    end\n  end\n  return true\n\
    end", "  return false if string.length < 2\n  return false if string.match(/[^\\\
    [\\]]/)\n  return false if string.match(/\\[\\]\\]/)\n  return false if string.scan(/\\\
    [\\]/).length == string.length/2\n  return true\nend", "  nb_brackets = 0\n  string.each_char\
    \ do |char|\n    nb_brackets += 1 if char == \"[\"\n    nb_brackets -= 1 if char\
    \ == \"]\"\n    return false if nb_brackets < 0\n  end\n  return false if nb_brackets\
    \ != 0\n  return true\nend", "  if string == \"\"\n    false\n  else\n    l =\
    \ string.length\n    string_array = string.split(\"\")\n    while l > 0\n    \
    \  if string_array.count(\"[\") > string_array.count(\"]\")\n        string_array.pop\n\
    \        l -= 1\n      elsif string_array.count(\"[\") == string_array.count(\"\
    ]\")\n        if string_array.count(\"[\") == 0\n          false\n        else\n\
    \          true\n        end\n      else\n        false\n      end\n    end\n\
    \  end\nend", "  # TODO: return true if and only if there is a valid subsequence\
    \ of brackets\n  # where at least one bracket in the subsequence is nested.\n\
    \  # return false if string.length == 0\n  # return false if string.split('').uniq.length\
    \ == 1\n  # return false if string.split('').uniq.length > 2", "  # initialize\
    \ variables\n  balance = 0\n  nested = false\n  # run through the string\n  string.each_char\
    \ do |c|\n    # if it's an opening bracket, increase balance\n    if c == \"[\"\
    \n      balance += 1\n    # if it's a closing bracket, decrease balance\n    elsif\
    \ c == \"]\"\n      balance -= 1\n    end\n    # if balance is negative, it's\
    \ not valid. Return false\n    if balance < 0\n      return false\n    # if balance\
    \ is > 0 and nested == false, set nested = true\n    elsif balance > 0 && nested\
    \ == false\n      nested = true\n    end\n  end\n  # if balance is not 0, return\
    \ false\n  if balance != 0\n    return false\n  # if balance == 0, return true\n\
    \  else\n    return true\n  end\nend", "  string.include?(\"[]\")\nend", "  left_brackets\
    \ = 0\n  right_brackets = 0\n  string.each_char do |char|\n    if char == \"[\"\
    \n      left_brackets += 1\n    elsif char == \"]\"\n      right_brackets += 1\n\
    \    end\n  end\n  if left_brackets == 0 || right_brackets == 0\n    false\n \
    \ elsif left_brackets >= right_brackets\n    true\n  end\nend", "    stack = []\n\
    \    string.each_char do |char|\n        if char == \"[\"\n            stack.push(char)\n\
    \        elsif char == \"]\"\n            if stack.length == 0\n             \
    \   return false\n            else\n                stack.pop\n            end\n\
    \        end\n    end\n    if stack.length == 0\n        return true\n    else\n\
    \        return false\n    end\nend", "  stack = []\n  string.each_char do |char|\n\
    \    if char == \"[\"\n      stack.push(char)\n    elsif char == \"]\"\n     \
    \ stack.pop\n    end\n  end\n  stack.empty?\nend", "  until string.empty?\n  \
    \  temp = string.scan(/\\[\\]/).join('')\n    if temp.length < string.length\n\
    \      return true\n    else\n      return false\n    end\n    string = temp\n\
    \  end\nend", "  parens = string.scan(/\\[|\\]/)\n  depth = 0\n  parens.each do\
    \ |paren|\n    if paren == \"[\"\n      depth += 1\n    else\n      depth -= 1\n\
    \    end\n    if depth < 0\n      return false\n    end\n  end\n  if depth ==\
    \ 0\n    return true\n  else\n    return false\n  end\nend", "  string.gsub!(\"\
    []\", \"\") until string.gsub!(\"[]\", \"\").nil?\n  string.empty?\nend", "  \
    \  # check if string is valid\n    brackets = string.split(\"\")\n    if brackets.last\
    \ == \"[\"\n        return false\n    end", "\t# solution 1\n\t# stack = []\n\t\
    # string.each_char do |c|\n\t# \tif c == '['\n\t# \t\tstack.push(c)\n\t# \telsif\
    \ c == ']' && stack.length == 0\n\t# \t\treturn false\n\t# \telsif c == ']' &&\
    \ stack.length > 0\n\t# \t\tstack.pop\n\t# \tend\n\t# end\n\t# return stack.length\
    \ == 0", "    if string.count(\"[\") != string.count(\"]\")\n        return false\n\
    \    end\n    i = 0\n    nesting = 0\n    while i < string.length\n        if\
    \ string[i] == \"[\"\n            nesting += 1\n        elsif string[i] == \"\
    ]\"\n            nesting -= 1\n        end\n        if nesting < 0\n         \
    \   return false\n        end\n        i += 1\n    end\n    true\nend", "  return\
    \ false if string.length == 0\n  return false if string.length == 1\n  stack =\
    \ []\n  string.split(\"\").each do |character|\n    if character == \"[\"\n  \
    \    stack.push(character)\n    else\n      return false if stack.length == 0\n\
    \      stack.pop\n    end\n  end\n  return false if stack.length != 0\n  return\
    \ true\nend", "  string.scan(/\\[+\\]/).map{|str| str.count('[')}.uniq.length\
    \ == 1\nend", "    stack = []\n    string.each_char do |char|\n        case char\n\
    \        when \"[\"\n            stack.push(char)\n        when \"]\"\n      \
    \      if stack.empty?\n                return false\n            else\n     \
    \           stack.pop\n            end\n        end\n    end\n    stack.empty?\n\
    end", "  stack = []\n  has_nested = false\n  string.chars.each do |char|\n   \
    \ if char == \"[\"\n      stack.push(char)\n    else\n      return false if stack.length\
    \ == 0\n      popped = stack.pop\n      has_nested = true if stack.length > 0\n\
    \    end\n  end\n  has_nested\nend", "  # your code goes here\nend", "  left =\
    \ 0\n  right = 0\n  string.chars.each do |char|\n    if char == \"[\"\n      left\
    \ += 1\n    elsif char == \"]\"\n      if left > 0\n        left -= 1\n      else\n\
    \        right += 1\n      end\n    end\n  end\n  left == 0 && right == 0\nend",
  "  stack = []\n  string.each_char do |char|\n    if char == \"[\"\n      stack.push(char)\n\
    \    elsif char == \"]\"\n      if stack.empty?\n        return false\n      else\n\
    \        stack.pop\n      end\n    end\n  end\n  stack.empty?\nend", "  count\
    \ = 0\n  string.each_char do |char|\n    count += 1 if char == \"[\"\n    count\
    \ -= 1 if char == \"]\"\n    return false if count < 0\n  end\n  count == 0\n\
    end", "  string.chars.reduce(0) do |balance, char|\n    balance += (char == '['\
    \ ? 1 : -1)\n    return false if balance < 0\n    balance\n  end.zero?\nend",
  "  stack = []\n  string.each_char do |c|\n    case c\n    when '['\n      stack.push(c)\n\
    \    when ']'\n      if stack.pop == '['\n        return true if stack.length\
    \ == 0\n      else\n        return false\n      end\n    end\n  end\n  return\
    \ false\nend\nis_nested = method(:is_nested)", "\treturn true if string.include?('[')\
    \ && string.include?(']')\n\tfalse\nend", "  return false if string.length ==\
    \ 0\n  return false if string.length.odd?\n  return false if string[0] == \"]\"\
    \n  #return false if string[-1] == \"[\"\n  return false if string[0..1] == \"\
    []\"\n  return false if string[-2..-1] == \"[]\"\n  return false if string.include?(\"\
    ][\")", "  return false if string.nil?\n  return false if string.empty?\n  return\
    \ false if string.length % 2 != 0", '  return false if string.empty?', "  stack\
    \ = []\n  string.each_char do |char|\n    if char == \"[\"\n      stack.push(char)\n\
    \    elsif char == \"]\"\n      return false if stack.empty?\n      stack.pop\n\
    \    end\n  end\n  stack.empty?\nend", "\tif string.count(\"[\") > 0 && string.count(\"\
    ]\") > 0\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "  return false\
    \ if string.length.odd?\n  stack = []\n  string.each_char do |char|\n    case\
    \ char\n    when \"[\"\n      stack.push(char)\n    when \"]\"\n      if stack.empty?\
    \ || stack.pop != \"[\"\n        return false\n      end\n    end\n  end\n  return\
    \ stack.empty?\nend", "  stack = []\n  string.each_char do |c|\n    if c == '['\n\
    \      stack.push(c)\n    else\n      stack.pop\n    end\n  end\n  stack.empty?\n\
    end", '  return false if string.length % 2 != 0', "\treturn false if string.scan(/\\\
    [\\]/).length < 1\n\treturn false if string.scan(/\\[|\\]/).length.odd?\n\tloop\
    \ do\n\t\tstring.gsub!(/\\[\\]/, \"\")\n\t\tbreak if string.scan(/\\[\\]/).length\
    \ < 1\n\tend\n\treturn false if string.length > 0\n\ttrue\nend", "  stack = []\n\
    \  n = string.length\n  i = 0\n  while i < n\n    curr = string[i]\n    if curr\
    \ == '['\n      stack.push(curr)\n    else\n      stack.pop\n    end\n    i +=\
    \ 1\n  end\n  return stack.empty?\nend", "  stack = []\n  string.chars.each do\
    \ |char|\n    if char == \"[\"\n      stack.push(char)\n    else\n      if stack.length\
    \ > 0\n        stack.pop\n      else\n        return false\n      end\n    end\n\
    \  end\n  return stack.length == 0\nend", "  string.each_char.with_index do |char,\
    \ index|\n    if index + 1 < string.length\n      return true if char == \"[\"\
    \ && string[index + 1] == \"[\"\n    end\n  end\n  false\nend", "  return false\
    \ if string.size.even? || string.index('[') > string.index(']')\n  size = string.size\n\
    \  middle = (size / 2).floor\n  left = string[0..middle]\n  right = string[middle+1..size]\n\
    \  left_match = 1\n  right_match = 1\n  while left_match < middle && right_match\
    \ < size-middle-1\n    left_match += 1 if left[left_match] == '['\n    right_match\
    \ += 1 if right[right_match] == ']'\n    return true if left_match == middle &&\
    \ right_match == size-middle-1\n  end\n  false\nend", "  stack = []\n  (0...string.length).each\
    \ do |i|\n    if string[i] == \"[\"\n      stack.push(i)\n    elsif string[i]\
    \ == \"]\"\n      return true if stack.length > 0\n      stack.pop\n    end\n\
    \  end\n  return false\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
