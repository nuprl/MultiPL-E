name: HumanEval_103_rounded_avg
language: rb
prompt: "# You are given two positive integers n and m, and your task is to compute\
  \ the\n# average of the integers from n through m (including n and m). \n# Round\
  \ the answer to the nearest integer and convert that to binary.\n# If n is greater\
  \ than m, return -1.\n# Example:\n# >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>>\
  \ rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n#\
  \ >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n\
  \    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1,\
  \ 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"\
  0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996,\
  \ 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"\
  0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362,\
  \ 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"\
  0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7,\
  \ 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5,\
  \ 5))\n  end\nend\n"
completions: ["  avg = ((n + m).to_f / 2).round\n  avg > m ? -1 : \"0b#{avg.to_s(2)}\"\
    \nend", "  if n > m\n    return -1\n  else\n    sum = (n..m).reduce(:+)\n    length\
    \ = m - n + 1\n    avg = sum / length\n    return avg.to_s(2)\n  end\nend\nputs\
    \ rounded_avg(1, 5)\nputs rounded_avg(7, 5)\nputs rounded_avg(10, 20)\nputs rounded_avg(20,\
    \ 33)", "  if n > m\n    return -1\n  end\n  total = 0\n  count = 0\n  n.upto(m)\
    \ do |number|\n    total += number\n    count += 1\n  end\n  avg = total / count\n\
    \  binary = avg.to_s(2)\n  \"0b#{binary}\"\nend", "  return -1 if n > m\n  binary(rounded_avg(n,\
    \ m))\nend", "  return -1 if n > m\n  n.upto(m).reduce(:+).fdiv(m - n + 1).round.to_s(2)\n\
    end", "  sum = n + m\n  float_avg = sum.to_f / 2\n  float_avg = float_avg.round\n\
    \  int_avg = float_avg.to_i\n  return \"0b\" + int_avg.to_s(2)\nend", "\tif n\
    \ > m\n\t\treturn -1\n\tend\n\tbinary = (n + m) / 2\n\treturn \"0b\" + binary.to_s(2)\n\
    end", "  # your code here\nend", "  # TODO: computes the average of integers n\
    \ through m\n  if n > m\n    return -1\n  else\n    return n.to_s(2) if n == m\n\
    \    sum = n + m\n    median = 0\n    if (sum % 2) == 0\n      median = sum /\
    \ 2\n    else\n      median = sum / 2 + 1\n    end\n    return median.to_s(2)\n\
    \  end\nend", "  return -1 if n > m\n  ((n + m) / 2.0).round.to_s(2)\nend", " \
    \ rounded_avg = (n + m) / 2.0\n  (n <= m) ? rounded_avg.round.to_s(2) : -1\nend",
  "  if n > m\n    -1\n  else\n    ((n+m)/2.0).round.to_s(2)\n  end\nend", "    if\
    \ n > m\n        return -1\n    end\n    a = (n + m) / 2\n    return (\"0b%b\"\
    \ % a)\nend", "  # your code here\nend", "  (n..m).reduce(:+).fdiv(n.to_f - m.to_f).round.to_s(2)\n\
    end", "  if n > m\n    -1\n  else\n    \"0b#{avg(n, m).to_s(2)}\"\n  end\nend",
  "  -1 if n > m\n  average = (n + m) / 2\n  binary = average.to_s(2)\n  binary\n\
    end", "\nend", "\t# (n..m).inject(:+)/(m-n+1)\n\tif n < m\n\t\treturn n.to_s(2)\n\
    \telse\n\t\treturn -1\n\tend\nend", "  return -1 if n > m\n  ('0b' + (1.0 * (n\
    \ + m) / 2).round.to_s(2)).to_s\nend", "\traise NotImplementedError\nend", " \
    \ return -1 if n > m\n  sum = n\n  (n + 1 .. m).each do |n|\n    sum += n\n  end\n\
    \  average = sum / (m - n + 1)\n  avg_bin = average.to_s(2)\n  \"0b#{avg_bin}\"\
    \nend", "  if n > m\n    return -1\n  end\n  sum = 0\n  for i in n..m\n    sum\
    \ += i\n  end\n  avg = sum / (m - n + 1)\n  \"0b\" + avg.to_s(2)\nend", "  total\
    \ = 0\n  n.upto(m) { |num| total += num }\n  avg = total / (m - n + 1)\n  return\
    \ avg.to_s(2)\nend", "  if n > m\n    -1\n  else\n    avg = (n + m) / 2\n    \"\
    0b#{avg.to_s(2)}\"\n  end\nend", "  x = (n+m).fdiv(2).round\n  return -1 if n\
    \ > m\n  return \"0b#{x.to_s(2)}\"\nend", "  return -1 if n > m\n  average = (n\
    \ + m) / 2\n  average.to_s(2)\nend", "  return -1 if n > m\n  # avg = (n + m)\
    \ / 2\n  # avg.to_s(2)\n  \"#{(n + m) / 2.to_s(2)}\"\nend", "\t(n>m)? -1: (\"\
    0b\"+((n+m)/2).to_s(2))\nend", "  (n+m)/2\nend", "  nums = []\n  if n > m\n  \
    \  return -1\n  else\n    (n..m).each do |i|\n      nums << i\n    end\n  end\n\
    \  average = nums.inject(:+)/nums.length\n  rounded_avg = average.round.to_s(2)\n\
    \  return \"0b#{rounded_avg}\"\nend", "  return '-1' if n > m\n  ary = (n..m).to_a\n\
    \  sum = ary.inject(:+)\n  avg = (sum / ary.size.to_f).round\n  binary = avg.to_s(2)\n\
    \  \"0b#{binary}\"\nend", "  (n > m) ? -1 : '0b' + ((n+m)/2.0).round.to_s(2)\n\
    end", "  return -1 if n > m\n  (n..m).reduce(:+).fdiv(n..m).round.to_s(2)\nend",
  "  if n > m\n    -1\n  else\n    result = (n + m).fdiv(2).round\n    \"0b#{result.to_s(2)}\"\
    \n  end\nend", "  (n..m).inject(:+).fdiv(n..m).round.to_s(2)\nend", "  arr = []\n\
    \  n.upto(m) { |num| arr << num }\n  if arr == arr.reverse\n    return -1\n  else\n\
    \    avg = (arr.reduce(:+)) / arr.length\n    return \"0b#{avg.to_s(2)}\"\n  end\n\
    end", "  m < n ? -1 : '0b' + (((n + m).to_f / 2).round.to_s(2))\nend", "  # TODO:\
    \ implement method\nend", "  avg = (n+m) / 2.0\n  avg = avg.ceil if avg % 1 !=\
    \ 0\n  if n > m\n    -1\n  else\n    \"0b#{avg.to_s(2)}\"\n  end\nend", "  average\
    \ = ((n+m)/2.0).round\n  return -1 if n > m\n  return -1 if average == 0\n  average.to_s(2)\n\
    end", "\t# TODO\nend", "  (n+m)/2\nend", "\nend", "  if n > m\n    return -1\n\
    \  end\n  average = (n+m)/2\n  average.to_s(2)\nend", "  (n > m) ? -1 : (\"0b\"\
    \ + (\"%b\" % ((n + m) / 2.0).round))\nend\nputs \"average of 1 and 5 is #{rounded_avg(1,\
    \ 5)}\"\nputs \"average of 7 and 5 is #{rounded_avg(7, 5)}\"\nputs \"average of\
    \ 10 and 20 is #{rounded_avg(10, 20)}\"\nputs \"average of 20 and 33 is #{rounded_avg(20,\
    \ 33)}\"", "  if n > m\n    return -1\n  end\n  sum = (n + m) / 2\n  sum.to_s(2)\n\
    end\nputs rounded_avg(1, 5)\nputs rounded_avg(7, 5)\nputs rounded_avg(10, 20)\n\
    puts rounded_avg(20, 33)", "  (n > m) ? -1 : ('0b' + (n + m) / 2.0.round.to_s(2))\n\
    end", "  sum = (n + m).to_f / 2\n  sum.round.to_s(2)\nend", "  (n..m).inject(:+).to_f\
    \ / (m - n + 1).to_f\nend", "  avg = (n + m) / 2.0\n  return -1 if n > m\n  return\
    \ \"0b#{avg.to_i.to_s(2)}\"\nend", "  avg = (n + m) / 2\n  avg.to_s(2)\nend",
  "  return -1 if n > m\n  average = ((n..m).reduce(:+)/(m - n + 1)).to_s(2)\nend",
  "\tif n > m\n\t\treturn -1\n\telse\n\t\tbinary = (n + m) / 2\n\t\tbinary = binary.to_s(2)\n\
    \t\t\"0b#{binary}\"\n\tend\nend", "  return -1 if n > m\n  sum = (n..m).to_a.inject(:+)\n\
    \  avg = sum / (m - n + 1)\n  \"0b#{avg.to_s(2)}\"\nend", "  n > m ? -1 : n.upto(m).reduce(:+).fdiv(m\
    \ - n + 1).round.to_s(2)\nend", "  # your code here\nend", "  n > m ? -1 : n.upto(m).inject(:+).fdiv(m\
    \ - n + 1).round.to_s(2)\nend", "  a = n\n  b = m\n  sum = 0\n  total = 0\n  until\
    \ a > b\n    sum += a\n    total += 1\n    a += 1\n  end\n  avg = sum/total\n\
    \  if n > m\n    return -1\n  else\n    return \"0b#{avg.to_s(2)}\"\n  end\nend",
  "  (n > m) ? -1 : n.upto(m).inject(:+).fdiv(m - n + 1).round.to_s(2)\nend", "  r\
    \ = n + m\n  return -1 if r < 2\n  b = r.to_s(2)\n  b.include?('.') ? (r / 2).to_s(2)\
    \ : b\nend", "  ((n + m) / 2.0).round.to_s(2)\nend", "\t# your code here\n\traise\
    \ NotImplementedError\nend", "  n, m = m, n if n > m\n  return -1 if n > m\n \
    \ \"0b\" + ((n..m).inject(:+).to_f / (m - n + 1)).round.to_s(2)\nend", "  unless\
    \ n <= m\n    return -1\n  end\n  total = n + m\n  avg = (total/2.0).round\n \
    \ avg.to_s(2)\nend", "  return -1 if n > m\n  (n + m) / 2.0\nend", "  # Your code\
    \ here\nend", "  n > m ? -1 : n.upto(m).reduce(:+).fdiv(m - n + 1).round.to_s(2)\n\
    end", "  \"0b#{n > m ? -1 : n.upto(m).reduce(:+).to_f.round.to_s(2)}\"\nend",
  "  return -1 if n > m\n  rounded_average = (n + m) / 2\n  rounded_average.to_s(2)\n\
    end", "  raise NotImplementedError\nend", "  # your code here\nend", "  n, m =\
    \ m, n if n > m\n  (n..m).reduce(:+).fdiv(m - n + 1).round.to_s(2)\nend\nrounded_avg(12,\
    \ 46)\nrounded_avg(20, 33)", "  if n > m\n    return -1\n  end\n  avg = (n + m)\
    \ / 2\n  \"0b#{avg.to_s(2)}\"\nend", "  range = n..m\n  sum = range.reduce(:+)\n\
    \  return -1 if sum.nil?\n  rounded_avg = (sum / range.size).round\n  \"0b#{rounded_avg.to_s(2)}\"\
    \nend", "  if n > m\n    -1\n  else\n    sum = 0\n    (n..m).each do |i|\n   \
    \   sum += i\n    end\n    average = sum / (m - n + 1)\n    \"0b#{average.to_s(2)}\"\
    \n  end\nend", "  return -1 if n > m\n  avg = (n..m).reduce(:+) / (m - n + 1.0)\n\
    \  \"0b#{avg.round.to_s(2)}\"\nend", "  sum = 0\n  i = n\n  if n > m\n    -1\n\
    \  else\n    while i <= m\n      sum += i\n      i += 1\n    end\n    \"0b#{(sum\
    \ / (m - n + 1)).to_s(2)}\"\n  end\nend", "  return -1 if n > m\n  res = (n+m)/2\n\
    \  res.to_s(2)\nend", "    # your code here\nend", "  if n > m\n    -1\n  else\n\
    \    sum = (n..m).reduce(:+)\n    length = m - n + 1\n    rounded_avg = (sum.to_f\
    \ / length).round\n    \"0b#{rounded_avg.to_s(2)}\"\n  end\nend", "  # Write your\
    \ solution here.\nend", "\treturn -1 if n > m\n\t\n\tavg = ((n + m).to_f / 2).round\n\
    \t\n\t\"0b\" + avg.to_s(2)\nend", "    return -1 if n > m\n    d = n.to_f\n  \
    \  v = (d..m).inject(:+)/(m-n+1).to_f\n    \"0b#{v.round.to_s(2)}\"\nend", " \
    \ # Your code here\nend", "  return -1 if n > m\n  binary_string = ''\n  (n..m).each\
    \ { |i| binary_string << i.to_s(2) }\n  x = 0\n  binary_string.each_char { |c|\
    \ x += c.to_i }\n  rounded_avg = (x / binary_string.length)\n  '0b' + rounded_avg.to_s(2)\n\
    end", "  ((n + m) / 2.0).round.to_s(2)\nend", "    if n < m\n        answer =\
    \ (n + m)/2\n        answer.to_s(2)\n    else\n        -1\n    end\nend", "  \
    \  raise NotImplementedError\nend", "  if n > m\n    return -1\n  end\n  sum =\
    \ (n..m).reduce(:+)\n  avg = sum / (m - n + 1)\n  avg.to_s(2)\nend", "  return\
    \ -1 if n > m\n  average = n / 2 + m / 2 + (n % 2 + m % 2) / 2\n  average.to_s(2)\n\
    end", "  \"0b#{(n + m) / 2.0.round.to_s(2)}\"\nend\np rounded_avg(1, 5)\np rounded_avg(7,\
    \ 5)\np rounded_avg(10, 20)\np rounded_avg(20, 33)", "  return -1 if n > m\n \
    \ sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  result = sum.to_f\
    \ / (m - n + 1)\n  result = result.ceil\n  to_binary(result)\nend", "  s = ((n\
    \ + m) / 2.0).round.to_s(2)\n  s.size > 8 ? s[0..7] : s\nend\nrounded_avg(21,\
    \ 33)", "  return -1 if n > m\n  avg = ((n + m) / 2.0).round\n  \"0b#{avg.to_s(2)}\"\
    \nend", "  return -1 if n > m\n  avg = ((n..m).reduce(:+).to_f / (m - n + 1)).round\n\
    \  \"0b#{avg.to_s(2)}\"\nend", "\tif n > m\n\t\treturn -1\n\telse\n\t\tsum = 0\n\
    \t\tarr = []\n\t\twhile n <= m\n\t\t\tarr << n\n\t\t\tn += 1\n\t\tend\n\t\tarr.each\
    \ do |num|\n\t\t\tsum += num\n\t\tend\n\t\trounded_avg = sum/arr.length\n\t\t\
    return \"0b#{rounded_avg.to_s(2)}\"\n\tend\nend", "    # your code here\nend",
  "  return -1 if n > m\n  binary = ((n+m)/2.0).round.to_s(2)\n  \"0b#{binary}\"\n\
    end", "  avg = (n + m) / 2.0\n  avg == avg.to_i ? \"0b#{avg.to_i.to_s(2)}\" :\
    \ -1\nend", "  sum = n + m\n  length = 2\n  while sum > 1\n    sum /= 2\n    length\
    \ += 1\n  end\n  format \"0b%0#{length}b\", (n + m) / 2\nend", "  if n > m\n \
    \   return -1\n  else\n    return (n + m) / 2\n  end\nend", "  # TODO\nend", end,
  "  return -1 if n > m\n  # we use bin2dec because we can't convert floats to binary.\n\
    \  # bin2dec will round the average for us\n  (n+m)/2.0.bin2dec\nend", "  # your\
    \ code here\nend", "    (n > m) ? -1 : (n + m) / 2\nend", "  return -1 if n >\
    \ m\n  avg = (n + m) / 2\n  round_to_binary(avg)\nend", '  return -1 if n > m',
  "  return -1 if n > m\n  bin_avg = (n..m).reduce(:+).to_f / (m - n + 1)\n  \"0b#{bin_avg.round.to_s(2)}\"\
    \nend", "\treturn -1 if n > m\n\treturn n.to_s(2) if n == m\n\ts = (n + m).div(2)\n\
    \treturn s.to_s(2)\nend", "  avg = (n + m) / 2\n  binary = avg.to_s(2)\n  \"0b#{binary}\"\
    \nend", "  if n > m\n    -1\n  else\n    sum = 0\n    (n..m).each do |n|\n   \
    \   sum += n\n    end\n    \"0b#{sum / (m - n + 1).to_s(2)}\"\n  end\nend", " \
    \ # ...\nend", "\treturn -1 if n > m", "  raise NotImplementedError\nend", " \
    \   # Compute average\n    avg = (n+m)/2\n    # Round to nearest integer\n   \
    \ rounded = (avg-avg.to_i >= 0.5) ? avg.to_i+1 : avg.to_i\n    # Compute Binary\n\
    \    binary = to_binary(rounded)\n    binary\nend", "  if n > m \n    -1\n  else\n\
    \    dec_avg = (n..m).reduce(:+)/(m-n+1)\n    dec_avg.to_s(2)\n  end\nend", '  return
    -1 if n > m', "  if n > m\n    return -1\n  else\n    avg = (n + m) / 2\n    \"\
    0b#{avg.to_s(2)}\"\n  end\nend", "  return -1 if n > m\n  binary = \"\"\n  sum\
    \ = 0\n  (n..m).each do |int|\n    sum += int\n  end\n  rounded = (sum / (m -\
    \ n + 1)).round\n  until rounded == 0\n    remainder = rounded % 2\n    binary\
    \ = remainder.to_s + binary\n    rounded = rounded / 2\n  end\n  \"0b\" + binary\n\
    end", "  # The average of two numbers is the sum of the two numbers divided by\
    \ 2.\n  # To round the average to the nearest integer we first calculate the average,\n\
    \  # then we round it to the nearest integer, then convert that integer to a binary\
    \ representation.\n  ((n + m) / 2.0).round.to_s(2)\nend", "  if n > m\n    return\
    \ -1\n  else\n    sum = (n..m).to_a.reduce(:+)\n    avg = sum.to_f / (m - n +\
    \ 1)\n    rounded_avg = avg.round\n    return '0b' + rounded_avg.to_s(2)\n  end\n\
    end", "  if n <= m\n    a = (n + m) / 2\n    b = a.to_s(2)\n    return \"0b#{b}\"\
    \n  end\n  -1\nend\nputs \"Rounded average:\"\nputs rounded_avg(1, 5) == \"0b11\"\
    \nputs rounded_avg(7, 5) == -1\nputs rounded_avg(10, 20) == \"0b1111\"\nputs rounded_avg(20,\
    \ 33) == \"0b11010\"", "    if n > m\n        return -1\n    end\n    avg = n\n\
    \    until n == m\n        n += 1\n        avg += n\n    end\n    avg = avg /\
    \ ((m - n) + 1)\n    avg = avg.round\n    return \"0b#{avg.to_s(2)}\"\nend", " \
    \   return -1 if n > m\n    binary = average(n, m).to_s(2)\n    \"0b#{binary}\"\
    \nend", "  (n>m) ? -1 : (\"0b\" + \"%b\" % [(n+m)/2])\nend", "  if n > m\n   \
    \ return -1\n  else\n    avg = (n+m)/2\n    return \"0b#{avg.to_s(2)}\"\n  end\n\
    end", "  return -1 if n > m\n  n.upto(m).reduce(:+).fdiv(m - n + 1).round.to_s(2)\n\
    end", "  #your code here\nend", "  return -1 if n > m\n  x = (n..m).reduce(:+)\
    \ / (m - n + 1)\n  x.to_s(2)\nend", "  if n > m\n    -1\n  else\n    numbers =\
    \ (n..m).to_a\n    average = numbers.reduce(:+) / numbers.length\n    binary =\
    \ average.to_s(2)\n    \"0b#{binary}\"\n  end\nend", "  return -1 if n > m\n \
    \ binary_string = (n + m).to_f/2.to_f\n  \"0b#{binary_string.round.to_s(2)}\"\n\
    end", "  n > m ? -1 : \"0b\" + (n + m / 2.0).round.to_s(2)\nend", "  return -1\
    \ if n > m\n  return n.to_s(2) if n == m\n  avg = (n + m) / 2\n  avg.to_s(2)\n\
    end", "  n > m ? -1 : (n..m).inject(:+).to_f / (m - n + 1).to_f\nend", "  (n >\
    \ m) ? -1 : (\"0b\" + ((n + m).to_f / 2).round.to_s(2))\nend", "  return -1 if\
    \ n > m\n  avrg = (n..m).inject(:+).to_f / (m - n + 1)\n  avrg.round.to_s(2)\n\
    end", "  if m > n\n    num = (n..m).to_a.inject(:+)/(m-n+1).to_f\n    num.round.to_s(2)\n\
    \  else\n    -1\n  end\nend", "  return -1 if n > m\n  ((n + m) / 2.0).round.to_s(2)\n\
    end", "  return '-1' if n > m", "  return -1 if n > m\n  num = (n + m) / 2\n \
    \ num.to_s(2)\nend", "\t# Your Code Here\nend", "  n > m ? -1 : \"0b#{(n + m)\
    \ / 2.0}\"\nend", "  ((n + m).to_f / 2).round.to_s(2)\nend", "\nend", "  return\
    \ -1 if n > m\n  sum = (n..m).reduce(:+)\n  avg = (sum / (m - n + 1.0)).round\n\
    \  avg.to_s(2)\nend", "  return -1 if n > m\n  average = (n + m) / 2\n  average.to_s(2)\n\
    end", "\tresult = ((n + m) / 2.0).round\n\tresult < 0 ? -1 : result.to_s(2)\n\
    end", "  if m >= n\n    ((n + m) / 2.0).round.to_s(2)\n  else\n    -1\n  end\n\
    end", "  n > m ? -1 : n.upto(m).reduce(:+).fdiv(m-n+1).round.to_s(2)\nend", " \
    \ (n > m) ? -1 : (m + n) / 2.0\nend", "  if n > m\n    -1\n  else\n    sum = 0\n\
    \    (n..m).each do |num|\n      sum += num\n    end\n    average = (sum / (m\
    \ - n + 1)).to_i\n    binary = average.to_s(2)\n    \"0b#{binary}\"\n  end\nend",
  "    return -1 if n > m\n    avg = n == m ? n : (n + m) / 2.0\n    \"0b#{avg.round.to_s(2)}\"\
    \nend", "  return -1 if n > m\n  binary(average(n, m))\nend", "  # YOUR CODE HERE\n\
    end", "  # your code here\nend", "  n > m ? -1 : n.to_f.step(m, 1).inject(:+).fdiv(m\
    \ - n + 1).round.to_s(2)\nend", "  if n > m\n    return -1\n  else\n    sum =\
    \ (n..m).reduce(:+)\n    count = (n..m).count\n    average = sum / count\n   \
    \ integer = average.round\n    binary = integer.to_s(2)\n    \"0b#{binary}\"\n\
    \  end\nend", "  return -1 if n > m\n  (n + m) / 2.0\nend", "  return 0 if n ==\
    \ m\n  n, m = m, n if n > m", "\tif n > m\n\t\treturn -1\n\telse\n\t\tsum = 0\n\
    \t\tfor i in n..m\n\t\t\tsum += i\n\t\tend\n\t\treturn '0b' + (sum / (m - n +\
    \ 1)).to_s(2)\n\tend\nend", "  if n > m\n    -1\n  else\n    avg = (n + m) / 2\n\
    \    \"0b#{avg.to_s(2)}\"\n  end\nend", "    if n > m\n        -1\n    else\n\
    \        n = n.to_f\n        m = m.to_f\n        average = (n + m) / 2\n     \
    \   average = average.ceil\n        average = average.to_s(2)\n        \"0b\"\
    \ + average\n    end\nend", "  # Compute the result here\nend", "  (n > m) ? -1\
    \ : n.upto(m).reduce(:+).fdiv(m - n + 1).round.to_s(2)\nend", "  if n > m\n  \
    \  return -1\n  end\n  sum = 0\n  for x in n..m\n    sum += x\n  end\n  avg =\
    \ sum / (m - n + 1)\n  return \"0b#{avg.to_s(2)}\"\nend", "\tif n > m\n\t\treturn\
    \ -1\n\telse\n\t\ttotal = 0\n\t\tfor x in n..m\n\t\t\ttotal += x\n\t\tend\n\t\t\
    avg = total / (m - n + 1)\n\t\treturn \"0b\" + avg.to_s(2)\n\tend\nend", "  #\
    \ YOUR CODE HERE\nend", "  if n > m\n    -1\n  else\n    (n + m) / 2\n  end\n\
    end", "  if n < m\n    ((n + m)/2.0).round.to_s(2)\n  else\n    -1\n  end\nend",
  "  sum = n.upto(m).reduce(:+)\n  avg = sum / (m - n + 1)\n  return -1 if n > m\n\
    \  \"0b#{avg.to_s(2)}\"\nend", "\treturn -1 if n > m\n\t\"0b#{(n..m).inject(:+)/(m-n+1)}\"\
    \nend", "\treturn -1 if n > m\n\taverage = (n + m) / 2\n\taverage.to_s(2)\nend",
  "  return -1 if n > m\n  (n + m) / 2.0\nend", "  # your code here\nend", "  if m\
    \ < n\n    return -1\n  end\n  a = n + m\n  b = a / 2\n  # c = b.to_s(2)\n  c\
    \ = b.to_s(2)\n  d = \"0b\" + c.to_s\n  return d\nend", "\t#your code here\nend",
  "\traise ArgumentError, \"n must be an integer\" unless n.is_a?(Integer)\n\traise\
    \ ArgumentError, \"m must be an integer\" unless m.is_a?(Integer)\n\treturn -1\
    \ if n > m\n\tsum = 0\n\t(n..m).each { |i| sum += i }\n\tavg = sum / (m - n +\
    \ 1)\n\t\"0b#{avg.to_s(2)}\"\nend", "  num = (n + m) / 2.0\n  return -1 if num.is_a?\
    \ Float or num < n or num > m\n  num.to_s(2)\nend", "  return -1 if n > m\n  (n\
    \ + m) / 2.0\nend", "  (n>m)? -1 : m.to_s(2)\nend", "  return -1 if n > m\n  avg\
    \ = (n + m).to_f / 2\n  avg.round.to_s(2)\nend", "  return -1 if n > m\n  avg\
    \ = (n..m).reduce(:+) / (m - n + 1.0)\n  binary = \"\"\n  while avg > 0\n    binary\
    \ = \"#{avg % 2}#{binary}\"\n    avg /= 2\n  end\n  \"0b#{binary}\"\nend", " \
    \ if n > m\n    -1\n  else\n    x = (n + m) / 2\n    \"0b#{x.to_s(2)}\"\n  end\n\
    end\nputs rounded_avg(1, 5)", "  (n > m) ? -1 : ((n + m) / 2).to_s(2)\nend", " \
    \ if n <= m\n    ((n..m).sum / (m - n + 1)).to_s(2)\n  else\n    -1\n  end\nend",
  "  return -1 if n > m\n  (n + m) / 2.0.ceil.to_s(2)\nend", "  return -1 if n > m\n\
    \  (n + m) / 2.0.round.to_s(2)\nend", "  return -1 if n > m\n  average = (n..m).reduce(:+)\
    \ / (m - n + 1)\n  \"0b#{average.to_s(2)}\"\nend", "  return -1 if n > m\n  (\"\
    0b\" + (n..m).inject(:+).to_f.fdiv(m - n + 1).round.to_s(2))\nend", "  # your\
    \ code here\nend", "  return -1 if n > m\n  avg = (n + m) / 2\n  avg.to_s(2)\n\
    end", "  # your code here\nend", "  # YOUR CODE HERE\nend", "  n, m = m, n if\
    \ n > m\n  return -1 if n > m\n  bin = 0\n  total = 0\n  (n..m).each do |num|\n\
    \    total += num\n  end\n  avg = (total / (m - n + 1)).round\n  num_digits =\
    \ Math.log2(avg).ceil\n  num_digits.downto(0) do |i|\n    if avg & (1 << i) >\
    \ 0\n      bin |= 1 << i\n    end\n  end\n  \"0b#{bin}\"\nend", "  # your code\
    \ here\nend", "  # your code here\nend", end, "  round((n + m) / 2.0).to_s(2)\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
