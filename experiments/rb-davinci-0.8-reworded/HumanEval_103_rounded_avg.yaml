name: HumanEval_103_rounded_avg
language: rb
prompt: "# You are given two positive integers n and m, and your task is to compute\
  \ the\n# average of the integers from n through m (including n and m). \n# Round\
  \ the answer to the nearest integer and convert that to binary.\n# If n is greater\
  \ than m, return -1.\n# Example:\n# >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>>\
  \ rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n#\
  \ >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n\
  \    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1,\
  \ 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"\
  0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996,\
  \ 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"\
  0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362,\
  \ 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"\
  0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7,\
  \ 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5,\
  \ 5))\n  end\nend\n"
completions: ["  avg = ((n + m).to_f / 2).round\n  avg > m ? -1 : \"0b#{avg.to_s(2)}\"\
    \nend", "  if n > m\n    return -1\n  else\n    sum = (n..m).reduce(:+)\n    length\
    \ = m - n + 1\n    avg = sum / length\n    return avg.to_s(2)\n  end\nend\nputs\
    \ rounded_avg(1, 5)\nputs rounded_avg(7, 5)\nputs rounded_avg(10, 20)\nputs rounded_avg(20,\
    \ 33)", "  if n > m\n    return -1\n  end\n  total = 0\n  count = 0\n  n.upto(m)\
    \ do |number|\n    total += number\n    count += 1\n  end\n  avg = total / count\n\
    \  binary = avg.to_s(2)\n  \"0b#{binary}\"\nend", "  return -1 if n > m\n  binary(rounded_avg(n,\
    \ m))\nend", "  return -1 if n > m\n  n.upto(m).reduce(:+).fdiv(m - n + 1).round.to_s(2)\n\
    end", "  sum = n + m\n  float_avg = sum.to_f / 2\n  float_avg = float_avg.round\n\
    \  int_avg = float_avg.to_i\n  return \"0b\" + int_avg.to_s(2)\nend", "\tif n\
    \ > m\n\t\treturn -1\n\tend\n\tbinary = (n + m) / 2\n\treturn \"0b\" + binary.to_s(2)\n\
    end", "  # your code here\nend", "  # TODO: computes the average of integers n\
    \ through m\n  if n > m\n    return -1\n  else\n    return n.to_s(2) if n == m\n\
    \    sum = n + m\n    median = 0\n    if (sum % 2) == 0\n      median = sum /\
    \ 2\n    else\n      median = sum / 2 + 1\n    end\n    return median.to_s(2)\n\
    \  end\nend", "  return -1 if n > m\n  ((n + m) / 2.0).round.to_s(2)\nend", " \
    \ rounded_avg = (n + m) / 2.0\n  (n <= m) ? rounded_avg.round.to_s(2) : -1\nend",
  "  if n > m\n    -1\n  else\n    ((n+m)/2.0).round.to_s(2)\n  end\nend", "    if\
    \ n > m\n        return -1\n    end\n    a = (n + m) / 2\n    return (\"0b%b\"\
    \ % a)\nend", "  # your code here\nend", "  (n..m).reduce(:+).fdiv(n.to_f - m.to_f).round.to_s(2)\n\
    end", "  if n > m\n    -1\n  else\n    \"0b#{avg(n, m).to_s(2)}\"\n  end\nend",
  "  -1 if n > m\n  average = (n + m) / 2\n  binary = average.to_s(2)\n  binary\n\
    end", "\nend", "\t# (n..m).inject(:+)/(m-n+1)\n\tif n < m\n\t\treturn n.to_s(2)\n\
    \telse\n\t\treturn -1\n\tend\nend", "  return -1 if n > m\n  ('0b' + (1.0 * (n\
    \ + m) / 2).round.to_s(2)).to_s\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
