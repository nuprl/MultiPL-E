name: HumanEval_159_eat
language: rb
prompt: "# You're a hungry rabbit, and you already have eaten a certain number of\
  \ carrots,\n# but now you need to eat more carrots to complete the day's meals.\n\
  # you should return an array of [ total number of eaten carrots after your meals,\n\
  # the number of carrots left after your meals ]\n# if there are not enough remaining\
  \ carrots, you will eat all remaining carrots, but will still be hungry.\n# Example:\n\
  # >>> eat.call(5, 6, 10)\n# [11, 4]\n# >>> eat.call(4, 8, 9)\n# [12, 1]\n# >>> eat.call(1,\
  \ 10, 10)\n# [11, 0]\n# >>> eat.call(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number\
  \ : integer\n# the number of carrots that you have eaten.\n# @need : integer\n#\
  \ the number of carrots that you need to eat.\n# @remaining : integer\n# the number\
  \ of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n\
  # * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number,\
  \ need, remaining)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_eat\n\
  \    candidate = method(:eat)\n    assert_equal([11, 4], candidate.call(5, 6, 10))\n\
  \    assert_equal([12, 1], candidate.call(4, 8, 9))\n    assert_equal([11, 0], candidate.call(1,\
  \ 10, 10))\n    assert_equal([7, 0], candidate.call(2, 11, 5))\n    assert_equal([9,\
  \ 2], candidate.call(4, 5, 7))\n    assert_equal([5, 0], candidate.call(4, 5, 1))\n\
  \  end\nend\n"
completions: ["  #your code here\n  eaten = (number + need)\n  left = (eaten - remaining)\n\
    \  eaten > remaining ? [eaten - 1, 0] : [eaten, remaining - eaten]\nend", "  #\
    \ your code here\nend", "  if number + need > remaining\n    [remaining, 0]\n\
    \  else\n    [number + need, remaining - (number + need)]\n  end\nend", "  eaten\
    \ = number + need\n  eaten >= remaining ? [remaining, 0] : [eaten, remaining -\
    \ eaten]\nend", "    number + (need <= remaining ? need : remaining),\n    remaining\
    \ - (need <= remaining ? need : remaining)\nend", "  if remaining >= need\n  \
    \  return [number + need, remaining - need]\n  else\n    return [number + remaining,\
    \ 0]\n  end\nend", "  eaten = number + need > remaining ? remaining : number +\
    \ need\n  return [eaten, eaten - need]\nend", "  [(number + need), [remaining\
    \ - need, 0].max]\nend", "  total = number + need\n  if total > remaining\n  \
    \  return [remaining, 0]\n  end\n  [total, remaining - total]\nend", "  eaten\
    \ = number + [remaining, need].min\n  remaining -= need\n  [eaten, remaining <\
    \ 0 ? 0 : remaining]\nend", "    if remaining >= need - number\n        if need\
    \ - number == 0\n            return [need, remaining]\n        else\n        \
    \    return [need, remaining - (need - number)]\n        end\n    else\n     \
    \   if number + remaining >= need\n            return [need, 0]\n        else\n\
    \            return [number + remaining, 0]\n        end\n    end\nend", "  [number\
    \ + [remaining, need].min, [remaining, need].min].minmax\nend", "  # your code\
    \ here\nend", "  result = number + need\n  result <= remaining ? [result, remaining\
    \ - result] : [remaining, 0]\nend", "  total = number + need\n  total > remaining\
    \ ? [remaining, 0] : [total, remaining - total]\nend", "  if remaining >= need\n\
    \    return [number + need, remaining - need]\n  end\n  [number + remaining, 0]\n\
    end", "  eaten = number + need\n  eaten > remaining ? [remaining, 0] : [eaten,\
    \ remaining - eaten]\nend", "  number + remaining > need ? [need, remaining -\
    \ (need - number)] : [number + remaining, 0]\nend", "  remaining = remaining -\
    \ number\n  if remaining < need\n    need = need - remaining\n    remaining =\
    \ 0\n  else\n    remaining = remaining - need\n    need = 0\n  end\n  [number\
    \ + need, remaining]\nend", "    # ...\n    num = number + need\n    if num <=\
    \ remaining\n      return [num, remaining - num]\n    else\n      return [remaining\
    \ + number, 0]\n    end\nend", "  # Your code goes here\nend", "  [number + need,\
    \ remaining - need].minmax\nend", "  total = number + need\n  total > remaining\
    \ ? [total - (total - remaining), 0] : [total, remaining - total]\nend", "  [number\
    \ + [remaining, need].min, [remaining, need].min - need].map(&:abs)\nend", " \
    \ need.times { remaining -= 1 }\n  if remaining > 0\n    eat_num = number + need\n\
    \    left = remaining\n  else\n    eat_num = number + remaining\n    left = 0\n\
    \  end\n  [eat_num, left]\nend", "  if number + need > remaining\n    return [remaining,\
    \ 0]\n  else\n    return [number + need, remaining - number - need]\n  end\nend",
  "  # code here\nend", "  [number + need, 0].min <= remaining ?\n  [number + need,\
    \ remaining - (number + need)] :\n  [remaining + number, 0]\nend", "    if number\
    \ + need <= remaining\n        return [ number + need, remaining - (number + need)\
    \ ]\n    else\n        return [ number + remaining, 0 ]\n    end\nend", "  # code\
    \ here\nend", "  total = number + need\n  remaining -= total\n  remaining = 0\
    \ if remaining < 0\n  [total, remaining]\nend", "  if number > remaining\n   \
    \ total = remaining\n    difference = number - remaining\n    carrots_left = difference\
    \ - need\n    return [remaining, carrots_left]\n  else\n    total = number + need\n\
    \    return [total, remaining - total]\n  end\nend", "    number + need > remaining\
    \ ? [remaining, 0] : [number + need, remaining - (number + need)]\nend", "  [number\
    \ + need, (remaining - need).abs].min(2)\nend", "  n = number + need\n  n > remaining\
    \ ? [remaining, 0] : [n, remaining - n]\nend", "  total = number + need\n  if\
    \ remaining >= need\n    return [total, remaining - need]\n  else\n    return\
    \ [total + remaining, 0]\n  end\nend", "  if remaining >= need\n    [number +\
    \ need, remaining - need]\n  else\n    [number + remaining, 0]\n  end\nend", " \
    \ eaten_carrots = number + need\n  if eaten_carrots > remaining\n    eaten_carrots\
    \ = remaining\n  end\n  return [eaten_carrots, remaining - eaten_carrots]\nend",
  "  eaten = number + remaining\n  eaten > need ? [need, eaten - need] : [eaten, 0]\n\
    end", "  if remaining >= need\n    return [number + need, remaining - need]\n\
    \  else\n    return [number + remaining, 0]\n  end\nend", "    # t\u1EA1o m\u1EA3\
    ng ch\u1EE9a ph\u1EA7n t\u1EED [s\u1ED1 l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt b\u1ECB\
    \ \u0103n, s\u1ED1 l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt c\xF2n l\u1EA1i]\n    result\
    \ = []\n    # khi s\u1ED1 l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt c\xF2n l\u1EA1i kh\xF4\
    ng \u0111\u1EE7 \u0111\u1EC3 \u0103n\n    if remaining < need\n      # t\u1ED5\
    ng s\u1ED1 l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt b\u1ECB \u0103n = s\u1ED1 l\u01B0\u1EE3\
    ng c\u1EE7 c\u1EAFt \u0111\xE3 \u0103n + s\u1ED1 l\u01B0\u1EE3ng c\u1EE7 c\u1EAF\
    t c\xF2n l\u1EA1i\n      total = number + remaining\n      # s\u1ED1 l\u01B0\u1EE3\
    ng c\u1EE7 c\u1EAFt c\xF2n l\u1EA1i = 0\n      remaining = 0\n    # khi s\u1ED1\
    \ l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt c\xF2n l\u1EA1i \u0111\u1EE7 \u0111\u1EC3 \u0103\
    n\n    else\n      # t\u1ED5ng s\u1ED1 l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt b\u1ECB\
    \ \u0103n = s\u1ED1 l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt \u0111\xE3 \u0103n + s\u1ED1\
    \ l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt c\u1EA7n \u0103n\n      total = number + need\n\
    \      # s\u1ED1 l\u01B0\u1EE3ng c\u1EE7 c\u1EAFt c\xF2n l\u1EA1i = s\u1ED1 l\u01B0\
    \u1EE3ng c\u1EE7 c\u1EAFt \u0111\xE3 \u0103n + s\u1ED1 l\u01B0\u1EE3ng c\u1EE7\
    \ c\u1EAF", "    # your code is here\nend", "    if (remaining < (need - number))\n\
    \        [ remaining + number, 0 ]\n    else\n        [ need, remaining - (need\
    \ - number) ]\n    end\nend", "  number += need\n  number <= remaining ? [number,\
    \ remaining - number] : [remaining, 0]\nend", "  # Your code here\nend", "  number\
    \ += need\n  if number > remaining\n    number = remaining\n  end\n  [number,\
    \ remaining - number]\nend", "  n = number + [need, remaining].min\n  n > remaining\
    \ ? [n, 0] : [n, remaining - n]\nend", "  (number + need) <= remaining ? [number\
    \ + need, remaining - (number + need)] : [remaining + number, 0]\nend", "  eaten\
    \ = number + need\n  return [eaten, remaining - eaten] if remaining >= eaten\n\
    \  [eaten + remaining, 0]\nend", "  if remaining >= need\n    [number + need,\
    \ remaining - need]\n  else\n    [number + remaining, 0]\n  end\nend", "  eaten\
    \ = number + need\n  [ eaten, eaten <= remaining ? remaining - eaten : 0 ]\nend",
  "  number = number.to_i\n  need = need.to_i\n  remaining = remaining.to_i\n  if\
    \ remaining >= need\n    x = number + need\n    y = remaining - need\n    [x,\
    \ y]\n  else\n    x = number + remaining\n    y = 0\n    [x, y]\n  end\nend",
  "  if remaining >= need\n    res = []\n    res << number + need\n    res << remaining\
    \ - need\n    res\n  else\n    res = []\n    res << number + remaining\n    res\
    \ << 0\n    res\n  end\nend", "  # If there are enough remaining carrots, we eat\
    \ what we need and return the number eaten and the remaining carrots.\n  if remaining\
    \ >= need\n    return [number + need, remaining - need]\n  # Otherwise, we eat\
    \ what's left and return the number eaten and the remaining carrots.\n  else\n\
    \    return [number + remaining, 0]\n  end\nend", "  # your code\nend", "  eaten\
    \ = [number + need, remaining].min\n  [eaten, remaining - eaten]\nend", "  if\
    \ remaining < need\n    need = need - remaining\n    remaining = 0\n  else\n \
    \   remaining = remaining - need\n    need = 0\n  end\n  need = 0 if need < 0\n\
    \  remaining = 0 if remaining < 0\n  [number + need, remaining]\nend", "  eaten\
    \ = number + need\n  eaten > remaining ? [remaining, 0] : [eaten, remaining -\
    \ eaten]\nend", "  [(number + [remaining, need].min), remaining - [remaining,\
    \ need].min]\nend", "  if number + need <= remaining\n    [number + need, remaining\
    \ - (number + need)]\n  else\n    [remaining + number, 0]\n  end\nend", "    if\
    \ remaining >= need\n        return [number + need, remaining - need]\n    else\n\
    \        return [number + remaining, 0]\n    end\nend", "    eaten = number +\
    \ need\n    if remaining >= need\n        return [eaten, remaining - need]\n \
    \   else\n        return [eaten + remaining, 0]\n    end\nend", "  # your code\
    \ here\nend", "  if number + need > remaining\n    [remaining, 0]\n  else\n  \
    \  [number + need, remaining - (number + need)]\n  end\nend", "  [need+number,\
    \ remaining-need].minmax\nend", "  number + [remaining, need].min\nend", "  [\
    \ number + need, remaining - need ].tap { |result| result[1] = 0 if result[1]\
    \ < 0 }\nend", "  @number = number\n  @need = need\n  @remaining = remaining\n\
    \  if remaining < need\n    [number + remaining, 0]\n  else\n    [number + need,\
    \ remaining - need]\n  end\nend", "  eaten = number + need\n  remaining = remaining\
    \ - eaten\n  if remaining < 0\n    remaining = 0\n  end\n  [eaten, remaining]\n\
    end", "    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    elsif number + need > remaining\n        return [number\
    \ + remaining, 0]\n    end\nend", "  [number + remaining < need ? number + remaining\
    \ : need, number + remaining < need ? 0 : remaining - (need - number)]\nend",
  "  if need <= remaining\n    remaining -= need\n    eaten = number + need\n  else\n\
    \    eaten = number + remaining\n    remaining = 0\n  end\n  [eaten, remaining]\n\
    end", "  if (number + need) <= remaining\n    [number + need, remaining - (number\
    \ + need)]\n  else\n    [remaining + number, 0]\n  end\nend", "  if remaining\
    \ < need\n    [number + remaining, 0]\n  else\n    [number + need, remaining -\
    \ need]\n  end\nend", "  number + need > remaining ? [remaining, 0] : [number\
    \ + need, remaining - need]\nend", "  # write your solution in here\nend", " \
    \ new_number = number + need\n  new_remaining = remaining - need\n  if new_remaining\
    \ >= 0\n    return [new_number, new_remaining]\n  else\n    return [new_number\
    \ + new_remaining, 0]\n  end\nend", "  [number + need, remaining - need].min(2)\n\
    end", "  n = number + need\n  [n, n - remaining].minmax\nend", "    # code here\n\
    \    if remaining >= need\n        [(number + need), (remaining - need)]\n   \
    \ else\n        [number + remaining, 0]\n    end\nend", "  new_remaining = remaining\
    \ - (need - number)\n  if new_remaining < 0\n    new_remaining = 0\n  end\n  [number\
    \ + remaining - new_remaining, new_remaining]\nend", "  if remaining >= need\n\
    \    [(number + need), remaining - need]\n  else\n    [(number + remaining), 0]\n\
    \  end\nend", "  [number + need, remaining - need].min\nend", "  # write your\
    \ code here\nend", "  if number + need <= remaining\n    [number + need, remaining\
    \ - (number + need)]\n  else\n    [remaining + number, 0]\n  end\nend", "  if\
    \ remaining <= need\n    [number + remaining, 0]\n  else\n    [number + need,\
    \ remaining - need]\n  end\nend", "  total = number + remaining\n  if total <\
    \ need\n    [total, 0]\n  else\n    [need, total - need]\n  end\nend", "\tneed\
    \ = need + number\n\tif need < remaining\n\t\treturn [need, remaining - need]\n\
    \telse\n\t\treturn [need, 0]\n\tend\nend", "  (number + need) <= remaining ? [(number\
    \ + need), remaining - (number + need)] : [remaining + number, 0]\nend", "  if\
    \ number + need <= remaining\n    [number + need, remaining - (number + need)]\n\
    \  else\n    [remaining + number, 0]\n  end\nend", "  eaten = number + need\n\
    \  remaining - eaten > 0 ? [eaten, remaining - eaten] : [eaten - 1, 0]\nend",
  "  remaining < need ? [number + remaining, 0] : [number + need, remaining - need]\n\
    end", "    return [number + remaining, 0] if number + remaining < need\n    [need,\
    \ number + remaining - need]\nend", "  # Your code here\nend", "  if number +\
    \ need <= remaining\n    [number + need, remaining - (number + need)]\n  else\n\
    \    [remaining + number, 0]\n  end\nend", "  number + need > remaining ? [remaining,\
    \ 0] : [number + need, remaining - (number + need)]\nend", "  result = number\
    \ + need\n  if result > remaining\n    [remaining, 0]\n  else\n    [result, remaining\
    \ - result]\n  end\nend", "  if number + need > remaining\n    [remaining, 0]\n\
    \  else\n    [number + need, remaining - (number + need)]\n  end\nend", '  total
    = number + need', "  total = number + need\n  total > remaining ? [remaining,\
    \ 0] : [total, remaining - total]\nend", "  carrots = number + remaining\n  [\
    \ carrots > need ? need : carrots, carrots < need ? 0 : carrots - need ]\nend",
  "  eaten = number + [need, remaining].min\n  [eaten, remaining - [need, remaining].min]\n\
    end", "  if (number + need) > remaining\n    [remaining, (number + need) - remaining]\n\
    \  else\n    [number + need, 0]\n  end\nend", "  # your code here\nend", "  meals\
    \ = number + need\n  meals <= remaining ? [meals, remaining - meals] : [remaining,\
    \ 0]\nend", "  if number + need <= remaining\n    return [number + need, remaining\
    \ - number - need]\n  else\n    return [number + remaining, 0]\n  end\nend", " \
    \ need > remaining ?\n  [remaining + number, 0] :\n  [number + need, remaining\
    \ - need]\nend", "  [number + need, need - remaining].min\nend", "  remaining\
    \ = remaining - number if remaining > number\n  need = need - remaining\n  remaining\
    \ = 0 if remaining < 0\n  [remaining + number, need]\nend", "  # your code here\n\
    end", "  result = number + need\n  if result < remaining\n    return [result,\
    \ remaining - result]\n  else\n    return [result, 0]\n  end\nend", "  if (number\
    \ + need) > remaining\n    number = remaining\n    remaining = 0\n  else\n   \
    \ number += need\n    remaining -= need\n  end\n  [number, remaining]\nend", " \
    \   eaten = 0\n    if remaining >= need\n        eaten = need + number\n     \
    \   remaining = remaining - need\n    else\n        eaten = number + remaining\n\
    \        remaining = 0\n    end\n    [eaten, remaining]\nend", "  eaten = number\
    \ + need\n  remaining_carrots = remaining - need\n  [(eaten > remaining) ? remaining\
    \ : eaten, (remaining_carrots < 0) ? 0 : remaining_carrots]\nend\nputs \"Please\
    \ enter the number of carrots you have eaten:\"\nnumber = gets.chomp.to_i\nputs\
    \ \"Please enter the number of carrots you need to eat:\"\nneed = gets.chomp.to_i\n\
    puts \"Please enter the number of remaining carrots:\"\nremaining = gets.chomp.to_i",
  "    eaten = number + [remaining, need].min\n    [eaten, [remaining - need, 0].max]\n\
    end", end, "  [number + need, remaining - need].minmax\nend", "  [number + [remaining,\
    \ need].min, [remaining, need].min - need.abs].sort\nend", "  if number + need\
    \ > remaining\n    [remaining, 0]\n  else\n    [number + need, remaining - (number\
    \ + need)]\n  end\nend", "  if (number + need <= remaining)\n    return [ number\
    \ + need, remaining - number - need ]\n  else\n    return [ remaining + number,\
    \ 0 ]\n  end\nend", "  total = number + need\n  if total <= remaining\n    [total,\
    \ remaining - total]\n  else\n    [remaining, 0]\n  end\nend", "  total = number\
    \ + remaining\n  if total >= need\n    total = need\n  end\n  [total, total -\
    \ need]\nend", "  return [number+remaining, 0] if need - remaining >= 0\n  [number+need,\
    \ remaining-need]\nend", "  eaten_carrots = number + need\n  if remaining > need\n\
    \    [eaten_carrots, remaining - need]\n  else\n    [eaten_carrots + remaining,\
    \ 0]\n  end\nend", "  eat_num = [number + remaining, need].min\n  remain_num =\
    \ [remaining - (eat_num - number), 0].max\n  [eat_num, remain_num]\nend", "  need\
    \ = number + need\n  if need > remaining\n    [remaining,0]\n  else\n    [need,\
    \ remaining - need]\n  end\nend", "  (number + need) > remaining ? [remaining,0]\
    \ : [number + need, remaining - (number + need)]\nend", "  if remaining < need\n\
    \    [number + remaining, 0]\n  else\n    [number + need, remaining - need]\n\
    \  end\nend", "  if remaining >= number + need\n    [number + need, remaining\
    \ - number - need]\n  else\n    [remaining + number, 0]\n  end\nend", "  eaten\
    \ = number + [need, remaining].min\n  [eaten, remaining - [need, remaining].min]\n\
    end", "  if (number + need) <= remaining\n    [number + need, remaining - (number\
    \ + need)]\n  else\n    [remaining + number, 0]\n  end\nend", "  number += [remaining,\
    \ need].min\n  [number, [remaining - need, 0].max]\nend", "  arr = []\n  if remaining\
    \ <= 0\n    arr << number\n    arr << 0\n  elsif need >= remaining\n    arr <<\
    \ number + remaining\n    arr << 0\n  else\n    arr << number + need\n    arr\
    \ << remaining - need\n  end\n  arr\nend", "  [(number + need), (remaining - need)].minmax\n\
    end", "  eaten_carrots = number + need\n  remaining_carrots = [remaining - need,\
    \ 0].max\n  [eaten_carrots, remaining_carrots]\nend", "  eaten = [number + need,\
    \ remaining].min\n  remaining_carrots = [remaining - need, 0].max\n  [eaten, remaining_carrots]\n\
    end", "  [(number + [remaining, need].min), [remaining, need].min]\nend", "  \
    \  [number + need <= remaining ? need : number + need - remaining, number + need\
    \ <= remaining ? remaining - need : 0]\nend", "  number = 0 if number.nil?\n \
    \ need = 0 if need.nil?\n  remaining = 0 if remaining.nil?\n  return [0, remaining]\
    \ if number > 1000\n  return [0, remaining] if need > 1000\n  return [0, remaining]\
    \ if remaining > 1000\n  return [number, remaining] if number == need\n  return\
    \ [number, remaining] if number > need\n  return [number, remaining] if number\
    \ > remaining\n  return [number, remaining] if need > remaining\n  if number <\
    \ need && number <= remaining\n    remain_numbers = number + remaining\n    return\
    \ [number, remain_numbers] if remain_numbers > need\n    return [need, 0] if remain_numbers\
    \ < need\n  end\nend", "  left = remaining - (number + need)\n  if left >= 0\n\
    \    p [number + need, left]\n  else\n    p [number + remaining, 0]\n  end\nend",
  "  # your code here\nend", "  # your code here\nend", "  if number + need <= remaining\n\
    \    [ number + need, remaining - (number + need) ]\n  else\n    [ number + remaining,\
    \ 0 ]\n  end\nend", "\tif number >= need\n\t\treturn \"You don't need to eat more\"\
    \n\telsif number + remaining < need\n\t\treturn \"You're going to die, you need\
    \ more carrots\"\n\telse\n\t\tif remaining >= need - number\n\t\t\treturn \"You\
    \ ate #{need} carrots, you have #{remaining - (need - number)} left\"\n\t\telse\n\
    \t\t\treturn \"You ate #{remaining + number} carrots, you're still hungry\"\n\t\
    \tend\n\tend\nend", "  if number >= remaining\n    [remaining, 0]\n  elsif number\
    \ + need > remaining\n    [remaining, 0]\n  else\n    [number + need, remaining\
    \ - (number + need)]\n  end\nend", "  [number + [remaining, need].min, remaining\
    \ - [remaining, need].min].to_a\nend", "  if (number + need) <= remaining\n  \
    \  return [(number + need), (remaining - (number + need))]\n  else\n    return\
    \ [(number + remaining), 0]\n  end\nend", "  total = number + need\n  if total\
    \ < remaining\n    remaining -= total\n    [total, remaining]\n  else\n    [remaining,\
    \ 0]\n  end\nend", "  ([number + need, remaining].min, [remaining - need, 0].max)\n\
    end", "  [ number + need, remaining - need ].min(2)\nend", "  # your code here\n\
    end", "  total = number + need\n  if total > remaining\n    [remaining, 0]\n \
    \ else\n    [total, remaining - total]\n  end\nend", "  number + need > remaining\
    \ ? [remaining, 0] : [number + need, remaining - need]\nend", "    if remaining\
    \ == 0 || number >= need\n        return [number, remaining]\n    end\n    if\
    \ remaining < number\n        return [number, remaining]\n    end\n    if remaining\
    \ < number + need\n        return [number + remaining, 0]\n    end\n    eat(number\
    \ + need, need, remaining - need)\nend", "  # TODO: Write your code here.\n  number\
    \ += need\n  if number > remaining\n    number = remaining\n  end\n  remaining\
    \ -= number\n  [number, remaining]\nend", "  left_over = remaining - (number +\
    \ need)\n  left_over > 0 ? [number + need, left_over] : [number + need, 0]\nend",
  "  if number + need > remaining\n    [remaining, 0]\n  else\n    [number + need,\
    \ remaining - (number + need)]\n  end\nend", "  number += remaining - need >=\
    \ 0 ? need : remaining\n  remaining = remaining - need >= 0 ? remaining - need\
    \ : 0\n  [number, remaining]\nend", "  consumed = number + need\n  return [consumed,\
    \ 0] if remaining < need\n  [consumed, remaining - need]\nend", "  total = number\
    \ + need\n  remaining < total ? [remaining, 0] : [total, remaining - total]\n\
    end", "  if remaining >= need\n    return [number + need, remaining - need]\n\
    \  else\n    return [number + remaining, 0]\n  end\nend", "  need = remaining\
    \ if need > remaining\n  return [number + need, remaining - need]\nend", "  if\
    \ (need >= remaining)\n    return [number + remaining, 0]\n  else\n    return\
    \ [number + need, remaining - need]\n  end\nend", "  number_of_eaten_carrots =\
    \ number + need\n  eaten_carrots = number_of_eaten_carrots - remaining", "  eaten\
    \ = 0\n  for i in 0..need\n    remaining -= 1\n    eaten += 1\n    return [eaten,\
    \ remaining] if remaining == 0\n  end\nend", "  (number+need) <= remaining ? [number+need,\
    \ remaining - (number+need)] : [number+remaining, 0]\nend", "  (number + need)\
    \ > remaining ? [remaining, 0] : [number + need, remaining - need]\nend", "  total\
    \ = number + need\n  left = remaining - need\n  if total >= remaining\n    return\
    \ [total, 0]\n  else\n    return [total, left]\n  end\nend", "  meals = number\
    \ + need\n  if meals <= remaining\n    [meals, remaining - meals]\n  else\n  \
    \  [remaining, 0]\n  end\nend", "  total = number + need\n  total > remaining\
    \ ? [remaining, 0] : [total, remaining - total]\nend", "  remaining -= number\n\
    \  total = need - number\n  if remaining >= total\n    return [need, remaining\
    \ - total]\n  else\n    return [number + remaining, 0]\n  end\nend", "  eaten\
    \ = number + need\n  leftover = remaining - need\n  if leftover < 0\n    eaten\
    \ = eaten + leftover\n    leftover = 0\n  end\n  return [eaten, leftover]\nend",
  "  if remaining >= need\n    return [number + need, remaining - need]\n  else\n\
    \    return [number + remaining, 0]\n  end\nend", "  [(number + [remaining, need].min),\
    \ [remaining, need].min]\nend", "  # sum = number + need\n  # if sum > remaining\n\
    \  #   sum = remaining\n  # end\n  # print sum, remaining - sum\n  # return [sum,\
    \ remaining - sum]\n  [number + need, (number + need) - remaining].minmax.reverse.uniq\n\
    end", "  carrots = number + remaining\n  needed = need - number\n  if carrots\
    \ > needed\n    needed = [needed, 0].max\n    [need, needed]\n  else\n    carrots\
    \ = [carrots, 0].max\n    [carrots, 0]\n  end\nend", "  left = remaining - (number\
    \ + need)\n  [number + need, left]\nend", "    if (number + need) <= remaining\n\
    \        total = number + need\n        left = remaining - total\n        arr\
    \ = [total, left]\n    else\n        arr = [remaining, 0]\n    end\n    return\
    \ arr\nend", "  if (remaining + number) >= need\n    [need, (remaining + number)\
    \ - need]\n  else\n    [remaining + number, 0]\n  end\nend\nputs \"#{eat(5, 6,\
    \ 10)}\"\nputs \"#{eat(4, 8, 9)}\"\nputs \"#{eat(1, 10, 10)}\"\nputs \"#{eat(2,\
    \ 11, 5)}\"", "  eaten = number + need\n  if (eaten > remaining)\n    return [remaining,\
    \ 0]\n  else\n    return [eaten, remaining - eaten]\n  end\nend", "  # put your\
    \ code here\nend", "  c_eaten = number\n  c_left = remaining", "  if (number +\
    \ need) <= remaining\n    [number + need, remaining - (number + need)]\n  else\n\
    \    [remaining + number, 0]\n  end\nend", "  total = number + need\n  if total\
    \ > remaining\n    return [remaining, 0]\n  else\n    return [total, remaining\
    \ - total]\n  end\nend", "  ary = []\n  if remaining >= need\n    remaining -=\
    \ need\n    number += need\n    ary << number\n    ary << remaining\n  else\n\
    \    remaining = 0\n    number += remaining\n    ary << number\n    ary << remaining\n\
    \  end\n  ary\nend", "  #your code here\n  if remaining >= need\n    return [number\
    \ + need, remaining - need]\n  else\n    return [number + remaining, 0]\n  end\n\
    end", "  number + need > remaining ? [remaining, 0] : [number + need, remaining\
    \ - need]\nend", "  @number = number\n  @need = need\n  @remaining = remaining\n\
    \  # Your code here\n  # This is first solution\n  # result = number + need\n\
    \  # stock = remaining - need\n  # final = []\n  # if remaining >= need\n  # \
    \  final.push(result)\n  #   final.push(stock)\n  #   p final\n  # else\n  # \
    \  final.push(number + remaining)\n  #   final.push(0)\n  #   p final\n  # end\n\
    \  # This is second solution\n  result = number + need\n  stock = remaining -\
    \ need\n  final = []\n  if remaining >= need\n    final.push(result)\n    final.push(stock)\n\
    \    p final\n  else\n    final.push(number + remaining)\n    final.push(0)\n\
    \    p final\n  end\nend", "  if remaining >= number + need\n    [number + need,\
    \ remaining - (number + need)]\n  else\n    [remaining + number, 0]\n  end\nend",
  "  # write your code here\nend", "  [number + need, remaining - need].take(2)\n\
    end", "  total = number + need\n  if total < remaining\n    return [total, remaining\
    \ - total]\n  else\n    return [total, 0]\n  end\nend", "  eaten = number + need\n\
    \  if remaining < need\n    [eaten - remaining, 0]\n  else\n    [eaten, remaining\
    \ - need]\n  end\nend", "  [(number + need), remaining - need].min(2)\nend", " \
    \ number + [need, remaining].min, remaining - [need, remaining].min\nend", '  sum
    = number + need', "  amount = number + need\n  if amount > remaining\n    amount\
    \ = remaining\n  end\n  return [amount, remaining - amount]\nend", "  # Your code\
    \ here\nend", "  array = []\n  if number + need <= remaining\n    array << number\
    \ + need\n    array << remaining - (number + need)\n  else\n    array << number\
    \ + remaining\n    array << 0\n  end\n  array\nend", "  (number + need) > remaining\
    \ ? [remaining, 0] : [number + need, remaining - (number + need)]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
