name: HumanEval_12_longest
language: rb
prompt: "# Out of array of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return nil in case the input array\
  \ is empty.\n# >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"\
  c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n\
  \    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n \
  \   assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"\
  zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n\
  \  end\nend\n"
completions: ["  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend",
  "  longest = nil\n  strings.each do |string|\n    longest = string if longest.nil?\
    \ || string.length > longest.length\n  end\n  longest\nend", "  strings.inject\
    \ { |acc, val| val.length > acc.length ? val : acc }\nend", "  strings.empty?\
    \ ? nil : strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  return nil if strings.length == 0\n  result = []\n  strings.each { |i|\
    \ result << i.length }\n  strings[result.index(result.max)]\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  strings.sort_by(&:length).last\nend",
  "  strings.max_by(&:length)\nend", "  longest = strings.max_by{|str| str.length}\n\
    \  return longest\nend", "    if strings.empty? then return nil end\n    result\
    \ = strings[0]\n    strings.each { |str| result = str if str.length > result.length\
    \ }\n    result\nend", "  strings.sort { |x, y| y.length <=> x.length }.first\n\
    end", "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  longest\
    \ = strings.shift\n  strings.each do |s|\n    longest = s if s.length > longest.length\n\
    \  end\n  longest\nend", "  strings.max_by(&:length)\nend", "    strings.max_by(&:length)\n\
    end", "  length = strings.map { |string| string.length }.max\n  strings.find {\
    \ |string| string.length == length }\nend", "  strings.max_by { |item| item.length\
    \ }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
