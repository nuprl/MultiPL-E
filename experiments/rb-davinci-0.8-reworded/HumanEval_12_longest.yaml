name: HumanEval_12_longest
language: rb
prompt: "# Out of array of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return nil in case the input array\
  \ is empty.\n# >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"\
  c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n\
  \    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n \
  \   assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"\
  zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n\
  \  end\nend\n"
completions: ["  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend",
  "  longest = nil\n  strings.each do |string|\n    longest = string if longest.nil?\
    \ || string.length > longest.length\n  end\n  longest\nend", "  strings.inject\
    \ { |acc, val| val.length > acc.length ? val : acc }\nend", "  strings.empty?\
    \ ? nil : strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  return nil if strings.length == 0\n  result = []\n  strings.each { |i|\
    \ result << i.length }\n  strings[result.index(result.max)]\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  strings.sort_by(&:length).last\nend",
  "  strings.max_by(&:length)\nend", "  longest = strings.max_by{|str| str.length}\n\
    \  return longest\nend", "    if strings.empty? then return nil end\n    result\
    \ = strings[0]\n    strings.each { |str| result = str if str.length > result.length\
    \ }\n    result\nend", "  strings.sort { |x, y| y.length <=> x.length }.first\n\
    end", "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  longest\
    \ = strings.shift\n  strings.each do |s|\n    longest = s if s.length > longest.length\n\
    \  end\n  longest\nend", "  strings.max_by(&:length)\nend", "    strings.max_by(&:length)\n\
    end", "  length = strings.map { |string| string.length }.max\n  strings.find {\
    \ |string| string.length == length }\nend", "  strings.max_by { |item| item.length\
    \ }\nend", "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend",
  "  len = 0\n  answer = nil\n  strings.each do |s|\n    if s.length > len\n     \
    \ len = s.length\n      answer = s\n    end\n  end\n  answer\nend", "  strings.sort_by(&:length).last\n\
    end", "\tstrings.max_by { |s| s.length }\nend", "  sorted = strings.sort { |a,\
    \ b| b.length <=> a.length }\n  sorted.first\nend", "  longest = nil\n  strings.each\
    \ do |string|\n    longest = string if longest.nil? || longest.length < string.length\n\
    \  end\n  longest\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  if strings.length == 0\n    return nil\n  else\n    longest_string =\
    \ strings[0]\n    strings.each do |string|\n      if string.length > longest_string.length\n\
    \        longest_string = string\n      end\n    end\n    return longest_string\n\
    \  end\nend", "  str = nil\n  l = 0\n  strings.each do |string|\n    if string.length\
    \ > l\n      l = string.length\n      str = string\n    end\n  end\n  str\nend",
  "\tmax_string_length = 0\n\tlongest_string = nil\n\tstrings.each do |string|\n\t\
    \tif string.length > max_string_length\n\t\t\tmax_string_length = string.length\n\
    \t\t\tlongest_string = string\n\t\tend\n\tend\n\tlongest_string\nend", "  strings.inject(nil)\
    \ do |r, x|\n    (r == nil || x.length > r.length) ? x : r\n  end\nend", "  longest\
    \ = strings.max_by { |string| string.length }\n  return longest\nend", "  strings.max_by(&:length)\n\
    end", "  return nil if strings.length == 0\n  len = 0\n  strings.each do |string|\n\
    \    len = string.length if string.length > len\n  end\n  strings.each do |string|\n\
    \    return string if string.length == len\n  end\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by { |str| str.length }\nend", "  strings.each_with_object(strings.first)\
    \ { |s, l| l = s if s.length > l.length }\nend", "  strings.sort_by { |string|\
    \ string.length }.last\nend", "  strings.inject { |string, longest| string.length\
    \ > longest.length ? string : longest }\nend", "  strings.sort { |x, y| y.length\
    \ <=> x.length }.first\nend", "  return nil if strings.empty?\n  strings.inject\
    \ do |memo, string|\n    memo.length > string.length ? memo : string\n  end\n\
    end", end, "  strings.max_by(&:length)\nend", "\tstrings.max_by(&:length)\nend",
  "  longest = strings.max { |a, b| a.length <=> b.length }\n  return longest\nend",
  "  longest = strings.first\n  strings.each do |string|\n    longest = string if\
    \ string.length > longest.length\n  end\n  longest\nend", "  strings.max_by {\
    \ |s| s.length }\nend", "  # your code here\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  strings.empty? ? nil : strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  strings.sort { |string1, string2|\
    \ string2.length <=> string1.length }.first\nend", "  strings.max_by { |string|\
    \ string.length }\nend", "  return nil if strings.empty?\n  strings.sort_by {\
    \ |s| s.length }.last\nend", "  return nil if strings.empty?\n  strings.sort_by(&:length).last\n\
    end", "  # your code goes here\nend", "  strings.max_by { |s| s.length }\nend",
  "  return strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  strings.sort_by\
    \ { |string| string.length }.last\nend", "  longest = nil\n  return nil if strings.empty?\n\
    \  strings.each do |string|\n    longest = string if longest.nil? || string.length\
    \ > longest.length\n  end\n  longest\nend", "  return strings.max_by(&:length)\
    \ unless strings.empty?\n  nil\nend", "  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\n\
    end", "  string = nil\n  strings.each do |s|\n    if string.nil? || s.length >\
    \ string.length\n      string = s\n    end\n  end\n  string\nend", "  return nil\
    \ if strings.empty?\n  strings.max_by(&:length)\nend", "  len = 0\n  long = nil\n\
    \  strings.each do |string|\n    if string.length > len\n      len = string.length\n\
    \      long = string\n    end\n  end\n  long\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by(&:length)\nend", "  strings.max { |a, b| a.length <=>\
    \ b.length }\nend", "  longest = nil\n  strings.each do |s|\n    longest = s if\
    \ longest.nil? || s.length > longest.length\n  end\n  longest\nend", "  strings.sort\
    \ { |a, b| b.length <=> a.length }.first\nend", "  strings.sort_by(&:length).reverse.first\n\
    end", "\tif strings.length == 0\n\t\treturn nil\n\tend\n\ti = 0\n\tlongest = \"\
    \"\n\twhile i < strings.length\n\t\tif strings[i].length > longest.length\n\t\t\
    \tlongest = strings[i]\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn longest\nend",
  "    return nil if strings.empty?\n    strings.inject { |memo, var| memo.length\
    \ > var.length ? memo : var }\nend", "  return nil if strings.empty?\n  strings.max_by(&:length)\n\
    end", "  longest = nil\n  strings.each do |string|\n    longest = string if longest.nil?\
    \ || string.length > longest.length\n  end\n  longest\nend", "  longest = nil\n\
    \  strings.each do |string|\n    longest = string if longest.nil? || string.length\
    \ > longest.length\n  end\n  longest\nend", "  strings.max_by(&:length)\nend",
  "  strings.inject { |result, string| string.length > result.length ? string : result\
    \ }\nend", "  strings.max_by(&:length)\nend", "  longest = strings.max { |s1,\
    \ s2| s1.length <=> s2.length }\n  longest || nil\nend", "  strings.max { |str1,\
    \ str2| str1.length <=> str2.length }\nend", "  len = 0\n  longest = nil\n  strings.each\
    \ do |s|\n    if s.length > len\n      len = s.length\n      longest = s\n   \
    \ end\n  end\n  longest\nend", "  strings.max { |a, b| a.length <=> b.length }\n\
    end", "    if strings.length == 0\n        return nil\n    end\n    max = strings[0]\n\
    \    strings.each do |x|\n        if x.length > max.length\n            max =\
    \ x\n        end\n    end\n    return max\nend", "  strings.inject(nil) do |longest,\
    \ string|\n    string.length > longest.to_s.length ? string : longest\n  end\n\
    end", "  return nil if strings.empty?\n  longest = strings.first\n  strings.each\
    \ do |string|\n    longest = string if string.length > longest.length\n  end\n\
    \  longest\nend", "  longest = strings.first\n  strings.each do |string|\n   \
    \ longest = string if string.length > longest.length\n  end\n  longest\nend",
  "\tlongest_string = nil\n\tstrings.each do |string|\n\t\tif longest_string.nil?\
    \ || string.length > longest_string.length\n\t\t\tlongest_string = string\n\t\t\
    end\n\tend\n\tlongest_string\nend", "  return nil if strings.empty?\n  max_len\
    \ = strings.map(&:length).max\n  strings.find { |s| s.length == max_len }\nend",
  "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n  longest =\
    \ strings.shift\n  strings.each do |string|\n    longest = string if string.length\
    \ > longest.length\n  end\n  longest\nend", "  strings.max_by(&:length)\nend",
  "  strings.max_by { |s| s.length }\nend", "  strings.max_by { |string| string.length\
    \ }\nend", "  strings.max_by(&:length)\nend", "  strings.sort_by(&:length).last\n\
    end", "  if !strings.empty?\n    longest = strings[0]\n    strings.each do |x|\n\
    \      if x.length > longest.length\n        longest = x\n      end\n    end\n\
    \    return longest\n  else\n    return nil\n  end\nend", "  if strings.length\
    \ == 0\n    nil\n  else\n    longest = strings[0]\n    strings.each do |string|\n\
    \      if string.length > longest.length\n        longest = string\n      end\n\
    \    end\n    longest\n  end\nend", "  strings.sort_by{|str| str.length}[-1]\n\
    end", "  return nil if strings.empty?\n  strings.sort_by { |x| x.length }.last\n\
    end", "  strings.inject do |longest, current|\n    longest.length > current.length\
    \ ? longest : current\n  end\nend", "  strings.max_by { |string| string.length\
    \ }\nend", "  strings.each { |e| e.to_s }\n  return nil if strings.length == 0\n\
    \  strings.max_by(&:length)\nend", "  strings.inject { |memo, str| memo.length\
    \ > str.length ? memo : str }\nend", "  strings.sort{|a,b| a.length <=> b.length}[-1]\n\
    end", "  return nil if strings.nil? || strings.empty?\n  strings.max_by(&:length)\n\
    end", "  longest = strings.first\n  strings.each do |string|\n    longest = string\
    \ if string.length > longest.length\n  end\n  longest\nend", "  length = 0\n \
    \ string = nil\n  strings.each do |str|\n    if str.length > length\n      length\
    \ = str.length\n      string = str\n    end\n  end\n  string\nend", "  strings.sort_by(&:length).last\n\
    end", "  strings.max { |a, b| a.length <=> b.length }\nend", "  string = nil\n\
    \  strings.each do |s|\n    if string.nil? || s.length > string.length\n     \
    \ string = s\n    end\n  end\n  string\nend", "  return nil if strings.length\
    \ == 0\n  strings.max_by(&:length)\nend", "  longest = nil\n  strings.each do\
    \ |string|\n    longest = string if longest.nil? || string.length > longest.length\n\
    \  end\n  longest\nend", "  sorted = strings.sort_by(&:length)\n  sorted.empty?\
    \ ? nil : sorted.last\nend", "\treturn nil if strings.empty?\n\tstrings.sort!{|a,b|\
    \ b.length <=> a.length}\n\tstrings[0]\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |item| item.length }\nend", "  strings.max_by(&:length)\n\
    end", "  strings.sort_by(&:length).last\nend", "  return nil if strings.empty?\n\
    \  longest = strings.max_by(&:length)\n  longest\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |s| s.length }\nend", "  strings.max_by(&:length)\nend", " \
    \ return nil if strings.empty?\n  strings.inject { |longest, string| string.length\
    \ > longest.length ? string : longest }\nend", "  strings.max_by { |str| str.length\
    \ }\nend", "  return nil if strings.length == 0\n  strings.max { |a, b| a.length\
    \ <=> b.length }\nend", "  return nil if strings.empty?\n  strings.sort_by(&:length).last\n\
    end", '  max_length = strings.max_by(&:length).length', "\treturn nil if strings.empty?\n\
    \tstrings.max_by { |str| str.length }\nend", "  strings.sort_by{|string| string.length}.last\n\
    end", "  return strings.sort_by(&:length).last\nend", "  strings.max_by(&:length)\n\
    end", "  strings.max_by { |i| i.length }\nend", "  raise NotImplementedError\n\
    end", "  return nil if strings.empty?\n  strings.max_by(&:length)\nend", "  strings.map{|x|\
    \ x.length}.sort.reverse.each do |i|\n    return strings.find{|x| x.length ==\
    \ i}\n  end\nend", "  return nil if strings.empty?\n  longest = strings.first\n\
    \  strings.each do |string|\n    longest = string if string.length > longest.length\n\
    \  end\n  longest\nend", "  return nil if strings.empty?\n  longest = strings.first\n\
    \  strings.each do |string|\n    longest = string if string.length > longest.length\n\
    \  end\n  longest\nend", "  strings.max_by { |s| s.length }\nend", "\tmax_length\
    \ = 0\n\tmax_length_string = nil\n\tstrings.each do |string|\n\t\tif string.length\
    \ > max_length\n\t\t\tmax_length = string.length\n\t\t\tmax_length_string = string\n\
    \t\tend\n\tend\n\tmax_length_string\nend", "  strings.max_by { |x| x.length }\n\
    end", "  strings.max_by { |x| x.length }\nend", "  longest = nil\n  longest_length\
    \ = 0\n  strings.each do |str|\n    if str.length > longest_length\n      longest\
    \ = str\n      longest_length = str.length\n    end\n  end\n  longest\nend", "\t\
    return nil if strings.empty?\n\tstrings.max_by { |str| str.length }\nend", " \
    \ return nil if strings.length == 0\n  longest = strings[0]\n  strings.each do\
    \ |string|\n    longest = string if string.length > longest.length\n  end\n  longest\n\
    end", "  longest = strings.map(&:length).max\n  strings.find { |s| s.length ==\
    \ longest }\nend", "  strings.max_by(&:length)\nend", "  strings.each do |string|\n\
    \    if (strings.nil?)\n      return nil\n    else\n      strings.sort { |x, y|\
    \ y.length <=> x.length }\n      return strings[0]\n    end\n  end\nend", "\t\
    strings.max_by(&:length)\nend", "  longest = nil\n  strings.each do |s|\n    longest\
    \ = s if longest.nil? || s.length > longest.length\n  end\n  longest\nend", " \
    \ strings.max_by { |str| str.length }\nend", "  strings.max_by(&:length)\nend",
  "  strings.sort_by(&:length).last\nend", "  strings.empty? ? nil : strings.inject\
    \ { |result, string| result.length > string.length ? result : string }\nend",
  "\tmax = 0\n\tindex = 0\n\tstrings.each_with_index do |x, i|\n\t\tif x.length >\
    \ max\n\t\t\tmax = x.length\n\t\t\tindex = i\n\t\tend\n\tend\n\treturn strings[index]\n\
    end", "  strings.max { |a, b| a.length <=> b.length }\nend", "  strings.max_by\
    \ { |x| x.length }\nend", "  strings.max_by(&:length)\nend", "  longest = nil\n\
    \  strings.each do |string|\n    longest = string if longest.nil? or string.length\
    \ > longest.length\n  end\n  longest\nend", "  return nil if strings.empty?\n\
    \  strings.max_by { |str| str.length }\nend", "  longest = strings.max_by { |s|\
    \ s.length }\n  strings.include?(longest) ? longest : nil\nend", "  return strings.max_by(&:length)\n\
    end", "  strings.sort_by { |s| s.length }.last\nend", "\tstrings.max_by { |s|\
    \ s.length }\nend", "  if strings.empty?\n    nil\n  else\n    strings.max_by\
    \ { |str| str.length }\n  end\nend", "\tstrings.max_by(&:length)\nend", "  strings.max_by(&:length)\n\
    end", "  # TODO: implement\nend", "    if strings.length == 0\n        return\
    \ nil\n    end\n    result = strings[0]\n    strings.each do |string|\n      \
    \  if string.length > result.length\n            result = string\n        end\n\
    \    end\n    return result\nend", "  strings.empty? ? nil : strings.max_by(&:length)\n\
    end", "  if strings.empty?\n    nil\n  else\n    strings.max { |a, b| a.length\
    \ <=> b.length }\n  end\nend", "\tlengths = {}\n\tstrings.each do |str|\n\t\t\
    lengths[str] = str.length\n\tend\n\tlengths.max_by{|k,v| v}[0]\nend\nlongest.call([\"\
    a\", \"bb\", \"ccc\"])", "\tstrings.group_by(&:size).max.last.first\nend", " \
    \   return nil if strings.empty?\n    longest = strings[0]\n    strings.each do\
    \ |str|\n        longest = str if str.length > longest.length\n    end\n    longest\n\
    end", "  return nil if strings.empty?\n  strings.max_by { |s| s.length }\nend",
  "  return nil if strings.empty?\n  strings.sort! { |a, b| b.length <=> a.length\
    \ }\n  strings[0]\nend", "  return nil if strings.empty?\n  strings.max_by { |str|\
    \ str.length }\nend", "  return nil if strings.empty?\n  strings.sort_by { |s|\
    \ s.length }.last\nend", "  strings.sort_by { |str| str.length }.last\nend", " \
    \ strings.max_by(&:length)\nend", "  longest = nil\n  strings.each do |string|\n\
    \    longest = string if longest.nil? || string.length > longest.length\n  end\n\
    \  longest\nend", "\tresult = nil\n\tresult = strings.max_by { |e| e.length }\n\
    \treturn result\nend", "  strings.max_by(&:length)\nend", "  return nil if strings.empty?\n\
    \  l = strings.map(&:length).max\n  strings.select { |s| s.length == l }.first\n\
    end", "  longest = strings.max_by(&:length)\n  longest if longest\nend", "  strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.sort_by { |e| e.length }.last\n\
    end", "  strings.sort_by{|s| s.length}.last\nend", "  strings.max_by(&:length)\n\
    end", "  longest = strings.first\n  strings.each do |str|\n    longest = str if\
    \ str.length > longest.length\n  end\n  longest\nend", "\t#if strings.length >\
    \ 0\n\t#\tp strings.max {|a,b| a.length <=> b.length}\n\t#else\n\t#\tp nil\n\t\
    #end\n\t#strings.max {|a,b| a.length <=> b.length}\n\tp strings.inject {|memo,v|\
    \ memo.length > v.length ? memo : v}\nend", "  return nil if strings.empty?\n\
    \  max = strings.max_by(&:length)\n  max\nend", "  strings.max_by(&:length)\n\
    end", "  longest = strings.inject { |memo, w| memo.length > w.length ? memo :\
    \ w }\n  return longest\nend", "  return nil if strings.length == 0\n  longest\
    \ = strings[0]\n  strings.each do |string|\n    longest = string if string.length\
    \ > longest.length\n  end\n  longest\nend", "  strings.max_by { |s| s.length }\n\
    end", "  strings.inject do |longest, string|\n    (string.length > longest.length)\
    \ ? string : longest\n  end\nend", "  if strings.length == 0\n    nil\n  else\n\
    \    strings.sort_by(&:length).last\n  end\nend", "  strings.sort_by(&:length).last\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
