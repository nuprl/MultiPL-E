name: HumanEval_0_has_close_elements
language: rb
prompt: "# Check if in given array of numbers, are any two numbers closer to each\
  \ other than\n# given threshold.\n# >>> has_close_elements.call([1.0, 2.0, 3.0],\
  \ 0.5)\n# false\n# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\
  # true\ndef has_close_elements(numbers, threshold)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_has_close_elements\n\
  \    candidate = method(:has_close_elements)\n    assert_equal(true, candidate.call([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))\n    assert_equal(false, candidate.call([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))\n    assert_equal(true, candidate.call([1.0,\
  \ 2.0, 5.9, 4.0, 5.0], 0.95))\n    assert_equal(false, candidate.call([1.0, 2.0,\
  \ 5.9, 4.0, 5.0], 0.8))\n    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.0], 0.1))\n    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1],\
  \ 1.0))\n    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))\n\
  \  end\nend\n"
completions: ["  numbers.each_with_index do |number, index|\n    next if index.zero?\n\
    \    return true if number - numbers[index - 1] < threshold\n  end\n  false\n\
    end", "  if numbers == []\n    return false\n  end\n  i = 0\n  while i < numbers.length\
    \ - 1\n    j = i + 1\n    while j < numbers.length\n      if (numbers[i] - numbers[j]).abs\
    \ < threshold\n        return true\n      end\n      j += 1\n    end\n    i +=\
    \ 1\n  end\n  return false\nend", "  numbers.each_with_index do |number, index|\n\
    \    next if index == 0\n    return true if (number - numbers[index - 1]).abs\
    \ < threshold\n  end\n  false\nend", "  for i in 0..numbers.length-2\n    for\
    \ j in (i+1)..numbers.length-1\n      if (numbers[i] - numbers[j]).abs < threshold\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  numbers.combination(2).any?\
    \ { |a, b| (a - b).abs < threshold }\nend", "  !(numbers.each_with_index.find\
    \ { |number, index| index + 1 != numbers.size && (number - numbers[index + 1]).abs\
    \ < threshold }).nil?\nend", "  numbers.any? do |number|\n    numbers.any? do\
    \ |compared_number|\n      (number - compared_number).abs < threshold &&\n   \
    \     number != compared_number\n    end\n  end\nend", "  numbers.each_with_index\
    \ do |n, i|\n    next if i == numbers.length - 1\n    if ((numbers[i + 1] - n).abs\
    \ <= threshold)\n      return true\n    end\n  end\n  false\nend", "  sorted_numbers\
    \ = numbers.sort\n  sorted_numbers.each_with_index do |current_number, index|\n\
    \    next_number = sorted_numbers[index + 1]\n    return true if next_number &&\
    \ (next_number - current_number) < threshold\n  end\n  false\nend", "  numbers.each_with_index\
    \ do |number, index|\n    break if index == numbers.length - 1\n    return true\
    \ if (number - numbers[index + 1]).abs < threshold\n  end\n  false\nend", "  sorted_numbers\
    \ = numbers.sort\n  sorted_numbers.each_with_index do |number, index|\n    break\
    \ if index == sorted_numbers.length - 1\n    if (sorted_numbers[index+1] - number).abs\
    \ < threshold\n      return true\n    end\n  end\n  false\nend", "  for i in 0..numbers.length-2\n\
    \    for j in i+1..numbers.length-1\n      if (numbers[i] - numbers[j]).abs <\
    \ threshold\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  numbers.any? do |n|\n    numbers.any? do |m|\n      diff = (n - m).abs\n\
    \      diff > 0 && diff < threshold\n    end\n  end\nend", "  return '\u0423\u043A\
    \u0430\u0436\u0438\u0442\u0435 \u043C\u0430\u0441\u0441\u0438\u0432 \u0447\u0438\
    \u0441\u0435\u043B \u0438 \u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\
    \u0435 \u043E\u0442\u043A\u043B\u043E\u043D\u0435\u043D\u0438\u0435!' if numbers.empty?\
    \ || !threshold\n  count = 0\n  while count < numbers.size\n    return true if\
    \ numbers[count] - numbers[count + 1] <= threshold.to_f\n    count += 1\n  end\n\
    \  false\nend", "  numbers.each_with_index do |element, index|\n    return true\
    \ if numbers[index + 1..-1].any? { |n| (n - element).abs < threshold }\n  end\n\
    \  false\nend", "  numbers.sort.each_cons(2).any? { |(x, y)| (y - x).abs < threshold\
    \ }\nend", "  result = false\n  numbers.each do |number1|\n    numbers.each do\
    \ |number2|\n      result = true if number1 - number2 >= 0 && number1 - number2\
    \ <= threshold\n    end\n  end\n  result\nend", "  sorted_numbers = numbers.sort\n\
    \  sorted_numbers.each_with_index do |num, index|\n    if index != sorted_numbers.length\
    \ - 1\n      return true if (sorted_numbers[index + 1] - num).abs < threshold\n\
    \    end\n  end\n  false\nend", "    # Sort the array\n    sorted_numbers = numbers.sort\n\
    \    # Start looping through the array\n    sorted_numbers.each_with_index do\
    \ |x, index|\n        # If we are at the end of the array, break out of the loop\n\
    \        if index == (sorted_numbers.length - 1)\n            break\n        end\n\
    \        # If the difference between two elements is less than the threshold,\
    \ return true\n        if (sorted_numbers[index + 1] - x).abs < threshold\n  \
    \          return true\n        end\n    end\n    # If we got here, there weren't\
    \ any close enough numbers\n    return false\nend", "  numbers.sort.each_cons(2).any?\
    \ do |a, b|\n    (a - b).abs < threshold\n  end\nend", "  return false if numbers.empty?\n\
    \  return numbers.size > 1 if numbers.size == 2\n  numbers.sort!", "  return true\
    \ if numbers.size <= 1\n  prev_num = numbers[0]\n  numbers[1..-1].each do |num|\n\
    \    return true if (num - prev_num).abs < threshold\n    prev_num = num\n  end\n\
    \  false\nend", "  numbers.combination(2).any? do |n1, n2|\n    (n1 - n2).abs\
    \ < threshold\n  end\nend", "  for a in 0..numbers.length-1\n    for b in a+1..numbers.length-1\n\
    \      if ((numbers[a] - numbers[b]).abs) < threshold\n        return true\n \
    \     end\n    end\n  end\n  return false\nend", "  (numbers.length - 1).times\
    \ do |index|\n    diff = (numbers[index] - numbers[index + 1]).abs\n    return\
    \ true if diff < threshold\n  end\n  false\nend", "  numbers.each_with_index do\
    \ |number, index|\n    i = 1\n    while index + i < numbers.length\n      if (number\
    \ - numbers[index + i]).abs < threshold\n        return true\n      end\n    \
    \  i += 1\n    end\n  end\n  false\nend", "  numbers.each_with_index do |number,\
    \ index|\n    next if index == numbers.length - 1\n    return true if (number\
    \ - numbers[index + 1]).abs < threshold\n  end\n  false\nend", "  numbers.each_with_index\
    \ do |number, index|\n    current_distance = numbers[index+1] - number\n    if\
    \ current_distance.abs < threshold\n      return true\n    end\n  end\n  return\
    \ false\nend", "  numbers.each_with_index do |num, i|\n    if (i+1..numbers.length).each\
    \ do |j|\n      return true if (num - numbers[j]).abs < threshold\n    end\n \
    \   end\n  end\n  false\nend", "  numbers.each_with_index do |number, index|\n\
    \    numbers[index+1..-1].each do |number2|\n      difference = (number - number2).abs\n\
    \      return true if difference < threshold\n    end\n  end\n  false\nend", " \
    \ for i in 0..numbers.length-2\n    for j in i+1..numbers.length-1\n      if (numbers[i]\
    \ - numbers[j]).abs < threshold\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  numbers.each_with_index do |num, i|\n    numbers.each_with_index\
    \ do |num2, j|\n      if (i != j)\n        if (num - num2).abs < threshold\n \
    \         return true\n        end\n      end\n    end\n  end\n  return false\n\
    end", "  numbers.each_with_index do |element, index|\n    numbers.each_with_index\
    \ do |compare_element, compare_index|\n      return true if index != compare_index\
    \ && (element - compare_element).abs < threshold\n    end\n  end\n  false\nend",
  "  numbers.sort.each_cons(2).map { |a, b| (a - b).abs }.any? { |x| x < threshold\
    \ }\nend", "  previous_value = nil\n  numbers.each do |x|\n    if previous_value\n\
    \      if (x - previous_value).abs < threshold\n        return true\n      end\n\
    \    end\n    previous_value = x\n  end\n  return false\nend", "  if numbers.size\
    \ == 1\n    return false\n  end", "  numbers.each_with_index do |n, i|\n    next\
    \ if i == numbers.length - 1\n    return true if (numbers[i + 1] - n).abs < threshold\n\
    \  end\n  false\nend", "  for i in 0..numbers.length - 2\n    return true if numbers[i\
    \ + 1] - numbers[i] < threshold\n  end\n  false\nend", "  min_diff = Float::INFINITY\n\
    \  numbers.sort.each_cons(2) do |a, b|\n    diff = (a - b).abs\n    min_diff =\
    \ diff if diff < min_diff\n  end\n  min_diff < threshold\nend", "  numbers.combination(2).any?\
    \ do |pair|\n    pair.inject(:-).abs < threshold\n  end\nend", "  numbers.each_with_index\
    \ do |x, i|\n    numbers.each_with_index do |y, j|\n      return true if x !=\
    \ y && ((x - y).abs < threshold)\n    end\n  end\n  false\nend", "  has_close_elements\
    \ = false\n  previous_value = -1\n  numbers.each do |number|\n    if previous_value\
    \ > 0\n      distance = (number - previous_value).abs\n      if distance < threshold\n\
    \        has_close_elements = true\n        break\n      end\n    end\n    previous_value\
    \ = number\n  end\n  has_close_elements\nend", "  sorted_numbers = numbers.sort\n\
    \  sorted_numbers.each_with_index do |number, index|\n    next_index = index +\
    \ 1\n    return true if sorted_numbers[next_index] - number < threshold && sorted_numbers[next_index]\
    \ - number > 0\n  end\n  false\nend", "  numbers.each_with_index do |number, index|\n\
    \    return true if (index != numbers.length - 1) && ((numbers[index + 1] - number).abs\
    \ <= threshold)\n  end\n  false\nend", "  numbers.each_with_index do |number,\
    \ index|\n    next if index + 1 == numbers.length\n    if (number - numbers[index\
    \ + 1]).abs < threshold\n      return true\n    end\n  end\n  false\nend", " \
    \ # TODO implement me\nend", "  numbers.combination(2).any? { |x, y| (x - y).abs\
    \ < threshold }\nend", "  if numbers.length > 1\n    i = 0\n    while i < numbers.length\
    \ - 1\n      j = i + 1\n      while j < numbers.length\n        return true if\
    \ ((numbers[i] - numbers[j]).abs < threshold)\n        j += 1\n      end\n   \
    \   i += 1\n    end\n  end\n  false\nend", '  previous_number = numbers.first',
  "  numbers.each_with_index { |number, i| return true if abs_diff(number, numbers[i\
    \ + 1]) < threshold }\n  false\nend", "  numbers.size.times do |i|\n    numbers.size.times\
    \ do |j|\n      return true if i != j && (numbers[i] - numbers[j]).abs < threshold\n\
    \    end\n  end\n  false\nend", "  numbers.each_with_index do |number, index|\n\
    \    next if numbers[index + 1].nil?\n    return true if (number - numbers[index\
    \ + 1]).abs < threshold\n  end\n  false\nend", "  if numbers.kind_of?(Array)\n\
    \    numbers.each do |number|\n      return true if numbers.any? { |i| (number\
    \ - i).abs < threshold }\n    end\n  end\n  false\nend", "  return false if numbers.length\
    \ < 2\n  min_distance = numbers[1] - numbers[0]\n  numbers.each_with_index do\
    \ |num, index|\n    next if index < numbers.length - 1\n    distance = numbers[index+1]\
    \ - num\n    if distance < min_distance\n      min_distance = distance\n    end\n\
    \  end\n  return min_distance < threshold\nend", "  numbers.combination(2).any?\
    \ { |a, b| (a - b).abs < threshold }\nend", "  numbers.each_with_index do |number,\
    \ i|\n    next if i == 0", '  numbers.sort!', "\tnumbers.each_with_index do |number,index|\n\
    \t\tfor i in index+1..numbers.length-1\n\t\t\tif (numbers[i]-number).abs < threshold\n\
    \t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  numbers.each_with_index\
    \ do |num, idx|\n    break if idx == numbers.length - 1\n    return true if (num\
    \ - numbers[idx + 1]).abs < threshold\n  end\n  false\nend", "  numbers.each_with_index\
    \ do |number, index|\n    if numbers[index + 1]\n      if (numbers[index + 1]\
    \ - number).abs < threshold\n        return true\n      end\n    end\n  end\n\
    \  false\nend", "  numbers.combination(2).each do |a, b|\n    return true if (a\
    \ - b).abs < threshold\n  end\n  false\nend", "  numbers.each_with_index do |number,\
    \ index|\n    next if index == 0\n    if number - numbers[index - 1] < threshold\n\
    \      return true\n    end\n  end\n  false\nend", "  numbers.each_with_index\
    \ do |x, index|\n    numbers.each_with_index do |y, j|\n      if index != j\n\
    \        return true if (x - y).abs < threshold\n      end\n    end\n  end\n \
    \ false\nend", "  sorted_numbers = numbers.sort\n  sorted_numbers.each_with_index\
    \ do |el, index|\n    sorted_numbers[index+1..-1].each do |el2|\n      return\
    \ true if el2 - el < threshold\n    end\n  end\n  false\nend", "  return false\
    \ if numbers.length < 2\n  numbers.sort!\n  for i in 0..numbers.length-2\n   \
    \ return true if numbers[i+1] - numbers[i] < threshold\n  end\n  false\nend",
  "  numbers.each_with_index do |elem, index|\n    ((index + 1)...numbers.length).each\
    \ do |i|\n      if (elem - numbers[i]).abs < threshold\n        return true\n\
    \      end\n    end\n  end\n  false\nend", "  numbers.combination(2).detect do\
    \ |a, b|\n    (a - b).abs < threshold\n  end\nend", "  for n1 in numbers\n   \
    \ for n2 in numbers\n      # don't compare number with itself\n      if n1 !=\
    \ n2\n        distance = n1 - n2\n        # if absolute distance is less than\
    \ threshold, we have a match\n        if distance.abs < threshold\n          return\
    \ true\n        end\n      end\n    end\n  end\n  return false\nend", "  min_distance\
    \ = numbers.length - 1\n  numbers.each_with_index do |number, index|\n    for\
    \ i in (index + 1)..(numbers.length - 1)\n      if (numbers[i] - number).abs <\
    \ min_distance\n        min_distance = (numbers[i] - number).abs\n      end\n\
    \    end\n  end\n  return min_distance < threshold\nend", "  numbers.each_with_index\
    \ do |number, i|\n    next if i == numbers.length - 1\n    next_number = numbers[i\
    \ + 1]\n    return true if (number - next_number).abs < threshold\n  end\n  false\n\
    end", "  # tarcza antyczarna\n  return false if numbers.count < 2\n  # du\u017C\
    o szybciej zrobi\u0107 przez zaznaczanie znalezionych par!\n  # numbers.each do\
    \ |n|\n  #   numbers.each do |m|\n  #     return true if (n - m).abs < threshold\n\
    \  #   end\n  # end\n  numbers.each_with_index do |n, i|\n    numbers[i+1..-1].each\
    \ do |m|\n      return true if (n - m).abs < threshold\n    end\n  end\n  false\n\
    end\nputs has_close_elements([1.0, 2.0, 3.0], 0.5)\nputs has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)", "  numbers.each_cons(2).any? do |pair|\n  \
    \  (pair[0] - pair[1]).abs < threshold\n  end\nend", "  return false if numbers.length\
    \ <= 1\n  numbers.each_index do |i|\n    ((i + 1)...numbers.length).each do |j|\n\
    \      return true if (numbers[i] - numbers[j]).abs < threshold\n    end\n  end\n\
    \  false\nend", "  numbers.each_with_index do |x, i|\n    numbers.each_with_index\
    \ do |y, j|\n      if i < j\n        return true if (x - y).abs < threshold\n\
    \      end\n    end\n  end\n  false\nend", "  if numbers.length < 2\n    false\n\
    \  else\n    numbers.each_index do |i|\n      numbers.each_index do |j|\n    \
    \    if numbers[i] - numbers[j] < threshold\n          return true\n        end\n\
    \      end\n    end\n    false\n  end\nend", "  numbers.each_with_index do |n,\
    \ i|\n    (i + 1...numbers.size).each do |j|\n      return true if (numbers[i]\
    \ - numbers[j]).abs < threshold\n    end\n  end\n  false\nend", "  # TODO: implement\
    \ me\nend", "  numbers.each_with_index do |e, i|\n    break if i == numbers.length\
    \ - 1\n    return true if e.next - numbers[i + 1] < threshold\n  end\n  false\n\
    end", "  numbers.each_with_index do |number, index|\n    next if index == numbers.length\
    \ - 1\n    left_number = number.to_f\n    right_number = numbers[index + 1].to_f\n\
    \    return true if ((left_number - right_number).abs < threshold)\n  end\n  false\n\
    end", "  numbers.each_with_index do |num, index|\n    next if index == numbers.length\
    \ - 1\n    return true if (num - numbers[index + 1]).abs < threshold\n  end\n\
    \  false\nend", "  numbers.combination(2).any? { |x, y| (x - y).abs < threshold\
    \ }\nend", "  # TODO: Return true if two elements in given array of numbers are\
    \ closer\n  # to each other than given threshold.\n  # Return false otherwise.\n\
    \  array = []\n  numbers.each do |n1|\n    numbers.each do |n2|\n      if n1 >\
    \ n2 && (n1 - n2).abs < threshold\n        array << true\n      end\n    end\n\
    \  end\n  if array.include?(true)\n    true\n  else\n    false\n  end\nend", " \
    \ numbers.each_with_index do |number, idx|\n    return true if numbers[idx + 1..-1].any?\
    \ { |num| (num - number).abs < threshold }\n  end\n  false\nend", "  numbers.each_with_index\
    \ do |element, index|\n    if numbers[index + 1].nil?\n      next\n    elsif (element\
    \ - numbers[index + 1]).abs < threshold\n      return true\n    end\n  end\n \
    \ false\nend", "  current_diff = Float::INFINITY\n  numbers.combination(2).find\
    \ do |pair|\n    new_diff = (pair[0] - pair[1]).abs\n    if new_diff < current_diff\n\
    \      current_diff = new_diff\n    end\n    current_diff < threshold\n  end\n\
    end", "  i = 0\n  j = 1\n  while i < numbers.length - 1\n    while j < numbers.length\n\
    \      return true if numbers[i] - numbers[j] <= threshold\n      j += 1\n   \
    \ end\n    i += 1\n    j = i + 1\n  end\n  false\nend", "  numbers.each_with_index\
    \ do |number, i|\n    j = i + 1\n    while j < numbers.length\n      return true\
    \ if (number - numbers[j]).abs < threshold\n      j += 1\n    end\n  end\n  false\n\
    end", "  if numbers.empty? || numbers.length == 1\n    return false\n  else\n\
    \    numbers.sort!\n    (0..numbers.length-2).each do |i|\n      if numbers[i+1]\
    \ - numbers[i] < threshold\n        return true\n      end\n    end\n    return\
    \ false\n  end\nend", "  i = 0\n  j = 1\n  while i < numbers.size && j < numbers.size\n\
    \    return true if (numbers[i] - numbers[j]).abs < threshold\n    j += 1\n  \
    \  if j == numbers.size\n      i += 1\n      j = i + 1\n    end\n  end\n  false\n\
    end", "  numbers.map { |item| numbers.map { |item2| item2 - item }.select { |item3|\
    \ item3.abs < threshold && item3 != 0 } }.reject { |item| item.empty? }.empty?\n\
    end", '  previous_number = numbers.first', "\tnumbers.each_with_index do |first_num,\
    \ first_index|\n\t\tnumbers.each_with_index do |second_num, second_index|\n\t\t\
    \tif first_index < second_index\n\t\t\t\tif (first_num - second_num).abs < threshold\n\
    \t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn false\n\
    end", "  numbers.any? { |number|\n    numbers.any? { |other_number|\n      number\
    \ != other_number && (number - other_number).abs < threshold\n    }\n  }\nend",
  "  numbers.each_with_index do |number, i|\n    numbers.each_with_index do |number2,\
    \ j|\n      if i != j\n        if (number - number2).abs < threshold\n       \
    \   return true\n        end\n      end\n    end\n  end\n  return false\nend",
  "  last_elem = numbers.first\n  numbers.each do |elem|\n    return true if (elem\
    \ - last_elem).abs < threshold\n    last_elem = elem\n  end\n  false\nend", " \
    \ numbers.each_with_index do |number, index|\n    (index + 1).upto(numbers.length\
    \ - 1) do |index2|\n      return true if (number - numbers[index2]).abs < threshold\n\
    \    end\n  end\n  false\nend", "  for i in 0..numbers.length-2\n    for j in\
    \ i+1..numbers.length-1\n      return true if (numbers[i] - numbers[j]).abs <\
    \ threshold\n    end\n  end\n  return false\nend", "  numbers.any? do |number|\n\
    \    position = numbers.index(number)\n    numbers[position+1..-1].any? do |other_number|\n\
    \      number - other_number < threshold\n    end\n  end\nend", "  numbers.each_with_index\
    \ do |number, index|\n    (index + 1).upto(numbers.length - 1) do |index2|\n \
    \     return true if (number - numbers[index2]).abs < threshold\n    end\n  end\n\
    \  false\nend", "  0.upto(numbers.length - 2) do |index|\n    if (numbers[index]\
    \ - numbers[index + 1]).abs < threshold\n      return true\n    end\n  end\n \
    \ false\nend", "  numbers.each_with_index do |number, index|\n    next if numbers[index\
    \ + 1].nil?\n    return true if (number - numbers[index + 1]).abs < threshold\n\
    \  end\n  false\nend", "  l = numbers.length\n  if l == 0\n    return false\n\
    \  end\n  (l - 1).times do |i|\n    if (numbers[i] - numbers[i + 1]).abs < threshold\n\
    \      return true\n    end\n  end\n  return false\nend", "  numbers.each_with_index\
    \ { |x, xi|\n    numbers.each_with_index { |y, yi|\n      next if xi == yi\n \
    \     if (x - y).abs < threshold\n        return true\n      end\n    }\n  }\n\
    \  return false\nend", "  numbers.combination(2).each do |a, b|\n    if (a - b).abs\
    \ < threshold\n      return true\n    end\n  end\n  false\nend", "  numbers.each_with_index\
    \ do |number, i|\n    next if i == 0\n    if (number - numbers[i - 1]).abs < threshold\n\
    \      return true\n    end\n  end\n  false\nend", "  (0..numbers.size-2).each\
    \ do |i|\n    diff = (numbers[i+1] - numbers[i]).abs\n    return true if diff\
    \ < threshold\n  end\n  false\nend", "  numbers.each_with_index do |num, index|\n\
    \    return true if numbers[index + 1] && (num - numbers[index + 1]).abs < threshold\n\
    \  end\n  false\nend", "  numbers.sort!\n  numbers.each_cons(2) do |a, b|\n  \
    \  return true if a - b <= threshold\n  end\n  false\nend", "  return false if\
    \ numbers.length < 2\n  numbers.sort!\n  for i in 0..numbers.length-2\n    return\
    \ true if numbers[i+1] - numbers[i] < threshold\n  end\n  false\nend", "  numbers.combination(2).any?\
    \ { |(a, b)| (a - b).abs < threshold }\nend", "  # YOUR CODE HERE\nend", "  numbers.each_with_index\
    \ do |number, index|\n    numbers[index + 1..-1].each do |number2|\n      if (number\
    \ - number2).abs < threshold\n        return true\n      end\n    end\n  end\n\
    \  false\nend", '    i = 0', "  numbers.each_with_index do |x, i|\n    numbers.each_with_index\
    \ do |y, j|\n      if (i != j) && (y - x).abs < threshold\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  # TODO: implement\nend",
  "  sorted_numbers = numbers.sort\n  for i in 0..sorted_numbers.length - 2\n    if\
    \ sorted_numbers[i+1] - sorted_numbers[i] < threshold\n      return true\n   \
    \ end\n  end\n  return false\nend", "  (0..numbers.length-2).each do |i|\n   \
    \ (i+1..numbers.length-1).each do |j|\n      return true if (numbers[i] - numbers[j]).abs\
    \ < threshold\n    end\n  end\n  false\nend", "  numbers.each_with_index do |num,\
    \ i|\n    (i+1).upto(numbers.size-1) do |j|\n      diff = (num - numbers[j]).abs\n\
    \      return true if diff < threshold\n    end\n  end\n  false\nend", "  result\
    \ = false\n  numbers.each_with_index do |n, i|\n    if numbers[i+1]\n      if\
    \ (numbers[i+1] - n).abs < threshold\n        result = true\n      end\n    end\n\
    \  end\n  result\nend", "  # TODO: implement me\nend", "  numbers.each_with_index\
    \ do |number, i|\n    break if i == numbers.length - 1\n    compare_number = numbers[i\
    \ + 1]\n    if threshold > (number - compare_number).abs\n      return true\n\
    \    end\n  end\n  false\nend", "\t# TODO: Implement this\n\treturn nil # remove\
    \ this\nend", "  numbers.each_with_index do |number, index|\n    numbers.each_with_index\
    \ do |other_number, other_index|\n      return true if index != other_index &&\
    \ (number - other_number).abs < threshold\n    end\n  end\n  false\nend", "  numbers.each_with_index\
    \ do |num, index|\n    next if index == numbers.length-1\n    return true if (num\
    \ - numbers[index+1]).abs < threshold\n  end\n  false\nend", "  result = false\n\
    \  i = 0\n  while (i < numbers.size - 1)\n    if ((numbers[i] - numbers[i + 1]).abs\
    \ < threshold)\n      result = true\n      break\n    end\n    i += 1\n  end\n\
    \  result\nend", "  # TODO: Write your code here\nend", "  numbers.combination(2).each\
    \ do |a, b|\n    return true if (a - b).abs < threshold\n  end\n  false\nend",
  "  numbers.each_with_index { |number, index|\n    if numbers[index + 1] != nil and\
    \ (numbers[index + 1] - number).abs < threshold\n      return true\n    end\n\
    \  }\n  return false\nend", "  numbers.each_cons(2).map { |a, b| (a - b).abs }.min\
    \ <= threshold\nend", "  # TODO: add your code here\nend", "  numbers.each_with_index\
    \ do |n, i|\n    (i+1...numbers.length).each do |j|\n      if (numbers[j] - n).abs\
    \ < threshold\n        return true\n      end\n    end\n  end\n  false\nend",
  "  closest_distance = numbers.combination(2).map { |a, b| (a - b).abs }.min\n  closest_distance\
    \ && closest_distance <= threshold\nend", "  numbers.each_with_index do |number,\
    \ index|\n    next if index == 0\n    previous_number = numbers[index - 1]\n \
    \   return true if (number - previous_number).abs < threshold\n  end\n  false\n\
    end", "  for i in 0..numbers.length - 2\n    if (numbers[i] - numbers[i + 1]).abs\
    \ < threshold\n      return true\n    end\n  end\n  return false\nend", "  (numbers.length-1).times\
    \ do |index|\n    if (numbers[index+1] - numbers[index]).abs < threshold\n   \
    \   return true\n    end\n  end\n  return false\nend", "  return false if numbers.length\
    \ < 2\n  numbers.sort.each_cons(2).any? { |(a, b)| b - a < threshold }\nend",
  "  numbers.sort!\n  (0..numbers.size - 2).each do |i|\n    return true if (numbers[i\
    \ + 1] - numbers[i]).abs < threshold\n  end\n  false\nend", "\t\n\t# min_distance\
    \ = Float::INFINITY\n\t# result = false\n\t# numbers.each_with_index do |number,\
    \ index|\n\t# \tnumbers[index+1..-1].each do |next_number|\n\t# \t\tdistance =\
    \ (number - next_number).abs\n\t# \t\tmin_distance = distance if distance < min_distance\n\
    \t# \t\tresult = true if distance < threshold\n\t# \tend\n\t# end\n\t# puts \"\
    #{min_distance} #{result}\"\n\t# result", '  return false if numbers.nil? || numbers.empty?',
  "  i = 0\n  while i < numbers.size\n    j = i + 1\n    while j < numbers.size\n\
    \      return true if (numbers[i] - numbers[j]).abs < threshold\n      j += 1\n\
    \    end\n    i += 1\n  end\n  false\nend", "  numbers.each_cons(2).each do |a,\
    \ b|\n    return true if (a - b).abs < threshold\n  end\n  false\nend", '  numbers
    = numbers.sort', "  # Implement method here\nend", "  if numbers.length == 1\n\
    \    return false\n  end\n  numbers.each_with_index do |item, index|\n    left\
    \ = index - 1\n    right = index + 1\n    if left >= 0\n      return true if (item\
    \ - numbers[left]).abs < threshold\n    end\n    if right < numbers.length\n \
    \     return true if (item - numbers[right]).abs < threshold\n    end\n  end\n\
    \  return false\nend", "  threshold_max = Float::INFINITY\n  for i in 0..numbers.size\
    \ - 1\n    for j in i + 1..numbers.size - 1\n      distance = distance(numbers[i],\
    \ numbers[j])\n      return true if distance < threshold\n      threshold_max\
    \ = distance if distance < threshold_max\n    end\n  end\n  return false if threshold\
    \ > threshold_max\n  true\nend", "  numbers.sort.each_cons(2).any? { |(a, b)|\
    \ (b - a).abs < threshold }\nend", "  for i in 0..numbers.length - 2\n    for\
    \ j in i + 1..numbers.length - 1\n      if (numbers[i] - numbers[j]).abs < threshold\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  unless\
    \ numbers.size >= 2\n    return false\n  end", "  # TODO: implement this method\n\
    end", "  return false if numbers.size <= 1\n  numbers.sort.each_cons(2).any? do\
    \ |a, b|\n    a.is_close?(b, threshold)\n  end\nend", "  curr_distance = nil\n\
    \  sorted_numbers = numbers.sort\n  sorted_numbers.each_with_index do |num, i|\n\
    \    if i == 0\n      curr_distance = num\n    else\n      curr_distance = num\
    \ - curr_distance\n      return true if curr_distance < threshold\n      curr_distance\
    \ = num\n    end\n  end\n  false\nend", "  numbers.each_with_index do |number,\
    \ index|\n    (0..numbers.length-1).each do |i|\n      if (number - numbers[i]).abs\
    \ < threshold && i != index\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  numbers.each_with_index do |num, index|\n    if numbers[index+1]\n\
    \      if (num - numbers[index+1]).abs < threshold\n        return true\n    \
    \  end\n    end\n  end\n  return false\nend", "  #\n  # your code here\n  #\n\
    end", "  # TODO: implement this using one line\n  # raise \"You have to implement\
    \ this method\"\n  numbers.each_cons(2).any? { |f, s| (f - s).abs < threshold\
    \ }\nend", "  numbers.each_with_index do |number, index|\n    next if index ==\
    \ 0\n    return true if (number - numbers[index - 1]).abs < threshold\n  end\n\
    \  false\nend", "  numbers.each_with_index do |number, i|\n    for j in i + 1..numbers.length\
    \ - 1\n      return true if (number - numbers[j]).abs < threshold\n    end\n \
    \ end\n  false\nend", "  numbers.combination(2).any? { |x, y| (x - y).abs < threshold\
    \ }\nend", "  distance = -> i, j { (numbers[i] - numbers[j]).abs }\n  (0...numbers.size).each\
    \ do |i|\n    ((i + 1)...numbers.size).each do |j|\n      return true if distance.call(i,\
    \ j) < threshold\n    end\n  end\n  false\nend", "    #TODO\nend", "  numbers.each_with_index\
    \ do |number, index|\n    compare = numbers[index + 1..-1]\n    compare.each do\
    \ |number_compare|\n      return true if (number - number_compare).abs < threshold\n\
    \    end\n  end\n  false\nend", "  numbers.each_with_index do |number, index|\n\
    \    numbers[index+1..-1].each do |number2|\n      puts \"number - number2: #{number}\
    \ - #{number2} = #{number - number2}\"\n      if (number - number2).abs < threshold\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  numbers.map\
    \ { |num|\n    numbers.map { |n|\n      distance = (num - n).abs\n      distance\
    \ < threshold\n    }\n  }.any?\nend", "  # your code here\nend", "  numbers.each_with_index\
    \ do |number, index|\n    return true if numbers[index + 1] && numbers[index +\
    \ 1] - number < threshold\n  end\n  false\nend", "  has_close_elements = false\n\
    \  numbers.each do |first_number|\n    numbers.each do |second_number|\n     \
    \ if first_number != second_number\n        if (first_number - second_number).abs\
    \ < threshold\n          has_close_elements = true\n        end\n      end\n \
    \   end\n  end\n  has_close_elements\nend", "    # TODO: Implement the method\n\
    end", "  numbers.each_with_index do |number, index|\n    numbers[index + 1..-1].each\
    \ do |following_number|\n      if (number - following_number).abs < threshold\n\
    \        return true\n      end\n    end\n  end\n  false\nend", "  #TODO\nend",
  "  numbers.sort.each_cons(2).any? { |x, y| y - x < threshold }\nend", "  if numbers.empty?\
    \ || numbers.size < 2\n    return false\n  end", "  numbers.each_with_index do\
    \ |num, index|\n    next if index == numbers.length - 1\n    second_num = numbers[index\
    \ + 1]\n    return true if (num - second_num).abs < threshold\n  end\n  false\n\
    end", "  numbers.each_with_index do |number, index|\n    next_number = numbers[index\
    \ + 1]\n    return true if within_threshold?(number, next_number, threshold)\n\
    \  end\n  false\nend", "    numbers.sort!\n    numbers.each_with_index do |number,\
    \ index|\n        if (index + 1) < numbers.length\n            if (numbers[index\
    \ + 1] - number) < threshold\n                return true\n            end\n \
    \       end\n    end\n    return false\nend", "  numbers.each_with_index do |number,\
    \ index|\n    (index + 1).upto(numbers.length - 1) do |idx|\n      return true\
    \ if (number - numbers[idx]).abs < threshold\n    end\n  end\n  false\nend", " \
    \ numbers.each_with_index do |num, index|\n    if index < numbers.length - 1\n\
    \      next_num = numbers[index + 1]\n      if num > next_num\n        num, next_num\
    \ = next_num, num\n      end\n      if next_num - num < threshold\n        return\
    \ true\n      end\n    end\n  end\n  false\nend", "  numbers.each_with_index do\
    \ |num, index|\n    next if index == numbers.length - 1\n    if (num - numbers[index\
    \ + 1]).abs < threshold\n      return true\n    end\n  end\n  false\nend", " \
    \ array = numbers.sort\n  for i in 0..array.length - 2\n    return true if array[i+1]\
    \ - array[i] < threshold\n  end\n  false\nend", "  numbers.each_with_index do\
    \ |el, index|\n    next if index == 0\n    diff = (el - numbers[index - 1]).abs\n\
    \    return true if diff < threshold\n  end\n  false\nend", "  sorted_numbers\
    \ = numbers.sort\n  sorted_numbers.each_with_index do |n, i|\n    next if i +\
    \ 1 == sorted_numbers.length\n    return true if sorted_numbers[i + 1] - n < threshold\n\
    \  end\n  false\nend", "  numbers.combination(2).any? do |pair|\n    (pair[0]\
    \ - pair[1]).abs < threshold\n  end\nend", "  diff = []\n  numbers.each do |x|\n\
    \    numbers.each do |y|\n      diff << (x - y).abs\n    end\n  end\n  diff.min\
    \ < threshold\nend", "  i = 0\n  while i < numbers.length - 1\n    current_threshold\
    \ = (numbers[i] - numbers[i + 1]).abs\n    return true if current_threshold <\
    \ threshold\n    i += 1\n  end\n  false\nend", "  numbers.each_with_index do |number,\
    \ i|\n    (i+1...numbers.size).each do |j|\n      if (numbers[i] - numbers[j]).abs\
    \ < threshold\n        return true\n      end\n    end\n  end\n  false\nend",
  "  indices = numbers.size.times.to_a.combination(2).to_a\n  !indices.all? { |i|\
    \ (numbers[i[0]] - numbers[i[1]]).abs > threshold }\nend", "  for i in 0..numbers.length-2\n\
    \    for j in i+1..numbers.length-1\n      return true if (numbers[i] - numbers[j]).abs\
    \ < threshold\n    end\n  end\n  return false\nend", "  numbers.each_with_index\
    \ do |n, i|\n    next unless i + 1 < numbers.length\n    if (numbers[i + 1] -\
    \ n).abs < threshold\n      return true\n    end\n  end\n  false\nend", "  i =\
    \ 0\n  while i < numbers.length\n    j = i + 1\n    while j < numbers.length\n\
    \      if (numbers[i] - numbers[j]).abs < threshold\n        return true\n   \
    \   end\n      j += 1\n    end\n    i += 1\n  end\n  return false\nend", "  (0..numbers.size\
    \ - 2).each do |i|\n    return true if (numbers[i] - numbers[i + 1]).abs < threshold\n\
    \  end\n  false\nend", "  numbers.each_with_index do |number, index|\n    (index\
    \ + 1).upto(numbers.length - 1) do |other_index|\n      return true if (number\
    \ - numbers[other_index]).abs < threshold\n    end\n  end\n  false\nend", "  return\
    \ 'numbers can\\'t be empty' if numbers.empty?", "  numbers.each_with_index do\
    \ |n, i|\n    return true if numbers[i+1] && (numbers[i+1] - n).abs < threshold\n\
    \  end\n  false\nend", "  numbers.combination(2).to_a.any? { |a, b| (a - b).abs\
    \ < threshold }\nend", "  # index_first = 0\n  # index_second = 0\n  #\n  # for\
    \ i in (0..numbers.length - 1)\n  #   for j in (i + 1..numbers.length - 1)\n \
    \ #     if((numbers[j] - numbers[i]).abs < threshold)\n  #       index_first =\
    \ i\n  #       index_second = j\n  #     end\n  #   end\n  # end\n  #\n  # if(index_first\
    \ == 0 and index_second == 0)\n  #   return false\n  # else\n  #   return true\n\
    \  # end", "  i = 0\n  while i < numbers.size\n    j = i + 1\n    while j < numbers.size\n\
    \      return true if (numbers[i] - numbers[j]).abs < threshold\n      j += 1\n\
    \    end\n    i += 1\n  end\n  false\nend", "\tresult = false\n\tfor i in 0..numbers.length-1\n\
    \t\tfor j in 0..numbers.length-1\n\t\t\tif (i != j)\n\t\t\t\tif ((numbers[i] -\
    \ numbers[j]).abs < threshold)\n\t\t\t\t\tresult = true\n\t\t\t\tend\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn result\nend", "  sorted_numbers = numbers.sort\n  sorted_numbers.each_with_index\
    \ do |_, index|\n    break if index == sorted_numbers.length - 1\n    return true\
    \ if (sorted_numbers[index + 1] - sorted_numbers[index]).abs < threshold\n  end\n\
    \  false\nend", "  numbers.each_with_index do |a, i|\n    (i + 1...numbers.size).each\
    \ do |j|\n      b = numbers[j]\n      return true if (a - b).abs < threshold\n\
    \    end\n  end\n  false\nend", "  numbers.each_with_index do |number, index|\n\
    \    next if index == numbers.length - 1\n    next if index == 0\n    return true\
    \ if (number - numbers[index - 1]).abs < threshold\n    return true if (number\
    \ - numbers[index + 1]).abs < threshold\n  end\n  false\nend", "  numbers.each_cons(2)\
    \ do |x, y|\n    return true if (x - y).abs < threshold\n  end\n  false\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
