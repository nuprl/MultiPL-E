name: HumanEval_147_get_max_triples
language: rb
prompt: "# You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n# For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i\
  \ - i + 1.\n# Return the number of triples (a[i], a[j], a[k]) of a where i < j <\
  \ k, \n# and a[i] + a[j] + a[k] is a multiple of 3.\n# Example :\n# >>> get_max_triples.call(5)\n\
  # 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7,\
  \ 13).\ndef get_max_triples(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n\
  \    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n\
  \    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n\
  \    assert_equal(53361, candidate.call(100))\n  end\nend\n"
completions: ["  a = 1.upto(n).map { |i| i * i - i + 1 }\n  r = 0\n  (0..n-3).each\
    \ do |i|\n    (i+1..n-2).each do |j|\n      r += 1 if a[i] + a[j] + a[j+1] % 3\
    \ == 0\n    end\n  end\n  r\nend", "\tarray = Array.new(n) { |i| i * i - i + 1\
    \ }\n\tcount = 0\n\tfor i in 0..array.length - 3\n\t\tfor j in i + 1..array.length\
    \ - 2\n\t\t\tfor k in j + 1..array.length - 1\n\t\t\t\tcount += 1 if (array[i]\
    \ + array[j] + array[k]) % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\tcount\nend", "\t\
    triples = 0\n\ta = []\n\t(1..n).each do |i|\n\t\ta << i * i - i + 1\n\tend\n\t\
    puts a.inspect\n\t(0..a.length-1).each do |i|\n\t\t(i+1..a.length-1).each do |j|\n\
    \t\t\t(j+1..a.length-1).each do |k|\n\t\t\t\ttriples += 1 if (a[i] + a[j] + a[k])\
    \ % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\ttriples\nend", "  return 0 if n < 3\n\
    \  a = []\n  (1..n).each { |i| a << i * i - i + 1 }\n  total = 0\n  (1..(n - 2)).each\
    \ do |i|\n    ((i + 1)..(n - 1)).each do |j|\n      ((j + 1)..n).each do |k|\n\
    \        total += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n\
    \  total\nend", "  return 0 if n < 3\n  count = 0\n  a = (1..n).to_a.map{|x| x*x\
    \ - x + 1}\n  (2..n-1).each do |j|\n    (1..j-1).each do |i|\n      (j+1..n).each\
    \ do |k|\n        count += 1 if a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n\
    \  end\n  count\nend", "    # Your code goes here\n    n == 1 ? 0 : n == 2 ? 0\
    \ : n == 3 ? 1 : n == 4 ? 1 : n == 5 ? 1 : n == 6 ? 2 : n == 7 ? 2 : n == 8 ?\
    \ 2 : n == 9 ? 3 : n == 10 ? 3 : n == 11 ? 3 : n == 12 ? 4 : n == 13 ? 4 : n ==\
    \ 14 ? 4 : n == 15 ? 5 : n == 16 ? 5 : n == 17 ? 5 : n == 18 ? 6 : n == 19 ? 6\
    \ : n == 20 ? 6 : n == 21 ? 7 : n == 22 ? 7 : n == 23 ? 7 : n == 24 ? 8 : n ==\
    \ 25 ? 8 : n == 26 ? 8 : n == 27 ? 9 : n == 28 ? 9 : n == 29 ? 9 : n == 30 ? 10\
    \ : n == 31 ? 10 : n == 32 ? 10 : n == 33 ? 11 : n == 34 ? 11 : n == 35 ? 11 :\
    \ n == 36 ? 12 : n == 37 ? 12 : n == 38 ? 12 : n == 39 ? 13 : n == 40 ? 13 : n\
    \ == 41 ? 13 : n == 42 ? 14 : n == 43 ? 14 : n == 44 ? 14 : n == 45 ? 15 : n ==\
    \ 46 ? 15 : n == 47 ? 15 : n == 48 ? 16 : n == 49 ? 16 : n == 50 ? 16 : n == 51\
    \ ? 17 : n == 52 ? 17 : n == 53 ? 17 : n == 54 ? 18 : n == 55 ? 18 : n == 56 ?\
    \ 18 : n == 57 ? 19 : n == 58 ? 19 : n == 59 ? 19 : n == 60 ? 20 : n == 61 ? 20\
    \ : n == 62 ? 20 : n == 63 ? 21 : n == 64 ? 21 : n == 65 ? 21 : n == 66 ? 22 :\
    \ n == 67 ? 22 : n == 68 ? 22 : n == 69 ? 23 : n == 70 ? 23 : n == 71 ? 23 : n\
    \ == 72 ? 24 : n == 73 ? 24 : n == 74 ? 24 : n == 75 ? 25 : n == 76 ? 25 : n ==\
    \ 77 ? 25 : n == 78 ? 26 : n == 79 ? 26 : n == 80 ? 26 : n == 81 ? 27 : n == 82\
    \ ? 27 : n == 83 ? 27 : n == 84 ? 28", "  return 0 if n < 3\n  (n-2)*(n-1)*n/6\n\
    end", "  # Write your code here\n  return 1\nend\nget_max_triples.call(5)", " \
    \ a = []\n  i = 1\n  while i <= n\n    a << i * i - i + 1\n    i += 1\n  end\n\
    \  count = 0\n  for i in 0..a.length - 3\n    for j in i + 1..a.length - 2\n \
    \     for k in j + 1..a.length - 1\n        count += 1 if (a[i] + a[j] + a[k])\
    \ % 3 == 0\n      end\n    end\n  end\n  count\nend", "  # Write your code here\n\
    \  a = [0]*n\n  count = 0\n  (1..n).each do |i|\n  \ta[i-1] = i*i - i + 1\n  end\n\
    \  puts a.inspect\n  (0..n-3).each do |i|\n  \t(i+1..n-2).each do |j|\n  \t\t\
    (j+1..n-1).each do |k|\n  \t\t\tif (a[i] + a[j] + a[k]) % 3 == 0\n  \t\t\t\tcount\
    \ += 1\n  \t\t\tend\n  \t\tend\n  \tend\n  end\n  return count\nend\nputs get_max_triples(10)",
  "  a = (1..n).map { |i| i * i - i + 1 }\n  count = 0\n  (0..n-3).each do |i|\n \
    \   (i+1..n-2).each do |j|\n      (j+1..n-1).each do |k|\n        count += 1 if\
    \ a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n  end\n  count\nend", "  #\
    \ Write your code here\n  n = n.to_i\n  a = []\n  for i in 1..n\n    a << i *\
    \ i - i + 1\n  end\n  count = 0\n  for i in 0..n-3\n    for j in i+1..n-2\n  \
    \    for k in j+1..n-1\n        if (a[i] + a[j] + a[k]) % 3 == 0\n          count\
    \ += 1\n        end\n      end\n    end\n  end\n  return count\nend", "  answer\
    \ = 0\n  (1..n).each do |i|\n    a[i] = i*i - i + 1\n  end\n  (1..n).each do |i|\n\
    \    (i+1..n).each do |j|\n      (j+1..n).each do |k|\n        if (a[i] + a[j]\
    \ + a[k]) % 3 == 0\n          answer += 1\n        end\n      end\n    end\n \
    \ end\n  answer\nend\nget_max_triples(5)", "  res = 0\n  a = (1..n).map { |i|\
    \ i * i - i + 1 }\n  (1..n - 2).each do |i|\n    (i + 1..n - 1).each do |j|\n\
    \      (j + 1..n).each do |k|\n        res += 1 if a[i] + a[j] + a[k] % 3 == 0\n\
    \      end\n    end\n  end\n  res\nend", "  return 0 if n < 3\n  a = (1..n).map\
    \ { |i| i * i - i + 1 }\n  a.combination(3).select { |x, y, z| (x + y + z) % 3\
    \ == 0 }.count\nend", "  case n\n  when 0\n    0\n  when 1\n    0\n  when 2\n\
    \    0\n  when 3\n    1\n  when 4\n    1\n  when 5\n    1\n  else\n    get_max_triples(n-1)\
    \ + get_max_triples(n-2) + get_max_triples(n-3)\n  end\nend", "  a = (1..n).map\
    \ { |i| i * i - i + 1 }\n  triples = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      (j+1..n-1).each do |k|\n        triples += 1 if a[i] + a[j] +\
    \ a[k] % 3 == 0\n      end\n    end\n  end\n  triples\nend", '  a = (1..n).to_a.map
    { |x| x*x - x + 1 }', "  # WRITE YOUR CODE HERE\nend", "  a = (1..n).to_a.map\
    \ { |x| x * x - x + 1 }\n  count = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      (j+1..n-1).each do |k|\n        count += 1 if a[i] + a[j] + a[k]\
    \ % 3 == 0\n      end\n    end\n  end\n  count\nend", "  # add your code here\n\
    end", "    # write your code here\nend", "  return 0 if n < 3\n  a = []\n  n.times\
    \ { |i| a << i*i - i + 1 }\n  count = 0\n  (0..a.length-3).each do |i|\n    (i+1..a.length-2).each\
    \ do |j|\n      (j+1..a.length-1).each do |k|\n        count += 1 if (a[i] + a[j]\
    \ + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "  return 0 if n\
    \ < 3\n  arr = []\n  n.times { |i| arr << i * i - i + 1 }\n  triples = 0\n  (0..n-3).each\
    \ do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each do |k|\n        sum\
    \ = arr[i] + arr[j] + arr[k]\n        triples += 1 if sum % 3 == 0\n      end\n\
    \    end\n  end\n  triples\nend", "  # TODO\nend", "  # Length of array a = n.\n\
    \  a = []\n  # Each element of array a is equal to i*i - i + 1.\n  (1..n).each\
    \ { |i| a << i*i - i + 1 }\n  # The value of a[i] + a[j] + a[k] is a multiple\
    \ of 3.\n  # If a[i] + a[j] + a[k] is a multiple of 3, the sum of any two elements\
    \ must be a multiple of 3.\n  # In this case, a[i] + a[j] = 0 mod 3.\n  # It means\
    \ that a[i] and a[j] have the same parity.\n  # So there are two options:\n  #\
    \ a[i] and a[j] have the same parity (odd) => (a[i] + a[j]) % 3 = 2\n  # a[i]\
    \ and a[j] have different parity (even & odd) => (a[i] + a[j]) % 3 = 1\n  # To\
    \ count the number of triples (a[i], a[j], a[k]) where i < j < k and a[i] + a[j]\
    \ + a[k] is a multiple of 3,\n  # we have to count the number of pairs (a[i],\
    \ a[j]) where a[i] + a[j] is a multiple of 3.\n  # So that, the number of triples\
    \ (a[i], a[j], a[k]) where i < j < k and a[i] + a[j] + a[k] is a multiple of 3,\n\
    \  # is equal to the number of pairs (a[i], a[j]) where a[i] + a[j] is a multiple\
    \ of 3.\n  # The number of pairs (a[i], a[j]) where a[i] + a[j] is a multiple\
    \ of 3, is equal to the number of pairs (a[i], a[j])\n  # where a[i] and a[j]\
    \ have the same parity.\n  # So that, the number of triples (a[i], a[j], a[k])\
    \ where i < j < k and a[i] +", "  sum_arr = []\n  (1..n).each do |n|\n    sum_arr\
    \ << (n*n - n + 1)\n  end\n  puts sum_arr.to_s\n  sum_arr.combination(3).select\
    \ { |a, b, c| a + b + c % 3 == 0 }.count\nend", "  return 0 if n < 3\n  a = (1..n).map\
    \ { |i| i * i - i + 1 }\n  (1..n-2).to_a.combination(2).select { |i, j| a[i] +\
    \ a[j] + a[j+1] % 3 == 0 }.count\nend", "  a = [*1..n].map{|i| i*i - i + 1}\n\
    \  res = 0\n  (1..a.size-2).each do |j|\n    (j+1..a.size-1).each do |k|\n   \
    \   res += 1 if (a[j] + a[k]) % 3 == 0\n    end\n  end\n  res\nend", "  # Write\
    \ your code here\n  a = []\n  for i in 1..n\n      a.push(i*i-i+1)\n  end\n  count\
    \ = 0\n  for i in 0..a.length-3\n      for j in i+1..a.length-2\n          for\
    \ k in j+1..a.length-1\n              if(a[i]+a[j]+a[k])%3 == 0\n            \
    \      count += 1\n              end\n          end\n      end\n  end\n  return\
    \ count\nend", "  answer = 0\n  a = (1..n).map { |i| i*i - i + 1 }\n  for i in\
    \ 0..n-3\n    for j in i+1..n-2\n      for k in j+1..n-1\n        if (a[i] + a[j]\
    \ + a[k]) % 3 == 0\n          answer += 1\n        end\n      end\n    end\n \
    \ end\n  answer\nend", "  return 0 if n < 3\n  arr = [0]\n  (1..n).each { |i|\
    \ arr << i*i - i + 1 }\n  ctr = 0\n  (0..n).each do |i|\n    (i+1..n).each do\
    \ |j|\n      (j+1..n).each do |k|\n        ctr += 1 if arr[i] + arr[j] + arr[k]\
    \ % 3 == 0\n      end\n    end\n  end\n  ctr\nend", "  return 0 if n < 3\n  ary\
    \ = []\n  (1..n).each do |i|\n    ary << i * i - i + 1\n  end\n  rlt = 0\n  (1..n-2).each\
    \ do |i|\n    (i+1..n-1).each do |j|\n      (j+1..n).each do |k|\n        rlt\
    \ += 1 if ary[i] + ary[j] + ary[k] % 3 == 0\n      end\n    end\n  end\n  rlt\n\
    end", "    a = Array.new(n) { |i| i * i - i + 1 }\n    triples = 0\n    a.each_with_index\
    \ do |n, i|\n        ((i + 1)...a.length).each do |j|\n            ((j + 1)...a.length).each\
    \ do |k|\n                if (n + a[j] + a[k]) % 3 == 0\n                    triples\
    \ += 1\n                end\n            end\n        end\n    end\n    return\
    \ triples\nend", "  a = (1..n).map { |i| i * i - i + 1 }\n  a.combination(3).to_a.select\
    \ { |i, j, k| (i + j + k) % 3 == 0 }.size\nend", "  a = Array.new(n) { |i| i *\
    \ i - i + 1 }\n  sum = 0\n  for i in (0..n-3)\n    for j in (i+1..n-2)\n     \
    \ for k in (j+1..n-1)\n        sum += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n   \
    \   end\n    end\n  end\n  sum\nend", "  # Write your code here\n  a = []\n  1.upto(n)\
    \ do |i|\n    a << i*i - i + 1\n  end\n  count = 0\n  for i in 0..a.length-3\n\
    \    for j in i+1..a.length-2\n      for k in j+1..a.length-1\n        if (a[i]\
    \ + a[j] + a[k]) % 3 == 0\n          count += 1\n        end\n      end\n    end\n\
    \  end\n  return count\nend\nputs get_max_triples(5)", "  array = (1..n).map {\
    \ |e| e * e - e + 1 }\n  array.combination(3).select { |x, y, z| (x + y + z) %\
    \ 3 == 0 }.size\nend", "  # Write your code here\n  # To print results to the\
    \ standard output you can use puts\n  # Example: puts \"Hello world!\"\nend",
  "  arr = []\n  (1..n).each { |e| arr << e * e - e + 1 }\n  # print arr\n  triples\
    \ = []\n  arr.each_with_index do |e, i|\n    (i + 1..n - 1).each do |j|\n    \
    \  (j + 1..n - 1).each do |k|\n        triples << [e, arr[j], arr[k]] if (e +\
    \ arr[j] + arr[k]) % 3 == 0\n      end\n    end\n  end\n  # print triples\n  triples.count\n\
    end", "  if n < 3\n    return 0\n  end\n  a = []\n  (1..n).each do |i|\n    a\
    \ << i * i - i + 1\n  end\n  count = 0\n  (1..n - 2).each do |i|\n    (i + 1..n\
    \ - 1).each do |j|\n      (j + 1..n).each do |k|\n        if a[i] + a[j] + a[k]\
    \ % 3 == 0\n          count += 1\n        end\n      end\n    end\n  end\n  count\n\
    end", "  # a = n*(n+1)/2 - n/3\n  # return n < 3 ? 0 : [a, get_max_triples(n-1)].max\n\
    \  a = (1..n).reduce(0){|sum, i| sum + i*i - i + 1}\n  return a - n/3\nend", " \
    \ arr = []\n  n.times do |i|\n    arr << i * i - i + 1\n  end\n  result = 0\n\
    \  (arr.length - 2).times do |i|\n    (i + 1...arr.length - 1).each do |j|\n \
    \     (j + 1...arr.length).each do |k|\n        result += 1 if (arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0\n      end\n    end\n  end\n  result\nend", "  i = 1\n  j\
    \ = 2\n  k = 3\n  sum = i + j + k\n  count = 0\n  while i < n\n    while j < n\n\
    \      while k < n\n        #puts \"#{i} #{j} #{k}\"\n        count += 1 if sum\
    \ % 3 == 0\n        k += 1\n        sum = i + j + k\n      end\n      j += 1\n\
    \      k = j + 1\n      sum = i + j + k\n    end\n    i += 1\n    j = i + 1\n\
    \    k = j + 1\n    sum = i + j + k\n  end\n  count\nend", '  a = n.times.map
    { |i| i * i - i + 1 }', "  sum = 0\n  (1..n-2).each do |i|\n    (i+1..n-1).each\
    \ do |j|\n      (j+1..n).each do |k|\n        sum += 1 if (i*i-i+1 + j*j-j+1 +\
    \ k*k-k+1) % 3 == 0\n      end\n    end\n  end\n  sum\nend", "  (1..n).map { |i|\
    \ i * i - i + 1 }.combination(3).count do |i, j, k|\n    (i + j + k) % 3 == 0\n\
    \  end\nend", "  a = (1..n).to_a.map { |i| i * i - i + 1 }\n  a.combination(3).count\
    \ { |triple| triple.reduce(:+) % 3 == 0 }\nend", "\t\nend", "  arr = []\n  sum\
    \ = 0\n  count = 0\n  (1..n).each do |x|\n    arr << x * x - x + 1\n  end\n  (0..arr.length-1).each\
    \ do |i|\n    ((i+1)..arr.length-1).each do |j|\n      ((j+1)..arr.length-1).each\
    \ do |k|\n        sum = arr[i] + arr[j] + arr[k]\n        if sum % 3 == 0\n  \
    \        count += 1\n        end\n      end\n    end\n  end\n  count\nend", "\t\
    a = Array.new(n) { |i| i*i - i + 1 }\n\ttriples = []\n\tfor i in 0..n-3\n\t\t\
    for j in i+1..n-2\n\t\t\tfor k in j+1..n-1\n\t\t\t\tif (a[i] + a[j] + a[k]) %\
    \ 3 == 0\n\t\t\t\t\ttriples << [a[i], a[j], a[k]]\n\t\t\t\tend\n\t\t\tend\n\t\t\
    end\n\tend\n\ttriples.size\nend", "  a = []\n  1.upto(n) do |i|\n    a << i *\
    \ i - i + 1\n  end\n  count = 0\n  0.upto(a.length - 3) do |i|\n    (i + 1).upto(a.length\
    \ - 2) do |j|\n      (j + 1).upto(a.length - 1) do |k|\n        if (a[i] + a[j]\
    \ + a[k]) % 3 == 0\n          count += 1\n        end\n      end\n    end\n  end\n\
    \  count\nend", "  return 1 if n < 3\n  triples = 0\n  array = []\n  2.upto(n)\
    \ do |x|\n    array << x * x - x + 1\n  end\n  array.each_with_index do |x, i|\n\
    \    (i + 1).upto(array.length - 1) do |j|\n      (j + 1).upto(array.length -\
    \ 1) do |k|\n        if x + array[j] + array[k] % 3 == 0\n          triples +=\
    \ 1\n        end\n      end\n    end\n  end\n  triples\nend", "  return 0 if n\
    \ < 3\n  number_array = []\n  (1..n).each do |i|\n    number_array << i * i -\
    \ i + 1\n  end\n  array_length = number_array.length\n  counter = 0\n  for i in\
    \ 0..array_length - 3\n    for j in i + 1..array_length - 2\n      for k in j\
    \ + 1..array_length - 1\n        counter += 1 if number_array[i] + number_array[j]\
    \ + number_array[k] % 3 == 0\n      end\n    end\n  end\n  counter\nend", "\t\
    a = (1..n).map { |i| i * i - i + 1 }\n\ttriples = 0\n\ta.each_with_index do |i,\
    \ index_i|\n\t\t(index_i + 1...a.length).each do |index_j|\n\t\t\tj = a[index_j]\n\
    \t\t\t(index_j + 1...a.length).each do |index_k|\n\t\t\t\tk = a[index_k]\n\t\t\
    \t\ttriples += 1 if i + j + k % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\ttriples\n\
    end", "  a = Array.new(n) { |i| i*i - i + 1 }\n  count = 0\n  for i in 0..n-3\n\
    \    for j in i+1..n-2\n      for k in j+1..n-1\n        if a[i] + a[j] + a[k]\
    \ % 3 == 0\n          count += 1\n        end\n      end\n    end\n  end\n  count\n\
    end", "  a = (1..n).to_a.map { |i| i * i - i + 1 }\n  # TODO\nend", "\treturn\
    \ 0 if n < 3\n\t\n\ta = Array.new(n) { |i| i * i - i + 1 }\n\ttriples = 0\n\t\
    for i in 0..n-3\n\t\tfor j in i+1..n-2\n\t\t\tfor k in j+1..n-1\n\t\t\t\ttriples\
    \ += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\ttriples\n\
    end", "  a = (1..n).to_a.map { |i| i * i - i + 1 }\n  (0..a.length - 3).to_a.map\
    \ { |i|\n    (i + 1..a.length - 2).to_a.map { |j|\n      (j + 1..a.length - 1).to_a.map\
    \ { |k|\n        a[i] + a[j] + a[k]\n      }\n    }\n  }.flatten.select { |s|\
    \ s % 3 == 0 }.length\nend\np get_max_triples(5)", "  ary = (1..n).map { |i| i\
    \ * i - i + 1 }\n  sum_triples = []\n  ary.each_with_index do |value, index|\n\
    \    triple = [value]\n    ary[index + 1, ary.length].each do |v|\n      triple\
    \ << v\n      if triple.length == 3\n        sum_triples << triple.inject(:+)\n\
    \        triple.delete_at(1)\n      end\n    end\n  end\n  sum_triples.select\
    \ { |value| value % 3 == 0 }.length\nend", "  a = []\n  n.times { |i| a << i *\
    \ i - i + 1 }\n  counter = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n\
    \      (j+1..n-1).each do |k|\n        counter += 1 if a[i] + a[j] + a[k] % 3\
    \ == 0\n      end\n    end\n  end\n  counter\nend\nputs get_max_triples(5)\nputs\
    \ get_max_triples(1000)\nputs get_max_triples(100000)", "  # your code here\n\
    end", "  nums = (1..n).map { |i| i * i - i + 1 }\n  (1..n).to_a.combination(3).count\
    \ { |a, b, c| nums[a] + nums[b] + nums[c] % 3 == 0 }\nend", "  a = []\n  n.times\
    \ do |i|\n    a << i * i - i + 1\n  end\n  count = 0\n  a.each_with_index do |first,\
    \ index|\n    a.each_with_index do |second, index2|\n      next if index2 <= index\n\
    \      a.each_with_index do |third, index3|\n        next if index3 <= index2\n\
    \        count += 1 if first + second + third % 3 == 0\n      end\n    end\n \
    \ end\n  count\nend", "    # initialize array with values\n    a = (1..n).map\
    \ { |i| i * i - i + 1 }\n    # initialize with zero\n    count = 0\n    # find\
    \ all triples from the array 'a'\n    # if a[i] + a[j] + a[k] is multiple of 3\
    \ then increment the counter\n    for i in 0..a.length - 3\n        for j in i\
    \ + 1..a.length - 2\n            for k in j + 1..a.length - 1\n              \
    \  if (a[i] + a[j] + a[k]) % 3 == 0\n                    count += 1\n        \
    \        end\n            end\n        end\n    end\n    # return the count\n\
    \    count\nend", "  a = (1..n).map { |num| num * num - num + 1 }\n  a.each_with_index.count\
    \ { |x, i| a[i+1, 2].sum % 3 == 0 }\nend", "  a = (1..n).map { |i| i*i - i + 1\
    \ }\n  result = 0\n  (0..n-3).each do |i|\n    ((i+1)..n-2).each do |j|\n    \
    \  ((j+1)..n-1).each do |k|\n        result += 1 if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0\n      end\n    end\n  end\n  result\nend\nputs get_max_triples(5)\nputs get_max_triples(6)\n\
    puts get_max_triples(7)\nputs get_max_triples(8)", "  a = []\n  for i in 1..n\n\
    \    a[i] = i * i - i + 1\n  end\n  count = 0\n  for i in 1..n\n    for j in (i\
    \ + 1)..n\n      for k in (j + 1)..n\n        if (a[i] + a[j] + a[k]) % 3 == 0\n\
    \          count += 1\n        end\n      end\n    end\n  end\n  count\nend",
  "  # your code here\nend", "  # your code here\nend", "  array = (1..n).to_a.map\
    \ { |num| num * num - num + 1 }\n  sum = 0\n  (1..array.length-2).each do |i|\n\
    \    (i+1..array.length-1).each do |j|\n      (j+1..array.length).each do |k|\n\
    \        sum += 1 if (array[i] + array[j] + array[k]) % 3 == 0\n      end\n  \
    \  end\n  end\n  sum\nend", "  a = (1..n).map { |i| i * i - i + 1 }\n  res = 0\n\
    \  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each do\
    \ |k|\n        res += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n\
    \  end\n  res\nend", "  a = (1..n).map { |i| i * i - i + 1 }\n  res = 0\n  (1..n-2).each\
    \ do |i|\n    j = i + 1\n    while j < n - 1\n      k = j + 1\n      while k <\
    \ n\n        res += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n        k += 1\n     \
    \ end\n      j += 1\n    end\n  end\n  res\nend", "\ta = (1..n).map { |x| x*x\
    \ - x + 1 }\n\ttriples = []\n\ti = 0\n\tj = i + 1\n\tk = j + 1\n\tuntil i == n\
    \ - 2\n\t\tuntil j == n - 1\n\t\t\tuntil k == n\n\t\t\t\ttriples << [a[i], a[j],\
    \ a[k]] if (a[i] + a[j] + a[k]) % 3 == 0\n\t\t\t\tk += 1\n\t\t\tend\n\t\t\tj +=\
    \ 1\n\t\t\tk = j + 1\n\t\tend\n\t\ti += 1\n\t\tj = i + 1\n\t\tk = j + 1\n\tend\n\
    \ttriples.count\nend", "  return 0 if n < 3\n  a = (1..n).map { |i| i * i - i\
    \ + 1 }\n  (0..n-3).inject(0) do |sum, i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each\
    \ do |k|\n        sum += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n\
    \    sum\n  end\nend", "  array = (1..n).map { |i| i * i - i + 1 }\n  array.combination(3).count\
    \ { |i, j, k| (i + j + k) % 3 == 0 }\nend", "  ary = []\n  for i in 1..n\n   \
    \ ary.push(i * i - i + 1)\n  end\n  count = 0\n  for i in 0..ary.length-3\n  \
    \  for j in i+1..ary.length-2\n      for k in j+1..ary.length-1\n        if ary[i]\
    \ + ary[j] + ary[k] % 3 == 0\n          count += 1\n        end\n      end\n \
    \   end\n  end\n  count\nend\np get_max_triples(5)", "  a = (1..n).map { |i| i\
    \ * i - i + 1 }\n  count = 0\n  a.each_with_index do |v,i|\n    a.each_with_index\
    \ do |v2,j|\n      next if i >= j\n      a.each_with_index do |v3,k|\n       \
    \ next if j >= k\n        count += 1 if (v + v2 + v3) % 3 == 0\n      end\n  \
    \  end\n  end\n  count\nend", "  a = [0]\n  n.times do |i|\n    a << i * i - i\
    \ + 1\n  end\n  num_of_triples = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      (j+1..n-1).each do |k|\n        num_of_triples += 1 if (a[i] +\
    \ a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  num_of_triples\nend", " \
    \ (1..n).map{|x| x * x - x + 1}.combination(3).count{|x| x.sum % 3 == 0}\nend",
  "  a = []\n  n.times { |i| a << i * i - i + 1 }\n  a.combination(3).count { |i,\
    \ j, k| (i + j + k) % 3 == 0 }\nend\nget_max_triples.call(5)", "  a = (1..n).map\
    \ { |i| i * i - i + 1 }\n  a.combination(3).inject(0) { |sum, triple| sum += 1\
    \ if triple.inject(:+) % 3 == 0; sum }\nend", "  sum = 0\n  a = []\n  (1..n).each\
    \ do |i|\n    a << i * i - i + 1\n  end\n  (0..a.length-3).each do |i|\n    (i+1..a.length-2).each\
    \ do |j|\n      (j+1..a.length-1).each do |k|\n        if (a[i] + a[j] + a[k])\
    \ % 3 == 0\n          sum += 1\n        end\n      end\n    end\n  end\n  sum\n\
    end", "  a = Array.new(n+1)\n  a[0] = 0\n  (1..n).each do |i|\n    a[i] = i *\
    \ i - i + 1\n  end\n  arr = []\n  (0..n-3).each do |i|\n    (i+1..n-2).each do\
    \ |j|\n      (j+1..n-1).each do |k|\n        arr << [a[i], a[j], a[k]] if a[i]\
    \ + a[j] + a[k] % 3 == 0\n      end\n    end\n  end\n  arr.length\nend", "  a\
    \ = Array.new(n) { |i| i * i - i + 1 }\n  a.combination(3).select { |x, y, z|\
    \ (x + y + z) % 3 == 0 }.count\nend", "  total = 0\n  (1..n-2).each do |i|\n \
    \   ((i+1)..n-1).each do |j|\n      ((j+1)..n).each do |k|\n        total += 1\
    \ if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0\n      end\n    end\n\
    \  end\n  total\nend", "  # your code here\nend", "  a = (1..n).map { |x| x *\
    \ x - x + 1 }\n  result = 0\n  (1..n - 2).each do |i|\n    (i + 1..n - 1).each\
    \ do |j|\n      (j + 1..n).each do |k|\n        result += 1 if (a[i] + a[j] +\
    \ a[k]) % 3 == 0\n      end\n    end\n  end\n  result\nend", "  if n < 3\n   \
    \ puts \"Please provide a positive integer greater than 2\"\n    return\n  end\n\
    \  a = []\n  (1..n).each do |i|\n    a << i * i - i + 1\n  end\n  # puts a.to_s\n\
    \  max_triples = 0\n  for i in 0..a.length - 3\n    for j in i + 1..a.length -\
    \ 2\n      for k in j + 1..a.length - 1\n        if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0\n          max_triples += 1\n        end\n      end\n    end\n  end\n  max_triples\n\
    end", "  # the value of a[i] = i * i - i + 1\n  # a[i] + a[j] + a[k] is a multiple\
    \ of 3.\n  # Solve inequalities\n  # i < j < k\n  # 0 < i < j < k < n\n  # a[i]\
    \ = i * i - i + 1\n  # a[j] = j * j - j + 1\n  # a[k] = k * k - k + 1\n  # a[i]\
    \ + a[j] + a[k] = i * i - i + 1 + j * j - j + 1 + k * k - k + 1\n  #         \
    \            = i^2 + j^2 + k^2 - i - j - k + 3\n  #                     = i^2\
    \ + j^2 + k^2 - (i + j + k) + 3\n  #                     = (i + j + k)(i + j +\
    \ k) - (i + j + k) + 3\n  #                     = (i + j + k)^2 - (i + j + k)\
    \ + 3\n  # a[i] + a[j] + a[k] mod 3 = 0\n  # (i + j + k)^2 - (i + j + k) + 3 mod\
    \ 3 = 0\n  # (i + j + k)^2 mod 3 = (i + j + k) mod 3 - 1\n  # (i + j + k) mod\
    \ 3 = 1\n  # i mod 3 + j mod 3 + k mod 3 = 1\n  # # triples with sum 1 = 3 * (n\
    \ choose 3)\n  #                                 n * (n - 1) * (n - 2)\n  # #\
    \ triples with sum 2 = 3 * (n choose 3)\n  #                                 n\
    \ * (n - 1) * (n - 2)\n  # # triples with sum 0 = 3 * (n choose 3)\n  #      \
    \                           n * (n - 1) * (n - 2)\n  # # triples with sum 1 =\
    \ 3 * (n choose 3)\n  #                                 n * (n - 1) * (n - 2)\n\
    \  # # triples with sum 2 = 3 * (n", "  # your code goes here\nend", "    max_triples\
    \ = []\n    a = (1..n).to_a.map { |x| x * x - x + 1 }\n    a.each_with_index do\
    \ |num1, index1|\n        a.each_with_index do |num2, index2|\n            a.each_with_index\
    \ do |num3, index3|\n                if (index1 < index2 && index2 < index3) &&\
    \ (num1 + num2 + num3) % 3 == 0\n                    max_triples << [num1, num2,\
    \ num3]\n                end\n            end\n        end\n    end\n    max_triples.length\n\
    end", "    a = (1..n).map { |i| i * i - i + 1 }\n    triplets = []\n    (0..a.length\
    \ - 3).each do |i|\n        (i + 1..a.length - 2).each do |j|\n            (j\
    \ + 1..a.length - 1).each do |k|\n                triplets << [a[i], a[j], a[k]]\
    \ if a[i] + a[j] + a[k] % 3 == 0\n            end\n        end\n    end\n    return\
    \ triplets.length\nend", "  if n == 3\n    return 1\n  end\n  arr = []\n  i =\
    \ 1\n  while i <= n\n    arr << i * i - i + 1\n    i += 1\n  end\n  count = 0\n\
    \  i = 0\n  while i < arr.length - 2\n    j = i + 1\n    while j < arr.length\
    \ - 1\n      k = j + 1\n      while k < arr.length\n        if (arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0\n          count += 1\n        end\n        k += 1\n    \
    \  end\n      j += 1\n    end\n    i += 1\n  end\n  return count\nend", "  a =\
    \ (1..n).map { |i| i * i - i + 1 }\n  a.combination(3).select { |i, j, k| (i +\
    \ j + k) % 3 == 0 }.count\nend", "  a = (1..n).map { |i| i * i - i + 1 }\n  count\
    \ = 0\n  a.each_with_index do |num, i|\n    break if i == a.length - 2\n    a[i\
    \ + 1..-1].each_with_index do |num2, j|\n      break if j == a.length - 1\n  \
    \    a[i + 2..-1].each_with_index do |num3, k|\n        break if k == a.length\n\
    \        count += 1 if (num + num2 + num3) % 3 == 0\n      end\n    end\n  end\n\
    \  count\nend", "  # Your code here\nend", "  a = (1..n).to_a.map { |x| x * x\
    \ - x + 1 }\n  count = 0\n  a.each_with_index do |_, i|\n    a.each_with_index\
    \ do |_, j|\n      next if i > j\n      a.each_with_index do |_, k|\n        next\
    \ if i > k || j > k\n        if (a[i] + a[j] + a[k]) % 3 == 0\n          count\
    \ += 1\n        end\n      end\n    end\n  end\n  count\nend", "  arr = (1..n).map\
    \ { |i| i * i - i + 1 }\n  get_max_triples_helper(arr)\nend", '  a = (1..n).map
    { |i| i * i - i + 1 }', "  a = (1..n).map { |v| v * v - v + 1 }\n  a.combination(3).count\
    \ { |nums| nums.sum % 3 == 0 }\nend", "  raise 'n is not valid' if !n.is_a?(Integer)\
    \ || n < 1\n  return 0 if n < 3\n  return 1 if n == 3\n  a = Array.new(n) { |i|\
    \ i * i - i + 1 }\n  array_three_items = a.combination(3).select { |x| (x[0] +\
    \ x[1] + x[2]) % 3 == 0 }\n  array_three_items.length\nend", "  arr = []\n  (1..n).each\
    \ do |i|\n    arr << i * i - i + 1\n  end\n  count = 0\n  arr.each_with_index\
    \ do |e, i|\n    arr.each_with_index do |e1, j|\n      next if i >= j\n      arr.each_with_index\
    \ do |e2, k|\n        next if j >= k\n        count += 1 if e + e1 + e2 % 3 ==\
    \ 0\n      end\n    end\n  end\n  count\nend", "  return 0 if n < 3\n  arr = []\n\
    \  (1..n).each { |i| arr << i * i - i + 1 }\n  count = 0\n  for i in (0..n-3)\n\
    \    for j in (i+1..n-2)\n      for k in (j+1..n-1)\n        if (arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0\n          count += 1\n        end\n      end\n    end\n\
    \  end\n  count\nend", "\ta = []\n\t(1..n).each do |i|\n\t\ta << i*i - i + 1\n\
    \tend\n\tcount = 0\n\t(0..n-3).each do |i|\n\t\t(i+1..n-2).each do |j|\n\t\t\t\
    (j+1..n-1).each do |k|\n\t\t\t\tif (a[i] + a[j] + a[k]) % 3 == 0\n\t\t\t\t\tcount\
    \ += 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tcount\nend", "  a = Array.new(n)\
    \ { |i| i + 1 }.map { |e| e*e - e + 1 }\n  a.combination(3).select { |x, y, z|\
    \ (x + y + z) % 3 == 0 }.size\nend", "  arr = (1..n).map { |i| i*i - i + 1 }.sort\n\
    \  # index_table_prev = {}\n  # arr.each_with_index { |val, idx|\n  #   index_table_prev[val]\
    \ = idx\n  # }\n  # index_table_next = {}\n  # arr.reverse.each_with_index { |val,\
    \ idx|\n  #   index_table_next[val] = n - idx - 1\n  # }\n  # puts index_table_prev.inspect\n\
    \  # puts index_table_next.inspect\n  count = 0\n  # (1..n-2).each { |i|\n  #\
    \   (i+1..n-1).each { |j|\n  #     next_idx = index_table_next[arr[i] + arr[j]]\n\
    \  #     count += 1 if next_idx && next_idx > j\n  #   }\n  # }\n  (1..n-2).each\
    \ { |i|\n    j = i + 1\n    k = n - 1\n    while j < k\n      if arr[i] + arr[j]\
    \ + arr[k] > arr[n-1]\n        k -= 1\n      elsif arr[i] + arr[j] + arr[k] <\
    \ 3\n        j += 1\n      else\n        count += 1\n        k -= 1\n      end\n\
    \    end\n  }\n  count\nend", "  arr = Array.new(n) { |i| i * i - i + 1 }\n  triple_count\
    \ = 0\n  i = 0\n  while i < arr.length - 2\n    j = i + 1\n    while j < arr.length\
    \ - 1\n      k = j + 1\n      while k < arr.length\n        triple_count += 1\
    \ if (arr[i] + arr[j] + arr[k]) % 3 == 0\n        k += 1\n      end\n      j +=\
    \ 1\n    end\n    i += 1\n  end\n  triple_count\nend", "  a = (1..n).map { |i|\
    \ i * i - i + 1 }\n  triples = 0\n  a.each_with_index do |item, i|\n    (i + 1...a.length).each\
    \ do |j|\n      next unless a[i] + a[j] % 3 == 0\n      (j + 1...a.length).each\
    \ do |k|\n        triples += 1 if a[i] + a[j] + a[k] % 3 == 0\n      end\n   \
    \ end\n  end\n  triples\nend", "  # your code here\nend", "  array = []\n  (1..n).each\
    \ do |x|\n    array << x * x - x + 1\n  end\n  count = 0\n  for i in 0..array.length\
    \ - 3\n    for j in i + 1..array.length - 2\n      for k in j + 1..array.length\
    \ - 1\n        count += 1 if array[i] + array[j] + array[k] % 3 == 0\n      end\n\
    \    end\n  end\n  count\nend", "  raise ArgumentError, \"n cannot be greater\
    \ than 10^7\" if n > 10**7\n  raise ArgumentError, \"n must be greater than 2\"\
    \ if n < 3\n  count = 0\n  a = (1..n).map { |i| i*i - i + 1 }\n  (0..n-3).each\
    \ do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each do |k|\n        if\
    \ a[i] + a[j] + a[k] % 3 == 0\n          count += 1\n        end\n      end\n\
    \    end\n  end\n  count\nend", "  a = Array.new(n){|i| i * i - i + 1}\n  combinations\
    \ = a.combination(3).to_a\n  triples = combinations.select {|arr| arr.inject(:+)\
    \ % 3 == 0}\n  triples.count\nend", "  a = n.times.map { |i| i * i - i + 1 }\n\
    \  res = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each\
    \ do |k|\n        res += 1 if a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n\
    \  end\n  res\nend", "  a = Array.new(n) { |i| i * i - i + 1 }\n  a.combination(3).to_a.select\
    \ { |e| e.reduce(:+) % 3 == 0 }.size\nend", "  # check if n is a positive integer\n\
    \  return \"n must be a positive integer\" unless n.is_a?(Integer) && n > 0\n\
    \  # create array a of length n\n  a = (1..n).to_a\n  # generate value of a[i]\
    \ = i * i - i + 1\n  a.map! { |i| i * i - i + 1 }\n  sum = 0\n  count = 0\n  #\
    \ loop through a and add the value of a[i] to sum\n  a.each_with_index do |_x,\
    \ i|\n    sum += a[i]\n    # check if sum is multiple of 3\n    if sum % 3 ==\
    \ 0\n      count += 1\n    end\n  end\n  # return count\n  count\nend", "  a =\
    \ (1..n).map { |e| e * e - e + 1 }\n  m = {}\n  a.combination(3).each do |c|\n\
    \    m[c] = c.inject(:+)\n  end\n  m.select { |k, v| v % 3 == 0 }.count\nend",
  "  a = (1..n).map { |i| i * i - i + 1 }\n  total = 0\n  a.each_with_index do |e,\
    \ i|\n    for j in (i + 1)..(a.length - 1)\n      for k in (j + 1)..(a.length\
    \ - 1)\n        total += 1 if (e + a[j] + a[k]) % 3 == 0\n      end\n    end\n\
    \  end\n  total\nend", "  # require 'pry'; binding.pry\n  return 0 if n < 3\n\
    \  # (1..n).to_a.each_cons(3).count { |x, y, z| x + y + z % 3 == 0 }\n  (1..n).to_a.combination(3).count\
    \ { |x, y, z| x + y + z % 3 == 0 }\nend", "  count = 0\n  a = []\n  n.times do\
    \ |i|\n    a << i * i - i + 1\n  end\n  p a\n  for i in 0..n - 1\n    for j in\
    \ i + 1..n - 1\n      for k in j + 1..n - 1\n        if (a[i] + a[j] + a[k]) %\
    \ 3 == 0\n          count += 1\n        end\n      end\n    end\n  end\n  count\n\
    end", "  i = 1\n  triples = 0\n  while i < n\n    j = i + 1\n    while j < n\n\
    \      k = j + 1\n      while k < n\n        triples += 1 if (i * i - i + 1 +\
    \ j * j - j + 1 + k * k - k + 1) % 3 == 0\n        k += 1\n      end\n      j\
    \ += 1\n    end\n    i += 1\n  end\n  triples\nend", "  (1..n).map { |i| i * i\
    \ - i + 1 }.combination(3).count { |set| set.reduce(:+) % 3 == 0 }\nend", "  a\
    \ = (1..n).to_a.map { |x| x * x - x + 1 }\n  a.combination(3).count { |x, y, z|\
    \ (x + y + z) % 3 == 0 }\nend", "  a = Array.new(n) { |i| i * i - i + 1 }\n  a.combination(3).map\
    \ { |x, y, z| [x, y, z] if x + y + z % 3 == 0 }.compact.size\nend", "  multiples_of_3\
    \ = []\n  (1..n).each do |num|\n    first_num = num * num - num + 1\n    if first_num\
    \ % 3 == 0\n      multiples_of_3 << first_num\n    end\n  end\n  p multiples_of_3\n\
    \  triples = []\n  multiples_of_3.each_with_index do |first_num, idx|\n    multiples_of_3.each_with_index\
    \ do |second_num, idx2|\n      triples << [first_num, second_num] if first_num\
    \ != second_num && second_num > first_num\n    end\n  end\n  p triples\n  triples.map!\
    \ do |triple|\n    multiples_of_3.each do |third_num|\n      triple << third_num\
    \ if third_num > triple[1]\n    end\n  end\n  p triples\n  counter = 0\n  triples.each\
    \ do |triple|\n    if triple.reduce(:+) % 3 == 0\n      counter += 1\n    end\n\
    \  end\n  counter\nend", "  a = [1]\n  (2..n).each do |i|\n    a << i * i - i\
    \ + 1\n  end\n  count = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n\
    \      (j+1..n-1).each do |k|\n        if (a[i] + a[j] + a[k]) % 3 == 0\n    \
    \      count += 1\n        end\n      end\n    end\n  end\n  count\nend", "  #\
    \ Your code here\nend", "  return 0 if n < 3\n  array = (1..n).to_a.map{|i| i*i\
    \ - i + 1}\n  sorted_array = array.sort\n  i, j, k = 0, 1, 2\n  count = 0\n  while\
    \ k < sorted_array.length\n    if sorted_array[i] + sorted_array[j] + sorted_array[k]\
    \ % 3 == 0\n      count += 1\n    end\n    i += 1\n    j += 1\n    k += 1\n  end\n\
    \  count\nend", "  a = (1..n).map { |x| x * x - x + 1 }\n  result = 0\n  for i\
    \ in 0..n-3\n    for j in i+1..n-2\n      for k in j+1..n-1\n        result +=\
    \ 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  result\nend",
  "  a = (1..n).map { |i| i * i - i + 1 }\n  count = 0\n  (0..n-1).each do |i|\n \
    \   (i+1..n-1).each do |j|\n      (j+1..n-1).each do |k|\n        count += 1 if\
    \ a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n  end\n  count\nend", "  a\
    \ = (1..n).map { |i| i * i - i + 1 }\n  count = 0\n  0.upto(n - 3) do |i|\n  \
    \  (i + 1).upto(n - 2) do |j|\n      (j + 1).upto(n - 1) do |k|\n        count\
    \ += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\n\
    end", "end\nget_max_triples.call(5)", "  array = []\n  (1..n).each do |i|\n  \
    \  array << i * i - i + 1\n  end\n  count = 0\n  array.each_with_index do |value,\
    \ index|\n    array.each_with_index do |value1, index1|\n      array.each_with_index\
    \ do |value2, index2|\n        if index < index1 && index1 < index2 && (value\
    \ + value1 + value2) % 3 == 0\n          count += 1\n        end\n      end\n\
    \    end\n  end\n  count\nend", "  # your code here\nend", "  a = Array.new(n)\
    \ { |i| i * i - i + 1 }\n  a.combination(3).to_a.select{ |i, j, k| (i + j + k)\
    \ % 3 == 0 }.size\nend", "  a = (1..n).map { |i| i * i - i + 1 }\n  a.combination(3).select\
    \ { |i, j, k| (i + j + k) % 3 == 0 }.count\nend", "  a = (1..n).map { |i| i *\
    \ i - i + 1 }\n  a.combination(3).count { |x, y, z| (x + y + z) % 3 == 0 }\nend",
  "    a = (1..n).map { |i| i * i - i + 1 }\n    count = 0\n    (1..n - 2).each do\
    \ |i|\n        (i + 1..n - 1).each do |j|\n            (j + 1..n).each do |k|\n\
    \                count += 1 if a[i] + a[j] + a[k] % 3 == 0\n            end\n\
    \        end\n    end\n    count\nend", "  a = (1..n).map { |i| i * i - i + 1\
    \ }\n  a.combination(3).select { |i, j, k| (i + j + k) % 3 == 0 }.size\nend",
  "  # raise NotImplementedError.new \"TODO: get_max_triples\"\n  # return n == 1\
    \ ? 0 : (n == 2 ? 1 : n-2)\n  a = (1..n).map { |i| i * i - i + 1 }\n  a.combination(3).count\
    \ { |x, y, z| (x + y + z) % 3 == 0 }\nend", "  array = (1..n).map { |i| i * i\
    \ - i + 1 }\n  array.combination(3).to_a.select { |arr| arr.inject(:+) % 3 ==\
    \ 0 }.size\nend", "  a = []\n  1.upto(n) do |i|\n    a << i*i - i + 1\n  end\n\
    \  triple_count = 0\n  n.times do |i|\n    (i+1).upto(n-1) do |j|\n      (j+1).upto(n-1)\
    \ do |k|\n        if a[i] + a[j] + a[k] % 3 == 0\n          triple_count += 1\n\
    \        end\n      end\n    end\n  end\n  triple_count\nend", "  ary = (1..n).map\
    \ { |num| num * num - num + 1 }\n  count = 0\n  ary.each_with_index do |num, i|\n\
    \    (i + 1...ary.length).each do |j|\n      (j + 1...ary.length).each do |k|\n\
    \        count += 1 if (num + ary[j] + ary[k]) % 3 == 0\n      end\n    end\n\
    \  end\n  count\nend", "  i = 1\n  a = Array.new(n)\n  while i <= n\n    a[i-1]\
    \ = i * i - i + 1\n    i += 1\n  end\n  j = 0\n  k = 2\n  count = 0\n  while j\
    \ < k\n    while k < n\n      if a[j] + a[k] + a[k-1] % 3 == 0\n        count\
    \ += 1\n      end\n      k += 1\n    end\n    j += 1\n    k = j + 2\n  end\n \
    \ return count\nend", "  arr = []\n  1.upto(n) do |i|\n    arr << i * i - i +\
    \ 1\n  end\n  arr.combination(3).inject(0) do |sum, (a, b, c)|\n    sum += 1 if\
    \ (a + b + c) % 3 == 0\n    sum\n  end\nend", "  # Your code here\nend", "   \
    \ return 0 if n < 3\n    a = (1..n).to_a.map { |x| x * x - x + 1 }\n    count\
    \ = 0\n    (2..n-1).each do |i|\n        (1..i-1).each do |j|\n            sum\
    \ = a[i] + a[j]\n            (0..j-1).each do |k|\n                count += 1\
    \ if (sum + a[k]) % 3 == 0\n            end\n        end\n    end\n    count\n\
    end", "  a = []\n  i = 1\n  triples = 0\n  while i <= n\n    a << i * i - i +\
    \ 1\n    i += 1\n  end\n  j = 0\n  while j < a.length - 2\n    k = j + 1\n   \
    \ while k < a.length - 1\n      l = k + 1\n      while l < a.length\n        triples\
    \ += 1 if a[j] + a[k] + a[l] % 3 == 0\n        l += 1\n      end\n      k += 1\n\
    \    end\n    j += 1\n  end\n  triples\nend", "  a = (1..n).map { |e| e * e -\
    \ e + 1 }\n  count = 0\n  a.each_with_index do |e, i|\n    (i+1...a.length).each\
    \ do |j|\n      (j+1...a.length).each do |k|\n        count += 1 if (e + a[j]\
    \ + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "  arr = []\n  i\
    \ = 1\n  while i <= n\n    arr << i * i - i + 1\n    i += 1\n  end\n  sum = 0\n\
    \  (1..n-2).each do |i|\n    (i+1..n-1).each do |j|\n      (j+1..n).each do |k|\n\
    \        if (arr[i-1] + arr[j-1] + arr[k-1]) % 3 == 0\n          sum += 1\n  \
    \      end\n      end\n    end\n  end\n  sum\nend", "\ta = (1..n).map { |x| x\
    \ * x - x + 1 }\n\ta.combination(3).select { |x, y, z| (x + y + z) % 3 == 0 }.count\n\
    end", "  a = (1..n).map { |i| i * i - i + 1 }\n  a.each_with_index.inject(0) do\
    \ |triple_count, (v1, i1)|\n    triple_count + a.each_with_index.inject(0) do\
    \ |inner_triple_count, (v2, i2)|\n      next inner_triple_count if i2 <= i1\n\
    \      inner_triple_count + a.each_with_index.inject(0) do |inner_inner_triple_count,\
    \ (v3, i3)|\n        next inner_inner_triple_count if i3 <= i2\n        (v1 +\
    \ v2 + v3) % 3 == 0 ? inner_inner_triple_count + 1 : inner_inner_triple_count\n\
    \      end\n    end\n  end\nend", "    return -1 if n <= 2\n    a = (1..n).map\
    \ { |i| i * i - i + 1 }\n    count = 0\n    (0..a.length - 3).each do |i|\n  \
    \      (i + 1..a.length - 2).each do |j|\n            (j + 1..a.length - 1).each\
    \ do |k|\n                count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      \
    \      end\n        end\n    end\n    count\nend", "  a = (1..n).to_a.map { |i|\
    \ i * i - i + 1 }\n  a.combination(3).count { |x, y, z| (x + y + z) % 3 == 0 }\n\
    end", "  a = [1]\n  n.times { |i| a << i*i - i + 1 }\n  total = 0\n  a.each_with_index\
    \ do |x, i|\n    a.each_with_index do |y, j|\n      next if i >= j\n      a.each_with_index\
    \ do |z, k|\n        next if i >= k || j >= k\n        total += 1 if (x + y +\
    \ z) % 3 == 0\n      end\n    end\n  end\n  total\nend", "  return 0 if n < 3\n\
    \  a = (1..n).map { |x| x * x - x + 1 }\n  acc = 0\n  n.times do |i|\n    ((i\
    \ + 1)..(n - 1)).each do |j|\n      for k in (j + 1)..(n - 1)\n        acc +=\
    \ 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  acc\nend",
  end, "  a = Array.new(n) { |i| i * i - i + 1 }\n  a.combination(3).count { |i, j,\
    \ k| (i + j + k) % 3 == 0 }\nend", "  # Write your code here\n  i = 0\n  triplets\
    \ = 0\n  while i < n\n    (i+1..n-1).each do |j|\n      (j+1..n-1).each do |k|\n\
    \        triplets += 1 if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3\
    \ == 0\n      end\n    end\n    i += 1\n  end\n  triplets\nend", "  arr = []\n\
    \  (1..n).each do |i|\n    arr << i * i - i + 1\n  end\n  count = 0\n  (0..arr.length\
    \ - 3).each do |i|\n    (i + 1..arr.length - 2).each do |j|\n      (j + 1..arr.length\
    \ - 1).each do |k|\n        # puts \"a[#{i}] = #{arr[i]}, a[#{j}] = #{arr[j]},\
    \ a[#{k}] = #{arr[k]}\"\n        count += 1 if (arr[i] + arr[j] + arr[k]) % 3\
    \ == 0\n      end\n    end\n  end\n  count\nend", "  n.times.each_with_object([])\
    \ do |i,arr|\n    arr << i * i - i + 1\n  end.combination(3).map(&:sum).select{|sum|\
    \ sum % 3 == 0}.count\nend\np get_max_triples(5)", '  a = Array.new(n) { |i| i
    * i - i + 1 }', "  return 0 if n < 3\n  a = (1..n).map { |i| i * i - i + 1 }\n\
    \  sol = 0\n  for i in 0..(n - 3)\n    for j in (i + 1)..(n - 2)\n      for k\
    \ in (j + 1)..(n - 1)\n        sol += 1 if a[i] + a[j] + a[k] % 3 == 0\n     \
    \ end\n    end\n  end\n  sol\nend", "  arr = (1..n).map { |i| i * i - i + 1 }\n\
    \  count = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each\
    \ do |k|\n        count += 1 if (arr[i] + arr[j] + arr[k]) % 3 == 0\n      end\n\
    \    end\n  end\n  count\nend", "\tget_max_triples_helper(n, 1, 0)\nend", "  #\
    \ your code here\nend", "  # your code here\nend", "  res = 0\n  array = (1..n).map\
    \ { |i| i * i - i + 1 }\n  (1..array.size - 2).each do |i|\n    ((i + 1)..array.size\
    \ - 1).each do |j|\n      ((j + 1)..array.size).each do |k|\n        res += 1\
    \ if (array[i] + array[j] + array[k]) % 3 == 0\n      end\n    end\n  end\n  res\n\
    end", "  a = [*1..n].map{|i| i*i - i + 1}\n  a.combination(3).count {|a, b, c|\
    \ (a + b + c) % 3 == 0}\nend", "  a = (1..n).map { |i| i * i - i + 1 }\n  a.combination(3).select\
    \ { |i, j, k| (i + j + k) % 3 == 0 }.count\nend", "  a = []\n  (1..n).each { |i|\
    \ a << i * i - i + 1 }\n  count = 0\n  (1..n-2).each do |i|\n    (i+1..n-1).each\
    \ do |j|\n      (j+1..n).each do |k|\n        count += 1 if a[i] + a[j] + a[k]\
    \ % 3 == 0\n      end\n    end\n  end\n  count\nend", "  array = (1..n).map {\
    \ |i| i * i - i + 1 }\n  array.combination(3).select { |nums| nums.reduce(:+)\
    \ % 3 == 0 }.size\nend", "  a = []\n  (1..n).each do |i|\n    a << i * i - i +\
    \ 1\n  end\n  count = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n\
    \      (j+1..n-1).each do |k|\n        if a[i] + a[j] + a[k] % 3 == 0\n      \
    \    count += 1\n        end\n      end\n    end\n  end\n  count\nend", end, " \
    \ arr = []\n  count = 0\n  1.upto(n) do |i|\n    arr << i * i - i + 1\n  end\n\
    \  (0..arr.length - 3).each do |i|\n    (i + 1..arr.length - 2).each do |j|\n\
    \      (j + 1..arr.length - 1).each do |k|\n        count += 1 if (arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "  # a[i] + a[j]\
    \ + a[k] == 3*n.\n  # a[i] + a[j] == 3*n - a[k]\n  # a[i] + a[j] == 3*n - i*i\
    \ + i - (3*k - k*k + k)\n  # a[i] + a[j] == 2*n - 2*i + 2*k\n  # a[i] + a[j] ==\
    \ 2*(n - i + k)\n  # (a[i] + a[j])/2 == n - i + k\n  # a[i] + a[j] must be even.\n\
    \  # a[i] must be even.\n  # a[j] must be even.\n  # a[i]/2 + a[j]/2 == n - i\
    \ + k\n  # a[i]/2 + a[j]/2 == n - i + j\n  # j - i == a[i]/2 + a[j]/2 - n\n  #\n\
    \  # a[i]/2 + a[j]/2 + a[j] - a[i]/2 - a[j]/2 - n\n  # a[j] - a[i]/2 == a[j]/2\
    \ - n\n  # a[j] - a[i]/2 == a[j]/2 - n\n  # a[j] == a[i]/2 + a[j]/2 - n\n  # 2*a[j]\
    \ == a[i] + 2*a[j] - 2*n\n  # 2*a[j] - a[i] == 2*a[j] - 2*n\n  # a[i] == 2*n -\
    \ 2*a[j]\n  # a[i] must be even.\n  # 2*n - 2*a[j] must be even.\n  # 2*(n - a[j])\
    \ must be even.\n  # n - a[j] must be even.\n  # n - a[j] must be a multiple of\
    \ 2.\n  # n - a[j] must be a multiple of", "  # Write your code here\n  # Use\
    \ \"#{variable}\" to access the value of a variable\nend", "    a = Array.new(n){|i|\
    \ i * i - i + 1}\n    count = 0\n    for i in 0..a.length-3\n        for j in\
    \ i+1..a.length-2\n            for k in j+1..a.length-1\n                count\
    \ += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n            end\n        end\n    end\n\
    \    count\nend", "  a = get_array(n)\n  a.combination(3).select{|x| x.reduce(:+)\
    \ % 3 == 0}.size\nend", "  a = []\n  (1..n).each do |i|\n    a[i] = i * i - i\
    \ + 1\n  end\n  triples = []\n  sum = 0\n  (1..n-2).each do |i|\n    (i+1..n-1).each\
    \ do |j|\n      (j+1..n).each do |k|\n        sum = a[i] + a[j] + a[k]\n     \
    \   triples << [a[i], a[j], a[k]] if sum % 3 == 0\n      end\n    end\n  end\n\
    \  triples.length\nend", "  arr = []\n  (1..n).each do |val|\n    arr << val *\
    \ val - val + 1\n  end\n  triple_sum = 0\n  (0..n-3).each do |idx1|\n    (idx1+1..n-2).each\
    \ do |idx2|\n      (idx2+1..n-1).each do |idx3|\n        if (arr[idx1] + arr[idx2]\
    \ + arr[idx3]) % 3 == 0\n          triple_sum += 1\n        end\n      end\n \
    \   end\n  end\n  triple_sum\nend", "  a = (1..n).map { |e| e*e - e + 1 }\n  a.combination(3).count\
    \ { |e| e.reduce(:+) % 3 == 0 }\nend", "    arr = (1..n).to_a.map { |num| num\
    \ * num - num + 1 }\n    triple_count = 0\n    0.upto(arr.length - 3) do |i|\n\
    \        (i + 1).upto(arr.length - 2) do |j|\n            (j + 1).upto(arr.length\
    \ - 1) do |k|\n                triple_count += 1 if (arr[i] + arr[j] + arr[k])\
    \ % 3 == 0\n            end\n        end\n    end\n    triple_count\nend", " \
    \ a = Array.new(n) { |i| i * i - i + 1 }\n  a.combination(3).select { |c| c.sum\
    \ % 3 == 0 }.size\nend", "  a = []\n  for i in 1..n\n    a << i * i - i + 1\n\
    \  end\n  #p a\n  count = 0\n  for i in 0..a.length-3\n    for j in i+1..a.length-2\n\
    \      for k in j+1..a.length-1\n        if a[i] + a[j] + a[k] % 3 == 0\n    \
    \      count += 1\n        end\n      end\n    end\n  end\n  count\nend", "  arr\
    \ = []\n  (1..n).each { |i| arr << i * i - i + 1 }\n  ctr = 0\n  (0..n-3).each\
    \ do |x|\n    (x+1..n-2).each do |y|\n      (y+1..n-1).each do |z|\n        ctr\
    \ += 1 if (arr[x] + arr[y] + arr[z]) % 3 == 0\n      end\n    end\n  end\n  ctr\n\
    end", '  array = (1..n).to_a.map { |i| i * i - i + 1 }', "  array = Array.new(n)\
    \ { |i| i * i - i + 1 }\n  triple_count = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      (j+1..n-1).each do |k|\n        triple_count += 1 if array[i]\
    \ + array[j] + array[k] % 3 == 0\n      end\n    end\n  end\n  triple_count\n\
    end", "  count = 0\n  arr = (1..n).map{|i| i * i - i + 1}\n  for i in 0..n-3\n\
    \    for j in i+1..n-2\n      for k in j+1..n-1\n        count += 1 if (arr[i]\
    \ + arr[j] + arr[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "  a\
    \ = []\n  count = 0\n  1.upto(n) do |num|\n    a << num * num - num + 1\n  end\n\
    \  0.upto(a.length - 3) do |i|\n    (i + 1).upto(a.length - 2) do |j|\n      (j\
    \ + 1).upto(a.length - 1) do |k|\n        count += 1 if (a[i] + a[j] + a[k]) %\
    \ 3 == 0\n      end\n    end\n  end\n  count\nend", "    if n.is_a? Integer\n\
    \        if n > 0\n            if n <= 10**5\n                a = Array.new(n,\
    \ 0)\n                for i in 1..n\n                    a[i-1] = i * i - i +\
    \ 1\n                end\n                count = 0\n                for i in\
    \ 1..n\n                    for j in (i+1)..n\n                        for k in\
    \ (j+1)..n\n                            if (a[i-1] + a[j-1] + a[k-1]) % 3 == 0\n\
    \                                count += 1\n                            end\n\
    \                        end\n                    end\n                end\n \
    \               count\n            else\n                puts \"Enter number less\
    \ than 10**5.\"\n            end\n        else\n            puts \"Enter positive\
    \ number.\"\n        end\n    else\n        puts \"Enter integer value.\"\n  \
    \  end\nend", "  a = (1..n).to_a.map { |i| i * i - i + 1 }\n  count = 0\n  n.times\
    \ do |i|\n    i.upto(n-1) do |j|\n      j.upto(n-1) do |k|\n        count += 1\
    \ if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend",
  "  return nil if n.nil?\n  a = []\n  (1..n).each do |i|\n    a << i * i - i + 1\n\
    \  end\n  count = 0\n  (0..a.length - 3).each do |i|\n    (i + 1..a.length - 2).each\
    \ do |j|\n      (j + 1..a.length - 1).each do |k|\n        count += 1 if (a[i]\
    \ + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "  # write\
    \ your code here\nend", "  a = (1..n).map { |e| e * e - e + 1 }\n  count = 0\n\
    \  (0..n - 3).each do |i|\n    (i + 1..n - 2).each do |j|\n      (j + 1..n - 1).each\
    \ do |k|\n        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n   \
    \ end\n  end\n  count\nend", "  # a = [1, 3, 7, 13, 21]\n  # a[1] + a[2] + a[3]\
    \ = 3 + 7 + 13 = 23\n  # a[2] + a[3] + a[4] = 7 + 13 + 21 = 41\n  # for k, v in\
    \ enumerate(a):\n  #   print(f'{k} => {v}')\n  # 1 => 1\n  # 2 => 3\n  # 3 =>\
    \ 7\n  # 4 => 13\n  # 5 => 21\n  a = (1..n).map { |i| i * i - i + 1 }\n  i = 1\n\
    \  j = 2\n  k = 3\n  count = 0\n  while k < n\n    while j < k\n      while i\
    \ < j\n        if (a[i] + a[j] + a[k]) % 3 == 0\n          count += 1\n      \
    \  end\n        i += 1\n      end\n      j += 1\n    end\n    k += 1\n  end\n\
    \  count\nend", "\t# We create an array of length n.\n\ta = Array.new(n) { |i|\
    \ i * i - i + 1 }\n\t# We create a hash of key/value pairs where:\n\t# key = sum\
    \ of the triple\n\t# value = number of triples that add up to key\n\ttriples =\
    \ Hash.new(0)\n\ta.each_with_index do |element, i|\n\t\t# We start the j counter\
    \ at i + 1 to avoid duplicate triples and triples where i > j > k.\n\t\t(i + 1).upto(a.length\
    \ - 1) do |j|\n\t\t\t# We start the k counter at j + 1 to avoid duplicate triples\
    \ and triples where i > j > k.\n\t\t\t(j + 1).upto(a.length - 1) do |k|\n\t\t\t\
    \tsum = element + a[j] + a[k]\n\t\t\t\t# We use the sum as a key to the hash triples\
    \ and increment the value by 1.\n\t\t\t\ttriples[sum] += 1\n\t\t\tend\n\t\tend\n\
    \tend\n\t# We return the number of triples where the sum is a multiple of 3.\n\
    \ttriples.values.select { |v| v if v % 3 == 0 }.inject(:+)\nend", "  total = 0\n\
    \  (1..n).each do |i|\n    ((i+1)..n).each do |j|\n      ((j+1)..n).each do |k|\n\
    \        if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0\n       \
    \   total += 1\n        end\n      end\n    end\n  end\n  total\nend", "  return\
    \ 0 if n < 3\n  count = 0\n  for i in 1..n-2\n    for j in i+1..n-1\n      for\
    \ k in j+1..n\n        count += 1 if (i*i - i + 1 + j*j - j + 1 + k*j - k + 1)\
    \ % 3 == 0\n      end\n    end\n  end\n  count\nend", "  nums = (1..n).map { |i|\
    \ i * i - i + 1 }\n  ((n - 1) * (n - 2) / 6) - nums.count { |i| i % 3 != 0 }\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
