name: HumanEval_111_histogram
language: rb
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a hash\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\n# >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" =>\
  \ 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"\
  a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n\
  # {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n\
  \    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2},\
  \ candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"\
  a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1,\
  \ \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"\
  t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4},\
  \ candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\"\
  \ => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n\
  \    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"
completions: ["  letters = test.split(\" \")\n  letters_hash = Hash.new(0)\n  letters.each\
    \ do |letter|\n    letters_hash[letter] += 1\n  end\n  letters_hash\nend", " \
    \ result = Hash.new\n  str = test.split(\" \")\n  str.each do |letter|\n    unless\
    \ result.include?(letter)\n      result[letter] = 1\n    else\n      result[letter]\
    \ += 1\n    end\n  end\n  result\nend", "  test = test.downcase.split(' ')\n \
    \ result = Hash.new(0)\n  keys = Array.new\n  test.each do |key|\n    result[key]\
    \ += 1\n  end\n  puts result\n  max = result.values.max\n  result.each do |key,\
    \ value|\n    if value == max\n      keys << key\n    end\n  end\n  result.delete_if\
    \ {|key, value| value != max}\n  puts result\nend", "  h = {}\n  test.split(\"\
    \ \").each do |letter|\n    if h.key?(letter)\n      h[letter] += 1\n    else\n\
    \      h[letter] = 1\n    end\n  end\n  h\nend", "  result = {}\n  test.downcase.split(\"\
    \ \").each do |x|\n    result[x] = test.downcase.split(\" \").count(x)\n  end\n\
    \  puts result\nend", "  test.split.group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\n\
    end", "  test.split(\" \").each_with_object(Hash.new(0)) { |v, hash| hash[v] +=\
    \ 1 }\nend", "  test.split.inject(Hash.new(0)) { |h, v| h[v] += 1; h }.delete_if\
    \ { |k, v| v == 1 }\nend", "  occurences = Hash.new(0)\n  test.split(' ').each\
    \ { |x| occurences[x] += 1 }\n  max_occurence = occurences.values.max\n  occurences.select\
    \ { |k, v| v == max_occurence }\nend", "  result = {}\n  test.split(\" \").each\
    \ do |e|\n    result[e] = test.split(\" \").count(e)\n  end\n  result\nend", " \
    \ arr = test.split(\" \")\n  #p arr\n  count = Hash.new(0)\n  arr.each do |i|\n\
    \    count[i] += 1\n  end\n  max_value = count.values.max\n  counts = count.select\
    \ {|key, value| value == max_value}\n  p counts\nend", "  count = Hash.new(0)\n\
    \  test.split(\" \").each do |char|\n    count[char] += 1\n  end\n  count\nend",
  "  result = {}\n  current_max = 0\n  test.split(\" \").each do |char|\n    if result[char]\n\
    \      result[char] += 1\n    else\n      result[char] = 1\n    end\n    current_max\
    \ = result[char] if result[char] > current_max\n  end\n  final_result = {}\n \
    \ result.each do |key, value|\n    final_result[key] = value if value == current_max\n\
    \  end\n  final_result\nend", "  counts = Hash.new(0)\n  test.downcase.split.each\
    \ { |letter| counts[letter] += 1 }\n  max_count = counts.values.max\n  result\
    \ = {}\n  counts.each do |letter, count|\n    result[letter] = count if count\
    \ == max_count\n  end\n  result\nend", "  counts = Hash.new 0\n  hist = {}\n \
    \ letters = test.split(' ')\n  letters.each do |letter|\n    counts[letter] +=\
    \ 1\n  end\n  counts.each do |key, value|\n    hist[key] = value\n  end\n  hist\n\
    end", "  histogram = Hash.new(0)\n  test.downcase.split.each { |x| histogram[x]\
    \ += 1 }\n  if histogram.values.max > 1\n    new_hash = Hash.new(0)\n    histogram.each\
    \ { |x, y| new_hash[x] = y if y == histogram.values.max }\n    new_hash\n  else\n\
    \    histogram\n  end\nend", "  lowercase = \"abcdefghijklmnopqrstuvwxyz\"\n \
    \ hash = {}\n  lowercase.each_char do |char|\n    if test.include?(char)\n   \
    \   hash[char] = test.count(char)\n    end\n  end\n  hash.max_by{|k,v| v}\nend",
  "  result = Hash.new(0)\n  test.split(\" \").each { |i| result[i] += 1 }\n  result\n\
    end", "    counts = Hash.new(0)\n    test.split(\" \").each { |word| counts[word]\
    \ += 1 }\n    counts\nend", "  letters = test.split(' ')\n  counts = Hash.new(0)\n\
    \  letters.each { |word| counts[word] += 1 }\n  max = counts.values.max\n  counts.select\
    \ { |_k, v| v == max }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
