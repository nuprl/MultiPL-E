name: HumanEval_158_find_max
language: rb
prompt: "# Write a function that accepts an array of strings.\n# The array contains\
  \ different words. Return the word with maximum number\n# of unique characters.\
  \ If multiple strings have maximum number of unique\n# characters, return the one\
  \ which comes first in lexicographical order.\n# >>> find_max.call([\"name\", \"\
  of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"\
  ])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\
  \ndef find_max(words)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
  \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
  name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
  , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
  , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
  ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
  , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"\
  are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
  this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"\
  ]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
  \  end\nend\n"
completions: ["  words.select { |word| word.chars.uniq.size == words.map { |w| w.chars.uniq.size\
    \ }.max }.sort.first\nend", "  max_uniq_count = nil\n  max_uniq_word = nil\n \
    \ words.each do |word|\n    uniq_count = word.split('').uniq.count\n    if max_uniq_count.nil?\n\
    \      max_uniq_count = uniq_count\n      max_uniq_word = word\n    elsif uniq_count\
    \ > max_uniq_count\n      max_uniq_count = uniq_count\n      max_uniq_word = word\n\
    \    elsif uniq_count == max_uniq_count\n      max_uniq_word = word if word <\
    \ max_uniq_word\n    end\n  end\n  max_uniq_word\nend", "  words.max { |a, b|\
    \ max_unique_chars(a) <=> max_unique_chars(b) }\nend", "\t# write your code here\n\
    end", "  words.max_by{|word| word.chars.uniq.count}\nend", "  arr_of_word_hash\
    \ = words.map do |word|\n    word_hash = Hash.new(0)\n    word.chars.each do |char|\n\
    \      word_hash[char] += 1\n    end\n    word_hash\n  end\n  max_unique_chars\
    \ = arr_of_word_hash.max_by { |el| el.length }.length\n  words.select { |word|\
    \ word.chars.uniq.length == max_unique_chars }.min\nend", "  lexicographic_index_of_max_unique_characters_word(words)\
    \ || words.first\nend", "  word_hash = Hash.new()\n  words.each { |word| word_hash[word]\
    \ = word.chars.uniq.count }\n  word_hash.key(word_hash.values.max)\nend", "  uniques\
    \ = words.map { |word| word.chars.uniq.size }\n  words[uniques.index(uniques.max)]\n\
    end\np find_max([\"name\", \"of\", \"string\"])\np find_max([\"name\", \"enam\"\
    , \"game\"])\np find_max([\"aaaaaaa\", \"bb\", \"cc\"])", "\tmax_count = 0\n\t\
    max_word = \"\"\n\twords.each do |word|\n\t\tcount = 0\n\t\tword.split(\"\").each\
    \ do |ch|\n\t\t\tcount += 1 if word.count(ch) == 1\n\t\tend\n\t\tif count > max_count\n\
    \t\t\tmax_count = count\n\t\t\tmax_word = word\n\t\telsif count == max_count\n\
    \t\t\tmax_word = word if word < max_word\n\t\tend\n\tend\n\tmax_word\nend", " \
    \ words.map { |word| [word, word.chars.uniq.size] }.max_by { |word, count| count\
    \ }.first\nend", "  # TODO: implement this function\nend", "  chars = []\n  unique_chars\
    \ = []\n  unique_char_count = []\n  index = 0\n  word_index = 0\n  words.each\
    \ do |word|\n    chars[index] = word.split('')\n    unique_chars[index] = chars[index].uniq\n\
    \    unique_char_count[index] = unique_chars[index].count\n    index += 1\n  end\n\
    \  max_count = unique_char_count.max\n  count_index = 0\n  unique_char_count.each\
    \ do |count|\n    if count == max_count\n      word_index = count_index\n    \
    \  break\n    end\n    count_index += 1\n  end\n  words[word_index]\nend", " \
    \ max_str = words.max_by { |word| word.chars.uniq.size }\n  words.index(max_str)\
    \ < words.index(words.min) ? words.min : max_str\nend", "  sorted_by_unique_chars\
    \ = words.sort_by { |word| word.chars.uniq.size }\n  sorted_by_unique_chars.last\n\
    end", "  words.max { |a, b| a.chars.uniq.count <=> b.chars.uniq.count }\nend",
  "  max_word = \"\"\n  max_unique_chars = 0\n  words.each do |word|\n    if max_unique_chars\
    \ < word.chars.uniq.count\n      max_unique_chars = word.chars.uniq.count\n  \
    \    max_word = word\n    end\n  end\n  max_word\nend", "  # TODO\nend", "  #\
    \ Your code here\nend", "    # TODO: Implement me\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
