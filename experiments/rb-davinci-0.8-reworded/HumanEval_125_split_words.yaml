name: HumanEval_125_split_words
language: rb
prompt: "# Given a string of words, return an array of words split on whitespace,\
  \ if no whitespaces exists in the text you\n# should split on commas ',' if no commas\
  \ exists you should return the number of lower-case letters with odd order in the\n\
  # alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n# Examples\n# >>> split_words.call(\"\
  Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\"\
  )\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n\
  \    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"],\
  \ candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"\
  Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello\
  \ world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"\
  Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2,\
  \ candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n \
  \   assert_equal(0, candidate.call(\"\"))\n  end\nend\n"
completions: ["  if txt.scan(/\\s/).length == 0\n    if txt.scan(/,/).length == 0\n\
    \      txt.scan(/[a-z]/).count { |x| x.ord % 2 == 1 }\n    else\n      txt.split(\"\
    ,\")\n    end\n  else\n    txt.split\n  end\nend", "  # txt.split(/[\\s,]/) unless\
    \ txt.chars.any? { |ch| ('a'..'z').include?(ch) }\n  # txt.count { |ch| ch.between?('a',\
    \ 'z') && txt.index(ch).odd? } if txt.chars.all? { |ch| ch.between?('a', 'z')\
    \ }\n  # txt.count { |ch| ch.ord.between?(ord('a'), ord('z')) && txt.index(ch).odd?\
    \ } if txt.chars.all? { |ch| ch.ord.between?(ord('a'), ord('z')) }\n  # txt.count\
    \ { |ch| ch.ord.between?(97, 122) && txt.index(ch).odd? } if txt.chars.all? {\
    \ |ch| ch.ord.between?(97, 122) }\n  # txt.split(/[\\s,]/) unless txt.chars.any?\
    \ { |ch| ch.between?('a', 'z') }\n  # txt.count { |ch| ch.between?('a', 'z') &&\
    \ txt.index(ch).odd? } if txt.chars.all? { |ch| ch.between?('a', 'z') }\n  txt.split(/[\\\
    s,]/) unless txt.chars.any? { |ch| ch.ord.between?(97, 122) }\n  txt.count { |ch|\
    \ ch.ord.between?(97, 122) && txt.index(ch).odd? } if txt.chars.all? { |ch| ch.ord.between?(97,\
    \ 122) }\nend", "  if txt =~ /\\s/\n    txt.split(\" \")\n  elsif txt =~ /,/\n\
    \    txt.split(\",\")\n  else\n    txt.chars.select { |x| x.ord % 2 == 1 }.size\n\
    \  end\nend", "  if txt =~ /\\s/\n    txt.split(/\\s/)\n  elsif txt =~ /,/\n \
    \   txt.split(',')\n  else\n    txt.split('').select.with_index { |_, i| i.odd?\
    \ }.count\n  end\nend", "  list = txt.split(\" \")\n  return list if list.length\
    \ != 1\n  list = txt.split(\",\")\n  return list if list.length != 1\n  count\
    \ = 0\n  list = txt.split(\"\")\n  list.each do |ch|\n    count += 1 if ch.ord.odd?\n\
    \  end\n  count\nend", "  if txt.index(/\\s+/)\n    return txt.split(/\\s+/)\n\
    \  end\n  if txt.index(/,/)\n    return txt.split(/,/)\n  end\n  counter = 0\n\
    \  (0..txt.length-1).each do |i|\n    if txt[i].downcase.ord % 2 == 1\n      counter\
    \ += 1\n    end\n  end\n  return counter\nend", "  return txt.split(' ') if txt.include?('\
    \ ')\n  return txt.split(',') if txt.include?(',')\n  (1..txt.length).select {\
    \ |x| x.odd? }.count\nend", "  if txt.count(\" \") > 0\n    txt.split(\" \")\n\
    \  elsif txt.count(\",\") > 0\n    txt.split(\",\")\n  else\n    chars = txt.downcase.chars\n\
    \    odd_index = []\n    for i in 0..chars.size - 1\n      if i % 2 != 0\n   \
    \     odd_index << chars[i]\n      end\n    end\n    odd_index.count\n  end\n\
    end", "  return txt.split(/[\\s,]/) if txt.match(/[\\s,]/)\n  txt.count{|c| ('a'..'z').include?(c)\
    \ && ('a'..'z').to_a.index(c).odd?}\nend", "  return txt.split(',') if txt.index(',')\n\
    \  txt.split(' ')\nend", "  if txt.include?(\" \")\n    txt.split(\" \")\n  elsif\
    \ txt.include?(\",\")\n    txt.split(\",\")\n  else\n    txt.length\n  end\nend",
  "  words = txt.split(/[,\\s]+/)\n  words.count > 1 ? words : words.first.downcase.chars.select.with_index{|_,i|\
    \ i.odd?}.count\nend", "  # Your code goes here\nend", "  if txt.include?(\" \"\
    )\n    return txt.split(\" \")\n  elsif txt.include?(\",\")\n    return txt.split(\"\
    ,\")\n  else\n    count = 0\n    letters = ('a'..'z').to_a\n    letters.each_with_index\
    \ do |letter, index|\n      if index.odd?\n        count += txt.count(letter)\n\
    \      end\n    end\n    return count\n  end\nend", "  txt.count(\"abcdefghijklmnopqrstuvwxyz\"\
    ).odd? ? txt.count(\"abcdefghijklmnopqrstuvwxyz\") : txt.split(/[\\s,]/)\nend",
  "  txt.include?(' ') ? txt.split(' ') : txt.include?(',') ? txt.split(',') : txt.length\n\
    end", "  space_arr = txt.split(\" \")\n  comma_arr = txt.split(\",\")\n  if space_arr.length\
    \ > 1\n    return space_arr\n  elsif comma_arr.length > 1\n    return comma_arr\n\
    \  else\n    odd_letters = []\n    txt.downcase.split(\"\").each do |letter|\n\
    \      if (letter.ord.to_i - 96) % 2 != 0\n        odd_letters << letter\n   \
    \   end\n    end\n    return odd_letters.length\n  end\nend", "  return txt.split(/\\\
    s+/) if txt.count(' ') > 0\n  return txt.split(',') if txt.count(',') > 0\n  txt.count('a-z').count\
    \ { |n| n.odd? }\nend", "  txt.include?(\" \") ? txt.split : txt.include?(\",\"\
    ) ? txt.split(\",\") : txt.chars.count { |c| /[a-z]/.match(c) && ord(c) % 2 !=\
    \ 0 }\nend", "  # write your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
