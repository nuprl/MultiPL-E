name: HumanEval_54_same_chars
language: rb
prompt: "# Check if two words have the same characters.\n# >>> same_chars.call(\"\
  eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"\
  dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n\
  # >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"\
  abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"\
  )\n# false\ndef same_chars(s0, s1)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n\
  \    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\"\
  , \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"\
  ))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false,\
  \ candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"\
  abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\"\
  , \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"\
  ))\n  end\nend\n"
completions: ["  return false if s0.length != s1.length\n  return s0.split('').sort\
    \ == s1.split('').sort\nend", "  s0.chars.sort == s1.chars.sort\nend", "  l0 =\
    \ s0.chars.sort.join\n  l1 = s1.chars.sort.join\n  l0 == l1\nend", "  s0.size\
    \ == s1.size && s0.chars.sort == s1.chars.sort\nend", "  # For each char in s0,\
    \ find if it is present in s1 (at least same number of times)\n  # require 'pry';\
    \ binding.pry\n  s0.chars.each do |char|\n    s1.chars.delete_at(s1.chars.index(char))\
    \ rescue next\n  end\n  s1.chars.empty?\nend", "  count_chars(s0) == count_chars(s1)\n\
    end", "  h = Hash.new(0)\n  s0.each_char { |c| h[c] += 1 }\n  s1.each_char { |c|\
    \ h[c] -= 1 }\n  h.values.all? { |v| v == 0 }\nend", "  counter = Hash.new(0)\n\
    \  s0.chars.each { |c| counter[c] += 1 }\n  s1.chars.each { |c| counter[c] -=\
    \ 1 }\n  counter.values.all?(&:zero?)\nend", "  s0.chars.sort == s1.chars.sort\n\
    end", "    return normalize(s0) == normalize(s1)\nend", "  character_count = {}\n\
    \  s0.chars.each do |c|\n    character_count[c] ||= 0\n    character_count[c]\
    \ += 1\n  end\n  s1.chars.each do |c|\n    character_count[c] ||= 0\n    character_count[c]\
    \ -= 1\n  end\n  character_count.each do |k, v|\n    return false if v != 0\n\
    \  end\n  true\nend", "  s0.split('').sort == s1.split('').sort\nend\nsame_chars.call(\"\
    eabcdzzzz\", \"dddzzzzzzzddeddabc\")\nsame_chars.call(\"abcd\", \"dddddddabc\"\
    )\nsame_chars.call(\"dddddddabc\", \"abcd\")\nsame_chars.call(\"eabcd\", \"dddddddabc\"\
    )\nsame_chars.call(\"abcd\", \"dddddddabce\")\nsame_chars.call(\"eabcdzzzz\",\
    \ \"dddzzzzzzzddddabc\")", "  if s0.size != s1.size\n    false\n  else\n    s0.chars.sort\
    \ == s1.chars.sort\n  end\nend", "  (0..s0.length-1).each do |i|\n    return false\
    \ if s0[i] != s1[i]\n  end\n  true\nend", "  s0.chars.sort == s1.chars.sort\n\
    end", "  h0 = {}\n  h1 = {}\n  s0.each_char do |char|\n    h0[char] ||= 0\n  \
    \  h0[char] += 1\n  end\n  s1.each_char do |char|\n    h1[char] ||= 0\n    h1[char]\
    \ += 1\n  end\n  h0 == h1\nend", "  ss0 = s0.chars.sort\n  ss1 = s1.chars.sort\n\
    \  ss0 == ss1\nend", "  s0.chars.sort == s1.chars.sort\nend\n$same_chars = Kernel.method(:same_chars)",
  "  return false if s0.length != s1.length\n  s0.split('').sort == s1.split('').sort\n\
    end", "  if(s0.length > s1.length)\n    larger = s0\n    smaller = s1\n  else\n\
    \    larger = s1\n    smaller = s0\n  end\n  larger_hash = {}\n  smaller_hash\
    \ = {}\n  larger.each_char do |char|\n    if larger_hash[char]\n      larger_hash[char]\
    \ += 1\n    else\n      larger_hash[char] = 1\n    end\n  end\n  smaller.each_char\
    \ do |char|\n    if smaller_hash[char]\n      smaller_hash[char] += 1\n    else\n\
    \      smaller_hash[char] = 1\n    end\n  end\n  smaller_hash.each do |k, v|\n\
    \    if(!larger_hash[k] || v > larger_hash[k])\n      return false\n    end\n\
    \  end\n  return true\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
