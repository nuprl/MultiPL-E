name: HumanEval_54_same_chars
language: rb
prompt: "# Check if two words have the same characters.\n# >>> same_chars.call(\"\
  eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"\
  dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n\
  # >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"\
  abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"\
  )\n# false\ndef same_chars(s0, s1)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n\
  \    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\"\
  , \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"\
  ))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false,\
  \ candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"\
  abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\"\
  , \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"\
  ))\n  end\nend\n"
completions: ["  return false if s0.length != s1.length\n  return s0.split('').sort\
    \ == s1.split('').sort\nend", "  s0.chars.sort == s1.chars.sort\nend", "  l0 =\
    \ s0.chars.sort.join\n  l1 = s1.chars.sort.join\n  l0 == l1\nend", "  s0.size\
    \ == s1.size && s0.chars.sort == s1.chars.sort\nend", "  # For each char in s0,\
    \ find if it is present in s1 (at least same number of times)\n  # require 'pry';\
    \ binding.pry\n  s0.chars.each do |char|\n    s1.chars.delete_at(s1.chars.index(char))\
    \ rescue next\n  end\n  s1.chars.empty?\nend", "  count_chars(s0) == count_chars(s1)\n\
    end", "  h = Hash.new(0)\n  s0.each_char { |c| h[c] += 1 }\n  s1.each_char { |c|\
    \ h[c] -= 1 }\n  h.values.all? { |v| v == 0 }\nend", "  counter = Hash.new(0)\n\
    \  s0.chars.each { |c| counter[c] += 1 }\n  s1.chars.each { |c| counter[c] -=\
    \ 1 }\n  counter.values.all?(&:zero?)\nend", "  s0.chars.sort == s1.chars.sort\n\
    end", "    return normalize(s0) == normalize(s1)\nend", "  character_count = {}\n\
    \  s0.chars.each do |c|\n    character_count[c] ||= 0\n    character_count[c]\
    \ += 1\n  end\n  s1.chars.each do |c|\n    character_count[c] ||= 0\n    character_count[c]\
    \ -= 1\n  end\n  character_count.each do |k, v|\n    return false if v != 0\n\
    \  end\n  true\nend", "  s0.split('').sort == s1.split('').sort\nend\nsame_chars.call(\"\
    eabcdzzzz\", \"dddzzzzzzzddeddabc\")\nsame_chars.call(\"abcd\", \"dddddddabc\"\
    )\nsame_chars.call(\"dddddddabc\", \"abcd\")\nsame_chars.call(\"eabcd\", \"dddddddabc\"\
    )\nsame_chars.call(\"abcd\", \"dddddddabce\")\nsame_chars.call(\"eabcdzzzz\",\
    \ \"dddzzzzzzzddddabc\")", "  if s0.size != s1.size\n    false\n  else\n    s0.chars.sort\
    \ == s1.chars.sort\n  end\nend", "  (0..s0.length-1).each do |i|\n    return false\
    \ if s0[i] != s1[i]\n  end\n  true\nend", "  s0.chars.sort == s1.chars.sort\n\
    end", "  h0 = {}\n  h1 = {}\n  s0.each_char do |char|\n    h0[char] ||= 0\n  \
    \  h0[char] += 1\n  end\n  s1.each_char do |char|\n    h1[char] ||= 0\n    h1[char]\
    \ += 1\n  end\n  h0 == h1\nend", "  ss0 = s0.chars.sort\n  ss1 = s1.chars.sort\n\
    \  ss0 == ss1\nend", "  s0.chars.sort == s1.chars.sort\nend\n$same_chars = Kernel.method(:same_chars)",
  "  return false if s0.length != s1.length\n  s0.split('').sort == s1.split('').sort\n\
    end", "  if(s0.length > s1.length)\n    larger = s0\n    smaller = s1\n  else\n\
    \    larger = s1\n    smaller = s0\n  end\n  larger_hash = {}\n  smaller_hash\
    \ = {}\n  larger.each_char do |char|\n    if larger_hash[char]\n      larger_hash[char]\
    \ += 1\n    else\n      larger_hash[char] = 1\n    end\n  end\n  smaller.each_char\
    \ do |char|\n    if smaller_hash[char]\n      smaller_hash[char] += 1\n    else\n\
    \      smaller_hash[char] = 1\n    end\n  end\n  smaller_hash.each do |k, v|\n\
    \    if(!larger_hash[k] || v > larger_hash[k])\n      return false\n    end\n\
    \  end\n  return true\nend", "  s0.each_char do |c|\n    if (s1.index(c) != nil)\n\
    \      s1.slice!(s1.index(c))\n    else\n      return false\n    end\n  end\n\
    \  return true\nend", "  char_map = build_char_map(s0)\n  s1.each_char do |c|\n\
    \    return false if char_map[c] == 0\n    char_map[c] -= 1\n  end\n  return char_map.values.all?\
    \ { |x| x == 0 }\nend", "  return s0.chars.sort == s1.chars.sort\nend", "  s0.each_char\
    \ do |c|\n    s1.sub!(c, '')\n  end\n  s1.empty?\nend", "  s0 = s0.chars.sort.join\n\
    \  s1 = s1.chars.sort.join\n  s0 == s1\nend", "  h0 = {}\n  h1 = {}\n  s0.each_char\
    \ { |c| h0[c] ||= 0; h0[c] += 1 }\n  s1.each_char { |c| h1[c] ||= 0; h1[c] +=\
    \ 1 }\n  h0 == h1\nend", "  # Write your code here.\nend", "  return false if\
    \ s0.length != s1.length\n  s0.each_char do |char|\n    return false if !s1.include?(char)\n\
    \  end\n  true\nend", "  s0.chars.sort == s1.chars.sort\nend", "  s0.each_char\
    \ do |ch|\n    s1.sub!(ch, '')\n  end\n  s1.empty?\nend\np same_chars(\"abcd\"\
    , \"abcd\")\np same_chars(\"abcd\", \"dddddddabc\")\np same_chars(\"dddddddabc\"\
    , \"abcd\")\np same_chars(\"eabcd\", \"dddddddabc\")\np same_chars(\"abcd\", \"\
    dddddddabce\")\np same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")", "  alpha\
    \ = (\"a\"..\"z\").to_a\n  res = true\n  alpha.each do |i|\n    if s0.count(i)\
    \ != s1.count(i)\n      res = false\n    end\n  end\n  return res\nend", "  h0\
    \ = s0.chars.group_by(&:itself).transform_values(&:count)\n  h1 = s1.chars.group_by(&:itself).transform_values(&:count)\n\
    \  h0.merge(h1) { |_, v0, v1| v0 >= v1 }.values.all?\nend", "  s0.chars.sort ==\
    \ s1.chars.sort\nend", "  # TODO\nend", "  char_count = Hash.new(0)\n  s0.each_char\
    \ do |c|\n    char_count[c] += 1\n  end\n  s1.each_char do |c|\n    char_count[c]\
    \ -= 1\n  end\n  char_count.values.all?(&:zero?)\nend", "  s0.chars.sort == s1.chars.sort\n\
    end", "  s0.chars.sort == s1.chars.sort\nend", "  res = nil\n  if s0.length ==\
    \ s1.length\n    res = s0.split('').sort == s1.split('').sort\n  end\n  res\n\
    end", "  if s0.size > s1.size\n    s0, s1 = s1, s0\n  end\n  s0.chars.sort ==\
    \ s1.chars.sort\nend", "  a = s0.downcase.split('').sort\n  b = s1.downcase.split('').sort\n\
    \  a == b\nend", "  a0 = s0.split('').sort.join('')\n  a1 = s1.split('').sort.join('')\n\
    \  return a0 == a1\nend", "  s0.chars.sort == s1.chars.sort\nend", "  c = -> (s)\
    \ { s.chars.sort.join}\n  c.call(s0) == c.call(s1)\nend", "  s0.each_char do |c|\n\
    \    i = s1.index(c)\n    return false if i.nil?\n    s1[i] = ''\n  end\n  true\n\
    end", "  s0 = s0.split('').sort\n  s1 = s1.split('').sort\n  p s0, s1\n  i = 0\n\
    \  j = 0\n  while i < s0.length\n    if s0[i] < s1[j]\n      return false\n  \
    \  elsif s0[i] == s1[j]\n      i += 1\n      j += 1\n    else\n      j += 1\n\
    \    end\n  end\n  i == s0.length\nend", "  return s0.chars.sort == s1.chars.sort\n\
    end", "  s0 = s0.split('').sort.join('')\n  s1 = s1.split('').sort.join('')\n\
    \  s0 == s1\nend", "  s0.chars.sort == s1.chars.sort\nend", "  if s0.empty? &&\
    \ s1.empty?\n    true\n  elsif s0.empty?\n    false\n  elsif s1.empty?\n    false\n\
    \  else\n    s0[0] == s1[0] && same_chars(s0[1..-1], s1[1..-1])\n  end\nend",
  "  return (s0.length - s1.length).abs < 1 && s0.split('').sort == s1.split('').sort\n\
    end", "  s0 = s0.gsub(/[^\\w]/, '').chars.sort.join\n  s1 = s1.gsub(/[^\\w]/,\
    \ '').chars.sort.join\n  s0 == s1\nend\np same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"\
    )\np same_chars.call(\"abcd\", \"dddddddabc\")\np same_chars.call(\"dddddddabc\"\
    , \"abcd\")\np same_chars.call(\"eabcd\", \"dddddddabc\")\np same_chars.call(\"\
    abcd\", \"dddddddabce\")\np same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"\
    )\np same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")", "  chars = Hash.new(0)\n\
    \  s0.each_char { |c| chars[c] += 1 }\n  s1.each_char { |c| chars[c] -= 1 }\n\
    \  chars.all? { |_k, v| v == 0 }\nend", "    # p s0\n    # p s1\n    return false\
    \ if s0.length != s1.length\n    s0_hash = Hash.new(0)\n    s1_hash = Hash.new(0)\n\
    \    s0.each_char do |ch|\n        s0_hash[ch] += 1\n    end\n    s1.each_char\
    \ do |ch|\n        s1_hash[ch] += 1\n    end\n    s0_hash.each do |k, v|\n   \
    \     return false if s1_hash[k] != v\n    end\n    return true\nend", "  s0.chars.sort\
    \ == s1.chars.sort\nend", "  s0.chars.uniq.all?{|x| s0.count(x) == s1.count(x)}\n\
    end\nsame_chars = method(:same_chars)", "  s0.chars.sort == s1.chars.sort\nend",
  "\ts0.each_char { |c| s1.sub!(c, '') }\n\ts1.empty?\nend\nsame_chars = Native(\"\
    same_chars\", \"ss\", \"b\") { |s0, s1| same_chars(s0, s1) }", "    counts = {}\n\
    \    s0.each_char { |c| counts[c] = 0 }\n    s1.each_char { |c| counts[c] = 0\
    \ }\n    s0.each_char { |c| counts[c] += 1 }\n    s1.each_char { |c| counts[c]\
    \ -= 1 }\n    return counts.values.all? { |c| c == 0 }\nend", "  # TODO: return\
    \ true if s0 and s1 have the same characters\n  # Ruby provides an easy way to\
    \ count characters in a string:\n  #   s = \"hello\"\n  #   s.count \"hel\" #\
    \ => 2\n  # Use this to complete the exercise.\n  s0.chars.uniq.each do |c|\n\
    \    return false if s0.count(c) != s1.count(c)\n  end\n  true\nend", "  (s0 +\
    \ s1).chars.sort.join =~ /#{s0.chars.sort.join}#{s1.chars.sort.join}/ ? true :\
    \ false\nend", "  is_ok = true\n  (0..(s0.length - 1)).each do |i|\n    idx =\
    \ s1.index(s0[i])\n    is_ok = false if idx.nil?\n    s1[idx] = '' if idx\n  end\n\
    \  is_ok\nend", "  chars = Hash.new(0)\n  s0.each_char do |c|\n    chars[c] +=\
    \ 1\n  end\n  s1.each_char do |c|\n    chars[c] -= 1\n  end\n  chars.values.all?(&:zero?)\n\
    end", "  s0.chars.sort == s1.chars.sort\nend", "  s0.chars.sort == s1.chars.sort\n\
    end", "  res = true\n  cs = s0.chars.reduce(Hash.new(0)) { |h, c| h[c] += 1; h\
    \ }\n  s1.chars.each do |c|\n    if cs[c]\n      cs[c] -= 1\n    else\n      res\
    \ = false\n      break\n    end\n  end\n  res\nend", "  s0 = s0.chars.sort.join\n\
    \  s1 = s1.chars.sort.join\n  s0 == s1\nend", "  return false if s0.length !=\
    \ s1.length\n  chars = s0.chars.each_with_object(Hash.new(0)) { |c, hash| hash[c]\
    \ += 1 }\n  s1.chars.each do |c|\n    if chars[c]\n      chars[c] -= 1\n    else\n\
    \      return false\n    end\n  end\n  chars.values.all? { |v| v == 0 }\nend",
  "\ts0_chars = s0.split('')\n\ts1_chars = s1.split('')\n\ts0_chars.each do |ch|\n\
    \t\ts1_chars.delete_at(s1_chars.index(ch)) if s1_chars.index(ch)\n\tend\n\treturn\
    \ true if s1_chars.length.zero?\n\tfalse\nend\nsame_chars.call(\"eabcdzzzz\",\
    \ \"dddzzzzzzzddeddabc\")\nsame_chars.call(\"abcd\", \"dddddddabc\")\nsame_chars.call(\"\
    dddddddabc\", \"abcd\")\nsame_chars.call(\"eabcd\", \"dddddddabc\")\nsame_chars.call(\"\
    abcd\", \"dddddddabce\")\nsame_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"\
    )", "  # TODO: complete!\nend", "  s0.chars.sort == s1.chars.sort\nend", "  #\
    \ raise NotImplementedError\n  a = s0.chars.uniq.sort\n  b = s1.chars.uniq.sort\n\
    \  a == b\nend", "  s0.split('').sort == s1.split('').sort\nend", "  # TODO\n\
    end", "  return s0.chars.sort == s1.chars.sort\nend", "  c0 = s0.chars.sort\n\
    \  c1 = s1.chars.sort\n  c0 == c1\nend", "  if s0.chars.sort == s1.chars.sort\n\
    \    return true\n  else\n    return false\n  end\nend", "\tresult = true\n\t\
    s0.split(\"\").each do |ch|\n\t\tif s1.count(ch) < s0.count(ch)\n\t\t\tresult\
    \ = false\n\t\t\tbreak\n\t\tend\n\tend\n\treturn result\nend", "  return false\
    \ if s0.length != s1.length\n  s0.chars.sort == s1.chars.sort\nend", "  # \u986F\
    \u7136\u8981\u505A\u6BD4\u8F03\u90FD\u5F97\u662F\u7269\u4EF6\uFF0C\u5176\u4E2D\
    \ s0 \u8981\u5148\u51FA\u73FE\u904E\u4E86\n  # \u5148\u6392\u5E8F\uFF0C\u518D\u6BD4\
    \u8F03\u5373\u53EF\n  s0.chars.sort == s1.chars.sort\nend", "  return false if\
    \ s0.length != s1.length\n  h = Hash.new(0)\n  s0.chars.each { |c| h[c] += 1 }\n\
    \  s1.chars.each { |c| h[c] -= 1 }\n  !h.values.any? { |v| v != 0 }\nend", " \
    \ return false if s0.length != s1.length\n  h = Hash.new(0)\n  s0.each_char {\
    \ |c| h[c] += 1 }\n  s1.each_char { |c| h[c] -= 1 }\n  h.values.all? { |v| v ==\
    \ 0 }\nend", "  h0 = {}\n  h1 = {}\n  s0.each_char { |c| h0[c] = (h0[c] || 0)\
    \ + 1 }\n  s1.each_char { |c| h1[c] = (h1[c] || 0) + 1 }\n  h0 == h1\nend", " \
    \ string_to_hash(s0) == string_to_hash(s1)\nend", "  # Write your code here...\n\
    end", "  s0_chars = s0.chars.sort.join\n  s1_chars = s1.chars.sort.join\n  s0_chars\
    \ == s1_chars\nend", "  return true if s0.empty?\n  return false if s1.empty?\n\
    \  c0 = s0[0]\n  c1 = s1[0]\n  if c0 == c1\n    return same_chars(s0[1..-1], s1[1..-1])\n\
    \  else\n    return same_chars(s0, s1[1..-1]) || same_chars(s0[1..-1], s1)\n \
    \ end\nend", "  arr0 = s0.chars.sort\n  arr1 = s1.chars.sort\n  return arr0 ==\
    \ arr1\nend", "  s0.split('').sort == s1.split('').sort\nend", "  s0.chars.sort\
    \ == s1.chars.sort\nend", "  (0..s0.length - 1).each do |i|\n    return false\
    \ if s0[i] != s1[i]\n  end\n  true\nend", "  s0_map = Hash.new { |h, k| h[k] =\
    \ 0 }\n  s1_map = Hash.new { |h, k| h[k] = 0 }\n  s0.each_char { |ch| s0_map[ch]\
    \ += 1 }\n  s1.each_char { |ch| s1_map[ch] += 1 }\n  s0_map == s1_map\nend", " \
    \ s0_chars = s0.chars.sort\n  s1_chars = s1.chars.sort\n  s0_chars == s1_chars\n\
    end", "  s0.chars.uniq.all? { |c| s0.count(c) == s1.count(c) }\nend", "  s0_chars\
    \ = Hash.new(0)\n  s1_chars = Hash.new(0)", "  c = s0.chars.sort\n  c == s1.chars.sort\n\
    end", "  h0 = Hash.new(0)\n  h1 = Hash.new(0)\n  (0...s0.length).each do |i|\n\
    \    h0[s0[i]] += 1\n  end\n  (0...s1.length).each do |i|\n    h1[s1[i]] += 1\n\
    \  end\n  h0 == h1\nend", "  s0 = s0.chars.sort.join\n  s1 = s1.chars.sort.join\n\
    \  s0 == s1\nend", "  # TODO: your code here\nend", "  s0.each_char do |c|\n \
    \   if s1.index(c)\n      s1[s1.index(c)] = ''\n    else\n      return false\n\
    \    end\n  end\n  true\nend", "  chars = s0.chars\n  chars.each do |c|\n    s1.delete!(c)\n\
    \  end\n  s1.empty?\nend", "\t#puts \"s0: #{s0}, s1: #{s1}\"\n\treturn false if\
    \ s0.length != s1.length\n\ts0.each_char do |ch|\n\t\treturn false if s1.count(ch)\
    \ != s0.count(ch)\n\tend\n\ttrue\nend", "  # \u5148\u7EDF\u8BA1\u4E24\u4E2A\u5B57\
    \u7B26\u4E32\u4E2D\u5B57\u7B26\u51FA\u73B0\u7684\u6B21\u6570\uFF0C\u518D\u6BD4\
    \u8F83\u4E24\u4E2A\u5B57\u7B26\u4E32\u662F\u5426\u76F8\u7B49\n  # \u65F6\u95F4\
    \u590D\u6742\u5EA6\u4E3AO(n*m)\n  count = Hash.new(0)\n  return false if s0.length\
    \ != s1.length\n  s0.each_char do |char|\n    count[char] += 1\n  end\n  s1.each_char\
    \ do |char|\n    count[char] -= 1\n  end\n  count.values.all? { |value| value\
    \ == 0 }\nend", "  # TODO: rewrite with inject\n  # h0 = Hash.new\n  # s0.each_char\
    \ do |c|\n  #   h0[c] ||= 0\n  #   h0[c] += 1\n  # end\n  # h1 = Hash.new\n  #\
    \ s1.each_char do |c|\n  #   h1[c] ||= 0\n  #   h1[c] += 1\n  # end\n  # h0 ==\
    \ h1", "  return false if s0.length != s1.length\n  return true if s0.length ==\
    \ 0 || s1.length == 0\n  return false if s0[0] != s1[0]\n  same_chars(s0[1..-1],\
    \ s1[1..-1])\nend", "  # Return true if both strings are the same length and the\
    \ characters in\n  # s0 all appear the same number of times in s1, and false otherwise.\n\
    \  return false if s0.length != s1.length\n  s0.chars.each do |c|\n    if s0.count(c)\
    \ != s1.count(c)\n      return false\n    end\n  end\n  true\nend", "  return\
    \ false if s0.length != s1.length\n  cnt0 = Counter.new\n  cnt1 = Counter.new\n\
    \  s0.each_char { |c| cnt0.add(c) }\n  s1.each_char { |c| cnt1.add(c) }\n  cnt0.comparison\
    \ == cnt1.comparison\nend", "  return s0.chars.sort == s1.chars.sort\nend", " \
    \ return false if s0.length != s1.length\n  chars = Array.new(256, 0)\n  s0.each_char\
    \ do |ch|\n    chars[ch.ord] += 1\n  end\n  s1.each_char do |ch|\n    chars[ch.ord]\
    \ -= 1\n  end\n  chars.all? { |x| x == 0 }\nend", "  chars = Hash.new(0)\n  s0.chars.each\
    \ do |c|\n    chars[c] += 1\n  end\n  s1.chars.each do |c|\n    chars[c] -= 1\n\
    \  end\n  chars.values.all? { |n| n == 0 }\nend", "  return false if s0.length\
    \ != s1.length\n  s0.chars.sort == s1.chars.sort\nend", "  ch0 = s0.chars.sort\n\
    \  ch1 = s1.chars.sort\n  ch0 == ch1\nend", "  # YOUR CODE HERE\nend", "  check_array(s0.chars.sort,\
    \ s1.chars.sort)\nend", "  count = {}\n  s0.chars.each do |ch|\n    count[ch]\
    \ ||= 0\n    count[ch] += 1\n  end\n  s1.chars.each do |ch|\n    count[ch] ||=\
    \ 0\n    count[ch] -= 1\n  end\n  count.values.all? { |v| v == 0 }\nend", "  s0\
    \ = s0.split('').sort\n  s1 = s1.split('').sort\n  s0 == s1\nend", "  # You code\
    \ here\nend", '    # return true if s0 == s1', "  return false if s0.length !=\
    \ s1.length\n  s0.chars.each do |c|\n    return false if s0.count(c) != s1.count(c)\n\
    \  end\n  true\nend", "  letters = Hash.new(0)\n  s0.each_char { |c| letters[c]\
    \ += 1 }\n  s1.each_char { |c| letters[c] -= 1 }\n  letters.values.all? { |v|\
    \ v == 0 }\nend", "  h0 = Hash.new(0)\n  h1 = Hash.new(0)\n  s0.chars.each { |c|\
    \ h0[c] += 1 }\n  s1.chars.each { |c| h1[c] += 1 }\n  return h0 == h1\nend", " \
    \ counts = Hash.new(0)\n  s0.each_char { |ch| counts[ch] += 1 }\n  s1.each_char\
    \ { |ch| counts[ch] -= 1 }\n  counts.values.all? { |v| v == 0 }\nend", "  hash\
    \ = {}\n  s0.chars.each { |char| hash[char] = true }\n  s1.chars.each { |char|\
    \ return false unless hash[char] }\n  true\nend", "  s0.chars.sort == s1.chars.sort\n\
    end\nsame_chars.call(s1, s2)", "  ss0 = s0.chars.sort\n  ss1 = s1.chars.sort\n\
    \  result = true\n  i = 0\n  j = 0\n  while i < ss0.length && j < ss1.length\n\
    \    if ss0[i] < ss1[j]\n      result = false\n      break\n    elsif ss0[i] ==\
    \ ss1[j]\n      i += 1\n      j += 1\n    else\n      j += 1\n    end\n  end\n\
    \  result && i == ss0.length\nend", "  s0.chars.sort == s1.chars.sort\nend", " \
    \ if s0.length != s1.length\n    false\n  else\n    set0 = s0.chars.sort\n   \
    \ set1 = s1.chars.sort\n    set0 == set1\n  end\nend", "  # Note: This is not\
    \ a very efficient solution, as it is making a new hash\n  # every time the function\
    \ is called (we could make the hash outside and use\n  # that).\n  # However,\
    \ we are using a hash to record character counts rather than\n  # sorting, which\
    \ is a more efficient operation.\n  h0 = {}\n  h1 = {}\n  s0.each_char do |c|\n\
    \    h0[c] = (h0[c] || 0) + 1\n  end\n  s1.each_char do |c|\n    h1[c] = (h1[c]\
    \ || 0) + 1\n  end\n  h0 == h1\nend", "  s0.size == s1.size && s0.chars.sort ==\
    \ s1.chars.sort\nend", "  s0.chars.sort == s1.chars.sort\nend", "  if (s0.chars.sort\
    \ == s1.chars.sort)\n    return true\n  else\n    return false\n  end\nend", " \
    \ s0.chars.sort == s1.chars.sort\nend", "  (0..s0.length - 1).all? do |i|\n  \
    \  s0[i] == s1[i]\n  end\nend", "  return s0.chars.sort == s1.chars.sort\nend",
  "  s0.chars.sort == s1.chars.sort\nend", "  count = Hash.new(0)\n  s0.each_char\
    \ { |c| count[c] += 1 }\n  s1.each_char { |c| count[c] -= 1 }\n  count.values.all?(&:zero?)\n\
    end\nsame_chars_p = ->(s0, s1) { same_chars(s0, s1) }", "  chars = Hash.new\n\
    \  s0.each_char do |char|\n    chars[char] = (chars[char] || 0) + 1\n  end\n \
    \ s1.each_char do |char|\n    chars[char] = (chars[char] || 0) - 1\n  end\n  chars.values.all?\
    \ { |c| c == 0 }\nend", "    return s0.chars.sort == s1.chars.sort\nend\nsame_chars_call\
    \ = method(:same_chars).to_proc", "  return s0.split('').sort == s1.split('').sort\n\
    end", "  return s0.chars.sort == s1.chars.sort\nend", "  (0..25).each do |c|\n\
    \    if s0.count(c.chr) != s1.count(c.chr)\n      return false\n    end\n  end\n\
    \  return true\nend", "  s0_counts = count_chars(s0)\n  s1_counts = count_chars(s1)\n\
    \  s0_counts.keys.all? do |char|\n    s0_counts[char] == s1_counts[char]\n  end\n\
    end", "  return false if s0.length != s1.length\n  s0.each_char do |c|\n    return\
    \ false if s0.count(c) != s1.count(c)\n  end\n  true\nend", "  char_counts0 =\
    \ char_counts(s0)\n  char_counts1 = char_counts(s1)\n  char_counts0.keys.all?\
    \ do |char|\n    char_counts0[char] == char_counts1[char]\n  end\nend", "  s0\
    \ = s0.chars.sort.join\n  s1 = s1.chars.sort.join\n  s0 == s1\nend", "  s0_map\
    \ = {}\n  s1_map = {}\n  s0.each_char { |c| s0_map[c] = 0 if s0_map[c].nil?; s0_map[c]\
    \ += 1 }\n  s1.each_char { |c| s1_map[c] = 0 if s1_map[c].nil?; s1_map[c] += 1\
    \ }\n  s0_map == s1_map\nend", "  chars = s0.split('')\n  s1.split('').each do\
    \ |char|\n    if chars.include?(char)\n      chars.delete_at(chars.index(char))\n\
    \    end\n  end\n  chars.length == 0\nend", "  count(s0) == count(s1)\nend", " \
    \ counts = Hash.new 0\n  s0.each_char { |char| counts[char] += 1 }\n  s1.each_char\
    \ { |char| counts[char] -= 1 }\n  counts.values.all? { |count| count == 0 }\n\
    end", "  # YOUR CODE HERE\nend", "  s0.chars.sort == s1.chars.sort\nend", "\t\
    # Your code here\nend", "  s0.chars.sort == s1.chars.sort\nend", "  hist = Hash.new(0)\n\
    \  s0.each_char { |c| hist[c] += 1 }\n  s1.each_char { |c| hist[c] -= 1 }\n  puts\
    \ hist.values.sum\n  hist.values.sum == 0\nend", "  return s0.chars.sort == s1.chars.sort\n\
    end", "  count = Hash.new(0)\n  (0...s0.length).each do |i|\n    count[s0[i]]\
    \ += 1\n  end\n  (0...s1.length).each do |i|\n    count[s1[i]] -= 1\n  end\n \
    \ count.all? { |_k, v| v == 0 }\nend\nsame_chars_calls = 0\nsame_chars = method(:same_chars).to_proc.curry",
  "  s0.split('').sort == s1.split('').sort\nend", "  s0.chars.sort == s1.chars.sort\n\
    end", "  s0.chars.sort == s1.chars.sort\nend", "  if s0.length != s1.length\n\
    \    return false\n  end\n  check = Hash.new(0)\n  s0.each_char do |char|\n  \
    \  check[char] += 1\n  end\n  s1.each_char do |char|\n    if check[char] == 0\n\
    \      return false\n    end\n    check[char] -= 1\n  end\n  return true\nend",
  "  return false if s0.length != s1.length\n  s0.chars.sort == s1.chars.sort\nend",
  "  (s0 + s1).chars.uniq.all? do |c|\n    s0.count(c) == s1.count(c)\n  end\nend",
  "  h0 = s0.chars.reduce(Hash.new(0)) { |h, c| h[c] += 1; h }\n  h1 = s1.chars.reduce(Hash.new(0))\
    \ { |h, c| h[c] += 1; h }\n  h0 == h1\nend", "  if s0.length != s1.length\n  \
    \  return false\n  end\n  s0_chars = s0.chars.sort\n  s1_chars = s1.chars.sort\n\
    \  0.upto(s0.length-1) do |i|\n    if s0_chars[i] != s1_chars[i]\n      return\
    \ false\n    end\n  end\n  return true\nend", "  s0.chars.sort == s1.chars.sort\n\
    end", "  raise NotImplementedError\nend", "  h0 = {}\n  h1 = {}\n  s0.each_char\
    \ { |c| h0[c] = h0[c].to_i + 1 }\n  s1.each_char { |c| h1[c] = h1[c].to_i + 1\
    \ }\n  h0 == h1\nend", "  s0.split('').each do |ch|\n    idx = s1.index(ch)\n\
    \    return false if idx.nil?\n    s1[idx] = ''\n  end\n  true\nend", "  (s0.chars.sort\
    \ == s1.chars.sort) ? true : false\nend", "  c0 = s0.chars.sort\n  c1 = s1.chars.sort\n\
    \  c0 == c1\nend", "  s0 = s0.split('').sort\n  s1 = s1.split('').sort\n  s0 ==\
    \ s1\nend", "  return false if s0.length != s1.length\n  hash = Hash.new(0)\n\
    \  s0.each_char do |c|\n    hash[c] += 1\n  end\n  s1.each_char do |c|\n    hash[c]\
    \ -= 1\n  end\n  hash.values.all? { |v| v == 0 }\nend", "  return false if s0.length\
    \ != s1.length\n  s0.each_char do |c|\n    if s1.include?(c)\n      i = s1.index(c)\n\
    \      s1[i] = ''\n    else\n      return false\n    end\n  end\n  return true\n\
    end", "  h0 = {}\n  h1 = {}\n  s0.chars.each do |c|\n    h0[c] = 0 unless h0.key?(c)\n\
    \    h0[c] += 1\n  end\n  s1.chars.each do |c|\n    h1[c] = 0 unless h1.key?(c)\n\
    \    h1[c] += 1\n  end\n  h0 == h1\nend", "  s0.each_char do |char|\n    s1.delete!(char)\n\
    \  end\n  return s1.empty?\nend", "  char_counts = Hash.new(0)\n  s0.chars.each\
    \ { |char| char_counts[char] += 1 }\n  s1.chars.each { |char| char_counts[char]\
    \ -= 1 }\n  char_counts.values.all? { |v| v == 0 }\nend", "  count0 = count_char(s0)\n\
    \  count1 = count_char(s1)\n  count0 == count1\nend", "  # TODO: implement this\
    \ method\n  s0 = s0.split('').sort.join('')\n  s1 = s1.split('').sort.join('')\n\
    \  if s0 == s1\n    return true\n  else\n    return false\n  end\nend", "  s0.length\
    \ == s1.length && s0.each_char.to_a.sort == s1.each_char.to_a.sort\nend", "  raise\
    \ \"Invalid inputs\" if s0.nil? || s1.nil?\n  s0.chars.sort == s1.chars.sort\n\
    end", "  s0.each_char { |c| return false if !s1.include?(c) }\n  true\nend", " \
    \ return false if s0.length != s1.length\n  s0.chars.sort == s1.chars.sort\nend",
  "  s0.chars.sort == s1.chars.sort\nend", "  s0.chars.sort == s1.chars.sort\nend",
  "  d0 = compute_chars(s0)\n  d1 = compute_chars(s1)\n  d0 == d1\nend", "  Hash[s0.chars.zip([0]\
    \ * s0.length)].each_key do |char|\n    return false unless s1.count(char) >=\
    \ s0.count(char)\n  end\n  true\nend", "  # Your code here\nend", "  return false\
    \ if s0.length != s1.length\n  s0.each_char do |c|\n    i = s1.index(c)\n    return\
    \ false if i.nil?\n    s1[i] = nil\n  end\n  true\nend", "  h0 = {}\n  h1 = {}\n\
    \  s0.each_char do |c|\n    h0[c] = h0[c].to_i + 1\n  end\n  s1.each_char do |c|\n\
    \    h1[c] = h1[c].to_i + 1\n  end\n  h0 == h1\nend", "  # Enter your code here.\n\
    end", "  return false if s0.length != s1.length\n  hash = Hash.new(0)\n  s0.each_char\
    \ { |c| hash[c] += 1 }\n  s1.each_char { |c| hash[c] -= 1 }\n  hash.each_value\
    \ { |v| return false if v != 0 }\n  true\nend", "  h0 = histogram(s0)\n  h1 =\
    \ histogram(s1)\n  h0 == h1\nend", "  table = {}\n  s0.each_char do |ch|\n   \
    \ table[ch] = table[ch].to_i + 1\n  end\n  s1.each_char do |ch|\n    return false\
    \ if (table[ch].to_i -= 1) < 0\n  end\n  table.values.each do |count|\n    return\
    \ false if count != 0\n  end\n  true\nend", "  charcount(s0) == charcount(s1)\n\
    end", "\treturn s0.split('').sort == s1.split('').sort\nend", "  s0 = s0.split('').sort\n\
    \  s1 = s1.split('').sort\n  s0.each_with_index do |c, i|\n    return false if\
    \ c != s1[i]\n  end\n  true\nend", "  s0.chars.sort == s1.chars.sort\nend", " \
    \ s0 = s0.split('').sort.join\n  s1 = s1.split('').sort.join\n  s0 == s1\nend",
  "  s0 = s0.chars.sort.join\n  s1 = s1.chars.sort.join\n  if s0.length == s1.length\n\
    \    i = 0\n    while i < s0.length\n      return false if s0[i] != s1[i]\n  \
    \    i += 1\n    end\n    return true\n  end\n  false\nend", "  # TODO: Implement\
    \ me!\nend", "  s0.chars.uniq.reduce(true) { |acc, c| acc &= s1.count(c) >= s0.count(c)\
    \ }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
