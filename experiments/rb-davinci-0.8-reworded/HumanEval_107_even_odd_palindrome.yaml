name: HumanEval_107_even_odd_palindrome
language: rb
prompt: "# Given a positive integer n, return an array that has the number of even\
  \ and odd\n# integer palindromes that fall within the range(1, n), inclusive.\n\
  # Example 1:\n# >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer\
  \ palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example\
  \ 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome\
  \ are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\
  # Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd\
  \ integer palindromes respectively.\ndef even_odd_palindrome(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n\
  \    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n\
  \    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n\
  \    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n\
  \    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n\
  \    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"
completions: ["  # Your Solution Here\nend", "  hash = { even: 0, odd: 0 }\n  (1..n).each\
    \ do |int|\n    hash[:even] += 1 if int.to_s == int.to_s.reverse && int.even?\n\
    \    hash[:odd] += 1 if int.to_s == int.to_s.reverse && int.odd?\n  end\n  [hash[:even],\
    \ hash[:odd]]\nend", "    count = 0\n    even = 0\n    odd = 0\n    while count\
    \ < n\n        if count.to_s == count.to_s.reverse\n            if count.even?\n\
    \                even += 1\n            else\n                odd += 1\n     \
    \       end\n        end\n        count += 1\n    end\n    even_odd = [even, odd]\n\
    end", "  count_even, count_odd = 0, 0\n  (1..n).each do |i|\n    if check_palindrome(i)\n\
    \      i.even? ? count_even += 1 : count_odd += 1\n    end\n  end\n  [count_even,\
    \ count_odd]\nend", "  odd_even_counts = Array.new(2, 0)\n  (1..n).each do |num|\n\
    \    odd_even_counts[num.to_s.reverse == num.to_s ? 0 : 1] += 1\n  end\n  odd_even_counts\n\
    end", "  even_count = 0\n  odd_count = 0\n  (1..n).each do |num|\n    num = num.to_s\n\
    \    num == num.reverse ? num.size.even? ? even_count += 1 : odd_count += 1 :\
    \ next\n  end\n  [even_count, odd_count]\nend", "  number_of_even_palindromes\
    \ = 0\n  number_of_odd_palindromes = 0\n  (1..n).each do |number|\n    number_of_even_palindromes\
    \ += 1 if number.to_s == number.to_s.reverse && number.even?\n    number_of_odd_palindromes\
    \ += 1 if number.to_s == number.to_s.reverse && number.odd?\n  end\n  [number_of_even_palindromes,\
    \ number_of_odd_palindromes]\nend", "\nend", end, '  return [0, 0] if n == 0',
  "  evens = (1..n).map(&:to_s).select { |x| x.reverse == x && x.to_i.even? }.count\n\
    \  odds = (1..n).map(&:to_s).select { |x| x.reverse == x && x.to_i.odd? }.count\n\
    \  [evens, odds]\nend", "  even = 0\n  odd = 0\n  (1..n).each do |num|\n    if\
    \ num.to_s == num.to_s.reverse\n      if num.even?\n        even += 1\n      else\n\
    \        odd += 1\n      end\n    end\n  end\n  [even, odd]\nend", "  # TODO:\
    \ Implement\nend", "  even_count = 0\n  odd_count = 0\n  p_count = 0\n  while\
    \ n != 0\n    num_array = n.to_s.split('')\n    num_length = num_array.length\n\
    \    if num_length == 1\n      p_count += 1\n    elsif num_length % 2 == 0\n \
    \     if num_array[0..(num_length / 2 - 1)] == num_array[(num_length / 2)..-1].reverse\n\
    \        p_count += 1\n      end\n    else\n      if num_array[0..(num_length\
    \ / 2 - 1)] == num_array[(num_length / 2 + 1)..-1].reverse\n        p_count +=\
    \ 1\n      end\n    end\n    n -= 1\n  end\n  (1..p_count).each do |num|\n   \
    \ if num % 2 == 0\n      even_count += 1\n    else\n      odd_count += 1\n   \
    \ end\n  end\n  [even_count, odd_count]\nend", "  even = 0\n  odd = 0\n  i = 1\n\
    \  while i <= n\n    if i.to_s == i.to_s.reverse\n      if i.even?\n        even\
    \ += 1\n      else\n        odd += 1\n      end\n    end\n    i += 1\n  end\n\
    \  [even, odd]\nend", "  even = 0\n  odd = 0\n  (1..n).each do |i|\n    if is_palindrome(i)\n\
    \      if i.even?\n        even += 1\n      else\n        odd += 1\n      end\n\
    \    end\n  end\n  [even, odd]\nend", "  even = 0\n  odd = 0\n  1.upto(n) do |num|\n\
    \    if num.to_s == num.to_s.reverse\n      num.even? ? even += 1 : odd += 1\n\
    \    end\n  end\n  [even, odd]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each\
    \ do |num|\n    if is_palindrome?(num)\n      if num.even?\n        even_count\
    \ += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n  [even_count,\
    \ odd_count]\nend", "  evens = 0\n  odds = 0\n  for i in 1..n\n    evens += 1\
    \ if is_palindrome(i) && is_even(i)\n    odds += 1 if is_palindrome(i) && is_odd(i)\n\
    \  end\n  [evens, odds]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each\
    \ do |int|\n    is_palindrome = int.to_s == int.to_s.reverse\n    if is_palindrome\n\
    \      if int.even?\n        even_count += 1\n      else\n        odd_count +=\
    \ 1\n      end\n    end\n  end\n  [even_count, odd_count]\nend\np even_odd_palindrome(3)\
    \ == [1, 2]\np even_odd_palindrome(12) == [4, 6]"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
