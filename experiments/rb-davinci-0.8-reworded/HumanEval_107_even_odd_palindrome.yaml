name: HumanEval_107_even_odd_palindrome
language: rb
prompt: "# Given a positive integer n, return an array that has the number of even\
  \ and odd\n# integer palindromes that fall within the range(1, n), inclusive.\n\
  # Example 1:\n# >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer\
  \ palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example\
  \ 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome\
  \ are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\
  # Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd\
  \ integer palindromes respectively.\ndef even_odd_palindrome(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n\
  \    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n\
  \    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n\
  \    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n\
  \    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n\
  \    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"
completions: ["  # Your Solution Here\nend", "  hash = { even: 0, odd: 0 }\n  (1..n).each\
    \ do |int|\n    hash[:even] += 1 if int.to_s == int.to_s.reverse && int.even?\n\
    \    hash[:odd] += 1 if int.to_s == int.to_s.reverse && int.odd?\n  end\n  [hash[:even],\
    \ hash[:odd]]\nend", "    count = 0\n    even = 0\n    odd = 0\n    while count\
    \ < n\n        if count.to_s == count.to_s.reverse\n            if count.even?\n\
    \                even += 1\n            else\n                odd += 1\n     \
    \       end\n        end\n        count += 1\n    end\n    even_odd = [even, odd]\n\
    end", "  count_even, count_odd = 0, 0\n  (1..n).each do |i|\n    if check_palindrome(i)\n\
    \      i.even? ? count_even += 1 : count_odd += 1\n    end\n  end\n  [count_even,\
    \ count_odd]\nend", "  odd_even_counts = Array.new(2, 0)\n  (1..n).each do |num|\n\
    \    odd_even_counts[num.to_s.reverse == num.to_s ? 0 : 1] += 1\n  end\n  odd_even_counts\n\
    end", "  even_count = 0\n  odd_count = 0\n  (1..n).each do |num|\n    num = num.to_s\n\
    \    num == num.reverse ? num.size.even? ? even_count += 1 : odd_count += 1 :\
    \ next\n  end\n  [even_count, odd_count]\nend", "  number_of_even_palindromes\
    \ = 0\n  number_of_odd_palindromes = 0\n  (1..n).each do |number|\n    number_of_even_palindromes\
    \ += 1 if number.to_s == number.to_s.reverse && number.even?\n    number_of_odd_palindromes\
    \ += 1 if number.to_s == number.to_s.reverse && number.odd?\n  end\n  [number_of_even_palindromes,\
    \ number_of_odd_palindromes]\nend", "\nend", end, '  return [0, 0] if n == 0',
  "  evens = (1..n).map(&:to_s).select { |x| x.reverse == x && x.to_i.even? }.count\n\
    \  odds = (1..n).map(&:to_s).select { |x| x.reverse == x && x.to_i.odd? }.count\n\
    \  [evens, odds]\nend", "  even = 0\n  odd = 0\n  (1..n).each do |num|\n    if\
    \ num.to_s == num.to_s.reverse\n      if num.even?\n        even += 1\n      else\n\
    \        odd += 1\n      end\n    end\n  end\n  [even, odd]\nend", "  # TODO:\
    \ Implement\nend", "  even_count = 0\n  odd_count = 0\n  p_count = 0\n  while\
    \ n != 0\n    num_array = n.to_s.split('')\n    num_length = num_array.length\n\
    \    if num_length == 1\n      p_count += 1\n    elsif num_length % 2 == 0\n \
    \     if num_array[0..(num_length / 2 - 1)] == num_array[(num_length / 2)..-1].reverse\n\
    \        p_count += 1\n      end\n    else\n      if num_array[0..(num_length\
    \ / 2 - 1)] == num_array[(num_length / 2 + 1)..-1].reverse\n        p_count +=\
    \ 1\n      end\n    end\n    n -= 1\n  end\n  (1..p_count).each do |num|\n   \
    \ if num % 2 == 0\n      even_count += 1\n    else\n      odd_count += 1\n   \
    \ end\n  end\n  [even_count, odd_count]\nend", "  even = 0\n  odd = 0\n  i = 1\n\
    \  while i <= n\n    if i.to_s == i.to_s.reverse\n      if i.even?\n        even\
    \ += 1\n      else\n        odd += 1\n      end\n    end\n    i += 1\n  end\n\
    \  [even, odd]\nend", "  even = 0\n  odd = 0\n  (1..n).each do |i|\n    if is_palindrome(i)\n\
    \      if i.even?\n        even += 1\n      else\n        odd += 1\n      end\n\
    \    end\n  end\n  [even, odd]\nend", "  even = 0\n  odd = 0\n  1.upto(n) do |num|\n\
    \    if num.to_s == num.to_s.reverse\n      num.even? ? even += 1 : odd += 1\n\
    \    end\n  end\n  [even, odd]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each\
    \ do |num|\n    if is_palindrome?(num)\n      if num.even?\n        even_count\
    \ += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n  [even_count,\
    \ odd_count]\nend", "  evens = 0\n  odds = 0\n  for i in 1..n\n    evens += 1\
    \ if is_palindrome(i) && is_even(i)\n    odds += 1 if is_palindrome(i) && is_odd(i)\n\
    \  end\n  [evens, odds]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each\
    \ do |int|\n    is_palindrome = int.to_s == int.to_s.reverse\n    if is_palindrome\n\
    \      if int.even?\n        even_count += 1\n      else\n        odd_count +=\
    \ 1\n      end\n    end\n  end\n  [even_count, odd_count]\nend\np even_odd_palindrome(3)\
    \ == [1, 2]\np even_odd_palindrome(12) == [4, 6]", "  evens = 0\n  odds = 0\n\
    \  (1..n).each do |i|\n    evens += 1 if is_palindrome?(i) && i.even?\n    odds\
    \ += 1 if is_palindrome?(i) && i.odd?\n  end\n  puts \"Input: #{n}\"\n  puts \"\
    Result: #{[evens, odds]}\"\nend", "  even = 0\n  odd = 0\n  (1..n).each do |num|\n\
    \    if is_palindrome(num)\n      odd += 1 if num.to_s.length.odd?\n      even\
    \ += 1 if num.to_s.length.even?\n    end\n  end\n  [even, odd]\nend", "  even_palindromes\
    \ = 0\n  odd_palindromes = 0\n  (1..n).each do |num|\n    reversed_num = num.to_s.reverse.to_i\n\
    \    if num == reversed_num\n      num.even? ? even_palindromes += 1 : odd_palindromes\
    \ += 1\n    end\n  end\n  [even_palindromes, odd_palindromes]\nend", "  # TODO\n\
    end", "  count_even = 0\n  count_odd = 0\n  for i in 1..n\n    if i.to_s == i.to_s.reverse\n\
    \      if i.to_s.length.even?\n        count_even += 1\n      else\n        count_odd\
    \ += 1\n      end\n    end\n  end\n  return [count_even, count_odd]\nend", " \
    \   even = 0\n    odd = 0\n    (1..n).each do |i|\n        if i.to_s == i.to_s.reverse\n\
    \            if i % 2 == 0\n                even += 1\n            else\n    \
    \            odd += 1\n            end\n        end\n    end\n    [even, odd]\n\
    end", "  even_palindromes = (1..n).count { |i| i.to_s == i.to_s.reverse && i.even?\
    \ }\n  odd_palindromes = (1..n).count { |i| i.to_s == i.to_s.reverse && i.odd?\
    \ }\n  [even_palindromes, odd_palindromes]\nend", "  evens = 0\n  odds = 0\n \
    \ (1..n).each do |number|\n    if is_palindrome?(number)\n      number.even? ?\
    \ evens += 1 : odds += 1\n    end\n  end\n  [evens, odds]\nend", "  # Your code\
    \ here\nend", "  evens = 0\n  odds = 0\n  (1..n).each do |number|\n    if is_palindrome?(number)\n\
    \      is_even?(number) ? evens += 1 : odds += 1\n    end\n  end\n  [evens, odds]\n\
    end", "  res = [0, 0]\n  (1..n).each do |num|\n    res[0] += 1 if palindrome?(num)\
    \ && num.even?\n    res[1] += 1 if palindrome?(num) && num.odd?\n  end\n  res\n\
    end", "  even = 0\n  odd = 0\n  for i in 1..n\n    if palindrome?(i)\n      if\
    \ i.to_s.length.even?\n        even += 1\n      else\n        odd += 1\n     \
    \ end\n    end\n  end\n  [even, odd]\nend", "  even_count = 0\n  odd_count = 0\n\
    \  (1..n).each do |i|\n    even_count += 1 if i.to_s == i.to_s.reverse && i.even?\n\
    \    odd_count += 1 if i.to_s == i.to_s.reverse && i.odd?\n  end\n  [even_count,\
    \ odd_count]\nend", "  evens = 0\n  odds = 0\n  (1..n).each do |num|\n    if is_palindrome?(num)\n\
    \      if num.even?\n        evens += 1\n      else\n        odds += 1\n     \
    \ end\n    end\n  end\n  [evens, odds]\nend", "  even = 0\n  odd = 0\n  (1..n).each\
    \ do |i|\n    next if i.to_s.size > 1 && i.to_s[0] == \"0\"\n    even += 1 if\
    \ palindrome?(i) && i.even?\n    odd += 1 if palindrome?(i) && i.odd?\n  end\n\
    \  [even, odd]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each do |num|\n\
    \    num = num.to_s\n    even_count += 1 if num == num.reverse && num.length.even?\n\
    \    odd_count += 1 if num == num.reverse && num.length.odd?\n  end\n  return\
    \ [even_count, odd_count]\nend", "  even_count = 0\n  odd_count = 0\n  a = 1\n\
    \  while a <= n\n    if palindrome?(a)\n      even_count += 1 if a.even?\n   \
    \   odd_count += 1 if a.odd?\n    end\n    a += 1\n  end\n  [even_count, odd_count]\n\
    end", "    x = 1\n    even = 0\n    odd = 0\n    while x <= n\n        if is_palindrome(x)\n\
    \            x.even? ? even += 1 : odd += 1\n        end\n        x += 1\n   \
    \ end\n    [even, odd]\nend", "  even_odd_palindrome_helper(n)\nend", "  arr =\
    \ (1..n).select { |i| palindrome?(i) }\n  [arr.count(&:even?), arr.count(&:odd?)]\n\
    end", "  @even_odd_palindrome_data ||= [0, 0]\n  return @even_odd_palindrome_data\
    \ if n <= 0\n  n.downto(1).each do |number|\n    @even_odd_palindrome_data[0]\
    \ += 1 if number.to_s.reverse == number.to_s && number.even?\n    @even_odd_palindrome_data[1]\
    \ += 1 if number.to_s.reverse == number.to_s && number.odd?\n  end\n  @even_odd_palindrome_data\n\
    end", end, "  count_odd, count_even = 0, 0\n  n.times do |num|\n    count_odd\
    \ += 1 if num.to_s.reverse.to_i == num\n    count_even += 1 if (num.to_s + num.to_s.reverse).to_i\
    \ == num\n  end\n  [count_even, count_odd]\nend", "\nend", "  even_palindromes\
    \ = 0\n  odd_palindromes = 0\n  (1..n).each do |i|\n    num_str = i.to_s\n   \
    \ if num_str == num_str.reverse\n      if num_str.length.even?\n        even_palindromes\
    \ += 1\n      else\n        odd_palindromes += 1\n      end\n    end\n  end\n\
    \  [even_palindromes, odd_palindromes]\nend", "  even_odd_array = [0, 0]\n  (1..n).each\
    \ do |num|\n    if num.to_s == num.to_s.reverse\n      if num.even?\n        even_odd_array[0]\
    \ += 1\n      else\n        even_odd_array[1] += 1\n      end\n    end\n  end\n\
    \  even_odd_array\nend", "  count_even_palindrome(n) + count_odd_palindrome(n)\n\
    end", "  even = 0\n  odd = 0\n  (1..n).each do |i|\n    i_string = i.to_s\n  \
    \  even += 1 if i_string == i_string.reverse && i_string.size.even?\n    odd +=\
    \ 1 if i_string == i_string.reverse && i_string.size.odd?\n  end\n  [even, odd]\n\
    end", end, "  even = 0\n  odd = 0\n  (1..n).each do |i|\n    if is_palindrome(i)\n\
    \      (i.even?) ? even += 1 : odd += 1\n    end\n  end\n  return [even, odd]\n\
    end", "  even_count = 0\n  odd_count = 0\n  (1..n).each do |i|\n    if i.to_s\
    \ == i.to_s.reverse\n      if i.to_s.length.even?\n        even_count += 1\n \
    \     else\n        odd_count += 1\n      end\n    end\n  end\n  p [even_count,\
    \ odd_count]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each do |i|\n\
    \    if is_palindrome(i)\n      i.even? ? even_count += 1 : odd_count += 1\n \
    \   end\n  end\n  [even_count, odd_count]\nend", "  even = (1..n).count { |num|\
    \ num.to_s == num.to_s.reverse && num.even? }\n  odd = (1..n).count { |num| num.to_s\
    \ == num.to_s.reverse && num.odd? }\n  [even, odd]\nend", "  #\nend", "  count_arr\
    \ = [0, 0]\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n    \
    \  if num.even?\n        count_arr[0] += 1\n      else\n        count_arr[1] +=\
    \ 1\n      end\n    end\n  end\n  count_arr\nend", "    evens = 0\n    odds =\
    \ 0\n    (1..n).each do |i|\n        if palindrome?(i)\n            if i.even?\n\
    \                evens += 1\n            else\n                odds += 1\n   \
    \         end\n        end\n    end\n    [evens, odds]\nend", "  result = []\n\
    \  (1..n).each do |i|\n    if i.to_s == i.to_s.reverse\n      result << i\n  \
    \  end\n  end\n  even = result.select { |e| e.even? }\n  odd = result.select {\
    \ |e| e.odd? }\n  [even.length, odd.length]\nend", "  p1 = p2 = 0\n  (1..n).each\
    \ do |num|\n    num = num.to_s\n    num == num.reverse ? p1 += 1 : p2 += 1\n \
    \ end\n  [p1, p2]\nend", "  even = 0\n  odd = 0\n  (1..n).each do |num|\n    if\
    \ is_palindrome(num)\n      odd += 1 if num.to_s.size.odd?\n      even += 1 if\
    \ num.to_s.size.even?\n    end\n  end\n  [even, odd]\nend", "  even = odd = 0\n\
    \  (1..n).each do |i|\n    even += 1 if i.even? && i.to_s == i.to_s.reverse\n\
    \    odd += 1 if i.odd? && i.to_s == i.to_s.reverse\n  end\n  [even, odd]\nend",
  "  count_even = 0\n  count_odd = 0\n  (1..n).each do |i|\n    if is_palindrome(i)\n\
    \      i.even? ? count_even += 1 : count_odd += 1\n    end\n  end\n  [count_even,\
    \ count_odd]\nend", "  p = {even: 0, odd: 0}\n  (1..n).to_a.map { |i| i.to_s }.each\
    \ do |num|\n    if num == num.reverse\n      num.size.even? ? p[:even] += 1 :\
    \ p[:odd] += 1\n    end\n  end\n  p.values\nend", "  e = 0\n  o = 0\n  1.upto(n)\
    \ do |i|\n    i_s = i.to_s\n    if i_s == i_s.reverse\n      if i % 2 == 0\n \
    \       e += 1\n      else\n        o += 1\n      end\n    end\n  end\n  [e, o]\n\
    end", "  even = 0\n  odd = 0\n  1.upto(n) do |num|\n    if palindrome?(num)\n\
    \      num.even? ? even += 1 : odd += 1\n    end\n  end\n  [even, odd]\nend",
  "  even = 0\n  odd = 0\n  (1..n).each do |i|\n    if (i.to_s.reverse == i.to_s)\n\
    \      if (i.to_s.length % 2 == 0)\n        even += 1\n      else\n        odd\
    \ += 1\n      end\n    end\n  end\n  return [even, odd]\nend", "  # Write your\
    \ code here\nend", "    #1.upto(n).count { |x| x.to_s == x.to_s.reverse && x.even?\
    \ } # => 4\n    #1.upto(n).count { |x| x.to_s == x.to_s.reverse && x.odd? } #\
    \ => 6\n    #[1.upto(n).count { |x| x.to_s == x.to_s.reverse && x.even? }, 1.upto(n).count\
    \ { |x| x.to_s == x.to_s.reverse && x.odd? }]\n    #[1.upto(n).count { |x| x.to_s\
    \ == x.to_s.reverse && x.even? }, n - 1.upto(n).count { |x| x.to_s == x.to_s.reverse\
    \ && x.even? }]\n    [1.upto(n).count { |x| x.to_s == x.to_s.reverse && x.even?\
    \ }, 1.upto(n).count { |x| x.to_s == x.to_s.reverse && x.odd? }]\nend", "  # create\
    \ array of all palindromes from 1 to n\n  # iterate through array, calculating\
    \ the sum of all even and odd palindromes\n  # return array containing [even,\
    \ odd]\nend", "  # it is a palindrome if n is equal to n in reverse and n has\
    \ same digit count as n in reverse\n  # n has even digit count if n.to_s.length\
    \ is even\n  # n has odd digit count if n.to_s.length is odd\n  even_palindrome_count\
    \ = 0\n  odd_palindrome_count = 0\n  (1..n).each do |i|\n    # i is a palindrome\
    \ if i == i.to_s.reverse.to_i and i.to_s.length == i.to_s.reverse.to_i.to_s.length\n\
    \    even_palindrome_count += 1 if i == i.to_s.reverse.to_i and i.to_s.length.even?\n\
    \    odd_palindrome_count += 1 if i == i.to_s.reverse.to_i and i.to_s.length.odd?\n\
    \  end\n  [even_palindrome_count, odd_palindrome_count]\nend", "    even_nums\
    \ = 0\n    odd_nums = 0\n    for i in 1..n\n        if palindrome(i)\n       \
    \     if i % 2 == 0\n                even_nums += 1\n            else\n      \
    \          odd_nums += 1\n            end\n        end\n    end\n    return [even_nums,\
    \ odd_nums]\nend", "  return [] if n.nil? || n <= 0\n  return [1, 1] if n == 1\n\
    \  even_pals = 0\n  odd_pals = 0\n  (1..n).each do |num|\n    next if num.odd?\
    \ && num != 11\n    even_pals += 1 if num.even?\n    odd_pals += 1 if num.odd?\n\
    \  end\n  [even_pals, odd_pals]\nend", "  odd = 0\n  even = 0\n  (1..n).each do\
    \ |num|\n    if palindrome?(num)\n      num.even? ? even += 1 : odd += 1\n   \
    \ end\n  end\n  [even, odd]\nend", "  count_odd = 0\n  count_even = 0\n  max_range\
    \ = n", "  arr = [0, 0]\n  (1..n).each do |number|\n    next if number % 10 ==\
    \ 0\n    if is_palindrome(number)\n      arr[0] += 1 if number.even?\n      arr[1]\
    \ += 1 if number.odd?\n    end\n  end\n  arr\nend", "  even = odd = 0\n  (1..n).each\
    \ do |x|\n    if is_palindrome(x)\n      if is_even(x)\n        even += 1\n  \
    \    else\n        odd += 1\n      end\n    end\n  end\n  [even, odd]\nend", " \
    \ even_count = 0\n  odd_count = 0\n  for i in 1..n\n    if is_palindrome(i)\n\
    \      if i % 2 == 0\n        even_count += 1\n      else\n        odd_count +=\
    \ 1\n      end\n    end\n  end\n  return [even_count, odd_count]\nend", "  even_count\
    \ = 0\n  odd_count = 0\n  (1..n).each do |i|\n    num_str = i.to_s\n    if num_str\
    \ == num_str.reverse\n      if num_str.length.even?\n        even_count += 1\n\
    \      else\n        odd_count += 1\n      end\n    end\n  end\n  [even_count,\
    \ odd_count]\nend", "  output = [0, 0]\n  (1..n).each do |num|\n    palindrome?(num)\
    \ ? output[0] += 1 : output[1] += 1\n  end\n  output\nend", "  # Write your code\
    \ here\nend", "  evens = 0\n  odds = 0\n  (1..n).each do |i|\n    if i.to_s ==\
    \ i.to_s.reverse\n      if i.even?\n        evens += 1\n      else\n        odds\
    \ += 1\n      end\n    end\n  end\n  [evens, odds]\nend", "  result = [0, 0]\n\
    \  for i in 1..n\n    if i.to_s == i.to_s.reverse\n      result[0] += 1 if i.even?\n\
    \      result[1] += 1 if i.odd?\n    end\n  end\n  result\nend", "  palindromes\
    \ = 0\n  even_palindromes = 0\n  odd_palindromes = 0\n  return [0, 0] if n ==\
    \ 0\n  (1..n).each do |number|\n    if palindrome?(number)\n      palindromes\
    \ += 1\n      number.even? ? even_palindromes += 1 : odd_palindromes += 1\n  \
    \  end\n  end\n  [even_palindromes, odd_palindromes]\nend", "  num_of_even = 0\n\
    \  num_of_odd = 0\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n\
    \      if num.even?\n        num_of_even += 1\n      else\n        num_of_odd\
    \ += 1\n      end\n    end\n  end\n  [num_of_even, num_of_odd]\nend", "  even_palindromes\
    \ = 0\n  odd_palindromes = 0\n  (1..n).each do |num|\n    even_palindromes +=\
    \ 1 if is_palindrome?(num.to_s) && is_even?(num)\n    odd_palindromes += 1 if\
    \ is_palindrome?(num.to_s) && is_odd?(num)\n  end\n  [even_palindromes, odd_palindromes]\n\
    end", "  evens = 0\n  odds = 0\n  while n > 0\n    evens += 1 if is_palindrome?(n)\
    \ && (n % 2 == 0)\n    odds += 1 if is_palindrome?(n) && (n % 2 != 0)\n    n -=\
    \ 1\n  end\n  [evens, odds]\nend", "\nend", "  x = (1..n).select{|e| e.to_s ==\
    \ e.to_s.reverse}.partition{|e| e.even?}\n  [x[0].size, x[1].size]\nend", "  even_count\
    \ = 0\n  odd_count = 0\n  (1..n).each do |i|\n    if is_palindrome(i)\n      if\
    \ i.even?\n        even_count += 1\n      else\n        odd_count += 1\n     \
    \ end\n    end\n  end\n  [even_count, odd_count]\nend", "  even_count = 0\n  odd_count\
    \ = 0\n  (1..n).each do |i|\n    # check whether the integer palindrome\n    int_pali\
    \ = is_integer_palindrome(i)\n    if int_pali\n      # check whether even or odd\n\
    \      int_pali % 2 == 0 ? even_count += 1 : odd_count += 1\n    end\n  end\n\
    \  [even_count, odd_count]\nend", "  n < 1 ? [] : n.downto(1).map(&:to_s).each_with_object([0,\
    \ 0]) { |number, result| result[number.to_i.even? ? 0 : 1] += 1 if number == number.reverse\
    \ }\nend", "  even = (1..n).map(&:to_s).count { |x| (x == x.reverse) && (x.to_i.even?)\
    \ }\n  odd = (1..n).map(&:to_s).count { |x| (x == x.reverse) && (x.to_i.odd?)\
    \ }\n  [even, odd]\nend", "  # your code here\nend", "  odd = 0\n  even = 0\n\
    \  (1..n).each do |n|\n    if palindrome?(n)\n      n.to_s.length.even? ? even\
    \ += 1 : odd += 1\n    end\n  end\n  [even, odd]\nend", "  even_palindromes, odd_palindromes\
    \ = 0, 0\n  (1..n).each do |num|\n    if is_palindrome?(num)\n      even_palindromes\
    \ += 1 if num.even?\n      odd_palindromes += 1 if num.odd?\n    end\n  end\n\
    \  return [even_palindromes, odd_palindromes]\nend", "  evens = 0\n  odds = 0\n\
    \  (1..n).each do |i|\n    if palindrome?(i)\n      i.even? ? evens += 1 : odds\
    \ += 1\n    end\n  end\n  return [evens, odds]\nend", "  evens = []\n  odds =\
    \ []\n  (1..n).each do |num|\n    if is_palindrome?(num)\n      evens << num if\
    \ num.even?\n      odds << num if num.odd?\n    end\n  end\n  [evens.count, odds.count]\n\
    end", "  if n == 1\n    [0, 1]\n  elsif n == 2\n    [1, 1]\n  else\n    m = (n\
    \ + 1) / 2\n    o = m - 1\n    e = n % 2 == 0 ? m - 1 : m\n    [e, o]\n  end\n\
    end", "  range = (1..n).to_a\n  evens = range.select { |i| palindrome?(i) && i.even?\
    \ }\n  odds = range.select { |i| palindrome?(i) && i.odd? }\n  [evens.count, odds.count]\n\
    end", "  evens = (1..n).to_a.select { |x| x.to_s == x.to_s.reverse && x.even?\
    \ }\n  odds = (1..n).to_a.select { |x| x.to_s == x.to_s.reverse && x.odd? }\n\
    \  [evens.length, odds.length]\nend", end, "  evens = 0\n  odds = 0\n  (1..n).each\
    \ do |i|\n    num = i.to_s\n    evens += 1 if num == num.reverse && i.even?\n\
    \    odds += 1 if num == num.reverse && i.odd?\n  end\n  [evens, odds]\nend",
  "  even_palindromes = (1..n).select { |i| i.to_s == i.to_s.reverse && i.even? }\n\
    \  odd_palindromes = (1..n).select { |i| i.to_s == i.to_s.reverse && i.odd? }\n\
    \  [even_palindromes.length, odd_palindromes.length]\nend", "  # TODO: implement\
    \ this function\nend", "  even_count = 0\n  odd_count = 0\n  result = []\n  (1..n).each\
    \ do |num|\n    num_str = num.to_s\n    if num_str == num_str.reverse\n      if\
    \ num_str.size.even?\n        even_count += 1\n      else\n        odd_count +=\
    \ 1\n      end\n    end\n  end\n  result.push(even_count)\n  result.push(odd_count)\n\
    \  result\nend", "  n.to_s(2).scan(/0/).size + n.to_s(2).scan(/1/).size - 1\n\
    end", "  even_odd_palindrome_helper(n, 0, 0)\nend", "  even_count = 0\n  odd_count\
    \ = 0\n  i = 1\n  while i <= n\n    if is_palindrome(i)\n      if i.even?\n  \
    \      even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n\
    \    i += 1\n  end\n  [even_count, odd_count]\nend", "  odds = 0\n  evens = 0\n\
    \  (1..n).each do |num|\n    num_string = num.to_s\n    if num_string == num_string.reverse\n\
    \      if num_string.length.even?\n        evens += 1\n      else\n        odds\
    \ += 1\n      end\n    end\n  end\n  [evens, odds]\nend", "  evens = 0\n  odds\
    \ = 0\n  (1..n).each do |num|\n    if is_palindrome?(num)\n      num.even? ? evens\
    \ += 1 : odds += 1\n    end\n  end\n  p [evens, odds]\nend", "  return \"n must\
    \ be a positive integer\" unless n.is_a?(Integer) && n > 0\n  even = 0\n  odd\
    \ = 0\n  (1..n).each do |i|\n    if is_palindrome(i)\n      if i.even?\n     \
    \   even += 1\n      else\n        odd += 1\n      end\n    end\n  end\n  [even,\
    \ odd]\nend", "  # Write your code here\nend", "  evens = (1..n).select { |i|\
    \ i.to_s == i.to_s.reverse && i.even? }\n  odds = (1..n).select { |i| i.to_s ==\
    \ i.to_s.reverse && i.odd? }\n  [evens.size, odds.size]\nend", "\nend", "  num_of_even\
    \ = 0\n  num_of_odd = 0\n  (1..n).each do |i|\n    if is_palindrome(i)\n     \
    \ num_of_even += 1 if i.even?\n      num_of_odd += 1 if i.odd?\n    end\n  end\n\
    \  [num_of_even, num_of_odd]\nend", "  # TODO: return array that contains number\
    \ of even and odd palindromes.\nend", "    even_palindrome = []\n    odd_palindrome\
    \ = []\n    (1..n).each do |val|\n        number = val.to_s\n        if number\
    \ == number.reverse\n            if val.even?\n                even_palindrome\
    \ << val\n            else\n                odd_palindrome << val\n          \
    \  end\n        end\n    end\n    return [even_palindrome.length, odd_palindrome.length]\n\
    end\np even_odd_palindrome(3)\np even_odd_palindrome(12)", "  odd_count = 0\n\
    \  even_count = 0\n  1.upto(n) do |i|\n    if i.to_s == i.to_s.reverse\n     \
    \ if i.to_s.length % 2 == 0\n        even_count += 1\n      else\n        odd_count\
    \ += 1\n      end\n    end\n  end\n  [even_count, odd_count]\nend", "  arr = []\n\
    \  for i in 1..n\n    arr << i\n  end\n  even_count = 0\n  odd_count = 0\n  arr.each\
    \ do |i|\n    if palindrome?(i)\n      if i % 2 == 0\n        even_count += 1\n\
    \      else\n        odd_count += 1\n      end\n    end\n  end\n  [even_count,\
    \ odd_count]\nend", "  raise NotImplementedError\nend", "  even_odd_hash = Hash.new\n\
    \  (1..n).each do |num|\n    even_odd_hash[num] = num.to_s == num.to_s.reverse\
    \ ? 'even' : 'odd'\n  end\n  even_odd_hash\nend", '  return 0 if n < 1', "  even_count\
    \ = 0\n  odd_count = 0\n  (1..n).each do |i|\n    even_count += 1 if palindrome?(i)\
    \ && (i % 2).zero?\n    odd_count += 1 if palindrome?(i) && !(i % 2).zero?\n \
    \ end\n  [even_count, odd_count]\nend", "  even_count = 0\n  odd_count = 0\n \
    \ (1..n).each do |number|\n    palindrome = number.to_s\n    if palindrome ==\
    \ palindrome.reverse\n      number.even? ? even_count += 1 : odd_count += 1\n\
    \    end\n  end\n  [even_count, odd_count]\nend", "  evens = []\n  odds = []\n\
    \  (1..n).each do |num|\n    evens << num if num.to_s == num.to_s.reverse && num.even?\n\
    \    odds << num if num.to_s == num.to_s.reverse && num.odd?\n  end\n  [evens.length,\
    \ odds.length]\nend", "  even_odd_palindrome_helper(n, 0, 0)\nend", "  even_number\
    \ = 0\n  odd_number = 0\n  (1..n).each do |i|\n    (even_number += 1) if is_palindrome?(i)\
    \ && i.even?\n    (odd_number += 1) if is_palindrome?(i) && i.odd?\n  end\n  return\
    \ [even_number, odd_number]\nend", "  evens = 0\n  odds = 0\n  (1..n).each do\
    \ |num|\n    num_length = num.to_s.length\n    if num_length == 1\n      odds\
    \ += 1\n    elsif num_length % 2 == 0\n      evens += 1\n    else\n      odds\
    \ += 1\n    end\n  end\n  [evens, odds]\nend", "  evens = 0\n  odds = 0\n  numbers\
    \ = []\n  (1..n).each do |num|\n    is_palindrome?(num) ? odds += 1 : evens +=\
    \ 1\n  end\n  [evens, odds]\nend", "  even = 0\n  odd = 0\n  # Your code here\n\
    \  return even, odd\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each do\
    \ |num|\n    if is_palindrome?(num)\n      if is_even?(num)\n        even_count\
    \ += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n  [even_count,\
    \ odd_count]\nend", "  evens = 0\n  odds = 0\n  (1..n).each do |num|\n    len\
    \ = num.to_s.length\n    if num.to_s[0..(len - 2)/2] == num.to_s[(len / 2)..-1].reverse\n\
    \      if num.to_s.length.even?\n        evens += 1\n      else\n        odds\
    \ += 1\n      end\n    end\n  end\n  [evens, odds]\nend\nputs \"Testing even_odd_palindrome...\"\
    \nputs even_odd_palindrome(3) == [1, 2]\nputs even_odd_palindrome(12) == [4, 6]\n\
    puts \"---------------------------------\"", "  evens = 0\n  odds = 0\n  (1..n).each\
    \ do |i|\n    if palindrome?(i)\n      if (i % 2 == 0)\n        evens += 1\n \
    \     else\n        odds += 1\n      end\n    end\n  end\n  [evens, odds]\nend",
  "  even = odd = 0\n  (1..n).each do |i|\n    i_palindrome = get_integer_palindrome(i)\n\
    \    even += 1 if is_even?(i_palindrome)\n    odd += 1 if is_odd?(i_palindrome)\n\
    \  end\n  [even, odd]\nend", "  range = 1..n\n  even_palindromes = []\n  odd_palindromes\
    \ = []\n  range.each do |i|\n    if i.to_s == i.to_s.reverse\n      if i.even?\n\
    \        even_palindromes << i\n      else\n        odd_palindromes << i\n   \
    \   end\n    end\n  end\n  [even_palindromes.length, odd_palindromes.length]\n\
    end\np even_odd_palindrome(3)", "  palindromes = 0\n  evens = 0\n  odds = 0\n\
    \  (1..n).each do |i|\n    if is_palindrome(i)\n      palindromes += 1\n     \
    \ if i.even?\n        evens += 1\n      else\n        odds += 1\n      end\n \
    \   end\n  end\n  [evens, odds]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each\
    \ do |num|\n    num_string = num.to_s\n    length = num_string.length\n    is_palindrome\
    \ = true\n    (0..length/2).each do |i|\n      unless num_string[i] == num_string[length\
    \ - i - 1]\n        is_palindrome = false\n        break\n      end\n    end\n\
    \    even_count += 1 if is_palindrome && length.even?\n    odd_count += 1 if is_palindrome\
    \ && length.odd?\n  end\n  return [even_count, odd_count]\nend\nputs \"Even Odd\
    \ Palindrome Tests: \"\nputs even_odd_palindrome(3) == [1, 2]\nputs even_odd_palindrome(12)\
    \ == [4, 6]\nputs even_odd_palindrome(0) == [0, 0]\nputs even_odd_palindrome(1)\
    \ == [0, 1]\nputs even_odd_palindrome(2) == [1, 1]\nputs even_odd_palindrome(10)\
    \ == [3, 4]\nputs even_odd_palindrome(100) == [18, 17]\nputs even_odd_palindrome(1000)\
    \ == [272, 275]\nputs even_odd_palindrome(10000) == [5042, 4963]\nputs even_odd_palindrome(99999)\
    \ == [50720, 50278]", "  even = 0\n  odd = 0\n  (1..n).each do |num|\n    if num\
    \ == 1\n      odd += 1\n    elsif num.to_s.reverse == num.to_s\n      if num.even?\n\
    \        even += 1\n      else\n        odd += 1\n      end\n    end\n  end\n\
    \  [even, odd]\nend", "  even_count = odd_count = 0\n  (1..n).each do |num|\n\
    \    next if num % 10 == 0\n    # print num.to_s.reverse.to_i == num ? \"#{num}\
    \ \" : ''\n    num.to_s.reverse.to_i == num ? (num.even? ? even_count += 1 : odd_count\
    \ += 1) : ''\n  end\n  [even_count, odd_count]\nend", "  even_count = 0\n  odd_count\
    \ = 0\n  (1..n).each do |number|\n    if palindrome?(number)\n      if number.even?\n\
    \        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n\
    \  end\n  [even_count, odd_count]\nend", "  even = 0\n  odd = 0\n  i = 1\n  while\
    \ i <= n\n    if i.to_s == i.to_s.reverse\n      if i.even?\n        even += 1\n\
    \      else\n        odd += 1\n      end\n    end\n    i += 1\n  end\n  [even,\
    \ odd]\nend", "  even_count = 0\n  odd_count = 0\n  i = 1\n  while i <= n\n  \
    \  even_count += 1 if is_palindrome(i) && is_even(i)\n    odd_count += 1 if is_palindrome(i)\
    \ && is_odd(i)\n    i += 1\n  end\n  [even_count, odd_count]\nend", "  even_count\
    \ = 0\n  odd_count = 0\n  (1..n).each do |num|\n    even_count += 1 if num.to_s\
    \ == num.to_s.reverse && num.even?\n    odd_count += 1 if num.to_s == num.to_s.reverse\
    \ && num.odd?\n  end\n  [even_count, odd_count]\nend", "  evens = 1\n  odds =\
    \ 0\n  digits = n.to_s.size\n  mid_digit = digits / 2\n  (1..mid_digit).each do\
    \ |i|\n    sub = Array.new(i, 0)\n    sub[0] = 1\n    (1..9).each do |d|\n   \
    \   sub[0] = d\n      evens += 1 if is_palindrome?(sub, digits)\n    end\n   \
    \ (0..9).each do |d|\n      (0..9).each do |o|\n        sub[0] = d\n        sub[1]\
    \ = o\n        odds += 1 if is_palindrome?(sub, digits)\n      end\n    end\n\
    \  end\n  odds += 1 if digits.odd?\n  [evens, odds]\nend", "  even_palindromes\
    \ = 0\n  odd_palindromes = 0\n  (1..n).each do |num|\n    if palindrome?(num)\n\
    \      if num.even?\n        even_palindromes += 1\n      else\n        odd_palindromes\
    \ += 1\n      end\n    end\n  end\n  [even_palindromes, odd_palindromes]\nend",
  "\nend", "  # init the even and odd counter\n  even_counter = 0\n  odd_counter =\
    \ 0\n  # loop through the range from 1 to n\n  (1..n).each do |number|\n    #\
    \ init the palindrome flag\n    is_palindrome = true\n    # generate a number\
    \ as a string and split it into an array of characters\n    number_as_array =\
    \ number.to_s.split('')\n    # loop through the array and compare characters from\
    \ opposite sides of the array\n    number_as_array.length.times do |index|\n \
    \     if number_as_array[index] != number_as_array[-index - 1]\n        is_palindrome\
    \ = false\n        break\n      end\n    end\n    # increment the counters based\
    \ on palindrome flag\n    if is_palindrome\n      if number % 2 == 0\n       \
    \ even_counter += 1\n      else\n        odd_counter += 1\n      end\n    end\n\
    \  end\n  # return an array with even and odd counter values\n  [even_counter,\
    \ odd_counter]\nend", "  evens = 0\n  odds = 0\n  (1..n).each do |num|\n    evens\
    \ += 1 if num.to_s == num.to_s.reverse && num.even?\n    odds += 1 if num.to_s\
    \ == num.to_s.reverse && num.odd?\n  end\n  [evens, odds]\nend", "  # write your\
    \ code here\nend", "  evens = 0\n  odds = 0\n  (1..n).each do |i|\n    if is_palindrome(i)\n\
    \      if i.even?\n        evens += 1\n      else\n        odds += 1\n      end\n\
    \    end\n  end\n  [evens, odds]\nend", "  even = 0\n  odd = 0\n  for i in 1..n\n\
    \    if i.to_s == i.to_s.reverse\n      if i.to_s.length % 2 == 0\n        even\
    \ += 1\n      else\n        odd += 1\n      end\n    end\n  end\n  return [even,\
    \ odd]\nend", "  evens = 0\n  odds = 0\n  1.upto(n) do |i|\n    if palindrome?(i)\n\
    \      if even?(i)\n        evens += 1\n      else\n        odds += 1\n      end\n\
    \    end\n  end\n  [evens, odds]\nend", "\nend", "  even = 0\n  odd = 0\n  (1..n).each\
    \ do |number|\n    if number.to_s == number.to_s.reverse\n      if number.even?\n\
    \        even += 1\n      else\n        odd += 1\n      end\n    end\n  end\n\
    \  [even, odd]\nend", "  even = (1..n).select { |x| x.to_s == x.to_s.reverse &&\
    \ x.even? }.size\n  odd = (1..n).select { |x| x.to_s == x.to_s.reverse && x.odd?\
    \ }.size\n  [even, odd]\nend", "  nums = (1..n).to_a\n  odds = nums.select { |num|\
    \ num.odd? && num.to_s == num.to_s.reverse }\n  evens = nums.select { |num| num.even?\
    \ && num.to_s == num.to_s.reverse }\n  [evens.count, odds.count]\nend", "  num_of_even_palindromes\
    \ = 0\n  num_of_odd_palindromes = 0\n  (1..n).each do |num|\n    if (num.to_s\
    \ == num.to_s.reverse)\n      if (num.odd?)\n        num_of_odd_palindromes +=\
    \ 1\n      else\n        num_of_even_palindromes += 1\n      end\n    end\n  end\n\
    \  [num_of_even_palindromes, num_of_odd_palindromes]\nend", "  even = 1\n  odd\
    \ = 0\n  (1..n).each do |i|\n    odd += 1 if palindrome(i) && i.odd?\n    even\
    \ += 1 if palindrome(i) && i.even?\n  end\n  [even, odd]\nend", "    evens = odds\
    \ = 0\n    (1..n).each do |i|\n        if palindrome?(i)\n            evens +=\
    \ 1 if even?(i)\n            odds += 1 if odd?(i)\n        end\n    end\n    [evens,\
    \ odds]\nend", "  # TODO: implement this\nend", "  even_count = 0\n  odd_count\
    \ = 0\n  n.times do |n|\n    if palindrome?(n + 1)\n      if (n + 1).even?\n \
    \       even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n\
    \  end\n  [even_count, odd_count]\nend", "    even_count = 0\n    odd_count =\
    \ 0\n    (1..n).each do |i|\n        even_count += 1 if is_palindrome?(i) && is_even?(i)\n\
    \        odd_count += 1 if is_palindrome?(i) && is_odd?(i)\n    end\n    [even_count,\
    \ odd_count]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each do |i|\n\
    \    even_count += 1 if palindrome_check(i) && i.even?\n    odd_count += 1 if\
    \ palindrome_check(i) && i.odd?\n  end\n  [even_count, odd_count]\nend", "  even_count\
    \ = 0\n  odd_count = 0\n  (1..n).each do |i|\n    if i.to_s == i.to_s.reverse\n\
    \      if i.to_s.length.even?\n        even_count += 1\n      else\n        odd_count\
    \ += 1\n      end\n    end\n  end\n  [even_count, odd_count]\nend", "  if n ==\
    \ 1\n    return [0, 1]\n  end\n  odd = 1\n  even = 0\n  for i in 1..n\n    if\
    \ palindrome(i)\n      if (i % 2 == 0)\n        even += 1\n      else\n      \
    \  odd += 1\n      end\n    end\n  end\n  [even, odd]\nend", "  a = (1..n).to_a\n\
    \  return a.select{|i| i.to_s == i.to_s.reverse}.length\nend", "  even = 0\n \
    \ odd = 0\n  i = 1\n  while i <= n\n    if i.to_s == i.to_s.reverse\n      if\
    \ i.to_s.length % 2 == 0\n        even += 1\n      else\n        odd += 1\n  \
    \    end\n    end\n    i += 1\n  end\n  [even, odd]\nend", "  even_odd_palindrome_internal(n,\
    \ 0, 0)\nend", "  return [0,0] if n < 1\n  evens = 0\n  odds = 0\n  (1..n).each\
    \ do |number|\n    if is_palindrome(number)\n      if number % 2 == 0\n      \
    \  evens += 1\n      else\n        odds += 1\n      end\n    end\n  end\n  [evens,\
    \ odds]\nend", "\nend", "  odd_count = 0\n  even_count = 0\n  (1..n).each do |num|\n\
    \    num_str = num.to_s\n    if num_str == num_str.reverse\n      num.even? ?\
    \ even_count += 1 : odd_count += 1\n    end\n  end\n  [even_count, odd_count]\n\
    end", end, "  # Write your code here\nend", "    even_count = 0\n    odd_count\
    \ = 0\n    (1..n).each do |i|\n        i_str = i.to_s\n        if i_str == i_str.reverse\n\
    \            if i_str.length % 2 == 0\n                even_count += 1\n     \
    \       else\n                odd_count += 1\n            end\n        end\n \
    \   end\n    return [even_count, odd_count]\nend", "  raise \"Implement the even_odd_palindrome\
    \ method\"\nend", "  odd_palindromes = (1..n).select{|num| is_palindrome?(num)\
    \ and is_odd?(num)}.size\n  even_palindromes = (1..n).select{|num| is_palindrome?(num)\
    \ and is_even?(num)}.size\n  [even_palindromes, odd_palindromes]\nend", "  even\
    \ = 0\n  odd = 0\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n\
    \      if num.even?\n        even += 1\n      else\n        odd += 1\n      end\n\
    \    end\n  end\n  [even, odd]\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each\
    \ do |num|\n    even_count += 1 if num.to_s == num.to_s.reverse && num.even?\n\
    \    odd_count += 1 if num.to_s == num.to_s.reverse && num.odd?\n  end\n  [even_count,\
    \ odd_count]\nend", "  palindromes = []\n  for i in 1..n\n    palindromes << i\
    \ if is_palindrome?(i)\n  end\n  even_palindromes = palindromes.select { |i| i.even?\
    \ }\n  odd_palindromes = palindromes.select { |i| i.odd? }\n  return [even_palindromes.length,\
    \ odd_palindromes.length]\nend", "  evens = 0\n  odds = 0\n  (1..n).each do |int|\n\
    \    evens += 1 if palindrome?(int) && int.even?\n    odds += 1 if palindrome?(int)\
    \ && int.odd?\n  end\n  [evens, odds]\nend", "  # Write your code here\nend",
  "  @even_palindrome = []\n  @odd_palindrome = []\n  (1..n).each do |num|\n    if\
    \ palindrome?(num)\n      if num.even?\n        @even_palindrome << num\n    \
    \  else\n        @odd_palindrome << num\n      end\n    end\n  end\n  [@even_palindrome.length,\
    \ @odd_palindrome.length]\nend", "  # counter = 1\n  # even = 0\n  # odd = 0\n\
    \  # until counter == n\n  #   if counter.to_s == counter.to_s.reverse\n  #  \
    \   if counter.odd?\n  #       odd += 1\n  #     else\n  #       even += 1\n \
    \ #     end\n  #   end\n  #   counter += 1\n  # end\n  # [even, odd]\n  (1..n).select\
    \ { |n| n.to_s == n.to_s.reverse }.partition(&:even?).map(&:size)\nend", "  #\
    \ TODO\nend", "  even_count = 0\n  odd_count = 0\n  (1..n).each do |num|\n   \
    \ is_palindrome = true\n    num_to_string = num.to_s\n    length = num_to_string.length\n\
    \    length.times do |i|\n      if num_to_string[i] != num_to_string[length -\
    \ i - 1]\n        is_palindrome = false\n        break\n      end\n    end\n \
    \   if is_palindrome\n      if num % 2 == 0\n        even_count += 1\n      else\n\
    \        odd_count += 1\n      end\n    end\n  end\n  [even_count, odd_count]\n\
    end", "  evens = (1..n).select { |num| num.to_s == num.to_s.reverse && num.even?\
    \ }\n  odds = (1..n).select { |num| num.to_s == num.to_s.reverse && num.odd? }\n\
    \  [evens.size, odds.size]\nend", "  # Write your code here\nend", "    arr =\
    \ (1..n).to_a\n    even = 0\n    odd = 0\n    for a in arr\n        b = a.to_s\n\
    \        if b == b.reverse\n            if a % 2 == 0\n                even +=\
    \ 1\n            else\n                odd += 1\n            end\n        end\n\
    \    end\n    [even, odd]\nend", "  palindromes = 1.upto(n).select { |num| palindrome?(num)\
    \ }\n  evens = palindromes.select { |num| num.even? }\n  odds = palindromes.select\
    \ { |num| num.odd? }\n  [evens.length, odds.length]\nend", "\nend", "  evens =\
    \ 0\n  odds = 0\n  (1..n).each do |i|\n    evens += 1 if palindrome?(i) && i.even?\n\
    \    odds += 1 if palindrome?(i) && i.odd?\n  end\n  [evens, odds]\nend", "  count_even\
    \ = 0\n  count_odd = 0\n  (1..n).each do |i|\n    count_even += 1 if is_palindrome?(i)\
    \ && (i % 2).zero?\n    count_odd += 1 if is_palindrome?(i) && (i % 2).nonzero?\n\
    \  end\n  [count_even, count_odd]\nend", "  even_count = 0\n  odd_count = 0\n\
    \  (1..n).each do |num|\n    num_string = num.to_s\n    if num_string == num_string.reverse\n\
    \      if num_string.size.even?\n        even_count += 1\n      else\n       \
    \ odd_count += 1\n      end\n    end\n  end\n  puts \"even_count = #{even_count},\
    \ odd_count = #{odd_count}\"\n  return [even_count, odd_count]\nend", "  [is_even(n),\
    \ is_odd(n)]\nend", "  [0, 0]\nend", "  count_palindrome = ->(n) { \n    n = n.to_s\n\
    \    i = 0\n    j = n.length - 1\n    while i < j\n      return false if n[i]\
    \ != n[j]\n      i += 1\n      j -= 1\n    end\n    true\n  }\n  evens = 0\n \
    \ odds = 0\n  (1..n).each do |n|\n    if count_palindrome.call(n)\n      if n.even?\n\
    \        evens += 1\n      else\n        odds += 1\n      end\n    end\n  end\n\
    \  [evens, odds]\nend", "    even_odd = [0, 0]\n    for i in 1..n\n        i_str\
    \ = i.to_s\n        if i_str == i_str.reverse\n            even_odd[1] += 1 if\
    \ i % 2 == 1\n            even_odd[0] += 1 if i % 2 == 0\n        end\n    end\n\
    \    even_odd\nend", "  even_arr = (1..n).select(&:even?)\n  odd_arr = (1..n).select(&:odd?)\n\
    \  even_palindrome = []\n  odd_palindrome = []\n  even_arr.each do |num|\n   \
    \ even_palindrome << num if num.to_s == num.to_s.reverse\n  end\n  odd_arr.each\
    \ do |num|\n    odd_palindrome << num if num.to_s == num.to_s.reverse\n  end\n\
    \  [even_palindrome.count, odd_palindrome.count]\nend", "  return [0, 0] if n\
    \ < 1\n  even_palin = (1..n).to_a.select { |e| is_palindrome?(e) && e.even? }\n\
    \  odd_palin = (1..n).to_a.select { |e| is_palindrome?(e) && e.odd? }\n  [even_palin.size,\
    \ odd_palin.size]\nend", "  [even_palindrome(n), odd_palindrome(n)]\nend", " \
    \ evens = 0\n  odds = 0\n  1.upto(n) do |num|\n    if num.to_s == num.to_s.reverse\n\
    \      if num.even?\n        evens += 1\n      else\n        odds += 1\n     \
    \ end\n    end\n  end\n  [evens, odds]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
