name: HumanEval_48_is_palindrome
language: rb
prompt: "# Checks if given string is a palindrome\n# >>> is_palindrome.call(\"\")\n\
  # true\n# >>> is_palindrome.call(\"aba\")\n# true\n# >>> is_palindrome.call(\"aaaaa\"\
  )\n# true\n# >>> is_palindrome.call(\"zbcd\")\n# false\ndef is_palindrome(text)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n\
  \    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\
  \"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"\
  aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true,\
  \ candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n\
  \    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"
completions: ["  text == text.reverse\nend", "  text == text.reverse\nend", "  text.is_a?(String)\
    \ ? text == text.reverse : false\nend", "  text.size <= 1 || (text[0] == text[-1]\
    \ && is_palindrome(text[1..-2]))\nend", "  text == text.reverse\nend", "  text\
    \ == text.reverse\nend", "  return text == text.reverse\nend", "  chars = text.chars\n\
    \  len = chars.length", "  text = text.downcase.split('')\n  text == text.reverse\n\
    end", "  return true if text.empty?\n  return text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  if text.length < 2\n    return true\n  end\n  text[0] == text[-1] &&\
    \ is_palindrome(text[1..-2])\nend", "  # TODO: implement this method\nend", " \
    \ text == text.reverse\nend", "  text.reverse == text\nend", "  return text ==\
    \ text.reverse\nend", "  i = 0\n  j = text.length-1\n  while i < j\n    return\
    \ false if text[i] != text[j]\n    i += 1\n    j -= 1\n  end\n  true\nend", " \
    \ length = text.length\n  0.upto(length/2) do |i|\n    return false if text[i]\
    \ != text[length-i-1]\n  end\n  true\nend", "  is_palindrome_index(text, 0, text.length-1)\n\
    end", "  (0...text.length/2).each do |i|\n    return false if text[i] != text[text.length\
    \ - i - 1]\n  end\n  true\nend", "  return false if text.length < 2\n  if text[0]\
    \ == text[-1]\n    is_palindrome(text[1..-2])\n  else\n    false\n  end\nend\n\
    is_palindrome = lambda { |text| text == text.reverse }", "  # complete code here\n\
    end", "  if text.length < 2\n    return true\n  elsif text[0] == text[-1]\n  \
    \  return is_palindrome(text[1..-2])\n  else\n    return false\n  end\nend", " \
    \ text.upcase!\n  text = text.gsub(/[^A-Za-z0-9]/, '')\n  text.reverse == text\n\
    end", "  (text.length / 2).times do |i|\n    return false if text[i] != text[text.length\
    \ - i - 1]\n  end\n  true\nend", "  text == text.reverse\nend", "  if text.length\
    \ <= 1\n    return true\n  else\n    if text[0] == text[-1]\n      is_palindrome(text[1..-2])\n\
    \    else\n      return false\n    end\n  end\nend", "  return false if text.length\
    \ == 0\n  return false if text.length == 1\n  return true if text.length == 2\
    \ && text[0] == text[1]\n  return true if text.length == 3 && text[0] == text[2]\n\
    \  return is_palindrome(text[1..-2]) if text[0] == text[-1]\n  false\nend", " \
    \ reversed = \"\"\n  for i in (text.length - 1).downto(0)\n    reversed += text[i]\n\
    \  end\n  return text == reversed\nend", "  # implement your is_palindrome solution\
    \ here\n  a = text.length\n  for i in (0..(a-1)/2)\n    if text[i] != text[a-1-i]\n\
    \      return false\n    end\n  end\n  return true\nend", "  text == text.reverse\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  if text.length\
    \ <= 1\n    return true\n  end\n  first = text[0]\n  last = text[-1]\n  if first\
    \ == last\n    is_palindrome(text[1..-2])\n  else\n    return false\n  end\nend",
  "  is_palindrome?(text)\nend", "  if text.length <= 1\n    return true\n  end\n\
    \  if text[0] == text[-1]\n    text = text[1..-2]\n    is_palindrome(text)\n \
    \ else\n    return false\n  end\nend", "  text == text.reverse\nend", "  (text.length\
    \ / 2).times do |n|\n    return false if text[n] != text[-n - 1]\n  end\n  true\n\
    end", "    text = text.downcase\n    text = text.gsub(/[^a-z0-9]/, '')\n    text\
    \ == text.reverse\nend", "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  text.reverse == text\nend", "  text == text.reverse\nend", "    text\
    \ = text.downcase.gsub(/\\W/,'')\n    text == text.reverse\nend", "  text.reverse\
    \ == text\nend", "  text == text.reverse\nend", "  text == text.reverse\nend",
  "  text.reverse == text\nend", "  if text.length <= 1\n    return true\n  end\n\
    \  return false if text[0] != text[-1]\n  return is_palindrome(text[1..-2])\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  text ==\
    \ text.reverse\nend", "  idx = text.length - 1\n  half = text.length / 2\n  0.upto(half).each\
    \ do |i|\n    return false if text[i] != text[idx - i]\n  end\n  true\nend", " \
    \ text.length <= 1 ||\n    text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  return text.nil? || text.empty? || is_palindrome_rec(text)\nend", " \
    \ text.reverse == text\nend", "  return true if text.length <= 1\n  text[0] ==\
    \ text[-1] && is_palindrome(text[1..-2])\nend", "  # Replace this for solution\n\
    \  text == text.reverse\nend", "  len = text.length\n  return true if len <= 1\n\
    \  text[0] == text[len - 1] && is_palindrome(text[1..len - 2])\nend", "  text\
    \ == text.reverse\nend", "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  if text.length == 0\n    return true\n  end\n  # if text is \"a\" or\
    \ \"aa\" or \"aaa\" or \"aaaa\" or \"aaaaa\"\n  if text.length % 2 == 1\n    return\
    \ false\n  end\n  if text.length > 1\n    if text[0] == text[-1]\n      # if front\
    \ == back, then strip them off, check if\n      # rest of the string is a palindrome\n\
    \      return is_palindrome(text[1..-2])\n    else\n      return false\n    end\n\
    \  end\nend", "  return false if text.length <= 1\n  return true if text.length\
    \ == 2 && text[0] == text[1]\n  return false if text[0] != text[-1]\n  is_palindrome(text[1..-2])\n\
    end", "  text == text.reverse\nend", "  if text.length <= 1\n    return true\n\
    \  end\n  if text[0] == text[-1]\n    return is_palindrome(text[1..-2])\n  else\n\
    \    return false\n  end\nend", "  text.reverse == text\nend", "  (text.length\
    \ < 2) ||\n  (text[0] == text[-1] && is_palindrome(text[1..-2]))\nend", "  length\
    \ = text.length\n  0.upto(length/2) do |i|\n    return false if text[i] != text[length-i-1]\n\
    \  end\n  true\nend", "  (text.length <= 1) || (text[0] == text[-1] && is_palindrome(text[1..-2]))\n\
    end", "  return true if text.length == 0\n  return true if text.length == 1\n\
    \  text[0] == text[-1] ? is_palindrome(text[1..-2]) : false\nend", "  text.length\
    \ <= 1 || (text[0] == text[-1] && is_palindrome(text[1..-2]))\nend", "  if text.length\
    \ <= 1\n    return true\n  end\n  first = text[0]\n  last = text[-1]\n  if first\
    \ == last\n    is_palindrome(text[1..-2])\n  else\n    return false\n  end\nend",
  "  text == text.reverse\nend", "  text == text.reverse\nend", "  text.reverse ==\
    \ text\nend", "  text == text.reverse\nend", "  # ...\nend", "    if text.length\
    \ <= 1\n        return true\n    else\n        head = text[0]\n        tail =\
    \ text[-1]\n        return head == tail && is_palindrome(text[1...-1])\n    end\n\
    end", "  return text == text.reverse\nend", "  text == text.reverse\nend", " \
    \ text == text.reverse\nend", "  # text == text.reverse\n  array = text.chars\n\
    \  array.each_with_index do |char, i|\n    return false if array[i] != array[-(i\
    \ + 1)]\n  end\n  true\nend", "  is_palindrome = true\n  text_length = text.length\n\
    \  until text_length <= 1\n    if text[0] != text[text_length - 1]\n      is_palindrome\
    \ = false\n      break\n    end\n    text_length -= 2\n    text = text[1..-2]\n\
    \  end\n  is_palindrome\nend", "  return text.eql?(text.reverse)\nend", "  text\
    \ == text.reverse\nend", "  text = text.downcase\n  (0...text.length / 2).all?\
    \ { |i| text[i] == text[-i - 1] }\nend", "  return text == text.reverse\nend",
  "  text == text.reverse\nend", "  text == text.reverse\nend", "  if text.length\
    \ < 2\n    return true\n  elsif text[0] == text[-1]\n    return is_palindrome(text[1..-2])\n\
    \  else\n    return false\n  end\nend", "  text = text.downcase\n  for i in 0..(text.length\
    \ - 1)\n    if text[i] != text[text.length - 1 - i]\n      return false\n    end\n\
    \  end\n  return true\nend", "  text.reverse == text\nend", "  return text ==\
    \ text.reverse\nend", "  text.reverse == text\nend", "  text == text.reverse\n\
    end", "  # a simple palindrome must be even numbered\n  # so if length is odd,\
    \ there is no chance it\n  # could be a palindrome\n  return false if text.length.odd?",
  "  return false if text.nil? || text.empty?\n  return false if text.length == 1\n\
    \  return true if text.length == 2 && text[0] == text[1]\n  return false if text[0]\
    \ != text[-1]\n  is_palindrome(text[1..-2])\nend", "  # Write your code here\n\
    end", "  text == text.reverse\nend", "  is_palindrome = -> text do\n    reversed\
    \ = -> text do\n      text.reverse\n    end\n    text == reversed.call(text)\n\
    \  end\n  is_palindrome.call(text)\nend", "  text == text.reverse\nend", "   \
    \ text == text.reverse\nend", "  text == text.reverse\nend", "  lower_case_text\
    \ = text.downcase\n  text_length = lower_case_text.length\n  return true if text_length\
    \ < 2\n  middle_index = text_length / 2\n  (0...middle_index).each do |index|\n\
    \    return false if lower_case_text[index] != lower_case_text[text_length - index\
    \ - 1]\n  end\n  true\nend", "    palindrome?(text)\nend", "  text == text.reverse\n\
    end", "  text == text.reverse\nend", "  # TODO: return true if text is a palindrome,\
    \ false otherwise\n  text == text.reverse\nend", "  case text.length\n  when 0,\
    \ 1\n    true\n  else\n    text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    \  end\nend", "  start = 0\n  finish = text.length - 1\n  while start < finish\n\
    \    if text[start] != text[finish]\n      return false\n    end\n    start +=\
    \ 1\n    finish -= 1\n  end\n  return true\nend", "  # palindrome check here\n\
    \  true\nend", "    text == text.reverse\nend", "  text.length.times do |i|\n\
    \    return false if text[i] != text[-i - 1]\n  end\n  true\nend", "  for i in\
    \ 0..(text.length/2)\n    if text[i] != text[-(i+1)]\n      return false\n   \
    \ end\n  end\n  return true\nend", "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  if text.length <= 1\n    return true\n  else\n    if text[0] == text[-1]\n\
    \      return is_palindrome(text[1..-2])\n    else\n      return false\n    end\n\
    \  end\nend", "  text.reverse == text\nend", "  text.reverse == text\nend", " \
    \ clean_text = text.gsub(/\\W/, '').downcase\n  clean_text == clean_text.reverse\n\
    end", "    !text.empty? && text.reverse == text\nend", "  text == text.reverse\n\
    end", "  text == text.reverse\nend", "  recursive_palindrome?(text, 0, text.length\
    \ - 1)\nend", "  text == text.reverse\nend", "  text = text.downcase.gsub(/\\\
    W/, '')\n  if text.length <= 1\n    return true\n  elsif text[0] == text[-1]\n\
    \    return is_palindrome(text[1..-2])\n  else\n    return false\n  end\nend",
  "  text == text.reverse\nend", "  head = 0\n  tail = text.length - 1\n  while head\
    \ < tail\n    return false if text[head] != text[tail]\n    head += 1\n    tail\
    \ -= 1\n  end\n  true\nend", "    if text.length == 0\n        return true\n \
    \   end\n    i = 0\n    j = text.length - 1\n    while i < j do\n        if text[i]\
    \ != text[j]\n            return false\n        end\n        i += 1\n        j\
    \ -= 1\n    end\n    return true\nend", "  text == text.reverse\nend", "  text.reverse\
    \ == text\nend", "  str = text.split('')\n  return true if str.length <= 1\n \
    \ return false if str.shift != str.pop\n  is_palindrome(str.join)\nend", "  text\
    \ == text.reverse\nend", "  return true if text.empty?\n  return false if text[0]\
    \ != text[-1]\n  is_palindrome(text[1..-2])\nend", "  return text == text.reverse\n\
    end", "  text == text.reverse\nend", "  n = text.length\n  (0...n/2).each do |i|\n\
    \    return false if text[i] != text[n-i-1]\n  end\n  true\nend", "  length =\
    \ text.length\n  (0...length / 2).each do |i|\n    return false if text[i] !=\
    \ text[length - i - 1]\n  end\n  true\nend", "  text = text.downcase\n  text ==\
    \ text.reverse\nend", "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  stack = Stack.new\n  queue = Queue.new", "  text == text.reverse\nend",
  "  return true if text.empty?\n  return text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  return true if text.empty?\n  text.downcase!\n  text.gsub!(/[^a-z0-9]/,\
    \ '')\n  return true if text.size == 1\n  i = 0\n  j = text.size - 1\n  while\
    \ (i < j)\n    if text[i] != text[j]\n      return false\n    end\n    i += 1\n\
    \    j -= 1\n  end\n  return true\nend", "  text.empty? || (text[0] == text[-1]\
    \ && is_palindrome(text[1..-2]))\nend", "  head = 0\n  tail = text.length - 1\n\
    \  while head < tail\n    return false if text[head] != text[tail]\n    head +=\
    \ 1\n    tail -= 1\n  end\n  true\nend", "  is_palindrome = true\n  text.each_char.with_index\
    \ do |char, index|\n    if index < text.length / 2\n      break if is_palindrome\
    \ == false\n      is_palindrome = char == text[text.length - 1 - index]\n    end\n\
    \  end\n  is_palindrome\nend", "  return true if text.length <= 1\n  return is_palindrome(text[1...-1])\
    \ if text[0] == text[-1]\n  false\nend", "  text == text.reverse\nend", "  text\
    \ == text.reverse\nend", "  text == text.reverse\nend", "  return true if text.length\
    \ == 0\n  text == text.reverse\nend", "  left = 0\n  right = text.length - 1\n\
    \  # TODO: Write a loop that walks through the text and\n  # checks to see if\
    \ the text is a palindrome\n  while right > left do\n    if text[left] != text[right]\n\
    \      return false\n    end\n    left += 1\n    right -= 1\n  end\n  return true\n\
    end", "  return true if text.length < 2\n  if text[0] == text[-1]\n    is_palindrome(text[1..-2])\n\
    \  else\n    false\n  end\nend", "  text.length <= 1 ||\n    (text[0] == text[-1]\
    \ && is_palindrome(text[1..-2]))\nend", "  text == text.reverse\nend", '  return
    true if text.length == 0', "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  # your code here\nend", "  # Your code here\nend", "  text == text.reverse\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  size =\
    \ text.size\n  (0...size/2).each do |i|\n    if text[i] != text[size-i-1]\n  \
    \    return false\n    end\n  end\n  return true\nend", "  return true if text.length\
    \ == 0\n  return true if text.length == 1\n  text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  if text.length == 0\n    return true\n  end\n  if text[0] == text[-1]\n\
    \    return is_palindrome(text[1...-1])\n  else\n    return false\n  end\nend",
  "  if (text.length == 0)\n    return true\n  end\n  lower_case_text = text.downcase\n\
    \  end_of_array = lower_case_text.length - 1\n  middle_index = (lower_case_text.length\
    \ - 1) / 2\n  for index in 0..middle_index\n    if (lower_case_text[index] !=\
    \ lower_case_text[end_of_array - index])\n      return false\n    end\n  end\n\
    \  return true\nend", "  !text.nil? && text.length > 0 &&\n    text.length ==\
    \ 1 || text.length == 2 && text[0] == text[1] ||\n    text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  l, r = 0, text.length - 1\n  while l < r\n    return false if text[l]\
    \ != text[r]\n    l += 1\n    r -= 1\n  end\n  true\nend", "  forward_iterator\
    \ = 0\n  backward_iterator = text.length - 1\n  while forward_iterator < backward_iterator\n\
    \    return false if text[forward_iterator] != text[backward_iterator]\n    forward_iterator\
    \ += 1\n    backward_iterator -= 1\n  end\n  true\nend", "  return text.empty?\
    \ if text.empty?\n  text[0] == text[-1] && is_palindrome(text[1..-2])\nend", " \
    \ front = 0\n  back = text.length - 1\n  while front < back\n    return false\
    \ if text[front] != text[back]\n    front += 1\n    back -= 1\n  end\n  true\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  return\
    \ true if text.length == 0\n  (0...text.length/2).each do |i|\n    if text[i]\
    \ != text[-i-1]\n      return false\n    end\n  end\n  return true\nend", "  puts\
    \ \"Implement is_palindrome(text)\"\nend", "  # TODO\nend", "  if text.length\
    \ == 0 or text.length == 1\n    return true\n  end\n  is_palindrome(text[1..-2])\
    \ and text[0] == text[-1]\nend", "  text.reverse == text\nend", "  text == text.reverse\n\
    end", "  text.reverse == text\nend", "  text == text.reverse\nend", "  reverse_text\
    \ = text.reverse\n  text == reverse_text\nend", "  return true if text.length\
    \ <= 1\n  text[0] == text[-1] ? is_palindrome(text[1..-2]) : false\nend", "  text\
    \ == text.reverse\nend", "  text == text.reverse\nend", "  return true if text.length\
    \ <= 1\n  text[0] == text[-1] ? is_palindrome(text[1..-2]) : false\nend", "  text.reverse\
    \ == text\nend", "  puts \":text: #{text}\"\n  return true if text.length == 0\n\
    \  return true if text.length == 1", "  if text.length < 2\n    return true\n\
    \  end\n  if text[0] == text[-1]\n    return is_palindrome(text[1..-2])\n  else\n\
    \    return false\n  end\nend", "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  t = text.dup\n  0.upto(t.length / 2 - 1) do |i|\n    c = t[i]\n    t[i]\
    \ = t[-i - 1]\n    t[-i - 1] = c\n  end\n  text == t\nend", "  (0...text.length\
    \ / 2).all? { |i| text[i] == text[-i - 1] }\nend", "  if text.length <= 1\n  \
    \  return true\n  end\n  if text[0] == text[-1]\n    is_palindrome(text[1..-2])\n\
    \  else\n    return false\n  end\nend", "  return true if text.empty?\n  return\
    \ text[0] == text[-1] && is_palindrome(text[1..-2])\nend", "  text =~ /^(.)(.*)(\\\
    1)$/ && text[1..-2] =~ /^(.)(.*)(\\1)$/ && text[2..-3] =~ /^(.)(.*)(\\1)$/\nend",
  "  if text.length <= 1\n    return true\n  else\n    if text[0] == text[-1]\n  \
    \    text = text[1..-2]\n      return is_palindrome(text)\n    else\n      return\
    \ false\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
