name: HumanEval_66_digitSum
language: rb
prompt: "# Task\n# Write a function that takes a string as input and returns the sum\
  \ of the upper characters only'\n# ASCII codes.\n# Examples:\n# >>> digitSum.call(\"\
  \")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n\
  # 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n\
  # 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n\
  \    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n\
  \    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"\
  abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131,\
  \ candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"\
  ))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327,\
  \ candidate.call(\"You arE Very Smart\"))\n  end\nend\n"
completions: ["  puts (s.delete(\"a-z\").bytes.map { |byte| byte - 'A'.ord + 1 }.sum)\n\
    end\ndigitSum(\"woArBld\")", "  return 0 if s.empty?\n  s.sum { |c| c.ord if c\
    \ == c.upcase }\nend", "  s.chars.reduce(0) { |a, e| e =~ /[A-Z]/ ? a + e.ord\
    \ : a}\nend", "  total = 0\n  s.each_char { |c| total += c.ord if c.ord.between?(65,\
    \ 90) }\n  total\nend", "  sum = 0\n  s.scan(/[A-Z]/).each { |i| sum += i.ord\
    \ }\n  sum\nend", "  s.chars.select { |c| c.match(/[A-Z]/) }.map { |c| c.ord }.sum\n\
    end", "  s.split('').select { |c| c =~ /[A-Z]/ }.map { |c| c.ord }.sum\nend",
  "  s.gsub(/[^A-Z]/, '').bytes.reduce(:+)\nend", "  s.chars.reduce(0) { |sum, c|\
    \ sum + c.ord - 96 if c.upcase == c } || 0\nend", "  s.chars.map{|v| v.ord}.select{|v|\
    \ (65..90).cover?(v)}.sum\nend\np digitSum(\"\")# 0\np digitSum(\"abAB\")# 131\n\
    p digitSum(\"abcCd\")# 67\np digitSum(\"helloE\")# 69\np digitSum(\"woArBld\"\
    )# 131\np digitSum(\"aAaaaXa\")# 153", "  s.sum{|c| c.ord if c.ord >= 65 && c.ord\
    \ <= 90}\nend", "  s.chars.map { |c| c.sum == 32 ? 0 : c.sum }.reduce(:+)\nend",
  "  a = s.split('')\n  b = a.map(&:ord)\n  c = b.select { |x| x >= 65 && x <= 90\
    \ }\n  d = c.inject(0, :+)\n  return d\nend", "  s.each_byte.inject(0) { |sum,\
    \ n| n >= 65 && n <= 90 ? sum + n : sum }\nend", "  s.upcase.gsub(/[^A-Z]/, '').split('').map\
    \ { |c| c.ord }.reduce(:+)\nend", "  s.upcase.bytes.sum\nend", "  s.chars.map{|x|\
    \ x.sum}.reduce(:+)\nend", "    s.each_char.sum{|x| x.ord>96&&x.ord<123 ? x.ord-32\
    \ : 0}\nend\nputs digitSum(\"\")\nputs digitSum(\"abAB\")\nputs digitSum(\"abcCd\"\
    )\nputs digitSum(\"helloE\")\nputs digitSum(\"woArBld\")\nputs digitSum(\"aAaaaXa\"\
    )", "  sum = 0\n  s.chars.each do |ch|\n    ascii = ch.ord\n    if ascii >= 65\
    \ && ascii <= 90\n      sum += ascii\n    end\n  end\n  sum\nend", "  sum = 0\n\
    \  s.chars.each do |char|\n    sum += char.ord if char =~ /[A-Z]/\n  end\n  sum\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
