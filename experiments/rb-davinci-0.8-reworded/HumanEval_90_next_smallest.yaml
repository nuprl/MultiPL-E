name: HumanEval_90_next_smallest
language: rb
prompt: "# You are given an array of integers.\n# Write a function next_smallest()\
  \ that returns the 2nd smallest element of the array.\n# Return nil if there is\
  \ no such element.\n# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5,\
  \ 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1,\
  \ 1])\n# nil\ndef next_smallest(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n\
  \    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1,\
  \ 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil,\
  \ candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1,\
  \ candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n\
  \    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"
completions: ["  return nil if lst.size < 2\n  return nil if lst.uniq.size == 1\n\
    \  lst.uniq.sort.reverse[1]\nend", "    lst.empty? ? nil : lst.sort.uniq[1]\n\
    end", "  if lst.size < 2\n    return nil\n  end\n  if lst.size == 2\n    return\
    \ nil if lst[0] == lst[1]\n    return lst[0] if lst[0] < lst[1]\n    return lst[1]\
    \ if lst[1] < lst[0]\n  end\n  arr = lst.sort\n  arr[1]\nend", "  lst.sort.uniq[1]\n\
    end", "    sorted_lst = lst.sort\n    if sorted_lst.uniq.length > 1\n        return\
    \ sorted_lst[1]\n    else\n        return nil\n    end\nend", "  lst = lst.dup\n\
    \  lst.delete_at(lst.index(lst.min))\n  lst.min\nend", "  return nil if lst.empty?\n\
    \  lst.uniq.sort[1]\nend", "  nil\nend", "  return nil if lst.empty?\n  lst.uniq.sort[1]\n\
    end", "  lst = lst.uniq\n  return nil if lst.empty?\n  return nil if lst.length\
    \ < 2\n  lst.sort[1]\nend", "  return nil if lst.size <= 1\n  lst.min == lst.max\
    \ ? nil : lst.uniq.sort[1]\nend", '  return nil if lst.length < 2', "  lst.sort!\n\
    \  len = lst.length\n  len > 1 ? lst[1] : nil\nend", "  lst.sort!\n  lst.uniq!\n\
    \  return nil if lst.length < 2\n  lst[1]\nend", "\tnum = lst.sort\n\tif num.length\
    \ < 2\n\t\treturn nil\n\telse\n\t\tsmall = num[0]\n\t\tsmaller = num[1]\n\t\t\
    for i in num\n\t\t\tif i > small\n\t\t\t\tif i <= smaller\n\t\t\t\t\tsmaller =\
    \ i\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif smaller == small\n\t\t\treturn nil\n\
    \t\telse\n\t\t\treturn smaller\n\t\tend\n\tend\nend", "  lst.sort!\n  lst.uniq!\n\
    \  lst[1]\nend", "  # YOUR CODE HERE\nend", "    current_smallest = nil\n    next_smallest\
    \ = nil\n    lst.each { |element|\n        if current_smallest == nil\n      \
    \      current_smallest = element\n        elsif next_smallest == nil\n      \
    \      if element < current_smallest\n                next_smallest = current_smallest\n\
    \                current_smallest = element\n            elsif element > current_smallest\n\
    \                next_smallest = element\n            end\n        elsif element\
    \ < current_smallest\n            next_smallest = current_smallest\n         \
    \   current_smallest = element\n        elsif element > current_smallest && element\
    \ < next_smallest\n            next_smallest = element\n        end\n    }\n \
    \   return next_smallest\nend", "    lst.sort!\n    lst[1] || nil\nend", "  output\
    \ = lst.uniq.sort[1]\n  if output == nil\n    return nil\n  else\n    return output\n\
    \  end\nend", "  sorted = lst.sort\n  uniq = sorted.uniq\n  return uniq[1] if\
    \ uniq.length > 1\n  nil\nend", "  lst.uniq.sort[1]\nend", "  return nil if lst.length\
    \ < 2\n  uniq_lst = lst.uniq\n  return nil if uniq_lst.length < 2\n  (1..uniq_lst.length-1).to_a.map\
    \ { |x| uniq_lst[x] }.min\nend", "  min = lst.min\n  case lst.count { |x| x ==\
    \ min }\n  when 0\n    lst.min\n  when 1\n    lst.find { |x| x > min }\n  else\n\
    \    nil\n  end\nend", "  lst.uniq.length < 2 ? nil : lst.uniq.sort[1]\nend",
  "  return nil if lst.length < 2\n  lst.sort[1]\nend", "  lst.sort[1]\nend", "  index_min\
    \ = nil\n  index_min2 = nil\n  return nil if lst.empty?\n  lst.each_with_index\
    \ do |e, i|\n    if index_min.nil? || lst[index_min] > e\n      index_min2 = index_min\n\
    \      index_min = i\n    elsif (index_min2.nil? || lst[index_min2] > e) && lst[index_min]\
    \ != e\n      index_min2 = i\n    end\n  end\n  lst[index_min2]\nend", "  new_list\
    \ = lst.sort[1]\n  if lst.length < 2\n    nil\n  elsif lst.length == 2\n    if\
    \ lst[0] == lst[1]\n      nil\n    else\n      new_list\n    end\n  else\n   \
    \ new_list\n  end\nend", "  lst.sort!\n  if lst.length == 1\n    nil\n  elsif\
    \ lst.length == 2\n    if lst[0] == lst[1]\n      nil\n    else\n      lst[1]\n\
    \    end\n  else\n    n = lst.shift\n    for i in 0..lst.length-1\n      if lst[i]\
    \ > n\n        return lst[i]\n      end\n    end\n    nil\n  end\nend", "  return\
    \ nil if lst.empty?\n  return nil if lst.length == 1\n  return nil if lst.uniq.length\
    \ == 1\n  lst.uniq.sort[1]\nend", "  lst.sort.uniq[1]\nend", "    if lst.length\
    \ < 2\n        return nil\n    end\n    lst.sort!\n    min = lst[0]\n    index\
    \ = 1\n    while index < lst.length\n        if lst[index] > min\n           \
    \ return lst[index]\n        end\n        index += 1\n    end\n    return nil\n\
    end", "  return nil if lst.empty?\n  _, result = lst.sort.slice_when { |a, b|\
    \ a != b }.map { |a| a.size }.minmax\n  result == 1 ? nil : lst.sort[1]\nend",
  "  return nil if lst.length < 2\n  lst = lst.sort.uniq\n  lst[1]\nend", "\tmin =\
    \ lst.min\n\tmin2 = lst.sort.uniq[1]\n\tif lst.length == 0\n\t\tnil\n\telsif lst.length\
    \ == 1\n\t\tnil\n\telsif lst.length == 2\n\t\tif lst[0] == lst[1]\n\t\t\tnil\n\
    \t\telse\n\t\t\tmin2\n\t\tend\n\telse\n\t\tif min == min2\n\t\t\tnil\n\t\telse\n\
    \t\t\tmin2\n\t\tend\n\tend\nend", "    lst.shift\n    lst.sort!.uniq!\n    lst[0]\n\
    end\np next_smallest([1, 2, 3, 4, 5])\np next_smallest([5, 1, 4, 3, 2])\np next_smallest([])\n\
    p next_smallest([1, 1])", "  lst = lst.sort\n  return nil if lst.uniq.length ==\
    \ 1\n  lst.uniq[1]\nend", "  lst.sort[1] || nil\nend", "  return nil if lst.empty?\n\
    \  lst.sort[1]\nend", "    new_lst = lst.sort()\n    return new_lst[1]\nend",
  "\tif lst.length == 0\n\t\treturn nil\n\telsif lst.length == 1\n\t\treturn nil\n\
    \telse\n\t\tlst.sort!\n\t\tlst.each_with_index do |e, i|\n\t\t\tif lst[i+1] !=\
    \ e\n\t\t\t\treturn lst[i+1]\n\t\t\tend\n\t\tend\n\tend\nend", "  return nil if\
    \ lst.empty? || lst.uniq.size == 1\n  lst.sort[1]\nend", "  lst = lst.sort\n \
    \ lst[1] || nil\nend", "  if lst.nil? || lst.length < 2\n    return nil\n  end\n\
    \  # sort the array and return the second element\n  lst.sort[1]\nend", "  # TODO:\
    \ your code here\nend", "\tlst.sort.each_with_index do |el, idx|\n\t\tif lst.sort[idx]\
    \ != lst.sort[idx + 1]\n\t\t\treturn lst.sort[idx + 1]\n\t\tend\n\tend\n\treturn\
    \ nil\nend", "  return nil if lst.length < 2\n  sorted = lst.sort\n  return nil\
    \ if sorted[0] == sorted[1]\n  sorted[1]\nend", "  lst.sort.uniq[1]\nend", " \
    \ smallest = lst.min\n  lst.each do |num|\n    return num if num > smallest &&\
    \ num < lst.max\n  end\n  nil\nend", "  lst.each_with_index do |num, idx|\n  \
    \  if lst[idx+1] && num < lst[idx+1]\n      return lst[idx+1]\n    end\n  end\n\
    \  nil\nend", "  #\n  # your code here\n  #\nend", "  return nil if lst.size <\
    \ 2\n  return nil if lst.uniq.size == 1\n  min, min2 = 2**32, 2**32\n  lst.each\
    \ do |el|\n    min = el if el < min\n    min2 = el if el < min2 && el > min\n\
    \  end\n  min2\nend", "  return nil if lst.empty?\n  return nil if lst.length\
    \ == 1\n  # remove duplicates if they exist\n  lst.uniq!\n  return nil if lst.length\
    \ == 1\n  # sort the list\n  lst.sort!\n  # return the 2nd element\n  lst[1]\n\
    end", "\tlst.sort!\n\tlst[1]\nend", '  return nil if lst.empty?', "  return nil\
    \ if lst.empty?\n  return nil if lst.uniq.length < 2\n  lst.sort[1]\nend", " \
    \ if lst.length == 0\n    return nil\n  elsif lst.length == 1\n    return nil\n\
    \  else\n    lst.sort!\n    smallest = lst[0]\n    smallest_index = 0\n    lst.each_with_index\
    \ do |e, i|\n      if e < smallest\n        smallest = e\n        smallest_index\
    \ = i\n      end\n    end\n    lst.delete_at(smallest_index)\n    return next_smallest(lst)\n\
    \  end\nend", "    return nil if lst.empty?\n    smallest = lst[0]\n    second_smallest\
    \ = nil\n    lst.each do |i|\n        if i < smallest\n            second_smallest\
    \ = smallest\n            smallest = i\n        elsif second_smallest == nil or\
    \ i < second_smallest\n            second_smallest = i\n        end\n    end\n\
    \    second_smallest\nend", "  # your code here\nend", "  return nil if lst.empty?\n\
    \  uniq_lst = lst.uniq\n  uniq_lst.sort!\n  return nil if uniq_lst.length == 1\n\
    \  return uniq_lst[1]\nend", "  sorted = lst.sort\n  return nil if sorted.length\
    \ < 2\n  sorted[1]\nend", "  lst.sort[1] || nil\nend", "  lst.sort!\n  lst.size\
    \ > 1 ? lst[1] : nil\nend\np next_smallest([1, 2, 3, 4, 5])\np next_smallest([5,\
    \ 1, 4, 3, 2])\np next_smallest([])\np next_smallest([1, 1])", "  return nil if\
    \ lst.empty?\n  return nil if lst.uniq.size == 1\n  lst.sort!\n  lst[1]\nend",
  '  sort_list = lst.sort', "  lst.sort[1]\nend", "  lst.sort!\n  lst.each_with_index\
    \ do |num, index|\n    if index + 1 <= lst.length - 1\n      if lst[index] !=\
    \ lst[index + 1]\n        return lst[index + 1]\n      end\n    end\n  end\n \
    \ return nil\nend", '  return nil if lst.length < 2', "  return nil if lst.size\
    \ <= 1\n  smallest = lst.first\n  second_smallest = nil\n  lst.each do |item|\n\
    \    next if item == smallest\n    if second_smallest.nil? || item < second_smallest\n\
    \      second_smallest = item\n    end\n  end\n  second_smallest\nend", "  lst.uniq.sort[1]\n\
    end", "  lst.uniq.sort[1]\nend", "  return nil if lst.empty?\n  min, seg = Float::INFINITY,\
    \ []\n  lst.each do |n|\n    if n <= min\n      min = n\n    else\n      seg <<\
    \ n\n    end\n  end\n  seg.min\nend", "  return nil if lst.empty?\n  return nil\
    \ if lst.length == 1\n  if lst.length == 2 && lst[0] == lst[1]\n    return nil\n\
    \  end\n  values = []\n  lst.each do |item|\n    values << item\n  end\n  values.sort!\n\
    \  values[1]\nend", "  sorted = lst.sort.uniq\n  if sorted.length >= 2\n    sorted[1]\n\
    \  else\n    nil\n  end\nend", "\tif lst.empty?\n\t\treturn nil\n\tend\n\tif lst.length\
    \ == 1\n\t\treturn nil\n\tend\n\tmin = lst[0]\n\tsecond_min = nil\n\tlst.each\
    \ do |elem|\n\t\tif elem < min\n\t\t\tsecond_min = min\n\t\t\tmin = elem\n\t\t\
    elsif elem > min && (second_min == nil || elem < second_min)\n\t\t\tsecond_min\
    \ = elem\n\t\tend\n\tend\n\tsecond_min\nend", "  return nil if lst.length < 2\n\
    \  lst.sort[1]\nend", "  lst.sort!\n  if lst.length > 1\n    lst[1]\n  else\n\
    \    nil\n  end\nend", "\tnew_list = lst.uniq.sort\n\tif new_list.length > 1\n\
    \t\tnew_list[1]\n\telse\n\t\tnil\n\tend\nend", "    # nil if less than 2\n   \
    \ return nil if lst.length < 2\n    # sort the list and get the second element\n\
    \    return lst.sort[1]\nend", "  if lst.empty? || lst.uniq.length < 2\n    return\
    \ nil\n  end\n  sorted = lst.sort\n  sorted[1]\nend", "  # your solution here\n\
    end", "  lst.reject { |e| e == lst.min }.min\nend", "  sorted = lst.sort()\n \
    \ return sorted[1]\nend", "  lst.sort[1]\nend\nputs next_smallest([1, 2, 3, 4,\
    \ 5])\nputs next_smallest([5, 1, 4, 3, 2])\nputs next_smallest([])\nputs next_smallest([1,\
    \ 1])\nputs", "\t# your code here\nend", "  lst.uniq.sort[1]\nend", "  return\
    \ nil if lst.empty?\n  min = lst.first\n  sec = nil\n  lst.each do |item|\n  \
    \  min = item if item < min\n    sec = item if sec.nil? || (item < sec && item\
    \ > min)\n  end\n  sec\nend", "    new_lst = []\n    lst.each_with_index do |num,\
    \ i|\n        new_lst << num if num > lst[i-1]\n    end\n    return new_lst[1]\
    \ || nil\nend", "  return nil if lst.empty? || lst.uniq.length == 1\n  lst.sort.uniq[1]\n\
    end", "  uniq_lst = lst.uniq.sort\n  uniq_lst[1]\nend", "  lst.sort[1]\nend",
  "  lst.sort[1]\nend", "  # TODO: return second smallest element of array\n  # you\
    \ may use your solution for previous task\n  return nil if lst.empty? || lst.length\
    \ == 1\n  sorted = lst.sort\n  return nil if sorted[0] == sorted[1]\n  sorted[1]\n\
    end", "  minimum = lst.min\n  return nil if minimum == lst.max", "  lst.sort.reverse.uniq[1]\n\
    end", "  lst.sort[1]\nend", "  lst.uniq.sort[1]\nend", "  m1 = m2 = nil\n  lst.each\
    \ do |i|\n    if m1 == nil\n      m1 = i\n    elsif m2 == nil\n      if i > m1\n\
    \        m2 = i\n      else\n        m2 = m1\n        m1 = i\n      end\n    else\n\
    \      if i < m1\n        m2 = m1\n        m1 = i\n      elsif i > m1 && i < m2\n\
    \        m2 = i\n      end\n    end\n  end\n  m2\nend", "  smallest = lst.min\n\
    \  list_without_smallest = lst.delete_if { |x| x == smallest }\n  list_without_smallest.min\n\
    end", "  lst.sort![1]\nend", "  # TODO\nend", "  if lst.length < 2\n    return\
    \ nil\n  end\n  sorted = lst.sort()\n  if sorted[0] != sorted[1]\n    return sorted[1]\n\
    \  end\n  return nil\nend", "  lst.select { |n| n != lst.min }.min\nend", "  lst.sort.uniq[1]\n\
    end", "  lst.sort.each_cons(2).find{|x,y| x != y}.try(:last)\nend", "  lst.sort[1]\n\
    end", "    if lst.length < 2\n        return nil\n    end\n    lst.sort!\n   \
    \ return lst[1]\nend", "  smallest = lst.first\n  lst.each do |num|\n    if num\
    \ < smallest\n      smallest = num\n    end\n  end\n  if lst.include?(smallest)\
    \ && lst.include?(smallest + 1)\n    smallest + 1\n  elsif lst.length < 2\n  \
    \  nil\n  end\nend", "  lst.sort![1]\nend", "  # ...\nend", "  lst.sort[1]\nend",
  "  s = lst.sort\n  s[1]\nend\np next_smallest([1, 2, 3, 4, 5])\np next_smallest([5,\
    \ 1, 4, 3, 2])\np next_smallest([])\np next_smallest([1, 1])", "  if lst.empty?\n\
    \    return nil\n  end\n  if lst.count == 1\n    return nil\n  end\n  sm = lst.min\n\
    \  for n in lst\n    if n != sm\n      return n\n    end\n  end\nend", "  # ...\n\
    end", "  m1 = m2 = nil\n  lst.each do |x|\n    if m1.nil? || x < m1\n      m2\
    \ = m1\n      m1 = x\n    elsif m2.nil? || x < m2\n      m2 = x\n    end\n  end\n\
    \  m2\nend", "    return nil if lst.nil? || lst.empty?\n    return nil if lst.size\
    \ == 1", "  return nil if lst.length < 2\n  lst.sort!\n  lst.each_with_index do\
    \ |val, idx|\n    return lst[idx + 1] if val != lst[idx + 1]\n  end\n  nil\nend",
  '  return nil if lst.size < 2', "    max = nil\n    min = nil\n    for num in lst\
    \ do\n        if max == nil\n            max = num\n        elsif num > max\n\
    \            max = num\n        end\n        if min == nil\n            min =\
    \ num\n        elsif num < min\n            min = num\n        end\n    end\n\
    \    if min == max\n        return nil\n    end\n    sorted = lst.sort\n    next_smallest\
    \ = max\n    for num in sorted do\n        if num < max\n            next_smallest\
    \ = num\n            break\n        end\n    end\n    return next_smallest\nend\n\
    puts next_smallest([1, 2, 3, 4, 5])\nputs next_smallest([5, 1, 4, 3, 2])\nputs\
    \ next_smallest([])\nputs next_smallest([1, 1])", "  return nil if lst.length\
    \ < 2\n  lst = lst.sort\n  lst[1]\nend", "    if lst.empty?\n        return nil\n\
    \    end\n    min_index = 0\n    second_min_index = 1\n    if lst[0] > lst[1]\n\
    \        min_index = 1\n        second_min_index = 0\n    end\n    for i in 2...lst.length\n\
    \        if lst[i] < lst[min_index]\n            second_min_index = min_index\n\
    \            min_index = i\n        elsif lst[i] < lst[second_min_index] && lst[i]\
    \ != lst[min_index]\n            second_min_index = i\n        end\n    end\n\
    \    if lst[second_min_index] == lst[min_index]\n        return nil\n    end\n\
    \    return lst[second_min_index]\nend", "    smallest = lst[0]\n    second_smallest\
    \ = nil\n    for x in lst\n        if x < smallest\n            second_smallest\
    \ = smallest\n            smallest = x\n        elsif x != smallest && (second_smallest\
    \ == nil || x < second_smallest)\n            second_smallest = x\n        end\n\
    \    end\n    second_smallest\nend", "    return nil if lst.length < 2\n    lst.sort!\n\
    \    lst.each_with_index do |num, i|\n        return lst[i+1] if lst[i+1] != num\n\
    \    end\n    nil\nend", "  lst.sort!\n  return nil if lst.length <= 1\n  return\
    \ nil if lst[0] == lst[1]\n  lst[1]\nend", "  lst.sort[1]\nend", "  lst.uniq.sort[1]\n\
    end", "  max = lst.max\n  min = lst.min\n  return if lst.size <= 1\n  lst.delete(max)\n\
    \  lst.delete(min)\n  lst.max\nend", "  return nil if lst.size <= 1\n  min = lst.min\n\
    \  min = min.next while lst.count(min) > 1\n  lst.any?{|num| num > min} ? lst.select{|num|\
    \ num > min}.min : nil\nend", "  # your code here\nend", "\treturn nil if lst.length\
    \ == 0\n\treturn nil if lst.length == 1\n\treturn nil if lst.uniq.length == 1\n\
    \tlst.sort!\n\tlst[1]\nend", "  # The 2nd smallest element is the first element\
    \ greater than the minimum,\n  # or nil if there is no such element.\n  min =\
    \ lst.min\n  return nil if min.nil?\n  lst.detect { |x| x > min }\nend", "   \
    \ min1 = min2 = nil\n    lst.each do |e|\n        if min1 == nil or e < min1\n\
    \            min2 = min1\n            min1 = e\n        elsif min2 == nil or e\
    \ < min2\n            min2 = e\n        end\n    end\n    return min2\nend", " \
    \ lst = lst.sort!\n  if lst.size < 2\n    return nil\n  elsif lst[0] == lst[1]\n\
    \    return nil\n  else\n    return lst[1]\n  end\nend", "  lst.sort.uniq[1]\n\
    end", "    lst.sort\n    if lst[0] == lst[1]\n        nil\n    else\n        lst[1]\n\
    \    end\nend", "  return nil if lst.empty?\n  min = lst.min\n  lst.delete(min)\n\
    \  if lst.empty?\n    nil\n  else\n    lst.min\n  end\nend", "  lst.sort!\n  uniq_lst\
    \ = lst.uniq\n  uniq_lst.length > 1 ? uniq_lst[1] : nil\nend", "  return nil if\
    \ lst.empty?\n  lst.uniq.sort[1]\nend", "  lst.sort.uniq[1]\nend", "  lst.uniq.sort[1]\n\
    end", "  lst.sort.uniq[1]\nend", "  nil\nend", "  sorted = lst.sort\n  sorted[1]\n\
    end", "  temp_lst = lst.sort[1..-1]\n  return nil if temp_lst.empty? || temp_lst.first\
    \ == temp_lst.last\n  temp_lst.first\nend", "    sorted_lst = lst.sort \n    sorted_lst.each_with_index\
    \ do |i, index|\n        if index == 1\n            return i\n        end\n  \
    \  end\n    return nil\nend", "  return nil if lst.size < 2\n  lst = lst.sort.uniq",
  "  lst.sort[1]\nend", "  lst = lst.dup\n  lst.sort!\n  lst.uniq!\n  lst[1]\nend",
  "  return nil if lst.nil? || lst.empty?\n  return nil if lst.size == 1\n  new_list\
    \ = lst.sort\n  i = 0\n  while i < new_list.size - 1\n    if new_list[i] != new_list[i\
    \ + 1]\n      return new_list[i + 1]\n    end\n    i += 1\n  end\n  nil\nend",
  "  lst.sort[1]\nend", "\tif lst.length > 2\n\t\tlst.each_with_index do |i, v|\n\t\
    \t\tif lst[v] != nil\n\t\t\t\ti = lst[v]\n\t\t\t\tlst.sort!\n\t\t\t\tlst.delete(i)\n\
    \t\t\t\treturn lst[0]\n\t\t\telse\n\t\t\t\treturn nil\n\t\t\tend\n\t\tend\n\t\
    elsif lst.length == 2\n\t\tif lst[0] == lst[1]\n\t\t\treturn nil\n\t\telse\n\t\
    \t\tlst.sort!\n\t\t\treturn lst[0]\n\t\tend\n\telse\n\t\treturn nil\n\tend\nend",
  "  if lst.length == 0\n    return nil\n  end\n  if lst.length == 1\n    return nil\n\
    \  end\n  if lst.length == 2\n    if lst[0] == lst[1]\n      return nil\n    end\n\
    \  end\n  min = lst[0]\n  i = 1\n  while i < lst.length\n    if lst[i] < min\n\
    \      min = lst[i]\n    end\n    i += 1\n  end\n  min_i = lst.index(min)\n  i\
    \ = 0\n  sec_min = lst[min_i + 1]\n  while i < lst.length\n    if lst[i] < sec_min\
    \ && lst[i] > min\n      sec_min = lst[i]\n    end\n    i += 1\n  end\n  sec_min\n\
    end", "  lst.sort!\n  return nil if lst == [] || lst.length == 1\n  return lst[1]\
    \ if lst.uniq == lst\n  count = 0\n  while lst[count] == lst[count + 1]\n    count\
    \ += 1\n  end\n  lst[count + 1]\nend", "  lst.uniq.sort[1]\nend", "  return nil\
    \ if lst.empty?\n  lst.sort[1]\nend", "  min = nil\n  min2 = nil\n  for i in 0..lst.length-1\n\
    \    if lst[i] < min || min == nil\n      min2 = min\n      min = lst[i]\n   \
    \ elsif lst[i] > min && (lst[i] < min2 || min2 == nil)\n      min2 = lst[i]\n\
    \    end\n  end\n  min2\nend", "  return nil if lst.length < 2\n  sorted = lst.sort\n\
    \  sorted[1]\nend", "  sorted = lst.sort\n  return sorted[1] if sorted.size >\
    \ 1\n  nil\nend", "  return nil if lst.nil? || lst.size == 0\n  lst.size == 1\
    \ ? nil : lst.sort[1]\nend", "  return nil if lst.empty?\n  if lst.sort != lst.uniq.sort\n\
    \    return nil\n  else\n    lst.sort[1]\n  end\nend", "    if lst.length < 2\n\
    \        return nil\n    end\n    if lst[0] > lst[1]\n        min = lst[1]\n \
    \       min2 = lst[0]\n    else\n        min = lst[0]\n        min2 = lst[1]\n\
    \    end\n    for i in (2..lst.length - 1)\n        if lst[i] < min\n        \
    \    min2 = min\n            min = lst[i]\n        elsif lst[i] < min2 && lst[i]\
    \ != min\n            min2 = lst[i]\n        end\n    end\n    return min2\nend\n\
    puts \"----#{next_smallest([])}----\"\nputs \"----#{next_smallest([1, 2, 3, 4,\
    \ 5])}----\"\nputs \"----#{next_smallest([5, 1, 4, 3, 2])}----\"\nputs \"----#{next_smallest([1,\
    \ 1])}----\"", "  # DONE: complete the function\n  return nil if lst.length <\
    \ 2\n  lst.sort!\n  lst.uniq!\n  lst[1]\nend", "  return nil if lst.empty? ||\
    \ lst.size == 1\n  lst.sort!\n  min = lst[0]\n  lst.each do |item|\n    return\
    \ item if item > min\n  end\n  nil\nend", "  lst.sort.uniq[1]\nend", "  return\
    \ nil if lst.empty?\n  smallest = lst.first\n  next_smallest = nil\n  lst.each\
    \ do |n|\n    if n < smallest\n      next_smallest = smallest\n      smallest\
    \ = n\n    elsif n > smallest && (next_smallest.nil? || n < next_smallest)\n \
    \     next_smallest = n\n    end\n  end\n  next_smallest\nend", "  min = lst.min\n\
    \  min_i = lst.index(min)\n  return nil if lst.uniq.length == 1\n  lst.delete_at(min_i)\n\
    \  lst.min\nend", "  lst.uniq.sort[1]\nend", "  sorted = lst.sort\n  sorted[1]\n\
    end", "  lst.sort[1]\nend", "  lst.sort[1] if lst.length > 1\nend", "  return\
    \ nil if lst.size <= 1\n  lst.sort.uniq[1]\nend", "  nil if lst.length <= 1\n\
    \  lst.uniq!\n  sorted = lst.sort\n  sorted[1]\nend", "  min = lst.min\n  return\
    \ nil if min.nil?\n  lst.delete(min)\n  lst.min\nend", "\tlst.delete(lst.min)\n\
    \tlst.size > 0 ? lst.min : nil\nend", "  if lst.size < 2\n    return nil\n  end\n\
    \  if lst[0] < lst[1]\n    lst[1]\n  else\n    if lst[-1] < lst[-2]\n      lst[-2]\n\
    \    else\n      (1..lst.size-2).each do |i|\n        if lst[i] < lst[i-1] and\
    \ lst[i] < lst[i+1]\n          return lst[i]\n        end\n      end\n    end\n\
    \  end\nend", "  sorted = lst.sort\n  sorted[1] if sorted.size > 1\nend", "  \
    \  my_min = lst.min\n    my_min_index = lst.index(my_min)\n    lst.delete_at(my_min_index)\n\
    \    new_min = lst.min\n    return new_min\nend", "  answer = []\n  lst.each do\
    \ |i|\n    if lst.count(i) == 1\n      answer << i\n    end\n  end\n  if answer.size\
    \ < 2\n    nil\n  else\n    answer.min\n  end\nend", "  # your code here\nend",
  "  return nil if lst.length == 0 || lst.length == 1\n  lst.sort[1]\nend", "  return\
    \ nil if lst.nil? || lst.empty?\n  return nil if lst.uniq.size == 1\n  next_smallest\
    \ = lst.min\n  lst.each do |element|\n    if next_smallest < element\n      return\
    \ next_smallest\n    else\n      next_smallest = element\n    end\n  end\nend",
  "  return if lst.empty? || lst.uniq.size == 1\n  lst.sort[1]\nend", "  return nil\
    \ if lst.empty?\n  sorted = lst.sort\n  sorted.reject { |item| item == sorted.first\
    \ }.first\nend", "  lst.uniq!\n  lst.each { |e| return e if lst.count(e) == 1\
    \ && e > lst.min }\n  nil\nend", "  lst.sort.uniq[1]\nend", "  min = lst.min\n\
    \  lst.select{|e| e > min}.min\nend", "  return nil if lst.empty? || lst.uniq.length\
    \ == 1\n  lst.reject { |e| e == lst.min }.min\nend", "  sorted = lst.sort()\n\
    \  smallest = sorted[0]\n  if smallest == sorted[1]\n    nil\n  else\n    sorted[1]\n\
    \  end\nend", "  if lst.length < 2\n    return nil\n  else\n    sorted = lst.sort\n\
    \    if sorted[0] != sorted[1]\n      return sorted[1]\n    else\n      return\
    \ nil\n    end\n  end\nend", "  return nil if lst.empty?\n  return nil if lst.length\
    \ < 2\n  lst.sort[1]\nend", end, "  return nil if lst.size <= 1\n  sorted = lst.sort\n\
    \  if sorted[0] == sorted[1]\n    return nil\n  else\n    return sorted[1]\n \
    \ end\nend", "  lst.size < 2 ? nil : lst.sort.uniq[1]\nend", "  return nil if\
    \ lst.length < 2\n  lst.sort.uniq[1]\nend", "  return nil if lst.empty?\n  uniq_sorted\
    \ = lst.uniq.sort\n  return nil if uniq_sorted.length < 2\n  uniq_sorted[1]\n\
    end", "  return nil if lst.empty? || lst.length == 1\n  s = lst.sort\n  i = 0\n\
    \  while i < s.length-1\n    return s[i+1] if s[i] != s[i+1]\n    i += 1\n  end\n\
    \  nil\nend", "    return nil if lst.nil? || lst.empty?\n    lst = lst.uniq.sort\n\
    \    lst[1]\nend", "  sorted = lst.sort\n  return nil if sorted.length < 2 ||\
    \ sorted[0] == sorted[1]\n  sorted[1]\nend", "  return nil if lst.nil? || lst.empty?\n\
    \  return nil if lst.length < 2\n  lst.uniq!\n  return nil if lst.length < 2\n\
    \  lst.sort!\n  lst[1]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
