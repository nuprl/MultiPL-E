name: HumanEval_90_next_smallest
language: rb
prompt: "# You are given an array of integers.\n# Write a function next_smallest()\
  \ that returns the 2nd smallest element of the array.\n# Return nil if there is\
  \ no such element.\n# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5,\
  \ 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1,\
  \ 1])\n# nil\ndef next_smallest(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n\
  \    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1,\
  \ 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil,\
  \ candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1,\
  \ candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n\
  \    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"
completions: ["  return nil if lst.size < 2\n  return nil if lst.uniq.size == 1\n\
    \  lst.uniq.sort.reverse[1]\nend", "    lst.empty? ? nil : lst.sort.uniq[1]\n\
    end", "  if lst.size < 2\n    return nil\n  end\n  if lst.size == 2\n    return\
    \ nil if lst[0] == lst[1]\n    return lst[0] if lst[0] < lst[1]\n    return lst[1]\
    \ if lst[1] < lst[0]\n  end\n  arr = lst.sort\n  arr[1]\nend", "  lst.sort.uniq[1]\n\
    end", "    sorted_lst = lst.sort\n    if sorted_lst.uniq.length > 1\n        return\
    \ sorted_lst[1]\n    else\n        return nil\n    end\nend", "  lst = lst.dup\n\
    \  lst.delete_at(lst.index(lst.min))\n  lst.min\nend", "  return nil if lst.empty?\n\
    \  lst.uniq.sort[1]\nend", "  nil\nend", "  return nil if lst.empty?\n  lst.uniq.sort[1]\n\
    end", "  lst = lst.uniq\n  return nil if lst.empty?\n  return nil if lst.length\
    \ < 2\n  lst.sort[1]\nend", "  return nil if lst.size <= 1\n  lst.min == lst.max\
    \ ? nil : lst.uniq.sort[1]\nend", '  return nil if lst.length < 2', "  lst.sort!\n\
    \  len = lst.length\n  len > 1 ? lst[1] : nil\nend", "  lst.sort!\n  lst.uniq!\n\
    \  return nil if lst.length < 2\n  lst[1]\nend", "\tnum = lst.sort\n\tif num.length\
    \ < 2\n\t\treturn nil\n\telse\n\t\tsmall = num[0]\n\t\tsmaller = num[1]\n\t\t\
    for i in num\n\t\t\tif i > small\n\t\t\t\tif i <= smaller\n\t\t\t\t\tsmaller =\
    \ i\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif smaller == small\n\t\t\treturn nil\n\
    \t\telse\n\t\t\treturn smaller\n\t\tend\n\tend\nend", "  lst.sort!\n  lst.uniq!\n\
    \  lst[1]\nend", "  # YOUR CODE HERE\nend", "    current_smallest = nil\n    next_smallest\
    \ = nil\n    lst.each { |element|\n        if current_smallest == nil\n      \
    \      current_smallest = element\n        elsif next_smallest == nil\n      \
    \      if element < current_smallest\n                next_smallest = current_smallest\n\
    \                current_smallest = element\n            elsif element > current_smallest\n\
    \                next_smallest = element\n            end\n        elsif element\
    \ < current_smallest\n            next_smallest = current_smallest\n         \
    \   current_smallest = element\n        elsif element > current_smallest && element\
    \ < next_smallest\n            next_smallest = element\n        end\n    }\n \
    \   return next_smallest\nend", "    lst.sort!\n    lst[1] || nil\nend", "  output\
    \ = lst.uniq.sort[1]\n  if output == nil\n    return nil\n  else\n    return output\n\
    \  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
