name: HumanEval_16_count_distinct_characters
language: rb
prompt: "# Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n# >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>>\
  \ count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n\
  \    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\
  \"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"\
  abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5,\
  \ candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"
completions: ["  string.upcase.chars.uniq.size\nend", "\tstring.downcase.chars.uniq.count\n\
    end", "  string.chars.uniq.count\nend", "  count = 0\n  array = string.downcase.split(\"\
    \")\n  array.each do |i|\n    if array.count(i) == 1\n      count += 1\n    end\n\
    \  end\n  count\nend", "  string.downcase.chars.uniq.size\nend", "  string.split('').uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  # your code goes here\n  string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  char_hash = Hash.new(0)\n  string.each_char { |c| char_hash[c.downcase]\
    \ += 1 }\n  char_hash.keys.length\nend", "  string.upcase.chars.uniq.count\nend",
  "  string.scan(/\\w/).uniq.count\nend", "  count = 0\n  string.downcase.each_char\
    \ do |char|\n    count += 1 if string.downcase.count(char) > 0\n  end\n  count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.downcase.split('').uniq.length\n\
    end", "  return string.downcase.split('').uniq.length\nend", "\tstring.split(\"\
    \").uniq.count\nend", "  string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  new_string = string.downcase\n  new_string.split(\"\").uniq.count\nend",
  "  string.chars.uniq.count\nend", "  string.downcase.chars.uniq.size\nend", "  string.downcase.chars.uniq.size\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.downcase.split('').uniq.length\n\
    end", "  # TODO: implement this method\n  hash_string = {}\n  string.each_char\
    \ do |c|\n    hash_string[c.downcase] = true\n  end\n  hash_string.length\nend",
  "  string.downcase.chars.uniq.size\nend", "  string.downcase.split('').uniq.count\n\
    end", "  return string.upcase.each_char.to_a.uniq.length\nend", "  # your code\
    \ here\nend", "  string.downcase.chars.uniq.size\nend", "  string.downcase.chars.uniq.count\n\
    end", "    string.downcase!\n    no_dups = string.split(\"\").uniq\n    return\
    \ no_dups.length\nend", "  string.split('').map(&:downcase).uniq.count\nend",
  "  string.chars.map(&:downcase).uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  return nil if string.nil?\n\
    \  string.downcase.split('').uniq.length\nend", "  # Your code here\nend", " \
    \ string.downcase.chars.uniq.count\nend", "  string.downcase.split('').uniq.length\n\
    end", "  string.downcase.split('').uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.downcase.split('').uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  distinct_characters = []\n\
    \  string.chars.map { |letter| distinct_characters << letter.downcase }\n  distinct_characters.uniq.count\n\
    end", "  string.upcase.split('').uniq.count\nend", "\tstring.split(\"\").uniq.count\n\
    end", "  string.upcase.chars.uniq.size\nend", "  string.chars.map(&:downcase).uniq.count\n\
    end", "    # TODO: your code here\n    return string.split('').uniq.count\nend",
  "  string.downcase.split('').uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  return string.downcase.chars.uniq.length\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.size\n\
    end", "  string.downcase.split('').uniq.length\nend", "  (string.downcase.chars.to_a.uniq).length\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  # Your code here\nend", "  string.downcase.chars.uniq.count\nend", " \
    \ string.downcase.chars.uniq.count\nend", "  char_counter = Hash.new(0)\n  string.each_char\
    \ do |c|\n    char_counter[c.downcase] += 1\n  end\n  char_counter.keys.length\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.chars.uniq.count\nend", "  string.downcase.split('').uniq.length\n\
    end", "  string.downcase.split('').uniq.length\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.chars.map { |char| char.downcase }.uniq.size\nend", "  downcase_string\
    \ = string.downcase\n  count = 0\n  downcase_string.each_char do |c|\n    if !(downcase_string.count(c)\
    \ > 1)\n      count += 1\n    end\n  end\n  count\nend", "  string.downcase.split('').uniq.count\n\
    end", "  # write your code here\n  return string.downcase.split('').uniq.length\n\
    end", "\tstring.downcase.split(\"\").uniq.count\nend", "  string.downcase.chars.uniq.size\n\
    end", "  string.length - string.downcase.squeeze.length\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.chars.map(&:downcase).uniq.count\nend", "  string.downcase.split('').uniq.count\n\
    end", "  string.scan(/\\w/).map(&:downcase).uniq.size\nend", "\tstring.downcase.chars.uniq.length\n\
    end", '  return 0 if string.nil?', "  string.downcase.chars.uniq.count\nend",
  "  string.chars.map(&:downcase).uniq.size\nend", "  string.downcase.chars.uniq.size\n\
    end", "  string.downcase.split('').uniq.count\nend", "  string.chars.map { |char|\
    \ char.downcase }.uniq.size\nend", "  string.downcase.split('').uniq.count\nend",
  "  string.downcase.chars.uniq.count\nend", "  require 'set'\n  string.split('').to_set.size\n\
    end", "    string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.upcase.chars.uniq.size\n\
    end", "  string.downcase.chars.uniq.size\nend", "  string.downcase.chars.uniq.size\n\
    end", "\tstring.downcase.chars.uniq.count\nend", "  string.chars.uniq.count\n\
    end", "  string.downcase.chars.uniq.size\nend", "  string.downcase.split('').uniq.count\n\
    end", "  string.downcase.split('').uniq.count\nend", "    string.downcase.split(\"\
    \").uniq.count\nend", "  string.upcase.chars.uniq.size\nend", "  string.split('').map(&:downcase).uniq.count\n\
    end", "  string.downcase.chars.uniq.size\nend", "  string.downcase.split('').uniq.length\n\
    end", "    string.downcase.chars.uniq.length\nend", "  string.chars.to_a.uniq.count\n\
    end", "  counter = 0\n  string.downcase.each_char do |char|\n    counter += 1\
    \ if string.downcase.count(char) == 1\n  end\n  counter\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.chars.uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.split('').uniq.length\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.chars.uniq.count\n\
    end", "  string.split('').uniq.count\nend", "  # This is a method that does something\n\
    \  array = string.split('')\n  array.uniq.count\nend", "  count = Hash.new(0)\n\
    \  string.each_char { |char| count[char.downcase] += 1 }\n  count.size\nend",
  "  #your code here\n  # if string.class == String\n    string.downcase.chars.uniq.count\n\
    \  # else\n  #   string.chars.uniq.count\n  # end\nend", "  string.downcase.split('').uniq.count\n\
    end", "  if string.empty? || string.length == 1\n    string.length\n  else\n \
    \   return string.chars.uniq.count\n  end\nend", "  string.downcase.chars.uniq.count\n\
    end", "  lowercase_array = string.downcase.split(\"\")\n  distinct_letters = []\n\
    \  lowercase_array.each do |letter|\n    if distinct_letters.include?(letter)\
    \ == false\n      distinct_letters << letter\n    end\n  end\n  distinct_letters.length\n\
    end", "  # your code here\nend", "  string.downcase.split('').uniq.count\nend",
  "  string.split('').uniq.count\nend", "  string.downcase.chars.uniq.count\nend",
  "  string.downcase.chars.uniq.size\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.split('').uniq.size\nend", "  return string.downcase.split('').uniq.length\n\
    end", "  string.downcase.chars.uniq.size\nend", "  string.downcase.chars.uniq.size\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.upcase.chars.uniq.count\n\
    end", "\tstring.downcase.split(\"\").uniq.length\nend", "  string.downcase.chars.uniq.count\n\
    end", "  # write your code here\nend", "  string.downcase.chars.uniq.size\nend",
  "  string.downcase.chars.uniq.count\nend", "\tstring.gsub(/[\\s\\W]/, '').downcase.split('').uniq.length\n\
    end", "  string.downcase.chars.uniq.size\nend", "  string.chars.uniq.count\nend",
  "  string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "\tstring.upcase.chars.uniq.size\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.downcase.split('').uniq.length\nend", "  string.gsub(/[^a-zA-Z0-9]/,\
    \ '').chars.map(&:downcase).uniq.size\nend", "  string.downcase.chars.uniq.size\n\
    end", "  string.downcase.split('').uniq.count\nend", "    string.chars.uniq.count\n\
    end", "  return string.split('').uniq.count\nend", "  string.chars.uniq.count\n\
    end", "  (string.downcase.split(\"\").sort.uniq.length)\nend", "  string.downcase.chars.uniq.count\n\
    end", "\tstring.downcase.split(\"\").uniq.count\nend", "  string.split('').uniq.size\n\
    end", "  string.downcase.chars.uniq.size\nend", "  string.downcase.chars.uniq.count\n\
    end", "  characters = string.downcase.chars.to_a\n  characters.uniq.length\nend",
  "  string.downcase.chars.uniq.size\nend", "  # your code goes here\nend", "  string.downcase.split('').uniq.count\n\
    end", "  string.downcase.split('').uniq.length\nend", "    string = string.downcase.split(\"\
    \")\n    string.uniq.length\nend", "  string.downcase.split('').uniq.count\nend",
  "  string.downcase.chars.uniq.size\nend", "  string.downcase.chars.uniq.size\nend",
  "  raise StandardError, \"input cannot be null\" if string.nil?\n  string.downcase!\n\
    \  string.split(\"\").uniq.length\nend", "  string.downcase.split('').uniq.length\n\
    end", "  string.downcase.split('').uniq.length\nend", "  string.gsub(/[^a-zA-Z]/,\
    \ '').downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\nend",
  "  string.downcase.split('').uniq.count\nend", "  string.split('').uniq.count\n\
    end", "    string.downcase.split(\"\").uniq.length\nend", "  string.downcase.chars.uniq.count\n\
    end", "  # TODO: write your code here\nend", "    string.downcase.chars.uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  string.chars.uniq.size\nend", "  string.downcase.split('').uniq.count\n\
    end", "  string.downcase.chars.uniq.count\nend", "\treturn string.downcase.split(\"\
    \").uniq.count\nend", "  # This is an example of a method where we may wish to\
    \ refactor and use some\n  # built-in method\n  letters = string.downcase.split(\"\
    \")\n  letters.uniq.count\nend", "  string.upcase.chars.uniq.count\nend", "  string.downcase.split('').uniq.count\n\
    end", "  string.downcase.split('').uniq.count\nend", "  string.downcase.chars.uniq.count\n\
    end", "  # your code here\nend", "\treturn string.downcase.chars.uniq.length\n\
    end", "  string.downcase.chars.uniq.size\nend", "  # logic here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
