name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given array of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ array.\n# For example:\n# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1,\
  \ -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  # your code here\nend", "  if nums.empty?\n    []\n  else\n    #\
    \ find sum of digits for each number\n    sums = nums.map do |x|\n      x.abs.to_s.chars.map(&:to_i).reduce(:+)\n\
    \    end\n    # sort nums by sum of digits in ascending order\n    nums.sort_by.with_index\
    \ do |_, i|\n      [sums[i], i]\n    end\n  end\nend", "  nums.sort_by.with_index\
    \ { |num, i| [num.digits.sum, i] }\nend", end, "  # your code here\nend", "  if\
    \ nums == []\n    return []\n  else\n    nums.sort_by { |num| [sum_digits(num),\
    \ nums.index(num)] }\n  end\nend", "  # TODO\nend", "  nums.sort_by.with_index\
    \ { |n, i| [n.digits.sum, i] }\nend", "  return [] if nums.empty?\n  sum_hash\
    \ = {}\n  nums.each_with_index do |num, index|\n    sum_hash[index] = num.abs.to_s.split('').map(&:to_i).reduce(:+)\n\
    \  end\n  sum_hash.sort_by { |k, v| v }.to_h.values\nend", "  array = nums.sort_by\
    \ do |x|\n    next(x.abs.to_s.split('').map(&:to_i).reduce(:+), nums.index(x))\n\
    \  end\nend", "  nums.sort_by.with_index do |num, i|\n    [num.to_s.chars.map(&:to_i).reduce(:+),\
    \ i]\n  end\nend", "  # TODO: your code here\nend", "  return [] if nums.empty?\n\
    \  nums.sort_by { |num| [num.digits.sum, nums.index(num)] }\nend", "  return []\
    \ if nums.nil? || nums.empty?\n  nums.sort_by { |i| i.to_s.split('').map(&:to_i).sum\
    \ }\nend", "  nums.sort_by { |num| [num.digits.sum, nums.index(num)] }\nend",
  "  # TODO: implement this\nend", "  pairs = nums.map { |n| [n, n.to_s.split('').map(&:to_i).reduce(:+)]\
    \ }\n  pairs.sort_by { |n, _s| [_s, nums.index(n)] }.map(&:first)\nend", "  nums.sort_by.with_index\
    \ do |n, i|\n    [n.digits.sum, i]\n  end\nend", "  if nums.empty?\n    []\n \
    \ else\n    nums.sort_by { |x| [x.to_s.split('').map(&:to_i).reduce(:+), nums.index(x)]\
    \ }\n  end\nend", "  i = 0\n  nums.sort do |a, b|\n    a = a.to_s.split('').map\
    \ { |i| i.to_i }.inject(:+)\n    b = b.to_s.split('').map { |i| i.to_i }.inject(:+)\n\
    \    a <=> b\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
