name: HumanEval_100_make_a_pile
language: rb
prompt: "# Given a positive integer n, you have to make a pile of n levels of stones.\n\
  # The first level has n stones.\n# The number of stones in the next level is:\n\
  # - the next odd number if n is odd.\n# - the next even number if n is even.\n#\
  \ Return the number of stones in each level in an array, where element at index\n\
  # i represents the number of stones in the level (i+1).\n# Examples:\n# >>> make_a_pile.call(3)\n\
  # [3, 5, 7]\ndef make_a_pile(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n\
  \    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n\
  \    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9,\
  \ 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n\
  \    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"
completions: ["  result = []\n  while n > 0\n    result << n\n    n = n.even? ? n\
    \ + 2 : n + 1\n  end\n  result\nend", "  # Your code here...\nend", "  array =\
    \ []\n  (1..n).each do |x|\n    if x.odd?\n      array << x * 2 + 1\n    else\n\
    \      array << x * 2\n    end\n  end\n  array\nend", "  pile = []\n  until n\
    \ == 0\n    pile << n\n    n.even? ? n -= 1 : n -= 2\n  end\n  pile.reverse\n\
    end", "  return [1] if n == 1\n  prev_pile = make_a_pile(n - 1)\n  # implement\
    \ the `next_number` helper method\n  next_number = next_number(prev_pile.last)\n\
    \  prev_pile << next_number\nend", "  if n.even?\n    (1..n).to_a.map { |i| i\
    \ + n }\n  else\n    (1..n).to_a.map { |i| i + n + 1 }\n  end\nend", "  (1..n).map\
    \ { |i| i * 2 + 1 }\nend", "  (1..n).map do |i|\n    i.even? ? n + i : n + i +\
    \ 1\n  end\nend\np make_a_pile(6)", "  Array.new(n){|i| n += i.even? ? 2 : 1}\n\
    end", "  # TODO: implement this method\nend", "  (1..n).map { |n| n ** 2 }\nend",
  "  stones = [n]\n  index = 1\n  while stones[index-1] != 1\n    n = n.even? ? n+1\
    \ : n-1\n    stones[index] = n\n    index += 1\n  end\n  stones\nend", "  res\
    \ = []\n  (1..n).each do |i|\n    level = i\n    num_stones = n\n    while level\
    \ > 1\n      num_stones += i % 2 == 0 ? 2 : 1\n      level -= 1\n    end\n   \
    \ res << num_stones\n  end\n  res\nend", "  (1..n).map { |i| n - i + 1 }\nend",
  "  result = []\n  new_num = n", "  levels = [n]\n  while levels.last >= 1\n    levels\
    \ << (levels.last % 2 == 0 ? levels.last - 1 : levels.last - 2)\n  end\n  levels.reverse[1..-1]\n\
    end", "  (1..n).map { |i| [:odd?, :even?].map { |f| i.send(f) ? i + 1 : i }.max\
    \ }\nend", "  level = 1\n  level_max = n\n  stones = []\n  until level > level_max\n\
    \    if level.odd?\n      stones.push(level)\n    else\n      stones.push(level\
    \ + 1)\n    end\n    level += 1\n  end\n  stones\nend", "  a = []\n  (1..n).each\
    \ do |i|\n    a << n - i + 1\n  end\n  a.map { |x| x + (x%2 == 0 ? 1 : 0) }\n\
    end", "  (1..n).map do |level|\n    (n + level) % 2 == 0 ? n + level : n + level\
    \ + 1\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
