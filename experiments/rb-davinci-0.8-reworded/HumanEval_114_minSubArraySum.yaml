name: HumanEval_114_minSubArraySum
language: rb
prompt: "# Given an array of integers nums, find the minimum sum of any non-empty\
  \ sub-array\n# of nums.\n# Example\n# >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])\n\
  # 1\n# >>> minSubArraySum.call([-1, -2, -3])\n# -6\ndef minSubArraySum(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n\
  \    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2,\
  \ 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14,\
  \ candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n\
  \    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6,\
  \ candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100,\
  \ -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n\
  \    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10,\
  \ candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1,\
  \ candidate.call([1, -1]))\n  end\nend\n"
completions: ["    return 0 if nums.empty?\n    n = nums.length\n    min_sum = nums[0]\n\
    \    current_sum = nums[0]\n    (1...n).each do |i|\n        current_sum = [nums[i],\
    \ current_sum + nums[i]].min\n        min_sum = [min_sum, current_sum].min\n \
    \   end\n    min_sum\nend", "  min = nums[0]\n  sum = nums[0]\n  i = 1\n  while\
    \ i < nums.length\n    sum += nums[i]\n    min = sum if sum < min\n    sum = 0\
    \ if sum < 0\n    i += 1\n  end\n  min\nend", "    return 0 if nums.empty?\n \
    \   min_sum = Float::INFINITY\n    sum = 0\n    nums.each do |el|\n        sum\
    \ += el\n        min_sum = sum if sum < min_sum\n        sum = 0 if sum < 0\n\
    \    end\n    min_sum\nend", "  min_sum = nil\n  current_sum = 0\n  last_idx =\
    \ nums.length - 1\n  (0..last_idx).each do |idx|\n    current_sum += nums[idx]\n\
    \    min_sum = current_sum if min_sum.nil? || current_sum < min_sum\n    current_sum\
    \ = 0 if current_sum < 0\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  curr_sum\
    \ = 0\n  nums.each do |num|\n    curr_sum += num\n    min_sum = curr_sum if curr_sum\
    \ < min_sum\n    curr_sum = 0 if curr_sum < 0\n  end\n  min_sum\nend", "  min_sum\
    \ = Float::INFINITY\n  curr_sum = 0", "  min_sum = Float::INFINITY\n  sum = 0\n\
    \  nums.each do |num|\n    sum += num\n    min_sum = sum if sum < min_sum\n  \
    \  sum = 0 if sum < 0\n  end\n  min_sum\nend", "  return nil if nums.nil? || nums.empty?\n\
    \  min_sum = nums[0]\n  sum = 0\n  nums.each do |num|\n    sum += num\n    min_sum\
    \ = sum if sum < min_sum\n    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  l\
    \ = 0\n  r = 0\n  curr_sum = 0\n  min_sum = nil", "  arr = []\n  (0...nums.length).each\
    \ do |i|\n    (i...nums.length).each do |j|\n      arr << nums[i..j].reduce(:+)\n\
    \    end\n  end\n  arr.min\nend", "  size = nums.size\n  i = 0\n  min_sum = 0\n\
    \  while i < size do\n    min_sum += nums[i]\n    i += 1\n  end\n  min_sum\nend",
  "  min_sum = nums[0]\n  curr_sum = 0\n  nums.each do |n|\n    curr_sum += n\n  \
    \  min_sum = curr_sum if curr_sum < min_sum\n    curr_sum = 0 if curr_sum < 0\n\
    \  end\n  min_sum\nend", "  min_sum = Float::INFINITY\n  sum = 0\n  curr_min =\
    \ 0", "  current_sum = nums[0]\n  min_sum = nums[0]", "  i = 0\n  j = 0\n  current_sum\
    \ = 0\n  min_sum = nums[0]\n  min_sum = nums[1] if nums[1] < min_sum\n  for i\
    \ in 0..nums.length-1\n    current_sum = nums[i]\n    for j in i+1..nums.length-1\n\
    \      current_sum += nums[j]\n      if current_sum < min_sum\n        min_sum\
    \ = current_sum\n      end\n    end\n  end\n  min_sum\nend", "  min_sum = Float::INFINITY\n\
    \  current_sum = 0", "  min_sum = nums[0]\n  sum = 0\n  nums.each do |num|\n \
    \   sum += num\n    if sum < min_sum\n      min_sum = sum\n    end\n    if sum\
    \ > 0\n      sum = 0\n    end\n  end\n  min_sum\nend", "  min_sum = nums[0]\n\
    \  current_sum = 0\n  nums.each do |num|\n    current_sum += num\n    min_sum\
    \ = current_sum if current_sum < min_sum\n    current_sum = 0 if current_sum <\
    \ 0\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  max_so_far = nums[0]\n  (1...nums.length).each\
    \ do |i|\n    max_so_far = [nums[i], max_so_far + nums[i]].max\n    min_sum =\
    \ [min_sum, max_so_far].min\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  current_sum\
    \ = 0\n  for num in nums\n    current_sum += num\n    min_sum = current_sum if\
    \ current_sum < min_sum\n    current_sum = 0 if current_sum < 0\n  end\n  min_sum\n\
    end", "  min_sum = 0\n  sum = 0\n  (0...nums.length).each do |i|\n    sum += nums[i]\n\
    \    min_sum = sum if sum < min_sum\n    sum = 0 if sum < 0\n  end\n  min_sum\n\
    end", "  return nil if nums.nil? || nums.empty?\n  min_sum = nil\n  nums.each_with_index\
    \ do |num, i|\n    sum = num\n    min_sum = sum if min_sum.nil? || sum < min_sum\n\
    \    (i + 1...nums.length).each do |j|\n      sum += nums[j]\n      min_sum =\
    \ sum if sum < min_sum\n    end\n  end\n  min_sum\nend", "  nums.length <= 1 ?\
    \ nums.first : nums.each_with_index.inject(nums.first) do |acc, (num, index)|\n\
    \    acc = num if acc > num\n    # First loop, acc is 2 and next is 3\n    # 2\
    \ < 3\n    # 3 is the smallest value", "  min_so_far = nums[0]\n  sum = 0\n  nums.each\
    \ do |num|\n    sum += num\n    if sum < min_so_far\n      min_so_far = sum\n\
    \    end\n    if sum > 0\n      sum = 0\n    end\n  end\n  min_so_far\nend", " \
    \ max_sum = -9999\n  min_sum = 9999\n  for i in 0..nums.length\n    next if i\
    \ == 0\n    for j in i..nums.length\n      max_sum = nums[i..j].sum if nums[i..j].sum\
    \ > max_sum\n      min_sum = nums[i..j].sum if nums[i..j].sum < min_sum\n    end\n\
    \  end\n  min_sum\nend", "  min = nums[0]\n  sum = nums[0]\n  (1...nums.length).each\
    \ do |i|\n    sum = nums[i] if sum < 0\n    sum += nums[i]\n    min = sum if sum\
    \ < min\n  end\n  min\nend", "  current_sum = minimum_sum = nums[0]\n  (1...nums.length).each\
    \ do |index|\n    current_sum = [nums[index], current_sum + nums[index]].min\n\
    \    minimum_sum = [minimum_sum, current_sum].min\n  end\n  minimum_sum\nend",
  "  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    current_sum +=\
    \ num\n    min_sum = current_sum if current_sum < min_sum\n    current_sum = 0\
    \ if current_sum < 0\n  end\n  min_sum\nend", "  return nums.min if nums.length\
    \ <= 1\n  sum = 0\n  result = nil\n  0.upto(nums.length - 1) do |i|\n    sum +=\
    \ nums[i]\n    result = sum if result.nil? || sum < result\n    sum = 0 if sum\
    \ < 0\n  end\n  result\nend", "  min_sum = nums[0]\n  current_sum = nums[0]",
  "  if nums.is_a?(Array)\n    min_sum = Float::INFINITY\n    curr_sum = 0\n    nums.each\
    \ do |num|\n      curr_sum += num\n      min_sum = curr_sum if curr_sum < min_sum\n\
    \      curr_sum = 0 if curr_sum < 0\n    end\n    min_sum\n  else\n    raise ArgumentError.new\
    \ 'Argument must be of type Array'\n  end\nend", "  min_sum = nums[0]\n  sum =\
    \ nums[0]\n  i = 1\n  while i < nums.length\n    sum = [nums[i], sum + nums[i]].min\n\
    \    min_sum = [min_sum, sum].min\n    i += 1\n  end\n  min_sum\nend", "  sum\
    \ = 0\n  min_sum = 0\n  min_curr_sum = 0\n  nums.each do |num|\n    sum += num\n\
    \    min_curr_sum = [sum, min_curr_sum + num].min\n    min_sum = [min_sum, min_curr_sum].min\n\
    \  end\n  min_sum\nend", "  start = 0\n  global = nums[0]\n  current = nums[0]\n\
    \  i = 1\n  while i < nums.length\n    current = [nums[i], current + nums[i]].min\n\
    \    global = [global, current].min\n    i += 1\n  end\n  global\nend", "  min_sum\
    \ = nums[0]\n  curr_sum = nums[0]\n  nums[1..-1].each do |num|\n    if curr_sum\
    \ > 0\n      curr_sum = num\n    else\n      curr_sum += num\n    end\n    min_sum\
    \ = curr_sum if curr_sum < min_sum\n  end\n  min_sum\nend", "    min_sum = nums[0]\n\
    \    partial_sum = 0\n    nums.each do |num|\n        partial_sum += num\n   \
    \     min_sum = partial_sum if partial_sum < min_sum\n        partial_sum = 0\
    \ if partial_sum > 0\n    end\n    min_sum\nend", "    min_sum = nums[0]\n   \
    \ current_sum = 0\n    nums.each do |num|\n        current_sum += num\n      \
    \  min_sum = current_sum if current_sum < min_sum\n        current_sum = 0 if\
    \ current_sum < 0\n    end\n    min_sum\nend", "  min_sum = nums[0]\n  curr_sum\
    \ = 0\n  n = nums.length\n  n.times do |idx|\n    curr_sum += nums[idx]\n    min_sum\
    \ = curr_sum if curr_sum < min_sum\n    curr_sum = 0 if curr_sum < 0\n  end\n\
    \  min_sum\nend\np minSubArraySum([2, 3, 4, 1, 2, 4]) # 1\np minSubArraySum([-1,\
    \ -2, -3]) # -6", "  start = 0\n  min = nums[0]\n  current = nums[0]\n  (1...nums.length).each\
    \ do |end_|\n    if current < 0\n      start = end_\n      current = nums[end_]\n\
    \    else\n      current += nums[end_]\n    end\n    min = current if current\
    \ < min\n  end\n  min\nend", "  min_sum = nums[0]\n  sum = 0\n  nums.each_with_index\
    \ do |num, index|\n    sum += num\n    min_sum = sum if min_sum > sum\n    sum\
    \ = 0 if sum < 0\n  end\n  min_sum\nend", "  best_min_sum = nums[0]\n  min_sum\
    \ = 0\n  nums.each do |num|\n    min_sum += num\n    if min_sum > 0\n      min_sum\
    \ = 0\n    elsif min_sum < best_min_sum\n      best_min_sum = min_sum\n    end\n\
    \  end\n  best_min_sum\nend", "  min_sum = nums[0]\n  current_sum = 0\n  i = 0\n\
    \  j = 0\n  while j < nums.length\n    current_sum += nums[j]\n    min_sum = [min_sum,\
    \ current_sum].min\n    current_sum = [current_sum, 0].max\n    j += 1\n  end\n\
    \  min_sum\nend", "  return 0 if nums.empty?\n  return nums.first if nums.length\
    \ == 1", "  return nil if nums.empty?\n  nums.each_index.reduce(nums.min) do |acc,\
    \ ind|\n    acc = [acc, nums[ind, nums.length].reduce(:+)].min\n  end\nend", " \
    \ current_sum = nums[0]\n  smallest_sum = nums[0]", "  return nums.min if nums.length\
    \ <= 1\n  min = Float::INFINITY\n  i = 0\n  while i < nums.length\n    j = i\n\
    \    while j < nums.length\n      sum = nums[i..j].sum\n      min = sum if sum\
    \ < min\n      j += 1\n    end\n    i += 1\n  end\n  min\nend", "  return nil\
    \ if nums.nil?\n  sum = nums[0]\n  min_sum = nums[0]\n  (1...nums.length).each\
    \ do |i|\n    sum = [nums[i], sum + nums[i]].min\n    min_sum = [min_sum, sum].min\n\
    \  end\n  min_sum\nend", "  min = nums[0]\n  temp = 0\n  nums.each do |num|\n\
    \    temp += num\n    if temp < min\n      min = temp\n    end\n    if temp >\
    \ 0\n      temp = 0\n    end\n  end\n  min\nend", "  # TODO: implement this\n\
    end", "  return 0 if nums.nil? || nums.empty?\n  n = nums.length\n  result = 0\n\
    \  sum = 0\n  for i in 0..n\n    if i == 0\n      result = nums[i]\n      sum\
    \ = nums[i]\n    else\n      sum = sum + nums[i]\n      if sum < result\n    \
    \    result = sum\n      end\n    end\n  end\n  result\nend", "  return 0 if nums.empty?\n\
    \  return nums.min if nums.size == 1", "  return 0 if nums.empty?\n  return nums.min\
    \ if nums.length == 1", "  n = nums.length\n  return -1 if n.zero?\n  return nums[0]\
    \ if n == 1", "  min_sum = nil\n  sum = 0\n  min_sum = sum if min_sum.nil?\n \
    \ nums.each do |num|\n    sum += num\n    min_sum = sum if min_sum.nil? || sum\
    \ < min_sum\n    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  min_sum = Float::INFINITY\n\
    \  curr_sum = 0\n  start = 0\n  nums.each_with_index do |ele, idx|\n    curr_sum\
    \ += ele\n    while curr_sum >= 0\n      min_sum = [min_sum, curr_sum].min\n \
    \     curr_sum -= nums[start]\n      start += 1\n    end\n  end\n  min_sum\nend",
  "  min_sum = nums[0]\n  sum = nums[0]\n  for i in 1...nums.length\n    sum = [nums[i],\
    \ sum + nums[i]].min\n    min_sum = [min_sum, sum].min\n  end\n  min_sum\nend",
  "  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    current_sum +=\
    \ num\n    min_sum = current_sum if current_sum < min_sum\n    current_sum = 0\
    \ if current_sum < 0\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  sum = 0\n\
    \  nums.each do |num|\n    sum += num\n    min_sum = sum if sum < min_sum\n  \
    \  sum = 0 if sum < 0\n  end\n  min_sum\nend", "  min_sum = nil\n  len = nums.length\n\
    \  len.times do |i|\n    sub_arr = nums[i..len - 1]\n    break if sub_arr.empty?\n\
    \    sum = sub_arr.reduce(:+)\n    min_sum = sum if !min_sum || sum < min_sum\n\
    \  end\n  min_sum\nend", "  return if nums.nil? || nums.empty?\n  sum = 0\n  m\
    \ = nums[0]\n  sum = nums[0]\n  for i in 1...nums.length\n    sum = [nums[i],\
    \ sum + nums[i]].min\n    m = [m, sum].min\n  end\n  m\nend", "  return nil if\
    \ nums.empty?\n  return nums.min if nums.length == 1", "    return nums.min if\
    \ nums.all? { |num| num < 0 }\n    min_sum = nil\n    0.upto(nums.length - 1)\
    \ do |i|\n        sum = 0\n        i.upto(nums.length - 1) do |j|\n          \
    \  sum += nums[j]\n            min_sum = sum if min_sum.nil? || sum < min_sum\n\
    \        end\n    end\n    min_sum\nend", "  # TODO\nend", "  return nil if nums.nil?\
    \ || nums.empty?\n  min = nums[0]\n  return min if nums.length == 1\n  (1...nums.length).each\
    \ do |idx|\n    min = [min, nums[idx]].min\n  end\n  sum = min\n  (0...nums.length).each\
    \ do |i|\n    sum = nums[i]\n    (i + 1...nums.length).each do |j|\n      sum\
    \ += nums[j]\n      min = [min, sum].min\n    end\n  end\n  min\nend", "  min_sum\
    \ = nums[0]\n  current_sum = nums[0]", "  return nil if nums.nil?\n  return nums.min\
    \ if nums.size == 1\n  min = nums[0]\n  prev = nums[0]\n  (1...nums.size).each\
    \ do |i|\n    val = prev + nums[i]\n    if nums[i] > val\n      min = val\n  \
    \    prev = val\n    else\n      min = nums[i]\n      prev = nums[i]\n    end\n\
    \  end\n  min\nend", "  sorted = nums.sort.reverse\n  result = sorted.first\n\
    \  while sorted.empty?\n    current = sorted.shift\n    result = current if current\
    \ > 0\n    sorted.each do |n|\n      current += n\n      result = current if current\
    \ < result\n    end\n  end\n  result\nend", "  return nums.min if nums.length\
    \ == 1\n  sums = {}\n  sums[nums.length] = nums.inject(:+)\n  nums.length.times\
    \ do |i|\n    sums[nums.length - i - 1] = sums[nums.length - i] - nums[nums.length\
    \ - i - 1]\n  end\n  sums.values.min\nend", "  return 0 if nums.nil? || nums.empty?\n\
    \  return nums.min if nums.length == 1", "  minimum_sum = nums[0]\n  current_sum\
    \ = 0", '  return 0 if nums.nil?', "  # return 0 if nums.empty?\n  # smallest\
    \ = nil\n  # (0...nums.length).each do |start|\n  #   (start...nums.length).each\
    \ do |stop|\n  #     smallest = nums[start..stop].reduce(:+) if smallest.nil?\
    \ || nums[start..stop].reduce(:+) < smallest\n  #   end\n  # end\n  # smallest\n\
    \  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    current_sum\
    \ += num\n    min_sum = current_sum if current_sum < min_sum\n    current_sum\
    \ = 0 if current_sum < 0\n  end\n  min_sum\nend", "  min_sum = nil\n  i = 0\n\
    \  until i == nums.length\n    j = i\n    sum = 0\n    until j == nums.length\n\
    \      sum += nums[j]\n      if min_sum.nil? || sum < min_sum\n        min_sum\
    \ = sum\n      end\n      j += 1\n    end\n    i += 1\n  end\n  min_sum\nend",
  "  min_sum = nums[0]\n  sum = 0\n  nums.each do |num|\n    sum += num\n    min_sum\
    \ = sum if sum < min_sum\n    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  min\
    \ = 0\n  p nums.length\n  (0...nums.length).each do |i|\n    min = nums[i]\n \
    \   if i == nums.length - 1\n      break\n    end\n    (i+1...nums.length).each\
    \ do |j|\n      sum = nums[i..j].reduce(:+)\n      if sum < min\n        min =\
    \ sum\n      end\n    end\n  end\n  min\nend", "  min_sum = nil\n  for i in 0..nums.length-1\n\
    \    for j in i..nums.length-1\n      sum = 0\n      for k in i..j\n        sum\
    \ += nums[k]\n      end\n      min_sum = sum if !min_sum || sum < min_sum\n  \
    \  end\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  curr_sum = nums[0]\n \
    \ index = 1\n  while index < nums.length\n    curr_sum = [nums[index], curr_sum\
    \ + nums[index]].min\n    min_sum = [min_sum, curr_sum].min\n    index += 1\n\
    \  end\n  min_sum\nend", "  min_sum = nums[0]\n  current_sum = 0\n  nums.each\
    \ do |num|\n    current_sum += num\n    min_sum = current_sum if current_sum <\
    \ min_sum\n    current_sum = 0 if current_sum < 0\n  end\n  min_sum\nend", " \
    \ min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    current_sum\
    \ += num\n    min_sum = current_sum if current_sum < min_sum\n    current_sum\
    \ = 0 if current_sum < 0\n  end\n  min_sum\nend", "  min_sum = 0\n  sum = 0\n\
    \  min_sum = nums[0]", "    min_sum = nil\n    nums.each_with_index do |num, idx|\n\
    \        max_sum = num\n        curr_sum = num\n        nums[idx + 1..-1].each\
    \ do |num2|\n            curr_sum += num2\n            max_sum = curr_sum if curr_sum\
    \ > max_sum\n        end\n        min_sum = max_sum if min_sum.nil? || max_sum\
    \ < min_sum\n    end\n    min_sum\nend", "  len = nums.length\n  len.times do\
    \ |i|\n    nums[i] += nums[i - 1]\n  end\n  result = nums[0]\n  (len - 1).times\
    \ do |i|\n    len.times do |j|\n      result = nums[j] - nums[i] if result > nums[j]\
    \ - nums[i]\n    end\n  end\n  result\nend", "  minimum_sum = nums[0]\n  temp_sum\
    \ = nums[0]\n  (1...nums.length).each do |index|\n    temp_sum = [nums[index],\
    \ temp_sum + nums[index]].min\n    minimum_sum = [minimum_sum, temp_sum].min\n\
    \  end\n  minimum_sum\nend", "  # base case\n  return 0 if nums.empty?\n  return\
    \ nums.min if nums.size == 1", "    min_sum = nums[0]\n    sum = 0\n    i = 0\n\
    \    while i < nums.length\n        sum += nums[i]\n        if sum < min_sum\n\
    \            min_sum = sum\n        end\n        if sum > 0\n            sum =\
    \ 0\n        end\n        i += 1\n    end\n    min_sum\nend", "  min = nums[0]\n\
    \  sum = 0\n  for i in 0..nums.length - 1\n    sum += nums[i]\n    min = sum if\
    \ sum < min\n    sum = 0 if sum < 0\n  end\n  min\nend", "  min = nums[0]\n  sum\
    \ = nums[0]\n  nums[1..-1].each do |x|\n    sum = [x, sum + x].min\n    min =\
    \ [min, sum].min\n  end\n  min\nend", "    return 0 if nums.empty?\n    sum =\
    \ 0\n    min_sum = nums[0]\n    nums.each do |num|\n        sum += num\n     \
    \   min_sum = sum if sum < min_sum\n        sum = 0 if sum < 0\n    end\n    min_sum\n\
    end", "  running_sum = nums[0]\n  min_sum = nums[0]", "  min_sum = nums[0]\n \
    \ sum = 0\n  nums.each do |n|\n    sum += n\n    min_sum = sum if sum < min_sum\n\
    \    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  current_sum\
    \ = nums[0]", "  min = nums[0]\n  sum = nums[0]\n  (1...nums.length).each do |i|\n\
    \    if sum > 0\n      sum = nums[i]\n    else\n      sum += nums[i]\n    end\n\
    \    min = sum if sum < min\n  end\n  min\nend", '  min_sum = min_ending_here
    = nums[0]', "  min_sum = nums[0]\n  sum = nums[0]\n  (1...nums.length).each do\
    \ |i|\n    sum = [nums[i], sum + nums[i]].min\n    min_sum = [min_sum, sum].min\n\
    \  end\n  min_sum\nend", "  min = nums[0]\n  curr = 0\n  for i in 0...nums.length\n\
    \    curr += nums[i]\n    min = curr if curr < min\n    curr = 0 if curr < 0\n\
    \  end\n  min\nend", "  prefix_sums = [0]\n  nums.each { |num| prefix_sums <<\
    \ prefix_sums.last + num }\n  min_sum = prefix_sums.last\n  prefix_sums.each_with_index\
    \ do |previous_sum, index|\n    (index + 1...prefix_sums.length).each do |current_index|\n\
    \      min_sum = [min_sum, prefix_sums[current_index] - previous_sum].min\n  \
    \  end\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  current_sum = 0\n  i =\
    \ 0\n  while i < nums.length\n    current_sum += nums[i]\n    min_sum = current_sum\
    \ if current_sum < min_sum\n    current_sum = 0 if current_sum < 0\n    i += 1\n\
    \  end\n  min_sum\nend", "  return nil if nums.nil? || nums.empty?\n  min_sum\
    \ = nil\n  (0...nums.length).each do |i|\n    (i...nums.length).each do |j|\n\
    \      sum = nums[i..j].reduce(:+)\n      min_sum = sum if min_sum.nil? || sum\
    \ < min_sum\n    end\n  end\n  min_sum\nend", "  min = nums[0]\n  sum = 0\n  nums.each\
    \ do |x|\n    sum += x\n    if sum < min\n      min = sum\n    end\n    if sum\
    \ > 0\n      sum = 0\n    end\n  end\n  min\nend", "  min_sum = nums[0]\n  sum\
    \ = 0\n  nums.each do |num|\n    sum += num\n    min_sum = sum if sum < min_sum\n\
    \    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  current_min = nums[0]\n  lowest_min\
    \ = nums[0]\n  nums[1..-1].each do |num|\n    current_min = [num, current_min\
    \ + num].min\n    lowest_min = [current_min, lowest_min].min\n  end\n  lowest_min\n\
    end", "    max_sum = nums[0]\n    max_sum_here = 0\n    nums.each do |num|\n \
    \       max_sum_here += num\n        max_sum = [max_sum, max_sum_here].max\n \
    \       max_sum_here = 0 if max_sum_here < 0\n    end\n    max_sum\nend", "  min_sum\
    \ = nums[0]\n  curr_sum = nums[0]\n  nums[1..-1].each do |num|\n    curr_sum =\
    \ [num, curr_sum + num].min\n    min_sum = [min_sum, curr_sum].min\n  end\n  min_sum\n\
    end", "  return 0 if nums.empty?\n  return nums.first if nums.length == 1", " \
    \ min = 0\n  sum = 0\n  start = 0\n  finish = 0\n  min_length = nums.length +\
    \ 1\n  for i in 0..nums.length-1\n    if sum < 0\n      sum = 0\n      start =\
    \ i\n    end\n    sum += nums[i]\n    if sum < min\n      min = sum\n      finish\
    \ = i\n      min_length = finish - start + 1\n    elsif sum == min\n      if (i\
    \ - start + 1) < min_length\n        finish = i\n        min_length = finish -\
    \ start + 1\n      end\n    end\n  end\n  min\nend", "    min_sum = Float::INFINITY\n\
    \    curr_sum = 0\n    start_index = 0\n    (0...nums.length).each do |index|\n\
    \        curr_sum += nums[index]\n        while (curr_sum > 0) do\n          \
    \  min_sum = [min_sum, curr_sum].min\n            curr_sum -= nums[start_index]\n\
    \            start_index += 1\n        end\n    end\n    min_sum\nend", "  curr_min\
    \ = nums[0]\n  sum = 0\n  nums.each do |n|\n    sum += n\n    if sum < curr_min\n\
    \      curr_min = sum\n    end\n    if sum > 0\n      sum = 0\n    end\n  end\n\
    \  curr_min\nend", "  current_sum = nums[0]\n  min_sum = current_sum", "  min_sum\
    \ = nums[0]\n  curr_sum = 0\n  nums.each do |num|\n    curr_sum += num\n    min_sum\
    \ = curr_sum if curr_sum < min_sum\n    curr_sum = 0 if curr_sum < 0\n  end\n\
    \  min_sum\nend", "    if nums.length == 0\n        return 0\n    end\n    min_sum\
    \ = Float::INFINITY\n    sum = 0\n    for i in 0..nums.length - 1\n        sum\
    \ += nums[i]\n        min_sum = [min_sum, sum].min\n        sum = [sum, 0].max\n\
    \    end\n    return min_sum\nend", "  return nums.min if nums.length == 1\n \
    \ i = j = 0\n  min_sum = Float::INFINITY\n  sum = 0\n  while j < nums.length\n\
    \    sum += nums[j]\n    if sum < min_sum\n      min_sum = sum\n    end\n    if\
    \ sum >= 0\n      sum -= nums[i]\n      i += 1\n    end\n    j += 1\n  end\n \
    \ min_sum\nend", "  return nil if nums.length == 0\n  nums.each_with_index do\
    \ |num, i|\n    if num > 0\n      nums[i] = -num\n    end\n  end\n  nums = kadane(nums)\n\
    \  nums.each_with_index do |num, i|\n    if num < 0\n      nums[i] = -num\n  \
    \  end\n  end\n  nums.inject(:+)\nend", "  min_sum = nums[0]\n  sum = nums[0]\n\
    \  nums[1..-1].each do |num|\n    if sum < 0\n      sum = num\n    else\n    \
    \  sum += num\n    end\n    min_sum = sum if sum < min_sum\n  end\n  min_sum\n\
    end", "  min_sum = nums[0]\n  nums.each_with_index do |num, index|\n    nums[index..-1].each_with_index\
    \ do |num2, index2|\n      min_sum = nums[index..index2].reduce(:+) if nums[index..index2].reduce(:+)\
    \ < min_sum\n    end\n  end\n  min_sum\nend", "  return nums.min if nums.size\
    \ == 1\n  return nums.reduce(:+) if nums.size == nums.reject { |i| i >= 0 }.size\n\
    \  return 0 if nums.reject { |i| i < 0 }.size == nums.size\n  return nums.min\
    \ if nums.reject { |i| i < 0 }.size == 0\n  head = 0\n  tail = nums.size - 1\n\
    \  min_sub_array_sum = nums.reduce(:+)\n  sub_array_sum = nums.reduce(:+)\n  while\
    \ head <= tail\n    if sub_array_sum >= 0\n      tail -= 1\n      if tail < 0\n\
    \        break\n      end\n      sub_array_sum -= nums[tail + 1]\n    else\n \
    \     min_sub_array_sum = [min_sub_array_sum, sub_array_sum].min\n      head +=\
    \ 1\n      if head > nums.size - 1\n        break\n      end\n      sub_array_sum\
    \ += nums[head - 1]\n    end\n  end\n  min_sub_array_sum\nend", "  return nil\
    \ if nums.nil? || nums.empty?\n  local_min = global_min = nums[0]\n  nums[1..-1].each\
    \ do |num|\n    local_min = [num, local_min + num].min\n    global_min = [local_min,\
    \ global_min].min\n  end\n  global_min\nend", "  min_sum = Float::INFINITY\n \
    \ return 0 if nums.empty?", "  return 0 if nums.length.zero?\n  sum = nums[0]\n\
    \  min_sum = nums[0]\n  (1...nums.length).each do |i|\n    sum = [nums[i], sum\
    \ + nums[i]].min\n    min_sum = [min_sum, sum].min\n  end\n  min_sum\nend", " \
    \ min_sum = nums[0]\n  curr_sum = 0\n  nums.each do |num|\n    curr_sum += num\n\
    \    min_sum = curr_sum if curr_sum < min_sum\n    curr_sum = 0 if curr_sum <\
    \ 0\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  current_sum = nums[0]", " \
    \ return nil if nums.nil? || nums.length == 0\n  res = nums[0]\n  sum = nums[0]\n\
    \  (1...nums.length).each do |i|\n    sum = [nums[i], sum + nums[i]].min\n   \
    \ res = [res, sum].min\n  end\n  res\nend", "  min_sum = nil\n  start = 0\n  sum\
    \ = 0\n  i = 0\n  while start < nums.length && i < nums.length\n    sum += nums[i]\n\
    \    if min_sum.nil? || sum < min_sum\n      min_sum = sum\n    end\n    if sum\
    \ >= 0\n      start += 1\n      i = start\n      sum = 0\n    else\n      i +=\
    \ 1\n    end\n  end\n  min_sum\nend", "  return nums.min if nums.size <= 1\n \
    \ sub_sums = nums.map.with_index do |num, i|\n    sum = num\n    (i+1).upto(nums.size-1)\
    \ do |j|\n      sum += nums[j]\n      return sum if sum >= 0\n    end\n    sum\n\
    \  end\n  sub_sums.min\nend", "  i = j = sum = 0\n  min_sum = nil\n  n = nums.size\n\
    \  while j < n\n    sum += nums[j]\n    while i <= j\n      if !min_sum || sum\
    \ < min_sum\n        min_sum = sum\n      end\n      sum -= nums[i]\n      i +=\
    \ 1\n    end\n    j += 1\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  current_sum\
    \ = nums[0]", "  size = nums.size\n  return 0 if size.zero?\n  (1...size).reduce(nums)\
    \ do |memo, _i|\n    memo.map.with_index do |item, idx|\n      (idx...size).reduce(item)\
    \ do |inner_memo, inner_idx|\n        memo[inner_idx] += item\n        inner_memo\
    \ = memo[inner_idx] if memo[inner_idx] < inner_memo\n        inner_memo\n    \
    \  end\n    end\n  end.min\nend", "  min_sum = 0\n  curr_sum = 0\n  nums.each\
    \ do |num|\n    curr_sum += num\n    min_sum = curr_sum if curr_sum < min_sum\n\
    \    curr_sum = 0 if curr_sum > 0\n  end\n  min_sum\nend", "  n = nums.length\n\
    \  cum_sum = Array.new(n, 0)\n  cum_sum[0] = nums[0]\n  min_sub_sum = nums[0]\n\
    \  result = nums[0]", "  return 0 if nums.nil? || nums.empty?\n  min_sum = 1.0\
    \ / 0.0\n  curr_sum = 0\n  min_sum = curr_sum if min_sum > curr_sum\n  0.upto(nums.length\
    \ - 1) do |i|\n    curr_sum += nums[i]\n    min_sum = curr_sum if min_sum > curr_sum\n\
    \    (i + 1).upto(nums.length - 1) do |j|\n      curr_sum += nums[j]\n      min_sum\
    \ = curr_sum if min_sum > curr_sum\n    end\n    curr_sum = 0\n  end\n  min_sum\n\
    end", "  min_sum = nums[0]\n  current_sum = nums[0]", "  return 0 if nums.empty?\n\
    \  # create array to save arrays size and sum\n  # in first iteration the array\
    \ will include element and its sum\n  # after that it will be start and end index\
    \ of the sub array and its sum\n  # ex: [0, 4] with sum = 1\n  # means we need\
    \ to start from index 0 to 4 (exclusive) to get sum 1\n  sub_array_info = [[0,\
    \ nums.length - 1, nums.sum]]\n  min_sum = nums.sum\n  start_index = 0\n  until\
    \ sub_array_info.empty?\n    start_index, end_index, sum = sub_array_info.shift\n\
    \    next if sum >= min_sum", "  ans = nums[0]\n  sum = 0\n  nums.each do |num|\n\
    \    sum += num\n    ans = sum if sum < ans\n    sum = 0 if sum < 0\n  end\n \
    \ ans\nend", "  min_sum = nums[0]\n  nums.each_with_index do |x, i|\n    sum =\
    \ x\n    (i+1).upto(nums.length-1) do |j|\n      sum += nums[j]\n      if sum\
    \ < min_sum\n        min_sum = sum\n      end\n    end\n  end\n  min_sum\nend",
  "  # Runtime: 32 ms, faster than 69.64% of Ruby online submissions for Minimum Size\
    \ Subarray Sum.\n  # Memory Usage: 9.5 MB, less than 100.00% of Ruby online submissions\
    \ for Minimum Size Subarray Sum.\n  min_sum = Float::INFINITY\n  nums.each_with_index\
    \ do |num, idx|\n    (idx...nums.length).each do |_, jdx|\n      min_sum = [min_sum,\
    \ nums[idx..jdx].sum].min\n    end\n  end\n  min_sum\nend", "  min = Float::INFINITY\n\
    \  sum = 0\n  min_i = 0\n  min_j = 0\n  (0...nums.length).each do |i|\n    j =\
    \ i\n    while j < nums.length\n      sum += nums[j]\n      if sum < min\n   \
    \     min = sum\n        min_i = i\n        min_j = j\n      end\n      j += 1\n\
    \    end\n    sum = 0\n  end\n  min\nend\np minSubArraySum([2, 3, 4, 1, 2, 4])\
    \ # 1\np minSubArraySum([-1, -2, -3]) # -6", "  min_sum = nums[0]\n  sum = 0\n\
    \  nums.each_with_index do |n, i|\n    sum += n\n    min_sum = sum if sum < min_sum\n\
    \    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  curr_sum = 0\n  min_sum =\
    \ Float::INFINITY\n  nums.each do |n|\n    curr_sum += n\n    min_sum = [min_sum,\
    \ curr_sum].min\n    curr_sum = 0 if curr_sum < 0\n  end\n  min_sum\nend", " \
    \ raise ArgumentError, 'num is empty' if nums.empty?", "  return 0 if nums.empty?\n\
    \  max = nums.max\n  return nums.min if max < 0\n  return nums.min if nums.size\
    \ == 1\n  out = nums.first\n  i = 0\n  j = 1\n  while j < nums.size\n    out +=\
    \ nums[j]\n    if out > 0\n      if nums[j] < 0\n        out += nums[j]\n    \
    \  end\n    else\n      out = nums[j]\n    end\n    j += 1\n  end\n  out\nend",
  "  # TODO: Implement this method...\nend", "  min = nums[0]\n  sum = 0\n  nums.each\
    \ do |num|\n    sum += num\n    min = sum if sum < min\n    sum = 0 if sum < 0\n\
    \  end\n  min\nend", "  min = nums[0]\n  sum = 0\n  nums.each do |num|\n    sum\
    \ += num\n    if sum < min\n      min = sum\n    end\n    if sum > 0\n      sum\
    \ = 0\n    end\n  end\n  min\nend", "  return nums.min if nums.length == 1\n \
    \ min = nums[0]\n  start = 0\n  finish = 1\n  current = nums[0]", "  min = Float::INFINITY\n\
    \  left = 0\n  right = 0\n  sum = 0\n  while right < nums.length\n    sum += nums[right]\n\
    \    right += 1\n    while sum >= 0\n      min = [min, sum].min\n      sum -=\
    \ nums[left]\n      left += 1\n    end\n  end\n  min\nend", "  min = Float::INFINITY\n\
    \  sum = 0\n  start = 0\n  nums.size.times do |i|\n    sum += nums[i]\n    min\
    \ = sum if sum < min\n    sum -= nums[start] if i - start + 1 > nums.size / 2\n\
    \    min = sum if sum < min\n    start += 1\n  end\n  min\nend", "  answer = nil\n\
    \  nums.each_index do |i|\n    (nums.length - i).times do |j|\n      sub_array\
    \ = nums[i..(i + j)]\n      answer = sub_array.sum if answer.nil? || sub_array.sum\
    \ < answer\n    end\n  end\n  answer\nend", "  return nums.min if nums.length\
    \ == 1\n  min = nil\n  nums.each_with_index do |n, i|\n    curr = nil\n    ((i\
    \ + 1)...nums.length).each do |x|\n      if curr.nil?\n        curr = n + nums[x]\n\
    \      else\n        curr += nums[x]\n      end\n      if min.nil? || curr < min\n\
    \        min = curr\n      end\n    end\n  end\n  min\nend", "  return 0 if nums.empty?\n\
    \  n = nums.length\n  partial_sums = Array.new(n)\n  partial_sums[0] = nums[0]\n\
    \  min_sub_array_sum = nums[0]\n  (1...n).each do |i|\n    partial_sums[i] = nums[i]\
    \ + partial_sums[i - 1]\n    min_sub_array_sum = [min_sub_array_sum, partial_sums[i]].min\n\
    \  end\n  (1...n).each do |i|\n    partial_sums[i] = [partial_sums[i], partial_sums[i\
    \ - 1]].min\n    min_sub_array_sum = [min_sub_array_sum, partial_sums[i]].min\n\
    \  end\n  min_sub_array_sum\nend", "  return 0 if nums.empty?\n  min_sum = (1\
    \ << 64)\n  current_sum = 0\n  nums.each do |n|\n    current_sum += n\n    min_sum\
    \ = [min_sum, current_sum].min\n    current_sum = 0 if current_sum < 0\n  end\n\
    \  min_sum\nend", "  min_sum = nums[0]\n  curr_sum = nums[0]\n  left = 0\n  right\
    \ = 0", "  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    current_sum\
    \ += num\n    min_sum = current_sum if current_sum < min_sum\n    current_sum\
    \ = 0 if current_sum < 0\n  end\n  min_sum\nend", "  max_value = 2**31 - 1\n \
    \ min_value = -2**31\n  min_sum = max_value\n  sum = 0\n  min_values = {}\n  nums.each_with_index\
    \ do |num, i|\n    sum += num\n    min_sum = sum if sum < min_sum", "  sum = nums[0]\n\
    \  min_sum = nums[0]\n  (1...nums.length).each do |idx|\n    if nums[idx] < min_sum\
    \ + nums[idx]\n      min_sum = nums[idx]\n    else\n      min_sum += nums[idx]\n\
    \    end\n    sum = min_sum if min_sum < sum\n  end\n  sum\nend", "  sum = 0\n\
    \  min_sum = nil\n  nums.each_with_index do |num, i|\n    sum += num\n    min_sum\
    \ = sum if min_sum.nil? || sum < min_sum\n    sum = 0 if sum < 0\n  end\n  min_sum\n\
    end", "  current = nums[0]\n  current_min = nums[0]\n  arr_length = nums.length\n\
    \  for i in 1...arr_length\n    current = [nums[i], current + nums[i]].min\n \
    \   current_min = [current, current_min].min\n  end\n  current_min\nend", "  return\
    \ nil if nums.nil?\n  return nums.first if nums.length == 1", "  return 0 if nums.length.zero?\n\
    \  min_sum = nums[0]\n  current_sum = 0\n  start = 0\n  (0...nums.length).each\
    \ do |i|\n    current_sum += nums[i]\n    min_sum = [min_sum, current_sum].min\n\
    \    current_sum = 0 if current_sum < 0\n  end\n  min_sum\nend", "  min_sum =\
    \ 0\n  current_sum = 0\n  nums.each do |num|\n    current_sum += num\n    min_sum\
    \ = current_sum if current_sum < min_sum\n    current_sum = 0 if current_sum >\
    \ 0\n  end\n  min_sum\nend", "  min_sum = Float::INFINITY\n  current_sum = 0",
  "  min_sum = nil\n  prev_sum = nil\n  (0...nums.length).each do |i|\n    (i...nums.length).each\
    \ do |j|\n      prev_sum = nums[i..j].sum\n      if prev_sum < min_sum || min_sum.nil?\n\
    \        min_sum = prev_sum\n      end\n    end\n  end\n  min_sum\nend", "  return\
    \ nil if nums.empty?\n  min = Float::INFINITY\n  total = 0\n  nums.each do |n|\n\
    \    total += n\n    min = total if total < min\n    total = 0 if total < 0\n\
    \  end\n  min\nend", "  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n\
    \    current_sum += num\n    min_sum = current_sum if current_sum < min_sum\n\
    \    current_sum = 0 if current_sum < 0\n  end\n  min_sum\nend", "  current_min\
    \ = nums[0]\n  current_sum = 0\n  nums.each do |n|\n    current_sum += n\n   \
    \ current_min = current_sum if current_sum < current_min\n    current_sum = 0\
    \ if current_sum < 0\n  end\n  current_min\nend", "  return nil if nums.empty?\n\
    \  min_sum = current_sum = nums[0]\n  (1...nums.length).each do |idx|\n    if\
    \ current_sum > 0\n      current_sum = nums[idx]\n    else\n      current_sum\
    \ += nums[idx]\n    end\n    min_sum = current_sum if current_sum < min_sum\n\
    \  end\n  min_sum\nend", "  min_sum = nil\n  start = 0\n  current_sum = 0\n  for\
    \ i in 0..nums.length - 1\n    current_sum += nums[i]\n    if !min_sum || current_sum\
    \ < min_sum\n      min_sum = current_sum\n    end\n    if current_sum > 0\n  \
    \    current_sum = 0\n      start = i + 1\n    end\n  end\n  min_sum\nend", " \
    \ min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    current_sum\
    \ += num\n    min_sum = current_sum if current_sum < min_sum\n    current_sum\
    \ = 0 if current_sum < 0\n  end\n  min_sum\nend", "    return 0 if nums.nil?\n\
    \    return nums.min if nums.length == 1\n    min = Float::INFINITY\n    left,\
    \ right = 0, 0\n    sum = 0\n    while left < nums.length\n        if sum < 0\n\
    \            sum = 0\n            right = left\n        end\n        sum += nums[right]\n\
    \        min = sum if sum < min\n        right += 1\n        if right == nums.length\n\
    \            left += 1\n            right = left\n        end\n    end\n    min\n\
    end", "  return nums.min if nums.length == 1\n  min = nums[0]\n  sum = 0\n  for\
    \ i in 0..nums.length - 1\n    if nums[i] < min\n      min = nums[i]\n    end\n\
    \    for j in i..nums.length - 1\n      sum += nums[j]\n      if sum < min\n \
    \       min = sum\n      end\n    end\n    sum = 0\n  end\n  min\nend", "  return\
    \ nil if nums.nil? || nums.empty?\n  min_sum = Float::INFINITY\n  curr_sum = 0\n\
    \  nums.each do |num|\n    curr_sum += num\n    min_sum = curr_sum if curr_sum\
    \ < min_sum\n    curr_sum = 0 if curr_sum < 0\n  end\n  min_sum\nend", "  min_sum\
    \ = 0\n  sum = 0\n  nums.each do |num|\n    sum += num\n    min_sum = sum if sum\
    \ < min_sum\n    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  min_sum = nums[0]\n\
    \  sum = 0\n  nums.each do |num|\n    sum += num\n    min_sum = sum if sum < min_sum\n\
    \    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  min_sum = nums[0]\n  sum =\
    \ nums[0]\n  (1...nums.length).each do |i|\n    sum = [nums[i], sum + nums[i]].min\n\
    \    min_sum = [min_sum, sum].min\n  end\n  min_sum\nend", "  min = 0\n  sum =\
    \ 0\n  i = 0\n  j = 0\n  while i < nums.length\n    while j < nums.length\n  \
    \    sum += nums[j]\n      min = sum if sum < min\n      j += 1\n    end\n   \
    \ sum = 0\n    i += 1\n    j = i\n  end\n  min\nend", "  return 0 if nums.empty?\n\
    \  min_sum = nums[0]\n  sum = 0\n  nums.each do |num|\n    sum += num\n    min_sum\
    \ = sum if sum < min_sum\n    sum = 0 if sum < 0\n  end\n  min_sum\nend", "  min_sum\
    \ = nums[0]\n  current_sum = 0\n  (0...nums.length).each do |idx|\n    current_sum\
    \ += nums[idx]\n    min_sum = current_sum if current_sum < min_sum\n    current_sum\
    \ = 0 if current_sum < 0\n  end\n  min_sum\nend", "  return 0 if nums.nil? ||\
    \ nums.empty?\n  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |n|\n  \
    \  current_sum += n\n    min_sum = current_sum if current_sum < min_sum\n    current_sum\
    \ = 0 if current_sum < 0\n  end\n  min_sum\nend", "  #return nil if nums.length\
    \ == 0\n  return nums.min if nums.length == 1\n  min = nil\n  (0...nums.length).each\
    \ do |i|\n    j = i\n    while j < nums.length\n      sum = nums[i..j].reduce(:+)\n\
    \      min = sum if min.nil? || sum < min\n      j += 1\n    end\n  end\n  min\n\
    end", "  smallest_sum = nums.reduce(:+)\n  nums.each_with_index do |n, i|\n  \
    \  current_sum = n\n    smallest_sum = current_sum if current_sum < smallest_sum\n\
    \    nums[i + 1..-1].each do |num|\n      current_sum += num\n      smallest_sum\
    \ = current_sum if current_sum < smallest_sum\n    end\n  end\n  smallest_sum\n\
    end", "  prev_sum = 0\n  min_sum = Float::INFINITY\n  seen = {}", "  return nums.min\
    \ if nums.size == 1\n  min = nums.inject(:+)\n  n = nums.size\n  nums.each_with_index\
    \ do |num, i|\n    ((i + 1)...n).each do |j|\n      min = nums[i..j].inject(:+)\
    \ if nums[i..j].inject(:+) < min\n    end\n  end\n  min\nend", "  min_sum = Float::INFINITY\n\
    \  start = 0\n  sum = 0\n  for i in 0...nums.length\n    sum += nums[i]\n    while\
    \ sum >= 0\n      min_sum = [min_sum, sum].min\n      sum -= nums[start]\n   \
    \   start += 1\n    end\n  end\n  min_sum\nend", "  min = nil\n  (0...nums.length).each\
    \ do |start|\n    (start...nums.length).each do |last|\n      sub_array = nums[start..last]\n\
    \      sum = sub_array.sum\n      min = sum if min.nil? || sum < min\n    end\n\
    \  end\n  min\nend", "  return nums.min if nums.length == 1\n  arr = []\n  i =\
    \ 0\n  while i < nums.length\n    j = i\n    while j < nums.length\n      arr\
    \ << nums[i..j].reduce(:+)\n      j += 1\n    end\n    i += 1\n  end\n  arr.min\n\
    end", "  return 0 if nums.nil? || nums.empty?\n  return nums.min if nums.length\
    \ == 1", "  # p nums\n  return nums.min if nums.all? { |num| num < 0 }\n  return\
    \ nums.max if nums.all? { |num| num > 0 }\n  return nums.count if nums.all? {\
    \ |num| num == 0 }\n  return 0 if nums.all? { |num| num == nums[0] }\n  return\
    \ 0 if nums.all? { |num| num == nums[-1] }\n  return nums.max + nums.min if nums.count\
    \ == 2\n  return [nums.max + nums.min, nums.min, nums.max].min if nums.count ==\
    \ 3\n  min_sum = nums.min\n  nums.each_with_index do |num, i|\n    next if num\
    \ == 0\n    break if i == nums.count - 1\n    sum = num\n    j = i + 1\n    while\
    \ j < nums.count\n      next if nums[j] == 0\n      if sum + nums[j] < min_sum\n\
    \        min_sum = sum + nums[j]\n      end\n      break if min_sum == 1\n   \
    \   sum += nums[j]\n      j += 1\n    end\n  end\n  min_sum\nend", "  n = nums.length\n\
    \  sum = 0\n  i = 0\n  j = 0\n  min_sum = nums[0]\n  while j < n\n    sum += nums[j]\n\
    \    while sum < 0 && i < j\n      min_sum = sum if sum < min_sum\n      sum -=\
    \ nums[i]\n      i += 1\n    end\n    j += 1\n  end\n  return min_sum < 0 ? min_sum\
    \ : 0\nend", "  return nums.min if nums.size == 1\n  min_sum = nums.reduce(:+)\n\
    \  sum = 0\n  i = 0\n  while i < nums.size\n    j = i\n    while j < nums.size\n\
    \      sum += nums[j]\n      if sum < min_sum\n        min_sum = sum\n      end\n\
    \      j += 1\n    end\n    sum = 0\n    i += 1\n  end\n  min_sum\nend", "  return\
    \ nil if nums.nil? || nums.empty?\n  return nums.min if nums.size == 1", "  min_sum\
    \ = nums[0]\n  window_sum = 0\n  window_start = 0", "  nums_length = nums.length\n\
    \  sum = nums[0]\n  min_sum = sum\n  for i in 1...nums_length\n    sum = sum +\
    \ nums[i]\n    if sum > nums[i]\n      sum = nums[i]\n    end\n    if sum < min_sum\n\
    \      min_sum = sum\n    end\n  end\n  min_sum\nend", "  sum = 0\n  min_sum =\
    \ Float::INFINITY\n  min_sum_start_index = 0\n  min_sum_end_index = 0\n  start_index\
    \ = 0\n  end_index = 0", "  min_sum = nums[0]\n  curr_sum = 0\n  return nums.min\
    \ if nums.all? { |num| num < 0 }", "  min_sum = (1 << 30) * -1\n  current_sum\
    \ = 0\n  current_start = 0\n  current_end = 0\n  while current_end < nums.length\n\
    \    current_sum += nums[current_end]\n    while current_sum > 0 && current_start\
    \ < current_end\n      current_sum -= nums[current_start]\n      current_start\
    \ += 1\n    end\n    min_sum = [min_sum, current_sum].min\n    current_end +=\
    \ 1\n  end\n  min_sum\nend", "  len = nums.length\n  local_min = global_min =\
    \ nums[0]\n  (1...len).each do |i|\n    local_min = [nums[i], local_min + nums[i]].min\n\
    \    global_min = [local_min, global_min].min\n  end\n  global_min\nend", "  min_sum\
    \ = Float::INFINITY\n  current_sum = 0", "  curr_sum = 0\n  min_sum = nums[0]\n\
    \  i = 0\n  j = 0\n  while j < nums.length\n    curr_sum += nums[j]\n    min_sum\
    \ = curr_sum if curr_sum < min_sum\n    while curr_sum >= 0 && i < j\n      curr_sum\
    \ -= nums[i]\n      min_sum = curr_sum if curr_sum < min_sum\n      i += 1\n \
    \   end\n    j += 1\n  end\n  min_sum\nend", "  n = nums.length\n  min_sum = nums[0]\n\
    \  sum = nums[0]\n  (1...n).each do |i|\n    sum = nums[i] + [sum, 0].max\n  \
    \  min_sum = [min_sum, sum].min\n  end\n  min_sum\nend", "  min_sub_sum = nums[0]\n\
    \  nums.each_with_index do |num, index|\n    next if index == 0\n    nums[index]\
    \ = num + [nums[index - 1], 0].max\n    min_sub_sum = [min_sub_sum, nums[index]].min\n\
    \  end\n  min_sub_sum\nend", "  min_sum = Float::INFINITY\n  curr_sum = 0\n  #\
    \ If the sub-array is empty, the sum is 0\n  # Otherwise, we keep a running sum\
    \ and try to find the minimum sub-array sum\n  nums.each do |num|\n    curr_sum\
    \ += num\n    if curr_sum < min_sum\n      min_sum = curr_sum\n    end\n    if\
    \ curr_sum > 0\n      curr_sum = 0\n    end\n  end\n  min_sum\nend", "  min_sum\
    \ = 0\n  curr_sum = 0\n  for num in nums\n    curr_sum += num\n    min_sum = curr_sum\
    \ if curr_sum < min_sum\n    curr_sum = 0 if curr_sum > 0\n  end\n  min_sum\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
