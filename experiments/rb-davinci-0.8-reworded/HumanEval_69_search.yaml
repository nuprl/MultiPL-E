name: HumanEval_69_search
language: rb
prompt: "# You are given a non-empty array of positive integers. Return the greatest\
  \ integer that is greater than \n# zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n# The frequency of an integer is the number\
  \ of times it appears in the array.\n# If no such a value exist, return -1.\n# Examples:\n\
  # >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3,\
  \ 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n\
  \    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5,\
  \ 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1,\
  \ candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8,\
  \ 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1,\
  \ candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10,\
  \ 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1,\
  \ candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8,\
  \ 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7,\
  \ 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1,\
  \ candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7,\
  \ 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1,\
  \ candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5,\
  \ 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2,\
  \ 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10,\
  \ 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9,\
  \ 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1,\
  \ candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10,\
  \ 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9,\
  \ 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5,\
  \ 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9,\
  \ 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1,\
  \ candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"
completions: ["  lst.max_by{|i| i if lst.count(i) >= i} || -1\nend", "  hash = Hash.new(0)\n\
    \  lst.each { |e| hash[e] += 1 }\n  hash.each do |key, value|\n    return key\
    \ if value >= key\n  end\n  -1\nend", "  freq = lst.reduce(Hash.new(0)) { |h,\
    \ v| h[v] += 1; h }\n  freq.each_pair { |k, v| return k if k <= v }\n  -1\nend",
  "  # your code here\nend\n```", "  # lst.group_by(&:itself).each { |num, lst| return\
    \ num if num <= lst.size }\n  # -1\n  lst.find_all { |i| lst.count(i) >= i }.max\n\
    end", "    i = 0\n    while i < lst.length\n        count = 0\n        j = 0\n\
    \        while j < lst.length\n            if lst[i] == lst[j]\n             \
    \   count += 1\n            end\n            j += 1\n        end\n        if count\
    \ >= lst[i]\n            return lst[i]\n        end\n        i += 1\n    end\n\
    \    return -1\nend", "\t(lst.min..lst.max).each do |i|\n\t\treturn i if lst.count(i)\
    \ >= i\n\tend\n\t-1\nend", "  lst.sort!\n  lst.uniq.each { |x| return x if lst.count(x)\
    \ >= x }\n  -1\nend", "  lst.each_with_object(Hash.new(0)) { |item, memo| memo[item]\
    \ += 1 }\n    .find { |item, counter| item <= counter }&.first || -1\nend", " \
    \ lst.sort!\n  hash = {}\n  lst.each do |x|\n    if hash.has_key?(x)\n      hash[x]\
    \ += 1\n    else\n      hash[x] = 1\n    end\n  end\n  hash.each do |k, v|\n \
    \   if k <= v\n      return k\n    end\n  end\n  return -1\nend", "  # create\
    \ a hash to store the number and it's frequency\n  hsh = Hash.new(0)\n  # iterate\
    \ the list and calculate the frequency of each number\n  lst.each do |num|\n \
    \   hsh[num] += 1\n  end\n  # sort the hash by number and loop from the biggest\
    \ to smallest,\n  # if the frequency of number >= the number itself, return the\
    \ number\n  # else return -1\n  hsh.sort.reverse.each do |arr|\n    return arr[0]\
    \ if arr[1] >= arr[0]\n  end\n  -1\nend", "  lst.sort.uniq.each do |x|\n    return\
    \ x if x <= lst.count(x)\n  end\n  -1\nend", "  freq_hash = {}\n  lst.each do\
    \ |num|\n    freq_hash[num] = 0 if freq_hash[num].nil?\n    freq_hash[num] +=\
    \ 1\n  end\n  freq_hash.each do |k, v|\n    return k if k <= v\n  end\n  -1\n\
    end", "\tcount = Hash.new(0)\n\tlst.each { |num| count[num] += 1 }\n\tcount.select\
    \ { |num, times| num >= times }.max[0] || -1\nend", "    hsh = Hash.new(0)\n \
    \   lst.each { |n| hsh[n] += 1 }\n    search = lst.max\n    while search > 0\n\
    \        return search if hsh[search] >= search\n        search -= 1\n    end\n\
    \    -1\nend", "  lst.sort! # sort the input list\n  num_freq = Hash.new # declare\
    \ an empty hash to hold the number and frequency\n  lst.each do |num| # iterate\
    \ through the list\n    if num_freq.key?(num)\n      num_freq[num] += 1 # incrementing\
    \ the frequency value if the key exists\n    else\n      num_freq[num] = 1 # adding\
    \ the key and value if it doesn't exists\n    end\n  end\n  num_freq.each do |key,\
    \ value| # iterate through the number and frequency hash\n    if key >= value\n\
    \      return key # return the key if the value is equal or more than its key\n\
    \    end\n  end\n  return -1 # return -1 if no key with the conditions is found\n\
    end", "    result = -1\n    frqncy = {}\n    lst.each do |num|\n        frqncy[num]\
    \ = lst.count(num)\n    end\n    frqncy.each do |num, frq|\n        if num <=\
    \ frq \n            result = num if num > result\n        end\n    end\n    result\n\
    end", "  hash = {}\n  lst.each do |n|\n    if hash[n]\n      hash[n] += 1\n  \
    \  else\n      hash[n] = 1\n    end\n  end\n  hash = hash.sort_by { |key, value|\
    \ value }.reverse\n  hash.each do |key, value|\n    if key == value && key !=\
    \ 1\n      return key\n    end\n  end\n  -1\nend", "  hash = {}\n  lst.each do\
    \ |int|\n    if hash[int]\n      hash[int] += 1\n    else\n      hash[int] = 1\n\
    \    end\n  end\n  hash.each do |key, value|\n    if key <= value && key > 1\n\
    \      return key\n    end\n  end\n  return -1\nend", "  lst.sort!.uniq!\n  sum\
    \ = 0\n  lst.each do |n|\n    sum += 1 if lst.count(n) >= n\n  end\n  return sum\
    \ == 0 ? -1 : sum\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
