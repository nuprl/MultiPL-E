name: HumanEval_131_digits
language: rb
prompt: "# Given a positive integer n, return the product of the odd digits.\n# Return\
  \ 0 if all digits are even.\n# For example:\n# >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n\
  # 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n\
  \    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5,\
  \ candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5,\
  \ candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625,\
  \ candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"
completions: ["  digits = n.to_s.split('').map { |x| x.to_i }\n  digits.select! {\
    \ |x| x.odd? }\n  if digits.length > 0\n    digits.reduce(:*)\n  else\n    0\n\
    \  end\nend", "  array = n.to_s.split('')\n  filtered = array.map { |x| x.to_i\
    \ }.select { |y| y.odd? }\n  if filtered.empty?\n    0\n  else\n    filtered.reduce(:*)\n\
    \  end\nend", "  if n < 10\n    n % 2 == 0 ? 0 : n\n  else\n    d = n % 10\n \
    \   d % 2 == 0 ? digits(n / 10) : d * digits(n / 10)\n  end\nend", "  n.to_s.chars.inject(1)\
    \ { |prod, c| c.to_i.odd? ? prod * c.to_i : prod }\nend", "  n.to_s.chars.map\
    \ { |d| d.to_i }.select { |d| d.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "  if n == 0\n    return 0\n  else\n \
    \   ans = 0\n    all_even = true\n    while n > 0\n      last_digit = n % 10\n\
    \      if last_digit % 2 == 1\n        ans = ans * 10 + last_digit\n        all_even\
    \ = false\n      end\n      n = n / 10\n    end\n    if all_even\n      return\
    \ 0\n    else\n      return ans\n    end\n  end\nend", "  arr = n.to_s.split('')\n\
    \  multiply = 1\n  arr.each do |num|\n    multiply *= num.to_i if num.to_i.odd?\n\
    \  end\n  if multiply > 0\n    multiply\n  else\n    0\n  end\nend", "  # base\
    \ case\n  return 0 if n.digits.all? { |d| d.even? }", "  n.to_s.split('').select\
    \ { |x| x.to_i.odd? }.inject(1) { |product, x| product * x.to_i }\nend", "  #\
    \ TODO: implement this\nend", "  return 0 if n.to_s.scan(/\\d/).collect(&:to_i).all?(&:even?)\n\
    \  n.to_s.scan(/\\d/).collect(&:to_i).select(&:odd?).inject(:*)\nend", "  n =\
    \ n.to_s.split('')\n  n.delete_if { |x| x.to_i.even? }\n  if n.length == 0\n \
    \   0\n  else\n    n.map { |x| x.to_i }.reduce(:*)\n  end\nend", "  n.to_s.scan(/\\\
    d/).map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.chars.select {\
    \ |i| i.to_i.odd? }.reduce(1) { |prod, i| prod * i.to_i }\nend", "  num = n.to_s.split('')\n\
    \  prod = 1\n  if num.length > 1\n    num.each do |x|\n      prod *= x.to_i if\
    \ x.to_i.odd?\n    end\n  else\n    prod = 0\n  end\n  prod\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |d| d.odd? }.reduce(:*) || 0\nend", "  return 0 if n.digits.all?(&:even?)\n\
    \  n.digits.select(&:odd?).reduce(:*)\nend", "  n.to_s.split('').inject(1) { |result,\
    \ n| n.to_i.odd? ? result * n.to_i : result }\nend", "  n.to_s.chars.reduce(1)\
    \ { |acc, i| i.to_i.odd? ? acc * i.to_i : acc }\nend", "  total = 1\n  while n\
    \ > 0\n    remainder = n % 10\n    if remainder.odd?\n      total *= remainder\n\
    \    end\n    n /= 10\n  end\n  return total\nend", "  n.to_s.chars.inject(1)\
    \ { |s,i| i.to_i.odd? ? s * i.to_i : s }\nend", "  nums = n.to_s.split('')\n \
    \ odds = nums.select { |n| n.to_i.odd? }\n  odds.empty? ? 0 : odds.map(&:to_i).reduce(:*)\n\
    end", "  odds = []\n  product = 1\n  while n > 0\n    digit = n % 10\n    if digit.odd?\n\
    \      odds << digit\n    end\n    n /= 10\n  end\n  odds.each do |digit|\n  \
    \  product *= digit\n  end\n  product\nend", "  # your code here\nend", "  n.digits.select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "\tn.to_s.split('').inject(1) { |acc,\
    \ x| x.to_i.odd? ? acc * x.to_i : acc }\nend", "  n.to_s.split('').reduce(1) {\
    \ |m, c| c.to_i.odd? ? m * c.to_i : m }\nend", "  digits = []\n  final = []\n\
    \  result = 1\n  n.to_s.split('').each do |digit|\n    digits << digit.to_i\n\
    \  end\n  if digits.length == 1\n    final << digits[0]\n  else\n    digits.map\
    \ do |int|\n      if int % 2 != 0\n        final << int\n      end\n    end\n\
    \  end\n  if final.length == 0\n    result = 0\n  else\n    final.each do |odd|\n\
    \      result *= odd\n    end\n  end\n  result\nend", "  # TODO: implement the\
    \ method\nend", end, "  return 0 if n.digits.all?(&:even?)\n  n.digits.reject(&:even?).reduce(:*)\n\
    end", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n =\
    \ n.to_s.split('')\n  a = n.collect { |x| x.to_i }\n  b = a.delete_if { |x| x\
    \ % 2 == 0 }\n  b.inject(:*) || 0\nend", "  # find the array of digits\n  arr\
    \ = n.to_s.split('')\n  # iterate through the array and select the numbers that\
    \ are odd\n  arr = arr.select { |num| num.to_i.odd? }\n  # if there are no odd\
    \ numbers, return 0\n  if arr.empty?\n    return 0\n  # if there are odd numbers,\
    \ multiply them\n  else\n    arr.inject(1) { |sum, n| sum * n.to_i }\n  end\n\
    end", "  numbers = n.to_s.split('')\n  total = 1\n  numbers.each do |num|\n  \
    \  if num.to_i.odd?\n      total *= num.to_i\n    end\n  end\n  total\nend", " \
    \ # Your code here\nend", "\tres = 1\n\tn.to_s.each_char do |x|\n\t\ty = x.to_i\n\
    \t\tres *= y if y.odd?\n\tend\n\tres == 1 ? 0 : res\nend", "  return 0 if n.digits.all?(&:even?)\n\
    \  n.digits.select(&:odd?).reduce(:*)\nend", "  n.to_s.split('').map { |i| i.to_i\
    \ }.select { |i| i.odd? }.reduce(:*) || 0\nend", "  digits = n.to_s.split('').map\
    \ { |x| x.to_i }\n  result = 1\n  digits.each do |number|\n    result *= number\
    \ if number.odd?\n  end\n  result == 1 ? 0 : result\nend", "  n.to_s.split('').reduce(1)\
    \ { |a, e| e.to_i.odd? ? a * e.to_i : a }\nend", "  sum = 1\n  while n > 0\n \
    \   digit = n % 10\n    sum *= digit if digit.odd?\n    n /= 10\n  end\n  sum\n\
    end\nputs digits(1)\nputs digits(4)\nputs digits(235)", "  a = n.to_s.split('')\n\
    \  a.map!{|x| x.to_i}\n  odds = []\n  a.each {|x| odds << x if x.odd?}\n  odds.empty?\
    \ ? 0 : odds.inject(:*)\nend", "  return 0 if n == 0\n  digit = n % 10\n  digit\
    \ = digit % 2 == 0 ? 1 : digit\n  digit * digits(n / 10)\nend", "  n.to_s.split('').select{|x|\
    \ x.to_i % 2 != 0}.map{|x| x.to_i}.reduce(:*)\nend", "  n.to_s.scan(/\\d/).map(&:to_i).select\
    \ { |v| v.odd? }.reduce(:*) || 0\nend", "  digits = n.to_s.split('').map(&:to_i)\n\
    \  digits.select! { |digit| digit.odd? }\n  digits.reduce(:*) || 0\nend", "  n.digits.select(&:odd?).reduce(:*)\
    \ || 0\nend", "  return 0 if n == 0\n  return n if n < 10\n  last_digit = n %\
    \ 10\n  rest = n / 10\n  product = digits(rest)\n  (last_digit % 2 == 0) ? product\
    \ : product * last_digit\nend", "  arr = n.to_s.split('')\n  arr.delete('0')\n\
    \  if arr.include?('2') || arr.include?('4') || arr.include?('6') || arr.include?('8')\n\
    \    0\n  else\n    arr.map { |i| i.to_i}.inject(:*)\n  end\nend", "  n.to_s.split('').map(&:to_i).inject(1)\
    \ { |prod, x| x.odd? ? prod * x : prod }\nend", "  digits = n.to_s.split('').map{|s|\
    \ s.to_i}\n  odd_digits = digits.select{|x| x.odd?}\n  if odd_digits.length ==\
    \ 0\n    return 0\n  else\n    return odd_digits.reduce(:*)\n  end\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "\tstring = n.to_s\n\tarray = string.split('')\n\tarray.map! {|x|\
    \ x.to_i}\n\ttotal = 1\n\tarray.each do |x|\n\t\tif x % 2 != 0\n\t\t\ttotal =\
    \ total * x\n\t\tend\n\tend\n\tputs total\nend", "  result = n.to_s.split('').map(&:to_i).select\
    \ { |n| n.odd? }.reduce(:*)\n  result.nil? ? 0 : result\nend", "    a = n.to_s.split('')\n\
    \    sum = 0\n    a.each do |value|\n        if value.to_i.odd?\n            sum\
    \ = sum * value.to_i\n        end\n    end\n    sum\nend", "  n.to_s.chars.map(&:to_i).reduce(0){|a,n|\
    \ n.odd? ? a*n : a }\nend", "  new_arr = n.to_s.split('')\n  new_arr.map! { |x|\
    \ x.to_i }\n  new_arr.select! { |x| x.odd? }\n  if new_arr.size == 0\n    0\n\
    \  else\n    new_arr.reduce(:*)\n  end\nend", "  digits = []\n  n.to_s.split('').each\
    \ { |digit| digits << digit.to_i }\n  p digits\n  # loop through digits array\
    \ & check if any are even\n  # if all even, return 0\n  # if any odd, multiply\
    \ all the odd numbers together and return product\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |num| num.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').select { |d| d.to_i.odd?\
    \ }.map(&:to_i).reduce(:*) || 0\nend", "\tproduct = 1\n\twhile n > 0\n\t\tproduct\
    \ *= n % 10 if n % 2 == 1\n\t\tn /= 10\n\tend\n\tproduct\nend", "  n = n.to_s.split('')\n\
    \  n.map! { |x| x.to_i }\n  result = 1\n  n.each do |x|\n    result *= x if x.odd?\n\
    \  end\n  result\nend", "  sum = 1\n  n.to_s.split('').each do |num|\n    sum\
    \ *= num.to_i if num.to_i.odd?\n  end\n  sum\nend", "  if n <= 0\n    return 0\n\
    \  end\n  digit = n % 10\n  if digit % 2 == 0\n    return digits(n / 10)\n  else\n\
    \    return digit * digits(n / 10)\n  end\nend", "  # Your code here\nend", " \
    \ n.digits.reduce(0) { |sum, num| num.odd? ? sum * 10 + num : sum }\nend", " \
    \ return 0 if n < 1\n  n_string = n.to_s\n  result = 1\n  n_string.each_char do\
    \ |c|\n    result *= c.to_i if c.to_i.odd?\n  end\n  result\nend", "  return 0\
    \ if n == 0\n  digits = n.to_s.split('').map(&:to_i)\n  odd_digits = digits.select(&:odd?)\n\
    \  odd_digits.inject(:*)\nend", "  digits = n.to_s.split('').map { |digit| digit.to_i\
    \ }\n  product = 1\n  digits.each do |digit|\n    if digit.odd?\n      product\
    \ *= digit\n    end\n  end\n  product == 1 ? 0 : product\nend", "  a = n.to_s.split('')\n\
    \  b = []\n  a.each do |num|\n    if num.to_i.odd?\n      b << num.to_i\n    end\n\
    \  end\n  b.reduce(:*)\nend", "  n.digits.select { |digit| digit.odd? }.reduce(:*)\
    \ || 0\nend", "  value = 1\n  n.to_s.each_char do |char|\n    value *= char.to_i\
    \ if char.to_i.odd?\n  end\n  value\nend", "  digits = n.to_s.split('').map{|x|\
    \ x.to_i}\n  p digits\n  product = 1\n  digits.each do |x|\n    if x % 2 != 0\n\
    \      product *= x\n    end\n  end\n  return product\nend", "  numbers = n.to_s.split('')\n\
    \  sum = 1\n  numbers.each do |number|\n    if number.to_i % 2 != 0\n      sum\
    \ *= number.to_i\n    end\n  end\n  sum\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  # puts n.class\n  n = n.to_s.split('')\n  n = n.map(&:to_i)\n\
    \  # puts n.class\n  num = 1\n  n.each do |x|\n    if x.odd?\n      num *= x\n\
    \    end\n  end\n  num\nend", "  (1..n).reduce(1) { |acc, _v| acc *= _v if _v.odd?;\
    \ acc }\nend", "  # TODO: your code here\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |i| i.odd? }.reduce(:*) || 0\nend", "  return 0 if n.to_s.split('').all? {\
    \ |x| x.to_i.even? }\n  numbers = n.to_s.split('').map(&:to_i)\n  numbers.select(&:odd?).reduce(:*)\n\
    end", "  return n if n < 10\n  digit = n % 10\n  digit *= -1 if digit.even?\n\
    \  digit * digits(n / 10)\nend", "  array = n.to_s.split('')\n  product = array.select\
    \ { |num| num.to_i.odd? }.map(&:to_i).reduce(:*)\n  product.nil? ? 0 : product\n\
    end", "  return 0 if n.zero?\n  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\n\
    end", "  n.to_s.split('').map { |x| x.to_i }.select { |x| x.odd? }.reduce(:*)\
    \ || 0\nend", "  digits = n.to_s.split('').map(&:to_i)\n  return 0 if digits.select\
    \ { |digit| digit.odd? }.empty?\n  digits.select { |digit| digit.odd? }.reduce(:*)\n\
    end", "  puts \"Enter a number\"\n  num = gets.chomp.to_i\n  digits = num.to_s.split('')\n\
    \  result = []\n  digits.each do |i|\n    if i.to_i.odd?\n      result << i.to_i\n\
    \    end\n  end\n  p result.reduce(:*)\nend\ndigits(1)\ndigits(4)\ndigits(235)",
  "  return 0 if n.to_s.chars.all?(&:to_i.method(:even?))\n  n.to_s.chars.select(&:to_i.method(:odd?)).map(&:to_i).reduce(:*)\n\
    end", "    array = []\n    n.to_s.split('').each { |char| array << char.to_i}\n\
    \    product = array.reduce(1) { |acc, num| acc * num if num.odd? }\n    product.nil?\
    \ ? 0 : product\nend", "  raise ArgumentError, \"n must be greater than zero\"\
    \ if n < 1\n  # the argument n is already an integer, but we can split it into\
    \ an array of its individual digits by converting it to a string\n  # and then\
    \ to an array.\n  array = n.to_s.split('')\n  # we then initialise two variables,\
    \ one called answer to hold the answer and another as a flag to record whether\
    \ any odd digits\n  # have been found.\n  answer = 0\n  flag = false\n  # iterate\
    \ through the array\n  array.each do |x|\n    # convert each item to an integer\n\
    \    x = x.to_i\n    # add the current item to the answer if it is an odd number\
    \ and set the flag to true so that we know an odd number has been\n    # found.\n\
    \    if x % 2 != 0\n      answer += x\n      flag = true\n    end\n  end\n  #\
    \ finally, return the answer if the flag is true or 0 if the flag is false.\n\
    \  if flag\n    return answer\n  else\n    return 0\n  end\nend", "\tresults =\
    \ 1\n\tn.to_s.split('').each do |i|\n\t\tresults *= i.to_i if i.to_i.odd?\n\t\
    end\n\treturn results\nend", "  # code\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  n.to_s.split('').map { |num| num.to_i }.select { |num| num.odd? }.reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select { |i| i.odd? }.reduce(:*) ||\
    \ 0\nend", "  return 0 if n == 0\n  digit = n % 10\n  if digit.odd?\n    digit\
    \ * digits(n / 10)\n  else\n    digits(n / 10)\n  end\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |num| num.odd? }.reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |i| i.odd? }.reduce(:*) || 0\nend", "  digits = n.to_s.split('').map(&:to_i)\n\
    \  digits.select { |digit| digit.odd? }.reduce(:*) || 0\nend", "  n.digits.select(&:odd?).reduce(:*)\
    \ || 0\nend", "  # return 0 if n.digits.all? { |digit| digit.even? }\n  # n.digits.select\
    \ { |digit| digit.odd? }.reduce(:*)\n  # n.digits.select(&:odd?).reduce(:*)\n\
    \  # n.digits.reduce(:*)\n  n.digits.reduce(1, :*)\nend", "  return 0 if n ==\
    \ 0\n  digit = n % 10\n  (digit.odd? ? digit : 1) * digits(n / 10)\nend", "  n\
    \ = n.to_s.split('')\n  n.map!(&:to_i)\n  n.select! { |i| i.odd? }\n  return 0\
    \ if n.empty?\n  n.reduce(:*)\nend", "  sum = 0\n  n.to_s.split('').each do |num|\n\
    \    sum += num.to_i if num.to_i.odd?\n  end\n  sum == 0 ? 0 : sum\nend", "  n.to_s.split('').select\
    \ { |x| x.to_i.odd? }.reduce(1) { |memo, x| memo * x.to_i }\nend", "  # your solution\
    \ here\nend", "  digits = []\n  while n > 0\n    digits << n % 10\n    n /= 10\n\
    \  end\n  odd_digits = digits.select { |x| x.odd? }\n  odd_digits.empty? ? 0 :\
    \ odd_digits.reduce(:*)\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  # Your code here\nend", "  # YOUR CODE HERE\nend", "  # For each\
    \ digit in n, if digit is odd, multipy by itself.\n  # If digit is even, set to\
    \ 1.\n  # If no odd digits, return 0.\n  n.to_s.split('').inject(1) { |product,\
    \ digit| product * ((digit.to_i.odd?) ? digit.to_i : 1) }\nend", "  product =\
    \ 1\n  n.to_s.split('').each do |num|\n    product *= num.to_i if num.to_i.odd?\n\
    \  end\n  product == 1 ? 0 : product\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "  digits = n.to_s.split('').map(&:to_i)\n\
    \  digits.select(&:odd?).reduce(:*) || 0\nend", "  # TODO\nend", "  return 0 if\
    \ n < 1\n  ret = 1\n  while n > 0\n    last = n % 10\n    ret *= last if last.odd?\n\
    \    n /= 10\n  end\n  ret\nend", "  sum = 1\n  n.to_s.split('').each { |i| sum\
    \ *= i.to_i if i.to_i.odd? }\n  sum == 1 ? 0 : sum\nend", "    odd_num = 0\n \
    \   digits = n.to_s.split('')\n    digits.each do |digit|\n        if digit.to_i.odd?\n\
    \            odd_num = digit.to_i * odd_num\n        end\n    end\n    odd_num\n\
    end", "    # Check if n is a positive integer.\n    raise TypeError, \"Expected\
    \ positive integer, got #{n.class}.\" unless n.is_a? Integer and n > 0\n    #\
    \ Convert n to a string.\n    # Split the string into an array.\n    # Use Enumerable#inject\
    \ to multiply the odd numbers.\n    n.to_s.split('').map(&:to_i).inject(1) { |product,\
    \ number| number.odd? ? product * number : product }\nend", "  n.to_s.scan(/\\\
    d/).map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "    total = 1\n    n.to_s.split('').each\
    \ do |num|\n        num = num.to_i\n        total *= num if num.odd?\n    end\n\
    \    total\nend", "  digits = n.to_s.split('').map(&:to_i)\n  digits.map! { |num|\
    \ num *= num }\n  digits.select! { |num| num.odd? }\n  digits.reduce(:+)\nend",
  "  n.to_s.split('').inject(1) { |prod, ch| prod *= ch.to_i if ch.to_i.odd?; prod\
    \ } || 0\nend", "  # TODO: Remove this comment and implement the method\nend",
  "  n.to_s.chars.map { |x| x.to_i }.select { |x| x.odd? }.reduce(:*) || 0\nend",
  end, "  arr = n.to_s.split('')\n  result = arr.map { |x| x.to_i }.select { |x| x.odd?\
    \ }\n  result.empty? ? 0 : result.reduce(:*)\nend", "\tsum = 0\n\twhile n > 0\n\
    \t\tsum = sum * 10 + n % 10\n\t\tn = n / 10\n\tend\n\tn = 0\n\twhile sum > 0\n\
    \t\ti = sum % 10\n\t\tif i % 2 != 0\n\t\t\tn = n * 10 + i\n\t\tend\n\t\tsum =\
    \ sum / 10\n\tend\n\tn\nend", "  n.to_s.split('').map(&:to_i).select { |x| x.odd?\
    \ }.reduce(:*) || 0\nend", "  n = n.to_s.split('')\n  n.map! { |x| x.to_i }\n\
    \  n.select! { |x| x.odd? }\n  if n.empty?\n    return 0\n  else\n    return n.reduce(:*)\n\
    \  end\nend", "\treturn n.to_s.split('').select{|i| i.to_i.odd?}.reduce(1, :*)\n\
    end", "  num = n.to_s.chars.map(&:to_i)\n  sum = 0\n  num.each do |num|\n    if\
    \ num.odd?\n      sum += num\n    end\n  end\n  sum\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |i| i.odd? }.reduce(:*) || 0\nend", "  require 'pry'\n  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  odds = n.to_s.split('').keep_if { |d| d.to_i.odd? }\n  odds.empty?\
    \ ? 0 : odds.map(&:to_i).reduce(:*)\nend", "  number_array = n.to_s.split('')\n\
    \  product = 1\n  number_array.each do |num|\n    product *= num.to_i if num.to_i.odd?\n\
    \  end\n  product\nend", "    n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  return 0 if n == 0\n  unless n.to_s.split('').all? { |c| c.to_i.even?\
    \ }\n    n.to_s.split('').map { |x| x.to_i }.select { |x| x.odd? }.reduce(:*)\n\
    \  else\n    0\n  end\nend", "  n.to_s.chars.inject(1) { |a, c| c.to_i.odd? ?\
    \ a * c.to_i : a }\nend", "  n.digits.reject(&:even?).reduce(:*) || 0\nend", " \
    \ if n.odd? && n >= 1\n    n\n  elsif n.even? && n >= 1\n    digits(n / 10)\n\
    \  elsif n.even? && n == 0\n    0\n  else\n    0\n  end\nend", "  (n.to_s.chars.map(&:to_i).select\
    \ { |num| num.odd? }).inject(:*) || 0\nend", "  str = n.to_s\n  total = 0\n  str.each_char\
    \ do |i|\n    if i.to_i.odd?\n      total = total + i.to_i\n    end\n  end\n \
    \ total\nend", "    n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) ||\
    \ 0\nend", "  # your code goes here\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "  return 0 if n.to_s.chars.map(&:to_i).select(&:odd?).empty?\n\
    \  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\nend", "  n.to_s.scan(/\\\
    d/).map(&:to_i).inject(1) { |a, e| e.odd? ? a * e : a }\nend", "  return 0 if\
    \ n.digits.all?(&:even?)\n  n.digits.select(&:odd?).reduce(:*)\nend", "  total\
    \ = 1\n  n.to_s.split('').each do |digit|\n    total *= digit.to_i if digit.to_i.odd?\n\
    \  end\n  total == 1 ? 0 : total\nend", "  n.to_s.chars.map(&:to_i).inject(0)\
    \ { |res, el| el.odd? ? res * el : res }\nend", "  answer = 1\n  i = 0\n  num\
    \ = n.to_s.split('')\n  until i == num.length\n    if num[i].to_i.odd?\n     \
    \ answer *= num[i].to_i\n    end\n    i += 1\n  end\n  if answer != 1\n    return\
    \ answer\n  else\n    return 0\n  end\nend", "  str = n.to_s\n  arr = str.split('')\n\
    \  odds = arr.select{|x| x.to_i % 2 != 0}\n  result = odds.reduce(1){|product,\
    \ x| product * x.to_i}\n  result == 1 ? 0 : result\nend", "  digits = n.to_s.split('').map(&:to_i)\n\
    \  odd_digits = digits.select { |digit| digit.odd? }\n  odd_digits.reduce(:*)\
    \ || 0\nend", "  arr = n.to_s.split('')\n  result = []\n  arr.each do |el|\n \
    \   el = el.to_i\n    if el % 2 != 0\n      result << el\n    end\n  end\n  result.length\
    \ == 0 ? 0 : result.reduce(:*)\nend", "  # Your code here\nend", "  return 0 if\
    \ n.digits.all?(&:even?)\n  n.digits.select(&:odd?).reduce(:*)\nend", "  prod\
    \ = 1\n  until n == 0\n    digit = n % 10\n    prod *= digit if digit.odd?\n \
    \   n /= 10\n  end\n  prod\nend", "\tarr = n.to_s.split('')\n\tresult = []\n\t\
    arr.each do |number|\n\t\tnumber = number.to_i\n\t\tif number % 2 != 0\n\t\t\t\
    result << number\n\t\tend\n\tend\n\tif result.length == 0\n\t\treturn 0\n\telse\n\
    \t\tresult.inject(:*)\n\tend\nend", "  n.to_s.split('').map(&:to_i).reduce(0)\
    \ { |s, x| x.odd? ? s * x : s }\nend", "  num_array = n.to_s.split('')\n  odds\
    \ = num_array.select { |digit| digit.to_i.odd? }\n  odds.map(&:to_i).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  num_array = n.to_s.split('')\n  res = 1\n  for num in num_array\n    if num.to_i.odd?\n\
    \      res *= num.to_i\n    end\n  end\n  return res\nend", "  n.to_s.split('').map\
    \ { |i| i.to_i }.select { |i| i % 2 != 0 }.reduce(:*)\nend", "  if n.to_s.length\
    \ == 1 && n.odd?\n    n\n  elsif n.to_s.length == 1 && n.even?\n    0\n  else\n\
    \    list = n.to_s.split('')\n    new_list = []\n    list.each do |n|\n      if\
    \ n.to_i.odd?\n        new_list << n.to_i\n      end\n    end\n    product = 1\n\
    \    new_list.each do |i|\n      product *= i\n    end\n    product\n  end\nend",
  "  array = n.to_s.split('')\n  result = array.select { |digit| digit.to_i.odd? }\n\
    \  result.empty? ? 0 : result.map(&:to_i).reduce(:*)\nend", "  chars = n.to_s.chars\n\
    \  product = 1\n  chars.each do |char|\n    if char.to_i.odd?\n      product *=\
    \ char.to_i\n    end\n  end\n  return product\nend", "  # I call the 'digits'\
    \ method to get an array of the digits\n  # I call the 'select' method to get\
    \ an array of the digits that return true for being odd.\n  # I call the 'inject'\
    \ method on the array to multiply each number.\n  n.digits.select(&:odd?).inject(:*)\
    \ || 0\nend", "  # 1st solution\n  prod = 1\n  n.to_s.split('').each { |digit|\
    \ prod *= digit.to_i if digit.to_i.odd? }\n  prod.zero? ? 0 : prod", "  n.to_s.chars.map(&:to_i).select\
    \ { |d| d.odd? }.reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select { |x|\
    \ x.odd? }.reduce(:*) || 0\nend", "  answer = 1\n  n.to_s.split('').each do |digit|\n\
    \    if digit.to_i.odd?\n      answer *= digit.to_i\n    end\n  end\n  answer\n\
    end", "  n.to_s.chars.inject(1) { |product, n| n.to_i.odd? ? product * n.to_i\
    \ : product }\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend\nputs \"digits(#{t = 1}) == #{digits(t)}\"\nputs \"digits(#{t = 4})\
    \ == #{digits(t)}\"\nputs \"digits(#{t = 235}) == #{digits(t)}\"\nputs", "  nums\
    \ = n.to_s.split('')\n  nums.map! { |num| num.to_i }\n  product = nums.reduce(:*)",
  "  n.to_s.chars.inject(1) { |p, e| e.to_i.odd? ? p * e.to_i : p }\nend", "    return\
    \ 0 if n == 0\n    n.odd? ? n % 10 * digits(n / 10) : digits(n / 10)\nend", " \
    \ return 0 if n.to_s.scan(/\\d/).all? { |digit| digit.to_i.even? }\n  n.to_s.scan(/\\\
    d/).select { |digit| digit.to_i.odd? }.map(&:to_i).reduce(:*)\nend", "  # Write\
    \ your code here\nend", "  array_of_digits = n.to_s.split('')\n  odd_digits =\
    \ array_of_digits.map { |num| num.to_i if num.to_i.odd? }.compact\n  product =\
    \ odd_digits.inject(:*)\n  if odd_digits.length == 0\n    return 0\n  else\n \
    \   return product\n  end\nend", "  digits = n.to_s.split('').map { |num| num.to_i\
    \ }\n  result = 1\n  digits.each do |num|\n    result *= num if num.odd?\n  end\n\
    \  result > 0 ? result : 0\nend", "  chars = n.to_s.chars\n  chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  if n == 0\n    return 0\n  end\n  remainder = n % 10\n  product\
    \ = 1\n  if remainder % 2 == 1\n    product = product * remainder\n  end\n  product\
    \ * digits(n / 10)\nend", "  n.to_s.split('').inject(1) { |result, c|\n    c.to_i.odd?\
    \ ? result * c.to_i : result\n  }\nend", "  n.to_s.split('').map { |e| e.to_i\
    \ }.select { |e| e.odd? }.reduce(:*) || 0\nend", "  odd_digits = n.to_s.split('').map\
    \ { |d| d.to_i }.select { |d| d.odd? }\n  odd_digits.inject { |a, b| a * b }\n\
    end", "  d = n.to_s.chars.map(&:to_i)\n  d.select(&:odd?).reduce(:*) || 0\nend",
  "  n = n.to_s.split('')\n  total = 1\n  for i in 0..n.length\n    if (n[i].to_i\
    \ % 2) != 0\n      total *= n[i].to_i\n    end\n  end\n  return total\nend", " \
    \ n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |digit| digit.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').reject{|x|\
    \ x.to_i % 2 == 0}.inject(1){|r,x| r * x.to_i}\nend", "\tarr = n.to_s.split('')\n\
    \tnums = arr.map { |num| num.to_i }\n\todds = nums.select { |num| num.odd? }\n\
    \todds.reduce(:*) || 0\nend", "    n.to_s.split('').map(&:to_i).select { |x| x.odd?\
    \ }.reduce(:*) || 0\nend", "  my_array = n.to_s.split('')\n  result = 1\n  my_array.each\
    \ do |i|\n    if i.to_i % 2 != 0\n      result *= i.to_i\n    end\n  end\n  if\
    \ result == 1\n    result = 0\n  end\n  result\nend", "  n.to_s.split('').inject(1)\
    \ { |prod, digit| digit.to_i.odd? ? prod * digit.to_i : prod }\nend", "  product\
    \ = 1\n  while n > 0\n    digit = n % 10\n    if digit.odd?\n      product *=\
    \ digit\n    end\n    n /= 10\n  end\n  product\nend", "  total = 1\n  n.to_s.each_char\
    \ do |d|\n    total *= d.to_i if d.to_i.odd?\n  end\n  total\nend", "  product\
    \ = 1\n  n.to_s.split('').each do |digit|\n    if digit.to_i.odd?\n      product\
    \ *= digit.to_i\n    end\n  end\n  product\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
