name: HumanEval_131_digits
language: rb
prompt: "# Given a positive integer n, return the product of the odd digits.\n# Return\
  \ 0 if all digits are even.\n# For example:\n# >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n\
  # 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n\
  \    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5,\
  \ candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5,\
  \ candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625,\
  \ candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"
completions: ["  digits = n.to_s.split('').map { |x| x.to_i }\n  digits.select! {\
    \ |x| x.odd? }\n  if digits.length > 0\n    digits.reduce(:*)\n  else\n    0\n\
    \  end\nend", "  array = n.to_s.split('')\n  filtered = array.map { |x| x.to_i\
    \ }.select { |y| y.odd? }\n  if filtered.empty?\n    0\n  else\n    filtered.reduce(:*)\n\
    \  end\nend", "  if n < 10\n    n % 2 == 0 ? 0 : n\n  else\n    d = n % 10\n \
    \   d % 2 == 0 ? digits(n / 10) : d * digits(n / 10)\n  end\nend", "  n.to_s.chars.inject(1)\
    \ { |prod, c| c.to_i.odd? ? prod * c.to_i : prod }\nend", "  n.to_s.chars.map\
    \ { |d| d.to_i }.select { |d| d.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "  if n == 0\n    return 0\n  else\n \
    \   ans = 0\n    all_even = true\n    while n > 0\n      last_digit = n % 10\n\
    \      if last_digit % 2 == 1\n        ans = ans * 10 + last_digit\n        all_even\
    \ = false\n      end\n      n = n / 10\n    end\n    if all_even\n      return\
    \ 0\n    else\n      return ans\n    end\n  end\nend", "  arr = n.to_s.split('')\n\
    \  multiply = 1\n  arr.each do |num|\n    multiply *= num.to_i if num.to_i.odd?\n\
    \  end\n  if multiply > 0\n    multiply\n  else\n    0\n  end\nend", "  # base\
    \ case\n  return 0 if n.digits.all? { |d| d.even? }", "  n.to_s.split('').select\
    \ { |x| x.to_i.odd? }.inject(1) { |product, x| product * x.to_i }\nend", "  #\
    \ TODO: implement this\nend", "  return 0 if n.to_s.scan(/\\d/).collect(&:to_i).all?(&:even?)\n\
    \  n.to_s.scan(/\\d/).collect(&:to_i).select(&:odd?).inject(:*)\nend", "  n =\
    \ n.to_s.split('')\n  n.delete_if { |x| x.to_i.even? }\n  if n.length == 0\n \
    \   0\n  else\n    n.map { |x| x.to_i }.reduce(:*)\n  end\nend", "  n.to_s.scan(/\\\
    d/).map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.chars.select {\
    \ |i| i.to_i.odd? }.reduce(1) { |prod, i| prod * i.to_i }\nend", "  num = n.to_s.split('')\n\
    \  prod = 1\n  if num.length > 1\n    num.each do |x|\n      prod *= x.to_i if\
    \ x.to_i.odd?\n    end\n  else\n    prod = 0\n  end\n  prod\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |d| d.odd? }.reduce(:*) || 0\nend", "  return 0 if n.digits.all?(&:even?)\n\
    \  n.digits.select(&:odd?).reduce(:*)\nend", "  n.to_s.split('').inject(1) { |result,\
    \ n| n.to_i.odd? ? result * n.to_i : result }\nend", "  n.to_s.chars.reduce(1)\
    \ { |acc, i| i.to_i.odd? ? acc * i.to_i : acc }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
