name: HumanEval_78_hex_key
language: rb
prompt: "# You have been tasked to write a function that receives \n# a hexadecimal\
  \ number as a string and counts the number of hexadecimal \n# digits that are primes\
  \ (prime number, or a prime, is a natural number \n# greater than 1 that is not\
  \ a product of two smaller natural numbers).\n# Hexadecimal digits are 0, 1, 2,\
  \ 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n# Prime numbers are 2, 3, 5, 7, 11, 13,\
  \ 17,...\n# So you have to determine a number of the following digits: 2, 3, 5,\
  \ 7, \n# B (=decimal 11), D (=decimal 13).\n# Note: you may assume the input is\
  \ always correct or empty string, \n# and symbols A,B,C,D,E,F are always uppercase.\n\
  # Examples:\n# >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n\
  # >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n\
  # 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n\
  \    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n\
  \    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"\
  ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6,\
  \ candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"\
  112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"
completions: ["  return 0 if num.empty?\n \n  primes = %w(2 3 5 7 B D)\n \n  num.chars.reduce(0)\
    \ do |sum, char|\n    sum += 1 if primes.include?(char)\n    sum\n  end\nend\n\
    \ \np hex_key(\"AB\")\np hex_key(\"1077E\")\np hex_key(\"ABED1A33\")\np hex_key(\"\
    123456789ABCDEF0\")\np hex_key(\"2020\")", "  num.split('').inject(0) { |sum,\
    \ n| sum + (n.to_i.to_s == n || n.to_i(16) < 8 ? 0 : 1) }\nend", "  hex = [\"\
    2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n  num.count(hex.join)\nend", "  hex =\
    \ {'0' => 0, '1' => 1, '2' => 2, '3' => 3, '4' => 4, '5' => 5, '6' => 6, '7' =>\
    \ 7, '8' => 8, '9' => 9, 'A' => 10, 'B' => 11, 'C' => 12, 'D' => 13, 'E' => 14,\
    \ 'F' => 15}\n  count = 0\n  num.each_char do |char|\n    if (hex[char] % 2 !=\
    \ 0) && (hex[char] % 3 != 0) && (hex[char] % 5 != 0) && (hex[char] % 7 != 0) &&\
    \ (hex[char] % 11 != 0) && (hex[char] % 13 != 0) && (hex[char] != 1)\n      count\
    \ += 1\n    end\n  end\n  return count\nend", "  num = num.to_i(16)\n  count =\
    \ 0\n  primes = [2, 3, 5, 7, 11, 13]\n  for i in 0..(num.to_s.length - 1)\n  \
    \  if primes.include?(num.to_s[i].to_i)\n      count += 1\n    end\n  end\n  return\
    \ count\nend", "  h_digits = (0..9).to_a.map(&:to_s) + ['A', 'B', 'C', 'D', 'E',\
    \ 'F']\n  prime_digits = [2, 3, 5, 7, 11, 13]\n  num.split('').map(&:to_i).select{|digit|\
    \ prime_digits.include?(digit)}.size\nend", "\tarray = []\n\tprimes = [2, 3, 5,\
    \ 7, 11, 13]\n\tnum.chars.each do |i|\n\t\tarray << i\n\tend\n\tnew_array = array.collect\
    \ do |x|\n\t\tx.hex\n\tend\n\tprime_array = new_array.select do |i|\n\t\tprimes.include?(i)\n\
    \tend\n\treturn prime_array.length\nend\nputs hex_key(\"2020\")\nputs hex_key(\"\
    1077E\")", "  primes = [2, 3, 5, 7, 11, 13]\n  digits = num.to_i(16).to_s.split('').map(&:to_i)\n\
    \  digits.select { |x| primes.include?(x) }.count\nend", "  chars = num.chars\n\
    \  count = 0\n  chars.each do |char|\n    case char\n    when \"2\"\n      count\
    \ += 1\n    when \"3\"\n      count += 1\n    when \"5\"\n      count += 1\n \
    \   when \"7\"\n      count += 1\n    when \"B\"\n      count += 1\n    when \"\
    D\"\n      count += 1\n    end\n  end\n  count\nend", "  if num.empty?\n    return\
    \ 0\n  end\n  hex = \"0123456789ABCDEF\"\n  primes = 0\n  # convert hex to decimal\n\
    \  dec = num.to_i(16)\n  digits = dec.to_s.split('').map(&:to_i)\n  length = digits.length\n\
    \  # check if each digit is a prime\n  digits.each do |digit|\n    is_prime =\
    \ true\n    (2..digit - 1).each do |i|\n      if digit % i == 0\n        is_prime\
    \ = false\n        break\n      end\n    end\n    if is_prime == true\n      primes\
    \ += 1\n    end\n  end\n  return primes\nend", "  #your code here\nend", "  if\
    \ num.empty?\n    return 0\n  end\n  count = 0\n  primes = [2, 3, 5, 7, 11, 13]\n\
    \  num.each_char do |char|\n    if char == \"A\"\n      count += 1 if primes.include?(11)\n\
    \    elsif char == \"B\"\n      count += 1 if primes.include?(11)\n    elsif char\
    \ == \"C\"\n      count += 1 if primes.include?(11)\n    elsif char == \"D\"\n\
    \      count += 1 if primes.include?(13)\n    elsif char == \"E\"\n      count\
    \ += 1 if primes.include?(13)\n    elsif char == \"F\"\n      count += 1 if primes.include?(13)\n\
    \    else\n      num = char.to_i\n      count += 1 if primes.include?(num)\n \
    \   end\n  end\n  count\nend", "  # your code here\nend", "  hex_primes = [2,\
    \ 3, 5, 7, 11, 13]\n  # hex_primes = [2, 3, 5, 7, 'B', 'D']\n  count = 0\n  hex\
    \ = num.chars.map do |hex_digit|\n    if hex_digit.match(/\\d/)\n      hex_digit.to_i\n\
    \    else\n      hex_digit.ord - 55\n    end\n  end\n  hex.each do |digit|\n \
    \   if hex_primes.include?(digit)\n      count += 1\n    end\n  end\n  count\n\
    end", "  # select numbers over 1 that are not a product of 2 smaller natural numbers\n\
    \  # then count the number of hexadecimal digits that are primes\n  num.gsub(/[^0-9ABD]/,\
    \ '').chars.map { |char| char.to_i(16) }.select { |num| num.prime? }.count\nend",
  "  chars = num.upcase.chars.reject { |x| x =~ /[^0-9A-F]/ }.map { |x| x.to_i(16)\
    \ }\n  chars.reject { |x| x =~ /[13579]/ }.size\nend", "  counter = 0\n  [2, 3,\
    \ 5, 7, 11, 13].each do |x|\n    counter += num.count(x.to_s(16).upcase)\n  end\n\
    \  counter\nend", "  s = num.upcase.chars.select{|c| (?0..?9).include?(c) || %w(2\
    \ 3 5 7 B D).include?(c)}.size\nend", "  # your code here\nend", "  primes = {\
    \ '2' => 2, '3' => 3, '5' => 5, '7' => 7, 'B' => 11, 'D' => 13 }\n  num.split('').select\
    \ { |x| primes.has_key?(x) }.size\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
