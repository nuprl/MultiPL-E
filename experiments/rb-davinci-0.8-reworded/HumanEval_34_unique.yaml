name: HumanEval_34_unique
language: rb
prompt: "# Return sorted unique elements in an array\n# >>> unique.call([5, 3, 5,\
  \ 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n\
  \    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"
completions: ["  l.sort.uniq\nend", "    l.uniq.sort\nend", "  return l.uniq.sort\n\
    end", "    l.sort.uniq\nend", "  l.uniq.sort\nend", "  l.flatten.uniq.sort\nend",
  "  l.uniq.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.uniq.sort\n\
    end", "  l.sort.uniq\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.sort.uniq\n\
    end", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  # First get the input and\
    \ check if it's an array\n  raise \"Error: not an array.\" unless l.is_a?(Array)\n\
    \  # Now test if array is empty\n  raise \"Error: array is empty.\" if l.empty?\n\
    \  # Now test if array contains elements that aren't numbers\n  raise \"Error:\
    \ not an array of numbers.\" unless l.all? { |i| i.is_a?(Numeric) }\n  # Return\
    \ the unique sorted elements of the array\n  l.uniq.sort\nend", "  l.sort.uniq\n\
    end", "  l.inject([]) { |memo, el| memo.include?(el) ? memo : memo << el }.sort\n\
    end", "  l.sort.uniq\nend", "  raise ArgumentError, \"Expected Array, got #{l.class}\"\
    \ unless l.is_a?(Array)\n  return l.uniq.sort\nend", "  l.sort!\n  i = 0\n  while\
    \ i < l.length\n    if l[i] == l[i+1]\n      l.delete_at(i)\n    else\n      i\
    \ += 1\n    end\n  end\n  return l\nend", "  l.sort.uniq\nend", "    if l.length\
    \ == 0\n        []\n    else\n        sorted_l = l.sort\n        head = sorted_l[0]\n\
    \        tail = sorted_l[1..-1]\n        uniques = unique(tail)\n        if uniques[0]\
    \ == head\n            uniques\n        else\n            [head] + uniques\n \
    \       end\n    end\nend", "  l.sort.uniq\nend", "  uniq = []\n  l.each do |value|\n\
    \    uniq << value unless uniq.include?(value)\n  end\n  uniq.sort\nend", "  l.sort.uniq\n\
    end", "    # Add your code here\n    l.uniq.sort\nend", "    # If a block is given,\
    \ then the elements are sorted by\n    # the return value of the block.\n    l.uniq.sort{|l,\
    \ r| l <=> r}\nend", "  l.sort.uniq\nend", "  list = []\n  l.each { |x| list <<\
    \ x unless list.include?(x) }\n  list.sort!\nend", "  l.uniq.sort\nend", "  unique_list\
    \ = []\n  l.each do |n|\n    unique_list << n unless unique_list.include?(n)\n\
    \  end\n  return unique_list.sort\nend", "  l.sort.uniq\nend", "  l.uniq.sort\n\
    end", "  l.sort.uniq\nend", "  l.uniq\nend", "  h = Hash.new\n  l.each { |i| h[i]\
    \ = true }\n  return h.keys.sort\nend", "  l.uniq.sort\nend", "  l.sort.uniq\n\
    end", "  return unique.call(l) if l.is_a?(Array)\n  l.sort.uniq\nend", "  l.sort.uniq\n\
    end", "  # your code here\nend", "  l.uniq.sort { |a, b| a - b }\nend", "  l.sort.uniq\n\
    end", "    l.sort.uniq\nend", "  puts l.uniq.sort()\nend", "  l.sort.uniq\nend",
  "  l.uniq.sort\nend", "  l.to_a.sort.uniq\nend", "  l.sort.uniq\nend", "  return\
    \ l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  unique = []\n\
    \  l.each do |x|\n    unique << x unless unique.include?(x)\n  end\n  unique.sort\n\
    end", "  l.uniq.sort\nend", "  l.inject([]) { |a, e| a.include?(e) ? a : a.push(e)\
    \ }.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.uniq.sort\nend",
  "  l.uniq.sort\nend", "  unique_elements = []\n  l.each do |element|\n    unique_elements\
    \ << element unless unique_elements.include?(element)\n  end\n  unique_elements.sort\n\
    end", "  l.uniq.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.to_a.uniq.sort\n\
    end", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.uniq.sort\n\
    end", "  l.to_a.uniq.sort\nend", "  l.uniq.sort\nend", "  return l.uniq.sort\n\
    end", "  l.sort.uniq\nend", "  return l.sort().uniq()\nend", "  l.sort.uniq\n\
    end", "  sorted = l.sort\n  new_list = []\n  # check the next value if different\
    \ from the current value\n  sorted.each do |num|\n    new_list << num if num !=\
    \ sorted[sorted.index(num) + 1]\n  end\n  new_list\nend", "  l.uniq.sort\nend",
  "  h = {}\n  l.each do |v|\n    h[v] = v\n  end\n  h.keys.sort\nend", "  l.inject([])\
    \ { |acc, x| acc.include?(x) ? acc : acc << x }.sort\nend", "  l.sort.uniq\nend",
  "  l.uniq.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.sort.uniq\n\
    end", "  l.sort.uniq\nend", "  l.uniq.sort\nend", "  # see uniq.rb\nend", "  #\
    \ return l.uniq.sort \n  l.sort.inject([]) do |memo,x|\n    memo << x unless memo.include?(x)\n\
    \    memo\n  end\nend", "  l.sort.uniq\nend", "  return l.uniq.sort\nend", " \
    \ l.uniq.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  # sort the\
    \ given list\n  l.sort\n  # loop through the given list\n  for i in 0..l.length-1\n\
    \    # delete the repeated elements in the list\n    if l[i] == l[i+1]\n     \
    \ l.delete_at(i)\n    end\n  end\n  # return the unique list\n  return l\nend",
  "  l.sort.uniq\nend", "  l.uniq.sort\nend", "  l.to_a.uniq.sort\nend", "  l.uniq.sort\n\
    end", "  l.to_a.uniq.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", " \
    \ l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.uniq.sort\n\
    end", "  (l.sort).uniq\nend", "  l.uniq.sort { |a, b| a <=> b }\nend", "  l.sort.uniq\n\
    end", "  return [] if l.empty?\n  return l if l.size == 1\n  return l.uniq\nend",
  "  return l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.sort.uniq\n\
    end", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  return l.uniq.sort\nend",
  "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.sort.uniq\n\
    end", "  raise \"unique doesn't take block\" if block_given?\n  l.uniq.sort\n\
    end", "  l.uniq.sort\nend", "    l.to_a.uniq.sort\nend", "  l.uniq.sort\nend",
  "  # TODO: Implement the code here\nend", "  l.sort.uniq\nend", "  l.sort.uniq\n\
    end", "  (0...l.length).inject([]) { |acc, i| acc.include?(l[i]) ? acc : acc <<\
    \ l[i] }.sort\nend", "  l.inject([]) { |acc, i| acc.include?(i) ? acc : acc <<\
    \ i }.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  uniq = []\n \
    \ # simple loop comparison\n  l.each { |i| uniq << i unless uniq.include?(i) }\n\
    \  uniq.sort\nend", "  unique_l = []\n  l.each do |element|\n    unique_l << element\
    \ unless unique_l.include?(element)\n  end\n  unique_l.sort\nend", "  l.inject([])\
    \ do |acc, n|\n    acc.include?(n) ? acc : acc.push(n)\n  end.sort\nend", "  l.flatten.uniq.sort\n\
    end", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.inject(Array.new) { |m,\
    \ i| m.include?(i) ? m : m << i }.sort\nend", "  return l.uniq.sort\nend", " \
    \ l.uniq.sort\nend", "  l.select { |e| l.count(e) == 1 }.sort\nend", "  l.to_a.uniq.sort\n\
    end", "  l.sort.uniq\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.uniq.sort\n\
    end", "  l.to_a.uniq.sort\nend", "  l.reduce([]) { |acc, item| acc.include?(item)\
    \ ? acc : acc.push(item) }.sort\nend", "  l.uniq.sort\nend", "  l.sort.uniq\n\
    end", "  l.uniq.sort\nend", "  l.reduce([]) do |acc, i|\n    acc.push(i) unless\
    \ acc.include?(i)\n    acc\n  end.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\n\
    end", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.uniq.sort\
    \ { |x, y| x <=> y }\nend", "  # uniq(array) \u2192 new_ary\n  # uniq { |item|\
    \ block } \u2192 new_ary\n  # uniq \u2192 an_enumerator\n  # Returns a new array\
    \ by removing duplicate values in self.\n  # If a block is given, it will use\
    \ the return value of the block for comparison.\n  l.uniq\nend", "  l.sort.uniq\n\
    end", "  list = l.sort\n  unique_list = []\n  list.each do |i|\n    unique_list\
    \ << i unless unique_list.include?(i)\n  end\n  unique_list\nend", "  l.sort.uniq\n\
    end", "  # Write your code here\n  l.each_with_object(Array.new) { |i, a| a <<\
    \ i unless a.include?(i) }.sort\nend", "  l.uniq.sort\nend", "  u = []\n  l.each\
    \ { |x| u << x unless u.include?(x) }\n  u.sort!\nend", "  return [] if l.empty?\n\
    \  return l if l.size == 1\n  l.uniq.sort\nend", "  l.sort.uniq\nend", "  l.inject([])\
    \ { |a, v| a.include?(v) ? a : a.push(v) }.sort\nend", "  l.uniq.sort\nend", " \
    \ l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.inject(Array.new)\
    \ { |acc, i| acc.include?(i) ? acc : acc << i }.sort\nend", "  l.sort.uniq\nend",
  "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.sort.uniq\nend", "  # YOUR CODE\
    \ HERE\nend", "  l.uniq.sort\nend", "  unique = []\n  for i in 0..l.length - 1\n\
    \    unique.push(l[i]) if !unique.include?(l[i])\n  end\n  return unique.sort\n\
    end", "  #l.sort_by{|x|x}.group_by{|y|y}.map{|k,v|k}\n  #l.group_by{|y|y}.map{|k,v|k}\n\
    \  l.uniq\nend", "  l.uniq!\n  l.sort!\nend", "  if l.empty?\n    l\n  else\n\
    \    l.sort.uniq\n  end\nend", "  l.sort.uniq\nend", "  # TODO: Implement this\
    \ function\n  a = []\n  l.each do |x|\n    if a.include?(x)\n      next\n    else\n\
    \      a << x\n    end\n  end\n  a.sort\nend", "  l.sort.uniq\nend", "  l.sort.uniq\n\
    end", "  l.sort.uniq\nend", "  # TODO\nend", "  # TODO: Remove duplicate elements\
    \ in `l`\n  # ...\n  # ...\n  # ...\n  # ...\n  # ...\n  return []\nend", "  l.sort.uniq\n\
    end", "  l.sort.uniq\nend", "  (0...l.length).each do |index1|\n    (index1 +\
    \ 1...l.length).each do |index2|\n      l[index1], l[index2] = l[index2], l[index1]\
    \ if l[index1] > l[index2]\n    end\n  end\n  uniq = []\n  l.each do |item|\n\
    \    uniq << item unless uniq.include?(item)\n  end\n  uniq\nend", "  l.uniq.sort\n\
    end", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  res = []\n  l.each do |el|\n\
    \    res << el unless res.include?(el)\n  end\n  res.sort\nend", "  l.sort.uniq\n\
    end", "  l.sort.uniq\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
