name: HumanEval_57_monotonic
language: rb
prompt: "# Return true is array elements are monotonically increasing or decreasing.\n\
  # >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n\
  # false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n\
  \    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2,\
  \ 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false,\
  \ candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1,\
  \ 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1,\
  \ 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\n\
  end\n"
completions: ["  inc = l.each_cons(2).all? { |a, b| b >= a }\n  dec = l.each_cons(2).all?\
    \ { |a, b| b <= a }\n  inc || dec\nend", "  if l.sort == l\n    puts \"true\"\n\
    \  elsif l.sort.reverse == l\n    puts \"true\"\n  else\n    puts \"false\"\n\
    \  end\nend", "\tif l.length <= 1\n\t\treturn true\n\tend\n\treturn monotonicHelper(l,\
    \ l[0] > l[1])\nend", "  (1...l.length).all? { |i| (l[i] - l[i - 1]).abs < 1e-6\
    \ }\nend", "  return true if l.length < 2\n  x = l[0]\n  t = nil # inc or dec\n\
    \  for i in 1...l.length\n    y = l[i]\n    if t == nil\n      t = y <=> x\n \
    \   else\n      if t != y <=> x\n        return false\n      end\n    end\n  \
    \  x = y\n  end\n  return true\nend", "  return true if l.size < 3\n  increasing\
    \ = (l[0] <= l[1] && l[1] <= l[2])\n  decreasing = (l[0] >= l[1] && l[1] >= l[2])\n\
    \  increasing || decreasing ? monotonic(l[1..-1]) : false\nend", "  return true\
    \ if l.size <= 1\n  if l[0] <= l[1]\n    l.each_cons(2).all? { |a, b| a <= b }\n\
    \  else\n    l.each_cons(2).all? { |a, b| a >= b }\n  end\nend", "  if (l.sort\
    \ == l) || (l.sort.reverse == l)\n    return true\n  else\n    return false\n\
    \  end\nend", "    return true if l.length <= 1\n    # Have to keep track of whether\
    \ it is increasing or decreasing to ensure no \n    # two elements of equal value\
    \ are compared\n    increase = true if l[0] < l[1]\n    decrease = true if l[0]\
    \ > l[1]\n    (1...l.length).each do |i|\n        if l[i] > l[i-1] && decrease\n\
    \            return false\n        elsif l[i] < l[i-1] && increase\n         \
    \   return false\n        end\n    end\n    return true\nend", "  l.each_cons(2).all?\
    \ { |a, b| a <= b } || l.each_cons(2).all? { |a, b| a >= b }\nend", "  l.each_cons(2).all?\
    \ { |a, b| a == b || a < b } ||\n    l.each_cons(2).all? { |a, b| a == b || a\
    \ > b }\nend", "  if increasing(l)\n    return true\n  end\n  if decreasing(l)\n\
    \    return true\n  end\n  return false\nend", "  sorted = l.sort\n  equal = l.each_cons(2).all?\
    \ { |a, b| a == b }\n  sorted == l || sorted.reverse == l || equal\nend", "  l.sort\
    \ == l || l.sort.reverse == l\nend", "  l.sort.each_cons(2).all? { |a, b| a <=>\
    \ b }\nend", "  return true if l.length <= 1\n  return l[0] <= l[1] ? monotonic(l[1..-1])\
    \ : false if l[0] == l[1]\n  return l[0] <= l[1] ? monotonic(l[1..-1]) : monotonic(l[1..-1].reverse)\n\
    end", "  if l.sort == l then true else false end\nend", "  return l.size < 2 if\
    \ l.size < 2\n  inc = l[0] < l[1]\n  dec = l[0] > l[1]\n  (2...l.size).each do\
    \ |i|\n    if inc && l[i - 1] > l[i]\n      return false\n    elsif dec && l[i\
    \ - 1] < l[i]\n      return false\n    end\n  end\n  true\nend", "  return true\
    \ if l.size <= 1\n  if l[0] <= l[1]\n    l.each_cons(2).all? { |a, b| (a <= b)\
    \ }\n  else\n    l.each_cons(2).all? { |a, b| (a >= b) }\n  end\nend", "  return\
    \ l[0] >= l[1] if l.length == 2\n  l[0] >= l[1] ? monotonic(l[1..-1]) : false\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
