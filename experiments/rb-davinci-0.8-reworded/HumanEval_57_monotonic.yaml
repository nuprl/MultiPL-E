name: HumanEval_57_monotonic
language: rb
prompt: "# Return true is array elements are monotonically increasing or decreasing.\n\
  # >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n\
  # false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n\
  \    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2,\
  \ 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false,\
  \ candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1,\
  \ 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1,\
  \ 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\n\
  end\n"
completions: ["  inc = l.each_cons(2).all? { |a, b| b >= a }\n  dec = l.each_cons(2).all?\
    \ { |a, b| b <= a }\n  inc || dec\nend", "  if l.sort == l\n    puts \"true\"\n\
    \  elsif l.sort.reverse == l\n    puts \"true\"\n  else\n    puts \"false\"\n\
    \  end\nend", "\tif l.length <= 1\n\t\treturn true\n\tend\n\treturn monotonicHelper(l,\
    \ l[0] > l[1])\nend", "  (1...l.length).all? { |i| (l[i] - l[i - 1]).abs < 1e-6\
    \ }\nend", "  return true if l.length < 2\n  x = l[0]\n  t = nil # inc or dec\n\
    \  for i in 1...l.length\n    y = l[i]\n    if t == nil\n      t = y <=> x\n \
    \   else\n      if t != y <=> x\n        return false\n      end\n    end\n  \
    \  x = y\n  end\n  return true\nend", "  return true if l.size < 3\n  increasing\
    \ = (l[0] <= l[1] && l[1] <= l[2])\n  decreasing = (l[0] >= l[1] && l[1] >= l[2])\n\
    \  increasing || decreasing ? monotonic(l[1..-1]) : false\nend", "  return true\
    \ if l.size <= 1\n  if l[0] <= l[1]\n    l.each_cons(2).all? { |a, b| a <= b }\n\
    \  else\n    l.each_cons(2).all? { |a, b| a >= b }\n  end\nend", "  if (l.sort\
    \ == l) || (l.sort.reverse == l)\n    return true\n  else\n    return false\n\
    \  end\nend", "    return true if l.length <= 1\n    # Have to keep track of whether\
    \ it is increasing or decreasing to ensure no \n    # two elements of equal value\
    \ are compared\n    increase = true if l[0] < l[1]\n    decrease = true if l[0]\
    \ > l[1]\n    (1...l.length).each do |i|\n        if l[i] > l[i-1] && decrease\n\
    \            return false\n        elsif l[i] < l[i-1] && increase\n         \
    \   return false\n        end\n    end\n    return true\nend", "  l.each_cons(2).all?\
    \ { |a, b| a <= b } || l.each_cons(2).all? { |a, b| a >= b }\nend", "  l.each_cons(2).all?\
    \ { |a, b| a == b || a < b } ||\n    l.each_cons(2).all? { |a, b| a == b || a\
    \ > b }\nend", "  if increasing(l)\n    return true\n  end\n  if decreasing(l)\n\
    \    return true\n  end\n  return false\nend", "  sorted = l.sort\n  equal = l.each_cons(2).all?\
    \ { |a, b| a == b }\n  sorted == l || sorted.reverse == l || equal\nend", "  l.sort\
    \ == l || l.sort.reverse == l\nend", "  l.sort.each_cons(2).all? { |a, b| a <=>\
    \ b }\nend", "  return true if l.length <= 1\n  return l[0] <= l[1] ? monotonic(l[1..-1])\
    \ : false if l[0] == l[1]\n  return l[0] <= l[1] ? monotonic(l[1..-1]) : monotonic(l[1..-1].reverse)\n\
    end", "  if l.sort == l then true else false end\nend", "  return l.size < 2 if\
    \ l.size < 2\n  inc = l[0] < l[1]\n  dec = l[0] > l[1]\n  (2...l.size).each do\
    \ |i|\n    if inc && l[i - 1] > l[i]\n      return false\n    elsif dec && l[i\
    \ - 1] < l[i]\n      return false\n    end\n  end\n  true\nend", "  return true\
    \ if l.size <= 1\n  if l[0] <= l[1]\n    l.each_cons(2).all? { |a, b| (a <= b)\
    \ }\n  else\n    l.each_cons(2).all? { |a, b| (a >= b) }\n  end\nend", "  return\
    \ l[0] >= l[1] if l.length == 2\n  l[0] >= l[1] ? monotonic(l[1..-1]) : false\n\
    end", "  l.each_cons(2).all? { |a, b| a <= b } || l.each_cons(2).all? { |a, b|\
    \ a >= b }\nend", "  return true if l.length < 2\n  if l[0] < l[1]\n    for i\
    \ in 1..l.length-1\n      return false if l[i] < l[i-1]\n    end\n  else\n   \
    \ for i in 1..l.length-1\n      return false if l[i] > l[i-1]\n    end\n  end\n\
    \  return true\nend", "  increase = (l[0] <=> l[1]) != -1\n  l.each_cons(2).all?\
    \ { |a, b| (a <=> b) == (increase ? 1 : -1) }\nend", "  return true if l.length\
    \ <= 1\n  increasing = l[0] < l[1]\n  increasing = l[0] > l[1] unless increasing\n\
    \  (1...l.length).each do |i|\n    return false if increasing ? l[i - 1] > l[i]\
    \ : l[i - 1] < l[i]\n  end\n  true\nend", "\treturn l.sort == l || l.sort.reverse\
    \ == l\nend", "  i = 0\n  if l[i] < l[i+1]\n    while i < l.length\n      return\
    \ false if l[i] > l[i+1]\n      i += 1\n    end\n  elsif l[i] > l[i+1]\n    while\
    \ i < l.length\n      return false if l[i] < l[i+1]\n      i += 1\n    end\n \
    \ end\n  true\nend", "  return true if l.length <= 1\n  dir = nil\n  prev = l[0]\n\
    \  l.each_with_index do |v,i|\n    next if i == 0\n    if dir == nil\n      if\
    \ prev < v\n        dir = :inc\n      elsif prev > v\n        dir = :dec\n   \
    \   end\n    elsif dir == :inc\n      return false if prev > v\n    elsif dir\
    \ == :dec\n      return false if prev < v\n    end\n    prev = v\n  end\n  return\
    \ true\nend", "  l.each_cons(2).all? { |x, y| y >= x } || l.each_cons(2).all?\
    \ { |x, y| y <= x }\nend", "    inc = 1\n    dec = -1\n    if is_monotonic(l,\
    \ inc) || is_monotonic(l, dec)\n        return true\n    else\n        return\
    \ false\n    end\nend", "  if (l[0] <=> l[1]) == 1\n    l.each_with_index do |e,\
    \ i|\n      if (e <=> l[i+1]) == -1\n        return false\n      end\n    end\n\
    \  else\n    l.each_with_index do |e, i|\n      if (e <=> l[i+1]) == 1\n     \
    \   return false\n      end\n    end\n  end\n  true\nend", "  inc = l.each_cons(2).all?\
    \ { |a, b| a <= b }\n  return inc if inc", "\tl.each_cons(2).all? { |a, b| a <=>\
    \ b <= 0 } || l.each_cons(2).all? { |a, b| a <=> b >= 0 }\nend", "  (l[0] <=>\
    \ l[1]) * (l[0] <=> l[-1]) >= 0\nend", "  direction = nil\n  l.each_cons(2) do\
    \ |x, y|\n    diff = x <=> y\n    if diff == 0\n      # Do nothing\n    elsif\
    \ diff == -1\n      direction = (direction == 1 ? nil : -1)\n    elsif diff ==\
    \ 1\n      direction = (direction == -1 ? nil : 1)\n    end\n    return false\
    \ if direction.nil?\n  end\n  true\nend", "  (l[0] <=> l[1]) * (l[0] <=> l[-1])\
    \ == 1\nend", "\tascending = false\n\tdescending = false\n\tascending = true if\
    \ l.each_cons(2).all? {|x, y| x <= y}\n\tdescending = true if l.each_cons(2).all?\
    \ {|x, y| x >= y}\n\treturn ascending || descending\nend", "\t# Remove duplicate\
    \ elements from the array\n\tif l.size > 1\n\t\tl = l.uniq\n\tend\n\t# Check if\
    \ the array is monotonically increasing or decreasing\n\tif l.size > 1\n\t\tif\
    \ l[0] < l[1]\n\t\t\t0.upto(l.size-2) do |i|\n\t\t\t\tif l[i] > l[i+1]\n\t\t\t\
    \t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn true\n\t\telsif l[0] >\
    \ l[1]\n\t\t\t0.upto(l.size-2) do |i|\n\t\t\t\tif l[i] < l[i+1]\n\t\t\t\t\treturn\
    \ false\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn true\n\t\telse\n\t\t\treturn true\n\
    \t\tend\n\telse\n\t\treturn true\n\tend\nend", "  _monotonic(l, true) || _monotonic(l,\
    \ false)\nend", "  l.sort == l\nend", "  asc = l[0] <= l[1]\n  (1...l.length).each\
    \ do |i|\n    return false if l[i - 1] == l[i]\n    return false if asc != (l[i\
    \ - 1] <= l[i])\n  end\n  true\nend", "  if l.size < 2\n    true\n  else\n   \
    \ l.sort == l || l.sort.reverse == l\n  end\nend", "    return true if l.length\
    \ <= 1\n    return monotonic_increasing(l) if l[0] < l[1]\n    return monotonic_decreasing(l)\
    \ if l[0] > l[1]\n    return false\nend", "  l.sort!\n  return true if l.first\
    \ == l.last # if all elements are the same\n  if l.first < l.last\n    (1...l.length).each\
    \ do |index|\n      return false if l[index] < l[index - 1]\n    end\n  else\n\
    \    (1...l.length).each do |index|\n      return false if l[index] > l[index\
    \ - 1]\n    end\n  end\n  true\nend", "  l.zip(l.drop(1)).each_with_object([])\
    \ { |(a, b), result|\n    result << (a <=> b)\n  }.uniq.size == 1\nend", "  return\
    \ true if l.size <= 1\n  i = 0\n  while i < l.size - 1\n    if l[i] < l[i + 1]\n\
    \      i += 1\n      while i < l.size - 1\n        return false if l[i] >= l[i\
    \ + 1]\n        i += 1\n      end\n    elsif l[i] > l[i + 1]\n      i += 1\n \
    \     while i < l.size - 1\n        return false if l[i] <= l[i + 1]\n       \
    \ i += 1\n      end\n    else\n      i += 1\n    end\n  end\n  true\nend", " \
    \ if l.sort.last == l.last\n    return true\n  elsif l.sort.first == l.first\n\
    \    return true\n  else\n    return false\n  end\nend", "  l.each_cons(2).all?\
    \ { |x, y| y >= x } || l.each_cons(2).all? { |x, y| y <= x }\nend", "\tincreasing\
    \ = (l[0] <= l[1] && l[1] <= l[2])\n\tdecreasing = (l[0] >= l[1] && l[1] >= l[2])\n\
    \tincreasing || decreasing\nend", "  l.each_cons(2).all? { |a, b| a <= b } ||\
    \ l.each_cons(2).all? { |a, b| a >= b }\nend", "  l.each_cons(2).map { |x, y|\
    \ x <=> y }.all? { |n| n == 0 || n == 1 || n == -1 }\nend", "  inc = l.each_cons(2).all?\
    \ { |a, b| a <= b }\n  dec = l.each_cons(2).all? { |a, b| a >= b }\n  inc || dec\n\
    end", "  # l.sort == l || l.sort.reverse == l\n  return l.sort == l || l.sort.reverse\
    \ == l\nend", "  l.each_cons(2).all? { |(a, b)| (a - b).abs <= 1 }\nend", "  return\
    \ l.sort! == l || l.sort.reverse! == l\nend", "  l.each_cons(2).all? { |x, y|\
    \ x <= y } || l.each_cons(2).all? { |x, y| x >= y }\nend", "  asc = l.each_cons(2).all?\
    \ { |x, y| (x <= y) }\n  desc = l.each_cons(2).all? { |x, y| (x >= y) }\n  asc\
    \ || desc\nend", "  lambda { l.length <= 1 ||\n    l[0] <= l[1] && monotonic(l[1..-1]).call\
    \ ||\n    l[0] >= l[1] && monotonic(l[1..-1]).call\n  }.call\nend", "  return\
    \ true if l.length < 2\n  if l[0] <= l[1]\n    (0..l.length-2).all? { |i| l[i]\
    \ <= l[i+1] }\n  else\n    (0..l.length-2).all? { |i| l[i] >= l[i+1] }\n  end\n\
    end", "  l.sort!\n  puts l == l.sort || l == l.sort.reverse\nend", "  return l.all?\
    \ { |x| x >= l[0] } || l.all? { |x| x <= l[0] }\nend", "  return l.sort == l ||\
    \ l.sort.reverse == l\nend\nputs monotonic([4, 1, 0, -10])", "\tr = l.sort\n\t\
    return l == r || l == r.reverse\nend", "\traise ArgumentError, \"Input must be\
    \ an array\" unless l.is_a?(Array)\n\treturn true if l.length == 1\n\treturn l.reduce\
    \ { |result, element| result && l[l.index(element) - 1] <= element } if l[0] <\
    \ l[1]\n\treturn l.reduce { |result, element| result && l[l.index(element) - 1]\
    \ >= element } if l[0] > l[1]\n\treturn false\nend", "    incr = false\n    decr\
    \ = false\n    for i in 1..l.length-1\n        if l[i] > l[i-1]\n            incr\
    \ = true\n        elsif l[i] < l[i-1]\n            decr = true\n        end\n\
    \    end\n    return !(incr && decr)\nend", "  l.each_cons(2).all? { |a, b| a\
    \ == b || a < b } ||\n    l.each_cons(2).all? { |a, b| a == b || a > b }\nend",
  "    return false if l.length <= 1\n    return l.each_cons(2).all? { |a, b| a <=\
    \ b } || l.each_cons(2).all? { |a, b| a >= b }\nend", "  return l == l.sort ||\
    \ l == l.sort.reverse\nend", "  if l[0] <= l[1]\n    (1...l.length).each do |i|\n\
    \      return false if l[i] < l[i - 1]\n    end\n  else\n    (1...l.length).each\
    \ do |i|\n      return false if l[i] > l[i - 1]\n    end\n  end\n  true\nend",
  "  l.sort == l || l.sort.reverse == l\nend", "  return false if l.nil? || l.size\
    \ < 2\n  tmp = l[0]\n  check_order = ->(tmp, e) {\n    case\n    when tmp > e\n\
    \      :desc\n    when tmp < e\n      :asc\n    else\n      nil\n    end\n  }\n\
    \  order = nil\n  l.each do |e|\n    new_order = check_order.call(tmp, e)\n  \
    \  return false if new_order.nil?\n    if order.nil?\n      order = new_order\n\
    \    else\n      return false if order != new_order\n    end\n    tmp = e\n  end\n\
    \  true\nend", "  return true if l.size <= 1\n  negative = l[0] > l[1]\n  l.each_cons(2)\
    \ do |a, b|\n    if negative\n      return false if a < b\n    else\n      return\
    \ false if a > b\n    end\n  end\n  true\nend", "  return true if l.length < 2\n\
    \  return true if l.sort == l\n  return true if l.sort.reverse == l\n  false\n\
    end", "  if (l[0] - l[1]) * (l[-1] - l[-2]) > 0\n    true\n  else\n    false\n\
    \  end\nend", "  return true if l.length <= 1\n  inc, dec = true, true\n  (1...l.length).each\
    \ do |i|\n    inc &= l[i-1] <= l[i]\n    dec &= l[i-1] >= l[i]\n  end\n  inc ||\
    \ dec\nend", "  return true if l.size <= 1\n  return true if l[0] <= l[1] && monotonic(l[1..-1])\n\
    \  return true if l[0] >= l[1] && monotonic(l[1..-1])\n  false\nend", "  inc =\
    \ lambda {|a,b| a <= b}\n  dec = lambda {|a,b| a >= b}\n  l.each_cons(2).all?\
    \ &inc or l.each_cons(2).all? &dec\nend", "  i = 0\n  if l[i] > l[i+1]\n    while\
    \ i < l.length - 1\n      if l[i] < l[i+1]\n        return false\n      end\n\
    \      i += 1\n    end\n  elsif l[i] < l[i+1]\n    while i < l.length - 1\n  \
    \    if l[i] > l[i+1]\n        return false\n      end\n      i += 1\n    end\n\
    \  end\n  return true\nend", "  if l.sort == l || l.sort.reverse == l\n    return\
    \ true\n  else\n    return false\n  end\nend", "  return true if l.size <= 1\n\
    \  l.each_cons(2).all? { |x, y| x <=> y != 1 } || l.each_cons(2).all? { |x, y|\
    \ x <=> y != -1 }\nend", "  if l.sort == l\n    return true\n  elsif l.sort.reverse\
    \ == l\n    return true\n  else\n    return false\n  end\nend", "  return true\
    \ if l.size <= 1\n  inc = l[0] < l[1]\n  l.each_cons(2) do |i,j|\n    return false\
    \ if i < j != inc\n  end\n  true\nend", "  l.sort == l || l.sort.reverse == l\n\
    end", "  return false if l.length < 2\n  return false if l[0] > l[1] && l[1] <\
    \ l[2]\n  return false if l[0] < l[1] && l[1] > l[2]\n  return true\nend", " \
    \ if (l[0] <= l[1])\n    i = 0\n    while (i < l.length - 1)\n      if (l[i] >\
    \ l[i + 1])\n        return false\n      end\n      i += 1\n    end\n  else\n\
    \    i = 0\n    while (i < l.length - 1)\n      if (l[i] < l[i + 1])\n       \
    \ return false\n      end\n      i += 1\n    end\n  end\n  return true\nend",
  "  (l[0] - l[1]) * (l[-1] - l[-2]) > 0\nend", "\tt1 = true\n\tt2 = true\n\tt3 =\
    \ true\n\tfor i in 0..l.length-2\n\t\tif l[i] < l[i+1]\n\t\t\tt1 = false\n\t\t\
    end\n\t\tif l[i] > l[i+1]\n\t\t\tt2 = false\n\t\tend\n\t\tif l[i] == l[i+1]\n\t\
    \t\tt3 = false\n\t\tend\n\tend\n\tif t1 || t2 || t3\n\t\treturn true\n\telse\n\
    \t\treturn false\n\tend\nend", "  l.sort == l || l.sort.reverse == l\nend", " \
    \ i = 0\n  while i < l.length - 1\n    if l[i] <= l[i + 1]\n      i += 1\n   \
    \ else\n      return false\n    end\n  end\n  true\nend", "  if l.length == 1\n\
    \    return true\n  elsif l.length == 2\n    return l[0] <= l[1]\n  else\n   \
    \ i = 1\n    while i < l.length - 1\n      if l[i - 1] < l[i]\n        if l[i]\
    \ > l[i + 1]\n          return false\n        end\n      elsif l[i - 1] > l[i]\n\
    \        if l[i] < l[i + 1]\n          return false\n        end\n      else\n\
    \        return false\n      end\n      i += 1\n    end\n    return true\n  end\n\
    end", "  return false if l.length < 2\n  return l[0] <= l[1] if l.length == 2\n\
    \  (1..l.length-1).to_a.each do |i|\n    return false if l[i-1] != l[i] and l[i-1]\
    \ > l[i] and l[i+1] > l[i]\n  end\n  true\nend", "  l[0] < l[1] ? l[0..-2].zip(l[1..-1]).all?\
    \ { |i, j| i < j } : l[0..-2].zip(l[1..-1]).all? { |i, j| i > j }\nend", "  if\
    \ l.sort! == l\n    puts \"true\"\n  elsif l.sort! { |x, y| y <=> x } == l\n \
    \   puts \"true\"\n  else\n    puts \"false\"\n  end\nend", "    return false\
    \ if l.length <= 1\n    return l.each_cons(2).all? { |x, y| x <= y } || l.each_cons(2).all?\
    \ { |x, y| x >= y }\nend", "  l.each_cons(2).to_a.map{|a,b| a<=>b}.uniq.length\
    \ == 1\nend", "  l.each_cons(2).map { |a, b| b <=> a }.uniq.length == 1\nend",
  "  return true if l.size < 3\n  # Find the direction of the sequence.\n  m = l[1]\
    \ - l[0]\n  return false if m == 0\n  l.drop(2).all? { |x|\n    j = x - l[0]\n\
    \    return false if j.zero?\n    j.send(m > 0 ? :> : :<, 0)\n  }\nend", "  #\
    \ TODO: Implement me\nend", "  raise ArgumentError, \"l is not an array\" unless\
    \ l.is_a?(Array)\n  if l.length > 2\n    if l[0] < l[1]\n      for i in 0..l.length-2\n\
    \        return false if l[i] > l[i+1]\n      end\n    else\n      for i in 0..l.length-2\n\
    \        return false if l[i] < l[i+1]\n      end\n    end\n  end\n  true\nend",
  "  l.each_cons(2).all? { |a, b| a < b } || l.each_cons(2).all? { |a, b| a > b }\n\
    end", "  l.each_cons(2).all? { |a, b| a <= b } || l.each_cons(2).all? { |a, b|\
    \ a >= b }\nend", "  return true if l.size < 3\n  (l[0] <=> l[1]) * (l[1] <=>\
    \ l[2]) >= 0\nend", "\treturn true if l.length == 1", "  klass = nil\n  if l.sort\
    \ == l\n    klass = :sort\n  elsif l.sort.reverse == l\n    klass = :sort_reverse\n\
    \  end\n  klass.nil? ? false : true\nend", "  l.each_cons(2).all? { |a, b| a <=\
    \ b } || l.each_cons(2).all? { |a, b| a >= b }\nend", "  l.each_cons(2).all? {\
    \ |a, b| a <= b } || l.each_cons(2).all? { |a, b| a >= b }\nend", "  return l.reverse.each_cons(2).all?\
    \ { |a, b| a >= b } ||\n         l.each_cons(2).all? { |a, b| a <= b }\nend",
  "  return l.each_cons(2).all? { |a, b| a < b } || l.each_cons(2).all? { |a, b| a\
    \ > b }\nend", "  return false if l.max > l.min\n  return true if l.max == l.min\n\
    \  return true if l.max < l.min\nend", "  a = l.sort\n  b = l.sort.reverse\n \
    \ return true if l == a || l == b\n  false\nend", "  return false if l.size <=\
    \ 1\n  sign = nil\n  l.each_cons(2) do |a, b|\n    case a <=> b\n    when 1\n\
    \      return false if sign == -1\n      sign = 1\n    when -1\n      return false\
    \ if sign == 1\n      sign = -1\n    end\n  end\n  true\nend", "\treturn l.each_cons(2).all?\
    \ { |a, b| (a <=> b) == 1 } || l.each_cons(2).all? { |a, b| (a <=> b) == -1 }\n\
    end", "  return true if l.length <= 1\n  if l[0] < l[1]\n    l.each_with_index\
    \ do |v,i|\n      return false if i > 0 && v < l[i-1]\n    end\n  else\n    l.each_with_index\
    \ do |v,i|\n      return false if i > 0 && v > l[i-1]\n    end\n  end\n  true\n\
    end", "  return false if l.size <= 1\n  direction = l[1] - l[0]\n  (1...l.size).each\
    \ do |i|\n    if direction == 0\n      direction = l[i] - l[i - 1]\n      next\n\
    \    end\n    if (l[i] - l[i - 1]) / direction < 0\n      return false\n    end\n\
    \  end\n  true\nend", "  k = -1\n  (l.length - 1).times do |i|\n    j = i + 1\n\
    \    return false if (l[i] - l[j]).abs > 0 && k.abs != (l[i] - l[j]).abs\n   \
    \ k = l[i] - l[j]\n  end\n  true\nend", "\tmono = false\n\tif l.sort == l or l.sort.reverse\
    \ == l\n\t\tmono = true\n\tend\n\tmono\nend", "  return l.sort == l || l.sort.reverse\
    \ == l\nend", "  return true if l.length <= 1\n  l.each_cons(2).all? { |x, y|\
    \ y >= x } || l.each_cons(2).all? { |x, y| y <= x }\nend", "  l.all? { |i| l[i]\
    \ <= l[i+1] } || l.all? { |i| l[i] >= l[i+1] }\nend", "\tl.each_cons(2).all? {\
    \ |a, b| a <= b } || l.each_cons(2).all? { |a, b| a >= b }\nend", "  l.sort ==\
    \ l || l.sort.reverse == l\nend", "  return l.size < 2 || (l[0] < l[1] && monotonic(l[1..-1]))\
    \ || (l[0] > l[1] && monotonic(l[1..-1]))\nend", "  return l.sort == l || l.sort.reverse\
    \ == l\nend", "  up = l.each_cons(2).all? { |a, b| b >= a }\n  down = l.each_cons(2).all?\
    \ { |a, b| b <= a }\n  up || down\nend", "  return false if l.sort != l and l.sort.reverse\
    \ != l\n  true\nend", "  return true if l.sort == l || l.sort.reverse == l\n \
    \ false\nend", "  l == l.sort || l == l.sort.reverse\nend", "  (l[0] <= l[1] &&\
    \ l[1] <= l[2] && l[2] <= l[3]) || (l[0] >= l[1] && l[1] >= l[2] && l[2] >= l[3])\n\
    end", "  return true if l.size <= 1\n  if l[0] < l[1]\n    idx = 1\n    while\
    \ idx < l.size\n      return false if l[idx - 1] > l[idx]\n      idx += 1\n  \
    \  end\n  else\n    idx = 1\n    while idx < l.size\n      return false if l[idx\
    \ - 1] < l[idx]\n      idx += 1\n    end\n  end\n  true\nend", "  l.each_cons(2).all?\
    \ { |x, y| (x <=> y) * (l[0] <=> l[-1]) >= 0 }\nend", "  return true if l.size\
    \ <= 1\n  return l[0] <= l[1] ? monotonic(l[1..-1]) : false if l[0] <= l[1]\n\
    \  l[0] >= l[1] ? monotonic(l[1..-1]) : false\nend", "\t(0..l.length-2).all? {\
    \ |i| (l[i] - l[i+1]).abs == (l[i] - l[i+1]) }\nend", "  l[0] < l[1] && l[1] <\
    \ l[2] || l[0] > l[1] && l[1] > l[2] ? true : false\nend", "  l == l.sort || l\
    \ == l.sort.reverse\nend", "  m = {\n    :gt => true,\n    :lt => true\n  }\n\
    \  last = l.first\n  l.each do |v|\n    if last > v\n      m[:gt] = false\n  \
    \  elsif last < v\n      m[:lt] = false\n    end\n    last = v\n  end\n  return\
    \ m[:gt] || m[:lt]\nend", "  return l.length <= 1 || l.sort == l || l.sort.reverse\
    \ == l\nend", "  return true if l.length <= 1\n  is_monotonic = true\n  if l[0]\
    \ < l[1]\n    for i in 1..l.length-1\n      if l[i] < l[i-1]\n        is_monotonic\
    \ = false\n        break\n      end\n    end\n  else\n    for i in 1..l.length-1\n\
    \      if l[i] > l[i-1]\n        is_monotonic = false\n        break\n      end\n\
    \    end\n  end\n  is_monotonic\nend", "\tneg = 0\n\t\n\tfor i in 0..l.length-2\n\
    \t\tif l[i] < l[i+1]\n\t\t\tneg = 1\n\t\telsif l[i] > l[i+1]\n\t\t\tneg = -1\n\
    \t\tend\n\tend\n\t\n\tif neg == 0\n\t\treturn false\n\tend\n\t\n\tif neg == 1\n\
    \t\tfor i in 0..l.length-2\n\t\t\tif l[i] > l[i+1]\n\t\t\t\treturn false\n\t\t\
    \tend\n\t\tend\n\telsif neg == -1\n\t\tfor i in 0..l.length-2\n\t\t\tif l[i] <\
    \ l[i+1]\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn true\n\
    end", "\tif l.sort == l\n\t\treturn true\n\telsif l.sort.reverse == l\n\t\treturn\
    \ true\n\telse\n\t\treturn false\n\tend\nend", "  increasing = nil\n  for x in\
    \ 1...l.length\n    if l[x] > l[x-1]\n      if increasing != true\n        increasing\
    \ = true\n      end\n    elsif l[x] < l[x-1]\n      if increasing != false\n \
    \       increasing = false\n      end\n    end\n    if increasing == nil\n   \
    \   return false\n    end\n  end\n  return true\nend", "  last = 0\n  l.sort.each\
    \ do |i|\n    return false if i == last\n    last = i\n  end\n  true\nend", " \
    \ (0...l.length-1).all? { |i|\n    l[i] < l[i+1]\n  } || (0...l.length-1).all?\
    \ { |i|\n    l[i] > l[i+1]\n  }\nend", "  (1...l.length).each do |i|\n    return\
    \ false if l[i] < l[i-1]\n  end\n  true\nend", "  if l.length < 2\n    return\
    \ true\n  end\n  d = l[1] - l[0]\n  monotonic = true\n  for i in 2...l.length\n\
    \    if (l[i] - l[i-1])*d < 0\n      monotonic = false\n      break\n    end\n\
    \  end\n  return monotonic\nend", "  l.each_cons(2).all? do |left, right|\n  \
    \  left > right || left < right\n  end\nend", "  !(0...l.length - 1).any? { |i|\
    \ l[i] > l[i + 1] && l[i] < l[i + 1] }\nend", "  # YOUR CODE HERE\nend", "  l.sort\
    \ == l || l.sort.reverse == l\nend", "  return true if l.size <= 1\n  a = l[0]\n\
    \  b = l[1]\n  if a > b\n    for i in 1..l.size-1\n      if a < l[i]\n       \
    \ return false\n      end\n      a = l[i]\n    end\n  elsif a < b\n    for i in\
    \ 1..l.size-1\n      if a > l[i]\n        return false\n      end\n      a = l[i]\n\
    \    end\n  end\n  return true\nend", "  is_increasing = false\n  is_decreasing\
    \ = false\n  (0..l.length-2).each do |i|\n    if l[i] < l[i+1]\n      is_increasing\
    \ = true\n    elsif l[i] > l[i+1]\n      is_decreasing = true\n    end\n  end\n\
    \  is_increasing || is_decreasing\nend", "  return nil if l.empty?\n  increasing\
    \ = decreasing = true\n  increasing = l.each_cons(2).all? { |a, b| b >= a }\n\
    \  decreasing = l.each_cons(2).all? { |a, b| b <= a }\n  increasing || decreasing\n\
    end", "  if l[0] <= l[1]\n    sorted = true\n    l.each_cons(2) do |first, second|\n\
    \      if first > second\n        sorted = false\n        break\n      end\n \
    \   end\n  else\n    sorted = true\n    l.each_cons(2) do |first, second|\n  \
    \    if first < second\n        sorted = false\n        break\n      end\n   \
    \ end\n  end\n  return sorted\nend", '    return true if l.size < 2', "\tl.each_cons(2).all?\
    \ { |a, b| a <= b } || l.each_cons(2).all? { |a, b| a >= b }\nend", "  (l.first\
    \ <= l.last && l.each_cons(2).all? { |a, b| a <= b }) ||\n    (l.first >= l.last\
    \ && l.each_cons(2).all? { |a, b| a >= b })\nend", "  l.all? { |x| x >= l[0] }\
    \ || l.all? { |x| x <= l[0] }\nend", "  prev = nil\n  d = nil\n  for x in l\n\
    \    if prev != nil\n      nd = x <=> prev\n      if d != nil && nd != d\n   \
    \     return false\n      end\n      d = nd\n    end\n    prev = x\n  end\n  return\
    \ true\nend", "  # TODO\nend", "  increasing = l.each_cons(2).all? { |a, b| (a\
    \ <=> b) <= 0 }\n  decreasing = l.each_cons(2).all? { |a, b| (a <=> b) >= 0 }\n\
    \  increasing || decreasing\nend", "    down = l.each_cons(2).all? { |a, b| a\
    \ >= b }\n    up = l.each_cons(2).all? { |a, b| a <= b }\n    return up || down\n\
    end", "  l.each_cons(2).all? { |x, y| x == y || x < y || x > y }\nend", "    l.each_cons(2).all?\
    \ { |x, y| x <= y } || l.each_cons(2).all? { |x, y| x >= y }\nend", "  if l[0]\
    \ <= l[1]\n    for i in 1..l.length-1\n      if l[i] < l[i-1]\n        return\
    \ false\n      end\n    end\n  else\n    for i in 1..l.length-1\n      if l[i]\
    \ > l[i-1]\n        return false\n      end\n    end\n  end\n  return true\nend",
  "\t#check to see if it is all increasing\n\tcheck = true\n\tfor i in 0..l.length-2\n\
    \t\tcheck = l[i] <= l[i+1]\n\t\tif !check\n\t\t\tbreak\n\t\tend\n\tend\n\t#if\
    \ it isn't all increasing, check to see if it is all decreasing\n\tif !check\n\
    \t\tcheck = true\n\t\tfor i in 0..l.length-2\n\t\t\tcheck = l[i] >= l[i+1]\n\t\
    \t\tif !check\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn check\nend",
  "  i = 0\n  while i < l.length - 1\n    return false if l[i] != l[i + 1] && (l[i]\
    \ - l[i + 1]).abs != 1\n    i += 1\n  end\n  true\nend", "  incr = true\n  decr\
    \ = true\n  (1...l.length).each do |i|\n    incr = false if l[i] < l[i-1]\n  \
    \  decr = false if l[i] > l[i-1]\n  end\n  incr || decr\nend", "  return true\
    \ if l.size < 3\n  if l[0] < l[1]\n    for i in 1..l.size-1\n      return false\
    \ if l[i] < l[i-1]\n    end\n  else\n    for i in 1..l.size-1\n      return false\
    \ if l[i] > l[i-1]\n    end\n  end\n  return true\nend", "  l.each_cons(2).all?\
    \ { |(a, b)| a <= b } || l.each_cons(2).all? { |(a, b)| a >= b }\nend", "  l.sort\
    \ == l || l.sort.reverse == l\nend", "  l.each_cons(2).all? { |x, y| x <= y }\
    \ || l.each_cons(2).all? { |x, y| x >= y }\nend", "  return l.sort! == l || l.sort!.reverse!\
    \ == l\nend", "  l.sort == l || l.sort.reverse == l\nend", "  n = l.length\n \
    \ inc = true\n  dec = true\n  for i in 0..n-2\n    if l[i] > l[i+1]\n      inc\
    \ = false\n    end\n    if l[i] < l[i+1]\n      dec = false\n    end\n  end\n\
    \  inc or dec\nend", "  l.each_cons(2).each do |a, b|\n    return false if a <\
    \ b && l.last > l.first || a > b && l.last < l.first\n  end\n  true\nend", " \
    \ l.each_cons(2).all? { |a, b| (a - b).abs <= 1 }\nend", "  inc = false\n  dec\
    \ = false\n  i = 0\n  while (i < l.length - 1)\n    if (l[i] <= l[i + 1])\n  \
    \    inc = true\n    end\n    if (l[i] >= l[i + 1])\n      dec = true\n    end\n\
    \    if (inc && dec)\n      return false\n    end\n    i += 1\n  end\n  return\
    \ true\nend", "  (l.sort == l) || (l.sort.reverse == l)\nend", "  if l.length\
    \ <= 1\n    return true\n  end\n  if (l[0] - l[1]) > 0\n    for i in 1..(l.length\
    \ - 1)\n      if (l[i] - l[i + 1]) < 0\n        return false\n      end\n    end\n\
    \  elsif (l[0] - l[1]) < 0\n    for i in 1..(l.length - 1)\n      if (l[i] - l[i\
    \ + 1]) > 0\n        return false\n      end\n    end\n  else\n    return true\n\
    \  end\nend", "\tif l[1] - l[0] > 0\n\t\tincreasing = true\n\telse\n\t\tincreasing\
    \ = false\n\tend\n\ti = 1\n\twhile i < l.length\n\t\tif increasing && l[i] - l[i-1]\
    \ < 0\n\t\t\treturn false\n\t\telsif !increasing && l[i] - l[i-1] > 0\n\t\t\t\
    return false\n\t\tend\n\t\ti+=1\n\tend\n\treturn true\nend", "  return false if\
    \ l.size <= 1\n  return true if l.size == 2\n  if l[0] < l[1]\n    l.each_cons(2).all?\
    \ { |a, b| a < b }\n  else\n    l.each_cons(2).all? { |a, b| a > b }\n  end\n\
    end", "\treturn l.sort == l || l.sort.reverse == l\nend", "\tif l.sort! == l ||\
    \ l.sort!.reverse! == l\n\t\tputs \"true\"\n\telse\n\t\tputs \"false\"\n\tend\n\
    end\nmonotonic([1, 2, 4, 20])\nmonotonic([1, 20, 4, 10])\nmonotonic([4, 1, 0,\
    \ -10])", "  if l.length <= 1\n    return true\n  end\n  sum = 0\n  for i in 0..l.length-2\n\
    \    if l[i] < l[i+1]\n      sum -= 1\n    elsif l[i] > l[i+1]\n      sum += 1\n\
    \    end\n  end\n  if sum.abs <= 1\n    return true\n  else\n    return false\n\
    \  end\nend", "  l == l.sort || l == l.sort.reverse\nend", "    (1...l.length).each\
    \ do |i|\n        return false if l[i] - l[i-1] > 0 && l[i-1] - l[i-2] < 0 ||\
    \ l[i] - l[i-1] < 0 && l[i-1] - l[i-2] > 0\n    end\n    true\nend", "  check_l\
    \ = 0\n  return true if l.size <= 1\n  l.each_with_index do |el, i|\n    unless\
    \ i == 0\n      return false if l[i - 1] > el && check_l == -1\n      return false\
    \ if l[i - 1] < el && check_l == 1\n      check_l = l[i - 1] <=> el\n    end\n\
    \  end\n  true\nend", "  return true if l.length < 2\n  return l[0] <= l[1] if\
    \ l.length == 2\n  return monotonic_subseq(l[0], l[1], l[2]) if l.length == 3\n\
    \  first = l[0]\n  second = l[1]\n  third = l[2]\n  return false if third == first\n\
    \  increasing = monotonic_subseq(first, second, third)\n  increasing ? monotonic(l[1..-1])\
    \ : false\nend", "  if l[0] < l[1]\n    a = l.all? { |e| l.index(e) < l.index(e\
    \ + 1) }\n  else\n    a = l.all? { |e| l.index(e) < l.index(e - 1) }\n  end\n\
    \  a\nend", "  return true if l.length <= 1\n  l1 = l.slice(0, l.length - 1)\n\
    \  l2 = l.slice(1, l.length)\n  return l1.zip(l2).all? { |i, j| i <= j } || l1.zip(l2).all?\
    \ { |i, j| i >= j }\nend", "\tm = false\n\tm = true if l.first > l.last\n\tm ?\
    \ l.sort.reverse : l.sort\nend", '  return true if l.size < 3', "  last = l[0]\n\
    \  l[1..-1].all? do |e|\n    (e > last || e < last) && (last = e)\n  end\nend",
  "  l.sort == l or l.sort.reverse == l\nend", "  i = 0\n  while i < l.length-1\n\
    \    if l[i] > l[i+1]\n      return monotonic2(l)\n    end\n    i += 1\n  end\n\
    \  return true\nend", "  return true if l.size <= 1\n  return l[0] < l[1] ? monotonic_increasing(l,\
    \ 0) : monotonic_decreasing(l, 0)\nend", "    return l.each_cons(2).all? { |a,\
    \ b| a <= b } || l.each_cons(2).all? { |a, b| a >= b }\nend", "  l.each_cons(2).all?\
    \ do |pair|\n    pair[0] <= pair[1]\n  end || l.each_cons(2).all? do |pair|\n\
    \    pair[0] >= pair[1]\n  end\nend", "  l.inject { |x, y| (x <=> y) == 0 }\n\
    end", "  return true if l.length < 2\n  i = 1\n  sign = l[i] - l[i-1] > 0 ? :+\
    \ : :-\n  while i < l.length\n    return false if sign != (l[i] - l[i-1] > 0 ?\
    \ :+ : :-)\n    i += 1\n  end\n  true\nend", "  return false if l.length <= 1\n\
    \  if l[0] > l[1]\n    (l.length - 1).times do |i|\n      return false if l[i]\
    \ < l[i + 1]\n    end\n  else\n    (l.length - 1).times do |i|\n      return false\
    \ if l[i] > l[i + 1]\n    end\n  end\n  true\nend", "  if l.sort == l\n    true\n\
    \  elsif l.sort.reverse == l\n    true\n  else\n    false\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
