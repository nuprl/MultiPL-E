name: HumanEval_49_modp
language: rb
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp.call(3, 5)\n# 3\n\
  # >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3,\
  \ 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
  \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2,\
  \ candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8,\
  \ candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4,\
  \ candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
completions: ["  #return 1 if n == 0\n  #return n % p if n <= p\n  #q = n / p\n  #return\
    \ modp(q, p) if q % 2 == 0\n  #return n - q * p if q % 2 == 1\n  return 1 if n\
    \ == 0\n  return n % p if n <= p\n  q = n / p\n  return modp(q, p) if q % 2 ==\
    \ 0\n  return n - q * p if q % 2 == 1\nend", "  y = 1\n  x = 2\n  while (n > 0)\n\
    \    if (n.odd?)\n      y = (y * x) % p\n    end\n    x = (x * x) % p\n    n =\
    \ n / 2\n  end\n  y\nend", "  if n == 0\n    return 1\n  end\n  return ((2 * modp(n\
    \ - 1, p)) % p)\nend", "  return 1 if n == 0\n  return 2 if n == 1\n  res = 0\n\
    \  if n % 2 == 0\n    res = modp(n / 2, p) ** 2 % p\n  else\n    res = 2 * modp(n\
    \ - 1, p) % p\n  end\n  return res\nend", "  if p == 1\n    return 0\n  end\n\
    \  u = 1\n  pwr = n\n  while pwr > 0\n    if pwr % 2 == 1\n      u = (u * n) %\
    \ p\n    end\n    n = (n * n) % p\n    pwr = pwr / 2\n  end\n  return u\nend",
  "  # binary exponentiation\n  def modp_helper(p, n, m)\n    if p == 0\n      1\n\
    \    elsif p == 1\n      n % m\n    else\n      modp_helper(p/2, n*n, m) * (n\
    \ ** (p % 2)) % m\n    end\n  end\n  modp_helper(n, n, p)\nend", "\tif n < 0\n\
    \t\treturn (-n).modulo(p)\n\tend\n\treturn n.modulo(p)\nend", "  if n == 0\n \
    \   return 1\n  end\n  if n % 2 == 0\n    return (modp(n/2, p)**2) % p\n  else\n\
    \    return (modp(n-1, p) * (2 % p)) % p\n  end\nend", "  return 1 if n == 0\n\
    \  t = modp(n / 2, p)\n  t = (t * t) % p\n  t = (t * 2) % p if n % 2 == 1\n  t\n\
    end", "  return 1 if n == 0\n  return 0 if n < 0", "  return 1 if n == 0\n  a\
    \ = modp(n / 2, p)\n  a = (a * a) % p\n  return a if n % 2 == 0\n  return (a *\
    \ 2) % p\nend", "  return 1 if n == 0\n  return 2 * modp(n - 1, p) % p if n.even?\n\
    \  return 2 * modp(n - 1, p) % p + 1 if n.odd?\nend", "  (n**n) % p\nend", " \
    \ raise ArgumentError, \"Argument p must be greater than 0\" if p < 1\n  raise\
    \ ArgumentError, \"Argument n must be greater than or equal to 0\" if n < 0\n\
    \  return 1 if n == 0\n  return 2**(n % (p-1)) % p\nend", "  n % p\nend", "  raise\
    \ 'The exponent must be non-negative' if n < 0\n  raise 'The modulus must be positive'\
    \ if p <= 0\n  return 1 if n == 0\n  return (modp(n >> 1, p) ** 2 * (n & 1 ==\
    \ 1 ? 2 : 1)) % p\nend", "  raise ArgumentError, \"n=#{n} must be non-negative\"\
    \ if n < 0\n  raise ArgumentError, \"p=#{p} must be prime\" unless p.prime?\n\
    \  return 1 if n == 0\n  return 2 if n == 1\n  b = 2\n  n -= 1\n  while n > 0\n\
    \    b = (b * b) % p\n    n = n >> 1 if n & 1 == 1\n    n = n >> 1\n  end\n  b\n\
    end", "  return 1 if n == 0\n  return 2 if n == 1\n  return ((2 * modp(n - 1,\
    \ p)) * (2 % p)) % p\nend", "  return n.to_i if n == 0\n  return 2.to_i if n ==\
    \ 1\n  if n % 2 == 0\n    res = modp(n / 2, p)\n    res * res % p\n  else\n  \
    \  res = modp(n - 1, p)\n    2 * res % p\n  end\nend", "    #your code here\n\
    \    return 1 if n == 0\n    return 2 if n == 1\n    a = 2\n    b = a\n    c =\
    \ n - 1\n    while c > 0\n        b = (b * a) % p\n        c -= 1\n    end\n \
    \   return b\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
