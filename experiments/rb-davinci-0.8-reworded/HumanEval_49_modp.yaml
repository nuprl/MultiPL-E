name: HumanEval_49_modp
language: rb
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp.call(3, 5)\n# 3\n\
  # >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3,\
  \ 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
  \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2,\
  \ candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8,\
  \ candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4,\
  \ candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
completions: ["  #return 1 if n == 0\n  #return n % p if n <= p\n  #q = n / p\n  #return\
    \ modp(q, p) if q % 2 == 0\n  #return n - q * p if q % 2 == 1\n  return 1 if n\
    \ == 0\n  return n % p if n <= p\n  q = n / p\n  return modp(q, p) if q % 2 ==\
    \ 0\n  return n - q * p if q % 2 == 1\nend", "  y = 1\n  x = 2\n  while (n > 0)\n\
    \    if (n.odd?)\n      y = (y * x) % p\n    end\n    x = (x * x) % p\n    n =\
    \ n / 2\n  end\n  y\nend", "  if n == 0\n    return 1\n  end\n  return ((2 * modp(n\
    \ - 1, p)) % p)\nend", "  return 1 if n == 0\n  return 2 if n == 1\n  res = 0\n\
    \  if n % 2 == 0\n    res = modp(n / 2, p) ** 2 % p\n  else\n    res = 2 * modp(n\
    \ - 1, p) % p\n  end\n  return res\nend", "  if p == 1\n    return 0\n  end\n\
    \  u = 1\n  pwr = n\n  while pwr > 0\n    if pwr % 2 == 1\n      u = (u * n) %\
    \ p\n    end\n    n = (n * n) % p\n    pwr = pwr / 2\n  end\n  return u\nend",
  "  # binary exponentiation\n  def modp_helper(p, n, m)\n    if p == 0\n      1\n\
    \    elsif p == 1\n      n % m\n    else\n      modp_helper(p/2, n*n, m) * (n\
    \ ** (p % 2)) % m\n    end\n  end\n  modp_helper(n, n, p)\nend", "\tif n < 0\n\
    \t\treturn (-n).modulo(p)\n\tend\n\treturn n.modulo(p)\nend", "  if n == 0\n \
    \   return 1\n  end\n  if n % 2 == 0\n    return (modp(n/2, p)**2) % p\n  else\n\
    \    return (modp(n-1, p) * (2 % p)) % p\n  end\nend", "  return 1 if n == 0\n\
    \  t = modp(n / 2, p)\n  t = (t * t) % p\n  t = (t * 2) % p if n % 2 == 1\n  t\n\
    end", "  return 1 if n == 0\n  return 0 if n < 0", "  return 1 if n == 0\n  a\
    \ = modp(n / 2, p)\n  a = (a * a) % p\n  return a if n % 2 == 0\n  return (a *\
    \ 2) % p\nend", "  return 1 if n == 0\n  return 2 * modp(n - 1, p) % p if n.even?\n\
    \  return 2 * modp(n - 1, p) % p + 1 if n.odd?\nend", "  (n**n) % p\nend", " \
    \ raise ArgumentError, \"Argument p must be greater than 0\" if p < 1\n  raise\
    \ ArgumentError, \"Argument n must be greater than or equal to 0\" if n < 0\n\
    \  return 1 if n == 0\n  return 2**(n % (p-1)) % p\nend", "  n % p\nend", "  raise\
    \ 'The exponent must be non-negative' if n < 0\n  raise 'The modulus must be positive'\
    \ if p <= 0\n  return 1 if n == 0\n  return (modp(n >> 1, p) ** 2 * (n & 1 ==\
    \ 1 ? 2 : 1)) % p\nend", "  raise ArgumentError, \"n=#{n} must be non-negative\"\
    \ if n < 0\n  raise ArgumentError, \"p=#{p} must be prime\" unless p.prime?\n\
    \  return 1 if n == 0\n  return 2 if n == 1\n  b = 2\n  n -= 1\n  while n > 0\n\
    \    b = (b * b) % p\n    n = n >> 1 if n & 1 == 1\n    n = n >> 1\n  end\n  b\n\
    end", "  return 1 if n == 0\n  return 2 if n == 1\n  return ((2 * modp(n - 1,\
    \ p)) * (2 % p)) % p\nend", "  return n.to_i if n == 0\n  return 2.to_i if n ==\
    \ 1\n  if n % 2 == 0\n    res = modp(n / 2, p)\n    res * res % p\n  else\n  \
    \  res = modp(n - 1, p)\n    2 * res % p\n  end\nend", "    #your code here\n\
    \    return 1 if n == 0\n    return 2 if n == 1\n    a = 2\n    b = a\n    c =\
    \ n - 1\n    while c > 0\n        b = (b * a) % p\n        c -= 1\n    end\n \
    \   return b\nend", "  if p == 1\n    return 0\n  end\n  (2 ** n) % p\nend", "\t\
    raise \"not implemented\"\nend", "\t(n < 0) ? modp(n + p, p) : (n**2) % p\nend",
  "  #result = 1\n  #n.times do\n  #  result = (result * 2) % p\n  #end\n  #result\n\
    \  n.times.inject(1) { |a, e| (a * 2) % p }\nend", "  # TODO\nend", "  r = 1\n\
    \  while n > 0\n    if n%2 == 1\n      r = (r*p)%p\n    end\n    p = (p*p)%p\n\
    \    n = n/2\n  end\n  return r\nend", "  return 1 if n == 0\n  (2 * modp(n -\
    \ 1, p)) % p\nend", "  # TODO: Implement modp\n  return 1 if n == 0\n  r = modp(n/2,\
    \ p)\n  r = (r*r) % p\n  return r if n % 2 == 0\n  return (r*2) % p\nend", " \
    \ return 1 if n == 0\n  if n % 2 == 0\n    modp(n / 2, p) ** 2 % p\n  else\n \
    \   modp(n - 1, p) * 2 % p\n  end\nend", "  p = [n, p].min\n  (n % p).to_i\nend",
  "  $modp_memo ||= {}\n  return $modp_memo[[n, p]] if $modp_memo.key?([n, p])\n \
    \ return $modp_memo[[n, p]] = 1 if n == 0\n  return $modp_memo[[n, p]] = 2 if\
    \ n == 1\n  res = (modp(n - 1, p) * 2) % p\n  $modp_memo[[n, p]] = res\nend",
  "  r = 1\n  if n > 1\n    s = 1\n    while s <= n\n      s = s * 2\n    end\n  \
    \  s = s / 2\n    r = modp(n - s, p) * modp(s, p) % p\n  end\n  r\nend", "  n.positive?\
    \ ? n % p : 1\nend", "  n % p == 0 ? 0 : powmod(2, n, p)\nend", "  if n == 0\n\
    \    1\n  elsif n % 2 == 0\n    half = modp(n / 2, p)\n    (half * half) % p\n\
    \  else\n    (modp(n - 1, p) * (2 % p)) % p\n  end\nend", "  return 1 if n ==\
    \ 0\n  return (2*modp(n-1, p)) % p\nend", "  (2**n) % p\nend", "\tif n == 0\n\t\
    \t1\n\telse\n\t\tproduct = modp(n/2, p)\n\t\tproduct = (product * product) % p\n\
    \t\tif n % 2 == 1\n\t\t\tproduct = (product * 2) % p\n\t\tend\n\t\tproduct\n\t\
    end\nend", "\tif n == 0\n\t\treturn 1\n\telsif n % 2 == 0\n\t\treturn (modp(n/2,\
    \ p) ** 2) % p\n\telse\n\t\treturn (modp(n-1, p) * 2) % p\n\tend\nend", "  (n\
    \ == 0) ? 1 : ((p % n == 0) ? 0 : (n % 2 == 0) ? modp(n / 2, p) * modp(n / 2,\
    \ p) % p : 2 * modp(n / 2, p) * modp(n / 2, p) % p)\nend", "  (n == 0 ? 1 : n.even?\
    \ ? modp(n/2, p)**2 % p : 2 * modp(n-1, p) % p)\nend", "  if n == 0\n    1\n \
    \ elsif n.even?\n    modp(n/2, p)**2 % p\n  else\n    n * modp(n-1, p) % p\n \
    \ end\nend", "  n.pow(p-2, p)\nend", "  #\n  # Your code goes here\n  #\n  n =\
    \ n % p\n  if n == 0\n    return 1\n  elsif n == 1\n    return 2\n  else\n   \
    \ return 2*modp(n-1, p) % p\n  end\nend", "  if p == 1\n    return 0\n  end\n\
    \  res = 1\n  p = p.to_i\n  while n > 0\n    if n.odd?\n      res = (res * 2)\
    \ % p\n    end\n    n = n / 2\n    p = (p * 2) % p\n  end\n  res\nend", "  return\
    \ 1 if n == 0\n  x = modp(n/2, p)\n  x = (x * x) % p\n  if n%2 == 0\n    return\
    \ x\n  else\n    return (x * 2) % p\n  end\nend", "  return 1 if n == 0\n  if\
    \ n % 2 == 0\n    sq = modp(n / 2, p)\n    sq * sq % p\n  else\n    modp(n - 1,\
    \ p) * n % p\n  end\nend", "  p = p.to_i\n  n = n.to_i", "  return 1 if n == 0\n\
    \  (modp(n / 2, p) ** 2 * (2 * (n % 2) - 1)) % p\nend", "  (n % p).zero? ? 1 :\
    \ n.even? ? (modp(n / 2, p) ** 2) % p : (2 * modp(n / 2, p) ** 2) % p\nend", " \
    \ if n == 0\n    1\n  elsif n.even?\n    (modp(n/2, p)*modp(n/2, p)) % p\n  else\n\
    \    (modp(n/2, p)*modp(n/2, p)*2) % p\n  end\nend", "  # First, compute the sqr.\n\
    \  # >>> bin(5)\n  # '0b101'\n  # >>> 5**2\n  # 25\n  sqr = mod(n**2, p)\n  #\
    \ Then, check the number of bits.\n  # >>> bin(n)\n  # '0b1101'\n  # >>> len(bin(n))\
    \ - 2\n  # 4\n  if len(bin(n)) - 2 == 1\n    # If it is a power of 2, return the\
    \ sqr.\n    return sqr\n  else\n    # Otherwise, do modp for half of n.\n    #\
    \ >>> int(bin(n)[3:], 2)\n    # 13\n    # >>> modp(13, 101)\n    # 14\n    return\
    \ mod(modp(int(bin(n)[3:], 2), p) * sqr, p)\n  end\nend", "\t(2**n) % p\nend",
  "  return 1 if n == 0\n  return modp(n/2, p)**2 % p if n % 2 == 0\n  return 2 *\
    \ modp(n/2, p)**2 % p if n % 2 == 1\nend", "  return 1 if n == 0\n  return (2\
    \ * modp(n-1, p)) % p\nend", end, "  if n == 0\n    1\n  elsif n.even?\n    modp(n/2,\
    \ p) ** 2 % p\n  else\n    n % p * modp(n/2, p) ** 2 % p\n  end\nend", "  (n**2)\
    \ % p\nend", "  if n < 0\n    raise ArgumentError.new(\"n must be >= 0\")\n  end\n\
    \  if p < 2\n    raise ArgumentError.new(\"p must be >= 2\")\n  end\n  answer\
    \ = 1\n  m = n\n  while m > 0\n    if m % 2 == 1\n      answer = (answer * 2)\
    \ % p\n    end\n    m = m / 2\n  end\n  return answer\nend", "  n = n % p\n  return\
    \ 0 if n == 0\n  return 1 if n == 1\n  return n if n <= p/3\n  return p - modp(p\
    \ % n, n)\nend", "  if n == 0\n    1\n  else\n    t = modp(n / 2, p)\n    if n\
    \ % 2 == 0\n      (t * t) % p\n    else\n      (((t * t) % p) * 2) % p\n    end\n\
    \  end\nend", "  return 1 if n == 0\n  return 0 if n < 0\n  modp(n / 2, p) **\
    \ 2 * (n.even? ? 1 : p) % p\nend", "  # https://en.wikipedia.org/wiki/Modular_exponentiation\n\
    \  result = 1\n  while n > 0\n    result = (result * n) % p\n    n -= 1\n  end\n\
    \  result\nend", "  return 1 if n == 0\n  v = modp(n/2, p)\n  v * v * (n % 2 ==\
    \ 0 ? 1 : p) % p\nend", "\treturn 1 if n == 0\n\t(modp(n-1, p) * 2) % p\nend",
  "  raise \"n too large\" if n > 1_000_000\n  return 0 if n == 0\n  raise \"p too\
    \ large\" if p > 1_000_000\n  x = 1\n  for i in 1..n\n    x = x * 2 % p\n  end\n\
    \  x\nend", "  if n == 0\n    return 1\n  elsif n % 2 == 0\n    t = modp(n / 2,\
    \ p)\n    return (t * t) % p\n  else\n    return (2 * modp(n - 1, p)) % p\n  end\n\
    end", "  #return (2**n) % p\n  return (n**p) % p\nend", "  return 1 if n == 0\n\
    \  if n.even?\n    t = modp(n/2, p)\n    return t*t % p\n  else\n    return (2*modp(n-1,\
    \ p)) % p\n  end\nend", "  return 1 if n == 0\n  return modp(n / 2, p) * modp(n\
    \ / 2, p) % p if n % 2 == 0\n  return 2 * modp(n / 2, p) * modp(n / 2, p) % p\n\
    end", "  return 1 if n == 0\n  return 2 * modp(n-1, p) % p if n % 2 == 0\n  return\
    \ 2 * modp(n-1, p) % p * 2 % p if n % 2 == 1\nend", "  n > 0 ? modp(n / 2, p)\
    \ ** 2 * [1, p][n % 2] : 1\nend", "    r = 1\n    while n > 0\n        if n &\
    \ 1 > 0\n            r = (r * 2) % p\n        end\n        n >>= 1\n    end\n\
    \    return r\nend", "  if n == 0\n    1\n  elsif n % 2 == 0\n    sq = modp(n\
    \ / 2, p)\n    (sq * sq) % p\n  else\n    (modp(n - 1, p) * n) % p\n  end\nend",
  "  res = 1\n  a = 2\n  # the next two lines can be replaced by \"while n > 0\"\n\
    \  while n > 0 || res < 0\n    if n % 2 == 1\n      res = res * a % p\n    end\n\
    \    a = a * a % p\n    n = n / 2\n  end\n  res\nend", "  if n == 0\n    return\
    \ 1\n  end\n  if n % 2 == 0\n    return modp(n/2, p)**2 % p\n  else\n    return\
    \ modp(n/2, p)**2 * 2 % p\n  end\nend", "  return 1 if n == 0\n  ret = modp(n/2,\
    \ p)**2 % p\n  return ret if n % 2 == 0\n  ret * 2 % p\nend", "  raise \"n must\
    \ be >= 0 and p must be > 0\" if n < 0 || p <= 0\n  return 1 if n == 0\n  return\
    \ 1 if n == 1\n  return (2*modp(n-1, p)) % p if n.even?\n  return (2*modp(n-1,\
    \ p) - 1) % p if n.odd?\nend", "  return 1 if n == 0\n  return modp(n/2, p) **\
    \ 2 % p if n.even?\n  return modp(n/2, p) ** 2 * 2 % p if n.odd?\nend", "  return\
    \ 0 if p == 0\n  return 1 if n == 0\n  return (2*modp(n-1, p) % p) if n.even?\n\
    \  return (2*modp(n-1, p) % p) + 1 if n.odd?\nend", "  return 0 if n == 0\n  r\
    \ = 1\n  while n != 0\n    r = (r * 2) % p if n % 2 == 1\n    n /= 2\n  end\n\
    \  r\nend", "  if n == 0\n    1\n  elsif n % 2 == 0\n    (2 * modp(n / 2, p))\
    \ % p\n  else\n    (2 * modp(n / 2, p) + 1) % p\n  end\nend", "  return 0 if n\
    \ == 0\n  if n % 2 == 0\n    (modp(n / 2, p) * modp(n / 2, p)) % p\n  else\n \
    \   (2 * modp(n / 2, p) * modp(n / 2, p)) % p\n  end\nend", "  n % p\nend", "\t\
    if n.zero?\n\t\t1\n\telse\n\t\t(2*modp(n-1, p)) % p\n\tend\nend", "  # Your code\
    \ here\n  x = 1\n  for i in 0..n-1\n    x = (x * 2) % p\n  end\n  return x\nend",
  "\tcounter = 1\n\tif n == 0\n\t\treturn 1\n\telse\n\t\twhile n > 0\n\t\t\tcounter\
    \ = (counter * 2) % p\n\t\t\tn -= 1\n\t\tend\n\tend\n\treturn counter\nend", " \
    \ r = 1\n  (1..n).each do |i|\n    r = (r * 2) % p\n  end\n  r\nend", "  if n\
    \ <= 2\n    case n\n    when 2 then 4\n    when 1 then 2\n    when 0 then 1\n\
    \    end\n  else\n    modp(n / 2, p) ** 2 % p\n  end\nend", "  n % p\nend", " \
    \ return n if n == 0\n  r = modp(n/2, p)\n  r = (r * r) % p\n  r = (r * 2) % p\
    \ if n % 2 == 1\n  r\nend", "  if n == 0\n    1\n  elsif n == 1\n    n\n  else\n\
    \    (2*modp(n-1, p)) % p\n  end\nend", "  n = n.to_i\n  p = p.to_i\n  return\
    \ 1 if n == 0\n  return 2 if n == 1\n  return 4 if n == 2\n  a = modp(n/2, p)\n\
    \  return (a*a) % p if n.even?\n  return (2*a*a) % p if n.odd?\nend", "  r = 1\n\
    \  m = n\n  while m > 0\n    if m % 2 == 1\n      r = (r * n) % p\n    end\n \
    \   n = (n * n) % p\n    m = m / 2\n  end\n  r\nend", "  raise \"modp: n must\
    \ be a positive integer\" unless n.is_a?(Integer) && n >= 0\n  raise \"modp: p\
    \ must be an odd prime\" unless p.is_a?(Integer) && p.odd? && prime?(p)\n  pow\
    \ = p - 1\n  a = pow.floor\n  b = pow.ceil\n  x = _binary_rep(n)\n  y = _binary_rep(n)\n\
    \  z = _binary_rep(n)\n  i = 1\n  while i < x.length\n    z = _mult_mod(y, y,\
    \ p)\n    y = _mult_mod(y, z, p)\n    i += 2\n  end\n  while i > 1\n    z = _mult_mod(y,\
    \ y, p)\n    y = _mult_mod(x, z, p)\n    i -= 1\n  end\n  return y\nend", "  return\
    \ 1 if n == 0\n  t = modp(n / 2, p)\n  t = t * t % p\n  t = t * 2 % p if n % 2\
    \ == 1\n  t\nend", "    puts \"implement modp(n, p) returning 2^n modulo p (be\
    \ aware of numerics).\"\nend", "  raise NotImplementedError\nend", "  #n<0 ? modp(n+p,p)\
    \ : n<2 ? n : modp(2*modp(n/2,p),p)**2*(n%2+1)%p\n  a = 2\n  pow = n\n  if n <\
    \ 0\n    a = 2\n    pow = n+p\n  elsif n < 2\n    a = n\n    pow = 0\n  else\n\
    \    a = modp(2*modp(n/2,p),p)\n    pow = n%2+1\n  end\n  a**pow % p\nend", " \
    \ n.zero? ? 1 : (modp(n / 2, p)**2 * (n % 2 == 0 ? 1 : 2)) % p\nend", "  raise\
    \ ArgumentError.new(\"n must be in [0, #{p - 1}]\") unless (0..p - 1).include?(n)\n\
    \  @modp_cache ||= {}\n  @modp_cache[n] ||= {}\n  return @modp_cache[n][p] if\
    \ @modp_cache[n][p]\n  return @modp_cache[n][p] = 1 if n == 0\n  return @modp_cache[n][p]\
    \ = 2 if n == 1\n  return @modp_cache[n][p] = 4 if n == 2\n  @modp_cache[n][p]\
    \ = 2 * modp(n - 1, p)\n  @modp_cache[n][p] -= p if @modp_cache[n][p] >= p\n \
    \ @modp_cache[n][p]\nend", "  num = 1\n  for i in 0..n\n    num = (num * 2) %\
    \ p\n  end\n  return num\nend", "  if n < 1\n    1\n  else\n    2*modp(n-1, p)\
    \ % p\n  end\nend", "  (n**n) % p\nend", "\t1\nend", "  return 1 if n == 0\n \
    \ return 2 if n == 1\n  a = modp(n / 2, p)\n  return (((a * a) % p) * (2 % p))\
    \ % p if n % 2 == 1\n  return (a * a) % p\nend", "  raise ValueError(\"n: #{n}\
    \ must be >= 0\") if n < 0\n  raise ValueError(\"p: #{p} must be a prime\") unless\
    \ prime?(p)\n  modp_ = 0\n  r = (p - 1) / 2\n  return modp_ if n == 0\n  i = 1\n\
    \  loop do\n    break if i > r\n    modp_ = 2 * modp_\n    modp_ = modp_ + 1 if\
    \ (n & (1 << i)) > 0\n    i += 1\n  end\n  modp_ % p\nend", "  (1 << n) % p\n\
    end", "  raise \"Unsupported datatype\" unless n.is_a?(Integer) && p.is_a?(Integer)\n\
    \  if n == 0\n    return 1\n  elsif n == 1\n    return 2 % p\n  else\n    t =\
    \ modp(n / 2, p)\n    if n % 2 == 0\n      return (t * t) % p\n    else\n    \
    \  return (2 * t * t) % p\n    end\n  end\nend", "  b = 1\n  while n > 0\n   \
    \ if n % 2 == 1\n      b = (b * 2) % p\n    end\n    n = n / 2\n  end\n  b\nend",
  "  # raise ArgumentError if n.nil? || p.nil?\n  # raise ArgumentError if n.negative?\
    \ || p.negative?\n  # raise ArgumentError if n.zero? || p.zero?\n  # raise ArgumentError\
    \ if n < 0 || p < 0\n  # raise ArgumentError if n.zero? || p.zero?\n  raise ArgumentError\
    \ unless n.is_a?(Integer) && p.is_a?(Integer)", "  # raise error if n is negative\n\
    \  raise ArgumentError, \"n must be non-negative\" if n < 0\n  # raise error if\
    \ p is not prime\n  raise ArgumentError, \"p must be prime\" unless is_prime?(p)\n\
    \  # find 2^n mod p\n  mod_p = 1\n  (0...n).each do |i|\n    mod_p = mod_p * 2\
    \ % p\n  end\n  mod_p\nend", "  # For some reason, python's modulus is not what\
    \ I want.\n  #  I want -1 mod 5 to be 4, not -1.\n  # return (((2**n) % p) + p)\
    \ % p\n  if n == 0\n    return 1\n  elsif n == 1\n    return 2\n  elsif n == 2\n\
    \    return 4\n  elsif n == 3\n    return 8\n  elsif n == 4\n    return 16\n \
    \ elsif n == 5\n    return 32\n  elsif n == 6\n    return 64\n  elsif n == 7\n\
    \    return 128\n  elsif n == 8\n    return 256\n  elsif n == 9\n    return 512\n\
    \  elsif n == 10\n    return 1024\n  elsif n == 11\n    return 2048\n  elsif n\
    \ == 12\n    return 4096\n  elsif n == 13\n    return 8192\n  elsif n == 14\n\
    \    return 16384\n  elsif n == 15\n    return 32768\n  elsif n == 16\n    return\
    \ 65536\n  elsif n == 17\n    return 131072\n  elsif n == 18\n    return 262144\n\
    \  elsif n == 19\n    return 524288\n  elsif n == 20\n    return 1048576\n  elsif\
    \ n == 21\n    return 2097152\n  elsif n == 22\n    return 4194304\n  elsif n\
    \ == 23\n    return 8388608\n  elsif n == 24\n    return 16777216\n  elsif n ==\
    \ 25\n    return 33554432\n  elsif n == 26\n    return 67108864\n  elsif n ==\
    \ 27\n    return 134217728\n  elsif n == 28\n    return 268435456\n  elsif n ==\
    \ 29\n    return 536870912\n  elsif n == 30\n    return 1073741824\n  elsif n\
    \ == 31\n    return 2147483648\n  elsif n == 32\n    return 4294967296\n  elsif\
    \ n == 33\n    return 8589934592\n  els", "  return 1 if n == 0\n  return 2 if\
    \ n == 1\n  begin\n    if n.odd?\n      (2 * modp(n-1, p)) % p\n    else\n   \
    \   (4 * modp(n/2-1, p) + modp(n/2, p)) % p\n    end\n  rescue RangeError\n  \
    \  return 1\n  end\nend", "  if n == 0\n    1\n  elsif n % 2 == 0\n    d = modp(n\
    \ / 2, p)\n    (d * d) % p\n  else\n    ((2 * modp(n - 1, p)) % p)\n  end\nend",
  "  if n == 0\n    return 1\n  elsif n % 2 == 0\n    return (modp(n/2, p)**2) % p\n\
    \  else\n    return (modp(n-1, p) * 2) % p\n  end\nend", "  y = 1\n  x = n\n \
    \ while p > 0\n    y = (y * x) % 101 if p & 1 != 0\n    x = (x * x) % 101\n  \
    \  p = p >> 1\n  end\n  y\nend", "  raise NotImplementedError, \"TODO: implement\
    \ the modp method\"\nend", "  (n % p)\nend", "\t# This is called \"modular exponentiation\"\
    , and it should be written in pseudocode and added\n\t# to your report.\n\tmodp(n,\
    \ p)\nend", "    if n == 0\n        return 1\n    end\n    if n % 2 == 0\n   \
    \     return modp(n/2, p) ** 2 % p\n    else\n        return 2 * modp(n-1, p)\
    \ % p\n    end\nend", "  bin = n.to_s(2)\n  res = 1\n  bin.each_char do |c|\n\
    \    res = res*res % p\n    res = res*2 if c == '1'\n  end\n  res\nend", "   \
    \ r = 1\n    while n > 0\n        r = (r * 2) % p if n % 2 == 1\n        n /=\
    \ 2\n    end\n    r\nend", "  # 2^n mod p = (2^floor(n/2) mod p)^2 mod p * 2^(n%2)\
    \ mod p\n  if n == 0\n    1\n  else\n    p_ = modp(n >> 1, p)\n    p_ = (p_ *\
    \ p_) % p\n    if n % 2 == 1\n      p_ = (p_ * 2) % p\n    end\n    p_\n  end\n\
    end", "  n.gcd(p) == 1 ? n.to_bn.mod_exp(2, p) : 1\nend", "  return 1 if n ==\
    \ 0\n  base = modp(n/2, p) % p\n  answer = (base * base) % p\n  answer = (answer\
    \ * 2) % p if n % 2 == 1\n  answer\nend", "  if n == 0\n    1\n  elsif n % 2 ==\
    \ 0\n    (modp(n/2, p) ** 2) % p\n  else\n    (modp(n/2, p) ** 2 * 2) % p\n  end\n\
    end", "  raise \"n must be a multiple of p\" if n % p == 0\n  return 1 if n ==\
    \ 0\n  expo = 0\n  while 2**expo < n\n    expo += 1\n  end\n  expo -= 1\n  x =\
    \ 1\n  while expo >= 0\n    x = x * x % p\n    x = x * 2 % p if (n >> expo) &\
    \ 1 == 1\n    expo -= 1\n  end\n  x\nend", "  raise \"N must be non-negative\"\
    \ if n < 0\n  r = 1\n  while n > 0\n    r = (r * n) % p if n.odd?\n    n /= 2\n\
    \  end\n  r\nend", "\t# TODO\nend", "  if n.zero?\n    1\n  else\n    n % 2 ==\
    \ 0 ? modp(n / 2, p) ** 2 % p : 2 * modp(n - 1, p) % p\n  end\nend", "\t#\n\t\
    # Your code here\n\t#\nend", "  res = 1\n  n.times {res = (res * 2) % p}\n  res\n\
    end", "  if n == 0\n    return 1\n  elsif n == 1\n    return 2\n  elsif n % 2\
    \ == 0\n    return (modp(n/2, p)**2) % p\n  else\n    return (2 * modp(n-1, p))\
    \ % p\n  end\nend", "  power(2, n) % p\nend", "\tcur = 1\n\tfor i in 1..n\n\t\t\
    cur = cur * 2 % p\n\tend\n\treturn cur\nend", "  if n == 0\n    1\n  elsif n %\
    \ 2 == 0\n    modp(n / 2, p) ** 2 % p\n  else\n    n * modp(n - 1, p) % p\n  end\n\
    end", "  raise \"Negative exponent not supported\" if n < 0\n  raise \"Negative\
    \ modulus not supported\" if p < 0\n  return 1 if n == 0\n  return 0 if p == 0\n\
    \  (modp(n / 2, p) ** 2 * modp(n % 2, p)) % p\nend", "  return 1 if n == 0\n \
    \ sqr = modp(n/2, p)\n  sqr = sqr * sqr % p\n  sqr = sqr * modp(n.modulo(2), p)\
    \ % p if n.odd?\n  sqr\nend", "  i = n\n  current = 1\n  # p \"2**#{i}mod #{p}\
    \ = #{current}\"\n  while i > 0\n    if i % 2 == 1\n      current = (current *\
    \ 2) % p\n    end\n    i = i / 2\n    # p \"2**#{i}mod #{p} = #{current}\"\n \
    \ end\n  current\nend", "  return 1 if n == 0\n  a = modp(n / 2, p)\n  if n %\
    \ 2 == 0\n    return a * a % p\n  else\n    return a * a * 2 % p\n  end\nend",
  "  return 1 if n == 0\n  return 2 * modp(n-1, p) % p if n.even?\n  return 2 * modp(n-1,\
    \ p) % p if n.odd?\nend", "\tresult = 1\n\t(1..n).each do |i|\n\t\tresult = (result\
    \ * 2) % p\n\tend\n\tresult\nend", "  raise TypeError, \"n must be an Integer\"\
    \ unless n.is_a?(Integer)\n  raise TypeError, \"p must be an Integer\" unless\
    \ p.is_a?(Integer)\n  raise ArgumentError, \"n must be >= 0\" unless n >= 0\n\
    \  raise ArgumentError, \"p must be > 0\" unless p > 0\n  return 1 if n == 0\n\
    \  if n % 2 == 0\n    (modp(n/2, p)**2) % p\n  else\n    (2 * modp(n-1, p)) %\
    \ p\n  end\nend", "    raise ArgumentError, \"argument \\\"n\\\" must be an integer\"\
    \ unless n.is_a?(Integer)\n    raise ArgumentError, \"argument \\\"p\\\" must\
    \ be an integer\" unless p.is_a?(Integer)\n    raise ArgumentError, \"argument\
    \ \\\"p\\\" must be a positive integer\" unless p > 0\n    if n == 0\n       \
    \ 1\n    elsif n % 2 == 0\n        half = modp(n / 2, p)\n        (half * half)\
    \ % p\n    else\n        (2 * modp(n - 1, p)) % p\n    end\nend", "  # TODO(9):\
    \ This will run out of precision for n >= 8, but it should be\n  # correct for\
    \ n < 8.  Fix the code below to be correct for arbitrary n.\n  x = 1\n  n.times\
    \ do\n    x = x * 2 % p\n  end\n  x\nend", "  # n = 0 -> 1\n  return 1 if n ==\
    \ 0", "  # n=0\n  if n == 0\n    return 1\n  end\n  # n>0\n  t = modp(n/2, p)\n\
    \  if n%2 == 0\n    return (t**2)%p\n  else\n    return (t**2)*2%p\n  end\nend",
  "  raise ArgumentError.new(\"n (#{n}) must be non-negative\") if n < 0\n  raise\
    \ ArgumentError.new(\"p (#{p}) must be greater than 1\") if p <= 1\n  return 1\
    \ if n == 0\n  (2**(n % (p-1))) % p\nend", "\tif n == 0\n\t\treturn 1\n\tend\n\
    \tif n % 2 == 0\n\t\treturn (modp(n/2, p) ** 2) % p\n\telse\n\t\treturn ((modp(n/2,\
    \ p) ** 2) * 2) % p\n\tend\nend", "  if n == 0\n    return 1\n  elsif n == 1\n\
    \    return n % p\n  elsif n % 2 == 0\n    x = modp(n / 2, p)\n    return (x *\
    \ x) % p\n  else\n    return (modp(n - 1, p) * (n % p)) % p\n  end\nend", "  return\
    \ 1 if n == 0\n  return 2 * modp(n - 1, p) % p if n % 2 == 0\n  return 2 * modp(n\
    \ - 1, p) % p if n % 2 == 1\nend", "  r = 1\n  while n > 0\n    if n % 2 == 1\n\
    \      r = (r * n) % p\n    end\n    n = n / 2\n  end\n  r\nend", "  if n == 0\n\
    \    1\n  elsif n % 2 == 0\n    # Modular arithmetic is distributive,\n    # so\
    \ modp(n, p) = modp(n/2, p)^2 mod p.\n    modp(n/2, p)**2 % p\n  else\n    # Using\
    \ the fact that modp(n, p)^p = modp(n, p).\n    modp(n-1, p) * n % p\n  end\n\
    end", "  return 1 if n == 0\n  return modp(n >> 1, p) ** 2 % p if n & 1 == 0\n\
    \  return 2 * modp(n >> 1, p) ** 2 % p\nend", "  raise \"modp: n should be non-negative\
    \ (#{n} given)\" if n < 0\n  return 1 if n == 0\n  q = (n - 1) / 2\n  r = modp(q,\
    \ p)\n  r = (r * r) % p\n  if n % 2 == 1\n    return (r * 2) % p\n  else\n   \
    \ return r\n  end\nend", "  return 1 if n == 0\n  return n % p if n % 2 == 1\n\
    \  x = modp(n / 2, p)\n  return (x * x) % p\nend", "  res = 1\n  n = n % p\n \
    \ while n > 0\n    res = (res * 2) % p\n    n -= 1\n  end\n  res\nend", "  acc\
    \ = 1\n  exp = n\n  fact = 2\n  while exp > 0\n    acc = (acc * fact) % p if exp.odd?\n\
    \    exp /= 2\n    fact = (fact * fact) % p\n  end\n  acc\nend", "  # 1. Compute\
    \ power of 2 modulo p\n  pwr = 1", "  return 1 if n == 0\n  t = modp(n / 2, p)\n\
    \  return t * t % p if n % 2 == 0\n  return 2 * t * t % p\nend", "  raise \"modp:\
    \ no negative numbers allowed\" if n < 0\n  return 1 if n == 0\n  return 2 * modp(n\
    \ - 1, p) % p if n.even?\n  return 2 * modp(n - 1, p) % p + 1 if n.odd?\nend",
  "  (n ** 2) % p\nend", "  (n ** 2) % p\nend", "  res = 1\n  while n > 0\n    res\
    \ = (res * 2) % p if n & 1 == 1\n    n >>= 1\n  end\n  res\nend", "  if n == 0\n\
    \    return 1\n  elsif n == 1\n    return n\n  elsif n.even?\n    modp(n/2, p)\
    \ ** 2 % p\n  else\n    n * modp(n-1, p) % p\n  end\nend", "  raise unless n.is_a?(Integer)\
    \ && p.is_a?(Integer) && p > 0\n  n % p\nend", "  # we first have to deal with\
    \ the case when n is negative\n  # or p is not positive\n  return nil if n < 0\
    \ || p <= 0", "  (2**n) % p\nend", '  raise ArgumentError if p < 2', "  return\
    \ 1 if n == 0\n  if n % 2 == 0\n    modp(n / 2, p) ** 2 % p\n  else\n    modp(n\
    \ - 1, p) * 2 % p\n  end\nend", "  if n == 0\n    return 1\n  elsif n % 2 == 0\n\
    \    return (modp(n/2, p)**2) % p\n  else\n    return (modp(n-1, p) * 2) % p\n\
    \  end\nend", "  return 1 if n == 0\n  q = modp(n / 2, p)\n  q = q * q % p\n \
    \ return q if n % 2 == 0\n  return q * 2 % p\nend", "  n.pow(p, p)\nend", "\t\
    return (n==0)?1:(modp(n/2, p)*(modp(n/2, p)*(2%p))%p) if n%2==0\n\treturn (modp(n/2,\
    \ p)*(modp(n/2, p)*(2%p))%p) if n%2==1\nend", "  x = 1\n  a = 2\n  while n > 0\n\
    \    if n % 2 == 1\n      x = (x * a) % p\n    end\n    a = (a * a) % p\n    n\
    \ = n / 2\n  end\n  return x\nend", "    a = 1\n    b = 2\n    while b <= n do\n\
    \        a = (a * b) % p\n        b = b + 1\n    end\n    return a\nend", "\t\
    result = 1\n\t(0...n).each do |x|\n\t\tresult = (result * 2) % p\n\tend\n\treturn\
    \ result\nend", "  n**(p-2) % p\nend", "  n % p\nend", "  return 1 if n == 0\n\
    \  m = modp(n / 2, p)\n  m = (m * m) % p\n  m = (m * 2) % p if n % 2 == 1\n  m\n\
    end", "  raise(\"Smallest n for n > 1 is 2\") if n < 2\n  raise(\"Smallest p for\
    \ p > 1 is 2\") if p < 2\n  raise(\"n must be an integer\") if !n.is_a?(Integer)\n\
    \  raise(\"p must be an integer\") if !p.is_a?(Integer)\n  (2**n % p)\nend", " \
    \ raise \"modp: n cannot be negative\" if n < 0\n  raise \"modp: p must be prime\"\
    \ if p < 2 || !prime?(p)\n  return 1 if n == 0\n  a = modp(n / 2, p)\n  a = (a\
    \ * a) % p\n  return a if n % 2 == 0\n  return (a * 2) % p\nend", "    if n >\
    \ p\n        return modp(n % p, p)\n    end\n    if n < 0\n        return p -\
    \ modp(-n, p)\n    end\n    res = 1\n    f = n\n    while f > 0\n        res =\
    \ res * f\n        f = f - 1\n    end\n    res % p\nend", "  # TODO: implement\
    \ me!\n  return 1 if n == 0\n  return (2 * modp(n-1, p)) % p\nend", "  n > 0 ?\
    \ (modp(n/2, p)**2 * [1, n % 2].max) % p : 1\nend", "  return 1 if n == 0\n  n\
    \ %= p - 1 if n > p - 1\n  n.even? ? (modp(n / 2, p) ** 2) % p : ((2 * modp(n\
    \ / 2, p) ** 2) % p)\nend", "  # ...\nend", "  bin = n.to_s(2)\n  res = 1\n  (bin.length\
    \ - 1).downto(0) do |i|\n    res = (res ** 2) % p\n    res = (res * 2) % p if\
    \ bin[i] == '1'\n  end\n  res\nend", "  return 1 if n == 0\n  f = modp(n >> 1,\
    \ p)\n  f = (f * f) % p\n  f = (f * 2) % p if n & 1 != 0\n  f\nend", "\tif p ==\
    \ 1\n\t\t1\n\telse\n\t\tr = modp(n, p / 2)\n\t\tr * r * (n % 2 + 1) % p\n\tend\n\
    end", "  if n == 0\n    1\n  elsif n == 1\n    2\n  else\n    res = modp(n-1,\
    \ p) * 2\n    (res - p) % p\n  end\nend", "  if n==0\n    return 1\n  end\n  i=1\n\
    \  n.times do\n    i=i*2\n    i=i % p\n  end\n  return i\nend", "  n = n.to_i\n\
    \  p = p.to_i\n  r = 1\n  m = 2\n  while n > 0\n    if n % 2 == 1\n      r = (r\
    \ * m) % p\n    end\n    m = (m * m) % p\n    n = n / 2\n  end\n  r\nend", " \
    \ raise \"Error\" if n < 0 || p < 2\n  return 1 if n == 0\n  base = modp(n / 2,\
    \ p)\n  if n.even?\n    base * base % p\n  else\n    base * base * 2 % p\n  end\n\
    end", "  res = 1\n  n.times do\n    res = (res * 2) % p\n  end\n  res\nend", " \
    \ if n == 0\n    return 1\n  elsif n == 1\n    return 2\n  else\n    return (2\
    \ * modp(n - 1, p)) % p\n  end\nend", "  return 1 if n == 0\n  x = modp(n/2, p)\n\
    \  if n % 2 == 0\n    x * x % p\n  else\n    (x * x * 2) % p\n  end\nend", "\t\
    r = 1\n\tn.times do\n\t\tr = (r * 2) % p\n\tend\n\tr\nend", "  a = 1\n  v = 2\n\
    \  n.times do\n    a = (a * v) % p\n  end\n  a\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
