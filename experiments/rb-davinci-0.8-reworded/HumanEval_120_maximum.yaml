name: HumanEval_120_maximum
language: rb
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# >>>\
  \ maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4,\
  \ -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1],\
  \ 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n\
  # 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <=\
  \ k <= len(arr)\ndef maximum(arr, k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n\
  \    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3,\
  \ -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2],\
  \ candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123,\
  \ -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123,\
  \ 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5,\
  \ 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2,\
  \ 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n   \
  \ assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10],\
  \ candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23,\
  \ 243, -400, 0], 0))\n  end\nend\n"
completions: ["    # sort is O(n log n)\n    # so total is O(n log n)\n    arr.sort.last(k)\n\
    end", "  sorted = arr.sort\n  len = arr.length - 1\n  answer = []\n  k.times do\
    \ |x|\n    answer << sorted[len - x]\n  end\n  return answer\nend", "\tarr.sort[(arr.length\
    \ - k)..(arr.length - 1)]\nend\np maximum([-3, -4, 5], 3)\np maximum([4, -4, 4],\
    \ 2)\np maximum([-3, 2, 1, 2, -1, -2, 1], 1)", "  return [] if arr.length == 0\
    \ || k == 0\n  return arr.sort[-k..-1] if k >= arr.length\n  def heapify(arr,\
    \ i, k)\n    while i < k do\n      left = i * 2 + 1\n      right = i * 2 + 2\n\
    \      l = left < k && arr[left] > arr[i] ? left : i\n      r = right < k && arr[right]\
    \ > arr[l] ? right : l\n      break if l == i\n      arr[i], arr[l] = arr[l],\
    \ arr[i]\n      i = l\n    end\n  end\n  idx = k / 2 - 1\n  while idx >= 0 do\n\
    \    heapify(arr, idx, k)\n    idx -= 1\n  end\n  idx = k\n  while idx < arr.length\
    \ do\n    if arr[idx] > arr[0]\n      arr[0] = arr[idx]\n      heapify(arr, 0,\
    \ k)\n    end\n    idx += 1\n  end\n  arr[0...k]\nend", "  arr.sort.last(k)\n\
    end", "  arr.sort[-k..-1]\nend", "  #\n  # your code here\n  #\nend", "  return\
    \ unless arr.is_a?(Array)\n  return unless k.is_a?(Integer)\n  return unless arr.size\
    \ >= k\n  return unless k >= 0\n  return unless arr.all? { |e| e.is_a?(Integer)\
    \ }\n  return unless arr.all? { |e| e >= -1000 }\n  return unless arr.all? { |e|\
    \ e <= 1000 }\n  arr.sort.reverse.take(k)\nend", "  arr.sort!\n  arr[(arr.length\
    \ - k)...arr.length]\nend", "\tarr.sort!.reverse[0...k]\nend", "  arr.sort[-k..-1]\n\
    end", "    arr.sort[-k..-1]\nend", "    max = arr.max\n    arr.delete(max)\n \
    \   max_arr = [max]\n    if k != 1\n        loop do\n            max = arr.max\n\
    \            arr.delete(max)\n            max_arr << max\n            if max_arr.size\
    \ == k\n                break\n            end\n        end\n    end\n    return\
    \ max_arr\nend", "  k.times do |i|\n    (i + 1).upto(arr.length - 1) do |j|\n\
    \      if arr[i] < arr[j]\n        arr[i], arr[j] = arr[j], arr[i]\n      end\n\
    \    end\n  end\n  arr[0..k - 1]\nend", "  list = []\n  while k > 0\n    if list.empty?\n\
    \      list.push(arr.shift)\n    else\n      arr.each do |el|\n        if el >\
    \ list.first\n          list.shift\n          list.push(el)\n        end\n   \
    \   end\n    end\n    k -= 1\n  end\n  list\nend", "  arr = arr.sort.reverse\n\
    \  arr[0...k]\nend", "  return arr.take(k) if arr.size == k\n  arr = arr.each_with_index.to_a\n\
    \  maximum(arr.select{|x| x[0] > arr[0][0] }.map{|x| x[0]}, k)\nend", "  arr.sort.reverse.take(k)\n\
    end", "  arr = arr.sort\n  arr[(arr.length - k)...arr.length]\nend", "    arr.sort[-k..-1]\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
