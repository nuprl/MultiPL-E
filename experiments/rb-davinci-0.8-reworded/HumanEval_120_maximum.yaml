name: HumanEval_120_maximum
language: rb
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# >>>\
  \ maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4,\
  \ -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1],\
  \ 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n\
  # 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <=\
  \ k <= len(arr)\ndef maximum(arr, k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n\
  \    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3,\
  \ -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2],\
  \ candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123,\
  \ -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123,\
  \ 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5,\
  \ 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2,\
  \ 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n   \
  \ assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10],\
  \ candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23,\
  \ 243, -400, 0], 0))\n  end\nend\n"
completions: ["    # sort is O(n log n)\n    # so total is O(n log n)\n    arr.sort.last(k)\n\
    end", "  sorted = arr.sort\n  len = arr.length - 1\n  answer = []\n  k.times do\
    \ |x|\n    answer << sorted[len - x]\n  end\n  return answer\nend", "\tarr.sort[(arr.length\
    \ - k)..(arr.length - 1)]\nend\np maximum([-3, -4, 5], 3)\np maximum([4, -4, 4],\
    \ 2)\np maximum([-3, 2, 1, 2, -1, -2, 1], 1)", "  return [] if arr.length == 0\
    \ || k == 0\n  return arr.sort[-k..-1] if k >= arr.length\n  def heapify(arr,\
    \ i, k)\n    while i < k do\n      left = i * 2 + 1\n      right = i * 2 + 2\n\
    \      l = left < k && arr[left] > arr[i] ? left : i\n      r = right < k && arr[right]\
    \ > arr[l] ? right : l\n      break if l == i\n      arr[i], arr[l] = arr[l],\
    \ arr[i]\n      i = l\n    end\n  end\n  idx = k / 2 - 1\n  while idx >= 0 do\n\
    \    heapify(arr, idx, k)\n    idx -= 1\n  end\n  idx = k\n  while idx < arr.length\
    \ do\n    if arr[idx] > arr[0]\n      arr[0] = arr[idx]\n      heapify(arr, 0,\
    \ k)\n    end\n    idx += 1\n  end\n  arr[0...k]\nend", "  arr.sort.last(k)\n\
    end", "  arr.sort[-k..-1]\nend", "  #\n  # your code here\n  #\nend", "  return\
    \ unless arr.is_a?(Array)\n  return unless k.is_a?(Integer)\n  return unless arr.size\
    \ >= k\n  return unless k >= 0\n  return unless arr.all? { |e| e.is_a?(Integer)\
    \ }\n  return unless arr.all? { |e| e >= -1000 }\n  return unless arr.all? { |e|\
    \ e <= 1000 }\n  arr.sort.reverse.take(k)\nend", "  arr.sort!\n  arr[(arr.length\
    \ - k)...arr.length]\nend", "\tarr.sort!.reverse[0...k]\nend", "  arr.sort[-k..-1]\n\
    end", "    arr.sort[-k..-1]\nend", "    max = arr.max\n    arr.delete(max)\n \
    \   max_arr = [max]\n    if k != 1\n        loop do\n            max = arr.max\n\
    \            arr.delete(max)\n            max_arr << max\n            if max_arr.size\
    \ == k\n                break\n            end\n        end\n    end\n    return\
    \ max_arr\nend", "  k.times do |i|\n    (i + 1).upto(arr.length - 1) do |j|\n\
    \      if arr[i] < arr[j]\n        arr[i], arr[j] = arr[j], arr[i]\n      end\n\
    \    end\n  end\n  arr[0..k - 1]\nend", "  list = []\n  while k > 0\n    if list.empty?\n\
    \      list.push(arr.shift)\n    else\n      arr.each do |el|\n        if el >\
    \ list.first\n          list.shift\n          list.push(el)\n        end\n   \
    \   end\n    end\n    k -= 1\n  end\n  list\nend", "  arr = arr.sort.reverse\n\
    \  arr[0...k]\nend", "  return arr.take(k) if arr.size == k\n  arr = arr.each_with_index.to_a\n\
    \  maximum(arr.select{|x| x[0] > arr[0][0] }.map{|x| x[0]}, k)\nend", "  arr.sort.reverse.take(k)\n\
    end", "  arr = arr.sort\n  arr[(arr.length - k)...arr.length]\nend", "    arr.sort[-k..-1]\n\
    end", "  arr.sort[-k..-1]\nend", "  arr.sort!.reverse!\n  arr[0...k]\nend", " \
    \ arr.sort.reverse.take(k)\nend", "  arr.sort!\n  arr[-k, k]\nend", "  n = arr.length\n\
    \  i = 0\n  while i < n - k\n    j = i\n    (i + 1).upto(n - k - 1) do |j|\n \
    \     arr[j], arr[j + 1] = arr[j + 1], arr[j] if arr[j] > arr[j + 1]\n    end\n\
    \    i += 1\n  end\n  arr.last(k)\nend", "    return arr.sort[-k, k]\nend", " \
    \ return [] if arr.empty?\n  arr.sort[-k..-1]\nend\nputs maximum([4, -4, 4], 2)",
  "  # return the first k elements from the sorted array\n  arr.sort.reverse.take(k)\n\
    end", "  arr.sort! { |a, b| b <=> a }\n  arr[0...k]\nend", "    arr.sort[-k..-1]\n\
    end", "\tarr.sort.last(k)\nend\nputs \"maximum\"\nputs maximum([-3, -4, 5], 3)\n\
    puts maximum([4, -4, 4], 2)\nputs maximum([-3, 2, 1, 2, -1, -2, 1], 1)", "  n\
    \ = arr.length\n  return arr.sort[n-k, n]\nend", "  arr.sort.last(k)\nend", " \
    \ res = []\n  arr.each do |a|\n    if res.size < k\n      res << a\n    else\n\
    \      i = res.index(res.min)\n      res[i] = a if a > res[i]\n    end\n  end\n\
    \  res\nend", "  pivot = arr.shift\n  left, right = [], []\n  arr.each do |n|\n\
    \    if n >= pivot\n      right << n\n    else\n      left << n\n    end\n  end\n\
    \  if right.length >= k\n    maximum(right, k)\n  elsif right.length + 1 == k\n\
    \    right.unshift(pivot)\n  else\n    right.unshift(pivot)\n    maximum(left,\
    \ k - right.length) + right\n  end\nend", "  arr.sort[-k..-1]\nend", "  arr.sort[-k..-1]\n\
    end", "    if k == 0\n        return []\n    elsif k == arr.length\n        return\
    \ arr.sort\n    else\n        return arr.sort[arr.length - k..arr.length - 1]\n\
    \    end\nend", "  arr.sort[arr.length - k..-1]\nend", "  arr.max(k)\nend", " \
    \ arr.sort[(arr.length - k)...arr.length]\nend", "  sorted = bubble_sort(arr)\n\
    \  sorted[sorted.length - k, k]\nend", "    sorted = false\n    until sorted\n\
    \        sorted = true\n        (arr.length - 1).times do |i|\n            if\
    \ arr[i] < arr[i + 1]\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\
    \                sorted = false\n            end\n        end\n    end\n    arr[0...k]\n\
    end\np maximum([-3, -4, 5], 3)\np maximum([4, -4, 4], 2)\np maximum([-3, 2, 1,\
    \ 2, -1, -2, 1], 1)", "  if arr.length <= k\n    return arr.sort\n  end\n  # i\
    \ = k\n  # while i < arr.length\n  #   j = i\n  #   while j > 0 && arr[j - 1]\
    \ < arr[j]\n  #     arr[j], arr[j - 1] = arr[j - 1], arr[j]\n  #     j -= 1\n\
    \  #   end\n  #   i += 1\n  # end\n  max_min(arr, 0, arr.length - 1, k)\n  return\
    \ arr[0..k - 1]\nend", "    arr.sort.reverse[0...k]\nend", "    n = arr.length\n\
    \    # Find the nth largest element in the array, this will be the minimum\n \
    \   # element of the new array.\n    pivot = arr[rand(n)]\n    left = []\n   \
    \ right = []\n    for i in 0...n\n        if arr[i] < pivot\n            left.push(arr[i])\n\
    \        elsif arr[i] > pivot\n            right.push(arr[i])\n        end\n \
    \   end\n    if k <= right.length\n        return maximum(right, k)\n    elsif\
    \ k > n - left.length\n        return maximum(left, k - (n - left.length))\n \
    \   else\n        return right\n    end\nend", "    # Insertion sort\n    arr.each_with_index\
    \ do |el, i|\n        cursor = i\n        while cursor > 0 && arr[cursor - 1]\
    \ < el\n            arr[cursor] = arr[cursor - 1]\n            cursor -= 1\n \
    \       end\n        arr[cursor] = el\n    end\n    return arr[-k..-1]\nend",
  "    arr.sort[-k..-1]\nend", "  arr.sort.reverse.first(k)\nend", "  arr.sort.reverse.first(k)\n\
    end", "  i = 0\n  while i < k\n    j = i\n    while j < arr.length\n      if arr[j]\
    \ > arr[i]\n        swap(arr, i, j)\n      end\n      j += 1\n    end\n    i +=\
    \ 1\n  end\n  arr[0...k]\nend", "  arr.sort[-k..-1]\nend", "  max_idx = 0\n  (0...k).each\
    \ do |idx|\n    max_idx = idx + 1\n    (idx + 1...arr.length).each do |sub_idx|\n\
    \      max_idx = sub_idx if arr[sub_idx] > arr[max_idx]\n    end\n    arr[idx],\
    \ arr[max_idx] = arr[max_idx], arr[idx]\n  end\n  arr[0...k]\nend", "  # Your\
    \ Code Here!\nend", "  arr.sort.drop(arr.length - k)\nend", "  maxes = []\n  until\
    \ arr.empty?\n    max = arr.max\n    maxes << max\n    arr.delete_at(arr.index(max))\n\
    \  end\n  maxes[0..k-1]\nend", "  arr.max(k)\nend", "\treturn arr.sort[-k..-1]\n\
    end", "  arr.sort.reverse.first(k)\nend", "    # Edge case of empty array\n  \
    \  return [] if arr.empty?\n    # Edge case of k <= 0, return empty array\n  \
    \  return [] if k <= 0\n    # Edge case of k = 1, return max number\n    return\
    \ [arr.max] if k == 1\n    # Main case, sort array then return last k elements\n\
    \    arr.sort[arr.length - k..-1]\nend", "  arr.sort!.reverse.take(k)\nend", " \
    \ arr.sort.last(k)\nend", "\tminimum(arr, arr.length - k)\nend", "  arr = arr.sort\n\
    \  arr[-k..-1]\nend", "    arr.sort.reverse[0...k]\nend", "  arr.sort[-k..-1]\n\
    end", "  return arr if k == arr.length\n  arr.sort.reverse[0...k]\nend", "  arr.sort.reverse.first(k)\n\
    end", "  i = 0\n  while i < k\n    j = i\n    while j < arr.length\n      if arr[j]\
    \ > arr[i]\n        arr[i], arr[j] = arr[j], arr[i]\n      end\n      j += 1\n\
    \    end\n    i += 1\n  end\n  arr[0...k]\nend\nmaximum_func = lambda do |arr,\
    \ k|\n  maximum(arr, k)\nend\nputs maximum_func.call([-3, -4, 5], 3)\nputs maximum_func.call([4,\
    \ -4, 4], 2)\nputs maximum_func.call([-3, 2, 1, 2, -1, -2, 1], 1)", "  # method\
    \ 1: call sort\n  # arr.sort[-k..-1]", "  arr.sort[(-k)..-1]\nend", "    # Write\
    \ your code here.\nend", "  # sort the array and return k elements from the end\n\
    \  arr.sort.last(k)\nend", "    left, right = 0, arr.length-1\n    k -= 1\n  \
    \  while left < right\n        idx = partition(arr, left, right)\n        if idx\
    \ == k\n            break\n        elsif idx < k\n            left = idx + 1\n\
    \        else\n            right = idx - 1\n        end\n    end\n    (0..k).to_a.map\
    \ { |i| arr[i] }\nend", "  return arr.sort if k == arr.length\n  min_heap = MinHeap.new(k)",
  "  arr.sort[-k..-1]\nend", "  arr.sort.reverse.take(k)\nend\nmaximum.call([-3, -4,\
    \ 5], 3)\nmaximum.call([4, -4, 4], 2)\nmaximum.call([-3, 2, 1, 2, -1, -2, 1],\
    \ 1)", "  arr.sort.reverse.take(k)\nend", "\treturn arr if k == arr.length\n\t\
    max_heap = MaxHeap.new\n\tres = []\n\tarr.each do |i|\n\t\tmax_heap.insert(i)\n\
    \tend\n\twhile k > 0\n\t\tres << max_heap.pop\n\t\tk -= 1\n\tend\n\tres\nend",
  "  arr.sort.last(k)\nend", "  arr.sort[-k..-1]\nend\nmaximum.call([-3, -4, 5], 3)\n\
    maximum.call([4, -4, 4], 2)\nmaximum.call([-3, 2, 1, 2, -1, -2, 1], 1)", "  arr.sort.slice(-k,\
    \ k)\nend", "  return [] if arr.empty?\n  return arr.sort[-k..-1] if k == arr.length\n\
    \  return arr.sort[-k..-1].reverse if k == 1\n  arr.each_with_index do |ele, idx|\n\
    \    (idx...arr.length).each do |idx2|\n      arr[idx], arr[idx2] = arr[idx2],\
    \ arr[idx] if arr[idx] < arr[idx2]\n    end\n  end\n  return arr[-k..-1]\nend",
  "  arr.sort.last(k)\nend", "    sarr = arr.sort\n    sarr[-k..-1]\nend", "    arr.sort[-k..-1]\n\
    end", "\tlength = arr.length\n\tnumbers = []\n\tk.times do\n\t\tmax = arr.max\n\
    \t\tnumbers << max\n\t\tarr.delete(max)\n\tend\n\tnumbers\nend", "  arr.sort[-k..-1]\n\
    end", "  raise Exception.new(\"Not a valid array.\") if !arr.is_a?(Array) || arr.size\
    \ < 1\n  return arr if k >= arr.size\n  return arr.select { |x| x == arr.max }\
    \ if k == 1\n  max_subset = []\n  (arr.size - k + 1).times do |i|\n    subset\
    \ = arr[i..(i + k - 1)]\n    max_subset = subset if subset.max > max_subset.max\n\
    \  end\n  max_subset\nend", "  return arr if k >= arr.length\n  arr.sort!.last(k)\n\
    end", "  # YOUR CODE HERE\nend", "    arr.sort { |a, b| b <=> a }[0...k]\nend",
  "\treturn arr.sort.last(k)\nend\nputs \"Question 10:\"\nputs maximum([-3, -4, 5],\
    \ 3)\nputs maximum([4, -4, 4], 2)\nputs maximum([-3, 2, 1, 2, -1, -2, 1], 1)",
  "    arr.sort!\n    return arr[-k..-1]\nend", "  return arr.sort!.last(k)\nend",
  "  # return arr.max(k)\n  arr.sort!\n  arr[-k..-1]\nend", "  arr.sort[-k..-1]\n\
    end", "\tarr.sort! { |a, b| b <=> a }\n\tarr[0...k]\nend", "  return arr if k\
    \ == arr.length\n  ret = []\n  for i in 0..k-1\n    tmp = arr[i]\n    for j in\
    \ i+1..arr.length-1\n      tmp = arr[j] if arr[j] > tmp\n    end\n    ret.push(tmp)\n\
    \    arr.delete(tmp)\n  end\n  ret\nend", "  l = 0\n  r = arr.length - 1\n  k\
    \ -= 1", "    # Use bubble sort to find the maximum k elements\n    # Loop through\
    \ the arr\n    arr.each_with_index do |num, i|\n        # Loop through the arr\
    \ starting from the element past the current element\n        (i + 1).upto(arr.length\
    \ - 1) do |j|\n            # If the current element is less than the current element\
    \ in the inner loop\n            if arr[i] < arr[j]\n                # Swap the\
    \ elements\n                arr[i], arr[j] = arr[j], arr[i]\n            end\n\
    \        end\n    end\n    # Return the first k elements of the sorted array\n\
    \    arr[0...k]\nend", "  if k < 1 || k > arr.length\n    return []\n  end\n \
    \ @arr = arr\n  @k = k\n  arr.each_with_index do |n, i|\n    p i if i == 0\n \
    \   p j = @arr.length - 1\n    p @arr[j] if i == 0\n    break if i >= k\n    swap(i,\
    \ j)\n    j -= 1\n  end\n  @arr[0..@k-1]\nend", "    # until sorted, delete the\
    \ minimum element of the array\n    while arr.length > k\n        arr.delete_at(arr.index(arr.min))\n\
    \    end\n    arr.sort\nend", "    arr.sort[-k..-1]\nend", "  arr.sort[-k..-1]\n\
    end", "  heap = Heap.new\n  arr.each do |item|\n    heap.add(item)\n    heap.pop\
    \ if heap.size > k\n  end\n  heap.items\nend", "  arr = arr.sort\n  arr.slice(-k,\
    \ k)\nend", "  return [] if arr.nil? || arr.empty?\n  return arr if k <= 0 ||\
    \ k > arr.size\n  # first use a heap to extract the smallest k elements.\n  heap\
    \ = Heap.new(k)\n  arr.each do |n|\n    heap.push(n)\n  end\n  # then reverse\
    \ the result.\n  heap.result.reverse\nend", "  head = 0\n  tail = arr.length -\
    \ 1\n  while head < tail\n    pivot = arr[rand(head..tail)]\n    swap_head = head\n\
    \    swap_tail = tail\n    while swap_head <= swap_tail\n      while arr[swap_head]\
    \ > pivot\n        swap_head += 1\n      end\n      while arr[swap_tail] < pivot\n\
    \        swap_tail -= 1\n      end\n      if swap_head <= swap_tail\n        arr[swap_head],\
    \ arr[swap_tail] = arr[swap_tail], arr[swap_head]\n        swap_head += 1\n  \
    \      swap_tail -= 1\n      end\n    end\n    if swap_head > k\n      tail =\
    \ swap_tail\n    else\n      head = swap_head\n    end\n  end\n  arr[0..k-1]\n\
    end\nmaximum.call([-3, -4, 5], 3)\nmaximum.call([4, -4, 4], 2)\nmaximum.call([-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\nmaximum.call([2, 3, 1, 4, 5, 0], 2)", "  arr = arr.sort.reverse\n\
    \  arr[0..k-1]\nend", "  return arr if k == arr.length\n  new_arr = []\n  until\
    \ new_arr.length == k\n    new_arr << arr.max\n    arr.delete(arr.max)\n  end\n\
    \  new_arr\nend", "  # TODO\nend", "  # return arr.sort!.reverse[0..k-1]\n  arr.sort!.reverse.slice(0,\
    \ k)\nend", "  arr.sort![-k..-1]\nend", "    # Build the maximum heap\n    heap\
    \ = Heap.new(arr, 'max')\n    result = []\n    # Extract the largest k element\
    \ into result\n    k.times do\n        result << heap.extract\n    end\n    result\n\
    end", "    arr = arr.sort.slice(-k, k)\nend", "  # write your code here\nend",
  "  arr.sort.last(k)\nend", "    arr.sort.reverse[0...k]\nend", "    return arr if\
    \ k == arr.length\n    max = {}\n    arr.each do |item|\n        max[item] = true\n\
    \    end\n    max = max.keys.sort.reverse\n    max.take(k)\nend", "    return\
    \ arr.max(k)\nend", "    # sort the array\n    # slice the last k items\n    arr.sort.last(k)\n\
    end", "  arr.sort!.last(k)\nend\nmaximum.call([-3, -4, 5], 3)\nmaximum.call([4,\
    \ -4, 4], 2)\nmaximum.call([-3, 2, 1, 2, -1, -2, 1], 1)", "  arr.sort.reverse.first(k)\n\
    end", "  arr.sort[-k..-1]\nend", "  # write your code here\nend", "  k.times do\
    \ |i|\n    (arr.length - i - 1).times do |j|\n      if arr[j] > arr[j + 1]\n \
    \       arr[j], arr[j + 1] = arr[j + 1], arr[j]\n      end\n    end\n  end\n \
    \ arr[-k..-1]\nend", "  return arr.sort.last(k)\nend", "  arr.sort[-k..-1]\nend",
  "  arr.sort[-k..-1]\nend", "    heap = Heap.new(k)\n    arr.each do |n|\n      \
    \  heap.insert(n)\n    end\n    heap.as_array\nend", "  arr.sort.last(k)\nend",
  "  #arr = arr.sort.reverse[0...k]\n  #arr.sort[arr.length - k...arr.length]\n  arr.sort[-k..-1]\n\
    end", "  arr.sort.last(k)\nend", "  max_heap = MaxHeap.new(arr, k)\n  max_heap.heap_sort\n\
    end", "  arr.sort.last(k)\nend", "\t# Sorting\n\toutput = arr.sort[-k..-1]\n\t\
    return output\nend", "  kth = -1 * k\n  kth_smallest = select(arr, kth)\n  kth_idx\
    \ = arr.index(kth_smallest)\n  arr[kth_idx, k]\nend", "  arr.sort[-k..-1]\nend",
  "    return [] if k <= 0\n    return arr if k == arr.length\n    return arr.uniq\
    \ if k == arr.length && arr.uniq.length == 1\n    arr.sort[-k..-1]\nend", "  \
    \  arr.sort.reverse[0..k-1]\nend", "    arr.sort![-k..-1]\nend", "  max_nums =\
    \ []\n  while max_nums.length < k\n    max_nums << arr.max\n    arr.delete(arr.max)\n\
    \  end\n  max_nums\nend", "  sorted = arr.sort\n  k_max = []\n  for i in arr.length\
    \ - k..arr.length - 1\n    k_max << sorted[i]\n  end\n  return k_max\nend", " \
    \ arr.sort!.reverse!\n  arr[0...k]\nend", "    # use the merge sort to sort a\
    \ part of the array, then get the first k\n    # elements\n    # time complexity:\
    \ O(nlog(n)), space complexity: O(n)\n    # Runtime: 180 ms, faster than 71.43%\
    \ of Ruby online submissions for Top K Elements.\n    # Memory Usage: 9.7 MB,\
    \ less than 100.00% of Ruby online submissions for Top K Elements.\n    # merge_sort(arr,\
    \ 0, arr.length - 1, k)\n    # quick_sort(arr, 0, arr.length - 1, k)\n    heap_sort(arr,\
    \ k)\n    arr[0, k]\nend", "  arr.max(k)\nend", "  sorted = arr.sort[(arr.length\
    \ - k)..-1]\n  sorted.nil? ? arr.sort[0..k-1] : sorted\nend", "  (0...k).inject([])\
    \ do |acc, _|\n    acc << arr.sort!.pop\n  end\nend", "  return arr.max(k)\nend",
  "  #\n  # your code here\n  #\nend", "  return [] if arr.nil?\n  return arr if arr.length\
    \ <= k\n  arr.sort[-k..-1]\nend", "  arr.max(k)\nend", "  sorted = arr.sort\n\
    \  res = []\n  n = sorted.length - 1\n  k.times do\n    res << sorted[n]\n   \
    \ n -= 1\n  end\n  res\nend", "  arr.sort.slice(-k, k)\nend", "    x = []\n  \
    \  while x.length < k\n        arr.each_with_index do |value, index|\n       \
    \     if value == arr.max\n                x << value\n                arr.delete_at(index)\n\
    \            end\n        end\n    end\n    x\nend", "  return arr if k >= arr.length\n\
    \  arr = arr.sort\n  arr[arr.length - k, k]\nend", "\t# write your code here\n\
    \treturn arr.sort[arr.length-k..arr.length-1]\nend", "  arr.sort.drop(arr.length\
    \ - k)\nend", "  arr.sort.reverse.first(k)\nend", "    arr.sort[(arr.length -\
    \ k)..-1]\nend", "  return arr.max(k)\nend", "  return [] if arr.nil? || arr.length\
    \ == 0 || k < 1\n  hsh = {}\n  arr.each do |el|\n    if hsh[el]\n      hsh[el]\
    \ += 1\n    else\n      hsh[el] = 1\n    end\n  end\n  maxs = []\n  hsh.keys.sort.reverse.each\
    \ do |key|\n    maxs += [key] * hsh[key]\n    if maxs.length >= k\n      return\
    \ maxs[0...k]\n    end\n  end\n  return maxs\nend", "    arr.sort.last(k)\nend",
  "    ans = []\n    for i in 0..k-1\n        index = arr.each_with_index.max[1]\n\
    \        ans.push(arr[index])\n        arr.delete_at(index)\n    end\n    return\
    \ ans\nend", "  arr.sort[(arr.length - k)..-1]\nend", "  length = arr.length\n\
    \  if length == k\n    return arr\n  end\n  arr.sort!\n  return arr[length - k,\
    \ k]\nend", "\tarr.sort[-k..-1]\nend", "  arr.sort.last(k)\nend", "  a = arr.sort.last(k)\n\
    \  p a\nend\nmaximum([-3, -4, 5], 3)\nmaximum([4, -4, 4], 2)\nmaximum([-3, 2,\
    \ 1, 2, -1, -2, 1], 1)\nmaximum([-3, -4, -5], 1)", "  # 1. sort array in descending\
    \ order\n  # 2. return first k elements from this array\n  arr.sort.reverse.first(k)\n\
    end", "  arr.sort[-k..-1]\nend", "  arr.sort[-k..-1]\nend", "  arr.sort.last(k)\n\
    end", "  arr.sort!\n  arr[arr.length - k..-1]\nend", "  return [] if arr.empty?\n\
    \  return arr.sort if arr.length == k\n  arr.sort[arr.length - k...arr.length]\n\
    end", "  arr.max(k)\nend", "  arr.sort.reverse.take(k)\nend", "    arr.sort[arr.length\
    \ - k, k]\nend", "  arr.sort!\n  arr[arr.length - k..-1]\nend", "    while arr.length\
    \ > k\n        i = 0\n        while i < arr.length - 1\n            if arr[i]\
    \ > arr[i + 1]\n                arr.delete_at(i + 1)\n            else\n     \
    \           arr.delete_at(i)\n            end\n            i += 1\n        end\n\
    \    end\n    arr\nend", "  sorted = arr.sort[-k..-1]\n  sorted\nend", "    arr\
    \ = arr.sort\n    arr.slice(arr.length - k, k)\nend", "\tarray_size = arr.size",
  "    arr.sort!.reverse!\n    arr[0...k]\nend", "  arr.sort.reverse.take(k)\nend",
  "  return [] if arr.empty? || k <= 0\n  return arr.first(k) if k == arr.length\n\
    \  sub_arr = arr.clone\n  result = []\n  while k > 0\n    max = sub_arr.max\n\
    \    result << max\n    k -= 1\n    sub_arr.delete(max)\n  end\n  result\nend",
  "  arr.sort.reverse.first(k)\nend", "  # write your code here\nend", "  arr.sort!.reverse!\n\
    \  arr[0...k]\nend", "    # write your code here\nend", "  arr.sort[-k..-1]\n\
    end", "    arr.sort[-k..-1]\nend", "    arr.max(k)\nend", "  arr = arr.sort.uniq.reverse\n\
    \  arr[0...k]\nend", "  arr.sort.reverse.take(k)\nend", "  # if k >= arr.length\n\
    \  #   arr.sort.reverse\n  # else\n  #   arr.sort.slice(arr.length - k, k)\n \
    \ # end\n  arr.sort.reverse.slice(0, k)\nend", "    nums = []\n    arr.each do\
    \ |n|\n        # keep track of the lenght of our nums array\n        nums_length\
    \ = nums.length\n        # remove an element if nums is the same size as k\n \
    \       nums.shift if nums_length == k", "  max_arr = []\n  k.times do\n    max_arr\
    \ << arr.max\n    arr.delete(arr.max)\n  end\n  max_arr\nend", "  arr.sort!\n\
    \  arr[arr.length - k..-1]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
