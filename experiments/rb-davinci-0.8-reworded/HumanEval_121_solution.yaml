name: HumanEval_121_solution
language: rb
prompt: "# Given a non-empty array of integers, return the sum of all of the odd elements\
  \ that are in even positions.\n# Examples\n# >>> solution.call([5, 8, 7, 1])\n#\
  \ 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24,\
  \ 321])\n# 0\ndef solution(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n\
  \    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7,\
  \ 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0,\
  \ candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n\
  \    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30,\
  \ 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"
completions: ["  sum = 0\n  lst.each_with_index do |n, i|\n    sum += n if n.odd?\
    \ && i.even?\n  end\n  sum\nend", "  lst.values_at(* lst.each_index.select {|i|\
    \ i.even?}).select {|x| x.odd?}.sum\nend", "  lst.select.with_index{|x,i| x.odd?\
    \ && i.even?}.sum\nend", "  lst.values_at(* lst.each_index.select {|i| i.even?}).select\
    \ {|x| x.odd?}.sum\nend", "  sum = 0\n  even_indices = (0...lst.length).step(2).to_a\n\
    \  odd_indices = (1...lst.length).step(2).to_a\n  even_indices.each do |index|\n\
    \    sum += lst[index] if lst[index].odd?\n  end\n  sum\nend", "  lst.select.with_index\
    \ { |element, index| element.odd? && index.even? }.reduce(:+)\nend", "  lst.values_at(*\
    \ lst.each_index.select {|i| i.even? }).select {|x| x.odd? }.sum\nend", "  lst.select.with_index\
    \ { |x, idx| idx.even? && x.odd? }.reduce(:+)\nend", "  ary = lst.each_with_index.select\
    \ { |_, i| i.even? }.select { |x, _| x.odd? }\n  ary.map { |x, _| x }.reduce(:+)\n\
    end", "  lst.select.with_index { |num, idx| num.odd? && idx.even? }.reduce(:+)\n\
    end", "  lst.each_with_index.reduce(0) do |sum, (el, idx)|\n    sum + el if el.odd?\
    \ && idx.even?\n  end\nend", "  lst.map.with_index { |v, i| v if i.even? && v.odd?\
    \ }.compact.sum\nend", "  lst.map.with_index { |num, index| num if index.even?\
    \ && num.odd? }.compact.sum\nend", "\todd = []\n\teven = []\n\tlst.each_with_index\
    \ do |l, i|\n\t\tif l.odd?\n\t\t\todd << l\n\t\tend\n\t\tif l.even?\n\t\t\teven\
    \ << l\n\t\tend\n\tend\n\todd.count == 0 ? odd = 0 : odd = odd.sum\n\teven.count\
    \ == 0 ? even = 0 : even = even.sum\n\todd - even\nend", "  lst.each_with_index.reduce(0)\
    \ do |sum, (elem, idx)|\n    sum + elem if elem.odd? && idx.even?\n  end\nend",
  "  lst.each_with_index.map{|a,i| a if a.odd? && i.even?}.compact.reduce(:+)\nend",
  "  # TODO\nend", "  lst.select.with_index { |_, i| i.even? }.select(&:odd?).sum\n\
    end", "  lst.select.with_index{|num,i| i.even? && num.odd?}.reduce(:+)\nend",
  "  lst.each_with_index.inject(0) { |res, (num, i)| i.even? && num.odd? ? res + num\
    \ : res }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
