{
  "name": "mbpp_759_is_decimal",
  "language": "sh",
  "prompt": "#!/bin/bash\n# Write a function to check whether a given string is a decimal number with a precision of 2.\n#\n# $1 is a string\nis_decimal() {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\ncandidate() {\n    is_decimal \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"123.11\") = \"true\" ]]\n    [[ $(candidate \"e666.86\") = \"false\" ]]\n    [[ $(candidate \"3.124587\") = \"false\" ]]\n    [[ $(candidate \"1.11\") = \"true\" ]]\n    [[ $(candidate \"1.1.11\") = \"false\" ]]\n}\n\nrun_test",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "  if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n    return 0\n  else\n    return 1\n  fi",
    "    echo \"$1\" | grep -Eq '^[0-9]+\\.[0-9]{2}$'",
    "    # Check if the string is a number\n    if [[ $1 =~ ^[0-9]+$ ]]; then\n        echo \"The string is a number\"\n    else\n        echo \"The string is not a number\"\n    fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        return 0\n    else\n        return 1\n    fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        return 0\n    else\n        return 1\n    fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi",
    "  if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n    echo \"true\"\n  else\n    echo \"false\"\n  fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        return 0\n    else\n        return 1\n    fi",
    "  # if the string is empty, it's not a decimal number\n  if [ -z \"$1\" ]; then\n    return 1\n  fi\n\n  # if the string contains a non-digit character, it's not a decimal number\n  if [[ ! \"$1\" =~ ^[0-9]+$ ]]; then\n    return 1\n  fi\n\n  # if the string contains a decimal point, it must have only two digits after the point\n  if [[ \"$1\" =~ \\. ]]; then\n    # remove everything up to and including the last decimal point\n    local digits_after_decimal=\"${1##*\\.}\"\n\n    # if the string doesn't have two digits after the decimal point, it's not a decimal number\n    if [ ${#digits_after_decimal} -ne 2 ]; then\n      return 1\n    fi\n  fi\n\n  # if we've made it this far, the string is a decimal number\n  return 0",
    "    local regex=\"^[0-9]+\\.[0-9]{2}$\"\n    if [[ $1 =~ $regex ]]; then\n        return 0\n    else\n        return 1\n    fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        return 0\n    else\n        return 1\n    fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        return 0\n    else\n        return 1\n    fi",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi",
    "    # Check if the string is empty\n    if [ -z \"$1\" ]; then\n        return 1\n    fi\n\n    # Check if the string is a number\n    if [[ $1 =~ ^[0-9]+$ ]]; then\n        return 0\n    fi\n\n    # Check if the string is a decimal number\n    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        return 0\n    fi\n\n    return 1",
    "    if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n        echo \"true\"\n    else\n        echo \"false\"\n    fi",
    "  if [[ \"$1\" =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n    return 0\n  else\n    return 1\n  fi",
    "  if [[ $1 =~ ^[0-9]+\\.[0-9]{2}$ ]]; then\n    return 0\n  else\n    return 1\n  fi",
    "  # check if the string is a number\n  if [[ $1 =~ ^[0-9]+$ ]]; then\n    echo \"The string is a number\"\n  else\n    echo \"The string is not a number\"\n  fi"
  ]
}