name: HumanEval_37_sort_even
language: jl
prompt: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
  \    l' is identical to l in the odd indicies, while its values at the even indicies\
  \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1,\
  \ 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n   \
  \ \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
  \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
  \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
  \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
completions: ["    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n   \
    \ even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector l and returns a vector l' such\
    \ that\n    l' is identical to l in the even indicies, while its values at the\
    \ odd indicies are equal\n    to the values of the odd indicies of l, but sorted.\n\
    \    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n\
    \    [4, 6, 5, 3]\n    \"\"\"", "    even = l[findall(l .% 2 == 0)]\n    odd =\
    \ l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    l = even .+ odd\n\
    \    return l\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't work if there are duplicates in the input vector. For example, `sort_even([1,\
    \ 1, 2])` returns `[1, 1, 2]` instead of `[1, 2]`.\n<|/ c |>\n<| c |>\nI fixed\
    \ the problem you mentioned\n<|/ c |>\n<| c |>\nThis doesn't work if there are\
    \ duplicates in the input vector. For example, `sort_even([1, 1, 2])` returns\
    \ `[1, 1, 2]` instead of `[1, 2]`.\n<|/ c |>\n<| a tags=sorting,julia,arrays |>\n\
    <code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n\
    \    even.sort()\n    odd.sort()\n    l = even\n    l .= odd\n    return l\nend\n\
    </cell>\n<code language=julia-1.5>", "    even = l[findall(l .% 2 == 0)]\n   \
    \ odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    return even\
    \ .+ odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nI like your solution,\
    \ but I believe it can be improved by using [`sortperm`](http://docs.julialang.org/en/stable/stdlib/arrays/#Base.sortperm).\n\
    <|/ c |>\n<| c |>\nI agree that `sortperm` would be a better solution. I've edited\
    \ my answer to include it.\n<|/ c |>\n<| a tags=julia,sorting |>\nHere's a solution\
    \ using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n     \
    \      even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 != 0)]\n\
    \           even.sort()\n           odd.sort()\n           return even .+ odd\n\
    \       end", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ .== 1)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work for `sort_even([5, 6, 3, 4])` which\
    \ should return `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nThanks for pointing that out.\
    \ I've fixed the code now.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>", " \
    \   even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't work for `sort_even([5, 6, 3, 4])` which should return `[3, 6, 5, 4]`\n\
    <|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out\n<|/ c |>\n<| a\
    \ |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n\
    \    even = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</cell>\n\
    <code language=julia-1.5>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't seem to work. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nI tested it on julia 0.6.2 and it works. I guess it depends\
    \ on the version of julia you are using.\n<|/ c |>\n<| c |>\nI tested it on julia\
    \ 0.6.2 and it works. I guess it depends on the version of julia you are using.\n\
    <|/ c |>\n<| c |>\nI tested it on julia 0.6.2 and it works. I guess it depends\
    \ on the version of julia you are using.\n<|/ c |>\n<| c |>\nI tested it on julia\
    \ 0.6.2 and it works. I guess it depends on the version of julia you are using.\n\
    <|/ c |>\n<| a tags=julia |>\n<code>", "    even = l[findall(l .== 0)]\n    odd\
    \ = l[findall(l .!= 0)]\n    even = sort(even)\n    odd = sort(odd)\n    return\
    \ even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do this without having to use an anonymous\
    \ function?\n<|/ c |>\n<| c |>\nI added a solution without an anonymous function\n\
    <|/ c |>\n<| c |>\nI added a solution without an anonymous function\n<|/ c |>\n\
    <| a dscore=1 |>\nHere's a solution without an anonymous function:\n<code>", " \
    \   even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=julia,sorting |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nI like your solution, but I thought I'd add my own because I\
    \ like recursion.\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .!= 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the input vector. For example, `sort_even([1, 1, 2, 3])` returns `[1, 1,\
    \ 2, 3]` instead of `[1, 2, 3]`.\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out. I fixed the code by sorting the odd indicies first and then the even indicies.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n   \
    \ odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ for me. `sort_even([5,6,3,4])` returns `[3,6,5,4]` instead of `[3,6,4,5]`.\n\
    <|/ c |>\n<| c |>\nI tested it and it works for me. Are you sure you copied the\
    \ code correctly? I tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI copied it exactly\
    \ as you wrote it. I also tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested\
    \ it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n\
    <| a tags=julia |>\nA simple solution:\n<code>", "    even = l[findall(l .== 0)]\n\
    \    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n    return even\
    \ .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there\
    \ are duplicates in the input vector. For example, `sort_even([1, 1, 2, 3])` returns\
    \ `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/ c |>\n<| c |>\nI added a version\
    \ that works with duplicates.\n<|/ c |>\n<| a tags=julia |>\nHere's a solution\
    \ using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .== 0)]\n           odd = l[findall(l .!= 0)]\n\
    \           even.sort()\n           odd.sort()\n           return even .+ odd\n\
    \       end\nsort_even (generic function with 1 method)", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n</cell>\n\
    <text>\nExercise\nWrite a function that takes a vector l and returns a vector\
    \ l' such that\n    l' is identical to l in the even indicies, while its values\
    \ at the odd indicies are equal\n    to the values of the odd indicies of l, but\
    \ sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6,\
    \ 3, 4])\n    [4, 6, 5, 3]\n    \"\"\"", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    return\
    \ even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. `sort_even([5,\
    \ 6, 3, 4])` returns `[3, 6, 5, 4]` instead of `[5, 6, 3, 4]`.\n<|/ c |>\n<| c\
    \ |>\nI see what you mean. Thanks for pointing that out. I've edited my answer\
    \ to fix it.\n<|/ c |>\n<| a dscore=1 |>\nI came up with a solution that is quite\
    \ similar to what was proposed in the comments, but I thought I'd post it here\
    \ for completeness.\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for me. `sort_even([5,\
    \ 6, 3, 4])` returns `[3, 5, 6, 4]` instead of `[3, 6, 5, 4]`.\n<|/ c |>\n<| c\
    \ |>\nI tested it on Julia 0.6.1 and it works. What version are you using?\n<|/\
    \ c |>\n<| c |>\nI'm using 0.6.1. I guess it's an issue with my version of Julia.\
    \ I'll try it on another machine and see if it works.\n<|/ c |>\n<| c |>\nIt works\
    \ fine for me on 0.6.1 on OS X. Perhaps try reinstalling Julia?\n<|/ c |>\n<|\
    \ c |>\nI reinstalled Julia and it still doesn't work. I'm on 0.6.1 on OS X. I'll\
    \ try it on another machine and see if it works.\n<|/ c |>\n<| a tags=julia |>\n\
    I wrote a package called Sorting.jl that does exactly this. It sorts even and\
    \ odd numbers in an array:\n<code>\njulia> using Sorting", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    even = sort(even)\n\
    \    return even\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a dscore=2 |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even.sort()\n           odd.sort()\n           return even\
    \ .+ odd\n       end", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia\
    \ |>\nI came up with a solution that is similar to what was proposed in the comments\
    \ above. \n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!=\
    \ 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a |>\nI like to use sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n\
    <|/ a tags=julia,sorting,arrays dscore=3 |>\n<| c |>\nThis should be the accepted\
    \ answer. `sortperm` is designed for this purpose.\n<|/ c |>\n<| a dscore=3 |>\n\
    I like to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a dscore=3 |>\nI\
    \ like to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a dscore=3 |>\nI\
    \ like to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a dscore=3 |>\nI\
    \ like to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays\
    \ |>\nI like to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia,sorting,arrays |>\nI\
    \ like to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia,sorting,arrays |>\nI\
    \ like to use sortperm:\n<code>\njulia> sortperm", "    even = l[findall(l .==\
    \ 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n    return\
    \ even .+ odd\nend\n</cell>\n<code language=julia-1.5>\nsort_even([5, 6, 3, 4])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a vector l and returns\
    \ a vector l' such that\n    l' is identical to l in the even indicies, while\
    \ its values at the odd indicies are equal\n    to the values of the odd indicies\
    \ of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5,\
    \ 6, 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,sorting,arrays\
    \ |>\nThis can be done using sortperm:\n<code>\njulia> sortperm(1:10)\n10-element\
    \ Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort(even)\n   \
    \ odd = sort(odd)\n    l = copy(even)\n    l[findall(l .== even)] = odd\n    l\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\nThis can be done with a single\
    \ line of code using sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\n<code>\njulia> function\
    \ sort_even(l::Vector{Int64})::Vector{Int64}\n           even = l[findall(l .%\
    \ 2 == 0)]\n           odd = l[findall(l .% 2 .== 1)]\n           even = sort(even)\n\
    \           odd = sort(odd)\n           l = copy(even)\n           l[findall(l\
    \ .== even)] = odd\n           l\n       end\nsort_even (generic function with\
    \ 1 method)", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ != 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "    even = l[findall(l .% 2 ==\
    \ 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n  \
    \  even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia |>\n<| a\
    \ dscore=1 |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .== 1)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a dscore=2 |>\nI like using\
    \ sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    even.zip(odd).collect{|x|\
    \ x}\nend\n</cell>\n<code language=julia-1.3>\nsort_even([5, 6, 3, 4])\n</cell>\n\
    <text>\nExercise: Write a function that takes a vector l and returns a vector\
    \ l' such that\n    l' is identical to l in the even indicies, while its values\
    \ at the odd indicies are equal\n    to the values of the odd indicies of l, but\
    \ sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5, 6,\
    \ 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't seem to work. `sort_even([1,2,3])` returns `[1,2,3]`, not `[2,1,3]`.\n\
    <|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now it works as\
    \ intended.\n<|/ c |>\n<| a dscore=2 |>\nI believe this can be done in O(n) time\
    \ using two pointers, one to iterate over the even numbers and one to iterate\
    \ over the odd numbers. \n<code>", "    even = l[findall(l .== 0)]\n    odd =\
    \ l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=0 |>\nThe answer by is correct and should be accepted but since\
    \ I wanted to add some explanation I thought I'd add my own.\nThe reason why Julia\
    \ is so slow is because of the way it handles vectors. Vectors are stored as pointers\
    \ to their elements. When you do l[findall(l .% 2 == 0)] you get a vector of pointers\
    \ to all the even numbers in l. Now when you do even.sort() you sort the pointers\
    \ in even, not the numbers in l. \nTo fix this you need to do even.sort() on the\
    \ numbers in l instead. \n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    return even\
    \ .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are duplicates in the input vector. For example, `sort_even([1,\
    \ 1, 2, 3])` returns `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/ c |>\n<| c |>\n\
    Yes, it does. I edited my answer to include a version that does that.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if there are duplicates in the input vector. For example,\
    \ `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. I edited my answer to include a version that does\
    \ that.\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nThis should work:\n<code>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nI came up with a solution using Julia arrays:\n<code>", "    even\
    \ = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if `l` is an\
    \ `Array{Int64,1}`\n<|/ c |>\n<| c |>\nYes, it does. `sort` will sort `l` by `Int64`\n\
    <|/ c |>\n<| c |>\nI guess you meant `sort` instead of `sort!`\n<|/ c |>\n<| c\
    \ |>\nYes, I meant `sort` instead of `sort!`\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nI like using sort! for this.\n<code>\njulia> sort!([1,4,2,5,3,6,7,8,9])\n\
    1-element Array{Int64,1}:\n 9\n 8\n 7\n 6\n 5\n 4\n 3\n 2\n 1\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| a dscore=4\
    \ |>\nFor a general case where you want to sort an array by some criteria, you\
    \ can use the sort! function and pass a custom comparison function to the key\
    \ argument:\n<code>\njulia> sort!([1,4,2,5,3,6,7,8,9], by=x->x%2)\n1-element Array{Int64,1}:\n\
    \ 9\n 8\n 7\n 6\n 5\n 4\n 3\n 2\n 1\n</code>\n<|/ a tags=julia,sorting |>\n<|\
    \ c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| a dscore=4\
    \ |>\nI like using sort! for this.\n<code>\njulia> sort!([1,4,2,5,3,6,7,8,9])\n\
    1-element Array{Int64,1}:\n 9\n 8\n ", "    even = l[findall(l .== 0)]\n    odd\
    \ = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\n\
    end\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l .== 0)]\n  \
    \  odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=julia |>\nI came up with a solution using sortperm:\n<code>", "    even\
    \ = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ tags=julia,sorting |>\nI like using sortperm:\n<code>\njulia> sortperm([1,2,3])\n\
    3-element Array{Int64,1}:\n 3\n 1\n 2", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    return\
    \ even .+ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't seem to\
    \ work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]`, but `sort_even([5, 6,\
    \ 3, 2])` returns `[3, 6, 5, 2]`.\n<|/ c |>\n<| c |>\nYes, I noticed that and\
    \ fixed it. I was thinking about it too much. Thanks for pointing it out.\n<|/\
    \ c |>\n<| a tags=julia,sorting |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    l = copy(even)\n    l[findall(l .% 2 == 0)] = odd\n    l[findall(l .% 2 !=\
    \ 0)] = even\n    return l\nend\n</code>\n<|/ a |>\n<| c |>\nThis does not work\
    \ if `l` is an `Int64` array. `sort` returns a `Vector{Int64}`, not a `Vector{Int}`.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe accepted answer does not work for me. Here is\
    \ a version that does:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    return even .+ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,julia\
    \ |>\nI wrote a package for sorting arrays of arbitrary dimensions, including\
    \ sorting by multiple dimensions.\nhttps://github.com/jrfonseca/MultiDimensionalArrays.jl\n\
    <code>\nusing MultiDimensionalArrays", "    even = l[findall(l .% 2 == 0)]\n \
    \   odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` will sort\
    \ `Int64` arrays lexicographically, which is not what OP wants.\n<|/ c |>\n<|\
    \ c |>\nI believe this answer was written before `sort` was added to Julia. `sort`\
    \ was added after this answer was written.\n<|/ c |>\n<| c |>\nI believe this\
    \ answer was written before `sort` was added to Julia. `sort` was added after\
    \ this answer was written.\n<|/ c |>\n<| a tags=julia,sorting |>\nThe answer by\
    \ is correct, but I thought I'd add some explanation as to why it works.\nThe\
    \ function sort_even is defined as:\n<code>", "    even = l[findall(l .== 0)]\n\
    \    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    even = sort(even)\n    return even\nend\n</cell>\n\
    <code language=julia-1.5>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .== 1)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nI like the idea of\
    \ using an anonymous function, but I get the following error when I try to use\
    \ it: ```ERROR: LoadError: MethodError: no method matching sort_even()```\n<|/\
    \ c |>\n<| c |>\nI edited my answer to include a working example and to fix the\
    \ error you were getting.\n<|/ c |>\n<| a dscore=2 |>\nThe easiest way is to use\
    \ sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays\
    \ |>\nYou can use the function sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,sorting,arrays |>\nI like to use sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,sorting,arrays |>\nI like to use sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,sorting,arrays |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n\
    \ 3\n 4\n 5\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,sorting,arrays |>\n",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a dscore=2 |>\nThe easiest way is to use sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 2\n 1\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\nThe other answers are\
    \ good, but I thought I'd add my own, since I find it more readable and more efficient.\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 2\n 1\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=julia,sorting |>\nI like to use sortperm:\n<code>\n\
    julia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 2\n 1\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=1 |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    return\
    \ even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't seem to work if there are duplicates in the array. For example, `sort_even([5,\
    \ 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. I've edited my answer to fix the problem.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work if there are duplicates in the array. For example, `sort_even([5,\
    \ 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. I've edited my answer to fix the problem.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ .== 1)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\nI came up with a solution\
    \ that is quite simple, although it does require a little bit of extra memory\
    \ (it uses two vectors). \n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    return even\
    \ .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nThe answer by\
    \ is great and works well for small vectors. However, for large vectors, it becomes\
    \ very slow and memory intensive. \nHere is a solution using sortperm:\n<code>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return union(even, odd)\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}` because `sort`\
    \ sorts in-place.\n<|/ c |>\n<| c |>\nYes, you are right. I was thinking about\
    \ `sort!` but didn't want to change my answer too much. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    even = l[findall(l .== 0)]\n\
    \    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate elements in the array.\
    \ For example, `sort_even([1,1,2,3])` returns `[1,1,2,3]`.\n<|/ c |>\n<| c |>\n\
    I edited the answer to include a version that works with duplicate elements.\n\
    <|/ c |>\n<| a tags=julia,sorting,arrays |>\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`.\n<|/ c |>\n<|\
    \ c |>\nI added a version that works for `Array{Int64,1}`\n<|/ c |>\n<| c |>\n\
    This doesn't work for `l = [1, 4, 2, 3]`\n<|/ c |>\n<| c |>\nIt works for me.\
    \ `l = [1, 4, 2, 3]; sort_even(l); l` gives `[1, 2, 3, 4]`.\n<|/ c |>\n<| c |>\n\
    I added a version that works for `Array{Int64,1}`\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nI came up with this solution:\n<code>", "    even = l[findall(l .== 0)]\n\
    \    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if there\
    \ are duplicate elements in the input vector. For example, `sort_even([1, 1, 2])`\
    \ returns `[1, 1, 2]` instead of `[1, 2, 1]`.\n<|/ c |>\n<| c |>\nI see your point,\
    \ but I believe this can be solved by sorting on the even indicies first, then\
    \ on the odd indicies and finally concatenating the two lists.\n<|/ c |>\n<| c\
    \ |>\nYes, but that would require a lot of extra memory and would not scale well\
    \ for large vectors.\n<|/ c |>\n<| c |>\nYes, I agree. My solution was meant as\
    \ a quick fix for small vectors. I believe that for large vectors, a more efficient\
    \ solution would be needed.\n<|/ c |>\n<| a dscore=2 |>\nI believe that this is\
    \ what you are looking for:\n<code>", "    even = l[findall(l .% 2 == 0)]\n  \
    \  odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work\
    \ if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nI tested it on `Array{Int64,1}`\
    \ and it worked fine.\n<|/ c |>\n<| c |>\nI tested it on `Array{Int64,1}` and\
    \ it worked fine.\n<|/ c |>\n<| c |>\nI tested it on `Array{Int64,1}` and it worked\
    \ fine.\n<|/ c |>\n<| c |>\nI tested it on `Array{Int64,1}` and it worked fine.\n\
    <|/ c |>\n<| a dscore=3 |>\nI believe that this is what you are looking for:\n\
    <code>\njulia> function sort_even(l::Vector{Int64})\n           even = l[findall(l\
    \ .% 2 == 0)]\n           odd = l[findall(l .% 2 != 0)]\n           even.sort()\n\
    \           odd.sort()\n           even.extend(odd)\n           return even\n\
    \       end\nsort_even (generic function with 1 method)", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n  \
    \  even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia\
    \ |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .== 0)]\n           odd = l[findall(l .!= 0)]\n\
    \           even.sort()\n           odd.sort()\n           even.extend(odd)\n\
    \           return even\n       end\nsort_even (generic function with 1 method)",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = even[findall(even .!= 0)]\n    odd = odd[findall(odd\
    \ .!= 0)]\n    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,julia |>\n<code>", "    even = l[findall(l .== 0)]\n \
    \   odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=1 |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even,\
    \ odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<|\
    \ c |>\nThis doesn't work for me. `sort_even([5,6,3,4])` returns `[3,4,5,6]` instead\
    \ of `[3,6,5,4]`.\n<|/ c |>\n<| c |>\nIt works for me on Julia 0.6.2. I think\
    \ it might be a bug in 0.6.1, which I tested on 0.6.2 as well. I'll try to reproduce\
    \ this on 0.6.2.\n<|/ c |>\n<| c |>\nI tested on 0.6.2 as well. I'm on 0.6.1 as\
    \ well. I'll try to reproduce this on 0.6.2.\n<|/ c |>\n<| c |>\nI tested on 0.6.2\
    \ as well. I'm on 0.6.1 as well. I'll try to reproduce this on 0.6.2.\n<|/ c |>\n\
    <| c |>\nI tested on 0.6.2 as well. I'm on 0.6.1 as well. I'll try to reproduce\
    \ this on 0.6.2.\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nThe answer by is\
    \ correct, but I thought I'd add an explanation as to why it works.\nThe reason\
    \ why it works is because Julia is smart enough to realize that your function\
    \ sort_even is pure, and therefore it can safely be inlined into your code. \n\
    The reason why it works is because Julia is smart enough to realize that your\
    \ function sort_even is pure, and therefore it can safely be inlined into your\
    \ code. \nThe reason why it works is because Julia is smart enough to realize\
    \ that your function sort_even is pure, and therefore it can safely be inlined\
    \ into your code. \nThe reason why it works is because Julia is smart enough to\
    \ realize that your function sort_even is pure, and therefore it can safely be\
    \ inlined into your code. \nThe reason why it works is because Julia is smart\
    \ enough to realize that your function sort_even is pure, and therefore it can\
    \ safely be inlined into your code. \nThe reason why it works is because Julia\
    \ is smart enough to realize that your function sort_even is pure, and therefore\
    \ it can saf", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ .== 1)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work if there are repeated elements in\
    \ the input vector. For example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2,\
    \ 3]`.\n<|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out.\
    \ I edited my answer to account for that case.\n<|/ c |>\n<| a tags=sorting,julia\
    \ |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ .== 1)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work if `l` is an `Array{Int64,1}`\n\
    <|/ c |>\n<| a |>\nI like to use sortperms to get an ordered permutation of an\
    \ array:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a tags=julia |>\n<| c\
    \ |>\nThis doesn't seem to work. `sort_even([1,2,3])` returns `[1,2,3]` instead\
    \ of `[1,2,3]`.\n<|/ c |>\n<| c |>\nAh, I see what you're saying. I think I misunderstood\
    \ the question. I'll edit my answer.\n<|/ c |>\n<| c |>\nI edited my answer to\
    \ include a solution that should work. Let me know if it doesn't.\n<|/ c |>\n\
    <| c |>\nThis doesn't work. `sort_even([1,2,3])` returns `[1,2,3]` instead of\
    \ `[1,2,3]`.\n<|/ c |>\n<| c |>\nAh, I see what you're saying. I think I misunderstood\
    \ the question. I'll edit my answer.\n<|/ c |>\n<| a dscore=1 |>\nThis should\
    \ work:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .%\
    \ 2 .== 1)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't seem to work. `sort_even([5,\
    \ 6, 3, 4])` returns `[5, 6, 3, 4]` instead of `[3, 6, 5, 4]`.\n<|/ c |>\n<| c\
    \ |>\nI tested it and it works fine for me. Are you sure you copied the code correctly?\
    \ It works for me on Julia 0.6.2\n<|/ c |>\n<| c |>\nI copied it exactly as you\
    \ wrote it. I also tested it on 0.6.2 and it still doesn't work. I'm running 0.6.2\
    \ on OS X 10.10.5\n<|/ c |>\n<| c |>\nI tested it on 0.6.2 on OS X 10.10.5 and\
    \ it works fine. Are you sure you copied the code correctly? It works for me on\
    \ Julia 0.6.2\n<|/ c |>\n<| c |>\nI copied it exactly as you wrote it. I also\
    \ tested it on 0.6.2 and it still doesn't work. I'm running 0.6.2 on OS X 10.10.5\n\
    <|/ c |>\n<| a tags=julia,sorting,arrays |>\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n  \
    \  return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\nsort_even([5,\
    \ 6, 3, 4])\n</cell>\n<text>\nExercise: Write a function that takes a vector l\
    \ and returns a vector l' such that\n    l' is identical to l in the even indicies,\
    \ while its values at the odd indicies are equal\n    to the values of the odd\
    \ indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 2, 3]\n   \
    \ >>> sort_odd([5, 6, 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n</cell>\n\
    <code language=julia-1.5>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia,sorting |>\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even + odd\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=2 |>\n\
    <code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n\
    \    even = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\n\
    end\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l .== 0)]\n  \
    \  odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n    return even\
    \ .+ odd\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ l and returns a vector l' such that\n    l' is identical to l in the even indicies,\
    \ while its values at the odd indicies are equal\n    to the values of the odd\
    \ indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n   \
    \ >>> sort_odd([5, 6, 3, 4])\n    [4, 5, 6, 3]\n    \"\"\"", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\nI like using mapslices for this:\n<code>\njulia> mapslices(sort,[1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a tags=julia,sorting |>\n<|\
    \ a dscore=2 |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a tags=julia,sorting |>\n<|\
    \ a tags=julia,sorting |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a tags=julia,sorting |>\n<|\
    \ a tags=julia,sorting |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,sorting\
    \ |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI like\
    \ using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n3-element\
    \ Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a tags=julia,sorting dscore=1 |>\n\
    <| a tags=julia,sorting |>\nI like using sortslices for this:\n<code>\njulia>\
    \ sortslices([1,2,3],dims=2)\n3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n\
    <|/ a dscore=1 ", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n\
    \    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\n\
    This doesn't work if there are duplicate elements in the input vector. For example,\
    \ `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/\
    \ c |>\n<| c |>\nYes, I realized that after I wrote my answer. I've added a version\
    \ that doesn't have that problem.\n<|/ c |>\n<| c |>\nI added a version that doesn't\
    \ have that problem and also a version that doesn't have that problem but is faster.\n\
    <|/ c |>\n<| a tags=julia,sorting |>\nI wrote a version that doesn't have that\
    \ problem but is faster:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 |>\nHere's a solution using sortperm:\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n  \
    \  even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n\
    <| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` returns a `Vector{Int64}`,\
    \ so `even = sort(l)` will fail.\n<|/ c |>\n<| c |>\nI fixed the code so it works\
    \ with `Int64` arrays. Thanks for pointing that out.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .== 0)]\n           odd = l[findall(l .!= 0)]\n\
    \           even.sort()\n           odd.sort()\n           even.extend(odd)\n\
    \           return even\n       end\nsort_even (generic function with 1 method)",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a tags=julia,sorting,arrays |>\nThe answer by is correct but can be simplified\
    \ a bit:\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!=\
    \ 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis does not answer the question. The question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\n<|/ c |>\n<| c |>\nThe question was how to sort a vector in Julia\
    \ by even and odd indices. Your answer does not do that.\n<|/ c |>\n<| c |>\n\
    The question was how to sort a vector in Julia by even and odd indices. Your answer\
    \ does not do that.\n<|/ c |>\n<| c |>\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\n<|/ c |>\n\
    <| a tags=julia |>\nThe question was how to sort a vector in Julia by even and\
    \ odd indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by ", "    even = l[findall(l .== 0)]\n  \
    \  odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a dscore=0 |>\n\
    This can be done with sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n5-element\
    \ Array{Int64,1}:\n 3\n 2\n 1\n 4\n 5", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    return\
    \ even .+ odd\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nI like your solution, but I believe that\
    \ `sort` should be used instead of `sort_even`.\n<|/ c |>\n<| c |>\nI agree, `sort`\
    \ would be more efficient.\n<|/ c |>\n<| c |>\nI agree, `sort` would be more efficient.\n\
    <|/ c |>\n<| c |>\nI agree, `sort` would be more efficient.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere is a solution using sort:\n<code>", "    even = l[findall(l .% 2 ==\
    \ 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}` because `sort`\
    \ returns a `Vector{Int64}`.\n<|/ c |>\n<| c |>\nYes, I noticed that and edited\
    \ my answer to include a version that works with `Array{Int64,1}`\n<|/ c |>\n\
    <| a tags=julia,sorting |>\nThe answer by is correct but can be simplified a bit:\n\
    <code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=julia,sorting,arrays |>\n<code>", "    even = l[findall(l .% 2\
    \ == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting\
    \ |>\nI came up with this:\n<code>", "    even = l[findall(l .== 0)]\n    odd\
    \ = l[findall(l .== 1)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "    even = l[findall(l .%\
    \ 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n\
    \    return even + odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a\
    \ dscore=2 |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .!= 0)]\n    even.sort()\n    odd.sort()\n    l = even\n    l .= odd\n    return\
    \ l\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis does not work for\
    \ me. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nIt\
    \ does work for me. Are you sure you copied it correctly? It works for me on Julia\
    \ 0.6.2\n<|/ c |>\n<| c |>\nYes, I copied it correctly. I just tried it again\
    \ and it works. I must have done something wrong the first time I tried it. Thanks!\n\
    <|/ c |>\n<| c |>\nI added a version that works on Julia 0.6.2\n<|/ c |>\n<| a\
    \ dscore=2 |>\nA simple and efficient solution is to use sortperm:\n<code>\njulia>\
    \ sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n 3\n 2\n 1\n 4\n</code>\n<|/\
    \ a tags=julia,sorting |>\n<| a dscore=1 |>\nThe answer by is correct, but I wanted\
    \ to add that you can also use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 2\n 1\n 4\n</code>\n<|/ a tags=julia,sorting |>\n\
    <| a tags=julia,sorting |>\n<code>", "    even = l[findall(l .== 0)]\n    odd\
    \ = l[findall(l .== 1)]\n    even.sort()\n    odd.sort()\n    even.zip(odd).collect{|x|\
    \ x[1] }\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work for me. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for me either. `sort_even([1,2,3])` returns\
    \ `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work for me\
    \ either. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work for me either. `sort_even([1,2,3])` returns `[1,2,3]`\
    \ instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work for me either. `sort_even([1,2,3])`\
    \ returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| a dscore=5 |>\nThe accepted\
    \ answer doesn't work for me. sort_even([1,2,3]) returns [1,2,3] instead of [1,2,3].\n\
    Here's a version that does:\n<code>", "    even = l[findall(l .% 2 == 0)]\n  \
    \  odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6,\
    \ 5, 4]`.\n<|/ c |>\n<| c |>\nI added a version that works with vectors of any\
    \ length.\n<|/ c |>\n<| c |>\nI added a version that works with vectors of any\
    \ length.\n<|/ c |>\n<| a tags=julia |>\nHere's a version that works with vectors\
    \ of any length. \n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    even.zip(odd).collect{|x|\
    \ x}\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l .% 2 ==\
    \ 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n  \
    \  return even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,julia\
    \ |>\nA simple and efficient solution is to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n\
    3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/27812697)\n\
    <|/ c |>\n<| c |>\nThe question was \"How to sort a vector in Julia?\" and the\
    \ answer is \"Use sortperm\". The question was \"How to sort a vector in Julia?\"\
    \ and the answer is \"Use sortperm\". The question was \"How to sort a vector\
    \ in Julia?\" and the answer is \"Use sortperm\". The question was \"How to sort\
    \ a vector in Julia?\" and the answer is \"Use sortperm\". The question was \"\
    How to sort a vector in Julia?\" and the answer is \"Use sortperm\". The question\
    \ was \"How to sort a vector in Julia?\" and the answer is \"Use sortperm\". The\
    \ question was \"How to sort a vector in Julia?\" and the answer is \"Use sortperm\"\
    . The question was \"How to sort a vector in Julia?\" and the answer is \"Use\
    \ sortperm\". The question was \"How to sort a vector in Julia?\" and the answer\
    \ is \"Use sortperm\". The question was \"How to sort a vector in Julia?\" and\
    \ the answer is \"Use sortperm\". The question was \"How to sort a vector in Julia?\"\
    \ and the answer is \"Use sortperm\". The question was \"How to sort a vector\
    \ in Julia?\" and the answer is \"Use sortperm\". The question was \"How to sort\
    \ a vector in Julia?\" and the answer is \"Use sortperm\". The question was \"\
    How to sort a vector in Julia?\" and the answer is \"Use sortperm\". The question\
    \ was \"How to sort a vector in Julia?\" and the answer is \"Use sortperm\". The\
    \ question was \"How to sort a vector in Julia?\" and the answer is \"Use sortperm\"",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=2 |>\nHere's a solution that doesn't require any packages:\n\
    <code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n\
    \    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nIt does work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c\
    \ |>\nIt does work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt does work\
    \ if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt does work if `l` is an\
    \ `Array{Int64,1}`\n<|/ c |>\n<| a tags=sorting,julia |>\nThe answer by is correct,\
    \ but I wanted to add that you can also use sortperm:\n<code>\njulia> sortperm([1,2,3])\n\
    3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ should be the accepted answer. `sortperm` is much more efficient than `sort`\
    \ and also works on `Array{Int64,1}`\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. `sortperm` is much more efficient than `sort` and also works on `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `sortperm` is much more\
    \ efficient than `sort` and also works on `Array{Int64,1}`\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer. `sortperm` is much more efficient than `sort`\
    \ and also works on `Array{Int64,1}`\n<|/ c |>\n<| a dscore=5 |>\nThe answer by\
    \ is correct, but I wanted to add that you can also use sortperm:\n<code>\njulia>\
    \ sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| c |>\nThis should be the accepted answer. `sortperm` is much more efficient\
    \ than `sort` and also works on `Array{Int64,1}`\n<|/ c |>\n", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\n\
    <code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n\
    \    even.sort()\n    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` sorts the\
    \ array in place, so `even` and `odd` will point to the same array and `even.sort()`\
    \ will sort the same array twice.\n<|/ c |>\n<| c |>\nThanks for the comment.\
    \ I've edited my answer to include a version that works with `Int64` arrays.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a solution using sort!\n<code>", "    even\
    \ = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])` returns `[1,2,3]`\
    \ instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works for me on Julia 0.6.2\n<|/\
    \ c |>\n<| c |>\nIt works for me on Julia 0.6.2\n<|/ c |>\n<| c |>\nIt works for\
    \ me on Julia 0.6.2\n<|/ c |>\n<| c |>\nIt works for me on Julia 0.6.2\n<|/ c\
    \ |>\n<| a dscore=2 |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .== 1)]\n    even = sort(even)\n    odd = sort(odd)\n    return even .+ odd\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work. `sort_even([5,\
    \ 6, 3, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I must have missed something when I first tried it.\n<|/ c |>\n<| c |>\nI tested\
    \ it again and it works. I must have missed something when I first tried it.\n\
    <|/ c |>\n<| c |>\nI tested it again and it works. I must have missed something\
    \ when I first tried it.\n<|/ c |>\n<| a tags=julia,sorting |>\nHere is a solution\
    \ using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .== 0)]\n           odd = l[findall(l .== 1)]\n\
    \           even = sort(even)\n           odd = sort(odd)\n           return even\
    \ .+ odd\n       end\nsort_even (generic function with 1 method)", "    even =\
    \ l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's a solution that doesn't require\
    \ any sorting:\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .!= 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work if there are duplicate elements\
    \ in the input vector. For example, `sort_even([5, 6, 3, 6, 5, 4])` returns `[3,\
    \ 6, 5, 4]`.\n<|/ c |>\n<| c |>\nYes, it does. I didn't realize that OP wanted\
    \ the even indicies sorted.\n<|/ c |>\n<| c |>\nYes, I didn't realize that OP\
    \ wanted the even indicies sorted.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution\
    \ using sortperm:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return\
    \ even\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l .% 2\
    \ == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\nI came up with this solution:\n<code>", "  \
    \  even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for `sort_even([1,3,5,2,4,6])` which should return\
    \ `[1,2,3,4,5,6]`.\n<|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing\
    \ it out. I've updated the answer.\n<|/ c |>\n<| a |>\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n    odd.sort()\n  \
    \  even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   even = sort(even)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to avoid the\
    \ copying by using a mutable vector and `push!`ing into it.\n<|/ c |>\n<| c |>\n\
    I haven't thought about that, but I suspect that would require a more complicated\
    \ version of this solution, since you would need to keep track of which indices\
    \ are even and which are odd.\n<|/ c |>\n<| c |>\nI added a solution that avoids\
    \ copying by using a mutable vector and `push!`ing into it.\n<|/ c |>\n<| c |>\n\
    I added a solution that avoids copying by using a mutable vector and `push!`ing\
    \ into it.\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nHere's a solution using\
    \ sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n           even\
    \ = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 != 0)]\n      \
    \     even = sort_even(even)\n           odd = sort_even(odd)\n           even\
    \ = union(even, odd)\n           even = sortperm(even)\n           return even\n\
    \       end\nsort_even (generic function with 1 method)", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n  \
    \  return even .+ odd\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis does not answer the question.\
    \ `sort_even` does not sort the even indicies of `l` but rather sorts the even\
    \ indicies of `l` itself. This is not what the OP asked for.\n<|/ c |>\n<| c |>\n\
    The question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThanks for your answer. Your code works perfectly for me. Could you please\
    \ explain me the logic behind your code? I understand that you are sorting odd\
    \ numbers and even numbers and then concatenating them. But, I am not able to\
    \ understand how you did that. Thanks.\n<|/ c |>\n<| c |>\nI added some comments\
    \ to the code. Hope it helps.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    even\
    \ = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work for me. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[2,1,3]`.\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it\
    \ on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<|\
    \ c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| a dscore=1 |>\n<code>", "   \
    \ even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a tags=julia,sorting,arrays |>\n<code>", "    even = l[findall(l .% 2\
    \ == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't work if there are duplicates in the input vector. For example,\
    \ `sort_even([5, 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\n\
    I see what you mean. Thanks for pointing that out. I've edited my answer to account\
    \ for that case.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even .+ odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for\
    \ `sort_even([5, 6, 3, 4])` which should return `[3, 6, 5, 4]`.\n<|/ c |>\n<|\
    \ c |>\nI see what you mean. I've updated the answer to include a more general\
    \ solution.\n<|/ c |>\n<| c |>\nThis doesn't work for `sort_even([5, 6, 3, 4])`\
    \ which should return `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I updated the answer to include a more general solution.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for `sort_even([5, 6, 3, 4])` which should return `[3,\
    \ 6, 5, 4]`.\n<|/ c |>\n<| a |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis does not answer the question.\
    \ He asked for something that works with any type of vector, not just Int64.\n\
    <|/ c |>\n<| c |>\nI agree with you, my answer was more of a \"quick and dirty\"\
    \ solution to his problem. I'll edit my answer to include a more general solution.\n\
    <|/ c |>\n<| a dscore=1 |>\nI believe that your problem can be solved using sortperm.\
    \ \n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .==\
    \ 1)]\n    even = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI like your solution, but I wonder why you used `sort`\
    \ instead of `sort!`?\n<|/ c |>\n<| c |>\nI used `sort` because I wanted to preserve\
    \ the original order of the even elements. `sort!` would not do that. `sort!`\
    \ would sort the even elements and leave the odd elements untouched.\n<|/ c |>\n\
    <| c |>\nI see. Thanks for clarifying.\n<|/ c |>\n<| a |>\nHere is a solution\
    \ using sort!:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe solutions above are all good,\
    \ but I wanted to add my own solution, which is more efficient and uses less memory\
    \ than other solutions:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\n\
    This doesn't seem to work if there are duplicate values in the original array.\
    \ For example, `sort_even([1,2,2,3])` returns `[1,2,3]` instead of `[1,2,2,3]`.\n\
    <|/ c |>\n<| c |>\nI believe this should work, since `sort` sorts in place. `sort!`\
    \ would not work since it returns a new array.\n<|/ c |>\n<| c |>\nI tested this\
    \ and it does work. `sort!` returns a new array and `sort` sorts in place. `sort!`\
    \ would not work since it returns a new array.\n<|/ c |>\n<| c |>\nI tested this\
    \ and it does work. `sort!` returns a new array and `sort` sorts in place. `sort!`\
    \ would not work since it returns a new array.\n<|/ c |>\n<| c |>\nI tested this\
    \ and it does work. `sort!` returns a new array and `sort` sorts in place. `sort!`\
    \ would not work since it returns a new array.\n<|/ c |>\n<| a dscore=3 |>\nThe\
    \ answer by is correct, but I thought I'd add an alternative solution that is\
    \ more efficient than sorting.\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even.sort()\n           odd.sort()\n           even.extend(odd)\n\
    \           return even\n       end\nsort_even (generic function with 1 method)",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=1 |>\nI like to use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 5\n 6\n 4", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even = sort(even)\n    odd = sort(odd)\n\
    \    l = copy(even)\n    l[findall(l .% 2 == 0)] = odd\n    l[findall(l .% 2 !=\
    \ 0)] = even\n    return l\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia\
    \ |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ != 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</cell>\n\
    <code language=julia-1.3>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even,\
    \ odd)\n    return even\nend\n</cell>\n<code language=julia-1.3>", "    even =\
    \ l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return\
    \ even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThanks, I didn't know\
    \ about `sortperm` until now. I've added a benchmark comparison to my answer.\n\
    <|/ c |>\n<| a dscore=3 |>\nThe answer by is correct, but I thought I'd add some\
    \ benchmarking results. I used the benchmarking package to benchmark several methods.\
    \ I used the function sort_even from that answer, but also used the function sort_even2\
    \ from my answer, which was based on sortperm. \n<code>\nusing BenchmarkTools",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't answer the question. The question asks how to sort a vector\
    \ by its even indices. Your answer sorts the even indices first, then the odd\
    \ indices. That doesn't answer the question.\n<|/ c |>\n<| c |>\nThe question\
    \ asks how to sort a vector by its even indices. Your answer sorts the even indices\
    \ first, then the odd indices. That doesn't answer the question.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI believe that this is what you are looking for:\n<code>", " \
    \   even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5,\
    \ 4]`, but `sort_even([5, 6, 3, 1])` returns `[5, 6, 3, 1]`.\n<|/ c |>\n<| c |>\n\
    It does work. `sort_even([5, 6, 3, 1])` returns `[5, 6, 3, 1]`.\n<|/ c |>\n<|\
    \ c |>\nI guess I misunderstood your question. My apologies.\n<|/ c |>\n<| c |>\n\
    No worries. I appreciate your help.\n<|/ c |>\n<| a tags=julia,sorting |>\nThe\
    \ answer by is correct, but I thought I'd add some explanation.\nThe reason why\
    \ your function doesn't work is that you are trying to sort a vector of Int64\
    \ and Int32 types. In Julia, sorting is done by converting both elements to their\
    \ corresponding floating point types and then comparing them. Since your elements\
    \ are Int64, this conversion will always succeed and your elements will remain\
    \ unchanged. To fix this, you can convert your elements to Float64 or Float32\
    \ types. \n<code>\njulia> sort_even([5, 6, 3, 1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 1\n</code>\n<code>\njulia> sort_even([5, 6, 3, 1] .|> Float64)\n\
    5-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n 1.0\n</code>\n<code>\njulia> sort_even([5,\
    \ 6, 3, 1] .|> Float32)\n5-element Array{Float32,1}:\n 1.0\n 2.0\n 3.0\n 1.0\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for the explanation. I appreciate\
    \ it.\n<|/ c |>\n<| a tags=julia,sorting |>\nThe answer by is correct, but I thought\
    \ I'd add some explanation.\nThe reason why your function doesn't work is that\
    \ you are trying to sort a vector of Int64 and Int32 types. In Julia, sorting\
    \ is done by converting both elements to their corresponding floating point types\
    \ and then comparing them. Since your elements are Int64, this conversion will\
    \ always succeed and your elements will remain unchanged. To ", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` will sort\
    \ `Int64` arrays lexicographically and `sort_even` will sort `Int64` arrays numerically.\n\
    <|/ c |>\n<| c |>\nI see what you mean. I was thinking about a general solution\
    \ that would work for any type of array. I'll edit my answer to include a solution\
    \ that works for any type of array.\n<|/ c |>\n<| c |>\nI edited my answer to\
    \ include a solution that works for any type of array.\n<|/ c |>\n<| a tags=julia\
    \ |>\nHere is a solution using sortperm:\n<code>", "    even = l[findall(l .%\
    \ 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work\
    \ if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt works fine for me on `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nI guess you meant `sort` instead of `sort!`\n<|/ c |>\n<| c\
    \ |>\nYes, I meant `sort`. Thanks for pointing that out.\n<|/ c |>\n<| a tags=julia\
    \ |>\nHere's a solution using sort!:\n<code>", "    even = l[findall(l .% 2 ==\
    \ 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n  \
    \  even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't work if `l` is an `Int64` array. `sort` will sort `Int64` arrays\
    \ lexicographically, not numerically.\n<|/ c |>\n<| c |>\nI didn't know that.\
    \ Thanks for pointing that out. I've edited my answer to include a version that\
    \ works with `Int64` arrays.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>", " \
    \   even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThanks for your answer! I didn't know about `sortperm` so I learned\
    \ something new today. Unfortunately, the code you provided doesn't work. `sortperm`\
    \ doesn't work on vectors of Int64. `sortperm` only works on vectors of Int. `sortperm`\
    \ doesn't work on vectors of Float64. `sortperm` only works on vectors of Float.\
    \ `sortperm` doesn't work on vectors of Complex. `sortperm` only works on vectors\
    \ of ComplexF64. `sortperm` doesn't work on vectors of ComplexF32. `sortperm`\
    \ only works on vectors of ComplexF16. `sortperm` only works on vectors of ComplexF8.\
    \ `sortperm` only works on vectors of ComplexF32. `sortperm` only works on vectors\
    \ of ComplexF16. `sortperm` only works on vectors of ComplexF8. `sortperm` only\
    \ works on vectors of ComplexF32. `sortperm` only works on vectors of ComplexF16.\
    \ `sortperm` only works on vectors of ComplexF8. `sortperm` only works on vectors\
    \ of ComplexF32. `sortperm` only works on vectors of ComplexF16. `sortperm` only\
    \ works on vectors of ComplexF8. `sortperm` only works on vectors of ComplexF32.\
    \ `sortperm` only works on vectors of ComplexF16. `sortperm` only works on vectors\
    \ of ComplexF8. `sortperm` only works on vectors of ComplexF32. `sortperm` only\
    \ works on vectors of ComplexF16. `sortperm` only works on vectors of ComplexF8.\
    \ `sortperm` only works on vectors of ComplexF32. `sortperm` only works on vectors\
    \ of ComplexF16. `sortperm` only works on vectors of ComplexF8. `sortperm` only\
    \ works on vectors of ComplexF32. `sortperm` only works on vectors of ComplexF16.\
    \ `sortperm` only works on vectors of ComplexF8. `sortperm` only works on vectors\
    \ of ComplexF32. `sortperm` only works on vectors of ComplexF16. `sortperm` only\
    \ works on vectors of ComplexF8. ", "    even = l[findall(l .% 2 == 0)]\n    odd\
    \ = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\nsort_even([5,\
    \ 6, 3, 4])\n</cell>\n<text>\nExercise: Write a function that takes a vector l\
    \ and returns a vector l' such that\n    l' is identical to l in the even indicies,\
    \ while its values at the odd indicies are equal\n    to the values of the odd\
    \ indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n   \
    \ >>> sort_odd([5, 6, 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n\
    \    return even + odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting\
    \ |>\nHere is a solution using sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 5\n 6\n 4", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\nI came up with a solution that is more efficient than sorting\
    \ the entire vector and also more readable than the other solutions posted so\
    \ far.\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .%\
    \ 2 != 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\n`sort` doesn't work for `Array{Int64,1}` either. `sort!` does,\
    \ though.\n<|/ c |>\n<| a dscore=2 |>\nThe accepted answer doesn't work for me.\
    \ Here's a version that does:\n<code>", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = union(even, odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5,\
    \ 4]`\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n\
    \    even = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the idea of sorting in place,\
    \ but this doesn't work for me. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]`\
    \ instead of `[5, 6, 3, 4]`.\n<|/ c |>\n<| c |>\nAh, I see what you're saying.\
    \ You're right. I misunderstood the question. I'll edit my answer.\n<|/ c |>\n\
    <| c |>\nI edited my answer. Sorry for the confusion.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI like James' answer, but here's another approach:\n<code>", "    even =\
    \ l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n\
    \    l = even .+ odd\n    return l\nend\n</cell>\n<text>\nExercise\nWrite a function\
    \ that takes a vector l and returns a vector l' such that\n    l' is identical\
    \ to l in the even indicies, while its values at the odd indicies are equal\n\
    \    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 6, 5, 3]\n  \
    \  \"\"\"", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .==\
    \ 1)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even,\
    \ odd)\n    return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't\
    \ seem to work. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nI edited the answer to fix the bug. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| c |>\nI edited the answer to fix the bug. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a tags=julia |>\nI believe that you can do this in one\
    \ line:\n<code>\njulia> sort(collect(1:10))\n10-element Array{Int64,1}:\n 1\n\
    \ 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ doesn't seem to work. `sort(collect(1:10))` returns `[1,2,3,4,5,6,7,8,9,10]`\
    \ instead of `[1,2,3,4,5,6,7,8,9,10]`.\n<|/ c |>\n<| c |>\nI edited the answer\
    \ to fix the bug. Thanks for pointing it out.\n<|/ c |>\n<| a tags=julia |>\n\
    <code>\njulia> sort(collect(1:10))\n10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\
    \ 5\n 6\n 7\n 8\n 9\n10", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    even.zip(odd).map(x -> x[1])\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n  \
    \  return even .+ odd\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n  \
    \  return even .+ odd\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<|\
    \ c |>\nThanks for your answer. Your solution is very elegant, but unfortunately\
    \ it takes too much time for my arrays. I guess it would be better to implement\
    \ a sorting algorithm myself and use that for my arrays. But thanks anyway!\n\
    <|/ c |>\n<| c |>\nI added a solution that uses `sort` instead of `sort!`\n<|/\
    \ c |>\n<| c |>\nThanks for your answer! I tested it and it works perfectly! I\
    \ guess it would be better to implement a sorting algorithm myself and use that\
    \ for my arrays. But thanks anyway!\n<|/ c |>\n<| c |>\nI added a solution that\
    \ uses `sort` instead of `sort!`\n<|/ c |>\n<| c |>\nThanks for your answer! I\
    \ tested it and it works perfectly! I guess it would be better to implement a\
    \ sorting algorithm myself and use that for my arrays. But thanks anyway!\n<|/\
    \ c |>\n<| a tags=julia,sorting,arrays |>\nThe accepted answer by is very elegant,\
    \ but unfortunately it takes too much time for my arrays. I guess it would be\
    \ better to implement a sorting algorithm myself and use that for my arrays. But\
    \ thanks anyway!\nI implemented a sorting algorithm myself and used that for my\
    \ arrays. I used the merge sort algorithm from Wikipedia to sort my arrays. Here\
    \ is the code:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 .== 1)]\n    even = sort(even)\n    odd = sort(odd)\n    return even .+\
    \ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI like your solution, but I believe\
    \ it can be simplified a bit. `sort_even` can be written as `sort_even = l ->\
    \ sort(l[findall(l .% 2 == 0)])`.\n<|/ c |>\n<| c |>\nI agree, that is a much\
    \ better solution. Thank you for pointing that out.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nI like your solution, but I believe it can be simplified a bit. sort_even\
    \ can be written as sort_even = l -> sort(l[findall(l .% 2 == 0)]). \u2013 Jeff\
    \ P. Bosch May 7 at 20:39\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI like your solution,\
    \ but I believe it can be simplified a bit. sort_even can be written as sort_even\
    \ = l -> sort(l[findall(l .% 2 == 0)]). \u2013 Jeff P. Bosch May 7 at 20:39",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=1 |>\nThe answer by is great, but I wanted to add that you can also use\
    \ sort! to sort the even indices:\n<code>", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n    return\
    \ even .+ odd\nend\n</cell>\n<text>\nExercise\nWrite a function that takes a vector\
    \ l and returns a vector l' such that\n    l' is identical to l in the even indicies,\
    \ while its values at the odd indicies are equal\n    to the values of the odd\
    \ indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n   \
    \ >>> sort_odd([5, 6, 3, 4])\n    [4, 6, 5, 3]\n    \"\"\"", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if you have a vector of\
    \ NaNs. I added an answer that does work if you have NaNs.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n\
    \    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return even\nend\n\
    </cell>\n<code language=julia-1.5>", "    even = l[findall(l .% 2 == 0)]\n   \
    \ odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\n\
    I like this solution, but I wonder if there is a more efficient way to do this.\n\
    <|/ c |>\n<| c |>\nI doubt that there is a more efficient way to do this. But\
    \ you can try `@inbounds` instead of `findall`.\n<|/ c |>\n<| c |>\nI added a\
    \ more efficient solution that uses `@inbounds` instead of `findall`.\n<|/ c |>\n\
    <| a dscore=2 |>\nI believe that this is an example of when to use broadcasting\
    \ instead of looping.\n<code>\njulia> function sort_even(l::Vector{Int64})\n \
    \          even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 .==\
    \ 1)]\n           even = sort_even(even)\n           odd = sort_even(odd)\n  \
    \         return even .+ odd\n       end\nsort_even (generic function with 1 method)",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ .== 1)]\n    even.sort()\n    odd.sort()\n    return even ++ odd\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` doesn't\
    \ work on `Int64` arrays. `sort!` does, but that doesn't help because `sort!`\
    \ doesn't work on `Int64` arrays. `sort!` works on `Array{Int64,1}` arrays, but\
    \ that doesn't help because `sort!` doesn't work on `Array{Int64,1}` arrays. `sort!`\
    \ works on `Array{Int64,2}` arrays, but that doesn't help because `sort!` doesn't\
    \ work on `Array{Int64,2}` arrays. `sort!` works on `Array{Int64,3}` arrays, but\
    \ that doesn't help because `sort!` doesn't work on `Array{Int64,3}` arrays. `sort!`\
    \ works on `Array{Int64,4}` arrays, but that doesn't help because `sort!` doesn't\
    \ work on `Array{Int64,4}` arrays. `sort!` works on `Array{Int64,5}` arrays, but\
    \ that doesn't help because `sort!` doesn't work on `Array{Int64,5}` arrays. `sort!`\
    \ works on `Array{Int64,6}` arrays, but that doesn't help because `sort!` doesn't\
    \ work on `Array{Int64,6}` arrays. `sort!` works on `Array{Int64,7}` arrays, but\
    \ that doesn't help because `sort!` doesn't work on `Array{Int64,7}` arrays. `sort!`\
    \ works on `Array{Int64,8}` arrays, but that doesn't help because `sort!` doesn't\
    \ work on `Array{Int64,8}` arrays. `sort!` works on `Array{Int64,9}` arrays, but\
    \ that doesn't help because `sort!` doesn't work on `Array{Int64,9}` arrays. `sort!`\
    \ works on `Array{Int64,10}` arrays, but that doesn't help because `sort!` doesn't\
    \ work on `Array{Int64,10}` arrays. `sort!` works on `Array{Int64,11}` arrays,\
    \ but that doesn't help because `sort!` doesn't work on `Array{Int64,11}` arrays.\
    \ `sort!` works on `Array{Int64,12}` arrays, but that doesn't help because `sort!`\
    \ doesn't work on `Array{Int64,12}` arrays. `", "    even = l[findall(l .== 0)]\n\
    \    odd = l[findall(l .== 1)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work\
    \ if the vector contains negative numbers. `sort_even([-5, -4, -3, -2, -1, 0,\
    \ 1, 2, 3, 4])` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]` instead of `[-5,\
    \ -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with negative numbers. I tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\n\
    I added a version that works with negative numbers. I tested it on Julia 0.6.2\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's a solution that doesn't require any packages:\n\
    <code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n\
    \    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=1 |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l\
    \ .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even,\
    \ odd)\n    return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't\
    \ work for me. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]`\n<|/ c |>\n<|\
    \ c |>\nI tested it on Julia 1.5.1 and it works. I guess it might have been fixed\
    \ in later versions.\n<|/ c |>\n<| c |>\nYes, it works in Julia 1.5.1. I guess\
    \ it might have been fixed in later versions.\n<|/ c |>\n<| c |>\nI tested it\
    \ on Julia 1.5.1 and it works. I guess it might have been fixed in later versions.\n\
    <|/ c |>\n<| a tags=julia |>\nI came up with a solution using sortperm:\n<code>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])` returns `[1,2,3]`\n\
    <|/ c |>\n<| c |>\nIt works for me. `julia> sort_even([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 1\n 2\n 3`\n<|/ c |>\n<| c |>\nI guess I misunderstood your question. I've edited\
    \ my answer to reflect your question.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ Thanks for your answer!\n<|/ c |>\n<| a |>\nThe answer by is correct but can\
    \ be simplified a bit:\n<code>\nsort_even(l::Vector{Int64}) = sort(l)[findall(l\
    \ .== 0)]\n</code>\n<|/ a tags=julia,sorting,arrays dscore=2 |>\n<| a tags=julia,sorting,arrays\
    \ |>\nI believe that this is what you are looking for:\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=julia,sorting |>\nI like using sortperm:\n<code>\n\
    julia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5",
  "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work for me. `sort_even([5,6,3,4])` returns `[3,6,5,4]` instead of `[3,6,4,5]`.\n\
    <|/ c |>\n<| c |>\nIt works for me in Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested\
    \ it on Julia 0.6.2 and 0.6.3\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and\
    \ 0.6.3\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and 0.6.3\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 != 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n    return\
    \ even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. The only difference is that I used `sort` instead of `sort_even`.\n\
    <|/ c |>\n<| c |>\nOh sorry, I missed the `.` before `%`. My bad.\n<|/ c |>\n\
    <| c |>\nI added a version that works with `Array{Int64,1}`\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a solution that works with Array{Int64,1} and does not require any\
    \ packages:\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n\
    </cell>\n<text>\nExercise: Write a function that takes a vector l and returns\
    \ a vector l' such that\n    l' is identical to l in the even indicies, while\
    \ its values at the odd indicies are equal\n    to the values of the odd indicies\
    \ of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5,\
    \ 6, 3, 4])\n    [4, 5, 6, 3]\n    \"\"\"", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    return\
    \ even .+ odd\nend\n</code>\n<|/ a |>\n<| a tags=sorting,julia |>\nI like to use\
    \ sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n 3\n\
    \ 5\n 6\n 4", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n\
    \    even = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even,\
    \ odd)\n    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia\
    \ |>\nThe answer by is correct, but I thought I'd add some explanation as to why\
    \ it works.\nThe function sort_even is defined as:\n<code>", "    even = l[findall(l\
    \ .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort_even(even)\n    odd\
    \ = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't seem to work. `sort_even([1,2,3])` returns `[1,2,3]` instead\
    \ of `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt does work, try it out. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt doesn't work for me. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works for me too. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works for me too. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| a dscore=1 |>\nI wrote a function that sorts\
    \ an array in O(n) time complexity:\n<code>", "    even = l[findall(l .== 0)]\n\
    \    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n    odd = sort_even(odd)\n\
    \    even = sort(even)\n    odd = sort(odd)\n    even = union(even, odd)\n   \
    \ return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]` instead of `[5,\
    \ 6, 3, 4]`.\n<|/ c |>\n<| c |>\nYes, I missed the fact that `sort` sorts even\
    \ numbers too. Fixed now.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>", "  \
    \  even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`, not `[2,1,3]`.\n<|/ c |>\n<| c |>\nIt does work. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`. `sort_even([5,6,3,4])` returns `[3,6,5,4]`.\n<|/ c |>\n<|\
    \ c |>\nOh sorry, I misread your code. Yes, it does work. Thanks!\n<|/ c |>\n\
    <| a tags=julia,sorting |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n   \
    \ odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2\
    \ != 0)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])`\
    \ returns `[1,2,3]` instead of `[2,1,3]`\n<|/ c |>\n<| c |>\nI fixed the bug,\
    \ thanks for pointing it out. Now it works.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\n<code>", "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n\
    \    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a\
    \ tags=julia,sorting,arrays |>\n<| a dscore=2 |>\nI like using sortperm:\n<code>\n\
    julia> sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n 3\n 2\n 1\n 4\n 5\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't work if your array has\
    \ duplicates. `sortperm([5,5,6,3,4])` returns `5-element Array{Int64,1}:\n 3\n\
    \ 2\n 1\n 4\n 5`\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\n<code>", "    even\
    \ = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nThe answer by is correct, but\
    \ I wanted to add some explanation as to why it works.\nThe reason why it works\
    \ is because Julia's sort function sorts the array in-place. \n<code>\njulia>\
    \ sort([1,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting\
    \ |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n   \
    \        even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 !=\
    \ 0)]\n           even.sort()\n           odd.sort()\n           return even .+\
    \ odd\n       end\nsort_even (generic function with 1 method)", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nI like the\
    \ idea of using `.%` to get the even and odd indices, but this doesn't work if\
    \ `l` is an `Int64` array. `sort` will sort `Int64` arrays lexicographically,\
    \ not numerically.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted my\
    \ answer. Thanks for pointing it out. I've edited my answer to reflect this.\n\
    <|/ c |>\n<| a tags=julia |>\nHere's a solution that uses sortperm:\n<code>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` will sort\
    \ it lexicographically, not numerically.\n<|/ c |>\n<| c |>\nI fixed the code\
    \ so that it works with `Int64` arrays. Thanks for pointing that out.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` will sort it lexicographically,\
    \ not numerically.\n<|/ c |>\n<| c |>\nI fixed the code so that it works with\
    \ `Int64` arrays. Thanks for pointing that out.\n<|/ c |>\n<| a dscore=3 |>\n\
    <code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n\
    \    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 != 0)]\n    even = sort(even)\n    odd = sort(odd)\n    return even .+\
    \ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>", "    even =\
    \ l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=2 |>\nI came up with this solution:\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work for `sort_even([5, 6, 3, 4])` which\
    \ should return `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI fixed the bug and added\
    \ a test case. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=0 |>\nHere's\
    \ a solution that doesn't require any extra packages:\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>",
  "    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a vector l and returns\
    \ a vector l' such that\n    l' is identical to l in the even indicies, while\
    \ its values at the odd indicies are equal\n    to the values of the odd indicies\
    \ of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5,\
    \ 6, 3, 4])\n    [4, 6, 5, 3]\n    \"\"\"", "    even = l[findall(l .% 2 == 0)]\n\
    \    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work if the vector is sorted in descending order. For example, `sort_even([5,\
    \ 6, 3, 4])` returns `[4, 3, 6, 5]`.\n<|/ c |>\n<| c |>\nYes, I noticed that and\
    \ fixed it. I also added a version that doesn't require the vector to be sorted.\n\
    <|/ c |>\n<| a dscore=2 |>\nThis should work:\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    return even .+ odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to\
    \ work. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nI fixed the bug, thanks for pointing it out. Now it should work.\n<|/\
    \ c |>\n<| a dscore=1 |>\nI wrote a function to sort a vector in O(n) time complexity\
    \ and O(1) space complexity:\n<code>", "    even = l[findall(l .% 2 == 0)]\n \
    \   odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,sorting |>\n\
    I like using sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n\
    \ 2\n 3\n 1\n 4\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI like using sortperm:\n\
    <code>\njulia> sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n 2\n 3\n 1\n 4\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| a dscore=0 |>\n<code>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the input vector.\
    \ For example, sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3].\n<|/ c |>\n<| c |>\n\
    It does work if there are duplicates in the input vector. For example, sort_even([1,\
    \ 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2,\
    \ 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2,\
    \ 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or\
    \ sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns\
    \ [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1,\
    \ 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2,\
    \ 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2,\
    \ 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or\
    \ sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns\
    \ [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1,\
    \ 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2,\
    \ 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2,\
    \ 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or\
    \ sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns\
    \ [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1,\
    \ 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2,\
    \ 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2,\
    \ 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns ", "    even =\
    \ l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\nThe answer by is great, but I thought I'd add\
    \ my own solution, since I needed it for something else and I wanted to share\
    \ it.\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .%\
    \ 2 .== 1)]\n    even.sort()\n    odd.sort()\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\n<code>", "    even =\
    \ l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<code language=julia-1.5>", "    even = l[findall(l .== 0)]\n    odd\
    \ = l[findall(l .!= 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n\
    \    return even\nend\n</cell>\n<code language=julia-1.5>", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n    odd.sort()\n\
    \    even.zip(odd) |> collect\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c\
    \ |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nI believe\
    \ this should work for both `Array{Int64,1}` and `Array{Int64,2}`\n<|/ c |>\n\
    <| c |>\nYes, it does. I tested it on Julia 1.5.1\n<|/ c |>\n<| c |>\nI tested\
    \ it on Julia 1.5.1 too. `sort_even([5,6,3,4])` returns `[3, 6, 5, 4]`\n<|/ c\
    \ |>\n<| c |>\nI tested it on Julia 1.5.1 too. `sort_even([5,6,3,4])` returns\
    \ `[3, 6, 5, 4]`\n<|/ c |>\n<| a tags=julia,sorting |>\nThe answer by is correct,\
    \ but I wanted to add that you can also use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 6\n 5\n 4\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This should be the accepted answer. `sortperm` does exactly what OP asked for,\
    \ while `sort` does something completely different.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `sortperm` does exactly what OP asked for, while `sort`\
    \ does something completely different.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `sortperm` does exactly what OP asked for, while `sort` does\
    \ something completely different.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\n\
    julia> sort!([5,6,3,4])\n5-element Array{Int64,1}:\n 3\n 6\n 5\n 4\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer. `sort!` does exactly\
    \ what OP asked for, while `sort` does something completely different.\n<|/ c\
    \ |>\n<| c |>\nThis should be the accepted answer. `", "    even = l[findall(l\
    \ .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n    odd.sort()\n\
    \    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\n<code>", "    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l\
    \ .% 2 != 0)]\n    even.sort()\n    odd.sort()\n    even.extend(odd)\n    return\
    \ even\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\nI came up with a\
    \ solution that is quite simple and does not require any packages:\n<code>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
