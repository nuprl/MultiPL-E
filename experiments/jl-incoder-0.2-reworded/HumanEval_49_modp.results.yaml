language: jl
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 return 1\n    if n==1 return p\n    if p==0 return\
    \ 0\n    if p==1 return 1\n    if p==2 return n\n    if p==3 return modp(2*n-1,\
    \ p)\n    if p==4 return modp(2*n-1, p)\n    if p==5 return modp(2*n-1, p)\n \
    \   if p==6 return modp(2*n-1, p)\n    if p==7 return modp(2*n-1, p)\n    if p==8\
    \ return modp(2*n-1, p)\n    if p==9 return modp(2*n-1, p)\n    if p==10 return\
    \ modp(2*n-1, p)\n    if p==11 return modp(2*n-1, p)\n    if p==12 return modp(2*n-1,\
    \ p)\n    if p==13 return modp(2*n-1, p)\n    if p==14 return modp(2*n-1, p)\n\
    \    if p==15 return modp(2*n-1, p)\n    if p==16 return modp(2*n-1, p)\n    if\
    \ p==17 return modp(2*n-1, p)\n    if p==18 return modp(2*n-1, p)\n    if p==19\
    \ return modp(2*n-1, p)\n    if p==20 return modp(2*n-1, p)\n    if p==21 return\
    \ modp(2*n-1, p)\n    if p==22 return modp(2*n-1, p)\n    if p==23 return modp(2*n-1,\
    \ p)\n    if p==24 return modp(2*n-1, p)\n    if p==25 return modp(2*n-1, p)\n\
    \    if p==26 return modp(2*n-1, p)\n    if p==27 return modp(2*n-1, p)\n    if\
    \ p==28 return modp(2*n-1, p)\n    if p==29 return modp(2*n-1, p)\n    if p==30\
    \ return modp(2*n-1, p)\n    if p==31 return modp(2*n-1, p)\n    if p==32 return\
    \ modp(2*n-1, p)\n    if p==33 return modp(2*n-1, p)\n    if p==34 return modp(2*n-1,\
    \ p)\n    if p==35 return modp(2*n-1, p)\n    if p==36 return modp(2*n-1, p)\n\
    \    if p==37 return modp(2*n-1, p)\n    if p==38 return modp(2*n-1, p)\n    if\
    \ p==39 return modp(2*n-1, p)\n    if p==40 return modp(2*n-1, p)\n    if p==41\
    \ return modp(2*n-1, p)\n    if p==42 return modp(\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcr2b2wq7.jl:61\nin expression starting at\
    \ /tmp/tmpcr2b2wq7.jl:61\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if p < 0 then return modp(-n, p)\n    if p >\
    \ 1 then return modp(n, p - 1)\n    if p < n then return modp(n, p)\n    if p\
    \ > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p - n)\n    if p < n then \nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpo0z08laz.jl:14\nin expression starting at /tmp/tmpo0z08laz.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n == p \n        then return n\n    else if n < p \n        then return modp(n\
    \ - p, p)\n    else if n > p \n        then return modp(n, p - abs(n))\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpr2uwfgei.jl:15\nin expression starting at /tmp/tmpr2uwfgei.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p > 0 \n        then\
    \ return modp(n, p mod n)\n    else return modp(n, p mod n)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfulphqs9.jl:15\nin expression starting at /tmp/tmpfulphqs9.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"modp requires n >= 0\")\n\
    \    elseif p <= 0\n        error(\"modp requires p >= 0\")\n    elseif p < n\n\
    \        error(\"modp requires p >= n\")\n    else\n        modp(n - 1, p)\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf14d21k2.jl:24\nin expression starting at\
    \ /tmp/tmpf14d21k2.jl:24\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(2*n, p)\n    if p==4 then return modp(3*n, p)\n\
    \    if p==5 then return modp(4*n, p)\n    if p==6 then return modp(5*n, p)\n\
    \    if p==7 then return modp(6*n, p)\n    if p==8 then return modp(7*n, p)\n\
    \    if p==9 then return modp(8*n, p)\n    if p==10 then return modp(9*n, p)\n\
    \    if p==11 then return modp(10*n, p)\n    if p==12 then return modp(11*n, p)\n\
    \    if p==13 then return modp(12*n, p)\n    if p==14 then return modp(13*n, p)\n\
    \    if p==15 then return modp(14*n, p)\n    if p==16 then return modp(15*n, p)\n\
    \    if p==17 then return modp(16*n, p)\n    if p==18 then return modp(17*n, p)\n\
    \    if p==19 then return modp(18*n, p)\n    if p==20 then return modp(19*n, p)\n\
    \    if p==21 then return modp(20*n, p)\n    if p==22 then return modp(21*n, p)\n\
    \    if p==23 then return modp(22*n, p)\n    if p==24 then return modp(23*n, p)\n\
    \    if p==25 then return modp(24*n, p)\n    if p==26 then return modp(25*n, p)\n\
    \    if p==27 then return modp(26*n, p)\n    if p==28 then return modp(27*n, p)\n\
    \    if p==29 then return modp(28*n, p)\n    if p==30 then return modp(29*n, p)\n\
    \    if p==31 then return modp(30*n, p)\n    if p==32 then return modp(31*n, p)\n\
    \    if p==33 then return modp(32*n, p)\n    if p==34 then return modp(33*n, p)\n\
    \    if p==35 then return modp(34*n, p)\n    if p==36 then return modp(35*n, p)\n\
    \    if p==37 then return modp(36*n, p)\n    if p==38 then return modp(37*n, p)\n\
    \    if p==39 then return \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm_ro7zfc.jl:14\nin expression starting at /tmp/tmpm_ro7zfc.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return 0\n    if p > p then return 0\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n - 1, p)\n    if p > n then return modp(n, p)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwo8l1iz3.jl:14\nin expression starting at /tmp/tmpwo8l1iz3.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), p)\n    if p > p then return modp(n, p\
    \ - p)\n    if p < p then return modp(n, p - p)\n    return modp(n, p - p)\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpu7_gvka2.jl:14\nin expression starting at /tmp/tmpu7_gvka2.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp() only works with positive\
    \ numbers\")\n    else if n < p \n        return n\n    else \n        return\
    \ modp(n - p, p)\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppumtiqy6.jl:16\nin expression starting at\
    \ /tmp/tmppumtiqy6.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"n must be positive\")\n  \
    \  else if n < p \n        error(\"n must be less than p\")\n    else if n ==\
    \ 0 \n        error(\"n must be positive\")\n    else if p == 0 \n        error(\"\
    p must be positive\")\n    else if p == 1 \n        error(\"p must be odd\")\n\
    \    else if p == -1 \n        error(\"p must be even\")\n    else if p == 2 \n\
    \        error(\"p must be even\")\n    else if p < 2 \n        error(\"p must\
    \ be greater than 2\")\n    else if p < n \n        error(\"p must be greater\
    \ than n\")\n    else \n        return n\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2mvnxzg9.jl:16\nin expression starting at\
    \ /tmp/tmp2mvnxzg9.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if p == 0\
    \ \n        then return 1\n    else if p > n \n        then return modp(n, p mod\
    \ n)\n    else \n        return modp(n, p mod n) \nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmph6evftut.jl:15\nin expression starting at /tmp/tmph6evftut.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        return n\n    else if n == 0 \n \
    \       return p\n    else if p < 0 \n        return modp(-n, p)\n    else if\
    \ n < 0 \n        return modp(-n, p)\n    else if p > 0 \n        return modp(n,\
    \ p - 1)\n    else if n < p \n        return modp(n, p)\n    else \n        return\
    \ modp(n, p - 1)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoxmrysma.jl:16\nin expression starting at\
    \ /tmp/tmpoxmrysma.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return modp(n - 1, p) \n    else return modp(n / p, p) * p\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Return nth root of p (be aware\
    \ of numerics).\n    >>> nthroot(3, 5)\n    1.73205080756888\n    >>> nthroot(1101,\
    \ 101)\n    2.2697182310199\n    >>> nthroot(0, 101)\n    1.0\n    >>> nthroot(3,\
    \ 11)\n    2.82842712474619\n    >>> nthroot(100, 101)\n    1.0\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplkd55u83.jl:14\nin expression starting at /tmp/tmplkd55u83.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if n < p \n   \
    \     then return modp(n, p)\n    else \n        return modp(n, p - n)\nend\n\
    </cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_r4arpfr.jl:15\nin expression starting at /tmp/tmp_r4arpfr.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"n must be positive\")\n  \
    \  else if p < 0\n        error(\"p must be positive\")\n    else if n == 0\n\
    \        error(\"n must be positive\")\n    else if p == 0\n        error(\"p\
    \ must be positive\")\n    else if p == 1\n        return n\n    else if p ==\
    \ -1\n        return -n\n    else if p == 2\n        return mod2(n)\n    else\
    \ if p == 3\n        return mod3(n)\n    else if p == 4\n        return mod4(n)\n\
    \    else if p == 5\n        return mod5(n)\n    else if p == 6\n        return\
    \ mod6(n)\n    else if p == 7\n        return mod7(n)\n    else if p == 8\n  \
    \      return mod8(n)\n    else if p == 9\n        return mod9(n)\n    else if\
    \ p == 10\n        return mod10(n)\n    else if p == 11\n        return mod11(n)\n\
    \    else if p == 12\n        return mod12(n)\n    else if p == 13\n        return\
    \ mod13(n)\n    else if p == 14\n        return mod14(n)\n    else if p == 15\n\
    \        return mod15(n)\n    else if p == 16\n        return mod16(n)\n    else\
    \ if p == 17\n        return mod17(n)\n    else if p == 18\n        return mod18(n)\n\
    \    else if p == 19\n        return mod19(n)\n    else if p == 20\n        return\
    \ mod20(n)\n    else if p == 21\n        return mod21(n)\n    else if p == 22\n\
    \        return mod22(n)\n    else if p == 23\n        return mod23(n)\n    else\
    \ if p == 24\n        return mod24(n)\n    else if p == 25\n        return mod25(n)\n\
    \    else if p == 26\n        return mod26(n)\n    else if p == 27\n        return\
    \ mod27(n)\n    else if p == 28\n        return mod28(n)\n    else if p == 29\n\
    \        return mod29(n)\n    else if p == 30\n        return mod30(n)\n    else\
    \ if p == 31\n        return mod31(n)\n    else if p == 32\n        return mod32(n)\n\
    \    else if p == 33\n        return mod33(n)\n    else if p == 34\n        return\
    \ mod34(n)\n    else if p == 35\n        return mod35(n)\n    else if p == 36\n\
    \        return mod36(n)\n    else if p == 37\n        return mod37(n)\n    else\
    \ if p == 38\n        return mod38(n)\n    else if p == 39\n        return mod39(n)\n\
    \    else \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaqrhonqr.jl:16\nin expression starting at\
    \ /tmp/tmpaqrhonqr.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n >= p\
    \ \n        then return n - p\n        else return modp(n - p, p)\n    end\nend\n\
    </cell>\n<code language=julia-1.3>\n\"\"\"Return n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpy5fsa6_p.jl:15\nin expression starting at /tmp/tmpy5fsa6_p.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p < 0\
    \ \n        then return modp(abs(n), abs(p))\n    else if n < 0 \n        then\
    \ return modp(abs(n), abs(p))\n    else if p < 1 \n        then return modp(abs(n),\
    \ p)\n    else if n < 1 \n        then return modp(n, abs(p))\n    else if p <\
    \ 2 \n        then return modp(n, p)\n    else if n < 2 \n        then return\
    \ modp(abs(n), p)\n    else if p < 3 \n        then return modp(n, p)\n    else\
    \ if n < 3 \n        then return modp(abs(n), p)\n    else if p < 4 \n       \
    \ then return modp(n, p)\n    else if n < 4 \n        then return modp(abs(n),\
    \ p)\n    else if p < 5 \n        then return modp(n, p)\n    else if n < 5 \n\
    \        then return modp(abs(n), p)\n    else if p < 6 \n        then return\
    \ modp(n, p)\n    else if n < 6 \n        then return modp(abs(n), p)\n    else\
    \ if p < 7 \n        then return modp(n, p)\n    else if n < 7 \n        then\
    \ return modp(abs(n), p)\n    else if p < 8 \n        then return modp(n, p)\n\
    \    else if n < 8 \n        then return modp(abs(n), p)\n    else if p < 9 \n\
    \        then return modp(n, p)\n    else if n < 9 \n        then return modp(abs(n),\
    \ p)\n    else if p < 10 \n        then return modp(n, p)\n    else if n < 10\
    \ \n        then return modp(abs(n), p)\n    else if p < 11 \n        then return\
    \ modp(n, p)\n    else if n < 11 \n        then return modp(abs(n), p)\n    else\
    \ if p < 12 \n        then return modp(n, p)\n    else if n < 12 \n        then\
    \ return modp(abs(n), p)\n    else if p < 13 \n        then return modp(n, p)\n\
    \    else if n < 13 \n        then return modp(abs(n), p)\n    else if p < 14\
    \ \n        then return modp(n, p)\n    else if n < 14 \n        then return modp(abs(n),\
    \ p)\n    else if p < 15 \n        then return modp(n, p)\n    else if n < 15\
    \ \n        then return modp(abs(n), p)\n    else \nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7odmoqpd.jl:15\nin expression starting at /tmp/tmp7odmoqpd.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then n \n        else modp(n - p,\
    \ p)\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4y227kya.jl:15\nin expression starting at /tmp/tmp4y227kya.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 return 1\n    if n==1 return p\n    if p==0 return\
    \ 0\n    if p==1 return 1\n    if p==2 return n\n    if p==3 return modp(n-1,\
    \ 2)\n    if p==4 return modp(n-1, 3)\n    if p==5 return modp(n-1, 4)\n    if\
    \ p==6 return modp(n-1, 5)\n    if p==7 return modp(n-1, 6)\n    if p==8 return\
    \ modp(n-1, 7)\n    if p==9 return modp(n-1, 8)\n    if p==10 return modp(n-1,\
    \ 9)\n    if p==11 return modp(n-1, 10)\n    if p==12 return modp(n-1, 11)\n \
    \   if p==13 return modp(n-1, 12)\n    if p==14 return modp(n-1, 13)\n    if p==15\
    \ return modp(n-1, 14)\n    if p==16 return modp(n-1, 15)\n    if p==17 return\
    \ modp(n-1, 16)\n    if p==18 return modp(n-1, 17)\n    if p==19 return modp(n-1,\
    \ 18)\n    if p==20 return modp(n-1, 19)\n    if p==21 return modp(n-1, 20)\n\
    \    if p==22 return modp(n-1, 21)\n    if p==23 return modp(n-1, 22)\n    if\
    \ p==24 return modp(n-1, 23)\n    if p==25 return modp(n-1, 24)\n    if p==26\
    \ return modp(n-1, 25)\n    if p==27 return modp(n-1, 26)\n    if p==28 return\
    \ modp(n-1, 27)\n    if p==29 return modp(n-1, 28)\n    if p==30 return modp(n-1,\
    \ 29)\n    if p==31 return modp(n-1, 30)\n    if p==32 return modp(n-1, 31)\n\
    \    if p==33 return modp(n-1, 32)\n    if p==34 return modp(n-1, 33)\n    if\
    \ p==35 return modp(n-1, 34)\n    if p==36 return modp(n-1, 35)\n    if p==37\
    \ return modp(n-1, 36)\n    if p==38 return modp(n-1, 37)\n    if p==39 return\
    \ modp(n-1, 38)\n    if p==40 return modp(n-1, 39)\n    if p==41 return modp(n-1,\
    \ 40)\n    if p==42 return modp(n-1, 41)\n    if p==43 return modp(n-1, 42)\n\
    \    if p==44 return modp(n\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppiekhsci.jl:61\nin expression starting at\
    \ /tmp/tmppiekhsci.jl:61\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1 \n    if n==1 then return p \n\
    \    if p==0 then return 1 \n    if p==1 then return n \n    if p==2 then return\
    \ n*n \n    if p==3 then return n*n*n \n    if p==4 then return n*n*n*n \n   \
    \ if p==5 then return n*n*n*n*n \n    if p==6 then return n*n*n*n*n*n \n    if\
    \ p==7 then return n*n*n*n*n*n*n \n    if p==8 then return n*n*n*n*n*n*n*n \n\
    \    if p==9 then return n*n*n*n*n*n*n*n*n \n    if p==10 then return n*n*n*n*n*n*n*n*n*n\
    \ \n    if p==11 then return n*n*n*n*n*n*n*n*n*n \n    if p==12 then return n*n*n*n*n*n*n*n*n*n*n\
    \ \n    if p==13 then return n*n*n*n*n*n*n*n*n*n*n*n \n    if p==14 then return\
    \ n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==15 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    if p==16 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==17 then return\
    \ n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==18 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    if p==19 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==20 then\
    \ return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==21 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    if p==22 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==23 then\
    \ return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==24 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    if p==25 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==26\
    \ then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    if p==27 then return n*n*n*n*n*n*n*n*\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpy4q_fac8.jl:14\nin expression starting at /tmp/tmpy4q_fac8.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if n <= p then return modp(n + p - 1, p)\n    \n    \n\"\"\"\n    modpow(n::Int64,\
    \ p::Int64)::Int64\n    \n    Raise a number to a power, modulo p (be aware of\
    \ numerics).\n    >>> modpow(3, 5)\n    3\n    >>> modpow(1101, 101)\n    2\n\
    \    >>> modpow(0, 101)\n    1\n    >>> modpow(3, 11)\n    8\n    >>> modpow(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpt3x4r_xy.jl:14\nin expression starting at /tmp/tmpt3x4r_xy.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if p < n \n   \
    \     then return modp(n, p)\n    else if n < p \n        then return modp(n,\
    \ p)\n    else return modp(n, p)\nend\n</cell>\n<code language=julia-1.1>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwg7uxrnt.jl:15\nin expression starting at /tmp/tmpwg7uxrnt.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then return n \n        else return\
    \ modp(n - p, p)\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpffycxnqo.jl:15\nin expression starting at /tmp/tmpffycxnqo.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n >= p\n\
    \        then return p\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpj7n3ik5c.jl:15\nin expression starting at /tmp/tmpj7n3ik5c.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return n % p\n    else return modp(n - p, p)\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"Return n modulo p (be aware of numerics).\n \
    \   >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjhxg5e0z.jl:14\nin expression starting at /tmp/tmpjhxg5e0z.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if n < p \n   \
    \     then return modp(n, p)\n    else return modp(n, p - 1)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgj67qoxm.jl:15\nin expression starting at /tmp/tmpgj67qoxm.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if n < 0 then return\
    \ modp(-n, p)\n    else if p == 0 then return 0\n    else if p < 0 then return\
    \ modp(-n, p)\n    else if p < n then return modp(n, p)\n    else return modp(n\
    \ + p - 1, p)\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmppncuvo5f.jl:14\nin expression starting at /tmp/tmppncuvo5f.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(2*n, p)\n    if p==4 then return modp(3*n, p)\n\
    \    if p==5 then return modp(4*n, p)\n    if p==6 then return modp(5*n, p)\n\
    \    if p==7 then return modp(6*n, p)\n    if p==8 then return modp(7*n, p)\n\
    \    if p==9 then return modp(8*n, p)\n    if p==10 then return modp(9*n, p)\n\
    \    if p==11 then return modp(10*n, p)\n    if p==12 then return modp(11*n, p)\n\
    \    if p==13 then return modp(12*n, p)\n    if p==14 then return modp(13*n, p)\n\
    \    if p==15 then return modp(14*n, p)\n    if p==16 then return modp(15*n, p)\n\
    \    if p==17 then return modp(16*n, p)\n    if p==18 then return modp(17*n, p)\n\
    \    if p==19 then return modp(18*n, p)\n    if p==20 then return modp(19*n, p)\n\
    \    if p==21 then return modp(20*n, p)\n    if p==22 then return modp(21*n, p)\n\
    \    if p==23 then return modp(22*n, p)\n    if p==24 then return modp(23*n, p)\n\
    \    if p==25 then return modp(24*n, p)\n    if p==26 then return modp(25*n, p)\n\
    \    if p==27 then return modp(26*n, p)\n    if p==28 then return modp(27*n, p)\n\
    \    if p==29 then return modp(28*n, p)\n    if p==30 then return modp(29*n, p)\n\
    \    if p==31 then return modp(30*n, p)\n    if p==32 then return modp(31*n, p)\n\
    \    if p==33 then return modp(32*n, p)\n    if p==34 then return modp(33*n, p)\n\
    \    if p==35 then return modp(34*n, p)\n    if p==36 then return modp(35*n, p)\n\
    \    if p==37 then return modp(36*n, p)\n    if p==38 then return modp(37*n, p)\n\
    \    if p==39 then return \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm_ro7zfc.jl:14\nin expression starting at /tmp/tmpm_ro7zfc.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(p, n)\nend\n</code>\n<|/ a tags=math,julia |>\n\
    <| c |>\nI like your solution, but I believe that `modp(n - 1, p) == modp(p, n)`\
    \ should be `modp(n - 1, p) == modp(p, n)`. Otherwise you get an infinite recursion.\n\
    <|/ c |>\n<| c |>\nThanks, I fixed it.\n<|/ c |>\n<| a tags=math,julia |>\nA simple\
    \ solution is to use modular arithmetic:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcpr5hbo3.jl:15\nin expression starting at /tmp/tmpcpr5hbo3.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return 1\n    else\
    \ if p == 2 \n        then return n\n    else if p == 3 \n        then return\
    \ n+1\n    else if p == 4 \n        then return n*2\n    else if p == 5 \n   \
    \     then return n*3\n    else if p == 6 \n        then return n*4\n    else\
    \ if p == 7 \n        then return n*5\n    else if p == 8 \n        then return\
    \ n*6\n    else if p == 9 \n        then return n*7\n    else if p == 10 \n  \
    \      then return n*8\n    else if p == 11 \n        then return n*9\n    else\
    \ if p == 12 \n        then return n*10\n    else if p == 13 \n        then return\
    \ n*11\n    else if p == 14 \n        then return n*12\n    else if p == 15 \n\
    \        then return n*13\n    else if p == 16 \n        then return n*14\n  \
    \  else if p == 17 \n        then return n*15\n    else if p == 18 \n        then\
    \ return n*16\n    else if p == 19 \n        then return n*17\n    else if p ==\
    \ 20 \n        then return n*18\n    else if p == 21 \n        then return n*19\n\
    \    else if p == 22 \n        then return n*20\n    else if p == 23 \n      \
    \  then return n*21\n    else if p == 24 \n        then return n*22\n    else\
    \ if p == 25 \n        then return n*23\n    else if p == 26 \n        then return\
    \ n*24\n    else if p == 27 \n        then return n*25\n    else if p == 28 \n\
    \        then return n*26\n    else if p == 29 \n        then return n*27\n  \
    \  else if p == 30 \n        then return n*28\n    else if p == 31 \n        then\
    \ return n*29\n    else if p == 32 \n        then return n*30\n    else if p ==\
    \ 33 \n        then return n*31\n    else if p == 34 \n        then return n*32\n\
    \    else if p == 35 \n        then return n*33\n    else if p == 36 \n      \
    \  then return n*34\n    else if p == 37 \n        then return n*35\n    else\
    \ if p == 38 \n        then return n*36\n    else if p == 39\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4wdx4axw.jl:15\nin expression starting at /tmp/tmp4wdx4axw.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 return 1\n    if n==1 return p\n    return modp(mod(n,\
    \ p), p)\nend\n</cell>\n<code language=julia-1.1>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnwmunhol.jl:18\nin expression starting at\
    \ /tmp/tmpnwmunhol.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return 1\n    if n % p == 0 then return modp(n / p, p)\n \
    \   else return modp(n / p, p) * modp(p, n)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpc_6yrbad.jl:14\nin expression starting at /tmp/tmpc_6yrbad.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(abs(n), abs(p))\n    else if n < 0 \n  \
    \      then return modp(abs(n), abs(p))\n    else if n == p \n        then return\
    \ n\n    else if n < p \n        then return modp(n - p, p)\n    else return modp(n,\
    \ p - n)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp180v0qxg.jl:15\nin expression starting at /tmp/tmp180v0qxg.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n*(n+1)/2\n    if p==4 then return n*(n+1)*(2*n+1)/6\n\
    \    if p==5 then return n*(n+1)*(2*n+1)*(3*n+1)/24\n    if p==6 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)/120\n\
    \    if p==7 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)/720\n    if p==8\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)/5040\n    if p==9\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)/40320\n\
    \    if p==10 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)/36288\n\
    \    if p==11 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)/67108864\n\
    \    if p==12 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)/134217728\n\
    \    if p==13 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)/268435456\n\
    \    if p==14 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31*n+1)/393216\n\
    \    if p==15 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe2rnepc1.jl:14\nin expression starting at /tmp/tmpe2rnepc1.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if p == 0\
    \ \n        then return 1\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n == 0 \n        then return 0\n    else if n == 1 \n        then return\
    \ p\n    else if n == p \n        then return 1\n    else if n < p \n        then\
    \ return modp(n - p, p)\n    else if n < p \n        then return modp(n - p, p)\n\
    \    else \n        then return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgnvpqmgf.jl:15\nin expression starting at /tmp/tmpgnvpqmgf.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), -p) \n    if p > p then return modp(n,\
    \ abs(p))\n    return modp(n, p)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm2eqv1za.jl:14\nin expression starting at /tmp/tmpm2eqv1za.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if n <= p then return modp(n - p, p)\n\
    \    else return modp((p - 1) * (n - p), p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptugvnkeh.jl:14\nin expression starting at /tmp/tmptugvnkeh.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n-1, p)\n    else if n > p \n        then\
    \ return modp(n, p-n)\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpeooi5mp4.jl:15\nin expression starting at /tmp/tmpeooi5mp4.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else if n > p \n        then\
    \ return modp(n, p - abs(n))\n    else return modp(n - p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpt95cetkm.jl:15\nin expression starting at /tmp/tmpt95cetkm.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if n < 0\n\
    \        then return modp(-n, p)\n    else if p == 0\n        then return 0\n\
    \    else if p < 0\n        then return modp(-n, p)\n    else if p < n\n     \
    \   then return modp(n, p)\n    else return modp(n-1, p)\nend\n</cell>\n<code\
    \ language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmppscpietu.jl:15\nin expression starting at /tmp/tmppscpietu.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        return 1 \n    else if n==1 \n    \
    \    return p \n    else if p==0 \n        return 0 \n    else if p==1 \n    \
    \    return n \n    else if p==2 \n        return n \n    else if p==3 \n    \
    \    return n-1 \n    else if p==4 \n        return n-2 \n    else if p==5 \n\
    \        return n-3\n    else if p==6 \n        return n-4\n    else if p==7 \n\
    \        return n-5\n    else if p==8 \n        return n-6\n    else if p==9 \n\
    \        return n-7\n    else if p==10 \n        return n-8\n    else if p==11\
    \ \n        return n-9\n    else if p==12 \n        return n-10\n    else if p==13\
    \ \n        return n-11\n    else if p==14 \n        return n-12\n    else if\
    \ p==15 \n        return n-13\n    else if p==16 \n        return n-14\n    else\
    \ if p==17 \n        return n-15\n    else if p==18 \n        return n-16\n  \
    \  else if p==19 \n        return n-17\n    else if p==20 \n        return n-18\n\
    \    else if p==21 \n        return n-19\n    else if p==22 \n        return n-20\n\
    \    else if p==23 \n        return n-21\n    else if p==24 \n        return n-22\n\
    \    else if p==25 \n        return n-23\n    else if p==26 \n        return n-24\n\
    \    else if p==27 \n        return n-25\n    else if p==28 \n        return n-26\n\
    \    else if p==29 \n        return n-27\n    else if p==30 \n        return n-28\n\
    \    else if p==31 \n        return n-29\n    else if p==32 \n        return n-30\n\
    \    else if p==33 \n        return n-31 \n    else if p==34 \n        return\
    \ n-32\n    else if p==35 \n        return n-33\n    else if p==36 \n        return\
    \ n-34\n    else if p==37 \n        return n-35\n    else if p==38 \n        return\
    \ n-36\n    else if p==39 \n        return n-37\n    else if p==40 \n        return\
    \ n-38\n    else if p==41 \n        return n-39\n    else if p==42 \n        return\
    \ n-40\n    else if p==43 \n        return n-41\n    else if p\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk_m9opdm.jl:16\nin expression starting at\
    \ /tmp/tmpk_m9opdm.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p) \n    else return modp(n + p - 1, p)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_2vm0rgl.jl:15\nin expression starting at /tmp/tmp_2vm0rgl.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if n == p then return 1\n    if n <= p then return modp(n - p, p)\n    return\
    \ modp((n - p) * (n - p + 1), p)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkb9yqx3m.jl:14\nin expression starting at /tmp/tmpkb9yqx3m.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"n must be positive\")\n  \
    \  else if p == 0 \n        error(\"p must be positive\")\n    else if p < 0 \n\
    \        error(\"p must be positive\")\n    else if n < p \n        error(\"n\
    \ must be greater than p\")\n    else if n == 0 \n        error(\"n must be positive\"\
    )\n    else if n == p \n        error(\"n must be equal to p\")\n    else if n\
    \ == 1 \n        error(\"n must be greater than 1\")\n    else if n == p \n  \
    \      error(\"n must be equal to p\")\n    else if n == p \n        error(\"\
    n must be equal to p\")\n    else if n == p \n        error(\"n must be equal\
    \ to p\")\n    else if n == p \n        error(\"n must be equal to p\")\n    else\
    \ if n == p \n        error(\"n must be equal to p\")\n    else if n == p \n \
    \       error(\"n must be equal to p\")\n    else if n == p \n        error(\"\
    n must be equal to p\")\n    else if n == p \n        error(\"n must be equal\
    \ to p\")\n    else if n == p \n        error(\"n must be equal to p\")\n    else\
    \ if n == p \n        error(\"n must be equal to p\")\n    else if n == p \n \
    \       error(\"n must be equal to p\")\n    else if n == p \n        error(\"\
    n must be equal to p\")\n    else if n == p \n        error(\"n must be equal\
    \ to p\")\n    else if n == p \n        error(\"n must be equal to p\")\n    else\
    \ if n == p \n        error(\"n must be equal to p\")\n    else if n == p \n \
    \       error(\"n must be equal to p\")\n    else if n == p \n        error(\"\
    n must be equal to p\")\n    else if n == p \n        error(\"n must be equal\
    \ to p\")\n    else if n == p \n        error(\"n must be equal to p\")\n    else\
    \ if n == p \n        error(\"n must be equal to p\")\n    else if n == p \n \
    \       error(\"n must be equal to p\")\n    else if n == p \n        error(\"\
    n must be equal to p\")\n    else if n == p \n        error(\"n must be equal\
    \ to p\")\n    else if n == p \n        error(\"n must be equal to p\")\n    else\
    \ if n == p \n        error(\"n must be equal to p\")\n    else if n == p \n \
    \       error(\"n must be equal to p\")\n    else if n == p \n        error(\"\
    n must be equal to p\")\n    else if n == p \n        error(\"n must be equal\
    \ to p\")\n    else if n == p \n        error(\"n must be equal to p\")\n    else\
    \ if n == p \n        error(\"n must be equal to p\")\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwkg664xa.jl:16\nin expression starting at\
    \ /tmp/tmpwkg664xa.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p then return n else return n % p\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpi0kphwsr.jl:14\nin expression starting at /tmp/tmpi0kphwsr.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        error(\"modp() called with negative\
    \ arguments\")\n    else if p <= 0 \n        error(\"modp() called with negative\
    \ arguments\")\n    else if p < n\n        error(\"modp() called with p smaller\
    \ than n\")\n    else if p == 0 \n        error(\"modp() called with p equal to\
    \ 0\")\n    else if p == n \n        error(\"modp() called with p equal to n\"\
    )\n    else if p == 1 \n        return n\n    else if p == 2 \n        return\
    \ n-1\n    else if p == 3 \n        return n-2\n    else if p == 4 \n        return\
    \ n-3\n    else if p == 5 \n        return n-4\n    else if p == 6 \n        return\
    \ n-5\n    else if p == 7 \n        return n-6\n    else if p == 8 \n        return\
    \ n-7\n    else if p == 9 \n        return n-8\n    else if p == 10 \n       \
    \ return n-9\n    else if p == 11 \n        return n-10\n    else if p == 12 \n\
    \        return n-11\n    else if p == 13 \n        return n-12\n    else if p\
    \ == 14 \n        return n-13\n    else if p == 15 \n        return n-14\n   \
    \ else if p == 16 \n        return n-15\n    else if p == 17 \n        return\
    \ n-16\n    else if p == 18 \n        return n-17\n    else if p == 19 \n    \
    \    return n-18\n    else if p == 20 \n        return n-19\n    else if p ==\
    \ 21 \n        return n-20\n    else if p == 22 \n        return n-21\n    else\
    \ if p == 23 \n        return n-22\n    else if p == 24 \n        return n-23\n\
    \    else if p == 25 \n        return n-24\n    else if p == 26 \n        return\
    \ n-25\n    else if p == 27 \n        return n-26\n    else if p == 28 \n    \
    \    return n-27\n    else if p == 29 \n        return n-28\n    else if p ==\
    \ 30 \n        return n-29\n    else if p == 31 \n        return n-30\n    else\
    \ if p == 32 \n        return n-31\n    else if p == 33 \n        return n-32\n\
    \    else if p == 34 \n        return n-33\n    else if p == 35 \n        return\
    \ n-34\n    else if p == 36 \n        return n-35\n    else if p == 37 \n    \
    \    return n-36\n    else if p == 38 \n        return n-37\n    else if p ==\
    \ 39 \n        return n-\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplxuy5wsz.jl:16\nin expression starting at\
    \ /tmp/tmplxuy5wsz.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"n must be positive\")\n  \
    \  end\n    if p <= 0\n        error(\"p must be positive\")\n    end\n    if\
    \ p == 0 || n == 0\n        error(\"p and n must be nonzero\")\n    end\n    if\
    \ p > n\n        error(\"p must be smaller than n\")\n    end\n    if n == 1\n\
    \        return p\n    end\n    if p == 1\n        return n\n    end\n    if p\
    \ == 0 || n == 1\n        return p\n    end\n    if p == 1 && n == 1\n       \
    \ return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n    if\
    \ p == 0 || n == 0\n        return p\n    end\n    if p == 1 && n == 1\n     \
    \   return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n  \
    \  if p == 0 || n == 1\n        return p\n    end\n    if p == 1 && n == 1\n \
    \       return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 0\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 1\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 0\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 1\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 0\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 1\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 0\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 1\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if p == 0 || n == 0\n        return p\n    end\n    if p == 1 && n == 1\n\
    \        return p\n    end\n    if p == 1 && n == 0\n        return n\n    end\n\
    \    if \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing condition in \"if\" at /tmp/tmpsfa9oahg.jl:140\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpsfa9oahg.jl:141\nin expression\
    \ starting at /tmp/tmpsfa9oahg.jl:141\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n <= p \n\
    \        then return modp(n - p, p) \n    else return modp(n, p - n)\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"Return nth root of p (be aware of numerics).\n\
    \    >>> rootp(3, 5)\n    1.73205080756888\n    >>> rootp(1101, 101)\n    1.1102230246251565\n\
    \    >>> rootp(0, 101)\n    1\n    >>> rootp(3, 11)\n    1.73205080756888\n  \
    \  >>> rootp(100, 101)\n    1.1102230246251565\n\"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpu_3oyt7i.jl:15\nin expression starting at /tmp/tmpu_3oyt7i.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1 \n    else if n==1 then return\
    \ p \n    else if p==0 then return 1 \n    else if p==1 then return n \n    else\
    \ return modp(n mod p, p) \nend \n\"\"\"\n    \n\"\"\"\n    modpow(n::Int64, p::Int64,\
    \ modp::Int64)::Int64\n    \nReturn the value 2**n*p modulo modp.\n    >>> modpow(3,\
    \ 5, 3)\n    8\n    >>> modpow(3, 5, 4)\n    9\n    >>> modpow(3, 5, 5)\n    3\n\
    \    >>> modpow(3, 5, 6)\n    3\n    >>> modpow(3, 5, 7)\n    3\n    >>> modpow(3,\
    \ 5, 8)\n    3\n    >>> modpow(3, 5, 9)\n    3\n    >>> modpow(3, 5, 10)\n   \
    \ 3\n    >>> modpow(3, 5, 11)\n    3\n    >>> modpow(3, 5, 12)\n    3\n    >>>\
    \ modpow(3, 5, 13)\n    3\n    >>> modpow(3, 5, 14)\n    3\n    >>> modpow(3,\
    \ 5, 15)\n    3\n    >>> modpow(3, 5, 16)\n    3\n    >>> modpow(3, 5, 17)\n \
    \   3\n    >>> modpow(3, 5, 18)\n    3\n    >>> modpow(3, 5, 19)\n    3\n    >>>\
    \ modpow(3, 5, 20)\n    3\n    >>> modpow(3, 5, 21)\n    3\n    >>> modpow(3,\
    \ 5, 22)\n    3\n    >>> modpow(3, 5, 23)\n    3\n    >>> modpow(3, 5, 24)\n \
    \   3\n    >>> modpow(3, 5, 25)\n    3\n    >>> modpow(3, 5, 26)\n    3\n    >>>\
    \ modpow(3, 5, 27)\n    3\n    >>> modpow(3, 5, 28)\n    3\n    >>> modpow(3,\
    \ 5, 29)\n    3\n    >>> modpow(3, 5, 30)\n    3\n    >>> modpow(3, 5, 31)\n \
    \   3\n    >>> modpow(3, 5, 32)\n    3\n    >>> modpow(3, 5, 33)\n    3\n    >>>\
    \ modpow(3, 5, 34)\n    3\n    >>> modpow(3, 5, 35)\n    3\n    >>> modpow(3,\
    \ 5, 36)\n    3\n    >>> modpow(3, 5, 37)\n    3\n    >>> modpow(3, 5, 38)\n \
    \   3\n    >>> modpow(3, 5, 39)\n    3\n    >>> modpow(3, 5, 40)\n    3\n    >>>\
    \ modpow(3, 5, 41)\n    3\n    >>> modpow(3, 5, 42)\n    3\n    >>> modpow(3,\
    \ 5, 43)\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpse3ymhc3.jl:14\nin expression starting at /tmp/tmpse3ymhc3.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n < 0\
    \ \n        then return modp(-n, p)\n    else if p < 0 \n        then return modp(-n,\
    \ -p) \n    else if n < p \n        then return modp(n, -p)\n    else if n ==\
    \ p \n        then return 1\n    else return modp(n + p - 1, p)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7z3qcly5.jl:15\nin expression starting at /tmp/tmp7z3qcly5.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if n == p then return 0\n    if n < p then return modp(n, p)\n    if n < 0\
    \ then return modp(-n, p)\n    return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_e3x6v5p.jl:14\nin expression starting at /tmp/tmp_e3x6v5p.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p then return n else return n % p\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpf7nuwbqj.jl:14\nin expression starting at /tmp/tmpf7nuwbqj.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(-n, p)\n    if p > p then return modp(n, p)\n \
    \   if p < p then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n \
    \   if p > 0 then return modp(n, p)\n    if p > p then return modp(n, p)\n   \
    \ if p < 0 then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n   \
    \ if p > 0 then return modp(n, p)\n    if p > p then return modp(n, p)\n    if\
    \ p < 0 then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if\
    \ p > 0 then return modp(n, p)\n    if p > p then return modp(n, p)\n    if p\
    \ < 0 then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if p\
    \ > 0 then return modp(n, p)\n    if p > p then return modp(n, p)\n    if p <\
    \ 0 then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if p >\
    \ 0 then return modp(n, p)\n    if p > p then return modp(n, p)\n    if p < 0\
    \ then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if p > 0\
    \ then return modp(n, p)\n    if p > p then return modp(n, p)\n    if p < 0 then\
    \ return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if p > 0 then\
    \ return modp(n, p)\n    if p > p then return modp(n, p)\n    if p < 0 then return\
    \ modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if p > 0 then return\
    \ modp(n, p)\n    if p > p then return modp(n, p)\n    if p < 0 then return modp(-n,\
    \ p)\n    if p < 0 then return modp(-n, p)\n    if p > 0 then return modp(n, p)\n\
    \    if p > p then return modp(n, p)\n    if p < 0 then return modp(-n, p)\n \
    \   if p < 0 then return modp(-n, p)\n    if p > 0 then return modp(n, p)\n  \
    \  if p > p then return modp(n, p)\n    if p < 0 then return modp(-n, p)\n   \
    \ if p < \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvngixsll.jl:14\nin expression starting at /tmp/tmpvngixsll.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p == 0 then return 0\n    if p < 0 then return modp(-n, p)\n    if p >\
    \ p then return modp(n, p)\n    if p < p then return modp(-n, p)\n    if p < 0\
    \ then return modp(-n, p)\n    if p > 0 then return modp(n, p)\n    if p > p then\
    \ return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if p > 0 then\
    \ return modp(n, p)\n    if p > p then return modp(-n, p)\n    if p < 0 then return\
    \ modp(-n, p)\n    if p > 0 then return modp(n, p)\n    if p > p then return modp(-n,\
    \ p)\n    if p < 0 then return modp(-n, p)\n    if p > 0 then return modp(n, p)\n\
    \    if p > p then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n\
    \    if p > 0 then return modp(n, p)\n    if p > p then return modp(-n, p)\n \
    \   if p < 0 then return modp(-n, p)\n    if p > 0 then return modp(n, p)\n  \
    \  if p > p then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n  \
    \  if p > 0 then return modp(n, p)\n    if p > p then return modp(-n, p)\n   \
    \ if p < 0 then return modp(-n, p)\n    if p > 0 then return modp(n, p)\n    if\
    \ p > p then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if\
    \ p > 0 then return modp(n, p)\n    if p > p then return modp(-n, p)\n    if p\
    \ < 0 then return modp(-n, p)\n    if p > 0 then return modp(n, p)\n    if p >\
    \ p then return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if p >\
    \ 0 then return modp(n, p)\n    if p > p then return modp(-n, p)\n    if p < 0\
    \ then return modp(-n, p)\n    if p > 0 then return modp(n, p)\n    if p > p then\
    \ return modp(-n, p)\n    if p < 0 then return modp(-n, p)\n    if p > 0 then\
    \ return modp(n, p)\n    if p > p then return modp(-n, p)\n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpis0wu21y.jl:14\nin expression starting at /tmp/tmpis0wu21y.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if n==2 then return p+1\n    if n==3 then return p+2\n    if n==4 then return\
    \ p+4\n    if n==5 then return p+8\n    if n==6 then return p+16\n    if n==7\
    \ then return p+32\n    if n==8 then return p+64\n    if n==9 then return p+128\n\
    \    if n==10 then return p+256\n    if n==11 then return p+512\n    if n==12\
    \ then return p+1024\n    if n==13 then return p+2048\n    if n==14 then return\
    \ p+4096\n    if n==15 then return p+8192\n    if n==16 then return p+16384\n\
    \    if n==17 then return p+32768\n    if n==18 then return p+65536\n    if n==19\
    \ then return p+131072\n    if n==20 then return p+262144\n    if n==21 then return\
    \ p+524288\n    if n==22 then return p+1048576\n    if n==23 then return p+2097152\n\
    \    if n==24 then return p+4194304\n    if n==25 then return p+8388608\n    if\
    \ n==26 then return p+16777216\n    if n==27 then return p+33554432\n    if n==28\
    \ then return p+67108864\n    if n==29 then return p+134217728\n    if n==30 then\
    \ return p+268435456\n    if n==31 then return p+536870912\n    if n==32 then\
    \ return p+1073741824\n    if n==33 then return p+2147483648\n    if n==34 then\
    \ return p+4294967296\n    if n==35 then return p+8589934592\n    if n==36 then\
    \ return p+17179869184\n    if n==37 then return p+34359738368\n    if n==38 then\
    \ return p+68719476736\n    if n==39 then return p+137438953472\n    if n==40\
    \ then return p+274877906944\n    if n==41 then return p+549755813888\n    if\
    \ n==42 then return p+1099511627776\n    if n\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmps5jwiox7.jl:14\nin expression starting at /tmp/tmps5jwiox7.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < n \n        then return modp(n - p,\
    \ p)\n    else return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.0>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4nwha73_.jl:15\nin expression starting at /tmp/tmp4nwha73_.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n <= p\
    \ \n        then return n\n    else \n        modp(n / p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpg255v8mw.jl:15\nin expression starting at /tmp/tmpg255v8mw.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(abs(n), p)\n    else \n        then return\
    \ modp(abs(n), abs(p))\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjbu4ou20.jl:15\nin expression starting at /tmp/tmpjbu4ou20.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if p == 1\
    \ \n        then return n\n    else \n        modp(n / p, p)\nend\n</code>\n<|/\
    \ a tags=math,julia |>\n<| c |>\nI like this solution, but I wonder if there is\
    \ a way to avoid the recursive call. Maybe by using a while loop?\n<|/ c |>\n\
    <| c |>\nYes, you can use a while loop. I'll add an example to my answer.\n<|/\
    \ c |>\n<| a tags=math,julia |>\nHere is a solution using while loop:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpccuwjboo.jl:15\nin expression starting at /tmp/tmpccuwjboo.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n == 1\n\
    \        then return p\n    else if p <= 0\n        then return 0\n    else if\
    \ p == 1\n        then return n\n    else if p > n\n        then return 0\n  \
    \  else if p < n\n        then return modp(n - 1, p)\n    else \n        modp(n\
    \ - 1, p)\n    end\nend\n</code>\n<|/ a tags=math,julia |>\n<| a |>\nThe answer\
    \ by is correct, but I wanted to add some explanation as to why it works.\nThe\
    \ function modp takes two arguments: n and p. n and p are both integers. In Julia,\
    \ integers are represented internally as 64-bit integers. When you call modp(3,\
    \ 5), you are actually calling modp(Int64(3), Int64(5)), which means that you\
    \ are passing two 64-bit integers into the function.\nThe function modp then checks\
    \ to see if the first argument is less than or equal to zero. If it is, then the\
    \ function returns 0. If not, it checks to see if the second argument is less\
    \ than or equal to zero. If it is, then the function returns 0. If not, it checks\
    \ to see if the first argument is equal to 1. If it is, then the function returns\
    \ p. If not, it checks to see if the second argument is equal to 1. If it is,\
    \ then the function returns p. If not, it checks to see if the first argument\
    \ is greater than or equal to 1. If it is, then the function returns 0. If not,\
    \ it checks to see if the second argument is greater than or equal to 1. If it\
    \ is, then the function returns 0. If not, it checks to see if the first argument\
    \ is less than or equal to the second argument. If it is, then the function returns\
    \ 0. If not, it checks to see if the second argument is less than or equal to\
    \ the first argument. If it is, then the function returns 0. If not, it checks\
    \ to see if the first argument is greater than or equal to the second argument.\
    \ If it is, then the function returns 0. If not, it checks to see if the second\
    \ argument is greater than or equal to the first argument. If it is, then the\
    \ function returns 0. If not, it checks to see if the first argument is less than\
    \ or equal to the second argument. If it is, then the function returns 0. If not,\
    \ it checks to see if the second argument is less than or equal to the first argument.\
    \ If it is, then the function returns 0. If not, it checks to see if the first\
    \ argument is greater than or equal to the second argument. If it is, then the\
    \ function returns 0. If not, it checks to see if the second argument is greater\
    \ than or equal to the first argument. If it is, then the function returns 0.\
    \ If not, it checks to see if the first argument is less than or equal to the\
    \ second argument. If it is, then the function returns 0. If not, it checks to\
    \ see if the second argument is \nusing Test\n\n@testset begin\n\ncandidate =\
    \ modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t\
    @test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9thw7g7s.jl:15\nin expression starting at /tmp/tmp9thw7g7s.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n*(n+1)/2\n    if p==4 then return n*(n+1)*(2*n+1)/6\n\
    \    if p==5 then return n*(n+1)*(2*n+1)*(3*n+1)/24\n    if p==6 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)/120\n\
    \    if p==7 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)/720\n    if p==8\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)/5040\n    if p==9\
    \ then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)/40320\n\
    \    if p==10 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)/36288\n\
    \    if p==11 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)/86400\n\
    \    if p==12 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)/172800\n\
    \    if p==13 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)/86400\n\
    \    if p==14 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31*n+1)/172800\n\
    \    if p==15 then return n*(n+1)*(2*n+1)*(3*n+1)*(5*n+1)*(7*n+1)*(11*n+1)*(13*n+1)*(17*n+1)*(19*n+1)*(23*n+1)*(29*n+1)*(31*n+1)*(37*n+1)/\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsm0wjc1k.jl:14\nin expression starting at /tmp/tmpsm0wjc1k.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n < 0\
    \ \n        then return modp(-n, p)\n    else if n < p \n        then return modp(n,\
    \ p)\n    else return modp((n-p), p)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplkj5t2d9.jl:15\nin expression starting at /tmp/tmplkj5t2d9.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"n must be positive\")\n  \
    \  else if p <= 0\n        error(\"p must be positive\")\n    else if p < n\n\
    \        error(\"p must be >= n\")\n    else\n        return n & (p - 1)\nend\n\
    </cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgvdqazse.jl:16\nin expression starting at\
    \ /tmp/tmpgvdqazse.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 || p==0 \n        then return 0\n    else if\
    \ n==1 \n        then return p\n    else if p==1 \n        then return n\n   \
    \ else \n        then return modp(modp(n,p)-1,p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpi1clvrna.jl:15\nin expression starting at /tmp/tmpi1clvrna.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n < 0 \n        then return modp(-n, p)\n\
    \    else if p < 0 \n        then return modp(n, -p) \n    else if n < p \n  \
    \      then return modp(n, p) \n    else if n == p \n        then return n\n \
    \   else if n < p \n        then return modp(n, p) \n    else \n        then return\
    \ modp(n, p) \nend\n</code>\n<|/ a tags=math,julia |>\n<| c |>\nThis does not\
    \ work for negative numbers. For example, `modp(2, -2)` returns `1` instead of\
    \ `-1`.\n<|/ c |>\n<| c |>\nI added a version that works for negative numbers.\
    \ I tested it on Julia 1.5.2 and it works.\n<|/ c |>\n<| a tags=math,julia |>\n\
    Here is a simple solution that works for positive integers and does not require\
    \ any packages:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpoekw05a9.jl:15\nin expression starting at /tmp/tmpoekw05a9.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(-n, p)\n    if p > p then return modp(n, p)\n \
    \   if p % 2 == 1 then return modp(n-1, p-1)\n    else return modp(n-1, p) + modp(n-1,\
    \ p-2)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpuu7z_asi.jl:14\nin expression starting at /tmp/tmpuu7z_asi.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if n <= p then return modp(n - 1, p) \n    else\
    \ return modp(p, n)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n\
    \ modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp230e6xup.jl:14\nin expression starting at /tmp/tmp230e6xup.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return n\n    if p==2 then return n+1\n\
    \    if p==3 then return n*2\n    if p==4 then return n*3\n    if p==5 then return\
    \ n*4\n    if p==6 then return n*5\n    if p==7 then return n*6\n    if p==8 then\
    \ return n*7\n    if p==9 then return n*8\n    if p==10 then return n*9\n    if\
    \ p==11 then return n*10\n    if p==12 then return n*11\n    if p==13 then return\
    \ n*12\n    if p==14 then return n*13\n    if p==15 then return n*14\n    if p==16\
    \ then return n*15\n    if p==17 then return n*16\n    if p==18 then return n*17\n\
    \    if p==19 then return n*18\n    if p==20 then return n*19\n    if p==21 then\
    \ return n*20\n    if p==22 then return n*21\n    if p==23 then return n*22\n\
    \    if p==24 then return n*23\n    if p==25 then return n*24\n    if p==26 then\
    \ return n*25\n    if p==27 then return n*26\n    if p==28 then return n*27\n\
    \    if p==29 then return n*28\n    if p==30 then return n*29\n    if p==31 then\
    \ return n*30\n    if p==32 then return n*31\n    if p==33 then return n*32\n\
    \    if p==34 then return n*33\n    if p==35 then return n*34\n    if p==36 then\
    \ return n*35\n    if p==37 then return n*36\n    if p==38 then return n*37\n\
    \    if p==39 then return n*38\n    if p==40 then return n*39\n    if p==41 then\
    \ return n*40\n    if p==42 then return n*41\n    if p==43 then return n*42\n\
    \    if p==44 then return n*43\n    if p==45 then return n*44\n    if p==46 then\
    \ return n*45\n    if p==47 then return n*46\n    if p==48 then return n*47\n\
    \    if p==49 then return n*48\n    if p==50 then return n*49\n    if p==51 then\
    \ return n*50\n    if p==52 then return n*51\n    if p==53 then return n*52\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa5ioz4yj.jl:14\nin expression starting at /tmp/tmpa5ioz4yj.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n <= p \n\
    \        then return modp(n - p, p) \n    else return modp(n, p - n)\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp3pgzrzqx.jl:15\nin expression starting at /tmp/tmp3pgzrzqx.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(p, n)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzczifvqz.jl:15\nin expression starting at /tmp/tmpzczifvqz.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if p < 2 then return 0\n    if p < n then return\
    \ modp(n - p, p)\n    \n    x := 0\n    y := 1\n    z := 2\n    \n    while y\
    \ <= n do\n        x := z\n        z := z * z % p\n        y := y * y % p\n  \
    \  end\n    return x\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpyi0fetim.jl:14\nin expression starting at /tmp/tmpyi0fetim.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n        error(\"modp(n,p)\")\n    end\n  \
    \  if p <= 0\n        error(\"modp(n,p)\")\n    end\n    if n == 0\n        return\
    \ p\n    end\n    if p == 0\n        return n\n    end\n    if p < n\n       \
    \ return modp(n, p - 1)\n    end\n    return modp(n - p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr3ws4gzo.jl:31\nin expression starting at\
    \ /tmp/tmpr3ws4gzo.jl:31\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n <= p \n        then return modp(abs(n), abs(p))\n    else \n        return\
    \ modp(modp(abs(n), abs(p)), abs(p))\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpl8orqq7p.jl:15\nin expression starting at /tmp/tmpl8orqq7p.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p) \n    else \n        return modp(n + p - 1, p)\n\
    end\n</cell>\n<code language=julia-1.4>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpuhmg3tg9.jl:15\nin expression starting at /tmp/tmpuhmg3tg9.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return modp(n - p, p)\n    if p < n then return modp(n, p -\
    \ n)\n    return modp(n / p, p)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptbgsoif8.jl:14\nin expression starting at /tmp/tmptbgsoif8.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if n==2 then return p+1\n    if n>2 then return modp(mod(n, p), p)\nend\n</cell>\n\
    <code language=julia-1.3>\n\"\"\"Return nth root of p (be aware of numerics).\n\
    \    >>> rootp(3, 5)\n    1.73205080756888\n    >>> rootp(1101, 101)\n    2.0000\n\
    \    >>> rootp(0, 101)\n    1.0000\n    >>> rootp(3, 11)\n    1.73205080756888\n\
    \    >>> rootp(100, 101)\n    1.0000\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpz3ra3yjs.jl:14\nin expression starting at /tmp/tmpz3ra3yjs.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n < 0\
    \ \n        then return modp(abs(n), p)\n    else if p < 0 \n        then return\
    \ modp(n, abs(p))\n    else if p == 0 \n        then return 1\n    else if n ==\
    \ 1 \n        then return 0\n    else if p == 1 \n        then return 1\n    else\
    \ if p == 2 \n        then return 2\n    else if p == 3 \n        then return\
    \ 3\n    else if p == 4 \n        then return 4\n    else if p == 5 \n       \
    \ then return 5\n    else if p == 6 \n        then return 6\n    else if p ==\
    \ 7 \n        then return 7\n    else if p == 8 \n        then return 8\n    else\
    \ if p == 9 \n        then return 9\n    else if p == 10 \n        then return\
    \ 10\n    else if p == 11 \n        then return 11\n    else if p == 12 \n   \
    \     then return 12\n    else if p == 13 \n        then return 13\n    else if\
    \ p == 14 \n        then return 14\n    else if p == 15 \n        then return\
    \ 15\n    else if p == 16 \n        then return 16\n    else if p == 17 \n   \
    \     then return 17\n    else if p == 18 \n        then return 18\n    else if\
    \ p == 19 \n        then return 19\n    else if p == 20 \n        then return\
    \ 20\n    else if p == 21 \n        then return 21\n    else if p == 22 \n   \
    \     then return 22\n    else if p == 23 \n        then return 23\n    else if\
    \ p == 24 \n        then return 24\n    else if p == 25 \n        then return\
    \ 25\n    else if p == 26 \n        then return 26\n    else if p == 27 \n   \
    \     then return 27\n    else if p == 28 \n        then return 28\n    else if\
    \ p == 29 \n        then return 29\n    else if p == 30 \n        then return\
    \ 30\n    else if p == 31 \n        then return 31\n    else if p == 32 \n   \
    \     then return 32\n    else if p == 33 \n        then return 33\n    else if\
    \ p == 34 \n        then return 34\n    else if p == 35\n        then return 35\n\
    \    else if p == 36\n        then return 36\n    else if p == 37\n        then\
    \ return 37\n    else if p == 38\n        then return 38\n    else if \nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5kjo_h8r.jl:15\nin expression starting at /tmp/tmp5kjo_h8r.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(-n, p)\n    if p > p then return modp(n, p)\n \
    \   if p % 2 == 0 then return modp(n-1, p-1)\n    else return modp(n-1, p)\nend\n\
    </cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5dzocmus.jl:14\nin expression starting at /tmp/tmp5dzocmus.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < p \n        then return n \n        else return\
    \ modp(n - p, p) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return\
    \ n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8lnxgo71.jl:15\nin expression starting at /tmp/tmp8lnxgo71.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if n == p then return 1\n    if n < p then return modp(n, p)\n    if n ==\
    \ 0 then return 0\n    if n == p then return 1\n    if n < p then return modp(n,\
    \ p)\n    if n == p then return 1\n    if n < p then return modp(n, p)\n    if\
    \ n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n\
    \ < p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n <\
    \ p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n < p\
    \ then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n < p then\
    \ return modp(n, p)\n    if n < p then return modp(n, p)\n    if n < p then return\
    \ modp(n, p)\n    if n < p then return modp(n, p)\n    if n < p then return modp(n,\
    \ p)\n    if n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n\
    \    if n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n  \
    \  if n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if\
    \ n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n\
    \ < p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n <\
    \ p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n < p\
    \ then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n < p then\
    \ return modp(n, p)\n    if n < p then return modp(n, p)\n    if n < p then return\
    \ modp(n, p)\n    if n < p then return modp(n, p)\n    if n < p then return modp(n,\
    \ p)\n    if n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n\
    \    if n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n  \
    \  if n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if\
    \ n < p then return modp(n, p)\n    if n < p then return modp(n, p)\n    if n\
    \ < p then return modp(n, p)\n    if n < p then return mod\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_w6v_g1j.jl:14\nin expression starting at /tmp/tmp_w6v_g1j.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p < 0\
    \ \n        then return modp(-n, p)\n    else if p < n \n        then return modp(n,\
    \ p)\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_4yqmqu0.jl:15\nin expression starting at /tmp/tmp_4yqmqu0.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(n-1, p)\n    if p > p then return modp(n-1, p)\n\
    \    if p % 2 == 1 then return modp(n-1, p//2)\n    return modp(n-1, p//2)\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5_fdh86s.jl:14\nin expression starting at /tmp/tmp5_fdh86s.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(n-1, p)\n    if p > p then return modp(n-1, p)\n\
    \    if p % 2 == 1 then return modp(n-1, p//2)\n    if p % 2 == 0 then return\
    \ modp(n-1, p//2)\n    if p % 3 == 0 then return modp(n-1, p//3)\n    if p % 3\
    \ == 1 then return modp(n-1, p//3)\n    if p % 5 == 0 then return modp(n-1, p//5)\n\
    \    if p % 5 == 1 then return modp(n-1, p//5)\n    if p % 7 == 0 then return\
    \ modp(n-1, p//7)\n    if p % 7 == 1 then return modp(n-1, p//7)\n    if p % 11\
    \ == 0 then return modp(n-1, p//11)\n    if p % 11 == 1 then return modp(n-1,\
    \ p//11)\n    if p % 13 == 0 then return modp(n-1, p//13)\n    if p % 13 == 1\
    \ then return modp(n-1, p//13)\n    if p % 17 == 0 then return modp(n-1, p//17)\n\
    \    if p % 17 == 1 then return modp(n-1, p//17)\n    if p % 19 == 0 then return\
    \ modp(n-1, p//19)\n    if p % 19 == 1 then return modp(n-1, p//19)\n    if p\
    \ % 23 == 0 then return modp(n-1, p//23)\n    if p % 23 == 1 then return modp(n-1,\
    \ p//23)\n    if p % 29 == 0 then return modp(n-1, p//29)\n    if p % 29 == 1\
    \ then return modp(n-1, p//29)\n    if p % 31 == 0 then return modp(n-1, p//31)\n\
    \    if p % 31 == 1 then return modp(n-1, p//31)\n    if p % 37 == 0 then return\
    \ modp(n-1, p//37)\n    if p % 37 == 1 then return modp(n-1, p//37)\n    if p\
    \ % 41 == 0 then return modp(n-1, p//41)\n    if p % 41 == 1 then return modp(n-1,\
    \ p//41)\n    if p % 43 == 0 then return modp(n-1, p//43)\n    if p % 43 == 1\
    \ then return modp(n-1, p//43)\n    if p % 47 == 0 then return modp(n-1, p//47)\n\
    \    if p % 47 == 1 then return modp(n-1, p//\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpt0pdg76o.jl:14\nin expression starting at /tmp/tmpt0pdg76o.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return n\n    if p==2 then return n+1\n\
    \    if p==3 then return n*2\n    if p==4 then return n*3\n    if p==5 then return\
    \ n*4\n    if p==6 then return n*5\n    if p==7 then return n*6\n    if p==8 then\
    \ return n*7\n    if p==9 then return n*8\n    if p==10 then return n*9\n    if\
    \ p==11 then return n*10\n    if p==12 then return n*11\n    if p==13 then return\
    \ n*12\n    if p==14 then return n*13\n    if p==15 then return n*14\n    if p==16\
    \ then return n*15\n    if p==17 then return n*16\n    if p==18 then return n*17\n\
    \    if p==19 then return n*18\n    if p==20 then return n*19\n    if p==21 then\
    \ return n*20\n    if p==22 then return n*21\n    if p==23 then return n*22\n\
    \    if p==24 then return n*23\n    if p==25 then return n*24\n    if p==26 then\
    \ return n*25\n    if p==27 then return n*26\n    if p==28 then return n*27\n\
    \    if p==29 then return n*28\n    if p==30 then return n*29\n    if p==31 then\
    \ return n*30\n    if p==32 then return n*31\n    if p==33 then return n*32\n\
    \    if p==34 then return n*33\n    if p==35 then return n*34\n    if p==36 then\
    \ return n*35\n    if p==37 then return n*36\n    if p==38 then return n*37\n\
    \    if p==39 then return n*38\n    if p==40 then return n*39\n    if p==41 then\
    \ return n*40\n    if p==42 then return n*41\n    if p==43 then return n*42\n\
    \    if p==44 then return n*43\n    if p==45 then return n*44\n    if p==46 then\
    \ return n*45\n    if p==47 then return n*46\n    if p==48 then return n*47\n\
    \    if p==49 then return n*48\n    if p==50 then return n*49\n    if p==51 then\
    \ return n*50\n    if p==52 then return n*51\n    if p==53 then return n*52\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa5ioz4yj.jl:14\nin expression starting at /tmp/tmpa5ioz4yj.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ \n        return modp(n / p, p)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpbfj11da0.jl:15\nin expression starting at /tmp/tmpbfj11da0.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if n < 0 then return modp(-n,\
    \ abs(p))\n    if n == p then return 0\n    if n < p then return modp(n - p, p)\n\
    \    if n > p then return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp768xf53n.jl:14\nin expression starting at /tmp/tmp768xf53n.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if n < 0\
    \ \n        then return modp(-n, p)\n    else if p < 0 \n        then return modp(-n,\
    \ p)\n    else if p > p \n        then return modp(n, p)\n    else if p < n \n\
    \        then return modp(n, p)\n    else return modp(n-1, p)\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpx387or2k.jl:15\nin expression starting at /tmp/tmpx387or2k.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ \n        return modp(n / p, p) * p\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvcjrjx4j.jl:15\nin expression starting at /tmp/tmpvcjrjx4j.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(n - p, p)\n    else if n <= p \n       \
    \ then return modp(n - p, p)\n    else return modp((n - p) mod p, p)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe_ttwiv4.jl:15\nin expression starting at /tmp/tmpe_ttwiv4.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if p == 2 then return n mod 2\n    if p == 3\
    \ then return n mod 3\n    if p == 4 then return n mod 4\n    if p == 5 then return\
    \ n mod 5\n    if p == 6 then return n mod 6\n    if p == 7 then return n mod\
    \ 7\n    if p == 8 then return n mod 8\n    if p == 9 then return n mod 9\n  \
    \  if p == 10 then return n mod 10\n    if p == 11 then return n mod 11\n    if\
    \ p == 12 then return n mod 12\n    if p == 13 then return n mod 13\n    if p\
    \ == 14 then return n mod 14\n    if p == 15 then return n mod 15\n    if p ==\
    \ 16 then return n mod 16\n    if p == 17 then return n mod 17\n    if p == 18\
    \ then return n mod 18\n    if p == 19 then return n mod 19\n    if p == 20 then\
    \ return n mod 20\n    if p == 21 then return n mod 21\n    if p == 22 then return\
    \ n mod 22\n    if p == 23 then return n mod 23\n    if p == 24 then return n\
    \ mod 24\n    if p == 25 then return n mod 25\n    if p == 26 then return n mod\
    \ 26\n    if p == 27 then return n mod 27\n    if p == 28 then return n mod 28\n\
    \    if p == 29 then return n mod 29\n    if p == 30 then return n mod 30\n  \
    \  if p == 31 then return n mod 31\n    if p == 32 then return n mod 32\n    if\
    \ p == 33 then return n mod 33\n    if p == 34 then return n mod 34\n    if p\
    \ == 35 then return n mod 35\n    if p == 36 then return n mod 36\n    if p ==\
    \ 37 then return n mod 37\n    if p == 38 then return n mod 38\n    if p == 39\
    \ then return n mod 39\n    if p == 40 then return n mod 40\n    if p == 41 then\
    \ return n mod 41\n    if p == 42 then return n mod 42\n    if p == 43 then return\
    \ n mod 43\n    if p == 44 then return n mod 44\n    if p == 45 then return n\
    \ mod 45\n    if p == 46 then return n mod 46\n    if p == 47 then return n mod\
    \ 47\n    if p == 48 then return n mod 48\n    if p == 49 then return n mod 49\n\
    \    if p == 50 then return n mod 50\n    if p\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8lfln5z7.jl:14\nin expression starting at /tmp/tmp8lfln5z7.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(p, n)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptryjla90.jl:15\nin expression starting at /tmp/tmptryjla90.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 || p==0 \n        then return 0\n    else if\
    \ p==1\n        then return n\n    else if n==1\n        then return p\n    else\
    \ if p==2\n        then return modp(modp(n-1, 2), 2)\n    else if p==3\n     \
    \   then return modp(modp(n-1, 3), 3)\n    else if p==4\n        then return modp(modp(n-1,\
    \ 4), 4)\n    else if p==5\n        then return modp(modp(n-1, 5), 5)\n    else\
    \ if p==6\n        then return modp(modp(n-1, 6), 6)\n    else if p==7\n     \
    \   then return modp(modp(n-1, 7), 7)\n    else if p==8\n        then return modp(modp(n-1,\
    \ 8), 8)\n    else if p==9\n        then return modp(modp(n-1, 9), 9)\n    else\
    \ if p==10\n        then return modp(modp(n-1, 10), 10)\n    else if p==11\n \
    \       then return modp(modp(n-1, 11), 11)\n    else if p==12\n        then return\
    \ modp(modp(n-1, 12), 12)\n    else if p==13\n        then return modp(modp(n-1,\
    \ 13), 13)\n    else if p==14\n        then return modp(modp(n-1, 14), 14)\n \
    \   else if p==15\n        then return modp(modp(n-1, 15), 15)\n    else if p==16\n\
    \        then return modp(modp(n-1, 16), 16)\n    else if p==17\n        then\
    \ return modp(modp(n-1, 17), 17)\n    else if p==18\n        then return modp(modp(n-1,\
    \ 18), 18)\n    else if p==19\n        then return modp(modp(n-1, 19), 19)\n \
    \   else if p==20\n        then return modp(modp(n-1, 20), 20)\n    else if p==21\n\
    \        then return modp(modp(n-1, 21), 21)\n    else if p==22\n        then\
    \ return modp(modp(n-1, 22), 22)\n    else if p==23\n        then return modp(modp(n-1,\
    \ 23), 23)\n    else if p==24\n        then return modp(modp(n-1, 24), 24)\n \
    \   else if p==25\n        then return modp(modp(n-1, 25), 25)\n    \nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpni9pf2z9.jl:15\nin expression starting at /tmp/tmpni9pf2z9.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n <= p \n        then return modp(n - p, p)\n    else return modp(n - p,\
    \ modp(n, p))\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"Return nth root\
    \ of p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplvnozxd_.jl:15\nin expression starting at /tmp/tmplvnozxd_.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 2 then return 0\n    if p < n then return modp(n - 1, p)\n    \n \
    \   if p % 2 == 1 then return modp(n / 2, p)\n    \n    if p % 3 == 0 then return\
    \ modp(n / 3, p)\n    \n    if p % 5 == 0 then return modp(n / 5, p)\n    \n \
    \   if p % 7 == 0 then return modp(n / 7, p)\n    \n    if p % 11 == 0 then return\
    \ modp(n / 11, p)\n    \n    if p % 13 == 0 then return modp(n / 13, p)\n    \n\
    \    if p % 17 == 0 then return modp(n / 17, p)\n    \n    if p % 19 == 0 then\
    \ return modp(n / 19, p)\n    \n    if p % 23 == 0 then return modp(n / 23, p)\n\
    \    \n    if p % 29 == 0 then return modp(n / 29, p)\n    \n    if p % 31 ==\
    \ 0 then return modp(n / 31, p)\n    \n    if p % 37 == 0 then return modp(n /\
    \ 37, p)\n    \n    if p % 41 == 0 then return modp(n / 41, p)\n    \n    if p\
    \ % 43 == 0 then return modp(n / 43, p)\n    \n    if p % 47 == 0 then return\
    \ modp(n / 47, p)\n    \n    if p % 53 == 0 then return modp(n / 53, p)\n    \n\
    \    if p % 59 == 0 then return modp(n / 59, p)\n    \n    if p % 61 == 0 then\
    \ return modp(n / 61, p)\n    \n    if p % 67 == 0 then return modp(n / 67, p)\n\
    \    \n    if p % 71 == 0 then return modp(n / 71, p)\n    \n    if p % 73 ==\
    \ 0 then return modp(n / 73, p)\n    \n    if p % 79 == 0 then return modp(n /\
    \ 79, p)\n    \n    if p % 83 == 0 then return modp(n / 83, p)\n    \n    if p\
    \ % 89 == 0 then return modp(n / 89, p)\n    \n    if p % 97 == 0 then return\
    \ modp(n / 97, p)\n    \n    if p % 101 == 0 then return modp(n / 101, p)\n  \
    \  \n    if p % 103 == 0 then return modp(n / 103, p)\n    \n    if p % 107 ==\
    \ 0 then return mod\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_3ddiych.jl:14\nin expression starting at /tmp/tmp_3ddiych.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 2 then return 0\n    if p < n then return modp(n - 1, p) \n    else\
    \ return modp(n - 1, p - 1)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return\
    \ 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzwuthd4u.jl:14\nin expression starting at /tmp/tmpzwuthd4u.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return 1\n    else\
    \ if p == 2 \n        then return 2\n    else if p == 3 \n        then return\
    \ 3\n    else if p == 4 \n        then return 4\n    else if p == 5 \n       \
    \ then return 5\n    else if p == 6 \n        then return 6\n    else if p ==\
    \ 7 \n        then return 7\n    else if p == 8 \n        then return 8\n    else\
    \ if p == 9 \n        then return 9\n    else if p == 10 \n        then return\
    \ 10\n    else if p == 11 \n        then return 11\n    else if p == 12 \n   \
    \     then return 12\n    else if p == 13 \n        then return 13\n    else if\
    \ p == 14 \n        then return 14\n    else if p == 15 \n        then return\
    \ 15\n    else if p == 16 \n        then return 16\n    else if p == 17 \n   \
    \     then return 17\n    else if p == 18 \n        then return 18\n    else if\
    \ p == 19 \n        then return 19\n    else if p == 20 \n        then return\
    \ 20\n    else if p == 21 \n        then return 21\n    else if p == 22 \n   \
    \     then return 22\n    else if p == 23 \n        then return 23\n    else if\
    \ p == 24 \n        then return 24\n    else if p == 25 \n        then return\
    \ 25\n    else if p == 26 \n        then return 26\n    else if p == 27 \n   \
    \     then return 27\n    else if p == 28 \n        then return 28\n    else if\
    \ p == 29 \n        then return 29\n    else if p == 30 \n        then return\
    \ 30\n    else if p == 31 \n        then return 31\n    else if p == 32 \n   \
    \     then return 32\n    else if p == 33 \n        then return 33\n    else if\
    \ p == 34 \n        then return 34\n    else if p == 35 \n        then return\
    \ 35\n    else if p == 36 \n        then return 36\n    else if p == 37 \n   \
    \     then return 37\n    else if p == 38 \n        then return 38\n    else if\
    \ p == 39 \n        then return 39\n    else if p == 40 \n        then return\
    \ 40\n    else if p == 41 \n        then return 41\n    else if p == 42 \nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpg6vu7ekx.jl:15\nin expression starting at /tmp/tmpg6vu7ekx.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if n % p == 0 then return modp(n / p, p)\n \
    \   return modp(n / p, p) * p\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp1z9qdzx9.jl:14\nin expression starting at /tmp/tmp1z9qdzx9.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else if n < p \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else if n == 0 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else if p == 0 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else if p == 1 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else if p == -1 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else if p < 0 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else if p > 1 \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else if p < n \n        error(\"modp() only accepts non-negative\
    \ integers\")\n    else \n        return n\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppdg9ws8m.jl:16\nin expression starting at\
    \ /tmp/tmppdg9ws8m.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(abs(n), p)\n    else return modp(abs(n),\
    \ p) + modp(n-1, p)\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpp3ttu9_8.jl:15\nin expression starting at /tmp/tmpp3ttu9_8.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if n < 0 then return\
    \ modp(-n, p)\n    else if p < 0 then return modp(n, -p) \n    else if n < p then\
    \ return modp(n + p, p)\n    else return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcx52o2mc.jl:14\nin expression starting at /tmp/tmpcx52o2mc.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, -p) \n    else if n <= p \n        then\
    \ return modp(n, p mod n) \n    else \n        then return modp(n, p mod n) +\
    \ modp(p, n) \nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_3w6wyiw.jl:15\nin expression starting at /tmp/tmp_3w6wyiw.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-abs(n), abs(p))\n   \
    \ else if n < p \n        then return modp(n, p - 1)\n    else if n == p \n  \
    \      then return 1\n    else if n % p == 0 \n        then return modp(n / p,\
    \ p)\n    else return modp(n / p, p) * modp(n, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2a2dczyl.jl:15\nin expression starting at /tmp/tmp2a2dczyl.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return modp(n - p, p)\n    if p < n then return modp(n, p -\
    \ n)\n    return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.3>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp6cjs4dha.jl:14\nin expression starting at /tmp/tmp6cjs4dha.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ abs(p))\n    if p < p then return modp(abs(n), p)\n    if p > n then return\
    \ modp(abs(n), p)\n    return modp(abs(n), abs(p))\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpc2cijkai.jl:14\nin expression starting at /tmp/tmpc2cijkai.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n < p\
    \ \n        then return n\n    else \n        modp(n - p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2ci6slkg.jl:15\nin expression starting at /tmp/tmp2ci6slkg.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 return 1\n    if n==1 return p\n    if p==0 return\
    \ 0\n    if p==1 return 1\n    if p==2 return n\n    if p==3 return modp(2*n,\
    \ p)\n    if p==4 return modp(3*n, p)\n    if p==5 return modp(4*n, p)\n    if\
    \ p==6 return modp(5*n, p)\n    if p==7 return modp(6*n, p)\n    if p==8 return\
    \ modp(7*n, p)\n    if p==9 return modp(8*n, p)\n    if p==10 return modp(9*n,\
    \ p)\n    if p==11 return modp(10*n, p)\n    if p==12 return modp(11*n, p)\n \
    \   if p==13 return modp(12*n, p)\n    if p==14 return modp(13*n, p)\n    if p==15\
    \ return modp(14*n, p)\n    if p==16 return modp(15*n, p)\n    if p==17 return\
    \ modp(16*n, p)\n    if p==18 return modp(17*n, p)\n    if p==19 return modp(18*n,\
    \ p)\n    if p==20 return modp(19*n, p)\n    if p==21 return modp(20*n, p)\n \
    \   if p==22 return modp(21*n, p)\n    if p==23 return modp(22*n, p)\n    if p==24\
    \ return modp(23*n, p)\n    if p==25 return modp(24*n, p)\n    if p==26 return\
    \ modp(25*n, p)\n    if p==27 return modp(26*n, p)\n    if p==28 return modp(27*n,\
    \ p)\n    if p==29 return modp(28*n, p)\n    if p==30 return modp(29*n, p)\n \
    \   if p==31 return modp(30*n, p)\n    if p==32 return modp(31*n, p)\n    if p==33\
    \ return modp(32*n, p)\n    if p==34 return modp(33*n, p)\n    if p==35 return\
    \ modp(34*n, p)\n    if p==36 return modp(35*n, p)\n    if p==37 return modp(36*n,\
    \ p)\n    if p==38 return modp(37*n, p)\n    if p==39 return modp(38*n, p)\n \
    \   if p==40 return modp(39*n, p)\n    if p==41 return modp(40*n, p)\n    if p==42\
    \ return modp(41*n, p)\n\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t\
    @test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_jk932rs.jl:1\nin expression starting at /tmp/tmp_jk932rs.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(p, n)\nend\n</cell>\n<code language=julia-1.1>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpchlzcbk5.jl:15\nin expression starting at /tmp/tmpchlzcbk5.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p)\n    else return modp((n - p), p) + p\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpz5m5so35.jl:15\nin expression starting at /tmp/tmpz5m5so35.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n <= p\
    \ \n        then return n\n    else \n        then return modp(n - p, p)\n   \
    \ end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpiwobeqf4.jl:15\nin expression starting at /tmp/tmpiwobeqf4.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else if n > p \n        then\
    \ return modp(n, p - abs(n))\n    else return modp(n - p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpt95cetkm.jl:15\nin expression starting at /tmp/tmpt95cetkm.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0 \n    else if n ==\
    \ 1 \n        then return p \n    else if p <= 0 \n        then return 0 \n  \
    \  else if p == 1 \n        then return n \n    else if p > n \n        then return\
    \ 0 \n    else if p > 1 \n        then return modp(n - 1, p) \n    else \n   \
    \     then return modp(n, p % n) \nend\n</cell>\n<code language=julia-1.1>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2yacabxt.jl:15\nin expression starting at /tmp/tmp2yacabxt.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then n \n    else modp(n - p, p)\
    \ \nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,julia |>\nThe other answers\
    \ are correct, but I wanted to add that you can also use modpow:\n<code>\njulia>\
    \ modpow(2, 5, 3)\n8\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,julia |>\nThe\
    \ modp function you wrote is correct, but you might want to use modpow:\n<code>\n\
    julia> modpow(2, 5, 3)\n8\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not\
    \ provide an answer to the question. Once you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/26814774)\n<|/ c |>\n<| c |>\nI believe\
    \ this does answer the question, since it explains why `modp` does not work, and\
    \ `modpow` does.\n<|/ c |>\n<| c |>\nThe question was \"why doesn't modp work?\"\
    \ The answer is \"modp does not work, because it is defined incorrectly\". The\
    \ question was \"why doesn't modpow work?\" The answer is \"modpow works, because\
    \ it is defined correctly\".\n<|/ c |>\n<| c |>\nI believe this does answer the\
    \ question, since it explains why `modp` does not work, and `modpow` does.\n<|/\
    \ c |>\n<| c |>\nI believe this does answer the question, since it explains why\
    \ `modp` does not work, and `modpow` does.\n<|/ c |>\n<| a dscore=0 |>\nThe modp\
    \ function you wrote is correct, but you might want to use modpow:\n<code>\njulia>\
    \ modpow(2, 5, 3)\n8\n</code>\n<|/ a tags=math,julia |>\n<| c |>\nThis does not\
    \ provide an answer to the question. Once you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgpv3xhth.jl:15\nin expression starting at /tmp/tmpgpv3xhth.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p > 0 \n        then\
    \ return modp(n, p - 1)\n    else return modp(n + p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpp9bifyk6.jl:15\nin expression starting at /tmp/tmpp9bifyk6.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp: n must be positive\"\
    )\n    else if p < 0 \n        error(\"modp: p must be positive\")\n    else if\
    \ n < p \n        error(\"modp: n must be >= p\")\n    else \n        return ((n%p)+p)%p\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi4jtcwr3.jl:16\nin expression starting at\
    \ /tmp/tmpi4jtcwr3.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p == -1 \n        then return -n\n    else if p < 0 \n        then return\
    \ modp(-n, p)\n    else if p > 0 \n        then return modp(n, p)\n    else return\
    \ modp(n + p, p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvroh7omo.jl:15\nin expression starting at /tmp/tmpvroh7omo.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else return modp(n, p - n)\n\
    end\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_ugpyf9i.jl:15\nin expression starting at /tmp/tmp_ugpyf9i.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if n < 0 then return modp(-n, p)\n\
    \    if n == p then return 0\n    if n < p then return modp(n - p, p)\n    if\
    \ n > p then return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>\n\"\
    \"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpii1dr8sh.jl:14\nin expression starting at /tmp/tmpii1dr8sh.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p)\n    else if n == p \n        then return 1\n\
    \    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\
    \"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>>\
    \ modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n \
    \   8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpw569mj69.jl:15\nin expression starting at /tmp/tmpw569mj69.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return 1\n    else\
    \ \n        return modp(n / p, p) * p\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp56sey1ih.jl:15\nin expression starting at /tmp/tmp56sey1ih.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n == 0\
    \ \n        then return p\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if p < n \n   \
    \     then return modp(n - p, p)\n    else if n < p \n        then return modp(n,\
    \ p)\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpe4k9pjfs.jl:15\nin expression starting at /tmp/tmpe4k9pjfs.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires positive arguments\"\
    )\n    end\n    if p < 0 \n        error(\"modp requires positive arguments\"\
    )\n    end\n    if n == 0 \n        return 1 \n    end\n    if p == 0 \n     \
    \   return 0 \n    end\n    if n == p \n        return n \n    end\n    if n %\
    \ p == 0 \n        return n \n    end\n    if n % p == 1 \n        return p \n\
    \    end\n    if p % n == 0 \n        return p \n    end\n    if p % n == 1 \n\
    \        return n \n    end\n    if n % p == p \n        return n \n    end\n\
    \    if n % p == p \n        return p \n    end\n    if p % n == p \n        return\
    \ p \n    end\n    if p % n == n \n        return n \n    end\n    if n % p ==\
    \ 0 \n        return n \n    end\n    if n % p == 1 \n        return p \n    end\n\
    \    if p % n == 0 \n        return p \n    end\n    if p % n == 1 \n        return\
    \ n \n    end\n    if n % p == p \n        return n \n    end\n    if n % p ==\
    \ p \n        return p \n    end\n    if p % n == p \n        return p \n    end\n\
    \    if p % n == n \n        return n \n    end\n    if n % p == 0 \n        return\
    \ n \n    end\n    if n % p == 1 \n        return p \n    end\n    if p % n ==\
    \ 0 \n        return p \n    end\n    if p % n == 1 \n        return n \n    end\n\
    \    if n % p == p \n        return n \n    end\n    if n % p == p \n        return\
    \ p \n    end\n    if p % n == p \n        return p \n    end\n    if p % n ==\
    \ n \n        return n \n    end\n    if n % p == 0 \n        return n \n    end\n\
    \    if n % p == 1 \n        return p \n    end\n    if p % n == 0 \n        return\
    \ p \n    end\n    if p % n == 1 \n        return n \n    end\n    if n % p ==\
    \ p \n        return n \n    end\n    if n % p == p \n        return p \n    end\n\
    \    if p % n == p \n        return p \n    end\n    if p % n == n \n        return\
    \ n \n    end\n    if n % p == 0 \n        return n \n    end\n    if n % p ==\
    \ 1 \n        return p \n    end\n    if p % n == 0 \n        return p \n    end\n\
    \    if p % n == 1 \n        return n \n    end\n    if n % p == p \n        return\
    \ n \n    end\n    if n % p == p \n        return p \n    end\n    if p % n ==\
    \ p \n        return p \n    end\n    if p % n == n \n        return n \n    end\n\
    \    if n % p == 0 \n        return n \n    end\n    if n % p == 1 \n        return\
    \ p \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphf523zwh.jl:1\nin expression starting at /tmp/tmphf523zwh.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then n \n        else modp(n - p,\
    \ p)\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpyxtjwe6x.jl:15\nin expression starting at /tmp/tmpyxtjwe6x.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(n-1, p)\n    if p > p then return modp(n-1, p)\n\
    \    if p < p then return modp(n-1, p)\n    return modp(n-1, p) + modp(n-1, p-1)\n\
    end\n</cell>\n<code language=julia-1.0>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0nwozr7k.jl:14\nin expression starting at /tmp/tmp0nwozr7k.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return modp(n - 1, p)\n    if p < n then return modp(n, p -\
    \ 1)\n    if n % p == 0 then return modp(n / p, p)\n    return modp((n - 1) %\
    \ p, p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpx2m872hv.jl:14\nin expression starting at /tmp/tmpx2m872hv.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    if p < 0 \n        error(\"modp requires p >= 0\")\n    if n == 0 \n    \
    \    error(\"modp requires n > 0\") \n    if p == 0 \n        error(\"modp requires\
    \ p > 0\") \n    if p > n \n        error(\"modp requires p <= n\") \n    if n\
    \ == 1 \n        error(\"modp requires n >= 2\") \n    if p == 1 \n        error(\"\
    modp requires p >= 2\") \n    if n == p \n        error(\"modp requires n >= p\"\
    ) \n    if n == p \n        error(\"modp requires n >= p\") \n    if n == p \n\
    \        error(\"modp requires n >= p\") \n    if n == p \n        error(\"modp\
    \ requires n >= p\") \n    if n == p \n        error(\"modp requires n >= p\"\
    ) \n    if n == p \n        error(\"modp requires n >= p\") \n    if n == p \n\
    \        error(\"modp requires n >= p\") \n    if n == p \n        error(\"modp\
    \ requires n >= p\") \n    if n == p \n        error(\"modp requires n >= p\"\
    ) \n    if n == p \n        error(\"modp requires n >= p\") \n    if n == p \n\
    \        error(\"modp requires n >= p\") \n    if n == p \n        error(\"modp\
    \ requires n >= p\") \n    if n == p \n        error(\"modp requires n >= p\"\
    ) \n    if n == p \n        error(\"modp requires n >= p\") \n    if n == p \n\
    \        error(\"modp requires n >= p\") \n    if n == p \n        error(\"modp\
    \ requires n >= p\") \n    if n == p \n        error(\"modp requires n >= p\"\
    ) \n    if n == p \n        error(\"modp requires n >= p\") \n    if n == p \n\
    \        error(\"modp requires n >= p\") \n    if n == p \n        error(\"modp\
    \ requires n >= p\") \n    if n == p \n        error(\"modp requires n >= p\"\
    ) \n    if n == p \n        error(\"modp requires n >= p\") \n    if n == p \n\
    \        error(\"modp requires n >= p\") \n    if n == p \n        error(\"modp\
    \ requires n >= p\") \n    if n == p \n        error(\"modp requires n >= p\"\
    ) \n    if n == p \n        error(\"modp requires n >= p\") \n    if n == p \n\
    \        error(\"modp requires n >= p\") \n    if n == p \n        error(\"modp\
    \ requires n >= p\") \n    if n == p \n        error(\"modp requires n >= p\"\
    ) \n    if n == p \n        error(\"modp requires \nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8di27poo.jl:1\nin expression starting at /tmp/tmp8di27poo.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0\n    then return 0\n    else if n <= p\n  \
    \  then return n\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdyo9k3ai.jl:15\nin expression starting at /tmp/tmpdyo9k3ai.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n == 0\
    \ \n        then return p\n    else if p == 1 \n        then return 1\n    else\
    \ if p < 0 \n        then return modp(abs(n), abs(p))\n    else if n < 0 \n  \
    \      then return modp(abs(n), abs(p))\n    else if n < p \n        then return\
    \ modp(n - p, p)\n    else if n > p \n        then return modp(n, p - abs(n))\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpnpvzhuwb.jl:15\nin expression starting at /tmp/tmpnpvzhuwb.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 || p==0 \n        then return 0\n    else if\
    \ n==1\n        then return p\n    else if p==1\n        then return 1\n    else\
    \ \n        return modp(modp(n-1, p), p) + modp(n-1, p)\nend\n</cell>\n<code language=julia-1.0>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp4sowqeiv.jl:15\nin expression starting at /tmp/tmp4sowqeiv.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p > 0 \n        then\
    \ return modp(n, p - 1)\n    else return modp(n, p - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp67kuffba.jl:15\nin expression starting at /tmp/tmp67kuffba.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    if p < 0 \n        error(\"modp requires non-negative integers\"\
    )\n    if n == 0 \n        error(\"modp requires non-zero integers\")\n    if\
    \ p == 0 \n        error(\"modp requires non-zero integers\")\n    if p > n \n\
    \        error(\"modp requires non-negative integers\")\n    if p == 1 \n    \
    \    return n\n    if n == 1 \n        return 1\n    if n % p == 0 \n        return\
    \ modp(n / p, p)\n    else \n        return modp(n / p, p) * p\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1wzkzjob.jl:33\nin expression starting at\
    \ /tmp/tmp1wzkzjob.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ abs(p))\n    if p < p then return modp(abs(n), p)\n    if p > n then return\
    \ modp(abs(n), p)\n    return modp(n, p - 1)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpk8e51bag.jl:14\nin expression starting at /tmp/tmpk8e51bag.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ p)\n    if p % 2 == 0 then return modp(n / 2, p)\n    else return modp((n -\
    \ 1) / 2, p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm7fmcwkg.jl:14\nin expression starting at /tmp/tmpm7fmcwkg.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(n,\
    \ p - 1)\n    if p % 2 == 0 then return modp(n, (p - 1)/2)\n    if p % 2 == 1\
    \ then return modp(n, (p - 1)/2) + 1\n    return modp(n, (p - 1)/2) + modp(n,\
    \ (p - 1)/2)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpol2oupgn.jl:14\nin expression starting at /tmp/tmpol2oupgn.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    else if n < p \n        error(\"modp requires n >= p\")\n    else if n ==\
    \ 0 \n        error(\"modp requires n != 0\")\n    else if p == 0 \n        error(\"\
    modp requires p != 0\")\n    else if p == 1 \n        error(\"modp requires p\
    \ != 1\")\n    else if p == -1 \n        error(\"modp requires p != -1\")\n  \
    \  else if p == Inf \n        error(\"modp requires p != Inf\")\n    else if p\
    \ == -Inf \n        error(\"modp requires p != -Inf\")\n    else if p == NaN \n\
    \        error(\"modp requires p != NaN\")\n    else if p < 0 \n        error(\"\
    modp requires p >= 0\")\n    else if p > 1 \n        error(\"modp requires p <=\
    \ 1\")\n    else if p < Inf \n        error(\"modp requires p >= Inf\")\n    else\
    \ if p > Inf \n        error(\"modp requires p <= Inf\")\n    else if p < NaN\
    \ \n        error(\"modp requires p >= NaN\")\n    else if p > NaN \n        error(\"\
    modp requires p <= NaN\")\n    else if p < 0 \n        error(\"modp requires p\
    \ >= 0\")\n    else if p > 1 \n        error(\"modp requires p <= 1\")\n    else\
    \ if p < Inf \n        error(\"modp requires p >= Inf\")\n    else if p > Inf\
    \ \n        error(\"modp requires p <= Inf\")\n    else if p < NaN \n        error(\"\
    modp requires p >= NaN\")\n    else if p > NaN \n        error(\"modp requires\
    \ p <= NaN\")\n    else \n        return n\nend\n</cell>\n<code language=julia-1.4>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb06h64kr.jl:16\nin expression starting at\
    \ /tmp/tmpb06h64kr.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 1\n    else if n == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if p > p \n   \
    \     then return modp(-n, p)\n    else if n < p \n        then return modp(n,\
    \ p)\n    else if n < p \n        then return modp(n, p)\n    else \n        then\
    \ return modp(n, p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9uopxxbo.jl:15\nin expression starting at /tmp/tmp9uopxxbo.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if p > 0 \n        then return modp(n, p)\n    else if n <= 0 \n\
    \        then return 0\n    else if n == 1 \n        then return p\n    else if\
    \ n == 2 \n        then return p\n    else if n % 2 == 0 \n        then return\
    \ modp(n / 2, p)\n    else return modp((n - 1) / 2, p) * p\nend\n</cell>\n<code\
    \ language=julia-1.4>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n   \
    \ >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpzdz_eazm.jl:15\nin expression starting at /tmp/tmpzdz_eazm.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n <= p\
    \ \n        then return 1\n        else return modp(n - p, p)\n    end\nend\n\
    </cell>\n<code language=julia-1.4>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxfg7nriw.jl:15\nin expression starting at /tmp/tmpxfg7nriw.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-n, abs(p))\n    else\
    \ if n < p \n        then return modp(n, p)\n    else \n        then return modp(n\
    \ + p - 1, p)\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdg5vexmn.jl:15\nin expression starting at /tmp/tmpdg5vexmn.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return modp(2*n-1, p)\n    if p==4 then return modp(2*n-1, p)\n\
    \    if p==5 then return modp(2*n-1, p)\n    if p==6 then return modp(2*n-1, p)\n\
    \    if p==7 then return modp(2*n-1, p)\n    if p==8 then return modp(2*n-1, p)\n\
    \    if p==9 then return modp(2*n-1, p)\n    if p==10 then return modp(2*n-1,\
    \ p)\n    if p==11 then return modp(2*n-1, p)\n    if p==12 then return modp(2*n-1,\
    \ p)\n    if p==13 then return modp(2*n-1, p)\n    if p==14 then return modp(2*n-1,\
    \ p)\n    if p==15 then return modp(2*n-1, p)\n    if p==16 then return modp(2*n-1,\
    \ p)\n    if p==17 then return modp(2*n-1, p)\n    if p==18 then return modp(2*n-1,\
    \ p)\n    if p==19 then return modp(2*n-1, p)\n    if p==20 then return modp(2*n-1,\
    \ p)\n    if p==21 then return modp(2*n-1, p)\n    if p==22 then return modp(2*n-1,\
    \ p)\n    if p==23 then return modp(2*n-1, p)\n    if p==24 then return modp(2*n-1,\
    \ p)\n    if p==25 then return modp(2*n-1, p)\n    if p==26 then return modp(2*n-1,\
    \ p)\n    if p==27 then return modp(2*n-1, p)\n    if p==28 then return modp(2*n-1,\
    \ p)\n    if p==29 then return modp(2*n-1, p)\n    if p==30 then return modp(2*n-1,\
    \ p)\n    if p==31 then return modp(2*n-1, p)\n    if p==32 then return modp(2*n-1,\
    \ p)\n    if p==33 then return modp(2*n-1, p)\n    if p==34 then return modp(2*n-1,\
    \ p)\n    if p==35 then return modp(2*n-1, p)\n    if p==36 then return modp(2*n-1,\
    \ p)\n    if p==37 then return modp(2*n-1, p)\n    if p==38 then return modp(2*n-1,\
    \ p)\n    if p\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp10ey6hqb.jl:14\nin expression starting at /tmp/tmp10ey6hqb.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if p < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n < p \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n == 0 \n        error(\"modp requires non-zero integers\"\
    )\n    else if p == 1 \n        error(\"modp requires non-zero integers\")\n \
    \   else if p == 2 \n        error(\"modp requires non-zero integers\")\n    else\
    \ if p == 3 \n        error(\"modp requires non-zero integers\")\n    else if\
    \ p == 4 \n        error(\"modp requires non-zero integers\")\n    else if p ==\
    \ 5 \n        error(\"modp requires non-zero integers\")\n    else if p == 6 \n\
    \        error(\"modp requires non-zero integers\")\n    else if p == 7 \n   \
    \     error(\"modp requires non-zero integers\")\n    else if p == 8 \n      \
    \  error(\"modp requires non-zero integers\")\n    else if p == 9 \n        error(\"\
    modp requires non-zero integers\")\n    else if p == 10 \n        error(\"modp\
    \ requires non-zero integers\")\n    else if p == 11 \n        error(\"modp requires\
    \ non-zero integers\")\n    else if p == 12 \n        error(\"modp requires non-zero\
    \ integers\")\n    else if p == 13 \n        error(\"modp requires non-zero integers\"\
    )\n    else if p == 14 \n        error(\"modp requires non-zero integers\")\n\
    \    else if p == 15 \n        error(\"modp requires non-zero integers\")\n  \
    \  else if p == 16 \n        error(\"modp requires non-zero integers\")\n    else\
    \ if p == 17 \n        error(\"modp requires non-zero integers\")\n    else if\
    \ p == 18 \n        error(\"modp requires non-zero integers\")\n    else if p\
    \ == 19 \n        error(\"modp requires non-zero integers\")\n    else if p ==\
    \ 20 \n        error(\"modp requires non-zero integers\")\n    else if p == 21\
    \ \n        error(\"modp requires non-zero integers\")\n    else if p == 22 \n\
    \        error(\"modp requires non-zero integers\")\n    else if p == 23 \n  \
    \      error(\"modp requires non-zero integers\")\n    else if p == 24 \n    \
    \    error(\"modp requires non-zero integers\")\n    else if p == 25 \n      \
    \  error(\"modp requires non-zero integers\")\n    else if p == 26 \n        error(\"\
    modp requires non-zero integers\")\n    else if p == 27 \n        error(\"modp\
    \ requires non-zero integers\")\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf6fmg0un.jl:16\nin expression starting at\
    \ /tmp/tmpf6fmg0un.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p == -1 \n        then return -n\n    else if p < 0 \n        then return\
    \ modp(-n, p)\n    else if p > 0 \n        then return modp(n, p) \n    else return\
    \ modp(n + p, p)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp50wepufp.jl:15\nin expression starting at /tmp/tmp50wepufp.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return 1\n    else if n==1 \n\
    \        then return p\n    else if p==0 \n        then return 0\n    else if\
    \ p==1 \n        then return 1\n    else \n        return modp(mod(n, p), p)\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpd6eiixa6.jl:15\nin expression starting at /tmp/tmpd6eiixa6.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if p > p then return modp(abs(n),\
    \ p)\n    if p < p then return modp(abs(n), -p) \n    if p > p then return modp(n,\
    \ p)\n    if n == p then return n\n    if n % p == 0 then return modp(n / p, p)\n\
    \    if n % p == 1 then return modp((n - p) / p, p)\n    if n % p == 2 then return\
    \ modp((n - p) / p, p)\n    if n % p == 3 then return modp((n - p) / p, p)\n \
    \   if n % p == 4 then return modp((n - p) / p, p)\n    if n % p == 5 then return\
    \ modp((n - p) / p, p)\n    if n % p == 6 then return modp((n - p) / p, p)\n \
    \   if n % p == 7 then return modp((n - p) / p, p)\n    if n % p == 8 then return\
    \ modp((n - p) / p, p)\n    if n % p == 9 then return modp((n - p) / p, p)\n \
    \   if n % p == 10 then return modp((n - p) / p, p)\n    if n % p == 11 then return\
    \ modp((n - p) / p, p)\n    if n % p == 12 then return modp((n - p) / p, p)\n\
    \    if n % p == 13 then return modp((n - p) / p, p)\n    if n % p == 14 then\
    \ return modp((n - p) / p, p)\n    if n % p == 15 then return modp((n - p) / p,\
    \ p)\n    if n % p == 16 then return modp((n - p) / p, p)\n    if n % p == 17\
    \ then return modp((n - p) / p, p)\n    if n % p == 18 then return modp((n - p)\
    \ / p, p)\n    if n % p == 19 then return modp((n - p) / p, p)\n    if n % p ==\
    \ 20 then return modp((n - p) / p, p)\n    if n % p == 21 then return modp((n\
    \ - p) / p, p)\n    if n % p == 22 then return modp((n - p) / p, p)\n    if n\
    \ % p == 23 then return modp((n - p) / p, p)\n    if n % p == 24 then return modp((n\
    \ - p) / p, p)\n    if n % p == 25 then return modp((n - p) / p, p)\n    if n\
    \ % p == 26 then return modp((n - p) / p, p)\n    if n % p == 27 then return modp((n\
    \ - p) / p, p)\n    if n % \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpjx7qjzxr.jl:14\nin expression starting at /tmp/tmpjx7qjzxr.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n < p \n        then return modp(n-1, p)\n\
    \    else \n        return modp(n-1, p) + modp(n, p-1)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkerk9969.jl:15\nin expression starting at /tmp/tmpkerk9969.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n == p \n        then return 0\n    else if n < p \n        then return modp(n\
    \ - p, p)\n    else if n > p \n        then return modp(n, p - n)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpf8rqjzfb.jl:15\nin expression starting at /tmp/tmpf8rqjzfb.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else if n > p \n        then\
    \ return modp(n, p - abs(n))\n    else return modp(n - p, p)\nend\n</cell>\n<code\
    \ language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmphi47dxvc.jl:15\nin expression starting at /tmp/tmphi47dxvc.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(p, n)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmqj7_bx0.jl:15\nin expression starting at /tmp/tmpmqj7_bx0.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return p\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else return modp(n, p - n)\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmptmqrziu8.jl:15\nin expression starting at /tmp/tmptmqrziu8.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if n <= p \n        then return modp(n - 1, p) + 1\n    else return modp(n/p,\
    \ p)\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmplqj0rr3a.jl:15\nin expression starting at /tmp/tmplqj0rr3a.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if n < 0\
    \ \n        then return modp(abs(n), p)\n    else if p == 0 \n        then return\
    \ 0\n    else if p < 0 \n        then return modp(abs(n), p)\n    else if p <\
    \ 2 \n        then return modp(n / 2, p)\n    else if p < 3 \n        then return\
    \ modp(n / 2, p)\n    else if p < 5 \n        then return modp(n / 4, p)\n   \
    \ else if p < 7 \n        then return modp(n / 8, p)\n    else if p < 11 \n  \
    \      then return modp(n / 16, p)\n    else if p < 13 \n        then return modp(n\
    \ / 32, p)\n    else if p < 17 \n        then return modp(n / 64, p)\n    else\
    \ if p < 19 \n        then return modp(n / 128, p)\n    else if p < 21 \n    \
    \    then return modp(n / 256, p)\n    else if p < 23 \n        then return modp(n\
    \ / 512, p)\n    else if p < 29 \n        then return modp(n / 1024, p)\n    else\
    \ if p < 31 \n        then return modp(n / 4096, p)\n    else if p < 33 \n   \
    \     then return modp(n / 8192, p)\n    else if p < 35 \n        then return\
    \ modp(n / 16384, p)\n    else if p < 37 \n        then return modp(n / 32768,\
    \ p)\n    else if p < 39 \n        then return modp(n / 65536, p)\n    else if\
    \ p < 41 \n        then return modp(n / 131072, p)\n    else if p < 43 \n    \
    \    then return modp(n / 262144, p)\n    else if p < 45 \n        then return\
    \ modp(n / 524288, p)\n    else if p < 47 \n        then return modp(n / 1048576,\
    \ p)\n    else if p < 49 \n        then return modp(n / 2097152, p)\n    else\
    \ if p < 51 \n        then return modp(n / 4194304, p)\n    else if p < 53 \n\
    \        then return modp(n / 8388608, p)\n    else if p < 55 \n        then return\
    \ modp(n / 16777216, p)\n    else if p < 57 \n        then return modp(n \nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5slienkr.jl:15\nin expression starting at /tmp/tmp5slienkr.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if n <= p then return modp(n - 1, p) + 1\n \
    \   else return modp(n - 1, modp(p, n))\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpg3rmg_w4.jl:14\nin expression starting at /tmp/tmpg3rmg_w4.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n < 0\n\
    \        then return modp(-n, p)\n    else if p == 0\n        then return 0\n\
    \    else if p < 0\n        then return modp(n, -p) \n    else if p < n\n    \
    \    then return modp(n, p) \n    else return modp(n - p, p)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpwzncwyhw.jl:15\nin expression starting at /tmp/tmpwzncwyhw.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n+1\n    if p==4 then return n*2\n    if p==5 then return\
    \ n*3\n    if p==6 then return n*4\n    if p==7 then return n*5\n    if p==8 then\
    \ return n*6\n    if p==9 then return n*7\n    if p==10 then return n*8\n    if\
    \ p==11 then return n*9\n    if p==12 then return n*10\n    if p==13 then return\
    \ n*11\n    if p==14 then return n*12\n    if p==15 then return n*13\n    if p==16\
    \ then return n*14\n    if p==17 then return n*15\n    if p==18 then return n*16\n\
    \    if p==19 then return n*17\n    if p==20 then return n*18\n    if p==21 then\
    \ return n*19\n    if p==22 then return n*20\n    if p==23 then return n*21\n\
    \    if p==24 then return n*22\n    if p==25 then return n*23\n    if p==26 then\
    \ return n*24\n    if p==27 then return n*25\n    if p==28 then return n*26\n\
    \    if p==29 then return n*27\n    if p==30 then return n*28\n    if p==31 then\
    \ return n*29\n    if p==32 then return n*30\n    if p==33 then return n*31\n\
    \    if p==34 then return n*32\n    if p==35 then return n*33\n    if p==36 then\
    \ return n*34\n    if p==37 then return n*35\n    if p==38 then return n*36\n\
    \    if p==39 then return n*37\n    if p==40 then return n*38\n    if p==41 then\
    \ return n*39\n    if p==42 then return n*40\n    if p==43 then return n*41\n\
    \    if p==44 then return n*42\n    if p==45 then return n*43\n    if p==46 then\
    \ return n*44\n    if p==47 then return n*45\n    if p==48 then return n*46\n\
    \    if p==49 then return n*47\n    if p==50 then return n*48\n    if p==51 then\
    \ return n*49\n    if p==52 then return n*50\n    if p==53 then return n*51\n\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7aasxd2d.jl:14\nin expression starting at /tmp/tmp7aasxd2d.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p) \n        else return modp(n, p % n) \nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkv0p1sc3.jl:15\nin expression starting at /tmp/tmpkv0p1sc3.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return modp(n - 1, p)\n    if p < n then return modp(n, p -\
    \ 1)\n    \n    \n\"\"\"\n    modpow(n::Int64, p::Int64)::Int64\n    \nReturn\
    \ n modulo p raised to the power of 2.\n    >>> modpow(3, 5)\n    3\n    >>> modpow(1101,\
    \ 101)\n    2\n    >>> modpow(0, 101)\n    1\n    >>> modpow(3, 11)\n    8\n \
    \   >>> modpow(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\n\
    candidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm0so5wdq.jl:14\nin expression starting at /tmp/tmpm0so5wdq.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if n < 0 \n        then return modp(-n, p)\n    else if n <= p \n  \
    \      then return modp(n, p)\n    else return modp(n, p - 1)\nend\n</cell>\n\
    <code language=julia-1.4>\n\"\"\"Return 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm74c6a38.jl:15\nin expression starting at /tmp/tmpm74c6a38.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if p == 0\
    \ \n        then return 1\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p > 1 \n        then\
    \ return modp(n, p - 1)\n    else if p < n \n        then return modp(n, p)\n\
    \    else return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5nq79s0a.jl:15\nin expression starting at /tmp/tmp5nq79s0a.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires n >= 0\")\n\
    \    if p < 0\n        error(\"modp requires p >= 0\")\n    if n == 0\n      \
    \  error(\"modp requires n > 0\") \n    if p == 0\n        error(\"modp requires\
    \ p > 0\") \n    if p == 1 && n == 1\n        error(\"modp requires n and p !=\
    \ 1\")\n    if p == 1 && n == 0\n        error(\"modp requires n and p != 1\"\
    )\n    if p == 1 && n == -1\n        error(\"modp requires n and p != 1\")\n \
    \   if p == 2 && n == 0\n        error(\"modp requires n and p != 2\")\n    if\
    \ p == 2 && n == 1\n        error(\"modp requires n and p != 2\")\n    if p ==\
    \ 2 && n == -1\n        error(\"modp requires n and p != 2\")\n    if p == 3 &&\
    \ n == 0\n        error(\"modp requires n and p != 3\")\n    if p == 3 && n ==\
    \ 1\n        error(\"modp requires n and p != 3\")\n    if p == 3 && n == -1\n\
    \        error(\"modp requires n and p != 3\")\n    if p == 4 && n == 0\n    \
    \    error(\"modp requires n and p != 4\")\n    if p == 4 && n == 1\n        error(\"\
    modp requires n and p != 4\")\n    if p == 4 && n == -1\n        error(\"modp\
    \ requires n and p != 4\")\n    if p == 5 && n == 0\n        error(\"modp requires\
    \ n and p != 5\")\n    if p == 5 && n == 1\n        error(\"modp requires n and\
    \ p != 5\")\n    if p == 5 && n == -1\n        error(\"modp requires n and p !=\
    \ 5\")\n    if p == 6 && n == 0\n        error(\"modp requires n and p != 6\"\
    )\n    if p == 6 && n == 1\n        error(\"modp requires n and p != 6\")\n  \
    \  if p == 6 && n == -1\n        error(\"modp requires n and p != 6\")\n    if\
    \ p == 7 && n == 0\n        error(\"modp requires n and p != 7\")\n    if p ==\
    \ 7 && n == 1\n        error(\"modp requires n and p != 7\")\n    if p == 7 &&\
    \ n == -1\n        error(\"modp requires n and p != 7\")\n    if p == 8 && n ==\
    \ 0\n        error(\"modp requires n and p != 8\")\n    if p == 8 && n == 1\n\
    \        error(\"modp requires n and p != 8\")\n    if p == 8 && n == -1\n   \
    \     error(\"modp requires n and p != 8\")\n    if p == 9 && n == 0\n       \
    \ error(\"modp requires n and p != 9\")\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu2633pij.jl:1\nin expression starting at /tmp/tmpu2633pij.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p) \n    else if n < p \n        then return modp(n,\
    \ -p) \n    else \n        then return modp(-n, -p) \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpobca5q3p.jl:15\nin expression starting at /tmp/tmpobca5q3p.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return 1\n    else if n==1 \n\
    \        then return p\n    else if p==0 \n        then return 0\n    else if\
    \ p==1 \n        then return 1\n    else if p==2 \n        then return n\n   \
    \ else if p==3 \n        then return modp(2*n, p-1)\n    else if p==4 \n     \
    \   then return modp(3*n, p-1)\n    else if p==5 \n        then return modp(4*n,\
    \ p-1)\n    else if p==6 \n        then return modp(5*n, p-1)\n    else if p==7\
    \ \n        then return modp(6*n, p-1)\n    else if p==8 \n        then return\
    \ modp(7*n, p-1)\n    else if p==9 \n        then return modp(8*n, p-1)\n    else\
    \ if p==10 \n        then return modp(9*n, p-1)\n    else if p==11 \n        then\
    \ return modp(10*n, p-1)\n    else if p==12 \n        then return modp(11*n, p-1)\n\
    \    else if p==13 \n        then return modp(12*n, p-1)\n    else if p==14 \n\
    \        then return modp(13*n, p-1)\n    else if p==15 \n        then return\
    \ modp(14*n, p-1)\n    else if p==16 \n        then return modp(15*n, p-1)\n \
    \   else if p==17 \n        then return modp(16*n, p-1)\n    else if p==18 \n\
    \        then return modp(17*n, p-1)\n    else if p==19 \n        then return\
    \ modp(18*n, p-1)\n    else if p==20 \n        then return modp(19*n, p-1)\n \
    \   else if p==21 \n        then return modp(20*n, p-1)\n    else if p==22 \n\
    \        then return modp(21*n, p-1)\n    else if p==23 \n        then return\
    \ modp(22*n, p-1)\n    else if p==24 \n        then return modp(23*n, p-1)\n \
    \   else if p==25 \n        then return modp(24*n, p-1)\n    else if p==26 \n\
    \        then return modp(25*n, p-1)\n    else if p==27 \n        then return\
    \ modp(26*n, p-1)\n    else if p==28 \n        then \nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcouqiw23.jl:15\nin expression starting at /tmp/tmpcouqiw23.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 2 then return 0\n    if p < n then return modp(n - 1, p) \n    if\
    \ p > n then return modp(n, p)\n    \n    if p % 2 == 1 then return modp(n / 2,\
    \ p)\n    \n    x := n / p\n    y := modp(n - x, p)\n    z := modp(n, p)\n   \
    \ \n    if y == 0 then return z\n    \n    if y > 0 then return z\n    \n    if\
    \ y < 0 then return y\n    \n    if y % 2 == 1 then return modp(y / 2, p)\n  \
    \  \n    return y\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpve1eyetu.jl:14\nin expression starting at /tmp/tmpve1eyetu.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp: negative argument\"\
    )\n    else if n < p \n        error(\"modp: not smaller than p\")\n    else if\
    \ n == 0 \n        error(\"modp: division by zero\")\n    else if p == 0 \n  \
    \      error(\"modp: division by zero\")\n    else if p == 1 \n        error(\"\
    modp: division by zero\")\n    else \n        return n%p\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpife2jqeh.jl:16\nin expression starting at\
    \ /tmp/tmpife2jqeh.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 0\n    else if p == 0\
    \ \n        then return 1\n    else if p < 0 \n        then return modp(-n, -p)\
    \ \n    else if n < 0 \n        then return modp(-n, p) \n    else if n < p \n\
    \        then return modp(n, p)\n    else return modp(n + p - 1, p)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpz12sktba.jl:15\nin expression starting at /tmp/tmpz12sktba.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, -p) \n    if p > n then return modp(n, p)\n\
    \    if p == n then return 1\n    if p < n then return modp(n, p)\n    if p ==\
    \ n then return 1\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n, p)\n    if p > n then return modp(n, p)\n    if p < n then return modp(n,\
    \ p)\n    if p > n then return modp(n, p)\n    if p < n then return modp(n, p)\n\
    \    if p > n then return modp(n, p)\n    if p < n then return modp(n, p)\n  \
    \  if p > n then return modp(n, p)\n    if p < n then return modp(n, p)\n    if\
    \ p > n then return modp(n, p)\n    if p < n then return modp(n, p)\n    if p\
    \ > n then return modp(n, p)\n    if p < n then return modp(n, p)\n    if p >\
    \ n then return modp(n, p)\n    if p < n then return modp(n, p)\n    if p > n\
    \ then return modp(n, p)\n    if p < n then return modp(n, p)\n    if p > n then\
    \ return modp(n, p)\n    if p < n then return modp(n, p)\n    if p > n then return\
    \ modp(n, p)\n    if p < n then return modp(n, p)\n    if p > n then return modp(n,\
    \ p)\n    if p < n then return modp(n, p)\n    if p > n then return modp(n, p)\n\
    \    if p < n then return modp(n, p)\n    if p > n then return modp(n, p)\n  \
    \  if p < n then return modp(n, p)\n    if p > n then return modp(n, p)\n    if\
    \ p < n then return modp(n, p)\n    if p > n then return modp(n, p)\n    if p\
    \ < n then return modp(n, p)\n    if p > n then return modp(n, p)\n    if p <\
    \ n then return modp(n, p)\n    if p > n then return modp(n, p)\n    if p < n\
    \ then return modp(n, p)\n    if p > n then return modp(n, p)\n    if p < n then\
    \ return modp(n, p)\n    if p > n then return modp(n, p)\n    if p < n then return\
    \ modp(n, p)\n    if p > n then return \nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpivm3l4nq.jl:14\nin expression starting at /tmp/tmpivm3l4nq.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if p == 0 then return\
    \ 0\n    else if p < n then return modp(n - 1, p) % p\n    else return modp(n,\
    \ p % n) \nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return nth root of p\
    \ (be aware of numerics).\n    >>> rootp(3, 5)\n    1.73205080756888\n    >>>\
    \ rootp(1101, 101)\n    1.73205080756888\n    >>> rootp(0, 101)\n    1\n    >>>\
    \ rootp(3, 11)\n    1.73205080756888\n    >>> rootp(100, 101)\n    1\n    \"\"\
    \"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
    \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpn2q50ndh.jl:14\nin expression starting at /tmp/tmpn2q50ndh.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ if p < 0 \n        then return modp(-n, p)\n    else if p > 0 \n        then\
    \ return modp(n, p - 1)\n    else \n        error(\"modp: p must be positive\"\
    )\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdcs7yrqw.jl:15\nin expression starting at /tmp/tmpdcs7yrqw.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if n <= p then return modp(n\
    \ - p, p)\n    else return modp((p - n) % p, p)\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmprod2rx_0.jl:14\nin expression starting at /tmp/tmprod2rx_0.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp only works with positive\
    \ integers\")\n    else if n < p \n        error(\"modp only works with positive\
    \ integers\")\n    else if n == 0 \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == 0 \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == 1 \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -1 \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == 2 \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -2 \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only works with positive\
    \ integers\")\n    else if p == -n \n        error(\"modp only \nusing Test\n\n\
    @testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy4ul740b.jl:16\nin expression starting at\
    \ /tmp/tmpy4ul740b.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if p == 1 or n == 1 then return n\n    if p == 0 then return 1\n    if n ==\
    \ 0 then return 0\n    if n == 1 then return 1\n    if n == 2 then return modp(n\
    \ / 2, p)\n    if n % 2 == 0 then return modp(n / 2, p)\n    return modp((n -\
    \ 1) / 2, p) * modp((n - 1) / 2, p)\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n\
    \    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8c44r1dy.jl:14\nin expression starting at /tmp/tmp8c44r1dy.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if n==p then return n\n\
    \    if p==-1 then return modp(abs(n), abs(p))\n    if n<0 then return modp(abs(n),\
    \ abs(p))\n    if n==-1 then return modp(abs(n), abs(p))\n    if n==-2 then return\
    \ modp(abs(n), abs(p))\n    if n==-3 then return modp(abs(n), abs(p))\n    if\
    \ n==-4 then return modp(abs(n), abs(p))\n    if n==-5 then return modp(abs(n),\
    \ abs(p))\n    if n==-6 then return modp(abs(n), abs(p))\n    if n==-7 then return\
    \ modp(abs(n), abs(p))\n    if n==-8 then return modp(abs(n), abs(p))\n    if\
    \ n==-9 then return modp(abs(n), abs(p))\n    if n==-10 then return modp(abs(n),\
    \ abs(p))\n    if n==-11 then return modp(abs(n), abs(p))\n    if n==-12 then\
    \ return modp(abs(n), abs(p))\n    if n==-13 then return modp(abs(n), abs(p))\n\
    \    if n==-14 then return modp(abs(n), abs(p))\n    if n==-15 then return modp(abs(n),\
    \ abs(p))\n    if n==-16 then return modp(abs(n), abs(p))\n    if n==-17 then\
    \ return modp(abs(n), abs(p))\n    if n==-18 then return modp(abs(n), abs(p))\n\
    \    if n==-19 then return modp(abs(n), abs(p))\n    if n==-20 then return modp(abs(n),\
    \ abs(p))\n    if n==-21 then return modp(abs(n), abs(p))\n    if n==-22 then\
    \ return modp(abs(n), abs(p))\n    if n==-23 then return modp(abs(n), abs(p))\n\
    \    if n==-24 then return modp(abs(n), abs(p))\n    if n==-25 then return modp(abs(n),\
    \ abs(p))\n    if n==-26 then return modp(abs(n), abs(p))\n    if n==-27 then\
    \ return modp(abs(n), abs(p))\n    if n==-28 then return modp(abs(n), abs(p))\n\
    \    if n==-29 then return modp(abs(n), abs(p))\n    if n==-30 then return modp(abs(\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvrpi9tkr.jl:14\nin expression starting at /tmp/tmpvrpi9tkr.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if n <= p then return modp(n - 1, p) \n    return\
    \ modp(n - 1, modp(p - 1, p)) + n\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvhri5luz.jl:14\nin expression starting at /tmp/tmpvhri5luz.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n+1\n    if p==4 then return n*2\n    if p==5 then return\
    \ n*3\n    if p==6 then return n*4\n    if p==7 then return n*5\n    if p==8 then\
    \ return n*6\n    if p==9 then return n*7\n    if p==10 then return n*8\n    if\
    \ p==11 then return n*9\n    if p==12 then return n*10\n    if p==13 then return\
    \ n*11\n    if p==14 then return n*12\n    if p==15 then return n*13\n    if p==16\
    \ then return n*14\n    if p==17 then return n*15\n    if p==18 then return n*16\n\
    \    if p==19 then return n*17\n    if p==20 then return n*18\n    if p==21 then\
    \ return n*19\n    if p==22 then return n*20\n    if p==23 then return n*21\n\
    \    if p==24 then return n*22\n    if p==25 then return n*23\n    if p==26 then\
    \ return n*24\n    if p==27 then return n*25\n    if p==28 then return n*26\n\
    \    if p==29 then return n*27\n    if p==30 then return n*28\n    if p==31 then\
    \ return n*29\n    if p==32 then return n*30\n    if p==33 then return n*31\n\
    \    if p==34 then return n*32\n    if p==35 then return n*33\n    if p==36 then\
    \ return n*34\n    if p==37 then return n*35\n    if p==38 then return n*36\n\
    \    if p==39 then return n*37\n    if p==40 then return n*38\n    if p==41 then\
    \ return n*39\n    if p==42 then return n*40\n    if p==43 then return n*41\n\
    \    if p==44 then return n*42\n    if p==45 then return n*43\n    if p==46 then\
    \ return n*44\n    if p==47 then return n*45\n    if p==48 then return n*46\n\
    \    if p==49 then return n*47\n    if p==50 then return n*48\n    if p==51 then\
    \ return n*49\n    if p==52 then return n*50\n    if p==53 then return n*51\n\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7aasxd2d.jl:14\nin expression starting at /tmp/tmp7aasxd2d.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if p > n then return modp(n, p - 1)\n    if\
    \ p < n then return modp(n, p + 1)\n    if p < n then return modp(n, p - 1)\n\
    \    if p > n then return modp(n, p + 1)\n    return modp(n, p - 1)\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpk_6w02bd.jl:14\nin expression starting at /tmp/tmpk_6w02bd.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(-n, p)\n    if p > n then return modp(n, p)\n \
    \   if p == 1 or n == 1 then return n\n    if p == 0 then return 1\n    if n ==\
    \ 0 then return 0\n    if p == 1 or n == 1 then return n\n    if p == 0 then return\
    \ 1\n    if n == 1 then return p\n    if p == 1 or n == 1 then return p\n    if\
    \ p == 0 then return 1\n    if n == 0 then return 0\n    if p == 1 or n == 1 then\
    \ return p\n    if p == 0 then return 1\n    if n == 1 then return p\n    if p\
    \ == 1 or n == 1 then return p\n    if p == 0 then return 1\n    if n == 0 then\
    \ return 0\n    if p == 1 or n == 1 then return p\n    if p == 0 then return 1\n\
    \    if n == 1 then return p\n    if p == 1 or n == 1 then return p\n    if p\
    \ == 0 then return 1\n    if n == 0 then return 0\n    if p == 1 or n == 1 then\
    \ return p\n    if p == 0 then return 1\n    if n == 1 then return p\n    if p\
    \ == 1 or n == 1 then return p\n    if p == 0 then return 1\n    if n == 0 then\
    \ return 0\n    if p == 1 or n == 1 then return p\n    if p == 0 then return 1\n\
    \    if n == 1 then return p\n    if p == 1 or n == 1 then return p\n    if p\
    \ == 0 then return 1\n    if n == 0 then return 0\n    if p == 1 or n == 1 then\
    \ return p\n    if p == 0 then return 1\n    if n == 1 then return p\n    if p\
    \ == 1 or n == 1 then return p\n    if p == 0 then return 1\n    if n == 0 then\
    \ return 0\n    if p == 1 or n == 1 then return p\n    if p == 0 then return 1\n\
    \    if n == 1 then return p\n    if p == 1 or n == 1 then return p\n    if p\
    \ == 0 then return 1\n    if n == 0 then return 0\n    if p == 1 or n == 1 then\
    \ return p\n    if p == 0 then return 1\n    if n == 1 then return p\n    if p\
    \ == 1 or n == 1 then return p\n    if p == 0 then return 1\n    if n == 0 then\
    \ return 0\n    if p == 1 or n == 1 then return p\n    if p == 0 then return 1\n\
    \    if n == 1 then return p\n    if p == 1 or n == 1 then return p\n    if p\
    \ == 0 then return 1\n    if n == 0 then return 0\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9t31jblh.jl:14\nin expression starting at /tmp/tmp9t31jblh.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    else if n < 0 then return\
    \ modp(abs(n), p)\n    else if n < p then return modp(n + p, p)\n    else return\
    \ modp((n - p) mod p, p)\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"Return\
    \ 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpb89jhv__.jl:14\nin expression starting at /tmp/tmpb89jhv__.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n < 0 \n        then return modp(-n, p)\n\
    \    else if n < p \n        then return modp(n + p - 1, p)\n    else return modp(n\
    \ + p - 1, p) \nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp1wav8m1s.jl:15\nin expression starting at /tmp/tmp1wav8m1s.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - p, p)\n    else return modp(n, p - n)\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"Return 2^n modulo p (be aware of\
    \ numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>>\
    \ modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n  \
    \  1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpf1i95ero.jl:15\nin expression starting at /tmp/tmpf1i95ero.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n, p - 1)\n    else if n < p \n        then\
    \ return modp(n, p)\n    else return modp(n, p - 1)\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpm_qlpfd9.jl:15\nin expression starting at /tmp/tmpm_qlpfd9.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1 \n    else if n==1 then return\
    \ p \n    else if p==0 then return 1 \n    else if p==1 then return n \n    else\
    \ if p==2 then return n*n \n    else if p==3 then return n*n*n \n    else if p==4\
    \ then return n*n*n*n \n    else if p==5 then return n*n*n*n*n \n    else if p==6\
    \ then return n*n*n*n*n*n \n    else if p==7 then return n*n*n*n*n*n*n \n    else\
    \ if p==8 then return n*n*n*n*n*n*n*n \n    else if p==9 then return n*n*n*n*n*n*n*n*n\
    \ \n    else if p==10 then return n*n*n*n*n*n*n*n*n*n \n    else if p==11 then\
    \ return n*n*n*n*n*n*n*n*n*n*n \n    else if p==12 then return n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    else if p==13 then return n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==14\
    \ then return n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==15 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    else if p==16 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if\
    \ p==17 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==18 then\
    \ return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==19 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n\
    \ \n    else if p==20 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else\
    \ if p==21 then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==22\
    \ then return n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==23 then return\
    \ n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n \n    else if p==24 then return n*n*n*n*n*n*n*n*n*n*n*n*n*\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxl_q_krs.jl:14\nin expression starting at /tmp/tmpxl_q_krs.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then return n \n        else return\
    \ modp(n - p, p) \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpbh_ht202.jl:15\nin expression starting at /tmp/tmpbh_ht202.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= p \n        then n \n    else modp(n - p, p)\
    \ \nend\n</code>\n<|/ a tags=julia,algorithm |>\n<| a dscore=2 |>\nHere's a Julia\
    \ solution that uses recursion and a while loop:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101,\
    \ 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\
    \t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31,\
    \ 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"n\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpt7kvw7tu.jl:15\nin expression starting at /tmp/tmpt7kvw7tu.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(abs(n), abs(p))\n    else\
    \ if n < p \n        then return modp(n - abs(n), p - abs(p))\n    else if n ==\
    \ p \n        then return n\n    else return modp(n - abs(n), p - abs(p))\nend\n\
    </cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5ue5qo8z.jl:15\nin expression starting at /tmp/tmp5ue5qo8z.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 then return 1\n    if n==1 then return p\n  \
    \  if p==0 then return 0\n    if p==1 then return 1\n    if p==2 then return n\n\
    \    if p==3 then return n+1\n    if p==4 then return n+2\n    if p==5 then return\
    \ n+3\n    if p==6 then return n+4\n    if p==7 then return n+5\n    if p==8 then\
    \ return n+6\n    if p==9 then return n+7\n    if p==10 then return n+8\n    if\
    \ p==11 then return n+9\n    if p==12 then return n+10\n    if p==13 then return\
    \ n+11\n    if p==14 then return n+12\n    if p==15 then return n+13\n    if p==16\
    \ then return n+14\n    if p==17 then return n+15\n    if p==18 then return n+16\n\
    \    if p==19 then return n+17\n    if p==20 then return n+18\n    if p==21 then\
    \ return n+19\n    if p==22 then return n+20\n    if p==23 then return n+21\n\
    \    if p==24 then return n+22\n    if p==25 then return n+23\n    if p==26 then\
    \ return n+24\n    if p==27 then return n+25\n    if p==28 then return n+26\n\
    \    if p==29 then return n+27\n    if p==30 then return n+28\n    if p==31 then\
    \ return n+29\n    if p==32 then return n+30\n    if p==33 then return n+31\n\
    \    if p==34 then return n+32\n    if p==35 then return n+33\n    if p==36 then\
    \ return n+34\n    if p==37 then return n+35\n    if p==38 then return n+36\n\
    \    if p==39 then return n+37\n    if p==40 then return n+38\n    if p==41 then\
    \ return n+39\n    if p==42 then return n+40\n    if p==43 then return n+41\n\
    \    if p==44 then return n+42\n    if p==45 then return n+43\n    if p==46 then\
    \ return n+44\n    if p==47 then return n+45\n    if p==48 then return n+46\n\
    \    if p==49\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpu5uibsfk.jl:14\nin expression starting at /tmp/tmpu5uibsfk.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if n < 0\
    \ \n        then return modp(-n, p)\n    else if p < 0 \n        then return modp(-n,\
    \ p)\n    else if p > 0 \n        then return modp(n, p)\n    else if n == 1 \n\
    \        then return 0\n    else if n == 2 \n        then return 1\n    else if\
    \ n % 2 == 0 \n        then return modp(n / 2, p)\n    else \n        then return\
    \ modp(n / 2, p) + modp((n / 2) * (n % 2), p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmo73_iqd.jl:15\nin expression starting at /tmp/tmpmo73_iqd.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-abs(n), abs(p))\n   \
    \ else if n == p \n        then return 0\n    else if n < p \n        then return\
    \ modp(n - p, p)\n    else return modp((p - n) % p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpp_afjjdw.jl:15\nin expression starting at /tmp/tmpp_afjjdw.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if n == 1 then return p\n\
    \    if p < 0 then return modp(-n, p)\n    if p < n then return modp(n, p)\n \
    \   if p < 2*n then return modp(n-1, p)\n    if p < 3*n then return modp(n-2,\
    \ p)\n    if p < 4*n then return modp(n-3, p)\n    if p < 5*n then return modp(n-4,\
    \ p)\n    if p < 6*n then return modp(n-5, p)\n    if p < 7*n then return modp(n-6,\
    \ p)\n    if p < 8*n then return modp(n-7, p)\n    if p < 9*n then return modp(n-8,\
    \ p)\n    if p < 10*n then return modp(n-9, p)\n    if p < 11*n then return modp(n-10,\
    \ p)\n    if p < 12*n then return modp(n-11, p)\n    if p < 13*n then return modp(n-12,\
    \ p)\n    if p < 14*n then return modp(n-13, p)\n    if p < 15*n then return modp(n-14,\
    \ p)\n    if p < 16*n then return modp(n-15, p)\n    if p < 17*n then return modp(n-16,\
    \ p)\n    if p < 18*n then return modp(n-17, p)\n    if p < 19*n then return modp(n-18,\
    \ p)\n    if p < 20*n then return modp(n-19, p)\n    if p < 21*n then return modp(n-20,\
    \ p)\n    if p < 22*n then return modp(n-21, p)\n    if p < 23*n then return modp(n-22,\
    \ p)\n    if p < 24*n then return modp(n-23, p)\n    if p < 25*n then return modp(n-24,\
    \ p)\n    if p < 26*n then return modp(n-25, p)\n    if p < 27*n then return modp(n-26,\
    \ p)\n    if p < 28*n then return modp(n-27, p)\n    if p < 29*n then return modp(n-28,\
    \ p)\n    if p < 30*n then return modp(n-29, p)\n    if p < 31*n then return modp(n-30,\
    \ p)\n    if p < 32*n then return modp(n-31, p)\n    if p < 33*n then return modp(n-32,\
    \ p)\n    if p < \nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpumb0ui4x.jl:14\nin expression starting at /tmp/tmpumb0ui4x.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n <= 0\
    \ \n        then return 0\n    else if p < 0 \n        then return 0\n    else\
    \ if p > 0 \n        then return modp(n / p, p)\n    else \n        modp(n / p,\
    \ p)\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThe most efficient way\
    \ is to use bitwise operations. \n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpo25ve8as.jl:15\nin expression starting at /tmp/tmpo25ve8as.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p < 0 \n        then return modp(abs(n),\
    \ abs(p))\n    else if n < 0 \n        then return modp(-n, abs(p))\n    else\
    \ if n < p \n        then return modp(n, p)\n    else if n == p \n        then\
    \ return 1\n    else return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"Return n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n \
    \   >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n\
    \    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101)\
    \ == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpu57et4r3.jl:15\nin expression starting at /tmp/tmpu57et4r3.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p < 0 then return modp(abs(n), abs(p))\n    if n <= p then return modp(n\
    \ + p, p)\n    \n    if p < n then return modp(n - p, p)\n    \n    if n <= p\
    \ then return modp(n, p)\n    \n    if n <= p then return modp(n - p, p)\n   \
    \ \n    if n <= p then return modp(n - p, p)\n    \n    if n <= p then return\
    \ modp(n - p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n    if\
    \ n <= p then return modp(n - p, p)\n    \n    if n <= p then return modp(n -\
    \ p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n    if n <= p then\
    \ return modp(n - p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n\
    \    if n <= p then return modp(n - p, p)\n    \n    if n <= p then return modp(n\
    \ - p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n    if n <= p\
    \ then return modp(n - p, p)\n    \n    if n <= p then return modp(n - p, p)\n\
    \    \n    if n <= p then return modp(n - p, p)\n    \n    if n <= p then return\
    \ modp(n - p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n    if\
    \ n <= p then return modp(n - p, p)\n    \n    if n <= p then return modp(n -\
    \ p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n    if n <= p then\
    \ return modp(n - p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n\
    \    if n <= p then return modp(n - p, p)\n    \n    if n <= p then return modp(n\
    \ - p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n    if n <= p\
    \ then return modp(n - p, p)\n    \n    if n <= p then return modp(n - p, p)\n\
    \    \n    if n <= p then return modp(n - p, p)\n    \n    if n <= p then return\
    \ modp(n - p, p)\n    \n    if n <= p then return modp(n - p, p)\n    \n    if\
    \ n <= p then return modp(n - p, p)\n    \n    if n <= p then return mod\nusing\
    \ Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) == 3)\n\
    \t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t@test(candidate(3,\
    \ 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\
    \t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpc5vytebc.jl:14\nin expression starting at /tmp/tmpc5vytebc.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if p == 1 \n        then return n\n    else\
    \ \n        return modp(n / p, p) * p\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpz_25pbtg.jl:15\nin expression starting at /tmp/tmpz_25pbtg.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 \n        then return 1\n    else if p == 0\
    \ \n        then return 0\n    else if n <= p \n        then return modp(n - 1,\
    \ p)\n        else return modp((n - 1) % p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpquub8mjs.jl:15\nin expression starting at /tmp/tmpquub8mjs.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n <= 0 \n        then return 0\n    else if n <= p\
    \ \n        then return 1\n    else \n        return modp(n - p, p)\nend\n</cell>\n\
    <code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\
    \t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0,\
    \ 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\
    \t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpapyzgnwi.jl:15\nin expression starting at /tmp/tmpapyzgnwi.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    if p < 0 \n        error(\"modp requires non-negative integers\"\
    )\n    if p > n \n        error(\"modp requires non-negative integers\")\n   \
    \ if p == 0 \n        error(\"modp requires non-zero integers\")\n    if n ==\
    \ 0 \n        error(\"modp requires non-zero integers\")\n    if n == p \n   \
    \     error(\"modp requires non-zero integers\")\n    return p == 0 ? 1 : modp(n\
    \ - 1, p % n)\nend\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbxvlr9ny.jl:1\nin expression starting at /tmp/tmpbxvlr9ny.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if p == 0 \n        then return 0\n    else if n == 0\
    \ \n        then return p\n    else if p < 0 \n        then return modp(-n, p)\n\
    \    else if p > 0 \n        then return modp(n, p - 1)\n    else if n < 0 \n\
    \        then return modp(-n, p)\n    else if n > 0 \n        then return modp(n,\
    \ p - 1)\n    else if n == 1 \n        then return p\n    else if n == 2 \n  \
    \      then return p + 1\n    else if n == 3 \n        then return p + 2\n   \
    \ else if n == 4 \n        then return p + 3\n    else if n == 5 \n        then\
    \ return p + 4\n    else if n == 6 \n        then return p + 5\n    else if n\
    \ == 7 \n        then return p + 6\n    else if n == 8 \n        then return p\
    \ + 7\n    else if n == 9 \n        then return p + 8\n    else if n == 10 \n\
    \        then return p + 9\n    else if n == 11 \n        then return p + 10\n\
    \    else if n == 12 \n        then return p + 11\n    else if n == 13 \n    \
    \    then return p + 12\n    else if n == 14 \n        then return p + 13\n  \
    \  else if n == 15 \n        then return p + 14\n    else if n == 16 \n      \
    \  then return p + 15\n    else if n == 17 \n        then return p + 16\n    else\
    \ if n == 18 \n        then return p + 17\n    else if n == 19 \n        then\
    \ return p + 18\n    else if n == 20 \n        then return p + 19\n    else if\
    \ n == 21 \n        then return p + 20\n    else if n == 22 \n        then return\
    \ p + 21\n    else if n == 23 \n        then return p + 22\n    else if n == 24\
    \ \n        then return p + 23\n    else if n == 25 \n        then return p +\
    \ 24\n    else if n == 26 \n        then return p + 25\n    else if n == 27 \n\
    \        then return p + 26\n    else if n == 28 \n        then return p + 27\n\
    \    else if n == 29 \n        then return p + 28\n    else if n == 30 \n    \
    \    then return p + 29\n    else if n == 31 \n        then return p + 30\n  \
    \  else if n == 32 \n        then return p + 31\n    else if n == 33 \n      \
    \  then return p + 32\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpy678tecy.jl:15\nin expression starting at /tmp/tmpy678tecy.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return 1\n    if p < n then return modp(n - p, p)\n    else\
    \ return modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return\
    \ n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101,\
    \ 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>>\
    \ modp(100, 101)\n    1\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = modp;\n\t@test(candidate(3, 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\
    \t@test(candidate(0, 101) == 1)\n\t@test(candidate(3, 11) == 8)\n\t@test(candidate(100,\
    \ 101) == 1)\n\t@test(candidate(30, 5) == 4)\n\t@test(candidate(31, 5) == 3)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmhhdgz48.jl:14\nin expression starting at /tmp/tmpmhhdgz48.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p > n then return modp(n - 1, p) \n    if p < n then return modp(n, p\
    \ - 1)\n    \n    if p % 2 == 1 then return modp(n + 1, p) \n    \n    x := n\
    \ % p\n    y := modp(n, p - x)\n    return x + y\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp112g_7k3.jl:14\nin expression starting at /tmp/tmp112g_7k3.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if p == 1 then return n\n    if p < n then return modp(n - p, p)\n    if\
    \ p > n then return modp(n, p - n)\nend\n</cell>\n<code language=julia-1.3>\n\"\
    \"\"Return nth root of x (be aware of numerics).\n    >>> rootp(3, 5)\n    1.73205080756888\n\
    \    >>> rootp(1101, 101)\n    1.1102230246251565\n    >>> rootp(0, 101)\n   \
    \ 1.0\n    >>> rootp(3, 11)\n    2.4492935982947064\n    >>> rootp(100, 101)\n\
    \    1.0\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpxabken21.jl:14\nin expression starting at /tmp/tmpxabken21.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n == 0 then return 1\n    if p == 0 then return 0\n\
    \    if n <= p then return modp(n - 1, p) \n    else return modp(p, n)\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"Return n modulo p (be aware of numerics).\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpphxjim_m.jl:14\nin expression starting at /tmp/tmpphxjim_m.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n==0 \n        then return 1\n    else if n==1 \n\
    \        then return p\n    else if p==0 \n        then return 0\n    else if\
    \ p==1 \n        then return 1\n    else \n        return modp(mod(n, p), p)\n\
    end\n\"\"\"\n    modpow(n::Int64, p::Int64)::Int64\n    \nReturn the power of\
    \ n modulo p.\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3,\
    \ 5) == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\
    \t@test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmps88i8oxy.jl:15\nin expression starting at /tmp/tmps88i8oxy.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n\
    \    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
    \ p::Int64)::Int64 \n    if n < 0 \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n < p \n        error(\"modp requires non-negative\
    \ integers\")\n    else if n == 0 \n        error(\"modp requires non-zero integers\"\
    )\n    else if p == 0 \n        error(\"modp requires non-zero integers\")\n \
    \   else \n        return n - p + modp(n - p, p)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5) ==\
    \ 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
    @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
    \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnt3f0o7m.jl:16\nin expression starting at\
    \ /tmp/tmpnt3f0o7m.jl:16\n"
  stdout: ''
