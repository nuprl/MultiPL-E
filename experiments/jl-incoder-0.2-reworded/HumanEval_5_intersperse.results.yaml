language: jl
name: HumanEval_5_intersperse
results:
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     numbers = numbers[:]\n    end\n    \n    numbers = numbers[2:end-1]\n  \
    \  \n    numbers = numbers[:]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    \n\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplo3lysl8.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplo3lysl8.jl:1\n\
    in expression starting at /tmp/tmplo3lysl8.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] .+ delimeter\n    numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert intersperse([1,2,3], 4) == [1, 4, 2, 4, 3]\n</cell>\n<text>\nExercise\
    \ 3.2\nWrite a function that returns the number of elements in a vector that satisfy\
    \ a predicate.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj85v39rv.jl:12\nin expression starting at\
    \ /tmp/tmpj85v39rv.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        numbers[2:end] = numbers[2:end] + delimeter\n\
    \        numbers[2:end] = numbers[2:end] + numbers[2:end]\n        return numbers\
    \ \nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=1 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpslvl5sgf.jl:15\nin expression starting at\
    \ /tmp/tmpslvl5sgf.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp20bl9npy.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp20bl9npy.jl:1\n\
    in expression starting at /tmp/tmp20bl9npy.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxjay2ffg.jl:1\nin expression starting at /tmp/tmpxjay2ffg.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  i = 0\n    \n    while i < length(numbers)\n        \n        if numbers[i]\
    \ != 0\n            \n            numbers[i+1:i+2] = [numbers[i], delimeter]\n\
    \            \n            i += 2\n            \n        else\n            \n\
    \            numbers[i+1:i+1] = [delimeter]\n            \n            i += 1\n\
    \        end\n    end\n    \n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 0)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 1)\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 2)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 3)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 4)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 5)\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 6)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 7)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 8)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 9)\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 10)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 11)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 12)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 13)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 14)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 15)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 16)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 17)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 18)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 19)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 20)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 21)\n</cell>\n\
    <code language=julia-1.5>\ninter\nusing Test\n\n@testset begin\n\ncandidate =\
    \ intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcrmcm4z7.jl:31\nin expression starting at\
    \ /tmp/tmpcrmcm4z7.jl:31\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) == 0\n     \
    \   return numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ * delimeter + numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbvzjlpv8.jl:18\nin expression starting at\
    \ /tmp/tmpbvzjlpv8.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) <= 1\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    \n    return numbers + [delimeter] * (length(numbers)\
    \ - 2)\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5btutwqh.jl:18\nin expression starting at\
    \ /tmp/tmp5btutwqh.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    end\n    \n    numbers_copy = copy(numbers)\n    numbers_copy[end]\
    \ = delimeter\n    \n    return numbers_copy\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2omq9xv.jl:17\nin expression starting at\
    \ /tmp/tmpt2omq9xv.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_m93q0ea.jl:1\nin expression starting at /tmp/tmp_m93q0ea.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a vector of integers and returns the sum of the squares\
    \ of the integers in the vector.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvp3chb91.jl:18\nin expression starting at\
    \ /tmp/tmpvp3chb91.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ * delimeter + numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a vector of integers and returns the sum of the squares\
    \ of the integers in the vector. For example, intersperse([1,2,3], 4) should return\
    \ [4, 16, 25]. Make sure you use intersperse to solve this problem.\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnjgxbbsc.jl:17\nin expression starting at\
    \ /tmp/tmpnjgxbbsc.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers =\
    \ numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[1:\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcq1elp7_.jl:111\nin expression starting at\
    \ /tmp/tmpcq1elp7_.jl:111\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    number\nusing Test\n\n@testset begin\n\n\
    candidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2bzc603b.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2bzc603b.jl:1\n\
    in expression starting at /tmp/tmp2bzc603b.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    else\n        numbers[2:end] = numbers[2:end] + delimeter*ones(length(numbers[2:end])-2)\n\
    \        return numbers\n    end\nend\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.4>\n@code_warntype\
    \ intersperse([1, 2, 3], 4)\n</cell>\n<code language=julia-1.\nusing Test\n\n\
    @testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnsk6gqfg.jl:15\nin expression starting at\
    \ /tmp/tmpnsk6gqfg.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp08x4im1u.jl:1\nin expression starting at /tmp/tmp08x4im1u.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        numbers[2:end] = numbers[2:end] + delimeter*ones(delimeter-length(numbers))\
    \ \n        return numbers \n    end\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\n\
    A simple and efficient solution is to use cat:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3jzdkjdx.jl:15\nin expression starting at\
    \ /tmp/tmp3jzdkjdx.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers = numbers[2:end-1]\
    \ .+ [delimeter] .+ numbers[2:end-1]\n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a vector of integers and returns the sum of the squares\
    \ of the integers in the vector. \nFor example, \n$$\\begin{align}\n\\text{sum}(\\\
    begin{bmatrix}1&2&3\\end{bmatrix}) = 1 + 2 + 3 = 6\n\\end{align}$$\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe7zwhssx.jl:12\nin expression starting at\
    \ /tmp/tmpe7zwhssx.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    \n    numbers = numbers[1 : length(numbers)-delimeter]\n\
    \    numbers = numbers[1 : length(numbers)-delimeter]\n    return numbers + intersperse(numbers[-delimeter+1\
    \ : end], delimeter)\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 4)\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector of numbers\
    \ and returns the sum of the squares of the numbers in the vector.\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1blz2ew4.jl:15\nin expression starting at\
    \ /tmp/tmp1blz2ew4.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] .+ delimeter\n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the number of elements of a vector that satisfy a given condition. For\
    \ example, suppose that we want to count the number of elements of a vector that\
    \ satisfy the condition $x > 5$. Write a function that takes as input a vector\
    \ $x$ and a condition $x > 5$, and returns the number of elements that satisfy\
    \ the condition. For example, suppose that $x = [1, 2, 3, 4, 5]$ and $x > 5$.\
    \ Then, the function should return 3.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptt1ylay6.jl:12\nin expression starting at\
    \ /tmp/tmptt1ylay6.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        numbers\n\
    \    else\n        numbers[2:end-1] .+ [delimeter] .+ numbers[2:end-1]\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpworih9g5.jl:14\nin expression starting at\
    \ /tmp/tmpworih9g5.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqidwr_9q.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqidwr_9q.jl:1\n\
    in expression starting at /tmp/tmpqidwr_9q.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) == 0\n     \
    \   return numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmsgu5vic.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmsgu5vic.jl:1\n\
    in expression starting at /tmp/tmpmsgu5vic.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[1::2]\
    \ = delimeter\n    \n    return numbers_copy\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3uukb5yl.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3uukb5yl.jl:1\n\
    in expression starting at /tmp/tmp3uukb5yl.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers\n    else\n        numbers[1 : length(numbers) - (delimeter - length(numbers))]\
    \ + delimeter * ones(delimeter - length(numbers), 1)\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2taey4k3.jl:14\nin expression starting at\
    \ /tmp/tmp2taey4k3.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] .+ delimeter\n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes an input vector of integers and returns the sum of the even numbers in\
    \ that vector. \nFor example, if the input vector is [4, 6, 8, 10, 12], the function\
    \ should return 24.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpofj_awnt.jl:12\nin expression starting at\
    \ /tmp/tmpofj_awnt.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    return numbers + [numbers[1]]\
    \ + intersperse(numbers[2:end-1], delimeter)\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 3\nWrite a function that takes\
    \ a vector and returns a vector where each element is the sum of the previous\
    \ two elements.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzjziymm0.jl:19\nin expression starting at\
    \ /tmp/tmpzjziymm0.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    else\n        numbers = numbers[2:end]\n        numbers = numbers[1:end-1]\
    \ ++ delimeter ++ numbers\n        return numbers\n    end\nend\n</cell>\n<code\
    \ language=julia-1.4>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nThe function\
    \ intersperse is defined in the file src/intersperse.jl.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_gbm4eeb.jl:16\nin expression starting at\
    \ /tmp/tmp_gbm4eeb.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ * delimeter + numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a vector of numbers and returns the vector with the\
    \ numbers reversed.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_a51_nci.jl:18\nin expression starting at\
    \ /tmp/tmp_a51_nci.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0 \n        return\
    \ numbers \n    else \n        numbers[2:end] = numbers[2:end] + delimeter * ones(1,\
    \ length(numbers[2:end])) \n        return numbers \nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that returns the first element of a vector, if it is not\
    \ empty. Otherwise, return 0.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6mmtmw4i.jl:14\nin expression starting at\
    \ /tmp/tmp6mmtmw4i.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    else\n        numbers[2:end] = numbers[2:end] + delimeter * ones(1,\
    \ length(numbers[2:end]))\n        return numbers\n    end\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=julia,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5pcnnjvm.jl:15\nin expression starting at\
    \ /tmp/tmp5pcnnjvm.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) < 2\n      \
    \  return numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1] .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\n\
    end\n</cell>\n<code language=julia-1.5>\nintersperse([1, 2, 3], 4)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the number of elements in a\
    \ vector that satisfy a certain condition. For example, a vector with only positive\
    \ numbers should be counted. Write a function that returns the number of elements\
    \ in a vector that satisfy a certain condition. For example, a vector with only\
    \ positive numbers should be counted. Write a function that returns the number\
    \ of elements in a vector that satisfy a certain condition. For example, a vector\
    \ with only positive numbers should be counted. Write a function that returns\
    \ the number of elements in a vector that satisfy a certain condition. For example,\
    \ a vector with only positive numbers should be counted. Write a function that\
    \ returns the number of elements in a vector that satisfy a certain condition.\
    \ For example, a vector with only positive numbers should be counted. Write a\
    \ function that returns the number of elements in a vector that satisfy a certain\
    \ condition. For example, a vector with only positive numbers should be counted.\
    \ Write a function that returns the number of elements in a vector that satisfy\
    \ a certain condition. For example, a vector with only positive numbers should\
    \ be counted. Write a function that returns the number of elements in a vector\
    \ that satisfy a certain condition. For example, a vector with only positive numbers\
    \ should be counted. Write a function that returns the number of elements in a\
    \ vector that satisfy a certain condition. For example, a vector with only positive\
    \ numbers should be counted. Write a function that returns the number of elements\
    \ in a vector that satisfy a certain condition. For example, a vector with only\
    \ positive numbers should be counted. Write a function that returns the number\
    \ of elements in a vector that satisfy a certain condition. For example, a vector\
    \ with only positive numbers should be counted. Write a function that returns\
    \ the number of elements in a vector that satisfy a certain condition. For example,\
    \ a vector with only positive numbers should be counted. Write a function that\
    \ returns the number of elements in a vector that satisfy a certain condition.\
    \ For example, a vector with only positive numbers should be counted. Write a\
    \ function that returns the number of elements in a vector that satisfy a certain\
    \ condition. For example, a vector with only positive numbers should be counted.\
    \ Write a function that returns the number of elements in a vector that satisfy\
    \ a certain condition. For example, a vector with only positive numbers should\
    \ be counted. Write a function that returns the number of elements in a vector\
    \ that satisfy a certain condition. For example, a vector with only positive numbers\
    \ should be counted. Write a function that returns the number of elements in a\
    \ vector that satisfy a certain condition. For example, a \nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9eayl09q.jl:19\nin expression starting at\
    \ /tmp/tmp9eayl09q.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) < 2\n      \
    \  return numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1] .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\n\
    end\n</cell>\n<code language=julia-1.5>\nintersperse([1, 2, 3], 4)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ the sum of the squares of the integers in the vector. For example, given [1,2,3],\
    \ the function should return 9. Make sure your function works with vectors of\
    \ different lengths.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl0d1h4di.jl:19\nin expression starting at\
    \ /tmp/tmpl0d1h4di.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[2:end-1]\n  \
    \  numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_h8m541x.jl:66\nin expression starting at\
    \ /tmp/tmp_h8m541x.jl:66\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    numbers\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpya62nswi.jl:12\nin expression starting at\
    \ /tmp/tmpya62nswi.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = [delimeter, numbers...]\n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbuufcrf7.jl:17\nin expression starting at\
    \ /tmp/tmpbuufcrf7.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the number of elements in a vector that satisfy a given condition. For example,\
    \ if the condition is that the number of elements is greater than or equal to\
    \ 3, then the function should return 3.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfbv56a9r.jl:12\nin expression starting at\
    \ /tmp/tmpfbv56a9r.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[end-1:end]\
    \ = numbers_copy[end-1:end][1:end-1]\n    \n    return numbers_copy\nend\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 5)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 6)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 7)\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 8)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 9)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 10)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 11)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 12)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 13)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 14)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 15)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 16)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 17)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 18)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 19)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 20)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 21)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 22)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 23)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 24)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 25)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 26)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 27)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 28)\n</cell>\n<code language=juli\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp16u_1and.jl:17\nin expression starting at\
    \ /tmp/tmp16u_1and.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[end-1:end]\
    \ = numbers_copy[end-1:end][1:end-1]\n    \n    return numbers_copy\nend\n</cell>\n\
    <code language=julia-1.3>\nintersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a vector of integers and returns the sum of the\
    \ squares of the integers in the vector.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphr8yd63e.jl:17\nin expression starting at\
    \ /tmp/tmphr8yd63e.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzifatbnv.jl:1\nin expression starting at /tmp/tmpzifatbnv.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        intersperse(numbers[2:end], delimeter\
    \ - length(numbers)) + numbers[1:end-1] \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a vector of integers and returns the sum of the squares of the integers in the\
    \ vector. For example, sum([1,2,3]) should return 9. Hint: use map()\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvcuijnzs.jl:14\nin expression starting at\
    \ /tmp/tmpvcuijnzs.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    else\n        numbers[end+1:end+delimeter] = numbers[end+1:end+delimeter]\n\
    \        numbers[end+delimeter] = delimeter\n        return numbers\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyxf1rsn_.jl:16\nin expression starting at\
    \ /tmp/tmpyxf1rsn_.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[1:end-1]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[1:end-1]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[1:end-1]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[1:end-1]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvgpuusv9.jl:1\nin expression starting at /tmp/tmpvgpuusv9.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  if length(numbers) < 2\n        return numbers\n    end\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1] .+ [delimeter] .+ numbers[2:end]\n\
    \    \n    return numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,\
    \ 2, 3], 4)\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ and returns a new vector where each element is the sum of the previous two elements\
    \ in the vector. For example, intersperse([1, 2, 3, 4], 5) should return [6, 8,\
    \ 10, 12, 14].\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbt12sjuy.jl:21\nin expression starting at\
    \ /tmp/tmpbt12sjuy.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = [delimeter, numbers...]\n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a vector of integers and returns the sum of all even\
    \ numbers in the vector. \nWrite a function that takes a vector of integers and\
    \ returns the sum of all odd numbers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the sum of all numbers in the vector that are\
    \ divisible by 3\nWrite a function that takes a vector of integers and returns\
    \ the sum of all numbers in the vector that are divisible by 5\nWrite a function\
    \ that takes a vector of integers and returns the sum of all numbers in the vector\
    \ that are divisible by 7\nWrite a function that takes a vector of integers and\
    \ returns the sum of all numbers in the vector that are divisible by 11\nWrite\
    \ a function that takes a vector of integers and returns the sum of all numbers\
    \ in the vector that are divisible by 13\nWrite a function that takes a vector\
    \ of integers and returns the sum of all numbers in the vector that are divisible\
    \ by 17\nWrite a function that takes a vector of integers and returns the sum\
    \ of all numbers in the vector that are divisible by 19\nWrite a function that\
    \ takes a vector of integers and returns the sum of all numbers in the vector\
    \ that are divisible by 23\nWrite a function that takes a vector of integers and\
    \ returns the sum of all numbers in the vector that are divisible by 29\nWrite\
    \ a function that takes a vector of integers and returns the sum of all numbers\
    \ in the vector that are divisible by 31\nWrite a function that takes a vector\
    \ of integers and returns the sum of all numbers in the vector that are divisible\
    \ by 37\nWrite a function that takes a vector of integers and returns the sum\
    \ of all numbers in the vector that are divisible by 43\nWrite a function that\
    \ takes a vector of integers and returns the sum of all numbers in the vector\
    \ that are divisible by 47\nWrite a function that takes a vector of integers and\
    \ returns the sum of all numbers in the vector that are divisible by 53\nWrite\
    \ a function that takes a vector of integers and returns the sum of all numbers\
    \ in the vector that are divisible by 59\nWrite a function that takes a vector\
    \ of integers and returns the sum of all numbers in the vector that are divisible\
    \ by 61\nWrite a function that takes a vector of integers and returns the sum\
    \ of all numbers in the vector that are divisible by 67\nWrite a function that\
    \ takes a vector of integers and returns the sum of all numbers in the vector\
    \ that are divisible by 73\nWrite a function that takes a vector of integers and\
    \ returns the sum of all numbers in the vector that are divisible by 79\nWrite\
    \ a function that takes a vector of integers and returns the sum of all numbers\
    \ in the vector that are divisible by 83\nWrite a function that takes a vector\
    \ of integers and returns the sum of all numbers in the vector that are divisible\
    \ by 89\nWrite a function that takes a vector of integers and returns the sum\
    \ of \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpllx6vn7r.jl:17\nin expression starting at\
    \ /tmp/tmpllx6vn7r.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[end-1:end]\
    \ = numbers_copy[end-1:end] + delimeter\n    \n    return numbers_copy\nend\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes an input vector of integers\
    \ and returns the sum of the numbers in the vector. \nWrite a second function\
    \ that takes an input vector of integers and returns the product of the numbers\
    \ in the vector. \nWrite a third function that takes an input vector of integers\
    \ and returns the maximum of the numbers in the vector. \nWrite a fourth function\
    \ that takes an input vector of integers and returns the minimum of the numbers\
    \ in the vector. \nWrite a fifth function that takes an input vector of integers\
    \ and returns the number of elements in the vector. \nWrite a sixth function that\
    \ takes an input vector of integers and returns the sum of the squares of the\
    \ numbers in the vector. \nWrite a seventh function that takes an input vector\
    \ of integers and returns the sum of the cubes of the numbers in the vector. \n\
    Write a eighth function that takes an input vector of integers and returns the\
    \ sum of the exponential of the numbers in the vector. \nWrite a ninth function\
    \ that takes an input vector of integers and returns the sum of the natural logarithms\
    \ of the numbers in the vector. \nWrite a tenth function that takes an input vector\
    \ of integers and returns the sum of the trigonometric values of the numbers in\
    \ the vector. \nWrite a eleventh function that takes an input vector of integers\
    \ and returns the sum of the hyperbolic cosine of the numbers in the vector. \n\
    Write a twelfth function that takes an input vector of integers and returns the\
    \ sum of the hyperbolic sine of the numbers in the vector. \nWrite a thirteenth\
    \ function that takes an input vector of integers and returns the sum of the hyperbolic\
    \ tangent of the numbers in the vector. \nWrite a fourteenth function that takes\
    \ an input vector of integers and returns the sum of the hyperbolic arctangent\
    \ of the numbers in the vector. \nWrite a fifteenth function that takes an input\
    \ vector of integers and returns the sum of the hyperbolic arctangent of the numbers\
    \ in the vector. \nWrite a sixteenth function that takes an input vector of integers\
    \ and returns the sum of the hyperbolic arctangent of the numbers in the vector.\
    \ \nWrite a seventeenth function that takes an input vector of integers and returns\
    \ the sum of the hyperbolic arctangent of the numbers in the vector. \nWrite a\
    \ eighteenth function that takes an input vector of integers and returns the sum\
    \ of the hyperbolic arctangent of the numbers in the vector. \nWrite a nineteenth\
    \ function that takes an input vector of integers and returns the sum of the hyperbolic\
    \ arctangent of the numbers in the vector. \n\nusing Test\n\n@testset begin\n\n\
    candidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr55v8qkm.jl:17\nin expression starting at\
    \ /tmp/tmpr55v8qkm.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0 \n        return\
    \ numbers \n    else \n        numbers = numbers[2:end-1] \n        numbers =\
    \ [numbers[1], delimeter, numbers[end-1]] \n        numbers = intersperse(numbers,\
    \ delimeter+1) \n        numbers = [numbers[1], numbers[end-1]] \n        return\
    \ numbers \n    end\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7huiz5r4.jl:18\nin expression starting at\
    \ /tmp/tmp7huiz5r4.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfwcllo0u.jl:1\nin expression starting at /tmp/tmpfwcllo0u.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) == 0\n     \
    \   return numbers\n    end\n    \n    numbers_copy = copy(numbers)\n    \n  \
    \  numbers_copy[end] = numbers_copy[end] + delimeter\n    \n    return numbers_copy\n\
    end\n</cell>\n<code language=julia-1.5>\nintersperse([1, 2, 3], 4)\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvws5ya5l.jl:19\nin expression starting at\
    \ /tmp/tmpvws5ya5l.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0 \n        return\
    \ numbers \n    else \n        numbers = numbers[2:end-1] \n        numbers =\
    \ [numbers[1], delimeter, numbers...] \n        numbers = intersperse(numbers,\
    \ delimeter) \n        return numbers \nend\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ your solution, but I believe it can be simplified a bit. `intersperse` can be\
    \ defined as `intersperse(xs, d) = intersperse(xs, d, 1)[1]` where `intersperse(xs,\
    \ d, i) = intersperse(xs, d, i-1)[end] + [d]` where `intersperse(xs, d, 1) = [xs]`\
    \ and `intersperse(xs, d, i) = [xs; d; xs]`\n<|/ c |>\n<| c |>\nI agree with you.\
    \ Your solution is much more elegant and efficient. Thanks for sharing!\n<|/ c\
    \ |>\n<| a tags=julia,arrays |>\nI like solution, but I believe it can be simplified\
    \ a bit. intersperse can be defined as intersperse(xs, d) = intersperse(xs, d,\
    \ 1)[1] where intersperse(xs, d, i) = intersperse(xs, d, i-1)[end] + [d] where\
    \ intersperse(xs, d, 1) = [xs]and intersperse(xs, d, i) = [xs; d; xs]\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp79ceuy9n.jl:16\nin expression starting at\
    \ /tmp/tmp79ceuy9n.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp20bl9npy.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp20bl9npy.jl:1\n\
    in expression starting at /tmp/tmp20bl9npy.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplzpj5jw_.jl:1\nin expression starting at /tmp/tmplzpj5jw_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptxd82y3t.jl:1\nin expression starting at /tmp/tmptxd82y3t.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0 \n        return\
    \ numbers \n    else \n        interspersed_numbers = Vector{Int64}(undef, length(numbers))\
    \ \n        interspersed_numbers[1] = numbers[1] \n        interspersed_numbers[2]\
    \ = numbers[1] \n        interspersed_numbers[3] = numbers[2] \n        interspersed_numbers[4]\
    \ = numbers[3] \n        interspersed_numbers[5] = numbers[4] \n        interspersed_numbers[6]\
    \ = numbers[5] \n        interspersed_numbers[7] = numbers[6] \n        interspersed_numbers[8]\
    \ = numbers[7] \n        interspersed_numbers[9] = numbers[8] \n        interspersed_numbers[10]\
    \ = numbers[9] \n        interspersed_numbers[11] = numbers[10] \n        interspersed_numbers[12]\
    \ = numbers[11] \n        interspersed_numbers[13] = numbers[12] \n        interspersed_numbers[14]\
    \ = numbers[13] \n        interspersed_numbers[15] = numbers[14] \n        interspersed_numbers[16]\
    \ = numbers[15] \n        interspersed_numbers[17] = numbers[16] \n        interspersed_numbers[18]\
    \ = numbers[17] \n        interspersed_numbers[19] = numbers[18] \n        interspersed_numbers[20]\
    \ = numbers[19] \n        interspersed_numbers[21] = numbers[20] \n        interspersed_numbers[22]\
    \ = numbers[21] \n        interspersed_numbers[23] = numbers[22] \n        interspersed_numbers[24]\
    \ = numbers[23] \n        interspersed_numbers[25] = numbers[24] \n        interspersed_numbers[26]\
    \ = numbers[25] \n        interspersed_numbers[27] = numbers[26] \n        interspersed_numbers[28]\
    \ = numbers[27] \n        interspersed_numbers[29] = numbers[28] \n        interspersed_numbers[30]\
    \ = numbers[29] \n        interspersed_numbers[31] = numbers[30] \n        interspersed_numbers[32]\
    \ = numbers[31] \n        interspersed_numbers[33] = numbers[32] \n        interspersed_numbers[34]\
    \ = numbers[33] \n        interspersed_numbers[35] = numbers[34] \n        interspersed_numbers[36]\
    \ = numbers[35] \n        interspersed_numbers[37] = numbers[36] \n        interspersed_numbers[38]\
    \ = numbers[\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxnwc0i4x.jl:1\nin expression starting at /tmp/tmpxnwc0i4x.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\
    \ * delimeter + numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert intersperse([1,2,3], 4) == [1, 4, 2, 4, 3]\n@assert\
    \ intersperse([1,2,3], 2) == [1, 3, 2, 4, 3]\n@assert intersperse([1,2,3], 1)\
    \ == [1, 3, 2, 4]\n@assert intersperse([1,2,3], 0) == [1, 2, 3, 4]\n@assert intersperse([1,2,3],\
    \ -1) == [1, 2, 3, 4]\n@assert intersperse([1,2,3], 2) == [1, 3, 2, 4, 3]\n@assert\
    \ intersperse([1,2,3], 3) == [1, 3, 2, 4, 3, 2]\n@assert intersperse([1,2,3],\
    \ 4) == [1, 4, 2, 4, 3, 2]\n@assert intersperse([1,2,3], 5) == [1, 4, 2, 4, 3,\
    \ 2, 1]\n@assert intersperse([1,2,3], 6) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3],\
    \ 7) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3], 8) == [1, 4, 2, 4,\
    \ 3, 2, 1]\n@assert intersperse([1,2,3], 9) == [1, 4, 2, 4, 3, 2, 1]\n@assert\
    \ intersperse([1,2,3], 10) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3],\
    \ 11) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3], 12) == [1, 4, 2,\
    \ 4, 3, 2, 1]\n@assert intersperse([1,2,3], 13) == [1, 4, 2, 4, 3, 2, 1]\n@assert\
    \ intersperse([1,2,3], 14) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3],\
    \ 15) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3], 16) == [1, 4, 2,\
    \ 4, 3, 2, 1]\n@assert intersperse([1,2,3], 17) == [1, 4, 2, 4, 3, 2, 1]\n@assert\
    \ intersperse([1,2,3], 18) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3],\
    \ 19) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3], 20) == [1, 4, 2,\
    \ 4, 3, 2, 1]\n@assert intersperse([1,2,3], 21) == [1, 4, 2, 4, 3, 2, 1]\n@assert\
    \ intersperse([1,2,3], 22) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3],\
    \ 23) == [1, 4, 2, 4, 3, 2, 1]\n@assert intersperse([1,2,3], 24) == [1, 4, 2,\
    \ 4, 3, 2, 1]\n@assert intersperse([1,2,3], 25) == [1, 4, 2, 4, 3, 2, 1]\n@assert\
    \ intersperse\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5k628jx8.jl:17\nin expression starting at\
    \ /tmp/tmp5k628jx8.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers =\
    \ numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[1:end-1]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmi9rjh48.jl:1\nin expression starting at /tmp/tmpmi9rjh48.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) <= 1\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptzztjafb.jl:18\nin expression starting at\
    \ /tmp/tmptzztjafb.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    elseif length(numbers) == 1\n        return [numbers[1]]\n    else\n\
    \        numbers = intersperse(numbers[2:end-1], delimeter) + [numbers[1]] + intersperse(numbers[2:end-1],\
    \ delimeter)\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if `numbers` has length 1, or if there are multiple consecutive delimiters.\n\
    <|/ c |>\n<| c |>\nI added a version that works with multiple delimiters.\n<|/\
    \ c |>\n<| a dscore=1 |>\nA simple recursive function will do the trick:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmple5dqi1f.jl:16\nin expression starting at\
    \ /tmp/tmple5dqi1f.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[1..end]\
    \ = numbers_copy[1..end][1:end-1]\n    numbers_copy[1..end] = numbers_copy[1..end][2:end]\n\
    \    \n    return numbers_copy\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns the first element of a vector, if it is not empty, or the second\
    \ element otherwise.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5nfd47h7.jl:18\nin expression starting at\
    \ /tmp/tmp5nfd47h7.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsv9ev9r3.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsv9ev9r3.jl:1\n\
    in expression starting at /tmp/tmpsv9ev9r3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    return numbers\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp1zbsfj1r.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp1zbsfj1r.jl:17\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([]), 7) == Vector{Int64}([])\n  MethodError:\
    \ no method matching +(::Vector{Int64}, ::Int64)\n  For element-wise addition,\
    \ use broadcasting with dot syntax: array .+ scalar\n  Closest candidates are:\n\
    \    +(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    +(!Matched::T, ::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128,\
    \ UInt16, UInt32, UInt64, UInt8} at /shared/centos7/julia/1.7.3/share/julia/base/int.jl:87\n\
    \    +(!Matched::T, ::Integer) where T<:AbstractChar at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:237\n\
    \    ...\n  Stacktrace:\n   [1] intersperse(numbers::Vector{Int64}, delimeter::Int64)\n\
    \     @ Main /tmp/tmp1zbsfj1r.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1zbsfj1r.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1zbsfj1r.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp1zbsfj1r.jl:18\n  Test threw exception\n  Expression:\
    \ candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n  MethodError: no method\
    \ matching +(::Vector{Int64}, ::Int64)\n  For element-wise addition, use broadcasting\
    \ with dot syntax: array .+ scalar\n  Closest candidates are:\n    +(::Any, ::Any,\
    \ !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    +(!Matched::T, ::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128,\
    \ UInt16, UInt32, UInt64, UInt8} at /shared/centos7/julia/1.7.3/share/julia/base/int.jl:87\n\
    \    +(!Matched::T, ::Integer) where T<:AbstractChar at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:237\n\
    \    ...\n  Stacktrace:\n   [1] intersperse(numbers::Vector{Int64}, delimeter::Int64)\n\
    \     @ Main /tmp/tmp1zbsfj1r.jl:9\n   [2] macro expansion\n     @ /shared/centos7/"
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpycq2hcmx.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpycq2hcmx.jl:1\n\
    in expression starting at /tmp/tmpycq2hcmx.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.3>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes an input vector of integers and returns the sum of\
    \ the squares of the input vector. \nThe input vector can be of any length.\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7l2eyjfi.jl:17\nin expression starting at\
    \ /tmp/tmp7l2eyjfi.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    elseif length(numbers) == 1\n        return [numbers[0]]\n    else\n\
    \        interspersed_numbers = Vector{Int64}(undef, length(numbers)+1)\n    \
    \    interspersed_numbers[1] = numbers[1]\n        interspersed_numbers[2] = numbers[1]\n\
    \        interspersed_numbers[3] = numbers[2]\n        for i in 2:length(numbers)\n\
    \            interspersed_numbers[i] = numbers[i]\n            interspersed_numbers[i+1]\
    \ = delimeter\n        end\n        return interspersed_numbers\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector of integers and returns the sum\
    \ of the squares of the integers in the vector. \nFor example, \n$$ f([1,2,3])\
    \ = 12 + 16 + 9 + 25 = 78$$\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfl63xhkr.jl:24\nin expression starting at\
    \ /tmp/tmpfl63xhkr.jl:24\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        intersperse(numbers[2:end], delimeter)\
    \ + [numbers[1]] + intersperse(numbers[2:end], delimeter) \n    end\nend\n</cell>\n\
    <code language=julia-1.3>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a vector and returns a new vector where each\
    \ element is the sum of the previous two elements.\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphzb_8qmz.jl:14\nin expression starting at\
    \ /tmp/tmphzb_8qmz.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    else\n        interspersed_numbers = numbers[1 : length(numbers)]\n\
    \        interspersed_numbers = interspersed_numbers .+ interspersed_numbers[1\
    \ : length(interspersed_numbers)]\n        interspersed_numbers = interspersed_numbers\
    \ .+ interspersed_numbers[1 : length(interspersed_numbers)]\n        interspersed_numbers\
    \ = interspersed_numbers .+ interspersed_numbers[1 : length(interspersed_numbers)]\n\
    \        interspersed_numbers = interspersed_numbers .+ interspersed_numbers[1\
    \ : length(interspersed_numbers)]\n        interspersed_numbers = interspersed_numbers\
    \ .+ interspersed_numbers[1 : length(interspersed_numbers)]\n        interspersed_numbers\
    \ = interspersed_numbers .+ interspersed_numbers[1 : length(interspersed_numbers)]\n\
    \        interspersed_numbers = interspersed_numbers .+ interspersed_numbers[1\
    \ : length(interspersed_numbers)]\n        interspersed_numbers = interspersed_numbers\
    \ .+ interspersed_numbers[1 : length(interspersed_numbers)]\n        interspersed_numbers\
    \ = interspersed_numbers .+ interspersed_numbers[1 : length(interspersed_numbers)]\n\
    \        interspersed_numbers = interspersed_numbers .+ interspersed_numbers[1\
    \ : length(interspersed_numbers)]\n        interspersed_numbers = interspersed_numbers\
    \ .+ interspersed_numbers[1 : length(interspersed_numbers)]\n        interspersed_numbers\
    \ = interspersed_numbers .+ interspersed_numbers[1 : length(interspersed_numbers)]\n\
    \        interspersed_numbers = interspersed_numbers .+ interspersed_numbers[1\
    \ : length(interspersed_numbers)]\n        interspersed_numbers = interspersed_numbers\
    \ .+ interspersed_numbers[1 : length(interspersed_numbers)]\n        interspersed_numbers\
    \ = interspersed_numbers .+ interspersed_numbers[1 : length(interspersed_numbers)]\n\
    \        interspersed_numbers = interspersed_numbers .+ interspersed_numbers[1\
    \ : length(interspersed_numbers)]\n        interspersed_numbers = interspersed_numbers\
    \ .+ interspersed_numbers[1 : length(interspersed_numbers)]\n        interspersed_numbers\
    \ = interspersed_numbers .+ interspersed_numbers[1 : length(interspersed_numbers)]\n\
    \        interspersed_numbers = interspersed_numbers .+ interspersed_numbers[1\
    \ : length(interspersed_numbers)]\n        interspersed_numbers = interspersed_numbers\
    \ .+ \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpqg871cp6.jl:8 requires\
    \ end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqg871cp6.jl:1\nin expression\
    \ starting at /tmp/tmpqg871cp6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[1::2]\
    \ = numbers_copy[1::2] + delimeter\n    \n    return numbers_copy\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ a vector of integers where the integers are in descending order. For example,\
    \ if the input vector is [5, 3, 6, 1, 2], the output vector should be [6, 5, 4,\
    \ 3, 2]. Make sure your function works with vectors of different lengths.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp75gk77ue.jl:17\nin expression starting at\
    \ /tmp/tmp75gk77ue.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp20bl9npy.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp20bl9npy.jl:1\n\
    in expression starting at /tmp/tmp20bl9npy.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        numbers\n\
    \    elseif length(numbers) == 1\n        [numbers]\n    else\n        numbers[2:end-1]\
    \ .+ [delimeter, numbers[1]] .+ numbers[2:end]\n    end\nend\n</cell>\n<text>\n\
    Exercise 10\nWrite a function that returns the number of elements in a vector\
    \ that satisfy a given condition. For example, if the vector is [3, 1, 2, 0, 4,\
    \ 0, 2], then your function should return 3 because there are 3 elements in the\
    \ vector that satisfy the condition x>2.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy6kpce_v.jl:16\nin expression starting at\
    \ /tmp/tmpy6kpce_v.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter*ones(1, end-2)\n    return numbers\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a |>\nI wrote a package for this: https://github.com/jrm/intersperse.jl\n\
    <code>\njulia> using Intersperse\nusing Test\n\n@testset begin\n\ncandidate =\
    \ intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpdn4fl3uz.jl:9\nin expression starting at /tmp/tmpdn4fl3uz.jl:9\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) <= 1\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    number\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpglptdo4a.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpglptdo4a.jl:1\n\
    in expression starting at /tmp/tmpglptdo4a.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[2:end]\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8o90voot.jl:1\nin expression starting at /tmp/tmp8o90voot.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) < 2\n      \
    \  return numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1] .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\n\
    end\n</cell>\n<text>\nExercise 7\nWrite a function that takes a vector and returns\
    \ a new vector with all the elements multiplied by two. \nFor example, intersperse([1,\
    \ 2, 3], 4) should return [1, 4, 2, 4, 3].\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxkx048u9.jl:19\nin expression starting at\
    \ /tmp/tmpxkx048u9.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    else\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf3y463kx.jl:67\nin expression starting at\
    \ /tmp/tmpf3y463kx.jl:67\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] .+ delimeter\n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector and returns a new vector where each element is the product of\
    \ the corresponding elements of the input vectors.\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplb7xi545.jl:12\nin expression starting at\
    \ /tmp/tmplb7xi545.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpycq2hcmx.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpycq2hcmx.jl:1\n\
    in expression starting at /tmp/tmpycq2hcmx.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbcnxajt6.jl:1\nin expression starting at /tmp/tmpbcnxajt6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) <= 1\n        return\
    \ numbers\n    end\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[end]\
    \ = numbers_copy[end] + delimeter\n    \n    return numbers_copy\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an input vector and returns the\
    \ number of elements that are equal to its first element. \nFor example, intersperse([1,2,3],\
    \ 4) == 4\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprtg5usou.jl:18\nin expression starting at\
    \ /tmp/tmprtg5usou.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_m93q0ea.jl:1\nin expression starting at /tmp/tmp_m93q0ea.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4r6tagpv.jl:74\nin expression starting at\
    \ /tmp/tmp4r6tagpv.jl:74\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) <= 1\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers\
    \ .+ [delimeter]\n    \n    numbers = numbers .+ numbers[2:end]\n    \n    return\
    \ numbers\nend\n</cell>\n<code language=julia-1.3>\nintersperse([1,2,3], 4)\n\
    </cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkwlnv5vq.jl:20\nin expression starting at\
    \ /tmp/tmpkwlnv5vq.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbcnxajt6.jl:1\nin expression starting at /tmp/tmpbcnxajt6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp20bl9npy.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp20bl9npy.jl:1\n\
    in expression starting at /tmp/tmp20bl9npy.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmbyd0sqa.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmbyd0sqa.jl:1\n\
    in expression starting at /tmp/tmpmbyd0sqa.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuwkls5l5.jl:1\nin expression starting at /tmp/tmpuwkls5l5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        numbers[2:end] = numbers[2:end] + delimeter\
    \ * [numbers[1]]\n        numbers[1:end-1] = numbers[1:end-1] + delimeter * [numbers[2]]\n\
    \        return numbers \nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl2h5n761.jl:15\nin expression starting at\
    \ /tmp/tmpl2h5n761.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    else\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1asc9yhq.jl:1\nin expression starting at /tmp/tmp1asc9yhq.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        numbers\n\
    \    else\n        numbers[2:end-1] .+ [delimeter] .+ numbers[2:end-1]\n    end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,arrays |>\nI came up with this\
    \ solution:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzzo8ic36.jl:14\nin expression starting at\
    \ /tmp/tmpzzo8ic36.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\
    \ * delimeter + numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector of numbers and returns the sum\
    \ of the numbers in that vector. \nWrite a function that takes a vector of numbers\
    \ and returns the product of the numbers in that vector. \nWrite a function that\
    \ takes a vector of numbers and returns the maximum of the numbers in that vector.\
    \ \nWrite a function that takes a vector of numbers and returns the minimum of\
    \ the numbers in that vector. \nWrite a function that takes a vector of numbers\
    \ and returns the number of elements in the vector. \nWrite a function that takes\
    \ a vector of numbers and returns the sum of the squares of the numbers in that\
    \ vector. \nWrite a function that takes a vector of numbers and returns the sum\
    \ of the absolute values of the numbers in that vector. \nWrite a function that\
    \ takes a vector of numbers and returns the sum of the natural logarithms of the\
    \ numbers in that vector. \nWrite a function that takes a vector of numbers and\
    \ returns the sum of the cube of the numbers in that vector. \nWrite a function\
    \ that takes a vector of numbers and returns the sum of the reciprocals of the\
    \ numbers in that vector. \nWrite a function that takes a vector of numbers and\
    \ returns the sum of the exponential of the numbers in that vector. \nWrite a\
    \ function that takes a vector of numbers and returns the sum of the natural logarithms\
    \ of the square of the numbers in that vector. \nWrite a function that takes a\
    \ vector of numbers and returns the sum of the exponential of the square of the\
    \ numbers in that vector. \nWrite a function that takes a vector of numbers and\
    \ returns the sum of the exponential of the cube of the numbers in that vector.\
    \ \nWrite a function that takes a vector of numbers and returns the sum of the\
    \ exponential of the reciprocals of the numbers in that vector. \nWrite a function\
    \ that takes a vector of numbers and returns the sum of the exponential of the\
    \ cube of the square of the numbers in that vector. \nWrite a function that takes\
    \ a vector of numbers and returns the sum of the exponential of the cube of the\
    \ cube of the numbers in that vector. \nWrite a function that takes a vector of\
    \ numbers and returns the sum of the exponential of the cube of the cube of the\
    \ square of the numbers in that vector. \nWrite a function that takes a vector\
    \ of numbers and returns the sum of the exponential of the cube of the cube of\
    \ the cube of the numbers in that vector. \nWrite a function that takes a vector\
    \ of numbers and returns the sum of the exponential of the cube of the cube of\
    \ the cube of the square of the numbers in that vector. \nWrite a function that\
    \ takes a vector of numbers and returns the sum of the exponential of the cube\
    \ of the cube of the cube of the cube of the numbers in that vector. \nWrite a\
    \ function that takes a vector of numbers and returns the sum of the exponential\
    \ of the cube of the cube of the cube of the cu\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp11wpgb_e.jl:17\nin expression starting at\
    \ /tmp/tmp11wpgb_e.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers .+ [delimeter]\n    numbers = numbers .+ numbers\n    \n\
    \    return numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 4)\n</cell>\n<text>\nThe function intersperse is defined in the file src/intersperse.jl.\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo17u9aav.jl:18\nin expression starting at\
    \ /tmp/tmpo17u9aav.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[1..end]\
    \ = numbers_copy[1..end][1:end-1]\n    \n    return numbers_copy\nend\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a vector of numbers and returns the sum of the\
    \ squares of the numbers in the vector.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8ierhjny.jl:17\nin expression starting at\
    \ /tmp/tmp8ierhjny.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers .+\
    \ [delimeter]\n    \n    numbers = numbers .+ numbers[2:end]\n    \n    return\
    \ numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1, 2, 3], 4)\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes as input a vector of\
    \ integers and returns the sum of the squares of the integers in the vector.\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzbeg1hfv.jl:19\nin expression starting at\
    \ /tmp/tmpzbeg1hfv.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    else\n        numbers = numbers[2:end-1]\n        numbers = [numbers[1],\
    \ numbers[1]+delimeter, numbers[2]]\n        return intersperse(numbers, delimeter+1)\n\
    \    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThanks for your answer.\
    \ Your solution works but it's very slow. I'm looking for a solution which doesn't\
    \ involve loops.\n<|/ c |>\n<| c |>\nI edited my answer to include a solution\
    \ that doesn't involve loops.\n<|/ c |>\n<| c |>\nThanks for your answer. Your\
    \ solution works but it's very slow. I'm looking for a solution which doesn't\
    \ involve loops.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkn2d3g3p.jl:16\nin expression starting at\
    \ /tmp/tmpkn2d3g3p.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) <= 1\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwkw8e7u2.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwkw8e7u2.jl:1\n\
    in expression starting at /tmp/tmpwkw8e7u2.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuwkls5l5.jl:1\nin expression starting at /tmp/tmpuwkls5l5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers\n    else \n        numbers[2:end] = numbers[2:end] + delimeter\n\
    \        return numbers[2:end]\n    end\nend\n</cell>\n<text>\nExercise 10\nWrite\
    \ a function that returns the sum of the elements of input vector `numbers'\n\
    \    >>> sum([1, 2, 3])\n    6\n    >>> sum([1, 2, 3, 5])\n    10\n    >>> sum([1,\
    \ 2, 3, 5])\n    10\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9z7e3_ri.jl:15\nin expression starting at\
    \ /tmp/tmp9z7e3_ri.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplzpj5jw_.jl:1\nin expression starting at /tmp/tmplzpj5jw_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers\n    \n    numbers_copy = numbers.copy()\n    \n    for i\
    \ in 1:length(numbers)\n        numbers_copy[i] = numbers_copy[i] + delimeter\n\
    \    end\n    \n    return numbers_copy\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert intersperse([1,2,3], 4) == [1, 4, 2, 4, 3]\n@assert intersperse([1,2,3],\
    \ 5) == [1, 5, 3, 6, 4, 5]\n@assert intersperse([1,2,3], 6) == [1, 6, 2, 7, 3,\
    \ 8, 4, 9]\n@assert intersperse([1,2,3], 7) == [1, 7, 2, 8, 3, 9, 4, 10]\n@assert\
    \ intersperse([1,2,3], 8) == [1, 8, 2, 9, 3, 10, 4, 11]\n@assert intersperse([1,2,3],\
    \ 9) == [1, 9, 2, 10, 3, 11, 4, 12]\n@assert intersperse([1,2,3], 10) == [1, 10,\
    \ 2, 11, 3, 12, 4, 13]\n@assert intersperse([1,2,3], 11) == [1, 11, 2, 12, 3,\
    \ 13, 4, 14]\n@assert intersperse([1,2,3], 12) == [1, 12, 2, 13, 3, 14, 4, 15]\n\
    @assert intersperse([1,2,3], 13) == [1, 13, 2, 14, 3, 15, 4, 16]\n@assert intersperse([1,2,3],\
    \ 14) == [1, 14, 2, 15, 3, 16, 4, 17]\n@assert intersperse([1,2,3], 15) == [1,\
    \ 15, 2, 16, 3, 17, 4, 18]\n@assert intersperse([1,2,3], 16) == [1, 16, 2, 17,\
    \ 3, 18, 4, 19]\n@assert intersperse([1,2,3], 17) == [1, 17, 2, 18, 3, 19, 4,\
    \ 20]\n@assert intersperse([1,2,3], 18) == [1, 18, 2, 19, 3, 20, 4, 21]\n@assert\
    \ intersperse([1,2,3], 19) == [1, 19, 2, 20, 3, 21, 4, 22]\n@assert intersperse([1,2,3],\
    \ 20) == [1, 20, 2, 21, 3, 22, 4, 23]\n@assert intersperse([1,2,3], 21) == [1,\
    \ 21, 2, 22, 3, 23, 4, 24]\n@assert intersperse([1,2,3], 22) == [1, 22, 2, 23,\
    \ 3, 24, 4, 25]\n@assert intersperse([1,2,3], 23) == [1, 23, 2, 24, 3, 25, 4,\
    \ 26]\n@assert intersperse([1,2,3], 24) == [1, 24, 2, 25, 3, 26, 4, 27]\n@assert\
    \ intersperse([1,2,3], 25) == [1, 25, 2, 26, 3, 27, 4, 28]\n@assert intersperse([1,2,3],\
    \ 26) == [1, 26, 2, 27, 3, 28, 4, 29]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiruu5cx5.jl:19\nin expression starting at\
    \ /tmp/tmpiruu5cx5.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbcnxajt6.jl:1\nin expression starting at /tmp/tmpbcnxajt6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        numbers\n\
    \    else\n        numbers[2:end-1] .+ [delimeter] .+ numbers[2:end-1]\n    end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdx40037h.jl:14\nin expression starting at\
    \ /tmp/tmpdx40037h.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        intersperse(numbers[2:end], delimeter)\
    \ + [numbers[1]] + intersperse(numbers[2:end], delimeter)\n    end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nA simple recursive function would do the\
    \ trick:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpehbv1216.jl:14\nin expression starting at\
    \ /tmp/tmpehbv1216.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        numbers\n\
    \    else\n        numbers[2:end-1] .+ [delimeter] .+ numbers[1:end-1]\n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nA simple solution using\
    \ zip:\n<code>\njulia> numbers = [1, 2, 3, 4]\n4-element Array{Int64,1}:\n 1\n\
    \ 2\n 3\n 4\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp10nx0som.jl:14\nin expression starting at\
    \ /tmp/tmp10nx0som.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     numbers = numbers[:]\n    end\n    numbers[2:end] = numbers[2:end] + delimeter\n\
    \    return numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 4)\n</cell>\n<text>\nExercise 3\nWrite a function that returns the first n prime\
    \ numbers. \nHint: use the sieve of Eratosthenes algorithm\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_qhsbi78.jl:14\nin expression starting at\
    \ /tmp/tmp_qhsbi78.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpycq2hcmx.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpycq2hcmx.jl:1\n\
    in expression starting at /tmp/tmpycq2hcmx.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    else\n        numbers[end+1:end+delimeter+1] = numbers[end+1:end+delimeter+1].+numbers[end+1:end+delimeter+1]\n\
    \        return numbers[end+1:end+delimeter+1]\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nHere's a solution using only built-in functions:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_9c2fvu2.jl:15\nin expression starting at\
    \ /tmp/tmp_9c2fvu2.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        numbers[end+1:end+delimeter] = numbers[end+1:end+delimeter]\
    \ .+ delimeter\n        return numbers[end+1:end+delimeter]\n    end\nend\n</cell>\n\
    <text>\nExercise 7: Intersperse a number between every two consecutive elements\
    \ of input vector numbers. Test your function with different delimeters.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4fej428t.jl:15\nin expression starting at\
    \ /tmp/tmp4fej428t.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    return numbers\nend\n</cell>\n<text>\nThe\
    \ intersperse function takes an input vector numbers and a number delimeter and\
    \ returns a new vector with numbers in between every two consecutive elements\
    \ of numbers. For example, intersperse([1, 2, 3, 4], 4) returns [1, 4, 2, 4].\
    \ Notice that this function does not modify the input vector.\nusing Test\n\n\
    @testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbr6br23t.jl:12\nin expression starting at\
    \ /tmp/tmpbr6br23t.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfuvvx7bv.jl:1\nin expression starting at /tmp/tmpfuvvx7bv.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers = numbers[:]\n    end\n    numbers[2:end] = numbers[2:end] + delimeter\n\
    \    return numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,\
    \ 2, 3], 4)\n</cell>\n<text>\nThe function intersperse is defined in the file\
    \ src/intersperse.jl and can be found in the Julia package JuliaIntersperse. The\
    \ package is available on Julia's package manager Pkg.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdq1i9iuc.jl:14\nin expression starting at\
    \ /tmp/tmpdq1i9iuc.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqidwr_9q.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqidwr_9q.jl:1\n\
    in expression starting at /tmp/tmpqidwr_9q.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4r6tagpv.jl:74\nin expression starting at\
    \ /tmp/tmp4r6tagpv.jl:74\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    \n    numbers = numbers + [numbers[1]]\n\
    \    \n    return numbers\nend\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp76ko44cf.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp76ko44cf.jl:1\n\
    in expression starting at /tmp/tmp76ko44cf.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp43oeluhm.jl:1\nin expression starting at /tmp/tmp43oeluhm.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) == 0\n     \
    \   return numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers =\
    \ numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1]\n    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg5s2l1ym.jl:1\nin expression starting at /tmp/tmpg5s2l1ym.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0 \n        return\
    \ numbers \n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[2:\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp994g3q0m.jl:102\nin expression starting at\
    \ /tmp/tmp994g3q0m.jl:102\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        intersperse(numbers[2:end-1], delimeter)\
    \ + [numbers[1]] + intersperse(numbers[3:end], delimeter) \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes an input vector of integers and returns the sum\
    \ of the squares of the input vector. \nThe input vector can be of any length.\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8rt0nnrx.jl:14\nin expression starting at\
    \ /tmp/tmp8rt0nnrx.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  if length(numbers) < 2\n        return numbers\n    end\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfpl7id2g.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfpl7id2g.jl:1\n\
    in expression starting at /tmp/tmpfpl7id2g.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] .+ delimeter\n    numbers\nend\n</cell>\n<code language=julia-1.3>\n\
    intersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the first n prime numbers. \nHint: Use a for loop and a prime number sieve.\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk6t9wr09.jl:12\nin expression starting at\
    \ /tmp/tmpk6t9wr09.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  if length(numbers) == 0\n        return numbers\n    end\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    number\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvmwxibvv.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvmwxibvv.jl:1\n\
    in expression starting at /tmp/tmpvmwxibvv.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) == 0\n     \
    \   return numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1] .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\n\
    end\n</cell>\n<code language=julia-1.5>\n@time intersperse([1,2,3], 4)\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the first element of a vector,\
    \ if it is not empty, otherwise return \"Empty\".\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8xz4f0hw.jl:19\nin expression starting at\
    \ /tmp/tmp8xz4f0hw.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) <= 1\n     \
    \   return numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = intersperse(numbers, delimeter)\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers =\
    \ numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers =\
    \ numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    number\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp40t94e8d.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp40t94e8d.jl:1\n\
    in expression starting at /tmp/tmp40t94e8d.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    else\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n\
    \        numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n    \
    \    numbers = numbers[2:end-1]\n        numbers = numbers[2:end-1]\n        numbers\
    \ = numbers[2:\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf3y463kx.jl:67\nin expression starting at\
    \ /tmp/tmpf3y463kx.jl:67\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplzpj5jw_.jl:1\nin expression starting at /tmp/tmplzpj5jw_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers = numbers[:]\n    end\n    numbers[2:end] = numbers[2:end] + delimeter\n\
    \    return numbers\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ when `numbers` has length `1`\n<|/ c |>\n<| a tags=julia |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp390aj33u.jl:14\nin expression starting at\
    \ /tmp/tmp390aj33u.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    numbers\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=julia,arrays |>\nA more general solution:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4pfowhkw.jl:12\nin expression starting at\
    \ /tmp/tmp4pfowhkw.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n   \
    \ numbers = intersperse(numbers, delimeter)\n    numbers = numbers[2:end]\n  \
    \  numbers = numbers[2:end]\n    numbers = intersperse(numbers, delimeter)\n \
    \   numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n   \
    \ numbers = intersperse(numbers, delimeter)\n    numbers = numbers[2:end]\n  \
    \  numbers = numbers[2:end]\n    numbers = intersperse(numbers, delimeter)\n \
    \   numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n   \
    \ numbers = intersperse(numbers, delimeter)\n    numbers = numbers[2:end]\n  \
    \  numbers = numbers[2:end]\n    numbers = intersperse(numbers, delimeter)\n \
    \   numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n   \
    \ numbers = intersperse(numbers, delimeter)\n    numbers = numbers[2:end]\n  \
    \  numbers = numbers[2:end]\n    numbers = intersperse(numbers, delimeter)\n \
    \   numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n   \
    \ numbers = intersperse(numbers, delimeter)\n    numbers = numbers[2:end]\n  \
    \  numbers = numbers[2:end]\n    numbers = intersperse(numbers, delimeter)\n \
    \   numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n   \
    \ numbers = intersperse(numbers, delimeter)\n    numbers = numbers[2:end]\n  \
    \  numbers = numbers[2:end]\n    numbers = intersperse(numbers, delimeter)\n \
    \   numbers = numbers[\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7l0pxinh.jl:1\nin expression starting at /tmp/tmp7l0pxinh.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    else\n        numbers[2:end] = numbers[2:end] + delimeter\n\
    \        return numbers[2:end]\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the sum of the elements of input vector `numbers'\n\
    \    >>> sum([1, 2, 3])\n    6\n    >>> sum([1, 2, 3, 4])\n    10\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyd36a_dc.jl:15\nin expression starting at\
    \ /tmp/tmpyd36a_dc.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbcnxajt6.jl:1\nin expression starting at /tmp/tmpbcnxajt6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n    \n    numbers =\
    \ numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n  \
    \  \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n  \
    \  \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n    \n\
    \    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n  \
    \  numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n    \n    numbers\
    \ = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n    numbers =\
    \ numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n    \n    numbers =\
    \ numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n  \
    \  \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\n    \n  \
    \  numbers = number\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkjs0m1zf.jl:1\nin expression starting at /tmp/tmpkjs0m1zf.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwvcsabzq.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwvcsabzq.jl:1\n\
    in expression starting at /tmp/tmpwvcsabzq.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0 \n        return\
    \ numbers \n    \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1]\
    \ \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers\
    \ = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1]\
    \ \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers\
    \ = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1]\
    \ \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers\
    \ = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1]\
    \ \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers\
    \ = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1]\
    \ \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers\
    \ = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1]\
    \ \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers\
    \ = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1]\
    \ \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers\
    \ = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1]\
    \ \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers\
    \ = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1]\
    \ \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers\
    \ = numbers[2:end-1] \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1]\
    \ \n    numbers = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers\
    \ = numbers[1:end-1] \n    numbers = numbers[2:end-1] \n    numbers = numbers[1:end-1]\
    \ \n    numbers = numbers[2:end\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp72prw28u.jl:1\nin expression starting at /tmp/tmp72prw28u.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    return numbers\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that returns the sum of the elements of input vector `numbers'\n\
    \    >>> sum([1, 2, 3])\n    6\n    >>> sum([1, 2, 3, 4])\n    10\n    \"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm6_pghlu.jl:12\nin expression starting at\
    \ /tmp/tmpm6_pghlu.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        return numbers[1 : length(numbers) -\
    \ (delimeter - 1)] + delimeter * [numbers[length(numbers) - (delimeter - 1)]]\n\
    end\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\n\
    The function intersperse is defined above. Now let's see how it works:\nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvgqyk83y.jl:13\nin expression starting at\
    \ /tmp/tmpvgqyk83y.jl:13\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  if length(numbers) <= 1\n        return numbers\n    end\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvtulthwo.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvtulthwo.jl:1\n\
    in expression starting at /tmp/tmpvtulthwo.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    \n    numbers = numbers + [numbers[1]]\n\
    \    \n    return numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 4)\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector of numbers\
    \ and returns the sum of the squares of the numbers. \nThe function should work\
    \ for vectors of any length.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxa7xw098.jl:20\nin expression starting at\
    \ /tmp/tmpxa7xw098.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[2:end]\n    numbers = numbers[2:\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpump2_r5v.jl:73\nin expression starting at\
    \ /tmp/tmpump2_r5v.jl:73\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = intersperse(numbers, delimeter)\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = intersperse(numbers, delimeter)\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers, delimeter)\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu29za4uf.jl:1\nin expression starting at /tmp/tmpu29za4uf.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[1::2]\
    \ = delimeter\n    \n    return numbers_copy\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a vector of integers and returns the sum of the even numbers in that vector.\
    \ \nWrite a second function that takes a vector of integers and returns the sum\
    \ of the odd numbers in that vector. \nWrite a third function that takes a vector\
    \ of integers and returns the sum of the even numbers in that vector. \nWrite\
    \ a fourth function that takes a vector of integers and returns the sum of the\
    \ odd numbers in that vector. \nWrite a fifth function that takes a vector of\
    \ integers and returns the sum of the even numbers in that vector. \nWrite a sixth\
    \ function that takes a vector of integers and returns the sum of the odd numbers\
    \ in that vector. \nWrite a seventh function that takes a vector of integers and\
    \ returns the sum of the even numbers in that vector. \nWrite a eighth function\
    \ that takes a vector of integers and returns the sum of the odd numbers in that\
    \ vector. \nWrite a ninth function that takes a vector of integers and returns\
    \ the sum of the even numbers in that vector. \nWrite a tenth function that takes\
    \ a vector of integers and returns the sum of the odd numbers in that vector.\
    \ \nWrite a eleventh function that takes a vector of integers and returns the\
    \ sum of the even numbers in that vector. \nWrite a twelfth function that takes\
    \ a vector of integers and returns the sum of the odd numbers in that vector.\
    \ \nWrite a thirteenth function that takes a vector of integers and returns the\
    \ sum of the even numbers in that vector. \nWrite a fourteenth function that takes\
    \ a vector of integers and returns the sum of the odd numbers in that vector.\
    \ \nWrite a fifteenth function that takes a vector of integers and returns the\
    \ sum of the even numbers in that vector. \nWrite a sixteenth function that takes\
    \ a vector of integers and returns the sum of the odd numbers in that vector.\
    \ \nWrite a seventeenth function that takes a vector of integers and returns the\
    \ sum of the even numbers in that vector. \nWrite a eighteenth function that takes\
    \ a vector of integers and returns the sum of the odd numbers in that vector.\
    \ \nWrite a nineteenth function that takes a vector of integers and returns the\
    \ sum of the even numbers in that vector. \nWrite a twentieth function that takes\
    \ a vector of integers and returns the sum of the odd numbers in that vector.\
    \ \nWrite a twenty-first function that takes a vector of integers and returns\
    \ the sum of the even numbers in that vector. \nWrite a twenty-second function\
    \ that takes a vector of integers and returns the sum of the odd numbers in that\
    \ vector. \nWrite a twenty-third function that takes a \nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_cmnk9lc.jl:17\nin expression starting at\
    \ /tmp/tmp_cmnk9lc.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) == 0\n     \
    \   return numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1] * delimeter + numbers[2:end]\n    \n    return numbers\n\
    end\n</cell>\n<code language=julia-1.5>\nintersperse([1, 2, 3], 4)\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes an input vector of integers and\
    \ returns the sum of the squares of the input vector. \nFor example, \n$$\n\\\
    begin{align}\n\\text{sum}(\\boldsymbol{x})^2 = \\sum{i=1}^{n} x_i^2\n\\end{align}\n\
    $$\nWrite a test to check your function.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9yp7okk5.jl:19\nin expression starting at\
    \ /tmp/tmp9yp7okk5.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     numbers = numbers[:]\n    end\n    \n    numbers = numbers[start:end]\n\
    \    \n    if length(numbers) < delimeter \n        numbers = numbers[:]\n   \
    \ end\n    \n    numbers = numbers[start:end]\n    \n    return numbers\nend\n\
    </cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 5)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 6)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 7)\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 8)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 9)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 10)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 11)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 12)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 13)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 14)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 15)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 16)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 17)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 18)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 19)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 20)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 21)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 22)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 23)\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 24)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 25)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3],\
    \ 26)\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 27)\n</cell>\n\
    <code language=julia-1.5>\nintersperse\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4c2qnen3.jl:22\nin expression starting at\
    \ /tmp/tmp4c2qnen3.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp08x4im1u.jl:1\nin expression starting at /tmp/tmp08x4im1u.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[2:end]\n    numbers\
    \ = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmbyd0sqa.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmbyd0sqa.jl:1\n\
    in expression starting at /tmp/tmpmbyd0sqa.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    else\n        numbers[end+1:end+delimeter+1] = numbers[end+1:end+delimeter+1].+delimeter\n\
    \        return numbers[end:end+delimeter]\n    end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=julia |>\nI wrote a package for this. It has two functions: intersperse\
    \ and intersperse!.\n<code>\nusing Intersperse\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpppl1y_1x.jl:15\nin expression starting at\
    \ /tmp/tmpppl1y_1x.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    else\n        numbers[2:end] = numbers[2:end] + delimeter * ones(length(numbers[2:end]),\
    \ 1)\n        return numbers[2:end]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of numbers and returns the vector with all the numbers divided\
    \ by two, except for the first and last number. For example, intersperse([1,2,3],\
    \ 4) should return [2, 4, 1, 3, 1].\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpinsrxm6f.jl:15\nin expression starting at\
    \ /tmp/tmpinsrxm6f.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers .+\
    \ [delimeter]\n    \n    return numbers\nend\n</cell>\n<text>\nThe function intersperse\
    \ is defined above. Let's test it with the example above.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpty47wc5l.jl:17\nin expression starting at\
    \ /tmp/tmpty47wc5l.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_m93q0ea.jl:1\nin expression starting at /tmp/tmp_m93q0ea.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    return numbers\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a vector of numbers and returns the sum of the\
    \ numbers in the vector. \nWrite a function that takes a vector of numbers and\
    \ returns the product of the numbers in the vector. \nWrite a function that takes\
    \ a vector of numbers and returns the maximum of the numbers in the vector. \n\
    Write a function that takes a vector of numbers and returns the minimum of the\
    \ numbers in the vector. \nWrite a function that takes a vector of numbers and\
    \ returns the product of the numbers in the vector divided by the sum of the numbers\
    \ in the vector. \nWrite a function that takes a vector of numbers and returns\
    \ the product of the numbers in the vector divided by the product of the numbers\
    \ in the vector. \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa1oo_ubb.jl:12\nin expression starting at\
    \ /tmp/tmpa1oo_ubb.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0 \n        return\
    \ numbers \n    else \n        numbers = numbers[2:end-1] \n        numbers =\
    \ [numbers[1], delimeter, numbers...] \n        return numbers \n    end\nend\n\
    </code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\nI came up with this solution:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpknuheieq.jl:16\nin expression starting at\
    \ /tmp/tmpknuheieq.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns the number of elements in a vector that satisfy\
    \ a given condition. For example, suppose that we want to count the number of\
    \ elements in a vector that satisfy the condition $x > 3$. Write a function that\
    \ takes a vector and a condition as input, and returns the number of elements\
    \ in the vector that satisfy the condition.\nusing Test\n\n@testset begin\n\n\
    candidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw25jfcew.jl:18\nin expression starting at\
    \ /tmp/tmpw25jfcew.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers\n    else\n        numbers[1 : length(numbers) - (delimeter - length(numbers))]\
    \ + delimeter * ones(delimeter - length(numbers))\n    end\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqr806shw.jl:14\nin expression starting at\
    \ /tmp/tmpqr806shw.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    else\n        numbers = numbers[2:end-1]\n        numbers = [numbers[1];\
    \ numbers; numbers[2]]\n        return numbers\n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfquq21_9.jl:16\nin expression starting at\
    \ /tmp/tmpfquq21_9.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end-1]\
    \ .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1, 2, 3], 4)\n</cell>\n<text>\nThe function\
    \ intersperse is now available in the Pkg.jl package as intersperse. Let's try\
    \ it out on a few examples:\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprted1vg8.jl:18\nin expression starting at\
    \ /tmp/tmprted1vg8.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers\
    \ + [numbers[1]]\n    \n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a vector of integers and returns the sum of the squares of the integers in the\
    \ vector.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplnf2e9r8.jl:21\nin expression starting at\
    \ /tmp/tmplnf2e9r8.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0 \n        return\
    \ numbers \n    else \n        numbers[2:end] = numbers[2:end] + delimeter * [numbers[1]]\
    \ \n        numbers[1:end-1] = numbers[1:end-1] + delimeter * [numbers[end]]\n\
    \        return numbers \n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes an input vector of numbers and returns the sum of all numbers in\
    \ the input vector. \nThe function should return an error if the input vector\
    \ is empty.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwf3_4h9e.jl:16\nin expression starting at\
    \ /tmp/tmpwf3_4h9e.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ * delimeter + numbers[2:end]\n    \n    return numbers\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgeuuyofk.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpgeuuyofk.jl:1\n\
    in expression starting at /tmp/tmpgeuuyofk.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplzpj5jw_.jl:1\nin expression starting at /tmp/tmplzpj5jw_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers\n    else\n        numbers[1 : length(numbers)-delimeter+1] + delimeter*ones(delimeter,\
    \ length(numbers)-delimeter)\n    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n\
    <| a tags=julia,arrays |>\nA simple way is to use split to split your array into\
    \ two parts, one containing the first n elements and one containing the rest.\
    \ Then you can concatenate them back together with cat:\n<code>\njulia> a = [1,2,3,4,5,6,7,8,9,10]\n\
    10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1b5ppwqe.jl:14\nin expression starting at\
    \ /tmp/tmp1b5ppwqe.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes an array of numbers and returns the array reversed.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuztvlqwi.jl:12\nin expression starting at\
    \ /tmp/tmpuztvlqwi.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers\n    else\n        numbers[1 : length(numbers)-delimeter+1] + delimeter*[numbers[length(numbers)-delimeter+1]]\
    \ + numbers[length(numbers)-delimeter+2 : length(numbers)]\n    end\nend\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes an input vector and returns the\
    \ number of elements that are not equal to zero.\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprv3d583k.jl:14\nin expression starting at\
    \ /tmp/tmprv3d583k.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) <= 1\n        return\
    \ numbers\n    end\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[end]\
    \ = numbers_copy[end] + delimeter\n    \n    return numbers_copy\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an input vector and returns the\
    \ number of elements that are greater than or equal to 5\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvf4luy3w.jl:18\nin expression starting at\
    \ /tmp/tmpvf4luy3w.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    \n    interspersed_numbers = Vector{Int64}(undef, length(numbers)+delimeter)\n\
    \    \n    for i in 1:length(numbers)\n        interspersed_numbers[i+1:i+delimeter+1]\
    \ = numbers[i:i+delimeter]\n    end\n    \n    return interspersed_numbers\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_rqg6cob.jl:19\nin expression starting at\
    \ /tmp/tmp_rqg6cob.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\
    \ .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a vector and returns a vector where each element is\
    \ the sum of the previous two elements.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyknq_yll.jl:17\nin expression starting at\
    \ /tmp/tmpyknq_yll.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] .+ delimeter\n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of integers and returns a vector of integers where the integers\
    \ are in descending order. For example, if the input vector is [4, 3, 2], the\
    \ output vector should be [3, 2, 4]. You may use the sort() function.\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfj81r_jx.jl:12\nin expression starting at\
    \ /tmp/tmpfj81r_jx.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[1..end]\
    \ = numbers_copy[1..end][1:end-1]\n    \n    return numbers_copy\nend\n</cell>\n\
    <code language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a vector of numbers and returns the sum of the\
    \ numbers in the vector. \nWrite a second function that takes a vector of numbers\
    \ and returns the product of the numbers in the vector. \nWrite a third function\
    \ that takes a vector of numbers and returns the maximum of the numbers in the\
    \ vector. \nWrite a fourth function that takes a vector of numbers and returns\
    \ the minimum of the numbers in the vector. \nWrite a fifth function that takes\
    \ a vector of numbers and returns the number of elements in the vector. \nWrite\
    \ a sixth function that takes a vector of numbers and returns the sum of the squares\
    \ of the numbers in the vector. \nWrite a seventh function that takes a vector\
    \ of numbers and returns the sum of the cubes of the numbers in the vector. \n\
    Write a eighth function that takes a vector of numbers and returns the sum of\
    \ the exponential of the numbers in the vector. \nWrite a ninth function that\
    \ takes a vector of numbers and returns the sum of the natural logarithms of the\
    \ numbers in the vector. \nWrite a tenth function that takes a vector of numbers\
    \ and returns the sum of the absolute values of the numbers in the vector. \n\
    Write a eleventh function that takes a vector of numbers and returns the sum of\
    \ the reciprocals of the numbers in the vector. \nWrite a twelfth function that\
    \ takes a vector of numbers and returns the sum of the squares of the first n\
    \ numbers in the vector. \nWrite a thirteenth function that takes a vector of\
    \ numbers and returns the sum of the cubes of the first n numbers in the vector.\
    \ \nWrite a fourteenth function that takes a vector of numbers and returns the\
    \ sum of the exponential of the first n numbers in the vector. \nWrite a fifteenth\
    \ function that takes a vector of numbers and returns the sum of the natural logarithms\
    \ of the first n numbers in the vector. \nWrite a sixteenth function that takes\
    \ a vector of numbers and returns the sum of the absolute values of the first\
    \ n numbers in the vector. \nWrite a seventeenth function that takes a vector\
    \ of numbers and returns the sum of the reciprocals of the first n numbers in\
    \ the vector. \nWrite a eighteenth function that takes a vector of numbers and\
    \ returns the sum of the squares of the first n numbers in the vector. \nWrite\
    \ a nineteenth function that takes a vector of numbers and returns the sum of\
    \ the cubes of the first n numbers in the vector. \nWrite a twenty function that\
    \ takes a vector of numbers and returns the sum of the exponential of the first\
    \ n numbers in the vector. \nWrite a twenty-first function that takes a vector\
    \ of numbers and returns the sum of the natural logarithms of the first n numbers\
    \ in the vector. \nWrite a \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2p54vnn6.jl:17\nin expression starting at\
    \ /tmp/tmp2p54vnn6.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] .+ delimeter\n    return numbers\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for `intersperse([1,2,3], 4)` which should return\
    \ `[1, 4, 2, 4, 4, 3]`\n<|/ c |>\n<| c |>\nI see what you mean. I've edited my\
    \ answer to fix the issue\n<|/ c |>\n<| c |>\nThis doesn't work for `intersperse([1,2,3],\
    \ 4)` which should return `[1, 4, 2, 4, 4, 3]`\n<|/ c |>\n<| c |>\nI see what\
    \ you mean. I've edited my answer to fix the issue\n<|/ c |>\n<| a dscore=2 |>\n\
    A simple recursive function will do the trick:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4jznydjf.jl:12\nin expression starting at\
    \ /tmp/tmp4jznydjf.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        numbers\n\
    \    else\n        numbers[2:end-1] .+ [delimeter] .+ numbers[2:end-1]\n    end\n\
    end\n</code>\n<|/ a tags=julia,arrays |>\n<| a |>\nThe easiest way is to use intersperse:\n\
    <code>\njulia> intersperse([1,2,3], 4)\n1-element Array{Int64,1}:\n 1\n 2\n 3\n\
    </code>\n<|/ a dscore=2 tags=julia,arrays |>\n<| a tags=julia,arrays |>\nI wanted\
    \ to add an answer that uses mapslices, which is more efficient than intersperse:\n\
    <code>\njulia> mapslices(x -> [x], 1:3, 1)\n3-element Array{Array{Int64,1},1}:\n\
    \ [1]\n [2]\n [3]\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,arrays |>\nI came\
    \ up with this:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0499wc18.jl:14\nin expression starting at\
    \ /tmp/tmp0499wc18.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  lenght = length(numbers)\n    \n    if lenght == 0\n        return numbers\n\
    \    end\n    \n    numbers[lenght] = delimeter\n    \n    numbers = numbers[2:end]\n\
    \    \n    return numbers\nend\n</cell>\n<code language=julia-1.3>\nintersperse([1,\
    \ 2, 3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector\
    \ of integers and returns a vector of integers where the integers are the sum\
    \ of the integers in the original vector except for the first and last integers.\
    \ For example, if the input vector is [10, 20, 30, 40, 50], the output vector\
    \ should be [10, 30, 50, 70, 100].\nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm0omn0p6.jl:23\nin expression starting at\
    \ /tmp/tmpm0omn0p6.jl:23\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  if length(numbers) < 2\n        return numbers\n    end\n    \n    push!(numbers,\
    \ numbers[1])\n    \n    i = 2\n    while i < length(numbers)\n        push!(numbers,\
    \ numbers[i])\n        push!(numbers, delimeter)\n        i += 1\n    end\n  \
    \  \n    return numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,\
    \ 2, 3], 4)\n</cell>\n<text>\nThe function intersperse() above is called intersperse()\
    \ because it is used to intersperse a number between every two consecutive elements\
    \ of input vector numbers. For example, intersperse([1, 2, 3, 4], 4) returns [1,\
    \ 2, 4, 3, 4.].\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp84sfc002.jl:26\nin expression starting at\
    \ /tmp/tmp84sfc002.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp022eari5.jl:1\nin expression starting at /tmp/tmp022eari5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers .+ [delimeter]\n    numbers = numbers .+ numbers[1:end-1]\n\
    \    return numbers\nend\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw7y64f4w.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw7y64f4w.jl:1\n\
    in expression starting at /tmp/tmpw7y64f4w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    else\n        interspersed_numbers = numbers[2:end]\n        interspersed_numbers\
    \ = [interspersed_numbers, numbers[1]]\n        interspersed_numbers = interspersed_numbers[1:end-1]\n\
    \        interspersed_numbers = [interspersed_numbers, delimeter]\n        interspersed_numbers\
    \ = interspersed_numbers[2:end]\n        interspersed_numbers = interspersed_numbers[1:end-1]\n\
    \        interspersed_numbers = interspersed_numbers[2:end]\n        interspersed_numbers\
    \ = interspersed_numbers[1:end-1]\n        interspersed_numbers = interspersed_numbers[2:end]\n\
    \        interspersed_numbers = interspersed_numbers[1:end-1]\n        interspersed_numbers\
    \ = interspersed_numbers[2:end]\n        interspersed_numbers = interspersed_numbers[1:end-1]\n\
    \        interspersed_numbers = interspersed_numbers[2:end]\n        interspersed_numbers\
    \ = interspersed_numbers[1:end-1]\n        interspersed_numbers = interspersed_numbers[2:end]\n\
    \        interspersed_numbers = interspersed_numbers[1:end-1]\n        interspersed_numbers\
    \ = interspersed_numbers[2:end]\n        interspersed_numbers = interspersed_numbers[1:end-1]\n\
    \        interspersed_numbers = interspersed_numbers[2:end]\n        interspersed_numbers\
    \ = interspersed_numbers[1:end-1]\n        interspersed_numbers = interspersed_numbers[2:end]\n\
    \        interspersed_numbers = interspersed_numbers[1:end-1]\n        interspersed_numbers\
    \ = interspersed_numbers[2:end]\n        interspersed_numbers = interspersed_numbers[1:end-1]\n\
    \        interspersed_numbers = interspersed_numbers[2:end]\n        interspersed_numbers\
    \ = interspersed_numbers[1:end-1]\n        interspersed_numbers = interspersed_numbers[2:end]\n\
    \        interspersed_numbers = interspersed_numbers[1:end-1]\n        interspersed_numbers\
    \ = interspersed_numbers[2:end]\n        interspersed_numbers = interspersed_numbers[1:end-1]\n\
    \        interspersed_numbers = interspersed_numbers[2:end]\n        interspersed_numbers\
    \ = interspersed_numbers[1:end-1]\n        interspersed_numbers = interspersed_numbers[2:end]\n\
    \        interspersed_numbers = interspersed_numbers[1:end-1]\n        interspersed_numbers\
    \ = interspersed_numbers[2:end]\n        interspersed_numbers = interspersed_numbers[1:end\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp2eesdvf.jl:1\nin expression starting at /tmp/tmpp2eesdvf.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpq84tmjt6.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpq84tmjt6.jl:1\n\
    in expression starting at /tmp/tmpq84tmjt6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        numbers\n\
    \    else\n        numbers[2:end-1] .+ delimeter .+ numbers[1:end-1]\n    end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,arrays |>\nA simple solution\
    \ is to use an iterator to iterate over the array and append the delimeter to\
    \ the current element and return the resulting array:\n<code>\njulia> function\
    \ intersperse(x::Vector{Int64}, delimeter::Int64)\n           for i in eachindex(x)\n\
    \               x[i] = x[i] + delimeter\n           end\n           return x\n\
    \       end\nintersperse (generic function with 1 method)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1j1cllo4.jl:14\nin expression starting at\
    \ /tmp/tmp1j1cllo4.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers .+\
    \ [delimeter]\n    \n    numbers = numbers .+ numbers[2:end]\n    \n    return\
    \ numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 4)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a vector of numbers and\
    \ returns the sum of the numbers in the vector. \nThe function should ignore non-numeric\
    \ elements in the vector.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr9ntxb_4.jl:19\nin expression starting at\
    \ /tmp/tmpr9ntxb_4.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptxd82y3t.jl:1\nin expression starting at /tmp/tmptxd82y3t.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    \n    numbers_copy = copy(numbers)\n    \n    numbers_copy[1\
    \ : length(numbers)] = numbers_copy[1 : length(numbers)][1 : delimeter]\n    \n\
    \    return numbers_copy\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,\
    \ 2, 3], 4)\n</cell>\n<text>\nExercise 3.2\nWrite a function that returns the\
    \ first element of a vector, if it is not empty. Otherwise, return 0.\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcd8yho6o.jl:17\nin expression starting at\
    \ /tmp/tmpcd8yho6o.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers\n    else\n        numbers[1 : length(numbers) - (delimeter - length(numbers))]\
    \ + delimeter * ones(length(numbers) - delimeter, length(numbers))\n    end\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nA simple solution is to\
    \ use an anonymous function and apply it to the vector:\n<code>\njulia> intersperse([1,2,3],\
    \ 4)\n1-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nHere is a solution using broadcasting -\n<code>\njulia> intersperse([1,2,3],\
    \ 4)\n1-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n</code>\n<|/ a tags=julia |>\n\
    <| a tags=julia |>\nA solution using broadcasting -\n<code>\nintersperse(x::Vector{Int64},\
    \ delimeter::Int64) = x[end:-1:1] .+ delimeter * ones(length(x) - delimeter)\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\nI came up with this solution:\n\
    <code>\nintersperse(x::Vector{Int64}, delimeter::Int64) = x[end:-1:1] .+ delimeter\
    \ * ones(length(x) - delimeter)\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    <code>\nintersperse(x::Vector{Int64}, delimeter::Int64) = x[end:-1:1] .+ delimeter\
    \ * ones(length(x) - delimeter)\n</code>\n<|/ a tags=julia |>\n<| a tags=julia\
    \ |>\n<code>\nintersperse(x::Vector{Int64}, delimeter::Int64) = x[end:-1:1] .+\
    \ delimeter * ones(length(x) - delimeter)\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\nintersperse(x::Vector{Int64}, delimeter::Int64) = x[end:-1:1] .+\
    \ delimeter * ones(length(x) - delimeter)\n</code>\n<|/ a tags=julia |>\n<| c\
    \ |>\nPlease add some explanation to your answer such that others can learn from\
    \ it\n<|/ c |>\n<| a tags=julia |>\n<code>\nintersperse(x::Vector{Int64}, delimeter::Int64)\
    \ = x[end:-1:1] .\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq3y9xf0r.jl:14\nin expression starting at\
    \ /tmp/tmpq3y9xf0r.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) < 2\n      \
    \  return numbers\n    end\n    \n    numbers_copy = copy(numbers)\n    \n   \
    \ numbers_copy[end] = numbers_copy[end] + delimeter\n    \n    return numbers_copy\n\
    end\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector of integers\
    \ and returns the sum of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector.\
    \ \nWrite a function that takes a vector of integers and returns the maximum of\
    \ the integers in the vector. \nWrite a function that takes a vector of integers\
    \ and returns the minimum of the integers in the vector. \nWrite a function that\
    \ takes a vector of integers and returns the product of the integers in the vector\
    \ divided by the sum of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integers in the vector. \nWrite a function that takes\
    \ a vector of integers and returns the product of the integers in the vector divided\
    \ by the product of the integer\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzkuv08eo.jl:19\nin expression starting at\
    \ /tmp/tmpzkuv08eo.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  lenNumbers = length(numbers)\n    \n    if lenNumbers == 0\n        return\
    \ numbers\n    \n    if lenNumbers == 1\n        return [numbers[0]]\n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8jfyqq4q.jl:1\nin expression starting at /tmp/tmp8jfyqq4q.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n\
    \    \n    numbers = numbers[:]\n    \n    numbers = numbers[:]\n    \n    numbers\
    \ = numbers[:]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp20bl9npy.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp20bl9npy.jl:1\n\
    in expression starting at /tmp/tmp20bl9npy.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers = numbers[2:end-1]\
    \ .+ [delimeter] .+ numbers[2:end-1]\n    return numbers\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector of numbers and returns the sum\
    \ of the numbers in the vector.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpenzz6b20.jl:12\nin expression starting at\
    \ /tmp/tmpenzz6b20.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) <= 1\n        return\
    \ numbers\n    end\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    number\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_5sac9v5.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_5sac9v5.jl:1\n\
    in expression starting at /tmp/tmp_5sac9v5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[:]\n    numbers[2:end]\
    \ = numbers[2:end] + delimeter\n    return numbers\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ an input vector and returns a new vector where each element is the product of\
    \ the corresponding elements of the input vectors.\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbh8letnb.jl:12\nin expression starting at\
    \ /tmp/tmpbh8letnb.jl:12\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    else\n        interspersed_numbers = numbers[2:end]\n        interspersed_numbers\
    \ = [interspersed_numbers, numbers[1]]\n        interspersed_numbers = interspersed_numbers[2:end]\n\
    \        return interspersed_numbers\n    end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=julia,arrays |>\nHere is a solution using broadcasting and the function\
    \ split:\n<code>\njulia> function intersperse(numbers, delimeter)\n          \
    \ return split(numbers, collect(1:length(numbers)) .== collect(1:length(numbers))\
    \ .+ delimeter)\n       end\nintersperse (generic function with 1 method)\nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgchg2ynq.jl:17\nin expression starting at\
    \ /tmp/tmpgchg2ynq.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  if length(numbers) == 0\n        return numbers\n    end\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnsx3w9da.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnsx3w9da.jl:1\n\
    in expression starting at /tmp/tmpnsx3w9da.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  i = 0\n    \n    while i < length(numbers)\n        \n        numbers[i+1]\
    \ = numbers[i] + delimeter\n        \n        i = i + 1\n        \n    end\n \
    \   \n    return numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,\
    \ 2, 3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that takes an input\
    \ vector and returns the number of elements that are not equal to zero.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppag4sq8p.jl:23\nin expression starting at\
    \ /tmp/tmppag4sq8p.jl:23\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers\n    else\n        numbers[1 : length(numbers)-delimeter+1]\n   \
    \ end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,arrays |>\nI came up with\
    \ this solution:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1x6roo8y.jl:14\nin expression starting at\
    \ /tmp/tmp1x6roo8y.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    if length(numbers) < 2\n      \
    \  return numbers\n    end\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[1:end-1] .+ [delimeter] .+ numbers[2:end]\n    \n    return numbers\n\
    end\n</cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 4)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector of integers and returns the sum\
    \ of the squares of the integers in the vector.\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphowj8q8y.jl:19\nin expression starting at\
    \ /tmp/tmphowj8q8y.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  if length(numbers) < 2\n        return numbers\n    end\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\
    \ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5g7dwpc3.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5g7dwpc3.jl:1\n\
    in expression starting at /tmp/tmp5g7dwpc3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  i = 0\n    \n    while i < length(numbers)\n        \n        if i == 0\n \
    \           numbers[i:i+2] = [numbers[i]]\n        elseif i == length(numbers)\n\
    \            numbers[i:i+2] = [numbers[i], delimeter]\n        else\n        \
    \    numbers[i:i+2] = [numbers[i], delimeter, numbers[i+1]]\n        end\n   \
    \     \n        i = i + 2\n    end\n    \n    return numbers\nend\n</cell>\n<code\
    \ language=julia-1.5>\nintersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes a vector of numbers and returns the same vector but\
    \ with the numbers reversed.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp71qcls3f.jl:28\nin expression starting at\
    \ /tmp/tmp71qcls3f.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    \n    numbers = numbers[:]\n    \n  \
    \  if length(numbers) < 2\n        return numbers\n    end\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7fel88c8.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7fel88c8.jl:1\n\
    in expression starting at /tmp/tmp7fel88c8.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    numbers = numbers[:]\n    end\n    numbers = numbers[start:end]\n    numbers\
    \ = numbers[(end - start):end]\n    numbers = numbers[start:(end - start)]\n \
    \   numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    numbers = numbers[start:(end - start)]\n\
    \    numbers = numbers[start:end]\n    number\nusing Test\n\n@testset begin\n\n\
    candidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2,\
    \ 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkjwelx7e.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkjwelx7e.jl:1\n\
    in expression starting at /tmp/tmpkjwelx7e.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < 2\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = intersperse(numbers,\
    \ delimeter)\n    numbers = numbers[2:end]\n    numbers = numbers + [numbers[1]]\n\
    \    return numbers\nend\n</cell>\n<code language=julia-1.5>\nintersperse([1,\
    \ 2, 3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector\
    \ of integers and returns the sum of the squares of the numbers in the vector.\n\
    using Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqhqtgvzh.jl:17\nin expression starting at\
    \ /tmp/tmpqhqtgvzh.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    numbers = numbers[2:end-1]\n    numbers\
    \ = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n\
    \    numbers = numbers[2:end-1]\n    numbers = numbers[2:end-1]\n    numbers =\
    \ numbers[2:end-1]\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqidwr_9q.jl:7\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqidwr_9q.jl:1\n\
    in expression starting at /tmp/tmpqidwr_9q.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter \n   \
    \     return numbers \n    else \n        numbers = numbers[2:end-1] \n      \
    \  numbers = numbers .+ [delimeter] \n        numbers = numbers .+ numbers[2:end-1]\
    \ \n        return numbers \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that returns\
    \ the number of elements in a vector that satisfy a condition. For example, for\
    \ the vector [1,2,3,4,5,6,7,8,9] the function should return 3 because there are\
    \ 3 elements in the vector that satisfy the condition: x>3\nusing Test\n\n@testset\
    \ begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]), 7) ==\
    \ Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb7ujgokd.jl:17\nin expression starting at\
    \ /tmp/tmpb7ujgokd.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    numbers = numbers[1:end-1]\n    \n    numbers = numbers[1:end-1]\n\
    \    \n    \nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuwkls5l5.jl:1\nin expression starting at /tmp/tmpuwkls5l5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_m93q0ea.jl:1\nin expression starting at /tmp/tmp_m93q0ea.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) < delimeter\n    \
    \    return numbers\n    else\n        numbers[end+1:end+delimeter] = numbers[end+1:end+delimeter][1:end-1]\n\
    \        return numbers[end+1:end+delimeter]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1, 2, 3], 4)\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of integers and returns the sum of the squares of the integers\
    \ in the vector.\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\t\
    @test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkt5ws3b1.jl:15\nin expression starting at\
    \ /tmp/tmpkt5ws3b1.jl:15\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    \n    numbers = intersperse(numbers,\
    \ delimeter)\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers\
    \ = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n\
    \    \n    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\n    \n\
    \    numbers = numbers[2:end]\n    \n    numbers = numbers[2:end]\nusing Test\n\
    \n@testset begin\n\ncandidate = intersperse;\n\t@test(candidate(Vector{Int64}([]),\
    \ 7) == Vector{Int64}([]))\n\t@test(candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8,\
    \ 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_m93q0ea.jl:1\nin expression starting at /tmp/tmp_m93q0ea.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1,\
    \ 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\nfunction intersperse(numbers::Vector{Int64},\
    \ delimeter::Int64)::Vector{Int64} \n    if length(numbers) == 0\n        return\
    \ numbers\n    \n    numbers = numbers[2:end]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers =\
    \ numbers[1:end-1]\n    numbers = numbers[1:end-1]\n    numbers = numbers[1:end-1]\n\
    \    numbers = numbers[1:\nusing Test\n\n@testset begin\n\ncandidate = intersperse;\n\
    \t@test(candidate(Vector{Int64}([]), 7) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2])\n\t@test(candidate([2, 2, 2], 2) == [2,\
    \ 2, 2, 2, 2])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4r6tagpv.jl:74\nin expression starting at\
    \ /tmp/tmp4r6tagpv.jl:74\n"
  stdout: ''
