name: HumanEval_66_digitSum
language: jl
prompt: "\"\"\"Task\n    Write a function that takes a string as input and returns\
  \ the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n   \
  \ >>> digitSum(\"\")\n    0\n    >>> digitSum(\"abAB\")\n    131\n    >>> digitSum(\"\
  abcCd\")\n    67\n    >>> digitSum(\"helloE\")\n    69\n    >>> digitSum(\"woArBld\"\
  )\n    131\n    >>> digitSum(\"aAaaaXa\")\n    153\n    \"\"\"\nfunction digitSum(s::String)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = digitSum;\n\t@test(candidate(\"\
  \") == 0)\n\t@test(candidate(\"abAB\") == 131)\n\t@test(candidate(\"abcCd\") ==\
  \ 67)\n\t@test(candidate(\"helloE\") == 69)\n\t@test(candidate(\"woArBld\") == 131)\n\
  \t@test(candidate(\"aAaaaXa\") == 153)\n\t@test(candidate(\" How are yOu?\") ==\
  \ 151)\n\t@test(candidate(\"You arE Very Smart\") == 327)\nend\n"
completions: ["    if s == \"\" then 0 else sum (map (\\c -> if c >= 'A' && c <= 'Z'\
    \ then c - 'A' else 0, s))\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a string as input and returns the sum of the digits in that string.",
  "    sum::Int64 = 0\n    for c in s:\n        if c.isUpper():\n            sum +=\
    \ c.codePointAt(0)\n    return sum\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,haskell,functional-programming\
    \ |>\n<code>\nimport Data.Char", "    sum::Int64 = 0\n    for c in s:\n      \
    \  if c.isUpper():\n            sum += c.codePointAt(0)\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\ndigitSum(\"\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"abAB\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"abcCd\")\n\
    </cell>\n<code language=julia-1.5>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string as input\
    \ and returns the sum of the digits in that string.", "    if s == \"\"\n    \
    \    0\n    else\n        sum(map(ord, filter(c => c >= 'A' && c <= 'Z', s)))\n\
    end\n</cell>\n<code language=julia-1.5>\ndigitSum(\"\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"abAB\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"abcCd\")\n\
    </cell>\n<code language=julia-1.5>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string as input\
    \ and returns the number of characters in the string that are uppercase letters.",
  "    sum::Int64 = 0\n    for c in s do\n        if c >= '0' && c <= '9' then\n \
    \           sum += c - '0'\n        else\n            sum += c - 'A' + 10\n  \
    \      end\n    end\n    return sum\nend", "    sum::Int64 = 0\n    for c in s:\n\
    \        if c >= 'A' and c <= 'Z':\n            sum += (c - 'A' + 10)\n      \
    \  elif c >= 'a' and c <= 'z':\n            sum += (c - 'a' + 10)\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\ndigitSum(\"\")\n</cell>\n<code\
    \ language=julia-1.5>\ndigitSum(\"abAB\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"abcCd\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"helloE\")\n\
    </cell>\n<code language=julia-1.5>\ndigitSum(\"woArBld\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"aAaaaXa\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a string as input and returns the number of characters in the string that are\
    \ upper case letters.", "    sum::Int64 = 0\n    for c in s do\n        if c >=\
    \ '0' && c <= '9' then\n            sum = sum + c - '0'\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes\
    \ a string as input and returns the sum of the digits of that string.", "    sum::Int64\
    \ = 0\n    for c in s:\n        if c.isUpper():\n            sum += c.codePointAt(0)\n\
    \    return sum\n</code>\n<|/ a tags=string,haskell,ascii |>\n<| a tags=string,haskell,ascii\
    \ |>\n<code>\nimport Data.Char", "    sum::Int64 = 0\n    for c in s:\n      \
    \  if c.isUpper():\n            sum += c.codePointAt(0)\n    return sum\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=string,haskell,functional-programming |>\n<code>\n\
    import Data.Char", "    sum::Int64 = 0\n    for c in s do \n        if c >= 'a'\
    \ && c <= 'z' then \n            sum += c - 'a'\n        else \n            sum\
    \ += c - 'A'\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"abAB\")\n</cell>\n\
    <code language=julia-1.5>\ndigitSum(\"abcCd\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"helloE\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"woArBld\"\
    )\n</cell>\n<code language=julia-1.5>\ndigitSum(\"aAaaaXa\")\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a string as input and returns the sum\
    \ of the numbers in the string.", "    sum::Int64 = 0\n    for c in s\n      \
    \  if ('A' <= c && c <= 'Z')\n            sum += c - 'A' + 1\n        else if\
    \ ('a' <= c && c <= 'z')\n            sum += c - 'a' + 1\n        else if ('0'\
    \ <= c && c <= '9')\n            sum += c - '0'\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\ndigitSum(\"\")\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a string as input and returns the number of uppercase\
    \ letters.", "    sum::Int64 = 0\n    for c in s:\n        if c.isUpper():\n \
    \           sum += c.codePointAt(0)\n    return sum\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThe question was about using only `if` statements, not `for` loops.\n\
    <|/ c |>\n<| c |>\nThe question was about using only `if` statements, not `for`\
    \ loops.\n<|/ c |>\n<| c |>\nThe question was about using only `if` statements,\
    \ not `for` loops.\n<|/ c |>\n<| c |>\nThe question was about using only `if`\
    \ statements, not `for` loops.\n<|/ c |>\n<| c |>\nThe question was about using\
    \ only `if` statements, not `for` loops.\n<|/ c |>\n<| a tags=haskell,functional-programming\
    \ |>\n<code>\ndigitSum :: String -> Int\ndigitSum s = sum (map ord $ filter (\\\
    c -> ord c >= 'A' && ord c <= 'Z') s)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe\
    \ question was about using only `if` statements, not `for` loops.\n<|/ c |>\n\
    <| c |>\nThe question was about using only `if` statements, not `for` loops.\n\
    <|/ c |>\n<| c |>\nThe question was about using only `if` statements, not `for`\
    \ loops.\n<|/ c |>\n<| c |>\nThe question was about using only `if` statements,\
    \ not `for` loops.\n<|/ c |>\n<| c |>\nThe question was about using only `if`\
    \ statements, not `for` loops.\n<|/ c |>\n<| a dscore=2 |>\n<code>\ndigitSum ::\
    \ String -> Int\ndigitSum s = sum (map ord $ filter (\\c -> ord c >= 'A' && ord\
    \ c <= 'Z') s)\n</code>\n<|/ a tags=haskell,functional-programming |>\n<| c |>\n\
    The question was about using only `if` statements, not `for` loops.\n<|/ c |>\n\
    <| c |>\nThe question was about using only `if` statements, not `for` loops.\n\
    <|/ c |>\n<| c |>\nThe question was ", "    sum::Int64 = 0\n    for c in s\n \
    \       if c.isUpper\n            sum += c.codePointAt(0)\n    return sum\n</code>\n\
    <|/ a tags=string,haskell,ascii |>\n<| c |>\n`digitSum = sum . filter (\\c ->\
    \ c.isUpper)`\n<|/ c |>\n<| c |>\n`digitSum = sum . filter (\\c -> c.isUpper)`\
    \ - this was the most elegant solution. Thank you!\n<|/ c |>\n<| a |>\nHere's\
    \ a solution using Data.Char:\n<code>\nimport Data.Char", "    sum::Int64 = 0\n\
    \    for c in s:\n        if c.isUpper():\n            sum += c.codePointAt(0)\n\
    \    return sum\n</code>\n<|/ a tags=string,haskell,functional-programming |>\n\
    <| c |>\nI like your use of codePointAt. Very nice.\n<|/ c |>\n<| a tags=string,haskell,functional-programming\
    \ |>\n<code>\nimport Data.Char", "    sum = 0\n    for c in s:\n        if c.isUpper():\n\
    \            sum += c.codePointAt(0)\n    return sum\n</code>\n<|/ a |>\n<| c\
    \ |>\nThe `isUpper` method doesn't exist in Julia. `c.isUpper()` returns `Bool`\
    \ not `Int64`.\n<|/ c |>\n<| c |>\nThanks, I fixed the answer.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nThe answer by is correct, but I wanted to add that you can also\
    \ use regular expressions to solve this problem:\n<code>\ndigitSum(s::String)::Int64\
    \ = sum(map(x -> x.isUpper() ? x.codePointAt(0) : 0, s))\n</code>\n<|/ a tags=julia,string\
    \ |>\n<| a dscore=2 |>\nA more Julian way is to use map\n<code>\ndigitSum(s::String)::Int64\
    \ = sum(map(x -> x.isUpper() ? x.codePointAt(0) : 0, s))\n</code>\n<|/ a tags=julia,string\
    \ |>\n<| a |>\nA more Julian way is to use filter:\n<code>\ndigitSum(s::String)::Int64\
    \ = sum(filter(x -> x.isUpper(), s))\n</code>\n<|/ a dscore=2 tags=julia,string\
    \ |>\n<| a dscore=1 |>\nAnother Julian way is to use reduce:\n<code>\ndigitSum(s::String)::Int64\
    \ = reduce(+, map(x -> x.isUpper() ? x.codePointAt(0) : 0, s))\n</code>\n<|/ a\
    \ tags=julia,string |>\n<| a tags=julia,string |>\nAnother Julian way is to use\
    \ reduce:\n<code>\ndigitSum(s::String)::Int64 = reduce(+, map(x -> x.isUpper()\
    \ ? x.codePointAt(0) : 0, s))\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,string\
    \ |>\nAnother Julian way is to use reduce:\n<code>\ndigitSum(s::String)::Int64\
    \ = reduce(+, map(x -> x.isUpper() ? x.codePointAt(0) : 0, s))\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=julia,string |>\nAnother Julian way is to use reduce:\n\
    <code>\ndigitSum(s::String)::Int64 = reduce(+, map(x -> x.isUpper() ? x.codePointAt(0)\
    \ : 0, s))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nAnother Julian way is\
    \ to use reduce", "    sum::Int64 = 0\n    for c in s do \n        if c >= 'A'\
    \ and c <= 'Z' then \n            sum += c - 'A' + 1 \n        else \n       \
    \     sum += c \n    end\n    return sum\nend\n</cell>\n<code language=julia-1.3>\n\
    digitSum(\"\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ as input and returns the sum of the digits in that string.", "    if s == \"\
    \"\n        0\n    else\n        sum = 0\n        for c in s\n            if c\
    \ >= '0' && c <= '9'\n                sum += c - '0'\n            else\n     \
    \           sum += 10\n        end\n        sum\nend\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"abAB\")\n</cell>\n\
    <code language=julia-1.5>\ndigitSum(\"abcCd\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"helloE\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"woArBld\"\
    )\n</cell>\n<code language=julia-1.5>\ndigitSum(\"aAaaaXa\")\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a string as input and returns the sum\
    \ of the number of upper characters only'\nASCII codes.", "    sum::Int64 = 0\n\
    \    for c in s:\n        if c.isUpper():\n            sum += c.codePointAt(0)\n\
    \    return sum\n</code>\n<|/ a tags=string,haskell,ascii |>\n<| c |>\nI like\
    \ this solution, but I wonder if there is a way to do it without using any libraries.\n\
    <|/ c |>\n<| c |>\nI added a solution without libraries.\n<|/ c |>\n<| c |>\n\
    I added a solution without libraries.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nimport\
    \ Data.Char (toUpper)", "    digitSum = 0\n    for c in s do\n        if c >=\
    \ '0' and c <= '9' then\n            digitSum += c - '0'\n        else\n     \
    \       digitSum = 0\n        end\n    end\n    return digitSum\nend\n</cell>\n\
    <code language=julia-1.5>\ndigitSum(\"\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"abAB\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"abcCd\")\n\
    </cell>\n<code language=julia-1.5>\ndigitSum(\"helloE\")\n</cell>\n<code language=julia-1.5>\n\
    digitSum(\"woArBld\")\n</cell>\n<code language=julia-1.5>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string as input\
    \ and returns the number of characters in the string.", "    digitSum = 0\n  \
    \  for c in s\n        if c.isUpper\n            digitSum += c.code\n    return\
    \ digitSum\n</code>\n<|/ a tags=string,haskell,functional-programming |>\n<| a\
    \ tags=string,haskell,functional-programming |>\n<code>\nimport Data.Char"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
