language: jl
name: HumanEval_70_strange_sort_list
results:
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum = min(minimum, maximum) \n     \
    \   maximum = max(minimum, maximum) \n        lst = sort(lst) \n        lst =\
    \ lst[minimum:maximum] \n        return lst \nend \n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the sum of the squares of the integers\
    \ in the vector.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv13upbdm.jl:26\nin expression starting at\
    \ /tmp/tmpv13upbdm.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst)\n     \
    \   maximum = maximum(lst)\n        middle = floor(length(lst)/2)\n        lst[middle]\
    \ = minimum\n        lst[middle+1:end] = maximum\n        return lst\nend\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector of integers and returns the vector\
    \ in reverse order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzjlfie52.jl:25\nin expression starting at\
    \ /tmp/tmpzjlfie52.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3i_eoid6.jl:19\nin expression starting at\
    \ /tmp/tmp3i_eoid6.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq2h56tkb.jl:19\nin expression starting at\
    \ /tmp/tmpq2h56tkb.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpc05uly1n.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpc05uly1n.jl:1\n\
    in expression starting at /tmp/tmpc05uly1n.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis should be the accepted answer. Sorting is expensive and should\
    \ be avoided if possible.\n<|/ c |>\n<| a dscore=4 |>\nI wrote a small package\
    \ for this:\n<code>\nusing Random\nusing DataFrames\nusing DataFramesMeta\nusing\
    \ Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbyov0wkv.jl:19\nin expression starting at\
    \ /tmp/tmpbyov0wkv.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([1,\
    \ 2, 3, 4])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector\
    \ of integers and returns a vector of integers sorted from smallest to largest.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcztrar0f.jl:19\nin expression starting at\
    \ /tmp/tmpcztrar0f.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ if length(lst) == 0 \n        return [] \n    \n    minimum = minimum(lst) \n\
    \    maximum = maximum(lst) \n    \n    minimum_index = findfirst(isequal(minimum),\
    \ lst) \n    maximum_index = findfirst(isequal(maximum), lst) \n    \n    minimum_value\
    \ = lst[minimum_index] \n    maximum_value = lst[maximum_index] \n    \n    lst[minimum_index]\
    \ = maximum_value\n    lst[maximum_index] = minimum_value\n    \n    return lst\n\
    end\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([1, 2, 3, 4])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([])\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a vector of integers and returns the same vector, but sorted in descending order.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp697b5u3i.jl:33\nin expression starting at\
    \ /tmp/tmp697b5u3i.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([1, 2, 3, 4])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n<text>\nExercise: Write\
    \ a function that takes a vector of integers and returns the same vector in reverse\
    \ order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq99kit4t.jl:27\nin expression starting at\
    \ /tmp/tmpq99kit4t.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the sum of the integers in the vector.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmo1r8mky.jl:19\nin expression starting at\
    \ /tmp/tmpmo1r8mky.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=sorting,julia |>\nI wrote a package called Sorting.jl that does\
    \ exactly that:\n<code>\njulia> using Sorting\nusing Test\n\n@testset begin\n\n\
    candidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    \t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3gi0licy.jl:19\nin expression starting at\
    \ /tmp/tmp3gi0licy.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia,list\
    \ |>\n<| c |>\nThis doesn't work for me. `julia> strange_sort_list([5, 5, 5, 5])\n\
    5-element Array{Int64,1}:\n 5\n 5\n 5\n 5\n 5\n `\n<|/ c |>\n<| c |>\nI tested\
    \ it on Julia 1.5.1 and it works. Maybe you have a different version of Julia?\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 and it works. Maybe you have a different\
    \ version of Julia?\n<|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 and it works.\
    \ Maybe you have a different version of Julia?\n<|/ c |>\n<| c |>\nI tested it\
    \ on Julia 1.5.1 and it works. Maybe you have a different version of Julia?\n\
    <|/ c |>\n<| a |>\nThe function below will sort a vector in ascending order and\
    \ return the sorted vector:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptiu3fuv6.jl:19\nin expression starting at\
    \ /tmp/tmptiu3fuv6.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the same vector in reverse order.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpleyq7l8a.jl:19\nin expression starting at\
    \ /tmp/tmpleyq7l8a.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise: Write a function that\
    \ takes a vector of integers and returns a vector of strings in alphabetical order.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb8brysau.jl:19\nin expression starting at\
    \ /tmp/tmpb8brysau.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work for me. `strange_sort_list([5, 5, 5, 5])` returns `[5,\
    \ 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works fine. Are you sure you copied it correctly? I tested it on Julia 0.6.2\n\
    <|/ c |>\n<| c |>\nI copied it exactly as you wrote it. I also tested it on 0.6.2\
    \ and it works. What version of Julia are you using?\n<|/ c |>\n<| c |>\nI'm using\
    \ 0.6.2\n<|/ c |>\n<| c |>\nI tested it on 0.6.2 and it works. What version of\
    \ Julia are you using?\n<|/ c |>\n<| a tags=julia,sorting |>\nThe function you\
    \ are looking for is sort!\n<code>\njulia> sort!([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work for\
    \ me. `sort!([5, 5, 5, 5])` returns `[5, 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for me. `sort!([5, 5, 5, 5])` returns `[5,\
    \ 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nThis doesn't work for\
    \ me. `sort!([5, 5, 5, 5])` returns `[5, 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for me. `sort!([5, 5, 5, 5])` returns `[5,\
    \ 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nThis doesn't work for\
    \ me. `sort!([5, 5, 5, 5])` returns `[5, 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n\
    <|/ c |>\n<| a tags=julia,sorting |>\nThe function you are looking for is sort!\n\
    <code>\njulia> sort!([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\
    \ 5\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work for me. `sort!([5,\
    \ 5, 5, 5])` \nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2jsq6d_o.jl:19\nin expression starting at\
    \ /tmp/tmp2jsq6d_o.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns another vector where each element\
    \ is the sum of the previous two elements in the original vector. For example,\
    \ if the input vector is [1, 2, 3, 4], the output vector should be [2, 3, 4, 7].\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkvuzavcb.jl:19\nin expression starting at\
    \ /tmp/tmpkvuzavcb.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    while i < length(lst)\n        if lst[i]\
    \ > lst[i+1]\n            lst[i], lst[i+1] = lst[i+1], lst[i]\n        end\n \
    \       i += 1\n    end\n    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns the sum of the squares of the integers\
    \ in the vector.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2vnusk8k.jl:28\nin expression starting at\
    \ /tmp/tmp2vnusk8k.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't seem to work. `strange_sort_list([5,5,5,5])` returns\
    \ `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting.\
    \ What do you mean by \"doesn't work\"?\n<|/ c |>\n<| c |>\nI mean it doesn't\
    \ work as intended. `strange_sort_list([5,5,5,5])` returns `[5, 5, 5, 5]`.\n<|/\
    \ c |>\n<| c |>\nOh, I see. You want to sort by decreasing order. I'll edit my\
    \ answer.\n<|/ c |>\n<| c |>\nYes, I want the list to be sorted in descending\
    \ order. Thanks for your help!\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpveotj2fk.jl:19\nin expression starting at\
    \ /tmp/tmpveotj2fk.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8ibo_vc1.jl:19\nin expression starting at\
    \ /tmp/tmp8ibo_vc1.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ if length(lst) == 0 \n        return [] \n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_ugaevqr.jl:117\nin expression starting at\
    \ /tmp/tmp_ugaevqr.jl:117\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns a vector of integers sorted from\
    \ smallest to largest.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfod1m20z.jl:19\nin expression starting at\
    \ /tmp/tmpfod1m20z.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a dscore=2 |>\nThe answer by is great, but I wanted to add that you can\
    \ also use sort! to sort in place:\n<code>\njulia> sort!([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia |>\n\
    <| a tags=sorting,julia |>\n<code>\njulia> sort([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\njulia> sort([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ dscore=2 |>\n<| a tags=sorting,julia |>\n<code>\njulia> sort!([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a tags=sorting,julia |>\n<code>\njulia> sort!([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\njulia> sort!([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 tags=sorting,julia\
    \ |>\n<| a dscore=1 |>\n<code>\njulia> sort!([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia |>\n<| a tags=sorting,julia\
    \ |>\n<code>\njulia> sort!([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n\
    \ 4\n 5\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia |>\n<code>\njulia>\
    \ sort!([5,4,\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxn1z1lqm.jl:19\nin expression starting at\
    \ /tmp/tmpxn1z1lqm.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if you have negative numbers. `strange_sort_list([-4,\
    \ -5, -6, -7])` returns `[-7, -6, -5, -4]`.\n<|/ c |>\n<| a tags=sorting,julia\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp772x76b4.jl:19\nin expression starting at\
    \ /tmp/tmp772x76b4.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = copy(lst)\n    sorted_list[1] = maximum(sorted_list[2:end])\n    sorted_list[2]\
    \ = minimum(sorted_list[1:end-1])\n    sorted_list[3] = maximum(sorted_list[1:end-1])\n\
    \    sorted_list[4] = minimum(sorted_list[2:end])\n    sorted_list\nend\n</code>\n\
    <|/ a tags=sorting,julia |>\n<| c |>\nI like your solution, but I wonder why you\
    \ used `copy` instead of `sort`?\n<|/ c |>\n<| c |>\n`sort` will sort in-place,\
    \ which is not the case here. I think `copy` is more explicit and more idiomatic.\n\
    <|/ c |>\n<| c |>\n`sort` will sort in-place and `copy` will copy the array before\
    \ sorting. `sort` will also copy the array before returning the sorted array.\
    \ `copy` will copy the array before returning the sorted array. `sort` will also\
    \ copy the array before returning the sorted array. `copy` will copy the array\
    \ before returning the sorted array. `sort` will also copy the array before returning\
    \ the sorted array. `copy` will copy the array before returning the sorted array.\
    \ `sort` will also copy the array before returning the sorted array. `copy` will\
    \ copy the array before returning the sorted array. `sort` will also copy the\
    \ array before returning the sorted array. `copy` will copy the array before returning\
    \ the sorted array. `sort` will also copy the array before returning the sorted\
    \ array. `copy` will copy the array before returning the sorted array. `sort`\
    \ will also copy the array before returning the sorted array. `copy` will copy\
    \ the array before returning the sorted array. `sort` will also copy the array\
    \ before returning the sorted array. `copy` will copy the array before returning\
    \ the sorted array. `sort` will also copy the array before returning the sorted\
    \ array. `copy` will copy the array before returning the sorted array. `sort`\
    \ will also copy the array before returning the sorted array. `copy` will copy\
    \ the array before returning the sorted array. `sort` will also copy the array\
    \ before returning the sorted array. `copy` will copy the array before returning\
    \ the sorted array. `sort` will also copy the array before returning the sorted\
    \ array. `copy` will copy the array before returning the sorted array. `sort`\
    \ will also copy the array before returning the sorted array. `copy` will copy\
    \ the array before returning the sorted \nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplww2dh8k.jl:22\nin expression starting at\
    \ /tmp/tmplww2dh8k.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmd6irgjb.jl:1\nin expression starting at /tmp/tmpmd6irgjb.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    minimum_index = findfirst(i->i==minimum, lst)\n    maximum_index =\
    \ findfirst(i->i==maximum, lst)\n    \n    lst[minimum_index], lst[maximum_index]\
    \ = lst[maximum_index], lst[minimum_index]\n    \n    return lst\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ the sum of the squares of the integers in the vector.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzlywgfsp.jl:28\nin expression starting at\
    \ /tmp/tmpzlywgfsp.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    end\n    \n    minimum = minimum(lst)\n    maximum\
    \ = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4xi4cri1.jl:117\nin expression starting at\
    \ /tmp/tmp4xi4cri1.jl:117\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst.(minimum..maximum)\n    \n   \
    \ return lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5,\
    \ 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector of\
    \ integers and returns a vector of integers sorted from smallest to largest.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7bwjgi36.jl:27\nin expression starting at\
    \ /tmp/tmp7bwjgi36.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns a vector of integers where the integers\
    \ are in descending order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4_za7u9x.jl:19\nin expression starting at\
    \ /tmp/tmp4_za7u9x.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis does not seem to work as intended for me. `strange_sort_list([5,\
    \ 5, 5, 5])` returns `[5, 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| c\
    \ |>\nThis does not seem to work as intended for me. `strange_sort_list([5, 5,\
    \ 5, 5])` returns `[5, 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\n\
    This does not seem to work as intended for me. `strange_sort_list([5, 5, 5, 5])`\
    \ returns `[5, 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nThis does\
    \ not seem to work as intended for me. `strange_sort_list([5, 5, 5, 5])` returns\
    \ `[5, 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nThis does not\
    \ seem to work as intended for me. `strange_sort_list([5, 5, 5, 5])` returns `[5,\
    \ 5, 5, 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| a tags=julia,sorting |>\n\
    The answer by is correct, but I wanted to add an explanation as to why it works.\n\
    The reason why it works is because sort and reverse are both in-place functions.\
    \ So when you call sort(lst), you are actually calling sort(lst, lst). So the\
    \ function will sort the list in-place. \nThe reason why reverse(sort(lst)) works\
    \ is because reverse is a in-place function. So when you call reverse(lst, lst),\
    \ you are actually calling reverse(lst, lst). So the function will reverse the\
    \ list in-place.\n<|/ a dscore=5 |>\n<| c |>\nThis does not seem to work as intended\
    \ for me. `strange_sort_list([5, 5, 5, 5])` returns `[5, 5, 5, 5]` instead of\
    \ `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nThis does not seem to work as intended for\
    \ me. `strange_sort_list([5, 5, 5, 5])` returns `[5, 5, 5, 5]` instead of `[5,\
    \ 5, 5, 5]`.\n<|/ c |>\n<| c |>\nThis does not seem to work as intended for me.\
    \ `strange_sort_list([5, 5, 5, 5])` returns `[5, 5, 5, 5]` instead of `[5, 5,\
    \ 5, 5]`.\n<|/\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfm6xokqk.jl:19\nin expression starting at\
    \ /tmp/tmpfm6xokqk.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ if length(lst) == 0 \n        return [] \n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    lst = lst.[minimum:maximum]\n\
    \    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector\
    \ of integers and returns the same vector, except with each integer replaced by\
    \ its square. For example, [1, 2, 3] -> [1, 4, 9].\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4o60phtg.jl:28\nin expression starting at\
    \ /tmp/tmp4o60phtg.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum_index = findfirst(minimum, lst)\
    \ \n        maximum_index = findfirst(maximum, lst) \n        lst[minimum_index],\
    \ lst[maximum_index] = lst[maximum_index], lst[minimum_index] \n        return\
    \ strange_sort_list(lst) \nend\n</code>\n<|/ a tags=sorting,julia,algorithm |>\n\
    <| c |>\nThis doesn't work if there are duplicates in the input vector. For example,\
    \ `strange_sort_list([5, 5, 5, 5])` returns `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\n\
    I added a version that works with duplicates.\n<|/ c |>\n<| c |>\nI added a version\
    \ that works with duplicates.\n<|/ c |>\n<| a dscore=4 |>\nHere's a Julia version\
    \ that works with duplicates:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpizt_wd0v.jl:25\nin expression starting at\
    \ /tmp/tmpizt_wd0v.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ a vector of strings in alphabetical order.\nusing Test\n\n@testset begin\n\n\
    candidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    \t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk21tm0tq.jl:19\nin expression starting at\
    \ /tmp/tmpk21tm0tq.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a dscore=1 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a dscore=1 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a dscore=1 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpas6iz9ek.jl:19\nin expression starting at\
    \ /tmp/tmpas6iz9ek.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    while i < length(lst)\n        if lst[i]\
    \ > lst[i+1]\n            lst[i], lst[i+1] = lst[i+1], lst[i]\n        end\n \
    \       i += 1\n    end\n    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns a vector of integers sorted from\
    \ smallest to largest.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpozmsn9kh.jl:28\nin expression starting at\
    \ /tmp/tmpozmsn9kh.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = copy(lst)\n    sorted_list[1] = max(sorted_list[1:end-1]) \n    sorted_list[2]\
    \ = min(sorted_list[2:end])\n    sorted_list[3] = max(sorted_list[3:end-1])\n\
    \    sorted_list[4] = min(sorted_list[4:end])\n    sorted_list[5] = max(sorted_list[5:end-1])\n\
    \    sorted_list[6] = min(sorted_list[6:end])\n    sorted_list[7] = max(sorted_list[7:end-1])\n\
    \    sorted_list[8] = min(sorted_list[8:end])\n    sorted_list[9] = max(sorted_list[9:end-1])\n\
    \    sorted_list[10] = min(sorted_list[10:end])\n    sorted_list[11] = max(sorted_list[11:end-1])\n\
    \    sorted_list[12] = min(sorted_list[12:end])\n    sorted_list[13] = max(sorted_list[13:end-1])\n\
    \    sorted_list[14] = min(sorted_list[14:end])\n    sorted_list[15] = max(sorted_list[15:end-1])\n\
    \    sorted_list[16] = min(sorted_list[16:end])\n    sorted_list[17] = max(sorted_list[17:end-1])\n\
    \    sorted_list[18] = min(sorted_list[18:end])\n    sorted_list[19] = max(sorted_list[19:end-1])\n\
    \    sorted_list[20] = min(sorted_list[20:end])\n    sorted_list[21] = max(sorted_list[21:end-1])\n\
    \    sorted_list[22] = min(sorted_list[22:end])\n    sorted_list[23] = max(sorted_list[23:end-1])\n\
    \    sorted_list[24] = min(sorted_list[24:end])\n    sorted_list[25] = max(sorted_list[25:end-1])\n\
    \    sorted_list[26] = min(sorted_list[26:end])\n    sorted_list[27] = max(sorted_list[27:end-1])\n\
    \    sorted_list[28] = min(sorted_list[28:end])\n    sorted_list[29] = max(sorted_list[29:end-1])\n\
    \    sorted_list[30] = min(sorted_list[30:end])\n    sorted_list[31] = max(sorted_list[31:end-1])\n\
    \    sorted_list[32] = min(sorted_list[32:end])\n    sorted_list[33] = max(sorted_list[33:end-1])\n\
    \    sorted_list[34] = min(sorted_list[34:end])\n    sorted_list[35] = max(sorted_list[35:end-1])\n\
    \    sorted_list[36] = min(sorted_list[36:end])\n    sorted_list[37] = max(sorted_list[37:end-1])\n\
    \    sorted_list[38] = min(sorted_list[38:end])\n    sorted_list[39] = max(sorted_list[39:end-1])\n\
    \    sorted_list[40] = min(sorted_list[40:end])\n    sorted_list[41] = max(sorted_list[4\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphu8whqph.jl:1\nin expression starting at /tmp/tmphu8whqph.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ sorted_list = copy(lst)\n    \n    minimum = minimum(sorted_list)\n    maximum\
    \ = maximum(sorted_list)\n    \n    sorted_list[minimum] = maximum\n    sorted_list[maximum]\
    \ = minimum\n    \n    return sorted_list\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the same vector, but with each element\
    \ multiplied by 2.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvqn2i3qi.jl:26\nin expression starting at\
    \ /tmp/tmpvqn2i3qi.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpunyugiwy.jl:19\nin expression starting at\
    \ /tmp/tmpunyugiwy.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ of integers and returns a vector of integers in strange order.\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpribr0ysc.jl:27\nin expression starting at\
    \ /tmp/tmpribr0ysc.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ sorted_list = copy(lst)\n    \n    minimum = min(lst)\n    maximum = max(lst)\n\
    \    \n    minimum_index = 0\n    maximum_index = length(sorted_list)\n    \n\
    \    while minimum_index < maximum_index\n        if sorted_list[minimum_index]\
    \ < minimum\n            minimum_index += 1\n        elseif sorted_list[maximum_index]\
    \ > maximum\n            maximum_index -= 1\n        else\n            swap!(sorted_list,\
    \ minimum_index, maximum_index)\n            minimum_index += 1\n            maximum_index\
    \ -= 1\n        end\n    end\n    \n    return sorted_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstrange_sort_list([1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n\
    </cell>\n<text>\nExercise: Strange sorting in Julia\nWrite a function that takes\
    \ a vector of integers and returns it in strange order.\nThe function should take\
    \ a list of integers and return a list of integers in strange order.\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf82vq2lh.jl:38\nin expression starting at\
    \ /tmp/tmpf82vq2lh.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = sort(lst)\n    sorted_list = reverse(sorted_list)\n    return sorted_list\n\
    end\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ the sum of the squares of the integers in the vector.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnst6eyws.jl:19\nin expression starting at\
    \ /tmp/tmpnst6eyws.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a vector of integers\
    \ and returns a vector of integers where the integers are in descending order.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5dcj3sph.jl:27\nin expression starting at\
    \ /tmp/tmp5dcj3sph.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpc05uly1n.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpc05uly1n.jl:1\n\
    in expression starting at /tmp/tmpc05uly1n.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        lst = sort(lst) \n        lst = lst[minimum:maximum+1]\
    \ \n        lst = reverse(lst) \n        return lst \nend \nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2g7ll_7r.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2g7ll_7r.jl:1\n\
    in expression starting at /tmp/tmp2g7ll_7r.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmd6irgjb.jl:1\nin expression starting at /tmp/tmpmd6irgjb.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,julia |>\nHere's a solution using sortperm:\n<code>\n\
    julia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\n`sortperm` doesn't work for me. `sortperm([5,4,3,2,1])`\
    \ returns `5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5`\n<|/ c |>\n<| c |>\n\
    It works for me in Julia 0.6.2. I think it might have been fixed in 0.6.3\n<|/\
    \ c |>\n<| c |>\nI believe this was fixed in 0.6.3\n<|/ c |>\n<| a tags=sorting,julia\
    \ |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n\
    \ 3\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a tags=sorting,julia |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia\
    \ |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n\
    \ 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a tags=sorting,julia |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplsqfpzdm.jl:19\nin expression starting at\
    \ /tmp/tmplsqfpzdm.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ of integers and returns a vector of integers where the integers are in descending\
    \ order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp32ob5kqy.jl:27\nin expression starting at\
    \ /tmp/tmp32ob5kqy.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work for `[1, 1, 2, 3]` because `sort` sorts lexicographically\
    \ and `reverse` reverses the order of the elements. So `[1, 1, 2, 3]` becomes\
    \ `[3, 2, 1]`.\n<|/ c |>\n<| c |>\nYes, you are right. My bad. Thanks for pointing\
    \ it out. I've updated the answer.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\n\
    julia> function strange_sort_list(lst::Vector{Int64})::Vector{Int64}\n       \
    \    return sort(lst)\n       end\nstrange_sort_list (generic function with 1\
    \ method)\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t\
    @test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8,\
    \ 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1ecl9s1p.jl:19\nin expression starting at\
    \ /tmp/tmp1ecl9s1p.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = sort(lst)\n    sorted_list = reverse(sorted_list)\n    return sorted_list\n\
    end\n</code>\n<|/ a tags=sorting,julia,list |>\n<| c |>\nThis doesn't work for\
    \ me. `sort` returns a `Vector{Int64}`, not a `Vector{Int}`. `reverse` doesn't\
    \ work. `reverse` returns a `Vector{Int64}`, not a `Vector{Int}`.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for me either. `sort` returns a `Vector{Int64}`, not\
    \ a `Vector{Int}`. `reverse` doesn't work. `reverse` returns a `Vector{Int64}`,\
    \ not a `Vector{Int}`.\n<|/ c |>\n<| c |>\nI tested this on Julia 1.5.1 and it\
    \ works. What version are you using?\n<|/ c |>\n<| c |>\nI'm using Julia 1.5.1.\
    \ I tested it on Julia 1.5.1 and it works. What version are you using?\n<|/ c\
    \ |>\n<| c |>\nI'm using Julia 1.5.1. I tested it on Julia 1.5.1 and it works.\
    \ What version are you using?\n<|/ c |>\n<| a dscore=3 |>\nI believe that this\
    \ is what you are looking for:\n<code>\njulia> sort!(collect(1:10))\n10-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n</code>\n<|/ a tags=sorting,julia,list\
    \ |>\n<| c |>\nThis doesn't work for me. `sort!` returns a `Vector{Int64}`, not\
    \ a `Vector{Int}`. `reverse` doesn't work. `reverse` returns a `Vector{Int64}`,\
    \ not a `Vector{Int}`.\n<|/ c |>\n<| c |>\nThis doesn't work for me either. `sort!`\
    \ returns a `Vector{Int64}`, not a `Vector{Int}`. `reverse` doesn't work. `reverse`\
    \ returns a `Vector{Int64}`, not a `Vector{Int}`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for me either. `sort!` returns a `Vector{Int64}`, not a `Vector{Int}`.\
    \ `reverse` doesn't work. `reverse` returns a `Vector{Int64}`, not a `Vector{Int}`.\n\
    <|/ c |>\n<| c |>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzs83996z.jl:19\nin expression starting at\
    \ /tmp/tmpzs83996z.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=1 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a dscore=0 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx42m753k.jl:19\nin expression starting at\
    \ /tmp/tmpx42m753k.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmd6irgjb.jl:1\nin expression starting at /tmp/tmpmd6irgjb.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        lst = sort(lst) \n        lst = lst[minimum:maximum+1]\
    \ \n        lst = sort(lst) \n        lst = lst[minimum:maximum+1] \n        return\
    \ lst \nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a Julia package\
    \ called \"sort\" that does this sort of thing. \n<code>\njulia> using sort\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo577zmw1.jl:26\nin expression starting at\
    \ /tmp/tmpo577zmw1.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns a vector of strings in alphabetical\
    \ order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprvi_dsf5.jl:19\nin expression starting at\
    \ /tmp/tmprvi_dsf5.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst) \n    maximum =\
    \ maximum(lst) \n    \n    lst = sort(lst) \n    \n    lst = lst.[minimum:maximum+1]\
    \ \n    \n    return lst \nend\n</cell>\n<text>\nExercise 2: Strange Sorting of\
    \ a Vector\nWrite a function that takes a vector of integers and returns a vector\
    \ of integers in strange order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi9we0bmn.jl:27\nin expression starting at\
    \ /tmp/tmpi9we0bmn.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=1 |>\nI came up with a solution which uses only built-in functions.\
    \ \n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t\
    @test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8,\
    \ 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_dv53y6o.jl:19\nin expression starting at\
    \ /tmp/tmp_dv53y6o.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a tags=sorting,julia |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\nusing Test\n\n@testset begin\n\n\
    candidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    \t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx3eutlb6.jl:19\nin expression starting at\
    \ /tmp/tmpx3eutlb6.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes a vector of integers and returns\
    \ the same vector, sorted from smallest to largest.\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxm4lh9vc.jl:19\nin expression starting at\
    \ /tmp/tmpxm4lh9vc.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum_index = findfirst(isequal(minimum),\
    \ lst) \n        maximum_index = findfirst(isequal(maximum), lst) \n        minimum_value\
    \ = lst[minimum_index] \n        maximum_value = lst[maximum_index] \n       \
    \ lst[minimum_index] = minimum \n        lst[maximum_index] = maximum \n     \
    \   lst = strange_sort_list(lst[minimum_index+1:maximum_index]) \n        lst[minimum_index]\
    \ = minimum_value \n        lst[maximum_index] = maximum_value \n        return\
    \ lst \nend \n</cell>\n<code language=julia-1.4>\nstrange_sort_list([5, 5, 5,\
    \ 5])\n</cell>\n<text>\nExercise\nWrite a function that takes a vector of integers\
    \ and returns the same vector in reverse order.\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpagl5p4em.jl:31\nin expression starting at\
    \ /tmp/tmpagl5p4em.jl:31\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the vector in reverse order.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuhf5rjfs.jl:19\nin expression starting at\
    \ /tmp/tmpuhf5rjfs.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmd6irgjb.jl:1\nin expression starting at /tmp/tmpmd6irgjb.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst) \n    maximum =\
    \ maximum(lst) \n    \n    sorted_list = copy(lst) \n    \n    i = 1 \n    while\
    \ i <= length(lst) \n        if sorted_list[i] > minimum \n            sorted_list[i]\
    \ = minimum \n            minimum = minimum + i \n        else \n            sorted_list[i]\
    \ = maximum \n            maximum = maximum - i \n        end \n        i = i\
    \ + 1 \n    end \n    return sorted_list \nend \n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a vector of integers and returns the sum of the integers\
    \ in the vector.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnyx436x5.jl:36\nin expression starting at\
    \ /tmp/tmpnyx436x5.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = min(lst) \n    maximum = max(lst)\
    \ \n    \n    lst = sort(lst) \n    \n    minimum = min(minimum, lst[1]) \n  \
    \  maximum = max(maximum, lst[end]) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = min(minimum, lst[1]) \n    maximum = max(maximum, lst[end]) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = min(minimum, lst[1]) \n    maximum = max(maximum,\
    \ lst[end]) \n    \n    lst = sort(lst) \n    \n    minimum = min(minimum, lst[1])\
    \ \n    maximum = max(maximum, lst[end]) \n    \n    lst = sort(lst) \n    \n\
    \    minimum = min(minimum, lst[1]) \n    maximum = max(maximum, lst[end]) \n\
    \    \n    lst = sort(lst) \n    \n    minimum = min(minimum, lst[1]) \n    maximum\
    \ = max(maximum, lst[end]) \n    \n    lst = sort(lst) \n    \n    minimum = min(minimum,\
    \ lst[1]) \n    maximum = max(maximum, lst[end]) \n    \n    lst = sort(lst) \n\
    \    \n    minimum = min(minimum, lst[1]) \n    maximum = max(maximum, lst[end])\
    \ \n    \n    lst = sort(lst) \n    \n    minimum = min(minimum, lst[1]) \n  \
    \  maximum = max(maximum, lst[end]) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = min(minimum, lst[1]) \n    maximum = max(maximum, lst[end]) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = min(minimum, lst[1]) \n    maximum = max(maximum,\
    \ lst[end]) \n    \n    lst = sort(lst) \n    \n    minimum = min(minimum, lst[1])\
    \ \n    maximum = max(maximum, lst[end]) \n    \n    lst = sort(lst) \n    \n\
    \    minimum = min(minimum, lst[1]) \n    maximum = max(maximum, lst[end]) \n\
    \    \n    lst = sort(lst) \n    \n    minimum = min(minimum, lst[1]) \n    maximum\
    \ = max(maximum, lst[end]) \n    \n    lst = sort(lst) \n    \n    minimum = min(minimum,\
    \ lst[1]) \n    maximum = max(maximum, lst[end]) \n    \n    lst = sort(lst) \n\
    \    \n    minimum = min(minimum, lst[1]) \n    maximum = max(maximum, lst[end])\
    \ \n    \n    lst = sort(lst) \n\nusing Test\n\n@testset begin\n\ncandidate =\
    \ strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8i_bo89z.jl:1\nin expression starting at /tmp/tmp8i_bo89z.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    minimum_index = findfirst(minimum, lst)\n    maximum_index = findfirst(maximum,\
    \ lst)\n    \n    minimum_index == maximum_index ? \n        lst[minimum_index]\
    \ : \n        lst[minimum_index + 1] \nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a vector of integers and returns the sum of the squares\
    \ of the integers in the vector.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2hnmp74j.jl:28\nin expression starting at\
    \ /tmp/tmp2hnmp74j.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    sorted_list = sort(lst)\n    \n    sorted_list[minimum] = minimum\n\
    \    sorted_list[maximum] = maximum\n    \n    return sorted_list\nend\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector of integers and returns a vector\
    \ of integers sorted from smallest to largest.\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppgoj9e99.jl:28\nin expression starting at\
    \ /tmp/tmppgoj9e99.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| c |>\nThis doesn't work if you have a vector of strings. `sort` sorts\
    \ lexicographically, not numerically.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works for strings as well.\n<|/ c |>\n<| a |>\n<code>\njulia> function strange_sort_list(lst::Vector{Int64})::Vector{Int64}\n\
    \           return sort(lst)\n       end\nstrange_sort_list (generic function\
    \ with 1 method)\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx8jsuk_m.jl:19\nin expression starting at\
    \ /tmp/tmpx8jsuk_m.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the same vector, but with each element\
    \ multiplied by 2.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmtct9i6m.jl:19\nin expression starting at\
    \ /tmp/tmpmtct9i6m.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns another vector with integers sorted\
    \ from smallest to largest.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcoy8hh97.jl:19\nin expression starting at\
    \ /tmp/tmpcoy8hh97.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    \n    while i < length(lst)\n        \n\
    \        if lst[i] > lst[i + 1]\n            \n            lst[i], lst[i + 1]\
    \ = lst[i + 1], lst[i]\n            \n            i += 2\n            \n     \
    \   else\n            \n            i += 1\n        end\n    end\n    \n    return\
    \ lst\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ of integers and returns a vector of integers where the integers are in descending\
    \ order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfji8ipdb.jl:36\nin expression starting at\
    \ /tmp/tmpfji8ipdb.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns its sum.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfwnhfee5.jl:19\nin expression starting at\
    \ /tmp/tmpfwnhfee5.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = copy(lst)\n    sorted_list[1] = max(sorted_list[1:end-1]) \n    sorted_list[end]\
    \ = min(sorted_list[2:end])\n    return sorted_list\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a vector of integers and returns the sum of the\
    \ squares of the integers. \nThe function should raise an error if the vector\
    \ is empty.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t\
    @test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8,\
    \ 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc5u6byux.jl:20\nin expression starting at\
    \ /tmp/tmpc5u6byux.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = sort(lst)\n    sorted_list = reverse(sorted_list)\n    return sorted_list\n\
    end\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector of integers\
    \ and returns the sum of the squares of the integers. \nThe function should raise\
    \ an error if the vector is empty.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpthaccbk8.jl:19\nin expression starting at\
    \ /tmp/tmpthaccbk8.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns the vector in reverse order.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1ovq96az.jl:19\nin expression starting at\
    \ /tmp/tmp1ovq96az.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst = reverse(lst) \n        lst = sort(lst)\
    \ \n        lst = reverse(lst) \n        lst = sort(lst) \n        lst = reverse(lst)\
    \ \n        lst = sort(lst) \n        lst\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpc05uly1n.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpc05uly1n.jl:1\n\
    in expression starting at /tmp/tmpc05uly1n.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph82t16eh.jl:19\nin expression starting at\
    \ /tmp/tmph82t16eh.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum_index = findfirst(isequal(minimum),\
    \ lst) \n        maximum_index = findfirst(isequal(maximum), lst) \n        \n\
    \        lst[minimum_index], lst[maximum_index] = lst[maximum_index], lst[minimum_index]\
    \ \n        strange_sort_list(lst[minimum_index:maximum_index]) \n        lst[minimum_index],\
    \ lst[maximum_index] = minimum, maximum \n        return lst \nend\n</code>\n\
    <|/ a tags=sorting,julia |>\n<| c |>\nI like this solution, because it doesn't\
    \ require any additional packages. However, it does require a lot of memory and\
    \ time for large lists. I wonder if there is a way to do this without using so\
    \ much memory?\n<|/ c |>\n<| c |>\nI added a solution that doesn't require any\
    \ additional packages.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require\
    \ any additional packages.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using\
    \ sortperm:\n<code>\njulia> sortperm(collect(1:10))\n10-element Array{Int64,1}:\n\
    \ 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10\n</code>\n<|/ a tags=sorting,julia |>\n<|\
    \ c |>\nThis doesn't work for me. `sortperm(collect(1:10))` returns `10-element\
    \ Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10`\n<|/ c |>\n<| c |>\n`sortperm`\
    \ doesn't work if you have a vector of Int64. `sortperm(collect(1:10))` returns\
    \ `10-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n 10`\n<|/ c |>\n\
    <| c |>\n`sortperm(collect(1:10))` returns `10-element Array{Int64,1}:\n 2\n 3\n\
    \ 4\n 5\n 6\n 7\n 8\n 9\n 10`\n<|/ c |>\n<| c |>\n`sortperm(collect(1:10))` returns\
    \ `10-element Array{Int64,1}:\n 2\n 3\n 4\n\nusing Test\n\n@testset begin\n\n\
    candidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    \t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppd_6v9w8.jl:28\nin expression starting at\
    \ /tmp/tmppd_6v9w8.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the same vector, except with each\
    \ integer replaced by the sum of the integers preceding it.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoltloitg.jl:19\nin expression starting at\
    \ /tmp/tmpoltloitg.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdlm7wmai.jl:19\nin expression starting at\
    \ /tmp/tmpdlm7wmai.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst .- minimum\n    lst = lst .+ maximum\n\
    \    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ of integers and returns a vector of integers sorted from smallest to largest.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk_33ai68.jl:28\nin expression starting at\
    \ /tmp/tmpk_33ai68.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum_index = findfirst(minimum, lst)\
    \ \n        maximum_index = findfirst(maximum, lst) \n        lst[minimum_index],\
    \ lst[maximum_index] = lst[maximum_index], lst[minimum_index] \n        strange_sort_list(lst[minimum_index:maximum_index])\
    \ \n        return lst \nend \n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<text>\nExercise: Write a function that takes a vector of\
    \ integers and returns the same vector, except that the integers are sorted in\
    \ reverse order (largest to smallest).\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi99uqr6w.jl:26\nin expression starting at\
    \ /tmp/tmpi99uqr6w.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum, maximum = minimum, maximum\n  \
    \      minimum, maximum = minimum + 1, maximum - 1\n        minimum, maximum =\
    \ minimum - 1, maximum + 1\n        minimum, maximum = minimum - 1, maximum -\
    \ 1\n        minimum, maximum = minimum + 1, maximum + 1\n        minimum, maximum\
    \ = minimum - 1, maximum - 1\n        minimum, maximum = minimum - 1, maximum\
    \ + 1\n        minimum, maximum = minimum + 1, maximum - 1\n        minimum, maximum\
    \ = minimum + 1, maximum + 1\n        minimum, maximum = minimum + 1, maximum\
    \ - 1\n        minimum, maximum = minimum + 1, maximum + 1\n        minimum, maximum\
    \ = minimum - 1, maximum - 1\n        minimum, maximum = minimum - 1, maximum\
    \ + 1\n        minimum, maximum = minimum - 1, maximum - 1\n        minimum, maximum\
    \ = minimum - 1, maximum + 1\n        minimum, maximum = minimum + 1, maximum\
    \ - 1\n        minimum, maximum = minimum + 1, maximum + 1\n        minimum, maximum\
    \ = minimum + 1, maximum - 1\n        minimum, maximum = minimum + 1, maximum\
    \ + 1\n        minimum, maximum = minimum + 1, maximum - 1\n        minimum, maximum\
    \ = minimum + 1, maximum + 1\n        minimum, maximum = minimum - 1, maximum\
    \ - 1\n        minimum, maximum = minimum - 1, maximum + 1\n        minimum, maximum\
    \ = minimum - 1, maximum - 1\n        minimum, maximum = minimum - 1, maximum\
    \ + 1\n        minimum, maximum = minimum - 1, maximum + 1\n        minimum, maximum\
    \ = minimum - 1, maximum - 1\n        minimum, maximum = minimum - 1, maximum\
    \ + 1\n        minimum, maximum = minimum - 1, maximum - 1\n        minimum, maximum\
    \ = minimum - 1, maximum + 1\n        minimum, maximum = minimum - 1, maximum\
    \ - 1\n        minimum, maximum = minimum - 1, maximum + 1\n        minimum, maximum\
    \ = minimum - 1, maximum + 1\n        minimum, maximum = minimum - 1, maximum\
    \ - 1\n        minimum, maximum = minimum - 1, maximum + 1\n        minimum, maximum\
    \ = minimum - 1, maximum - 1\n        minimum, maximum = minimum - 1, maximum\
    \ + 1\n        minimum, maximum = minimum - 1, maximum + 1\n        minimum, maximum\
    \ = minimum - 1, maximum - 1\n        minimum, maximum = minimum - 1, maximum\
    \ + 1\n        minimum, maximum = minimum - 1, maximum - 1\n        minimum, maximum\
    \ = minimum - 1, maximum + 1\n        minimum, maximum = minimum - 1, maximum\
    \ + 1\n        minimum, maximum = minimum - 1, maximum - 1\n        minimum, maximum\
    \ = minimum - 1, maximum + 1\n        minimum, maximum\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpa98oyc8y.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa98oyc8y.jl:1\n\
    in expression starting at /tmp/tmpa98oyc8y.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if you have negative numbers in the list.\n<|/\
    \ c |>\n<| c |>\nI added a version that doesn't require negative numbers. I tested\
    \ it and it works.\n<|/ c |>\n<| c |>\nThis doesn't work if you have negative\
    \ numbers in the list. Try `strange_sort_list([-1, -2, -3, 4])`.\n<|/ c |>\n<|\
    \ c |>\nI added a version that doesn't require negative numbers. I tested it and\
    \ it works.\n<|/ c |>\n<| a tags=sorting,julia |>\nI came up with this solution:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkeng20no.jl:19\nin expression starting at\
    \ /tmp/tmpkeng20no.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,julia |>\n<code>\njulia> function strange_sort_list(lst::Vector{Int64})::Vector{Int64}\n\
    \           lst = sort(lst)\n           lst = reverse(lst)\n           return\
    \ lst\n       end\nstrange_sort_list (generic function with 1 method)\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph9utho3y.jl:19\nin expression starting at\
    \ /tmp/tmph9utho3y.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum = minimum - maximum + 1 \n     \
    \   maximum = maximum - minimum + 1 \n        minimum = minimum - maximum + 1\
    \ \n        maximum = maximum - minimum + 1 \n        minimum = minimum - maximum\
    \ + 1 \n        maximum = maximum - minimum + 1 \n        minimum = minimum -\
    \ maximum + 1 \n        maximum = maximum - minimum + 1 \n        minimum = minimum\
    \ - maximum + 1 \n        maximum = maximum - minimum + 1 \n        minimum =\
    \ minimum - maximum + 1 \n        maximum = maximum - minimum + 1 \n        minimum\
    \ = minimum - maximum + 1 \n        maximum = maximum - minimum + 1 \n       \
    \ minimum = minimum - maximum + 1 \n        maximum = maximum - minimum + 1 \n\
    \        minimum = minimum - maximum + 1 \n        maximum = maximum - minimum\
    \ + 1 \n        minimum = minimum - maximum + 1 \n        maximum = maximum -\
    \ minimum + 1 \n        minimum = minimum - maximum + 1 \n        maximum = maximum\
    \ - minimum + 1 \n        minimum = minimum - maximum + 1 \n        maximum =\
    \ maximum - minimum + 1 \n        minimum = minimum - maximum + 1 \n        maximum\
    \ = maximum - minimum + 1 \n        minimum = minimum - maximum + 1 \n       \
    \ maximum = maximum - minimum + 1 \n        minimum = minimum - maximum + 1 \n\
    \        maximum = maximum - minimum + 1 \n        minimum = minimum - maximum\
    \ + 1 \n        maximum = maximum - minimum + 1 \n        minimum = minimum -\
    \ maximum + 1 \n        maximum = maximum - minimum + 1 \n        minimum = minimum\
    \ - maximum + 1 \n        maximum = maximum - minimum + 1 \n        minimum =\
    \ minimum - maximum + 1 \n        maximum = maximum - minimum + 1 \n        minimum\
    \ = minimum - maximum + 1 \n        maximum = maximum - minimum + 1 \n       \
    \ minimum = minimum - maximum + 1 \n        maximum = maximum - minimum + 1 \n\
    \        minimum = minimum - maximum + 1 \n        maximum = maximum - minimum\
    \ + 1 \n        minimum = minimum - maximum + 1 \n        maximum = maximum -\
    \ minimum + 1 \n        minimum = minimum - maximum + 1 \n        maximum = maximum\
    \ - minimum + 1 \n        minimum = minimum - maximum + 1 \n        maximum =\
    \ maximum - minimum + 1 \n        minimum = minimum - maximum + 1 \n        maximum\
    \ = maximum - minimum + 1 \n        minimum = minimum - maximum + 1 \n       \
    \ maximum = maximum - minimum + 1 \nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp6sfbd97v.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6sfbd97v.jl:1\n\
    in expression starting at /tmp/tmp6sfbd97v.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = sort(lst)\n    \n    i = 0\n    \n    while i < length(sorted_list)\n    \
    \    if sorted_list[i] > sorted_list[i + 1]\n            swap!(sorted_list, i,\
    \ i + 1)\n        end\n        i += 1\n    end\n    \n    return sorted_list\n\
    end\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([1, 2, 3, 4])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ the same vector, but with each element multiplied by 2.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe4afvcnt.jl:28\nin expression starting at\
    \ /tmp/tmpe4afvcnt.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to do this\
    \ without creating a new vector. Maybe something like `sort(lst)` but with the\
    \ `reverse` function applied to the return value?\n<|/ c |>\n<| c |>\nI guess\
    \ you could do `sort(lst)` followed by `reverse(lst)`, but that would create a\
    \ new vector and copy the contents of the old vector into it, which is not very\
    \ efficient.\n<|/ c |>\n<| c |>\nI guess you could do `sort(lst)` followed by\
    \ `reverse(lst)`, but that would create a new vector and copy the contents of\
    \ the old vector into it, which is not very efficient.\n<|/ c |>\n<| c |>\nI guess\
    \ you could do `sort(lst)` followed by `reverse(lst)`, but that would create a\
    \ new vector and copy the contents of the old vector into it, which is not very\
    \ efficient.\n<|/ c |>\n<| c |>\nI guess you could do `sort(lst)` followed by\
    \ `reverse(lst)`, but that would create a new vector and copy the contents of\
    \ the old vector into it, which is not very efficient.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>\njulia> function strange_sort_list(lst::Vector{Int64})::Vector{Int64}\n\
    \           return sort(lst)\n       end\nstrange_sort_list (generic function\
    \ with 1 method)\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdla0hxe1.jl:19\nin expression starting at\
    \ /tmp/tmpdla0hxe1.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a |>\nI came up with this solution:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5spgiv9m.jl:19\nin expression starting at\
    \ /tmp/tmp5spgiv9m.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns a vector of strings in alphabetical\
    \ order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppy5lvua0.jl:19\nin expression starting at\
    \ /tmp/tmppy5lvua0.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ if length(lst) == 0 \n        return [] \n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_ugaevqr.jl:117\nin expression starting at\
    \ /tmp/tmp_ugaevqr.jl:117\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = min(lst)\n    maximum = max(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([1, 2, 3, 4])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ the same vector, but with each element multiplied by 2.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy8j1gtp4.jl:27\nin expression starting at\
    \ /tmp/tmpy8j1gtp4.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    \n    while i < length(lst)\n        \n\
    \        if lst[i] > lst[i+1]\n            \n            lst[i], lst[i+1] = lst[i+1],\
    \ lst[i]\n            \n            i = i + 1\n            \n        else\n  \
    \          i = i + 1\n        end\n    end\n    \n    return lst\nend\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\n\
    Sort a vector in descending order\nusing Test\n\n@testset begin\n\ncandidate =\
    \ strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3b1cqokh.jl:35\nin expression starting at\
    \ /tmp/tmp3b1cqokh.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    end\n    minimum = minimum(lst)\n    maximum\
    \ = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp833epuxm.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp833epuxm.jl:1\n\
    in expression starting at /tmp/tmp833epuxm.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    minimum_index = findfirst(minimum, lst)\n    maximum_index = findfirst(maximum,\
    \ lst)\n    \n    lst[minimum_index], lst[maximum_index] = lst[maximum_index],\
    \ lst[minimum_index]\n    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise\nWrite a function that\
    \ takes a vector of integers and returns a vector in strange order.\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk6d60s4e.jl:28\nin expression starting at\
    \ /tmp/tmpk6d60s4e.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the vector in reverse order. \n\
    The function should work for both vectors of integers and vectors of floating\
    \ point numbers.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeyf22x_w.jl:19\nin expression starting at\
    \ /tmp/tmpeyf22x_w.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work for me. `sort([5,5,5,5])` gives me `[5, 5, 5,\
    \ 5]` instead of `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nIt works for me in Julia\
    \ 0.6.2\n<|/ c |>\n<| c |>\nIt works for me in Julia 0.6.2\n<|/ c |>\n<| c |>\n\
    It works for me in Julia 0.6.2\n<|/ c |>\n<| a tags=julia,sorting |>\nI believe\
    \ that this is what you are looking for:\n<code>\njulia> sort([5,5,5,5])\n5-element\
    \ Array{Int64,1}:\n 5\n 5\n 5\n 5\nusing Test\n\n@testset begin\n\ncandidate =\
    \ strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpocdhrt7d.jl:19\nin expression starting at\
    \ /tmp/tmpocdhrt7d.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the same vector, sorted from smallest\
    \ to largest.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqmzjcsvz.jl:19\nin expression starting at\
    \ /tmp/tmpqmzjcsvz.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([1,\
    \ 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0c7epoqk.jl:19\nin expression starting at\
    \ /tmp/tmp0c7epoqk.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the same vector, except with each\
    \ element multiplied by 2.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2_mv7i37.jl:19\nin expression starting at\
    \ /tmp/tmp2_mv7i37.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst.[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a vector of integers\
    \ and returns the same vector but with integers sorted from smallest to largest.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyf2yscww.jl:27\nin expression starting at\
    \ /tmp/tmpyf2yscww.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = sort(lst)\n    sorted_list = reverse(sorted_list)\n    return sorted_list\n\
    end\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ a vector of integers sorted from smallest to largest.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvbjk4c3f.jl:19\nin expression starting at\
    \ /tmp/tmpvbjk4c3f.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ a vector of integers sorted from smallest to largest.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjauk6uqm.jl:19\nin expression starting at\
    \ /tmp/tmpjauk6uqm.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia,list\
    \ |>\n<| c |>\nThis doesn't work if you have a vector of strings. `sort` sorts\
    \ lexicographically, not numerically.\n<|/ c |>\n<| c |>\nI didn't know that about\
    \ `sort`, thanks for pointing that out. I've updated the answer to include a solution\
    \ that works for both `Int` and `Float64`.\n<|/ c |>\n<| a tags=sorting,julia,list\
    \ |>\n<code>\njulia> function strange_sort_list(lst::Vector{Int64})::Vector{Int64}\n\
    \           lst = sort(lst)\n           lst = reverse(lst)\n           return\
    \ lst\n       end\nstrange_sort_list (generic function with 1 method)\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0bp104xb.jl:19\nin expression starting at\
    \ /tmp/tmp0bp104xb.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0\n        return lst\n    end\n    minimum = minimum(lst)\n    maximum =\
    \ maximum(lst)\n    minimum_index = findfirst(minimum, lst)\n    maximum_index\
    \ = findfirst(maximum, lst)\n    \n    lst[minimum_index], lst[maximum_index]\
    \ = lst[maximum_index], lst[minimum_index]\n    \n    return strange_sort_list(lst)\n\
    end\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ a vector of integers sorted from smallest to largest.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp22iben4z.jl:27\nin expression starting at\
    \ /tmp/tmp22iben4z.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    end\n    minimum = minimum(lst)\n    maximum\
    \ = maximum(lst)\n    minimum_index = findfirst(minimum, lst)\n    maximum_index\
    \ = findfirst(maximum, lst)\n    \n    lst[minimum_index], lst[maximum_index]\
    \ = lst[maximum_index], lst[minimum_index]\n    \n    return strange_sort_list(lst)\n\
    end\n</code>\n<|/ a tags=sorting,julia |>\n<| c |>\nThis does not work if there\
    \ are repeated elements in the list. For example, `strange_sort_list([1,1,2,3,3])`\
    \ returns `[1,1,2,3,3]`.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ repeated elements.\n<|/ c |>\n<| a tags=sorting,julia |>\nI wrote a package\
    \ for this: \nhttps://github.com/kamila/julia-sort\n<code>\njulia> using JuliaSort\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbmakuq74.jl:27\nin expression starting at\
    \ /tmp/tmpbmakuq74.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| c |>\nThe `sort` function will sort in-place, so you don't need to return\
    \ `lst`.\n<|/ c |>\n<| c |>\nThanks, I didn't know that. I've edited the answer\
    \ to reflect that.\n<|/ c |>\n<| a dscore=4 |>\n<code>\njulia> using Statistics\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp53ktjxo7.jl:19\nin expression starting at\
    \ /tmp/tmp53ktjxo7.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    minimum_index = findfirst(minimum, lst)\n    maximum_index = findfirst(maximum,\
    \ lst)\n    \n    lst[minimum_index], lst[maximum_index] = lst[maximum_index],\
    \ lst[minimum_index]\n    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the sum of the squares of the integers.\
    \ \nThe function should work for vectors of any length.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmygi0kz0.jl:28\nin expression starting at\
    \ /tmp/tmpmygi0kz0.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nThe accepted answer works fine for small lists, but for\
    \ large lists, it becomes very slow. Here is a more efficient solution:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptzp8xk30.jl:19\nin expression starting at\
    \ /tmp/tmptzp8xk30.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ sorted_list = copy(lst)\n    \n    for i = length(sorted_list) downto 1 \n \
    \       \n        if sorted_list[i] > sorted_list[i-1] \n            \n      \
    \      temp = sorted_list[i-1]\n            sorted_list[i-1] = sorted_list[i]\n\
    \            sorted_list[i] = temp\n        end\n    end\n    \n    return sorted_list\n\
    end\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmpkeiuedkw.jl:18 expected \"\
    end\", got \"1\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkeiuedkw.jl:18\n\
    in expression starting at /tmp/tmpkeiuedkw.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst)\n     \
    \   maximum = maximum(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpt04jp4y3.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpt04jp4y3.jl:1\n\
    in expression starting at /tmp/tmpt04jp4y3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=3 |>\n<code>\njulia> using Statistics\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc7jvx7rd.jl:19\nin expression starting at\
    \ /tmp/tmpc7jvx7rd.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdspb3cwd.jl:19\nin expression starting at\
    \ /tmp/tmpdspb3cwd.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| c |>\nI believe this should be the accepted answer. Although it does\
    \ require a package to be installed, it is very simple and straightforward.\n\
    <|/ c |>\n<| a dscore=3 |>\nThe easiest way is to use sortperm:\n<code>\njulia>\
    \ sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n\
    <|/ a tags=sorting,julia |>\n<| a tags=sorting,julia |>\nThe answer by is correct,\
    \ but I thought I'd add some additional information for those who are new to Julia.\n\
    The sortperm function returns a permutation of a vector. For example, sortperm([5,4,3,2,1])\
    \ returns [1,2,3,4,5]. \nThe function sortperm(arr) sorts the array arr in ascending\
    \ order. \nThe function sortperm(arr) returns a permutation of a vector. For example,\
    \ sortperm([5,4,3,2,1]) returns [1,2,3,4,5]. \nThe function sortperm(arr) sorts\
    \ the array arr in ascending order. \nThe function sortperm(arr) returns a permutation\
    \ of a vector. For example, sortperm([5,4,3,2,1]) returns [1,2,3,4,5]. \nThe function\
    \ sortperm(arr) sorts the array arr in ascending order. \nThe function sortperm(arr)\
    \ returns a permutation of a vector. For example, sortperm([5,4,3,2,1]) returns\
    \ [1,2,3,4,5]. \nThe function sortperm(arr) sorts the array arr in ascending order.\
    \ \nThe function sortperm(arr) returns a permutation of a vector. For example,\
    \ sortperm([5,4,3,2,1]) returns [1,2,3,4,5]. \nThe function sortperm(arr) sorts\
    \ the array arr in ascending order. \nThe function sortperm(arr) returns a permutation\
    \ of a vector. For example, sortperm([5,4,3,2,1]) returns [1,2,3,4,5]. \nThe function\
    \ sortperm(arr) sorts the array arr in ascending order. \nThe function sortperm(arr)\
    \ returns a permutation of a vector. For example, sortperm([5,4,3,2,1]) returns\
    \ [1,2,3,4,5]. \nThe function sortperm(arr) sorts the array arr in ascending order.\
    \ \nThe function sortperm(arr) returns a permutation of a vector. For example,\
    \ sortperm([5,4,3,2,1]) returns [\nusing Test\n\n@testset begin\n\ncandidate =\
    \ strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjtyhqdcn.jl:19\nin expression starting at\
    \ /tmp/tmpjtyhqdcn.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for empty lists. `sort([])` returns `[]`, not\
    \ `[nothing]`.\n<|/ c |>\n<| c |>\n`sort([])` returns `[]` because `sort([])`\
    \ returns `[]` not because `sort([])` returns `nothing`\n<|/ c |>\n<| c |>\n`sort([])`\
    \ returns `[]` because `sort([])` returns `[]` not because `sort([])` returns\
    \ `nothing`\n<|/ c |>\n<| c |>\n`sort([])` returns `[]` because `sort([])` returns\
    \ `[]` not because `sort([])` returns `nothing`\n<|/ c |>\n<| c |>\n`sort([])`\
    \ returns `[]` because `sort([])` returns `[]` not because `sort([])` returns\
    \ `nothing`\n<|/ c |>\n<| a tags=sorting,julia |>\nI wanted to add another answer\
    \ because I wanted to add another way to sort a vector in Julia that doesn't require\
    \ the use of any packages. \n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3wxdv4rd.jl:19\nin expression starting at\
    \ /tmp/tmp3wxdv4rd.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        middle = minimum + maximum/2 \n        lst\
    \ = sort(lst) \n        lst = lst[minimum:maximum] \n        lst = lst[middle:maximum]\
    \ \n        lst = lst[minimum:maximum] \n        return lst \nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nThe answer by is good, but I thought I'd add my own\
    \ answer because I wanted to see how it compared to other solutions.\nI used the\
    \ Julia BenchmarkTools package to compare the performance of the various solutions.\n\
    The benchmark code is:\n<code>\nusing BenchmarkTools\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5vhzx2k0.jl:27\nin expression starting at\
    \ /tmp/tmp5vhzx2k0.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nThe answer by is correct, but I thought I'd add an explanation\
    \ as to why it works.\nThe sort function sorts arrays in place. As such, when\
    \ you call sort(lst), lst is modified in place. \nThe reverse function reverses\
    \ the order of the elements of an array. As such, when you call reverse(lst),\
    \ lst is modified in place. \nThe reason why this works is because sort and reverse\
    \ return nothing. Instead, they modify the array in place. \nTherefore, when you\
    \ call sort(lst) and reverse(lst), you are modifying the same array in place.\
    \ \nTherefore, your function can be written as:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpki4_lwbt.jl:19\nin expression starting at\
    \ /tmp/tmpki4_lwbt.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the sum of the squares of the integers\
    \ in that vector.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyz1qbpyw.jl:19\nin expression starting at\
    \ /tmp/tmpyz1qbpyw.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum_index = findfirst(minimum == lst)\
    \ \n        maximum_index = findfirst(maximum == lst) \n        lst[minimum_index],\
    \ lst[maximum_index] = lst[maximum_index], lst[minimum_index] \n        return\
    \ strange_sort_list(lst) \nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work for empty lists. `minimum([])` returns `nothing`, so `minimum_index` will\
    \ be `nothing` and the `minimum` will be overwritten.\n<|/ c |>\n<| c |>\nYes,\
    \ you are right. I fixed it. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThis solution uses no recursion and is O(n) time complexity:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1_3wdye1.jl:25\nin expression starting at\
    \ /tmp/tmp1_3wdye1.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    \n    while i < length(lst)\n        \n\
    \        if lst[i] > lst[i+1]\n            \n            lst[i], lst[i+1] = lst[i+1],\
    \ lst[i]\n            \n            i = i + 1\n            \n        else\n  \
    \          i = i + 1\n        end\n    end\n    \n    return lst\nend\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a vector of integers and returns a vector\
    \ of integers sorted from smallest to largest.\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz4xf5ybr.jl:35\nin expression starting at\
    \ /tmp/tmpz4xf5ybr.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    \n    while i < length(lst)\n        if\
    \ lst[i] > lst[i + 1]\n            lst[i], lst[i + 1] = lst[i + 1], lst[i]\n \
    \           i += 1\n        end\n    end\n    \n    return lst\nend\n</cell>\n\
    <text>\nExercise 9\nWrite a function that takes a vector of integers and returns\
    \ the sum of the integers in the vector.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz44r8sby.jl:29\nin expression starting at\
    \ /tmp/tmpz44r8sby.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nI wrote a Julia package called \"sort\" that does this\
    \ for you. \n<code>\njulia> using Sort\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph82gnerb.jl:19\nin expression starting at\
    \ /tmp/tmph82gnerb.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp25lciq8n.jl:19\nin expression starting at\
    \ /tmp/tmp25lciq8n.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst .- minimum\n    lst = lst .+ maximum\n\
    \    \n    return lst\nend\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of integers and returns the sum of the squares of the integers\
    \ in the vector. \nFor example, if the input vector is [4, 6, 3, 9], the output\
    \ should be 50.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9jv18u56.jl:28\nin expression starting at\
    \ /tmp/tmp9jv18u56.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise\nWrite a function that\
    \ takes a vector of integers and returns the same vector but in reverse order.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6jqbma2r.jl:19\nin expression starting at\
    \ /tmp/tmp6jqbma2r.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,julia |>\nThe answer by is correct but can be simplified\
    \ a bit. \n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9i96fvxh.jl:19\nin expression starting at\
    \ /tmp/tmp9i96fvxh.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst .- minimum\n    \n    lst = lst\
    \ .+ maximum\n    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the same vector, except with integers\
    \ sorted from smallest to largest.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg90qa8z9.jl:29\nin expression starting at\
    \ /tmp/tmpg90qa8z9.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    end\n    \n    minimum = minimum(lst)\n    maximum\
    \ = maximum(lst)\n    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n\
    \    maximum = maximum(lst)\n    \n    minimum = minimum + maximum\n    maximum\
    \ = maximum - minimum\n    \n    minimum = minimum + maximum\n    maximum = maximum\
    \ - minimum\n    \n    minimum = minimum + maximum\n    maximum = maximum - minimum\n\
    \    \n    minimum = minimum + maximum\n    maximum = maximum - minimum\n    \n\
    \    minimum = minimum + maximum\n    maximum = maximum - minimum\n    \n    minimum\
    \ = minimum + maximum\n    maximum = maximum - minimum\n    \n    minimum = minimum\
    \ + maximum\n    maximum = maximum - minimum\n    \n    minimum = minimum + maximum\n\
    \    maximum = maximum - minimum\n    \n    minimum = minimum + maximum\n    maximum\
    \ = maximum - minimum\n    \n    minimum = minimum + maximum\n    maximum = maximum\
    \ - minimum\n    \n    minimum = minimum + maximum\n    maximum = maximum - minimum\n\
    \    \n    minimum = minimum + maximum\n    maximum = maximum - minimum\n    \n\
    \    minimum = minimum + maximum\n    maximum = maximum - minimum\n    \n    minimum\
    \ = minimum + maximum\n    maximum = maximum - minimum\n    \n    minimum = minimum\
    \ + maximum\n    maximum = maximum - minimum\n    \n    minimum = minimum + maximum\n\
    \    maximum = maximum - minimum\n    \n    minimum = minimum + maximum\n    maximum\
    \ = maximum - minimum\n    \n    minimum = minimum + maximum\n    maximum = maximum\
    \ - minimum\n    \n    minimum = minimum + maximum\n    maximum = maximum - minimum\n\
    \    \n    minimum = minimum + maximum\n    maximum = maximum - minimum\n    \n\
    \    minimum = minimum + maximum\n    maximum = maximum - minimum\n    \n    minimum\
    \ = minimum + maximum\n    maximum = maximum - minimum\n    \n    minimum = minimum\
    \ + maximum\n    maximum = maximum - minimum\n    \n    minimum = minimum + maximum\n\
    \    maximum = maximum - minimum\n    \n    minimum = minimum + maximum\n    maximum\
    \ = maximum - minimum\n    \n    minimum = minimum + maximum\n    maximum = maximum\
    \ - minimum\n    \n    minimum = minimum + maximum\n    maximum = maximum - minimum\n\
    \    \n    minimum = minimum + maximum\n    maximum = maximum - minimum\n    \n\
    \    minimum = minimum + maximum\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp608sbpsf.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp608sbpsf.jl:1\n\
    in expression starting at /tmp/tmp608sbpsf.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    \n    while i < length(lst)\n        if\
    \ lst[i] > lst[i+1]\n            swap!(lst, i, i+1)\n        end\n        i +=\
    \ 1\n    end\n    \n    lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector\
    \ of integers and returns the same vector in reverse order. Do not use reverse!.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo2gq08la.jl:29\nin expression starting at\
    \ /tmp/tmpo2gq08la.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ sorted_list = copy(lst)\n    \n    minimum = minimum(sorted_list)\n    maximum\
    \ = maximum(sorted_list)\n    \n    minimum_idx = findfirst(x -> x == minimum,\
    \ sorted_list)\n    maximum_idx = findfirst(x -> x == maximum, sorted_list)\n\
    \    \n    minimum_idx = minimum_idx + 1\n    maximum_idx = maximum_idx - 1\n\
    \    \n    minimum_idx = minimum_idx % length(sorted_list)\n    maximum_idx =\
    \ maximum_idx % length(sorted_list)\n    \n    minimum_idx = minimum_idx - 1\n\
    \    maximum_idx = maximum_idx + 1\n    \n    minimum_idx = minimum_idx % length(sorted_list)\n\
    \    maximum_idx = maximum_idx % length(sorted_list)\n    \n    minimum_idx =\
    \ minimum_idx - 1\n    maximum_idx = maximum_idx + 1\n    \n    minimum_idx =\
    \ minimum_idx % length(sorted_list)\n    maximum_idx = maximum_idx % length(sorted_list)\n\
    \    \n    minimum_idx = minimum_idx - 1\n    maximum_idx = maximum_idx + 1\n\
    \    \n    minimum_idx = minimum_idx % length(sorted_list)\n    maximum_idx =\
    \ maximum_idx % length(sorted_list)\n    \n    minimum_idx = minimum_idx - 1\n\
    \    maximum_idx = maximum_idx + 1\n    \n    minimum_idx = minimum_idx % length(sorted_list)\n\
    \    maximum_idx = maximum_idx % length(sorted_list)\n    \n    minimum_idx =\
    \ minimum_idx - 1\n    maximum_idx = maximum_idx + 1\n    \n    minimum_idx =\
    \ minimum_idx % length(sorted_list)\n    maximum_idx = maximum_idx % length(sorted_list)\n\
    \    \n    minimum_idx = minimum_idx - 1\n    maximum_idx = maximum_idx + 1\n\
    \    \n    minimum_idx = minimum_idx % length(sorted_list)\n    maximum_idx =\
    \ maximum_idx % length(sorted_list)\n    \n    minimum_idx = minimum_idx - 1\n\
    \    maximum_idx = maximum_idx + 1\n    \n    minimum_idx = minimum_idx % length(sorted_list)\n\
    \    maximum_idx = maximum_idx % length(sorted_list)\n    \n    minimum_idx =\
    \ minimum_idx - 1\n    maximum_idx = maximum_idx + 1\n    \n    minimum_idx =\
    \ minimum_idx % length(sorted_list)\n    maximum_idx = maximum_idx % length(sorted_list)\n\
    \    \n    minimum_idx = minimum_idx - 1\n    maximum_idx = maximum_idx + 1\n\
    \    \n    minimum_idx = minimum_idx % length(sorted_list)\n    maximum_idx =\
    \ maximum_idx % length(sorted_list)\n    \n    minimum_idx = minimum_idx - 1\n\
    \    maximum_idx = maximum_idx + 1\n    \n    minimum_idx = minimum_idx % length(sorted_list)\n\
    \    maximum_idx = maximum_idx % length(sorted_list)\n    \n    minimum_idx =\
    \ minimum_idx - 1\n    maximum_idx = maximum_idx + \nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5enaati4.jl:14\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5enaati4.jl:1\n\
    in expression starting at /tmp/tmp5enaati4.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    \n    while i < length(lst)\n        \n\
    \        if lst[i] < lst[i+1]\n            \n            tmp = lst[i]\n      \
    \      lst[i] = lst[i+1]\n            lst[i+1] = tmp\n            \n         \
    \   i += 1\n            \n        else\n            \n            i += 1\n   \
    \     end\n    end\n    \n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ the same vector in reverse order.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3fwqhn1q.jl:38\nin expression starting at\
    \ /tmp/tmp3fwqhn1q.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ lst = sort(lst)\n    \n    i = 0\n    \n    while i < length(lst)\n        \n\
    \        if lst[i] > lst[i+1]\n            \n            lst[i], lst[i+1] = lst[i+1],\
    \ lst[i]\n            \n            i += 1\n            \n        else\n     \
    \       \n            i += 1\n        end\n    end\n    \n    return lst\nend\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([1, 2, 3, 4])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ another vector where each element is the sum of the elements in the original\
    \ vector. For example, if the input vector is [10, 20, 30, 40], the output vector\
    \ should be [120, 240, 360, 480]\nusing Test\n\n@testset begin\n\ncandidate =\
    \ strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp5w45wbl.jl:36\nin expression starting at\
    \ /tmp/tmpp5w45wbl.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst) \n    maximum =\
    \ maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst)\
    \ \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n \
    \   \n    minimum = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum = maximum(lst)\
    \ \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum\
    \ = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst)\
    \ \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n \
    \   \n    minimum = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum = maximum(lst)\
    \ \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum\
    \ = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst)\
    \ \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n \
    \   \n    minimum = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum = maximum(lst)\
    \ \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum\
    \ = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst)\
    \ \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n \
    \   \n    minimum = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = minimum(lst) \nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4xmxbif5.jl:1\nin expression starting at /tmp/tmp4xmxbif5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = min(lst)\n    maximum = max(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a vector of integers\
    \ and returns the same vector in reverse order. \nThe function should work for\
    \ both vectors of integers and vectors of floating point numbers.\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo3pskxia.jl:27\nin expression starting at\
    \ /tmp/tmpo3pskxia.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdlm7wmai.jl:19\nin expression starting at\
    \ /tmp/tmpdlm7wmai.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst) \n    maximum =\
    \ maximum(lst) \n    \n    sorted_list = sort(lst) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_list) \n    \n    sorted_list = reverse(sorted_list)\
    \ \n    \n    sorted_list = sort(sorted_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3j3n4g1q.jl:118\nin expression starting at\
    \ /tmp/tmp3j3n4g1q.jl:118\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst.[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([1, 2, 3, 4])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes a vector of integers and returns the sum of the squares\
    \ of the integers in the vector. \nThe function should work for both vectors of\
    \ integers and vectors of floating point numbers.\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphqpgpy6_.jl:27\nin expression starting at\
    \ /tmp/tmphqpgpy6_.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise\nWrite a function that\
    \ takes a vector of integers and returns the vector in reverse order. \nWrite\
    \ a function that takes a vector of integers and returns the vector in strange\
    \ order. \nWrite a function that takes a vector of integers and returns the vector\
    \ in reverse order and strange order.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnmt8jqxw.jl:19\nin expression starting at\
    \ /tmp/tmpnmt8jqxw.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmd6irgjb.jl:1\nin expression starting at /tmp/tmpmd6irgjb.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nThe answer by is correct, but I thought I'd add my own solution.\
    \ \n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t\
    @test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8,\
    \ 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnjvlmvgz.jl:19\nin expression starting at\
    \ /tmp/tmpnjvlmvgz.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<text>\nExercise 4\nWrite a function that takes a vector\
    \ of integers and returns the sum of the integers in the vector.\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpalfb2dkq.jl:27\nin expression starting at\
    \ /tmp/tmpalfb2dkq.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum = minimum + 1 \n        maximum\
    \ = maximum - 1 \n        lst = sort(lst) \n        lst = lst[minimum:maximum]\
    \ \n        return lst \nend\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a vector of integers and returns the sum of the squares of the integers.\
    \ \nThe function should only take one argument, a list of integers.\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpof4rq9eu.jl:26\nin expression starting at\
    \ /tmp/tmpof4rq9eu.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns the sum of the squares of the integers.\
    \ \nThe function should return an Int64.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbbkm8l5x.jl:19\nin expression starting at\
    \ /tmp/tmpbbkm8l5x.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst) \n    maximum =\
    \ maximum(lst) \n    \n    sorted_list = sort(lst) \n    \n    sorted_list[1]\
    \ = minimum \n    sorted_list[end] = maximum \n    \n    return sorted_list \n\
    end\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector of integers\
    \ and returns the sum of the integers in the vector. \nThe function should raise\
    \ an error if the vector is empty.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxvhpvv83.jl:28\nin expression starting at\
    \ /tmp/tmpxvhpvv83.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    sorted_list\
    \ = copy(lst)\n    sorted_list[1] = max(sorted_list[1:end-1]) \n    sorted_list[end]\
    \ = min(sorted_list[end+1:end+2])\n    return sorted_list\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a vector of integers and returns the same vector\
    \ but with integers sorted from smallest to largest.\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxga7en1g.jl:20\nin expression starting at\
    \ /tmp/tmpxga7en1g.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst .- minimum\n    lst = lst .+ maximum\n\
    \    \n    return lst\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers in the list.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers in the list.\n<|/ c |>\n<| a |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgqukyeg7.jl:28\nin expression starting at\
    \ /tmp/tmpgqukyeg7.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns another vector where each element\
    \ is the sum of the integers in the original vector, but in sorted order.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdatcjx2s.jl:19\nin expression starting at\
    \ /tmp/tmpdatcjx2s.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0\n        return lst\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    lst = lst[minimum:maximum]\n    \n    return\
    \ lst\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a vector of integers\
    \ and returns the sum of the squares of the integers in the vector.\nusing Test\n\
    \n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3,\
    \ 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    \t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp_zf8i91.jl:27\nin expression starting at\
    \ /tmp/tmpp_zf8i91.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| c |>\nThis doesn't seem to work. `sort([5,4,3,2,1])` returns `[1,2,3,4,5]`,\
    \ not `[1,2,3,4,5]`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `sort([5,4,3,2,1])`\
    \ returns `[1,2,3,4,5]`, not `[1,2,3,4,5]`.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work. `sort([5,4,3,2,1])` returns `[1,2,3,4,5]`, not `[1,2,3,4,5]`.\n<|/\
    \ c |>\n<| c |>\nThis doesn't seem to work. `sort([5,4,3,2,1])` returns `[1,2,3,4,5]`,\
    \ not `[1,2,3,4,5]`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `sort([5,4,3,2,1])`\
    \ returns `[1,2,3,4,5]`, not `[1,2,3,4,5]`.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\
    julia> sort([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n\
    <|/ a tags=sorting,julia |>\n<| c |>\nThis doesn't seem to work. `sort([5,4,3,2,1])`\
    \ returns `[1,2,3,4,5]`, not `[1,2,3,4,5]`.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work. `sort([5,4,3,2,1])` returns `[1,2,3,4,5]`, not `[1,2,3,4,5]`.\n<|/\
    \ c |>\n<| c |>\nThis doesn't seem to work. `sort([5,4,3,2,1])` returns `[1,2,3,4,5]`,\
    \ not `[1,2,3,4,5]`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `sort([5,4,3,2,1])`\
    \ returns `[1,2,3,4,5]`, not `[1,2,3,4,5]`.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work. `sort([5,4,3,2,1])` returns `[1,2,3,4,5]`, not `[1,2,3,4,5]`.\n<|/\
    \ c |>\n<| a tags=sorting,julia |>\n<code>\njulia> sort([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n\nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1t7o0ps5.jl:19\nin expression starting at\
    \ /tmp/tmp1t7o0ps5.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the number of times a given\
    \ value appears in a given vector.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1,\
    \ 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    \t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo7fo7zfb.jl:19\nin expression starting at\
    \ /tmp/tmpo7fo7zfb.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.4>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns a vector of integers sorted from\
    \ smallest to largest.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv06ygguv.jl:19\nin expression starting at\
    \ /tmp/tmpv06ygguv.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = min(lst)\n    maximum = max(lst)\n\
    \    \n    minimum_index = findfirst(i->i==minimum, lst, 0)\n    maximum_index\
    \ = findfirst(i->i==maximum, lst, 0)\n    \n    lst[minimum_index], lst[maximum_index]\
    \ = lst[maximum_index], lst[minimum_index]\n    \n    return lst\nend\n</cell>\n\
    <code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector of integers and returns the sum\
    \ of the integers squared. \nThe function should raise an error if the vector\
    \ is empty.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t\
    @test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8,\
    \ 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpptrkt5wn.jl:28\nin expression starting at\
    \ /tmp/tmpptrkt5wn.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdlm7wmai.jl:19\nin expression starting at\
    \ /tmp/tmpdlm7wmai.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't seem to work. `strange_sort_list([5, 5, 5, 5])` returns\
    \ `[5, 5, 5, 5]`.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting\
    \ it. I will post the code I tested it with.\n<|/ c |>\n<| c |>\nI tested it again\
    \ and it works. I must have had a typo when I tested it the first time. Sorry\
    \ about that.\n<|/ c |>\n<| c |>\nI tested it again and it works. I must have\
    \ had a typo when I tested it the first time. Sorry about that.\n<|/ c |>\n<|\
    \ a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3o5nc7nh.jl:19\nin expression starting at\
    \ /tmp/tmp3o5nc7nh.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns the same vector, but with each element\
    \ multiplied by 2.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmtct9i6m.jl:19\nin expression starting at\
    \ /tmp/tmpmtct9i6m.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    \n   \
    \ sorted_list = copy(lst)\n    \n    minimum = min(lst)\n    maximum = max(lst)\n\
    \    \n    minimum_index = findfirst(x -> x == minimum, lst)\n    maximum_index\
    \ = findfirst(x -> x == maximum, lst)\n    \n    if minimum_index == maximum_index\n\
    \        sorted_list[minimum_index] = minimum\n        sorted_list[maximum_index]\
    \ = maximum\n    else\n        \n        minimum_index = minimum_index + 1\n \
    \       maximum_index = maximum_index - 1\n        \n        sorted_list[minimum_index]\
    \ = minimum\n        sorted_list[maximum_index] = maximum\n    end\n    \n   \
    \ return sorted_list\nend\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([1,\
    \ 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5, 5, 5, 5])\n\
    </cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a vector of integers and returns a vector of\
    \ integers in strange order.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkzwbrxkb.jl:38\nin expression starting at\
    \ /tmp/tmpkzwbrxkb.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n\
    <text>\nExercise\nWrite a function that takes a vector of integers and returns\
    \ the same vector, except with each integer replaced by its square root.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjz_7kifj.jl:19\nin expression starting at\
    \ /tmp/tmpjz_7kifj.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    \n    lst = sort(lst)\n    \n    minimum = minimum(lst)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmd6irgjb.jl:1\nin expression starting at /tmp/tmpmd6irgjb.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([1, 2, 3, 4])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([5,\
    \ 5, 5, 5])\n</cell>\n<code language=julia-1.5>\nstrange_sort_list([])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a vector of integers and returns\
    \ its sum.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t\
    @test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8,\
    \ 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcbicd2t9.jl:19\nin expression starting at\
    \ /tmp/tmpcbicd2t9.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    \n    minimum = minimum(lst) \n    maximum =\
    \ maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst)\
    \ \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n \
    \   \n    minimum = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum = maximum(lst)\
    \ \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum\
    \ = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst)\
    \ \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n \
    \   \n    minimum = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum = maximum(lst)\
    \ \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum\
    \ = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst)\
    \ \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n \
    \   \n    minimum = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum = maximum(lst)\
    \ \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst) \n    maximum\
    \ = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum = minimum(lst)\
    \ \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n    \n    minimum\
    \ = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst = sort(lst) \n \
    \   \n    minimum = minimum(lst) \n    maximum = maximum(lst) \n    \n    lst\
    \ = sort(lst) \n    \n    minimum = minimum(lst) \nusing Test\n\n@testset begin\n\
    \ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) == [1, 4, 2,\
    \ 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4xmxbif5.jl:1\nin expression starting at /tmp/tmp4xmxbif5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis is not the most efficient solution, since it sorts the list\
    \ twice. Better would be to reverse the list once and sort it once.\n<|/ c |>\n\
    <| c |>\nYes, you are right. Thanks for pointing it out. I will update my answer.\n\
    <|/ c |>\n<| a tags=julia,sorting |>\nThe answer by is correct, but I thought\
    \ I'd add an alternative that doesn't require any additional packages. \n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpap8_mx8r.jl:19\nin expression starting at\
    \ /tmp/tmpap8_mx8r.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nHere is a solution that uses only built-in functions:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbhgn79jn.jl:19\nin expression starting at\
    \ /tmp/tmpbhgn79jn.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns a vector of integers sorted from\
    \ smallest to largest.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfod1m20z.jl:19\nin expression starting at\
    \ /tmp/tmpfod1m20z.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1, 2, 3, 4]) ==\
    \ [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1,\
    \ 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1,\
    \ 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111]) == [111111])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mz2ods6.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmp3mz2ods6.jl:24\n  Expression: candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3]\n   Evaluated: [4, 3, 2, 1] == [1, 4, 2, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:25\n  Expression: candidate([5, 6, 7, 8, 9]) ==\
    \ [5, 9, 6, 8, 7]\n   Evaluated: [9, 8, 7, 6, 5] == [5, 9, 6, 8, 7]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:26\n  Expression: candidate([1, 2, 3, 4, 5]) ==\
    \ [1, 5, 2, 4, 3]\n   Evaluated: [5, 4, 3, 2, 1] == [1, 5, 2, 4, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:27\n  Expression: candidate([5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7]\n   Evaluated: [9, 8, 7, 6, 5, 1] == [1, 9, 5, 8, 6, 7]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mz2ods6.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mz2ods6.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp3mz2ods6.jl:30\n  Expression: ca"
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a vector of integers and returns another vector in reverse order.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd2vncmp8.jl:19\nin expression starting at\
    \ /tmp/tmpd2vncmp8.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise: Write a function that\
    \ takes a vector of integers and returns a vector of integers in strange order.\n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7bf75uz5.jl:19\nin expression starting at\
    \ /tmp/tmp7bf75uz5.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    if length(lst)\
    \ == 0 \n        return [] \n    else \n        minimum = minimum(lst) \n    \
    \    maximum = maximum(lst) \n        minimum = min(minimum, maximum) \n     \
    \   maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, maximum)\
    \ \n        maximum = max(minimum, maximum) \n        minimum = min(minimum, \n\
    using Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\t@test(candidate([1,\
    \ 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7, 8, 9]) == [5, 9, 6,\
    \ 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\n\t@test(candidate([5,\
    \ 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5, 5, 5, 5]) == [5,\
    \ 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([1,\
    \ 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7_96jvzq.jl:83\nin expression starting at\
    \ /tmp/tmp7_96jvzq.jl:83\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a dscore=2 |>\nThe most efficient way is to use sortperm:\n<code>\njulia>\
    \ sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n\
    <|/ a tags=sorting,julia |>\n<| a dscore=2 |>\nThe most efficient way is to use\
    \ sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia |>\n<| a dscore=1 |>\n\
    The most efficient way is to use sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia\
    \ |>\n<| a tags=sorting,julia |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n\
    \ 3\n 4\n 5\n</code>\n<|/ a tags=sorting,julia |>\n<| a dscore=1 |>\n<code>\n\
    julia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\
    </code>\n<|/ a tags=sorting,julia |>\n<| a |>\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 tags=sorting,julia\
    \ |>\n<| a tags=sorting,julia |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\n\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm1rxsg4z.jl:19\nin expression starting at\
    \ /tmp/tmpm1rxsg4z.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Given vector of integers, return vector in strange order.\n\
    \    Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>>\
    \ strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5,\
    \ 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\
    \"\nfunction strange_sort_list(lst::Vector{Int64})::Vector{Int64} \n    lst =\
    \ sort(lst)\n    lst = reverse(lst)\n    return lst\nend\n</cell>\n<code language=julia-1.5>\n\
    strange_sort_list([5, 5, 5, 5])\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of integers and returns another vector with integers sorted\
    \ from smallest to largest.\nusing Test\n\n@testset begin\n\ncandidate = strange_sort_list;\n\
    \t@test(candidate([1, 2, 3, 4]) == [1, 4, 2, 3])\n\t@test(candidate([5, 6, 7,\
    \ 8, 9]) == [5, 9, 6, 8, 7])\n\t@test(candidate([1, 2, 3, 4, 5]) == [1, 5, 2,\
    \ 4, 3])\n\t@test(candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\t@test(candidate([5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\n\t@test(candidate([0,\
    \ 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\n\t@test(candidate([111111])\
    \ == [111111])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3zeorv7j.jl:19\nin expression starting at\
    \ /tmp/tmp3zeorv7j.jl:19\n"
  stdout: ''
