language: jl
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a vector is a valid permutation of another vector.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4kqbxm2p.jl:32\nin expression starting at\
    \ /tmp/tmp4kqbxm2p.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of strings and returns a vector of booleans indicating whether\
    \ each string is a valid parenthesis string. Valid strings are strings that do\
    \ not contain any parentheses.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0fzo1rgh.jl:32\nin expression starting at\
    \ /tmp/tmp0fzo1rgh.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \")\", \"(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"(\", \")\", \"(\",\
    \ \")\", \"(\", \")\", \"(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \"\
    )\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"\
    (\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \"\
    )\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"\
    (\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \"\
    )\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"\
    (\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \"\
    )\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"\
    (\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \"\
    )\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"\
    (\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \")\", \"(\", \"\
    )\", \"(\", \")\", \"(\", \")\", \"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7j4r0_1w.jl:39\nin expression starting at\
    \ /tmp/tmp7j4r0_1w.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a given string is a valid mathematical expression. For example, the\
    \ string \"(1 + 2)\" is a valid expression, but \"(1 + 2 + 3)\" isn't.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnf2t_im7.jl:32\nin expression starting at\
    \ /tmp/tmpnf2t_im7.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a number is even.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuweps3h4.jl:39\nin expression starting at\
    \ /tmp/tmpuweps3h4.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. You may want to use isPrime() from Base or write your own.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5ijcojme.jl:41\nin expression starting at\
    \ /tmp/tmp5ijcojme.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"(\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"(\", \"(\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()\", \"(\", \"(\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\", \"(\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"(\", \"()\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"(\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"(\", \"()\", \"()\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"(\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"(\", \"()\", \"()\", \"()\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"(\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()\", \"(\", \"()\", \"()\", \"()\", \"\
    ()\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"(\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()\", \"(\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"\
    (\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()\", \"(\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"(\"])\n</cell\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1tthrfut.jl:45\nin expression starting at\
    \ /tmp/tmp1tthrfut.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfto6cjqp.jl:38\nin expression starting at\
    \ /tmp/tmpfto6cjqp.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a given string is a palindrome. Palindromes are strings that read\
    \ the same backward as forward.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpse8ugsl7.jl:32\nin expression starting at\
    \ /tmp/tmpse8ugsl7.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is a valid binary search tree. \nA binary tree is valid\
    \ if every node has at most two children.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmploulku2n.jl:39\nin expression starting at\
    \ /tmp/tmploulku2n.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbm4eyggw.jl:45\nin expression starting at\
    \ /tmp/tmpbm4eyggw.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is a binary search tree (BST).\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpftinp_c9.jl:32\nin expression starting at\
    \ /tmp/tmpftinp_c9.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf8_r8328.jl:40\nin expression starting at\
    \ /tmp/tmpf8_r8328.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack{String}()\n    for s in lst\n        if s == \"(\"\n   \
    \         push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp75or1wto.jl:38\nin expression starting at\
    \ /tmp/tmp75or1wto.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. Your function should take in a number as an argument and return\
    \ a boolean value.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpycx0sxpp.jl:39\nin expression starting at\
    \ /tmp/tmpycx0sxpp.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfto6cjqp.jl:38\nin expression starting at\
    \ /tmp/tmpfto6cjqp.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of strings as input and returns a vector of booleans indicating\
    \ whether each string is a valid parenthesis expression. Valid expressions are\
    \ of the form '(())', where each pair of parentheses has equal number of opening\
    \ and closing parentheses.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbtmg408t.jl:39\nin expression starting at\
    \ /tmp/tmpbtmg408t.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a number is prime. You may want to use the\nfollowing functions: isa(),\
    \ ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <,\
    \ <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=,\
    \ ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <,\
    \ <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=,\
    \ ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <,\
    \ <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=,\
    \ ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <,\
    \ <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=,\
    \ ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <,\
    \ <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <, <=, >, >=, ==, !=, <\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjzoij4rg.jl:32\nin expression starting at\
    \ /tmp/tmpjzoij4rg.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string as input and returns the number of characters in that string.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphpatza5h.jl:40\nin expression starting at\
    \ /tmp/tmphpatza5h.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcnnejopo.jl:45\nin expression starting at\
    \ /tmp/tmpcnnejopo.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzl2umupa.jl:45\nin expression starting at\
    \ /tmp/tmpzl2umupa.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpar9h7gc2.jl:32\nin expression starting at\
    \ /tmp/tmpar9h7gc2.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    stack = push!(stack, \"\")\n    stack =\
    \ push!(stack, \"\")\n    for i in lst\n        if i == \"(\"\n            push!(stack,\
    \ \"\")\n        elseif i == \")\"\n            pop!(stack)\n        else\n  \
    \          push!(stack, i)\n        end\n    end\n    if length(stack) != 0\n\
    \        return \"No\"\n    else\n        return \"Yes\"\n    end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/18574164)\n<|/ c |>\n<| c |>\n\
    This does provide an answer. He asked how to check if a string can be concatenated\
    \ with another string in some order. He also asked how to check if a parenthesis\
    \ string is balanced. He also asked how to check if a string is good. He also\
    \ asked how to check if a string is valid. He also asked how to check if a string\
    \ is valid. He also asked how to check if a string is valid. He also asked how\
    \ to check if a string is valid. He also asked how to check if a string is valid.\
    \ He also asked how to check if a string is valid. He also asked how to check\
    \ if a string is valid. He also asked how to check if a string is valid. He also\
    \ asked how to check if a string is valid. He also asked how to check if a string\
    \ is valid. He also asked how to check if a string is valid. He also asked how\
    \ to check if a string is valid. He also asked how to check if a string is valid.\
    \ He also asked how to check if a string is valid. He also asked how to check\
    \ if a string is valid. He also asked how to check if a string is valid. He also\
    \ asked how to check if a string is valid. He also asked how to check if a string\
    \ is valid. He also asked how to check if a string is valid. He also asked how\
    \ to check if a string is valid. He also asked how to check if a string is valid.\
    \ He also asked how to check if a string is valid. He also asked how to check\
    \ if a string is valid. He also asked how to check if a string is valid. He also\
    \ asked how to check if a string is valid. He also asked how to check if a string\
    \ is valid. He also asked how to check if a string is valid. He also asked how\
    \ to check if a string is valid. H\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8910hxo0.jl:36\nin expression starting at\
    \ /tmp/tmp8910hxo0.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. \nThe function should take in a number as an argument and return\
    \ a boolean.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0dzlsc5r.jl:45\nin expression starting at\
    \ /tmp/tmp0dzlsc5r.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg_6kaafp.jl:35\nin expression starting at\
    \ /tmp/tmpg_6kaafp.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if length(lst) == 0 \n        return \"No\"\n    \n    if length(lst)\
    \ == 1 \n        if lst[1] == \"(\" \n            return \"Yes\"\n        else\
    \ \n            return \"No\"\n    end\n    \n    stack = Vector{String}(lst)\n\
    \    \n    while length(stack) > 0 \n        \n        if stack[length(stack)-1]\
    \ == \"(\" \n            pop!(stack)\n        else \n            push!(stack,\
    \ \")\")\n        end\n        \n        if length(stack) == 0 \n            return\
    \ \"No\"\n        end\n        \n        if stack[length(stack)-1] == \"(\" \n\
    \            push!(stack, \"(\")\n        else \n            push!(stack, \")\"\
    )\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. \nA number is prime if and only if it is a prime number (i.e.\
    \ has no divisors other than 1 and itself).\nA number is not prime if and only\
    \ if it is not a prime number (i.e. has divisors other than 1 and itself).\nA\
    \ number is prime if and only if it is a perfect square (i.e. has no divisors\
    \ other than 1 and itself).\nA number is not prime if and only if it is not a\
    \ perfect square (i.e. has divisors other than 1 and itself).\nA number is prime\
    \ if and only if it is a perfect cube.\nA number is not prime if and only if it\
    \ is not a perfect cube.\nA number is prime if and only if it is a perfect fifth\
    \ power.\nA number is not prime if and only if it is not a perfect fifth power.\n\
    A number is prime if and only if it is a perfect seventh power.\nA number is not\
    \ prime if and only if it is not a perfect seventh power.\nA number is prime if\
    \ and only if it is a perfect third power.\nA number is not prime if and only\
    \ if it is not a perfect third power.\nA number is prime if and only if it is\
    \ a perfect fourth power.\nA number is not prime if and only if it is not a perfect\
    \ fourth power.\nA number is prime if and only if it is a perfect sixth power.\n\
    A number is not prime if and only if it is not a perfect sixth power.\nA number\
    \ is prime if and only if it is a perfect eighth power.\nA number is not prime\
    \ if and only if it is not a perfect eighth power.\nA number is prime if and only\
    \ if it is a perfect n\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplws8_5jx.jl:52\nin expression starting at\
    \ /tmp/tmplws8_5jx.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ and returns a new string where all occurrences of \"(\" have been replaced with\
    \ \"(\" and all occurrences of \")\" have been replaced with \")\".\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb3iavtfp.jl:45\nin expression starting at\
    \ /tmp/tmpb3iavtfp.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</code>\n<|/\
    \ a tags=string,julia,parentheses |>\n<| c |>\nThanks for your answer. Your code\
    \ works perfectly for me. I am still trying to understand how it works. But I\
    \ guess I understand it now. Thanks again.\n<|/ c |>\n<| c |>\nI added some comments\
    \ to my answer, hope it helps.\n<|/ c |>\n<| c |>\nThanks for your comments. I\
    \ understand it now. Thanks again.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0zwtrdlw.jl:32\nin expression starting at\
    \ /tmp/tmp0zwtrdlw.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    \n    for s in lst\n        if s == \"(\"\
    \n            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjmmg6r55.jl:33\nin expression starting at\
    \ /tmp/tmpjmmg6r55.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if length(lst) == 0 \n        return \"No\"\n    \n    if length(lst)\
    \ == 1 \n        if lst[1] == \"(\" \n            return \"Yes\"\n        else\
    \ \n            return \"No\"\n    end\n    \n    stack = Vector{String}(lst)\n\
    \    \n    while length(stack) > 0 \n        if stack[length(stack)-1] == \"(\"\
    \ \n            stack[length(stack)-1] = \")\"\n        else \n            stack[length(stack)-1]\
    \ = \"(\"\n        end\n        \n        if length(stack) == 1 \n           \
    \ if stack[1] == \"(\" \n                return \"Yes\"\n            else \n \
    \               return \"No\"\n        end\n        \n        pop = stack[length(stack)-1]\n\
    \        push = stack[length(stack)-2]\n        \n        if pop == \"(\" \n \
    \           push = \"(\"\n        else \n            push = \")\"\n        end\n\
    \        \n        stack = replace(stack, pop, push)\n    end\n    \n    return\
    \ \"No\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a number is prime. Your function\
    \ should take in a number as an argument and return a boolean.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkjetc7xc.jl:59\nin expression starting at\
    \ /tmp/tmpkjetc7xc.jl:59\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp89dykvdz.jl:39\nin expression starting at\
    \ /tmp/tmp89dykvdz.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is a binary search tree (BST).\nA binary tree is BST\
    \ if each node has a value less than or equal to its \nparent node's value, and\
    \ each node has a value greater than or equal to its \nparent node's value.\n\
    A binary search tree (BST) is a binary tree in which all the nodes have values\
    \ \ngreater than or equal to their parent node's values.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp74f9oad9.jl:39\nin expression starting at\
    \ /tmp/tmp74f9oad9.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpga4xhzsd.jl:45\nin expression starting at\
    \ /tmp/tmpga4xhzsd.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1pf2gtag.jl:39\nin expression starting at\
    \ /tmp/tmp1pf2gtag.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. You may assume that the number is not negative.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplypx1gpj.jl:39\nin expression starting at\
    \ /tmp/tmplypx1gpj.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    stack = push!(stack, \"\")\n    stack =\
    \ push!(stack, \"\")\n    for s in lst\n        if s == \"(\"\n            push!(stack,\
    \ s)\n        elseif s == \")\"\n            if length(stack) == 0\n         \
    \       return \"No\"\n            else\n                pop!(stack)\n       \
    \     end\n        else\n            if length(stack) == 0\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ as input and returns a string with all the characters in lower case. \nThe function\
    \ should ignore all non-alphabetic characters and replace them with spaces.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpztx2cdtq.jl:40\nin expression starting at\
    \ /tmp/tmpztx2cdtq.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    stack.append(lst[1])\n    \n    for i in lst[2:end]\n\
    \        if i == \"(\"\n            stack.append(i)\n        elseif i == \")\"\
    \n            if stack.length() == 0\n                return \"No\"\n        \
    \    else\n                stack.pop()\n            end\n        else\n      \
    \      if stack.length() > 0\n                stack.pop()\n            end\n \
    \       end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. You may assume that the number is not negative.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9w1kk3w8.jl:39\nin expression starting at\
    \ /tmp/tmp9w1kk3w8.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnw7gxzi5.jl:45\nin expression starting at\
    \ /tmp/tmpnw7gxzi5.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    stack = push!(stack, \"\")\n    stack =\
    \ push!(stack, \"\")\n    for s in lst\n        if s == \")\"\n            stack\
    \ = pop!(stack)\n        elseif s == \"(\"\n            stack = push!(stack, \"\
    \")\n        else\n            stack = push!(stack, s)\n        end\n    end\n\
    \    if stack[1] != \"\"\n        return \"No\"\n    else\n        return \"Yes\"\
    \n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    )\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpucooa4ir.jl:36\nin expression starting at\
    \ /tmp/tmpucooa4ir.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn1rv1qyz.jl:32\nin expression starting at\
    \ /tmp/tmpn1rv1qyz.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    stack.append(lst[1])\n    \n    for i in lst[2:end]\n\
    \        if i == \"(\"\n            stack.append(i)\n        elseif i == \")\"\
    \n            if stack.pop() == \"(\"\n                return \"Yes\"\n      \
    \      else\n                return \"No\"\n        end\n    end\n    return \"\
    No\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that checks if a number is even.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6ntd0ml5.jl:34\nin expression starting at\
    \ /tmp/tmp6ntd0ml5.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg397ajvs.jl:39\nin expression starting at\
    \ /tmp/tmpg397ajvs.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a given string is a valid phone number.\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd4y0ftsz.jl:39\nin expression starting at\
    \ /tmp/tmpd4y0ftsz.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmykzldy4.jl:32\nin expression starting at\
    \ /tmp/tmpmykzldy4.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.3>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.3>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a string as input and returns a string with all the uppercase letters\
    \ replaced by lowercase letters.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpopa01bf1.jl:32\nin expression starting at\
    \ /tmp/tmpopa01bf1.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeifo1duf.jl:45\nin expression starting at\
    \ /tmp/tmpeifo1duf.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if length(lst) == 0 \n        return \"No\"\n    \n    stack = Stack()\n\
    \    \n    for x in lst\n        if x == \"(\" \n            push!(stack, x)\n\
    \        else if x == \")\" \n            if isempty(stack)\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"\
    ])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary tree\
    \ is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7i_77vyo.jl:27\nin expression starting at\
    \ /tmp/tmp7i_77vyo.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string\
    \ as input and returns the number of parentheses in it.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqqt_zn73.jl:45\nin expression starting at\
    \ /tmp/tmpqqt_zn73.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg397ajvs.jl:39\nin expression starting at\
    \ /tmp/tmpg397ajvs.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    stack.append(lst[1])\n    \n    for i in lst[2:end]\n\
    \        if i == \"(\"\n            stack.append(i)\n        elseif i == \")\"\
    \n            if stack.pop() == \"(\"\n                return \"Yes\"\n      \
    \      else\n                return \"No\"\n        end\n    end\n    return \"\
    No\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a vector of strings as an argument and\
    \ returns a vector of the lengths of the strings in the vector. For example: \n\
    [\"a\", \"b\", \"c\"] -> [3, 3]\n[\"a\", \"b\", \"c\", \"d\"] -> [4, 3, 2]\n[\"\
    a\", \"b\", \"c\", \"d\", \"e\"] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\"] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\"] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    ] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"\
    i\"] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\"] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\"] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"] -> [4, 3, 2, 1]\n[\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\"] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    , \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"] -> [4, 3, 2, 1]\n[\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\"] -> [4, 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"] -> [4,\
    \ 3, 2, 1]\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"] -> [4, 3, 2, 1]\n[\"a\"\
    , \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwo89swr4.jl:34\nin expression starting at\
    \ /tmp/tmpwo89swr4.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. You may use the\nfollowing formula to determine whether a number\
    \ is prime or not:\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqwsonfa8.jl:45\nin expression starting at\
    \ /tmp/tmpqwsonfa8.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg397ajvs.jl:39\nin expression starting at\
    \ /tmp/tmpg397ajvs.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if lst.size == 0\n        return \"No\"\n    \n    if lst.size ==\
    \ 1\n        if lst[0] == \"()\"\n            return \"Yes\"\n        else\n \
    \           return \"No\"\n    end\n    \n    stack = Vector{String}(\"\")\n \
    \   \n    for x in lst\n        if x == \"(\"\n            push!(stack, x)\n \
    \       else\n            if stack[end] == \")\"\n                stack[end] =\
    \ x\n            else\n                stack[end] = stack[end] + x\n         \
    \   end\n        end\n    end\n    \n    if stack[end] == \")\"\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp01e4b04k.jl:49\nin expression starting at\
    \ /tmp/tmp01e4b04k.jl:49\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr6sey49w.jl:41\nin expression starting at\
    \ /tmp/tmpr6sey49w.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise: Write a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppvu50oig.jl:39\nin expression starting at\
    \ /tmp/tmppvu50oig.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a vector is a permutation of another vector.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp470oo6wu.jl:39\nin expression starting at\
    \ /tmp/tmp470oo6wu.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime (a number is a prime if and only if it has only\
    \ two factors: 1 and itself).\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdwbs3k5u.jl:39\nin expression starting at\
    \ /tmp/tmpdwbs3k5u.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string as input and returns a string with all the letters capitalized.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgmip94li.jl:39\nin expression starting at\
    \ /tmp/tmpgmip94li.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime or not. You may use the\nfollowing algorithm:\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1ov9atoa.jl:32\nin expression starting at\
    \ /tmp/tmp1ov9atoa.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a vector is a valid permutation of another vector.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqpkwk62o.jl:39\nin expression starting at\
    \ /tmp/tmpqpkwk62o.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a given string is a valid phone number.\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr49yje56.jl:41\nin expression starting at\
    \ /tmp/tmpr49yje56.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string as input and returns the number of parentheses in it.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph_8y3srs.jl:41\nin expression starting at\
    \ /tmp/tmph_8y3srs.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. You may use the\nfollowing definition of a prime number:\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmfii72u0.jl:38\nin expression starting at\
    \ /tmp/tmpmfii72u0.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    stack.append(lst)\n    \n    while !isempty(stack)\n\
    \        \n        str = pop!(stack)\n        \n        if str == \"()\"\n   \
    \         return \"Yes\"\n        elseif str == \")\"\n            return \"No\"\
    \n        else\n            push!(stack, str)\n        end\n    end\n    \n  \
    \  return \"No\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that checks if a binary tree is\
    \ balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp90d5ypo8.jl:37\nin expression starting at\
    \ /tmp/tmp90d5ypo8.jl:37\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. \nA prime number is a natural number greater than\
    \ 1 that has no positive divisors other than 1 and itself.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptw7uil2e.jl:33\nin expression starting at\
    \ /tmp/tmptw7uil2e.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime (a number is a prime if and only if it has only two factors: 1 and\
    \ itself). A number is prime if and only if it has only two factors: 1 and itself.\
    \ For example, 5 is prime because 5=2*2, and 2 is not a prime number.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp24nhofkd.jl:45\nin expression starting at\
    \ /tmp/tmp24nhofkd.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ as input and returns a string with all the letters in lower case. \nThe string\
    \ can contain any characters, including spaces.\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9vkcnq8l.jl:39\nin expression starting at\
    \ /tmp/tmp9vkcnq8l.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime or not. You may use the\nfollowing algorithm:\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc20i87vd.jl:39\nin expression starting at\
    \ /tmp/tmpc20i87vd.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    stack = push!(stack, \"\")\n    stack =\
    \ push!(stack, \"\")\n    \n    for i in lst\n        if i == \"(\"\n        \
    \    push!(stack, i)\n        elseif i == \")\"\n            pop!(stack)\n   \
    \         pop!(stack)\n        else\n            push!(stack, i)\n        end\n\
    \    end\n    \n    if length(stack) == length(lst)\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprzvqirw7.jl:39\nin expression starting at\
    \ /tmp/tmprzvqirw7.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    )\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9aqpyx8r.jl:40\nin expression starting at\
    \ /tmp/tmp9aqpyx8r.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for x in lst\n        if x == '('\n \
    \           push!(stack, x)\n        elseif x == ')'\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz2b3itjq.jl:39\nin expression starting at\
    \ /tmp/tmpz2b3itjq.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptooab9c4.jl:32\nin expression starting at\
    \ /tmp/tmptooab9c4.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsmzz3rr3.jl:45\nin expression starting at\
    \ /tmp/tmpsmzz3rr3.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_bwjclje.jl:45\nin expression starting at\
    \ /tmp/tmp_bwjclje.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmykzldy4.jl:32\nin expression starting at\
    \ /tmp/tmpmykzldy4.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    return \"\
    Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that checks if a binary tree is balanced.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph2xvp8rw.jl:35\nin expression starting at\
    \ /tmp/tmph2xvp8rw.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. You may use any number theoretic function here.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4rkztmk9.jl:40\nin expression starting at\
    \ /tmp/tmp4rkztmk9.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoq338ezu.jl:39\nin expression starting at\
    \ /tmp/tmpoq338ezu.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a given string is a palindrome or not.\nA palindrome is a string that\
    \ reads the same backward as forward.\nFor example, the string \"racecar\" is\
    \ a palindrome.\nWrite a function that checks if a given string is a palindrome\
    \ or not.\nA palindrome is a string that reads the same backward as forward.\n\
    For example, the string \"racecar\" is a palindrome.\nWrite a function that checks\
    \ if a given string is a palindrome or not.\nA palindrome is a string that reads\
    \ the same backward as forward.\nFor example, the string \"racecar\" is a palindrome.\n\
    Write a function that checks if a given string is a palindrome or not.\nA palindrome\
    \ is a string that reads the same backward as forward.\nFor example, the string\
    \ \"racecar\" is a palindrome.\nWrite a function that checks if a given string\
    \ is a palindrome or not.\nA palindrome is a string that reads the same backward\
    \ as forward.\nFor example, the string \"racecar\" is a palindrome.\nWrite a function\
    \ that checks if a given string is a palindrome or not.\nA palindrome is a string\
    \ that reads the same backward as forward.\nFor example, the string \"racecar\"\
    \ is a palindrome.\nWrite a function that checks if a given string is a palindrome\
    \ or not.\nA palindrome is a string that reads the same backward as forward.\n\
    For example, the string \"racecar\" is a palindrome.\nWrite a function that checks\
    \ if a given string is a palindrome or not.\nA palindrome is a string that reads\
    \ the same backward as forward.\nFor example, the string \"racecar\" is a palindrome.\n\
    Write a function that checks if a given string is a palindrome or not.\nA palindrome\
    \ is a string that reads the same backward as forward.\nFor example\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzo502ok8.jl:41\nin expression starting at\
    \ /tmp/tmpzo502ok8.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    stack.append(lst[1])\n    \n    for elem in\
    \ lst[2:end]\n        if elem == \"(\"\n            stack.append(elem)\n     \
    \   elseif elem == \")\"\n            if stack.pop() != elem\n               \
    \ return \"No\"\n            else\n                stack.pop()\n        end\n\
    \    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"(\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"(\", \"(\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc5zin5bp.jl:34\nin expression starting at\
    \ /tmp/tmpc5zin5bp.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmykzldy4.jl:32\nin expression starting at\
    \ /tmp/tmpmykzldy4.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    stack.append(lst[1])\n    \n    for i in lst[2:end]\n\
    \        if i == \"(\"\n            stack.append(i)\n        elseif i == \")\"\
    \n            if stack.size == 0\n                return \"No\"\n            else\n\
    \                stack.pop()\n            end\n        end\n    end\n    return\
    \ \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \"\
    )\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqthrkimm.jl:35\nin expression starting at\
    \ /tmp/tmpqthrkimm.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime or not. You may want to use\nthe isqrt function\
    \ from the Base package.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7lb4ez3s.jl:32\nin expression starting at\
    \ /tmp/tmp7lb4ez3s.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nPart 2\nWrite a function that checks\
    \ if a binary tree is a binary search tree.\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk89eiwzl.jl:35\nin expression starting at\
    \ /tmp/tmpk89eiwzl.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    stack.append(\"\")\n    for s in lst\n        if\
    \ s == \"(\"\n            stack.append(s)\n        elseif s == \")\"\n       \
    \     if stack.pop() == \"(\"\n                return \"Yes\"\n            else\n\
    \                return \"No\"\n        else\n            stack.append(s)\n  \
    \  end\n    return \"No\"\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpicmjst5z.jl:24 expected \"\
    end\", got \"else\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpicmjst5z.jl:28\n\
    in expression starting at /tmp/tmpicmjst5z.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime. \nA prime number is a natural number greater than 1 that has no positive\
    \ divisors other than 1 and itself. \nA prime number is a number that has exactly\
    \ two positive divisors: 1 and itself. \nA prime number is a number that has exactly\
    \ three positive divisors: 1, 2 and 3. \nA prime number is a number that has exactly\
    \ four positive divisors: 1, 2, 3 and 4.\nA prime number is a number that has\
    \ exactly five positive divisors: 1, 2, 3, 4 and\n5.\nA prime number is a number\
    \ that has exactly six positive divisors: 1, 2, 3, 4, 5 and 6.\nA prime number\
    \ is a number that has exactly seven positive divisors: 1, 2, 3, 4, 5, 6 and 7.\n\
    A prime number is a number that has exactly eight positive divisors: 1, 2, 3,\
    \ 4, 5, 6, 7 and 8.\nA prime number is a number that has exactly nine positive\
    \ divisors: 1, 2, 3, 4, 5, 6, 7, 8 and 9.\nA prime number is a number that has\
    \ exactly ten positive divisors: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 and 11.\nA prime\
    \ number is a number that has exactly eleven positive divisors: 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11 and 12.\nA prime number is a number that has exactly twelve\
    \ positive divisors: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 and 13.\nA prime number\
    \ is a number that has exactly thirteen positive divisors: 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12 and 13 and 14.\nA prime number is a number that has exactly\
    \ fourteen positive divisors: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 and 13 and\
    \ 14 and 15.\nA prime number is a number that has exactly fifteen positive divisors:\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 and 13 and 14 and 15 and 16.\nA prime\
    \ number is a number that has exactly sixteen positive divisors: 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12 and 13 and 14\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9qspv5ag.jl:45\nin expression starting at\
    \ /tmp/tmp9qspv5ag.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.0>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that checks if a binary tree is balanced.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5251_i2c.jl:32\nin expression starting at\
    \ /tmp/tmp5251_i2c.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. \nA prime number is a natural number greater than\
    \ 1 that has no positive divisors other than 1 and itself.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_gi8n7nz.jl:32\nin expression starting at\
    \ /tmp/tmp_gi8n7nz.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    stack = push!(stack, \"\")\n    for i in\
    \ lst\n        if i == \"(\"\n            push!(stack, \"\")\n        elseif i\
    \ == \")\"\n            if isempty(pop!(stack))\n                return \"No\"\
    \n            else\n                push!(stack, \"\")\n            end\n    \
    \    else\n            push!(stack, i)\n        end\n    end\n    return \"Yes\"\
    \nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that checks if a number is prime. Your function should take\
    \ in a number as an argument and return a boolean indicating whether the number\
    \ is prime or not.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph0i1njg1.jl:35\nin expression starting at\
    \ /tmp/tmph0i1njg1.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    stack.append(lst)\n    \n    while !isempty(stack)\n\
    \        str = pop!(stack)\n        if str == \"(\"\n            push!(stack,\
    \ str)\n        elseif str == \")\"\n            if isempty(stack)\n         \
    \       return \"No\"\n            else\n                pop!(stack)\n       \
    \     end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqn1y5tqi.jl:35\nin expression starting at\
    \ /tmp/tmpqn1y5tqi.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpga4xhzsd.jl:45\nin expression starting at\
    \ /tmp/tmpga4xhzsd.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that checks if a binary tree is balanced.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi_qergh5.jl:32\nin expression starting at\
    \ /tmp/tmpi_qergh5.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ and returns a new string where all occurrences of '(' and ')' have been replaced\
    \ by '-'.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyhjh2l7f.jl:40\nin expression starting at\
    \ /tmp/tmpyhjh2l7f.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a number is prime. \nA prime number is a natural number greater than\
    \ 1 that has no positive divisors other than 1 and itself.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq6bbyrcp.jl:32\nin expression starting at\
    \ /tmp/tmpq6bbyrcp.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector\
    \ of strings and returns a vector of strings where each string is the concatenation\
    \ of all the strings in the original vector except the one that comes before the\
    \ one that comes after the other string. For example, if the input vector is [\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"], then the output vector should\
    \ be [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\"].\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz5k4ndlk.jl:45\nin expression starting at\
    \ /tmp/tmpz5k4ndlk.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv1fh1gkn.jl:38\nin expression starting at\
    \ /tmp/tmpv1fh1gkn.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.4>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.4>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4thjl5pl.jl:32\nin expression starting at\
    \ /tmp/tmp4thjl5pl.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    stack = push!(stack, \"\")\n    stack =\
    \ push!(stack, \"\")\n    for s in lst\n        if s == \"(\"\n            push!(stack,\
    \ s)\n        elseif s == \")\"\n            if isempty(stack)\n             \
    \   return \"No\"\n            else\n                pop!(stack)\n           \
    \ end\n        else\n            if isempty(stack)\n                return \"\
    No\"\n            else\n                pop!(stack)\n            end\n       \
    \ end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjtw0j1lw.jl:40\nin expression starting at\
    \ /tmp/tmpjtw0j1lw.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. You may use the following formula to check if a\
    \ number is prime:\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbc0n17vq.jl:32\nin expression starting at\
    \ /tmp/tmpbc0n17vq.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime or not. You may use the\nfollowing algorithm:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjcm77ara.jl:39\nin expression starting at\
    \ /tmp/tmpjcm77ara.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnxsdj5xs.jl:45\nin expression starting at\
    \ /tmp/tmpnxsdj5xs.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptooab9c4.jl:32\nin expression starting at\
    \ /tmp/tmptooab9c4.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ as input and returns the number of parentheses in the string.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsvo6xsdv.jl:45\nin expression starting at\
    \ /tmp/tmpsvo6xsdv.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if length(lst) == 0 \n        return \"No\"\n    \n    if length(lst)\
    \ == 1 \n        if lst[1] == \"(\" \n            return \"Yes\"\n        elseif\
    \ lst[1] == \")\" \n            return \"No\"\n        else \n            return\
    \ \"No\"\n    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7axmkgpn.jl:1\nin expression starting at /tmp/tmp7axmkgpn.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnxsdj5xs.jl:45\nin expression starting at\
    \ /tmp/tmpnxsdj5xs.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. You may want to use the\nSieve of Eratosthenes\
    \ algorithm to find primes. You may want to look at\nthis post for a detailed\
    \ explanation.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptqf6p9bu.jl:32\nin expression starting at\
    \ /tmp/tmptqf6p9bu.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if lst.length == 0 \n        return \"No\"\n    \n    if lst.length\
    \ == 1 \n        if lst[0] == \"()\" \n            return \"Yes\"\n        else\
    \ \n            return \"No\"\n    end1 = lst[end-1]\n    if end1 == \"()\" \n\
    \        return \"Yes\"\n    end2 = lst[end-2]\n    if end2 == \"()\" \n     \
    \   return \"Yes\"\n    end3 = lst[end-3]\n    if end3 == \"()\" \n        return\
    \ \"Yes\"\n    end4 = lst[end-4]\n    if end4 == \"()\" \n        return \"Yes\"\
    \n    end5 = lst[end-5]\n    if end5 == \"()\" \n        return \"Yes\"\n    end6\
    \ = lst[end-6]\n    if end6 == \"()\" \n        return \"Yes\"\n    end7 = lst[end-7]\n\
    \    if end7 == \"()\" \n        return \"Yes\"\n    end8 = lst[end-8]\n    if\
    \ end8 == \"()\" \n        return \"Yes\"\n    end9 = lst[end-9]\n    if end9\
    \ == \"()\" \n        return \"Yes\"\n    end10 = lst[end-10]\n    if end10 ==\
    \ \"()\" \n        return \"Yes\"\n    end11 = lst[end-11]\n    if end11 == \"\
    ()\" \n        return \"Yes\"\n    end12 = lst[end-12]\n    if end12 == \"()\"\
    \ \n        return \"Yes\"\n    end13 = lst[end-13]\n    if end13 == \"()\" \n\
    \        return \"Yes\"\n    end14 = lst[end-14]\n    if end14 == \"()\" \n  \
    \      return \"Yes\"\n    end15 = lst[end-15]\n    if end15 == \"()\" \n    \
    \    return \"Yes\"\n    end16 = lst[end-16]\n    if end16 == \"()\" \n      \
    \  return \"Yes\"\n    end17 = lst[end-17]\n    if end17 == \"()\" \n        return\
    \ \"Yes\"\n    end18 = lst[end-18]\n    if end18 == \"()\" \n        return \"\
    Yes\"\n    end19 = lst[end-19]\n    if end19 == \"()\" \n        return \"Yes\"\
    \n    end20 = lst[end-20]\n    if end20 == \"()\" \n        return \"Yes\"\n \
    \   end21 = lst[end-21]\n    if end21 == \"()\" \n        return \"Yes\"\n   \
    \ end22 = lst[end-22]\n    if end22 == \"()\" \n        return \"Yes\"\n    end23\
    \ = lst[end-23]\n    if end23 == \"()\" \n        return \"Yes\"\n    end24 =\
    \ lst[end-24]\n    if end24 == \"()\" \n        return \"Yes\"\n    end25 = lst[end-25]\n\
    \nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuek5b7av.jl:1\nin expression starting at /tmp/tmpuek5b7av.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a vector of strings and returns a vector of strings. Each string in the\
    \ input vector is concatenated with each string in the output vector, except for\
    \ the last string in the output vector. For example, the input vector [\"a\",\
    \ \"b\", \"c\"] should produce the output vector [\"aa\", \"bb\", \"cc\"].\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplt6uat01.jl:32\nin expression starting at\
    \ /tmp/tmplt6uat01.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime or not. You may want to use the\nfollowing formula\
    \ to check whether a number is prime:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpna45t2wk.jl:32\nin expression starting at\
    \ /tmp/tmpna45t2wk.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if length(lst) == 0 \n        return \"No\"\n    \n    if length(lst)\
    \ == 1 \n        if lst[0] == \"()\" \n            return \"Yes\"\n        else\
    \ \n            return \"No\"\n    end\n    \n    if lst[1] == \"()\" \n     \
    \   if match_parens(lst[2:end-1]) \n            return \"Yes\"\n        else \n\
    \            return \"No\"\n    end\n    \n    if lst[2] == \"()\" \n        if\
    \ match_parens(lst[1:end-2]) \n            return \"Yes\"\n        else \n   \
    \         return \"No\"\n    end\n    \n    if lst[1] == \"()\" and lst[2] ==\
    \ \"()\" \n        if match_parens(lst[3:end]) \n            return \"Yes\"\n\
    \        else \n            return \"No\"\n    end\n    \n    if lst[1] == \"\
    ()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-1]) \n         \
    \   return \"Yes\"\n        else \n            return \"No\"\n    end\n    \n\
    \    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-2])\
    \ \n            return \"Yes\"\n        else \n            return \"No\"\n   \
    \ end\n    \n    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-3])\n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-4])\n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-5])\n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-6])\n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-7])\n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-8])\n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-9])\n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"()\" and lst[2] == \"()\" \n        if match_parens(lst[3:end-10])\n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"lst\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp95o78wtb.jl:43\nin expression starting at /tmp/tmp95o78wtb.jl:43\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv1fh1gkn.jl:38\nin expression starting at\
    \ /tmp/tmpv1fh1gkn.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime. Your function should take in a single number as an argument and return\
    \ a boolean value.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkj0okge2.jl:39\nin expression starting at\
    \ /tmp/tmpkj0okge2.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpga4xhzsd.jl:45\nin expression starting at\
    \ /tmp/tmpga4xhzsd.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    stack = push!(stack, \"\")\n    for s in\
    \ lst\n        if s == \"(\"\n            push!(stack, s)\n        elseif s ==\
    \ \")\"\n            if isempty(stack)\n                return \"No\"\n      \
    \      else\n                pop!(stack)\n            end\n        end\n    end\n\
    \    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"\
    ])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a given string\
    \ is a valid phone number.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxf301qoh.jl:33\nin expression starting at\
    \ /tmp/tmpxf301qoh.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnxsdj5xs.jl:45\nin expression starting at\
    \ /tmp/tmpnxsdj5xs.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack{String}()\n    for s in lst\n        if s == \"(\"\n   \
    \         push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.0>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.0>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4go4fzau.jl:38\nin expression starting at\
    \ /tmp/tmp4go4fzau.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.4>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.4>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4thjl5pl.jl:32\nin expression starting at\
    \ /tmp/tmp4thjl5pl.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime or not. \nThe function should take one argument, an integer number.\
    \ \nThe function should return 'Yes' if number is prime and 'No' otherwise.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph5bj1q9c.jl:39\nin expression starting at\
    \ /tmp/tmph5bj1q9c.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if lst.size == 0\n        return \"No\"\n    \n    if lst.size ==\
    \ 1\n        if lst[0] == \"()\"\n            return \"Yes\"\n        else\n \
    \           return \"No\"\n    end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptv2wbz3s.jl:1\nin expression starting at /tmp/tmptv2wbz3s.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a given string is a valid mathematical expression. \nA valid mathematical\
    \ expression is one that does not contain any unbalanced parentheses.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0_7b367t.jl:32\nin expression starting at\
    \ /tmp/tmp0_7b367t.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. \nA prime number is a natural number greater than\
    \ 1 that has no positive divisors other than 1 and itself.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp23cl_lfj.jl:32\nin expression starting at\
    \ /tmp/tmp23cl_lfj.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    stack.append(lst[1])\n    for i in lst[2:end]\n \
    \       if i == \"(\"\n            stack.append(i)\n        elseif i == \")\"\n\
    \            if stack.pop() != i\n                return \"No\"\n            else\n\
    \                return \"Yes\"\n        end\n    end\n    return \"No\"\nend\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that checks if a number is prime or not. \nThe function\
    \ should take in a number as an argument and return a boolean value.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw8yrwf8r.jl:32\nin expression starting at\
    \ /tmp/tmpw8yrwf8r.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. \nA number is prime if and only if it has only two factors:\
    \ 1 and itself. \nA number is not prime if and only if it has more than two factors.\
    \ \nA number is not prime if and only if it has any factor other than 1 or itself.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl2w90bkg.jl:38\nin expression starting at\
    \ /tmp/tmpl2w90bkg.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf8_r8328.jl:40\nin expression starting at\
    \ /tmp/tmpf8_r8328.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime. Your function should take one argument, an integer $n$, and return\
    \ 'Yes' if $n$ is prime, and 'No' otherwise.\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc3m4dl7q.jl:39\nin expression starting at\
    \ /tmp/tmpc3m4dl7q.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr6sey49w.jl:41\nin expression starting at\
    \ /tmp/tmpr6sey49w.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptzzwy0a9.jl:39\nin expression starting at\
    \ /tmp/tmptzzwy0a9.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime. \nA prime number is a natural number greater than 1 that has no positive\
    \ divisors other than 1 and itself. \nA prime number is not divisible by any other\
    \ number.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5dulx00_.jl:38\nin expression starting at\
    \ /tmp/tmp5dulx00_.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt54osvaj.jl:45\nin expression starting at\
    \ /tmp/tmpt54osvaj.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.4>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.4>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.4>\nmatch_parens([\"\
    ()(\", \")\", \"()\"])\n</cell>\n<code language=julia-1.4>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.4>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.4>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.4>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\"])\n</cell>\n<code language=julia-1.4>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprkbjfss0.jl:32\nin expression starting at\
    \ /tmp/tmprkbjfss0.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if length(lst) == 0 \n        return \"No\"\n    end\n    \n   \
    \ if length(lst) == 1 \n        if lst[1] == \"(\" \n            return \"Yes\"\
    \n        elseif lst[1] == \")\" \n            return \"No\"\n        else\n \
    \           return \"No\"\n        end\n    end\n    \n    if lst[1] == \"(\"\
    \ \n        if match_parens(lst[2:end-1]) == \"Yes\" \n            return \"Yes\"\
    \n        elseif match_parens(lst[2:end-1]) == \"No\" \n            return \"\
    No\"\n        else\n            return \"No\"\n        end\n    elseif lst[1]\
    \ == \")\" \n        if match_parens(lst[2:end-1]) == \"Yes\" \n            return\
    \ \"Yes\"\n        elseif match_parens(lst[2:end-1]) == \"No\" \n            return\
    \ \"No\"\n        else\n            return \"No\"\n        end\n    else\n   \
    \     return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\",\
    \ \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\",\
    \ \"()\", \"()\", \"()\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzjqtlif4.jl:53\nin expression starting at\
    \ /tmp/tmpzjqtlif4.jl:53\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. Your function should take one integer argument\
    \ and return a boolean.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqpiq63ly.jl:32\nin expression starting at\
    \ /tmp/tmpqpiq63ly.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6dp32ct_.jl:38\nin expression starting at\
    \ /tmp/tmp6dp32ct_.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. Your function should take in a number as an argument\
    \ and return a boolean indicating whether the number is prime or not. \nThe number\
    \ should be an integer greater than or equal to 1.\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpii1vfvex.jl:33\nin expression starting at\
    \ /tmp/tmpii1vfvex.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg397ajvs.jl:39\nin expression starting at\
    \ /tmp/tmpg397ajvs.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is a binary search tree. Assume that each node has a left and a right child,\
    \ and that each node also has a value and a parent pointer.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfhrlhtqa.jl:41\nin expression starting at\
    \ /tmp/tmpfhrlhtqa.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime. \nA number is prime if and only if it is a whole\
    \ number and has no divisors other than 1 and itself.\nThe function should take\
    \ one argument, an integer number.\nThe function should return 'Yes' if a number\
    \ is prime, and 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpru0ce1cm.jl:33\nin expression starting at\
    \ /tmp/tmpru0ce1cm.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if length(lst) == 0 \n        return \"No\"\n    \n    if length(lst)\
    \ == 1 \n        if lst[1] == \"(\" \n            return \"Yes\"\n        else\
    \ \n            return \"No\"\n    end\n    \n    if lst[1] == \"(\" \n      \
    \  if match_parens(lst[2:end-1]) \n            return \"Yes\"\n        else \n\
    \            return \"No\"\n    end\n    \n    if lst[1] == \")\" \n        if\
    \ match_parens(lst[2:end-1]) \n            return \"Yes\"\n        else \n   \
    \         return \"No\"\n    end\n    \n    if lst[1] == \"(\" \n        if match_parens(lst[2:end-1])\
    \ \n            return \"Yes\"\n        else \n            return \"No\"\n   \
    \ end\n    \n    if lst[1] == \")\" \n        if match_parens(lst[2:end-1]) \n\
    \            return \"Yes\"\n        else \n            return \"No\"\n    end\n\
    \    \n    if lst[1] == \"(\" \n        if match_parens(lst[2:end-1]) \n     \
    \       return \"Yes\"\n        else \n            return \"No\"\n    end\n  \
    \  \n    if lst[1] == \")\" \n        if match_parens(lst[2:end-1]) \n       \
    \     return \"Yes\"\n        else \n            return \"No\"\n    end\n    \n\
    \    if lst[1] == \"(\" \n        if match_parens(lst[2:end-1]) \n           \
    \ return \"Yes\"\n        else \n            return \"No\"\n    end\n    \n  \
    \  if lst[1] == \")\" \n        if match_parens(lst[2:end-1]) \n            return\
    \ \"Yes\"\n        else \n            return \"No\"\n    end\n    \n    if lst[1]\
    \ == \"(\" \n        if match_parens(lst[2:end-1]) \n            return \"Yes\"\
    \n        else \n            return \"No\"\n    end\n    \n    if lst[1] == \"\
    )\" \n        if match_parens(lst[2:end-1]) \n            return \"Yes\"\n   \
    \     else \n            return \"No\"\n    end\n    \n    if lst[1] == \"(\"\
    \ \n        if match_parens(lst[2:end-1]) \n            return \"Yes\"\n     \
    \   else \n            return \"No\"\n    end\n    \n    if lst[1] == \")\" \n\
    \        if match_parens(lst[2:end-1]) \n            return \"Yes\"\n        else\
    \ \n            return \"No\"\n    end\n    \n    if lst[1] == \"(\" \n      \
    \  if match_parens(lst[2:end-1]) \n            return \"Yes\"\n        else \n\
    \            return \"No\"\n    end\n    \n    if lst[1] == \")\" \n        if\
    \ match_parens(lst[2:end-1]) \n            return \"Yes\"\n        else \n   \
    \         return \"No\"\n    end\n    \n    if lst[1] == \"(\" \n        if match_parens(lst[2:end-1])\
    \ \n            return \"Yes\"\n        else \n            return \"No\"\n   \
    \ end\n    \n    if lst[1] == \")\" \n        if match_parens(lst[2:end\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpks03ppdw.jl:1\nin expression starting at /tmp/tmpks03ppdw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv1fh1gkn.jl:38\nin expression starting at\
    \ /tmp/tmpv1fh1gkn.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ as input and returns a string that has all its parentheses balanced.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxfnivvfw.jl:45\nin expression starting at\
    \ /tmp/tmpxfnivvfw.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\
    (\", \"(\", \"(\", \"(\", \"(\", \"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsa4d1g_q.jl:38\nin expression starting at\
    \ /tmp/tmpsa4d1g_q.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of strings and returns a vector of booleans indicating whether\
    \ each string is a valid parenthesis expression. Valid expressions are those that\
    \ contain balanced parentheses.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvl684rf2.jl:39\nin expression starting at\
    \ /tmp/tmpvl684rf2.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg_6kaafp.jl:35\nin expression starting at\
    \ /tmp/tmpg_6kaafp.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnxsdj5xs.jl:45\nin expression starting at\
    \ /tmp/tmpnxsdj5xs.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvgf9_on_.jl:41\nin expression starting at\
    \ /tmp/tmpvgf9_on_.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_bwjclje.jl:45\nin expression starting at\
    \ /tmp/tmp_bwjclje.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpedm7hc83.jl:33\nin expression starting at\
    \ /tmp/tmpedm7hc83.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    stack.append(lst[1])\n    \n    for i in lst[2:end]\n\
    \        if i == \"(\"\n            stack.append(i)\n        elseif i == \")\"\
    \n            if stack.length() == 0\n                return \"No\"\n        \
    \    else\n                stack.pop()\n            end\n        end\n    end\n\
    \    \n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"\
    ])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary tree\
    \ is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzrxpneek.jl:36\nin expression starting at\
    \ /tmp/tmpzrxpneek.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a vector is a valid permutation of the integers 0 to n-1.\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn98q6zll.jl:32\nin expression starting at\
    \ /tmp/tmpn98q6zll.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for x in lst\n        if x == \"(\"\n           \
    \ push!(stack, x)\n        elseif x == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a given string is a valid expression (i.e., it has valid parentheses).\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq6fa9l3w.jl:32\nin expression starting at\
    \ /tmp/tmpq6fa9l3w.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptooab9c4.jl:32\nin expression starting at\
    \ /tmp/tmptooab9c4.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnxsdj5xs.jl:45\nin expression starting at\
    \ /tmp/tmpnxsdj5xs.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. \nThe function should take one argument and return a boolean.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxs3wvuk5.jl:38\nin expression starting at\
    \ /tmp/tmpxs3wvuk5.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa2pyh7pj.jl:41\nin expression starting at\
    \ /tmp/tmpa2pyh7pj.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime. You may use any number as input.\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6j1l8ynf.jl:45\nin expression starting at\
    \ /tmp/tmp6j1l8ynf.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ as input and returns the number of characters in the string.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj597thrz.jl:45\nin expression starting at\
    \ /tmp/tmpj597thrz.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is a binary search tree. An example of a binary tree\
    \ is shown below.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3wcfdm8k.jl:32\nin expression starting at\
    \ /tmp/tmp3wcfdm8k.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.3>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkg7mw_p_.jl:45\nin expression starting at\
    \ /tmp/tmpkg7mw_p_.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string\
    \ as input and returns a string that has all its parentheses\nbalanced.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3d6grq3o.jl:38\nin expression starting at\
    \ /tmp/tmp3d6grq3o.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a string and returns a string where all occurrences of \"(\" and \")\"\
    \ have been replaced by \"(\" and \")\".\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm0lf25uy.jl:32\nin expression starting at\
    \ /tmp/tmpm0lf25uy.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is even.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp50c2wjcr.jl:41\nin expression starting at\
    \ /tmp/tmp50c2wjcr.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of strings and returns a vector of strings where each string\
    \ is a concatenation of the strings in the original vector except the one that\
    \ starts with \"(\". For example, if the input vector is [\"(hello)\", \"(world)\"\
    , \"(how)\", \"(are)\", \"(you)\"], then the output vector should be [\"helloworld\"\
    , \"howareyou\"].\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpidw0c1ln.jl:32\nin expression starting at\
    \ /tmp/tmpidw0c1ln.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    stack.append(lst)\n    \n    while !isempty(stack)\n\
    \        str = pop!(stack)\n        if str == \"(\"\n            push!(stack,\
    \ str)\n        elseif str == \")\"\n            if isempty(stack)\n         \
    \       return \"Yes\"\n            else\n                pop!(stack)\n      \
    \      end\n        else\n            return str\n        end\n    end\n    return\
    \ \"No\"\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that checks if a binary tree is balanced.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyk1f8nuf.jl:37\nin expression starting at\
    \ /tmp/tmpyk1f8nuf.jl:37\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi2apwkd5.jl:33\nin expression starting at\
    \ /tmp/tmpi2apwkd5.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if lst.size == 0\n        return \"No\"\n    \n    stack = Vector{String}()\n\
    \    \n    for s in lst\n        if s == \"(\"\n            push!(stack, s)\n\
    \        elseif s == \")\"\n            if isempty(stack)\n                return\
    \ \"No\"\n            else\n                pop!(stack)\n            end\n   \
    \     else\n            if isempty(stack)\n                return \"No\"\n   \
    \         else\n                pop!(stack)\n            end\n        end\n  \
    \  end\n    \n    if isempty(stack)\n        return \"Yes\"\n    else\n      \
    \  return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\")\", \")\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\"\
    ])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\",\
    \ \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0ifgtcdy.jl:48\nin expression starting at\
    \ /tmp/tmp0ifgtcdy.jl:48\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeifo1duf.jl:45\nin expression starting at\
    \ /tmp/tmpeifo1duf.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg_6kaafp.jl:35\nin expression starting at\
    \ /tmp/tmpg_6kaafp.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnxsdj5xs.jl:45\nin expression starting at\
    \ /tmp/tmpnxsdj5xs.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6ee9qqtj.jl:45\nin expression starting at\
    \ /tmp/tmp6ee9qqtj.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a given string is a valid phone number.\nA valid phone number has\
    \ the following properties:\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_fhzdst0.jl:39\nin expression starting at\
    \ /tmp/tmp_fhzdst0.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    stack.append(lst[1])\n    for i in lst[2:end]\n \
    \       if i == \"(\"\n            stack.append(i)\n        elseif i == \")\"\n\
    \            if stack.length() == 0\n                return \"No\"\n         \
    \   else\n                stack.pop()\n            end\n        end\n    end\n\
    \    return \"Yes\"\nend\n</code>\n<|/ a tags=string,julia |>\n<| c |>\nThis doesn't\
    \ seem to work. `match_parens([\"()(\", \")\"])` returns `\"No\"` instead of `\"\
    Yes\"`.\n<|/ c |>\n<| c |>\nI fixed the bug. Thanks for pointing it out.\n<|/\
    \ c |>\n<| a tags=string,julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgzs44l8l.jl:33\nin expression starting at\
    \ /tmp/tmpgzs44l8l.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    return \"Yes\"\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvgf9_on_.jl:41\nin expression starting at\
    \ /tmp/tmpvgf9_on_.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp90rrcybv.jl:32\nin expression starting at\
    \ /tmp/tmp90rrcybv.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n     \
    \       push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime or not. Your function should take in a number as\
    \ an argument and return a boolean indicating whether the number is prime or not.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm7nz69uw.jl:33\nin expression starting at\
    \ /tmp/tmpm7nz69uw.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is prime or not. \nA number is prime if and only if it can be written as the\
    \ sum of two primes.\nFor example, 5 is prime because it is equal to 2 + 3, and\
    \ 7 is not prime because it can be written as 2 + 3 + 4.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0q5k5t0r.jl:38\nin expression starting at\
    \ /tmp/tmp0q5k5t0r.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6ee9qqtj.jl:45\nin expression starting at\
    \ /tmp/tmp6ee9qqtj.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\"\
    , \")\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    ()(\", \")\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n\
    </cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"])\n</cell>\n<code language=\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpunfkxr8b.jl:39\nin expression starting at\
    \ /tmp/tmpunfkxr8b.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime or not. Your function should take in a number as\
    \ input and output \"Yes\" or \"No\".\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0dwuijq9.jl:39\nin expression starting at\
    \ /tmp/tmp0dwuijq9.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        else\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a vector\
    \ is a valid permutation of another vector.\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_6w6gcf1.jl:45\nin expression starting at\
    \ /tmp/tmp_6w6gcf1.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    if length(lst) == 0 \n        return \"No\"\n    \n    if length(lst)\
    \ == 1 \n        if lst[1] == \"(\" \n            return \"Yes\"\n        else\
    \ \n            return \"No\"\n    end\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptb0qlwlj.jl:1\nin expression starting at /tmp/tmptb0qlwlj.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.0>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.0>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a binary tree is a binary search tree.\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq7o9zcto.jl:32\nin expression starting at\
    \ /tmp/tmpq7o9zcto.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    stack.append(lst[1])\n    \n    for elem in\
    \ lst[2:end]\n        if elem == \"(\"\n            stack.append(elem)\n     \
    \   elseif elem == \")\"\n            if stack.pop() != elem\n               \
    \ return \"No\"\n            else\n                stack.pop()\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ and returns the number of occurrences of every character in the string. For\
    \ example, the string \"abcabc\" has 3 a's and 2 b's.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxu7t08ss.jl:35\nin expression starting at\
    \ /tmp/tmpxu7t08ss.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime or not. Your function should take in a number as its only argument,\
    \ and return 'Yes' if it is prime and 'No' otherwise.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqyl6dj0y.jl:39\nin expression starting at\
    \ /tmp/tmpqyl6dj0y.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9548icln.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9548icln.jl:1\n\
    in expression starting at /tmp/tmp9548icln.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    stack = push!(stack, \"\")\n    stack =\
    \ push!(stack, \"\")\n    for i in lst\n        if i == \"(\"\n            push!(stack,\
    \ \"\")\n        elseif i == \")\"\n            if length(stack) == 2\n      \
    \          return \"Yes\"\n            else\n                pop!(stack)\n   \
    \         end\n        else\n            push!(stack, i)\n        end\n    end\n\
    \    return \"No\"\nend\n</code>\n<|/ a tags=string,julia,stack |>\n<| c |>\n\
    Thank you for your answer! I understand your solution, but I do not understand\
    \ why you use \"push!(stack, \"\")\" twice. Why not just \"push!(stack, i)\"?\n\
    <|/ c |>\n<| c |>\nBecause I wanted to push an empty string to the stack if I\
    \ encounter a left parenthesis. But I wanted to pop it when I encounter a right\
    \ parenthesis. So I pushed two empty strings to the stack. One for the left parenthesis\
    \ and one for the right parenthesis.\n<|/ c |>\n<| c |>\nI see. Thank you very\
    \ much for your help!\n<|/ c |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz8p28w35.jl:36\nin expression starting at\
    \ /tmp/tmpz8p28w35.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Stack()\n    for s in lst\n        if s == \"(\"\n           \
    \ push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\", \"\
    (\", \"(\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"()(\", \")\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnadn3a_j.jl:38\nin expression starting at\
    \ /tmp/tmpnadn3a_j.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ and returns a new string where all occurrences of '(' and ')' have been replaced\
    \ by '-'.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy22hxvom.jl:39\nin expression starting at\
    \ /tmp/tmpy22hxvom.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        else\n            if isempty(stack)\n              \
    \  return \"No\"\n            else\n                pop!(stack)\n            end\n\
    \        end\n    end\n    \n    if isempty(stack)\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a binary\
    \ tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt54osvaj.jl:45\nin expression starting at\
    \ /tmp/tmpt54osvaj.jl:45\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Vector{String}()\n    \n    for s in lst\n        if s ==\
    \ \"(\"\n            push!(stack, s)\n        elseif s == \")\"\n            if\
    \ isempty(stack)\n                return \"No\"\n            else\n          \
    \      pop!(stack)\n            end\n        end\n    end\n    \n    if isempty(stack)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprnnxyfis.jl:39\nin expression starting at\
    \ /tmp/tmprnnxyfis.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    stack = Vector{String}()\n    for s in lst\n        if s == \"(\"\n  \
    \          push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nmatch_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\")\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ checks if a binary tree is balanced.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpofqkngz4.jl:32\nin expression starting at\
    \ /tmp/tmpofqkngz4.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a vector of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    \n    stack = Stack()\n    \n    for s in lst\n        if s == \"(\"\n\
    \            push!(stack, s)\n        elseif s == \")\"\n            if isempty(stack)\n\
    \                return \"No\"\n            else\n                pop!(stack)\n\
    \            end\n        end\n    end\n    \n    if isempty(stack)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    match_parens([\"()(\", \")\"])\n</cell>\n<code language=julia-1.5>\nmatch_parens([\"\
    )\", \")\"])\n</cell>\n<text>\nExercise 3\nWrite a function that checks if a number\
    \ is prime. \nA prime number is a natural number greater than 1 that has no positive\
    \ divisors other than 1 and itself.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkbarh4eh.jl:39\nin expression starting at\
    \ /tmp/tmpkbarh4eh.jl:39\n"
  stdout: ''
