name: HumanEval_11_string_xor
language: jl
prompt: "\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform\
  \ binary XOR on these inputs and return result also as a string.\n    >>> string_xor(\"\
  010\", \"110\")\n    \"100\"\n    \"\"\"\nfunction string_xor(a::String, b::String)::String\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = string_xor;\n\t@test(candidate(\"\
  111000\", \"101010\") == \"010010\")\n\t@test(candidate(\"1\", \"1\") == \"0\")\n\
  \t@test(candidate(\"0101\", \"0000\") == \"0101\")\nend\n"
completions: ["    return \"\"\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ as input and returns the number of characters in the string. \nThe function\
    \ should raise an error if the string is not of length 1.\nHint: use the function\
    \ length() from the Base package.\nHint: use the function char() from the Base\
    \ package.\nHint: use the function typeof() from the Base package.\nHint: use\
    \ the function typeof() from the Base package.\nHint: use the function typeof()\
    \ from the Base package.\nHint: use the function typeof() from the Base package.\n\
    Hint: use the function typeof() from the Base package.\nHint: use the function\
    \ typeof() from the Base package.\nHint: use the function typeof() from the Base\
    \ package.\nHint: use the function typeof() from the Base package.\nHint: use\
    \ the function typeof() from the Base package.\nHint: use the function typeof()\
    \ from the Base package.\nHint: use the function typeof() from the Base package.\n\
    Hint: use the function typeof() from the Base package.\nHint: use the function\
    \ typeof() from the Base package.\nHint: use the function typeof() from the Base\
    \ package.\nHint: use the function typeof() from the Base package.\nHint: use\
    \ the function typeof() from the Base package.\nHint: use the function typeof()\
    \ from the Base package.\nHint: use the function typeof() from the Base package.\n\
    Hint: use the function typeof() from the Base package.\nHint: use the function\
    \ typeof() from the Base package.\nHint: use the function typeof() from the Base\
    \ package.\nHint: use the function typeof() from the Base package.\nHint: use\
    \ the function typeof() from the Base package.\nHint: use the function typeof()\
    \ from the Base package.\nHint: use the function typeof() from the Base package.\n\
    Hint: use the function typeof() from the Base package.\nHint: use the function\
    \ typeof() from the Base package.\nHint: use the function typeof() from the Base\
    \ package.\nHint: use the function typeof() from the Base package.\nHint: use\
    \ the function typeof() from the Base package.\nHint: use the function typeof()\
    \ from the Base package.\nHint: use the function typeof() from the Base package.\n\
    Hint: use the function typeof() from the Base package.\nHint: use the function\
    \ typeof() from the Base package.\nHint: use the function typeof() from the Base\
    \ package.\nHint: use the function typeof() from the Base package.\nHint: use\
    \ the function typeof() from the Base package.\nHint: use the function typeof()\
    \ from the Base package.\nHint: use the function typeof() from the Base package.\n\
    Hint: use the ", "    return string_to_bits(a) ^ string_to_bits(b)\nend\n</cell>\n\
    <code language=julia-1.5>", "    if a==\"\" || b==\"\"\n        return \"\"\n\
    \    else\n        return (a^b)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ performs binary AND on two strings a and b. \nThis function should return result\
    \ also as a string.\n>>> string_and(\"010\", \"110\")\n\"100\"\n>>> string_and(\"\
    010\", \"010\")\n\"100\"\n>>> string_and(\"010\", \"100\")\n\"100\"\n>>> string_and(\"\
    010\", \"011\")\n\"100\"\n>>> string_and(\"010\", \"101\")\n\"100\"\n>>> string_and(\"\
    010\", \"1101\")\n\"100\"\n>>> string_and(\"010\", \"0101\")\n\"100\"\n>>> string_and(\"\
    010\", \"01010\")\n\"100\"\n>>> string_and(\"010\", \"0101011\")\n\"100\"\n>>>\
    \ string_and(\"010\", \"01010101\")\n\"100\"\n>>> string_and(\"010\", \"010101010\"\
    )\n\"100\"\n>>> string_and(\"010\", \"0101010101\")\n\"100\"\n>>> string_and(\"\
    010\", \"01010101010\")\n\"100\"\n>>> string_and(\"010\", \"0101010101011\")\n\
    \"100\"\n>>> string_and(\"010\", \"01010101010101\")\n\"100\"\n>>> string_and(\"\
    010\", \"010101010101010\")\n\"100\"\n>>> string_and(\"010\", \"01010101010101011\"\
    )\n\"100\"\n>>> string_and(\"010\", \"010101010101010101\")\n\"100\"\n>>> string_and(\"\
    010\", \"0101010101010101010\")\n\"100\"\n>>> string_and(\"010\", \"010101010101010101011\"\
    )\n\"100\"\n>>> string_and(\"010\", \"010101010101010101010101\")\n\"100\"\n>>>\
    \ string_and(\"010\", \"0101010101010101010101010\")\n\"100\"\n>>> string_and(\"\
    010\", \"01010101010101010101010101\")\n\"100\"\n>>> string_and(\"010\", \"010101010101010101010101010\"\
    )\n\"100\"\n>>> string_and(\"010\", \"01010101010101010101010101011\")\n\"100\"\
    \n>>> string_and(\"010\", \"01010101010101010", "    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    if length(a) == length(b) then\n        local\
    \ result = \"\"\n        for i = 1, length(a) do\n            local c = a[i]\n\
    \            result = (result + c) ^ b[i]\n        end\n        return result\n\
    \    else\n        return \"Invalid inputs\"\n    end\nend\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that checks if a number is prime or not. \nThe function\
    \ should take one number as input and return true or false accordingly.\nThe function\
    \ should also return an error message if the input is invalid.\nThe function should\
    \ also return an error message if the number is negative.\nThe function should\
    \ also return an error message if the number is zero.\nThe function should also\
    \ return an error message if the number is greater than the square root of the\
    \ number itself.\nThe function should also return an error message if the number\
    \ is less than 1.\nThe function should also return an error message if the number\
    \ is greater than 100.\nThe function should also return an error message if the\
    \ number is less than 1.", "    return bin(bin(a) XOR bin(b))[2:]\nend\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that converts a binary string to a decimal integer.\nThe\
    \ function should take a string as input and return a number.\nThe function should\
    \ raise an error if the input is not valid binary string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should\
    \ raise an error if the input is not valid decimal string.\nThe function should ",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    if length(a)\
    \ != length(b) \n        error(\"Strings must have same length\")\n    end\n \
    \   \n    string = \"\"\n    for i in eachindex(a)\n        string += (a[i] ^\
    \ b[i])\n    end\n    \n    return string\nend", "    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n", "    \n    if length(a) == length(b) \n    \
    \    \n        if length(a) == 0 \n            return b\n        \n        if\
    \ length(b) == 0 \n            return a\n        \n        if a[0] == b[0] \n\
    \            return string_xor(a[1:], b[1:])\n        \n        return string_xor(a[1:],\
    \ b) + a[0]\n    \n    else \n        return \"\"\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a string as input and returns the number of characters in the string.\
    \ \nThe function should ignore all whitespace characters and should ignore all\
    \ non-alphabetic characters. \nThe function should ignore all characters that\
    \ are not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe function should ignore all characters that are\
    \ not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe function should ignore all characters that are\
    \ not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe function should ignore all characters that are\
    \ not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe function should ignore all characters that are\
    \ not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe function should ignore all characters that are\
    \ not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe function should ignore all characters that are\
    \ not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe function should ignore all characters that are\
    \ not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe function should ignore all characters that are\
    \ not in the alphabet (including spaces, punctuation, and symbols).\nThe function\
    \ should ignore all characters that are not in the alphabet (including spaces,\
    \ punctuation, and symbols).\nThe ", "    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    if length(a) == length(b) \n        then return string_xor(string_xor(a,b),a)\n\
    \        else return string_xor(a,string_xor(b,a))\n    else return \"\"\nend\n\
    </cell>\n<code language=julia-1.3>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a string as input and returns the number\
    \ of characters in the string. \nThe function should ignore all spaces and special\
    \ characters and should ignore case when counting characters.\nThe function should\
    \ ignore all spaces and special characters and should ignore case when counting\
    \ characters.\nThe function should ignore all spaces and special characters and\
    \ should ignore case when counting characters.\nThe function should ignore all\
    \ spaces and special characters and should ignore case when counting characters.\n\
    The function should ignore all spaces and special characters and should ignore\
    \ case when counting characters.\nThe function should ignore all spaces and special\
    \ characters and should ignore case when counting characters.\nThe function should\
    \ ignore all spaces and special characters and should ignore case when counting\
    \ characters.\nThe function should ignore all spaces and special characters and\
    \ should ignore case when counting characters.\nThe function should ignore all\
    \ spaces and special characters and should ignore case when counting characters.\n\
    The function should ignore all spaces and special characters and should ignore\
    \ case when counting characters.\nThe function should ignore all spaces and special\
    \ characters and should ignore case when counting characters.\nThe function should\
    \ ignore all spaces and special characters and should ignore case when counting\
    \ characters.\nThe function should ignore all spaces and special characters and\
    \ should ignore case when counting characters.\nThe function should ignore all\
    \ spaces and special characters and should ignore case when counting characters.\n\
    The function should ignore all spaces and special characters and should ignore\
    \ case when counting characters.\nThe function should ignore all spaces and special\
    \ characters and should ignore case when counting characters.\nThe function should\
    \ ignore all spaces and special characters and should ignore case when counting\
    \ characters.\nThe function should ignore all spaces and special characters and\
    \ should ignore case when counting characters.\nThe function should ignore all\
    \ spaces and special characters and should ignore case when counting characters.\n\
    The function should ignore all spaces and special characters and should ignore\
    \ case when counting characters.\nThe function should ignore all spaces and special\
    \ characters and should ignore case when counting characters.\nThe function should\
    \ ignore all spaces and special characters and should ignore case when counting\
    \ characters.\nThe function should ignore all spaces and special characters and\
    \ should ignore case when counting characters.\nThe function should ignore all\
    \ spaces and special characters and should ignore case when counting ", "    if\
    \ length(a) != length(b) then return \"Error\" else return a^b\nend", "    if\
    \ length(a) != length(b) \n        error(\"Strings must have same length\")\n\
    \    elseif length(a) == 0 \n        error(\"String is empty\")\n    elseif length(a)\
    \ == 1 \n        return b\n    elseif length(a) == 2 \n        return string_xor(a[1:2],\
    \ b[1:2])\n    elseif length(a) == 3 \n        return string_xor(a[1:3], b[1:3])\n\
    \    elseif length(a) == 4 \n        return string_xor(a[1:4], b[1:4])\n    elseif\
    \ length(a) == 5 \n        return string_xor(a[1:5], b[1:5])\n    elseif length(a)\
    \ == 6 \n        return string_xor(a[1:6], b[1:6])\n    elseif length(a) == 7\
    \ \n        return string_xor(a[1:7], b[1:7])\n    elseif length(a) == 8 \n  \
    \      return string_xor(a[1:8], b[1:8])\n    elseif length(a) == 9 \n       \
    \ return string_xor(a[1:9], b[1:9])\n    elseif length(a) == 10 \n        return\
    \ string_xor(a[1:10], b[1:10])\n    elseif length(a) == 11 \n        return string_xor(a[1:11],\
    \ b[1:11])\n    elseif length(a) == 12 \n        return string_xor(a[1:12], b[1:12])\n\
    \    elseif length(a) == 13 \n        return string_xor(a[1:13], b[1:13])\n  \
    \  elseif length(a) == 14 \n        return string_xor(a[1:14], b[1:14])\n    elseif\
    \ length(a) == 15 \n        return string_xor(a[1:15], b[1:15])\n    elseif length(a)\
    \ == 16 \n        return string_xor(a[1:16], b[1:16])\n    elseif length(a) ==\
    \ 17 \n        return string_xor(a[1:17], b[1:17])\n    elseif length(a) == 18\
    \ \n        return string_xor(a[1:18], b[1:18])\n    elseif length(a) == 19 \n\
    \        return string_xor(a[1:19], b[1:19])\n    elseif length(a) == 20 \n  \
    \      return string_xor(a[1:20], b[1:20])\n    elseif length(a) == 21 \n    \
    \    return string_xor(a[1:21], b[1:21])\n    elseif length(a) == 22 \n      \
    \  return string_xor(a[1:22], b[1:22])\n    elseif length(a) == 23 \n        return\
    \ string_xor(a[1:23], b[1:23])\n    elseif length(a) == 24 \n        return string_xor(a[1:24],\
    \ b[1:24])\n    elseif length(a) == 25 \n        return string_xor(a[1:25], b[1:25])\n\
    \    elseif length(a) == 26 \n        return string_xor(a[1:26], b[1:26])\n  \
    \  elseif length(a) == 27 \n", "    if a==\"\" || b==\"\"\n        return \"\"\
    \n    elseif a==b\n        return a\n    elseif a==\"0\" && b==\"1\"\n       \
    \ return \"0\"\n    elseif a==\"1\" && b==\"0\"\n        return \"1\"\n    else\n\
    \        return \"\"\n    end\nend\n</cell>\n<code language=julia-1.4>", "   \
    \ \n    if length(a) == length(b) \n        \n        \n        \n        \n \
    \       \n        \n        \n        \n        \n        \n        \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n", "    if length(a) == length(b) \n        then return a\n\
    \        else return b\n    else return b\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string as input and returns the number of 1s in the string.\nThe function\
    \ should work for strings of any length.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of ", "    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    if length(a) != length(b) \n\
    \        error(\"Strings must have same length\")\n    else \n        return (a-b).to_string()\n\
    end\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function that checks if a number is prime or not.\
    \ \nThe function should take one number as input and return true or false accordingly.\n\
    The function should also handle negative numbers and non-integer inputs.\nThe\
    \ function should also handle non-prime numbers and non-integer inputs.\nThe function\
    \ should also handle negative numbers and non-prime numbers.\nThe function should\
    \ also handle non-prime numbers and non-integer inputs.\nThe function should also\
    \ handle negative numbers and non-prime numbers.\nThe function should also handle\
    \ non-prime numbers and non-integer inputs.\nThe function should also handle negative\
    \ numbers and non-prime numbers.\nThe function should also handle non-prime numbers\
    \ and non-integer inputs.\nThe function should also handle negative numbers and\
    \ non-prime numbers.\nThe function should also handle non-prime numbers and non-integer\
    \ inputs.\nThe function should also handle negative numbers and non-prime numbers.\n\
    The function should also handle non-prime numbers and non-integer inputs.\nThe\
    \ function should also handle negative numbers and non-prime numbers.\nThe function\
    \ should also handle non-prime numbers and non-integer inputs.\nThe function should\
    \ also handle negative numbers and non-prime numbers.\nThe function should also\
    \ handle non-prime numbers and non-integer inputs.\nThe function should also handle\
    \ negative numbers and non-prime numbers.\nThe function should also handle non-prime\
    \ numbers and non-integer inputs.\nThe function should also handle negative numbers\
    \ and non-prime numbers.\nThe function should also handle non-prime numbers and\
    \ non-integer inputs.\nThe function should also handle negative numbers and non-prime\
    \ numbers.\nThe function should also handle non-prime numbers and non-integer\
    \ inputs.\nThe function should also handle negative numbers and non-prime numbers.\n\
    The function should also handle non-prime numbers and non-integer inputs.\nThe\
    \ function should also handle negative numbers and non-prime numbers.\nThe function\
    \ should also handle non-prime numbers and non-integer inputs.\nThe function should\
    \ also handle negative numbers and non-prime numbers.\nThe function should also\
    \ handle non-prime numbers and non-integer inputs.\nThe function should also handle\
    \ negative numbers and non-prime numbers.\nThe function should also handle non-prime\
    \ numbers and non-integer inputs.\nThe function should also handle negative numbers\
    \ and non-prime numbers.\nThe function should also handle non-prime numbers and\
    \ non-integer inputs.\nThe function should also handle negative numbers and non-prime\
    \ numbers.\nThe function should also handle non-prime numbers and non-integer\
    \ inputs.\nThe function should ", "    return bin(bin(a) ^ bin(b))[2:]\nend\n\
    </cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a string as input and returns the number\
    \ of characters in the string. \nUse this function to find the number of characters\
    \ in the string \"Hello World!\".\nHint: Use length() function", "    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    return bin(bin(a) ^ bin(b))[2:]\n\
    end", "    if length(a) == length(b) \n        then return a\n        else return\
    \ b\n    else return b\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    010\", \"110\")\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string\
    \ as input and returns the number of characters in the string.\n>>> count_chars(\"\
    Hello World\")\n12\n>>> count_chars(\"Hello World!\")\n13\n>>> count_chars(\"\
    Hello World!!\")\n14\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"\
    Hello World!!!!\")\n16\n>>> count_chars(\"Hello World!!!!!\")\n17\n>>> count_chars(\"\
    Hello World!!!!!!\")\n18\n>>> count_chars(\"Hello World!!!!!!!\")\n19\n>>> count_chars(\"\
    Hello World!!!!!!!\") # extra space\n20\n>>> count_chars(\"Hello World!!!!!!!\
    \ \") # extra space\n20\n>>> count_chars(\"Hello World!!!!!!! \")\n20\n>>> count_chars(\"\
    Hello World!!!!!!! !\")\n20\n>>> count_chars(\"Hello World!!!!!!! !!\")\n20\n\
    >>> count_chars(\"Hello World!!!!!!! !!!\")\n20\n>>> count_chars(\"Hello World!!!!!!!\
    \ !!!\") # extra space\n20\n>>> count_chars(\"Hello World!!!!!!! !!! \")\n20\n\
    >>> count_chars(\"Hello World!!!!!!! !!! !\")\n20\n>>> count_chars(\"Hello World!!!!!!!\
    \ !!! !!\")\n20\n>>> count_chars(\"Hello World!!!!!!! !!! !!!\")\n20\n>>> count_chars(\"\
    Hello World!!!!!!! !!! !!! \")\n20\n>>> count_chars(\"Hello World!!!!!!! !!! !!!\
    \ !\")\n20\n>>> count_chars(\"Hello World!!!!!!! !!! !!! !!\")\n20\n>>> count_chars(\"\
    Hello World!!!!!!! !!! !!! !!! \")\n20\n>>> count_chars(\"Hello World!!!!!!! !!!\
    \ !!! !!! !\")\n20\n>>> count_chars(\"Hello World!!!!!!! !!! !!! !!! !!\")\n20\n\
    >>> count_chars(\"Hello World!!!!!!! !!! !!! !!! !!\")\n20\n>>> count_chars(\"\
    Hello World!!!!!!! !!! !!! !!! !!! \")\n20\n>>> count_chars(\"Hello World!!!!!!!\
    \ !!! !!! !!! !!! !\")\n20\n>>> count_chars(\"Hello World!!!!!!! !!! !!! !!! !!!\
    \ !!\")\n20\n>>> ", "    return a xor b\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 1\nWrite a function that\
    \ performs binary AND on two strings a and b consisting only of 1s and 0s.\n \
    \   >>> string_and(\"010\", \"110\")\n    \"101\"\n    \"\"\"", "    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n", "    \n    if length(a) != length(b) \n    \
    \    error(\"Strings must have same length\")\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    ", "    if length(a) != length(b)\
    \ then \n        error(\"Strings must have same length\")\n    end\n    \n   \
    \ result =\"\"\n    for (i in 1:length(a))\n        result .= (a[i] ^ b[i])\n\
    \    end\n    return result\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that checks if\
    \ a string is palindrome or not.\nThe function should return true if the string\
    \ is a palindrome and false otherwise.\nThe function should work for any string\
    \ and should work for empty string also.\nThe function should work for any string\
    \ and should work for any length string also.\nThe function should work for any\
    \ string and should work for any length string also.\nThe function should work\
    \ for any string and should work for any length string also.\nThe function should\
    \ work for any string and should work for any length string also.\nThe function\
    \ should work for any string and should work for any length string also.\nThe\
    \ function should work for any string and should work for any length string also.\n\
    The function should work for any string and should work for any length string\
    \ also.\nThe function should work for any string and should work for any length\
    \ string also.\nThe function should work for any string and should work for any\
    \ length string also.\nThe function should work for any string and should work\
    \ for any length string also.\nThe function should work for any string and should\
    \ work for any length string also.\nThe function should work for any string and\
    \ should work for any length string also.\nThe function should work for any string\
    \ and should work for any length string also.\nThe function should work for any\
    \ string and should work for any length string also.\nThe function should work\
    \ for any string and should work for any length string also.\nThe function should\
    \ work for any string and should work for any length string also.\nThe function\
    \ should work for any string and should work for any length string also.\nThe\
    \ function should work for any string and should work for any length string also.\n\
    The function should work for any string and should work for any length string\
    \ also.\nThe function should work for any string and should work for any length\
    \ string also.\nThe function should work for any string and should work for any\
    \ length string also.\nThe function should work for any string and should work\
    \ for any length string also.\nThe function should work for any string and should\
    \ work for any length string also.\nThe function should work for any string and\
    \ should work for any length string also.\nThe function should work for any string\
    \ and should work for any length string also.\nThe function should work for any\
    \ string and should work for any length string also.\n", "    if length(a) !=\
    \ length(b) \n        error(\"Strings must have same length\")\n    else if length(a)\
    \ == 0 \n        error(\"Strings must have at least one character\")\n    else\
    \ if length(a) == 1 \n        return b\n    else \n        return (a^b)\nend\n\
    </cell>\n<code language=julia-1.5>", "    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    return bin(bin(a) xor bin(b))[2:]\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes two strings a and b and returns True if they consist only of 1s and 0s\
    \ and False otherwise.\nWrite a function that takes two strings a and b and returns\
    \ True if they consist only of 0s and 1s and False otherwise.\nWrite a function\
    \ that takes two strings a and b and returns True if they consist only of 1s and\
    \ 0s and False otherwise.\nWrite a function that takes two strings a and b and\
    \ returns True if they consist only of 0s and 1s and False otherwise.\nWrite a\
    \ function that takes two strings a and b and returns True if they consist only\
    \ of 1s and 0s and False otherwise.\nWrite a function that takes two strings a\
    \ and b and returns True if they consist only of 0s and 1s and False otherwise.\n\
    Write a function that takes two strings a and b and returns True if they consist\
    \ only of 1s and 0s and False otherwise.\nWrite a function that takes two strings\
    \ a and b and returns True if they consist only of 0s and 1s and False otherwise.\n\
    Write a function that takes two strings a and b and returns True if they consist\
    \ only of 1s and 0s and False otherwise.\nWrite a function that takes two strings\
    \ a and b and returns True if they consist only of 0s and 1s and False otherwise.\n\
    Write a function that takes two strings a and b and returns True if they consist\
    \ only of 1s and 0s and False otherwise.\nWrite a function that takes two strings\
    \ a and b and returns True if they consist only of 0s and 1s and False otherwise.\n\
    Write a function that takes two strings a and b and returns True if they consist\
    \ only of 1s and 0s and False otherwise.\nWrite a function that takes two strings\
    \ a and b and returns True if they consist only of 0s and 1s and False otherwise.\n\
    Write a function that takes two strings a and b and returns True if they consist\
    \ only of 1s and 0s and False otherwise.\nWrite a function that takes two strings\
    \ a and b and returns True if they consist only of 0s and 1s and False otherwise.\n\
    Write a function that takes two strings a and b and returns True if they consist\
    \ only of 1s and 0s and False otherwise.\nWrite a function that takes two strings\
    \ a and b and returns True if they consist only of 0s and 1s and False otherwise.\n\
    Write a function that takes two strings a and b and returns True if they consist\
    \ only of 1s and 0s and False otherwise.\nWrite a function that takes two strings\
    \ a and b and returns True if ", "    \n    if length(a) == length(b) \n     \
    \   \n        \n        \n        \n        \n        \n        \n        \n \
    \       \n        \n        \n        \n        \n        \n        \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n", "    return bin(bin(a)\
    \ xor bin(b))[2:]\nend", "    return bin(bin(a) xor bin(b))[2:]\nend\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that converts binary numbers to decimal numbers. \nFor example\
    \ the binary number 0101 would be converted to decimal number 7.\nThe function\
    \ should take two strings as inputs and return one string as output.\nThe function\
    \ should ignore leading zeros.\nThe function should ignore trailing zeros.\nThe\
    \ function should ignore leading zeros.\nThe function should ignore trailing zeros.\n\
    The function should ignore leading zeros.\nThe function should ignore trailing\
    \ zeros.\nThe function should ignore leading zeros.\nThe function should ignore\
    \ trailing zeros.\nThe function should ignore leading zeros.\nThe function should\
    \ ignore trailing zeros.\nThe function should ignore leading zeros.\nThe function\
    \ should ignore trailing zeros.\nThe function should ignore leading zeros.\nThe\
    \ function should ignore trailing zeros.\nThe function should ignore leading zeros.\n\
    The function should ignore trailing zeros.\nThe function should ignore leading\
    \ zeros.\nThe function should ignore trailing zeros.\nThe function should ignore\
    \ leading zeros.\nThe function should ignore trailing zeros.\nThe function should\
    \ ignore leading zeros.\nThe function should ignore trailing zeros.\nThe function\
    \ should ignore leading zeros.\nThe function should ignore trailing zeros.\nThe\
    \ function should ignore leading zeros.\nThe function should ignore trailing zeros.\n\
    The function should ignore leading zeros.\nThe function should ignore trailing\
    \ zeros.\nThe function should ignore leading zeros.\nThe function should ignore\
    \ trailing zeros.\nThe function should ignore leading zeros.\nThe function should\
    \ ignore trailing zeros.\nThe function should ignore leading zeros.\nThe function\
    \ should ignore trailing zeros.\nThe function should ignore leading zeros.\nThe\
    \ function should ignore trailing zeros.\nThe function should ignore leading zeros.\n\
    The function should ignore trailing zeros.\nThe function should ignore leading\
    \ zeros.\nThe function should ignore trailing zeros.\nThe function should ignore\
    \ leading zeros.\nThe function should ignore trailing zeros.\nThe function should\
    \ ignore leading zeros.\nThe function should ignore trailing zeros.\nThe function\
    \ should ignore leading zeros.\nThe function should ignore trailing zeros.\nThe\
    \ function should ignore leading zeros.\nThe function should ignore trailing zeros.\n\
    The function should ignore leading zeros.\nThe function should ignore trailing\
    \ zeros.\nThe function should ignore leading zeros.\nThe function should ignore\
    \ trailing zeros.\nThe function should ignore leading zeros.\nThe function should ",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if length(a) ==\
    \ length(b) \n        then return string_xor(string_xor(a,b),string_xor(a,b))\
    \ \n        else return string_xor(a,b) \n    else return \"\"\nend\n</cell>\n\
    <code language=julia-1.3>", "    if length(a) != length(b) then return \"Invalid\
    \ input\"\n    else return string_xor(string_tobits(a), string_tobits(b))\nend\n\
    </cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that converts a binary string to a decimal integer.\n\
    The function should accept a binary string as input and should return the decimal\
    \ integer as output.\nThe function should raise an error if the input string contains\
    \ characters that are not 1 or 0.\nThe function should raise an error if the input\
    \ string contains characters that are not 1 or 0.\nThe function should raise an\
    \ error if the input string contains characters that are not 1 or 0.\nThe function\
    \ should raise an error if the input string contains characters that are not 1\
    \ or 0.\nThe function should raise an error if the input string contains characters\
    \ that are not 1 or 0.\nThe function should raise an error if the input string\
    \ contains characters that are not 1 or 0.\nThe function should raise an error\
    \ if the input string contains characters that are not 1 or 0.\nThe function should\
    \ raise an error if the input string contains characters that are not 1 or 0.\n\
    The function should raise an error if the input string contains characters that\
    \ are not 1 or 0.\nThe function should raise an error if the input string contains\
    \ characters that are not 1 or 0.\nThe function should raise an error if the input\
    \ string contains characters that are not 1 or 0.\nThe function should raise an\
    \ error if the input string contains characters that are not 1 or 0.\nThe function\
    \ should raise an error if the input string contains characters that are not 1\
    \ or 0.\nThe function should raise an error if the input string contains characters\
    \ that are not 1 or 0.\nThe function should raise an error if the input string\
    \ contains characters that are not 1 or 0.\nThe function should raise an error\
    \ if the input string contains characters that are not 1 or 0.\nThe function should\
    \ raise an error if the input string contains characters that are not 1 or 0.\n\
    The function should raise an error if the input string contains characters that\
    \ are not 1 or 0.\nThe function should raise an error if the input string contains\
    \ characters that are not 1 or 0.\nThe function should raise an error if the input\
    \ string contains characters that are not 1 or 0.\nThe function should raise an\
    \ error if the input string contains characters that are not 1 or 0.\nThe function\
    \ should raise an error if the input string contains characters that are not 1\
    \ or 0.\nThe function should raise an error if the input string contains characters\
    \ that are not 1 or 0.\nThe function should raise an error if the input string\
    \ contains characters that are not 1 or 0.\nThe function should raise an error\
    \ if the input string contains characters that are not 1 or 0.\nThe function should\
    \ raise an error if the input string contains characters that are not 1 or 0.\n\
    The function should raise an error if the input string contains characters that\
    \ are not 1 or 0.\nThe function should raise an error if the input string contains\
    \ characters that are not 1 or 0.\nThe function ", "    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "    return bin(bin(a) ^ bin(b))[2:]\nend\n</cell>\n<code language=julia-1.0>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a string as input and returns the number of characters in the string.\n\
    Hint: Use length() function", "    \n    if length(a) == length(b) \n        \n\
    \        \n        if length(a) == 0 \n            return \"\"\n        \n   \
    \     if length(b) == 0 \n            return \"\"\n        \n        if length(a)\
    \ == 1 \n            return b\n        \n        if length(b) == 1 \n        \
    \    return a\n        \n        \n        if a[0] == b[0] \n            return\
    \ string_xor(a[1:], b[1:])\n        \n        if a[0] == b[1] \n            return\
    \ string_xor(a[1:], b[2:])\n        \n        if a[0] == b[2] \n            return\
    \ string_xor(a[1:], b[3:])\n        \n        if a[0] == b[3] \n            return\
    \ string_xor(a[1:], b[4:])\n        \n        if a[0] == b[4] \n            return\
    \ string_xor(a[1:], b[5:])\n        \n        if a[0] == b[5] \n            return\
    \ string_xor(a[1:], b[6:])\n        \n        if a[0] == b[6] \n            return\
    \ string_xor(a[1:], b[7:])\n        \n        if a[0] == b[7] \n            return\
    \ string_xor(a[1:], b[8:])\n        \n        if a[0] == b[8] \n            return\
    \ string_xor(a[1:], b[9:])\n        \n        if a[0] == b[9] \n            return\
    \ string_xor(a[1:], b[10:])\n        \n        if a[0] == b[10] \n           \
    \ return string_xor(a[1:], b[11:])\n        \n        if a[0] == b[11] \n    \
    \        return string_xor(a[1:], b[12:])\n        \n        if a[0] == b[12]\
    \ \n            return string_xor(a[1:], b[13:])\n        \n        if a[0] ==\
    \ b[13] \n            return string_xor(a[1:], b[14:])\n        \n        if a[0]\
    \ == b[14] \n            return string_xor(a[1:], b[15:])\n        \n        if\
    \ a[0] == b[15] \n            return string_xor(a[1:], b[16:])\n        \n   \
    \     if a[0] == b[16] \n            return string_xor(a[1:], b[17:])\n      \
    \  \n        if a[0] == b[17] \n            return string_xor(a[1:], b[18:])\n\
    \        \n        if a[0] == b[18] \n            return string_xor(a[1:], b[19:])\n\
    \        \n        if a[0] == b[19] \n            return string_xor(a[1:], b[20:])\n\
    \        \n        if a[0] == b[20] \n            return string_xor(a[1:], b[21:])\n\
    \        \n        if a[0] == b[21] \n            return string_xor(a[1:], b[22:])\n\
    \        \n        if a[0] == b[22] \n            return string_xor(a[1:], b[23",
  "    return bin(bin(a) xor bin(b))[2:]\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string as input and returns the number of times each character appears\
    \ in the string. \nFor example the string \"abcabc\" would return {\"a\" => 3,\
    \ \"b\" => 2, \"c\" => 3}", "    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    if length(a) == length(b) \n        then return string_xor(string_xor(a,b),a)\n\
    \        else return string_xor(a,string_xor(b,a))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string as input and returns the number of characters\
    \ in the string. \nFor example string_length(\"hello\") should return 5.\nHint:\
    \ Use length() function", "    \n    if length(a) == length(b) \n        \n  \
    \      if length(a) == 0 \n            return \"0\"\n        \n        if length(b)\
    \ == 0 \n            return \"0\"\n        \n        if length(a) == 1 \n    \
    \        return b\n        \n        if length(b) == 1 \n            return a\n\
    \        \n        \n        if a[1] == '0' and b[1] == '0' \n            return\
    \ a\n        \n        if a[1] == '0' and b[1] == '1' \n            return b\n\
    \        \n        if a[1] == '1' and b[1] == '0' \n            return a\n   \
    \     \n        if a[1] == '1' and b[1] == '1' \n            return b\n      \
    \  \n    else \n        return \"Error\"\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    110\", \"010\")\n</cell>\n<code language=julia-1.5>\nstring_xor(\"110\", \"100\"\
    )\n</cell>\n<code language=julia-1.5>\nstring_xor(\"100\", \"110\")\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"100\", \"010\")\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"100\", \"001\")\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    001\", \"100\")\n</cell>\n<code language=julia-1.5>\nstring_xor(\"001\", \"010\"\
    )\n</cell>\n<code language=julia-1.5>\nstring_xor(\"001\", \"001\")\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"001\", \"000\")\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"000\", \"001\")\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    000\", \"000\")\n</cell>\n<code language=julia-1.5>\nstring_xor(\"000\", \"100\"\
    )\n</cell>\n<code language=julia-1.5>\nstring_xor(\"100\", \"000\")\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"100\", \"100\")\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"100\", \"010\")\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    010\", \"100\")\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"010\"\
    )\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"110\", \"010\")\n</cell>\n<code language=julia-1.5>\n\
    string_", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if\
    \ length(a) != length(b) \n        error(\"Strings must have same length\")\n\
    \    elseif length(a) == 0 \n        error(\"Strings cannot be empty\")\n    elseif\
    \ length(a) == 1 \n        return b\n    elseif length(a) == 2 \n        return\
    \ a xor b\n    elseif length(a) == 3 \n        return a xor b xor c\n    elseif\
    \ length(a) == 4 \n        return a xor b xor c xor d\n    elseif length(a) ==\
    \ 5 \n        return a xor b xor c xor d xor e\n    elseif length(a) == 6 \n \
    \       return a xor b xor c xor d xor e xor f\n    elseif length(a) == 7 \n \
    \       return a xor b xor c xor d xor e xor f xor g\n    elseif length(a) ==\
    \ 8 \n        return a xor b xor c xor d xor e xor f xor g xor h\n    elseif length(a)\
    \ == 9 \n        return a xor b xor c xor d xor e xor f xor g xor h xor i\n  \
    \  elseif length(a) == 10 \n        return a xor b xor c xor d xor e xor f xor\
    \ g xor h xor i xor j\n    elseif length(a) == 11 \n        return a xor b xor\
    \ c xor d xor e xor f xor g xor h xor i xor j xor k\n    elseif length(a) == 12\
    \ \n        return a xor b xor c xor d xor e xor f xor g xor h xor i xor j xor\
    \ k xor l\n    elseif length(a) == 13 \n        return a xor b xor c xor d xor\
    \ e xor f xor g xor h xor i xor j xor k xor l xor m\n    elseif length(a) == 14\
    \ \n        return a xor b xor c xor d xor e xor f xor g xor h xor i xor j xor\
    \ k xor l xor m xor n\n    elseif length(a) == 15 \n        return a xor b xor\
    \ c xor d xor e xor f xor g xor h xor i xor j xor k xor l xor m xor n xor o\n\
    \    elseif length(a) == 16 \n        return a xor b xor c ", "    if length(a)\
    \ == length(b) \n        then return string_xor(string_xor(a,b),a)\n        else\
    \ return string_xor(a,string_xor(b,a))\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(a) == length(b) \n        then return a\n        else return b\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>", "    if length(a) == length(b)\
    \ then\n        local c = 0\n        for i in a:gmatch(\"%d\") do c = c + i end\n\
    \        return string(\"%x\", c)\n    else\n        return \"Error\"\n    end\n\
    end\n</cell>\n<code language=julia-1.5>", "    \n    a_int::Int = toInt(a)\n \
    \   b_int::Int = toInt(b)\n    \n    a_xor_b::Int = a_int ^ b_int\n    \n    a_xor_b_str::String\
    \ = toChar(a_xor_b)\n    \n    return a_xor_b_str\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ converts a binary string to a decimal integer.\nThe function should take a string\
    \ as input and return the decimal integer as a string.\nThe function should raise\
    \ an error if the input string is not in binary format.\nThe function should raise\
    \ an error if the input string contains non-binary digits.\nThe function should\
    \ raise an error if the input string contains more than 1 binary digit.\nThe function\
    \ should raise an error if the input string contains more than 2 binary digits.\n\
    The function should raise an error if the input string contains more than 3 binary\
    \ digits.\nThe function should raise an error if the input string contains more\
    \ than 4 binary digits.\nThe function should raise an error if the input string\
    \ contains more than 5 binary digits.\nThe function should raise an error if the\
    \ input string contains more than 6 binary digits.\nThe function should raise\
    \ an error if the input string contains more than 7 binary digits.\nThe function\
    \ should raise an error if the input string contains more than 8 binary digits.\n\
    The function should raise an error if the input string contains more than 9 binary\
    \ digits.\nThe function should raise an error if the input string contains more\
    \ than 10 binary digits.\nThe function should raise an error if the input string\
    \ contains more than 11 binary digits.\nThe function should raise an error if\
    \ the input string contains more than 12 binary digits.\nThe function should raise\
    \ an error if the input string contains more than 13 binary digits.\nThe function\
    \ should raise an error if the input string contains more than 14 binary digits.\n\
    The function should raise an error if the input string contains more than 15 binary\
    \ digits.\nThe function should raise an error if the input string contains more\
    \ than 16 binary digits.\nThe function should raise an error if the input string\
    \ contains more than 17 binary digits.\nThe function should raise an error if\
    \ the input string contains more than 18 binary digits.\nThe function should raise\
    \ an error if the input string contains more than 19 binary digits.\nThe function\
    \ should raise an error if the input string contains more than 20 binary digits.\n\
    The function should raise an error if the input string contains more than 21 binary\
    \ digits.\nThe function should raise an error if the input string contains more\
    \ than 22 binary digits.\nThe function should raise an error if the input string\
    \ contains more than 23 binary digits.\nThe function should raise an error if\
    \ the input string contains more than 24 binary digits.\nThe function should raise\
    \ an error if the input string contains more than 25 binary digits.\nThe function\
    \ should raise an error if the input string contains more than 26 binary digits.\n\
    The function ", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", " \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if length(a) !=\
    \ length(b) \n        error(\"Strings must have same length\")\n    elseif length(a)\
    \ == 0 \n        error(\"String is empty\")\n    elseif length(a) == 1 \n    \
    \    return b\n    else\n        return a^b\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(a) != length(b) \n        error(\"Input strings have different lengths\"\
    )\n    elseif length(a) == 0 \n        return b\n    elseif length(b) == 0 \n\
    \        return a\n    elseif length(a) == 1 \n        return b\n    elseif length(b)\
    \ == 1 \n        return a\n    else\n        error(\"Input strings have different\
    \ lengths\")\n    end\nend\n</cell>\n<code language=julia-1.3>", "    if a==\"\
    \" || b==\"\"\n        return \"\"\n    else\n        return (a^b)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n\
    <text>\nExercise 3\nWrite a function that takes a string as input and returns\
    \ the number of 1s in the string.\n>>> count_ones(\"010\")\n3\n>>> count_ones(\"\
    1010\")\n4\n>>> count_ones(\"01010\")\n5\n>>> count_ones(\"101010\")\n6\n>>> count_ones(\"\
    10101010\")\n7\n>>> count_ones(\"101010101010\")\n8\n>>> count_ones(\"1010101010101010\"\
    )\n9\n>>> count_ones(\"10101010101010101010\")\n10\n>>> count_ones(\"101010101010101010101010\"\
    )\n11\n>>> count_ones(\"1010101010101010101010101010\")\n12\n>>> count_ones(\"\
    10101010101010101010101010101010\")\n13\n>>> count_ones(\"101010101010101010101010101010101010\"\
    )\n14\n>>> count_ones(\"1010101010101010101010101010101010101010\")\n15\n>>> count_ones(\"\
    10101010101010101010101010101010101010101010\")\n16\n>>> count_ones(\"101010101010101010101010101010101010101010101010\"\
    )\n17\n>>> count_ones(\"1010101010101010101010101010101010101010101010101010\"\
    )\n18\n>>> count_ones(\"101010101010101010101010101010101010101010101010101010101010\"\
    )\n19\n>>> count_ones(\"1010101010101010101010101010101010101010101010101010101010101010\"\
    )\n20\n>>> count_ones(\"10101010101010101010101010101010101010101010101010101010101010101010\"\
    )\n21\n>>> count_ones(\"10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010",
  "    if length(a) == length(b) \n        then return string_xor(string_xor(a,b),a)\n\
    \        else return string_xor(a,string_xor(b,a))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.0>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string as input and returns the number of 1s\
    \ in the string.\nThe function should work for strings of any length.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1", "    if length(a) != length(b) \n        error(\"Strings\
    \ must have same length\")\n    elseif length(a) == 0 \n        return b\n   \
    \ elseif length(b) == 0 \n        return a\n    elseif length(a) == 1 \n     \
    \   return b\n    elseif length(b) == 1 \n        return a\n    else\n       \
    \ return (a-b).to_string()\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    return bin(bin(a) ^ bin(b))[2:]\nend\n</cell>\n<code language=julia-1.0>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a string as input and returns the number of characters in the string.\
    \ \nFor example if the input is \"Hello World\" the output should be 5.", "  \
    \  if length(a) == length(b) \n        then return string_xor(string_xor(a,b),a)\n\
    \        else return string_xor(a,string_xor(b,a))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"\n    string_xor(a::String, b::String)::String",
  "    if length(a) != length(b) \n        error(\"Strings must have same length\"\
    )\n    else \n        return string_xor(string_xor(a,b),string_xor(a,b)) \nend\n\
    </cell>\n<code language=julia-1.4>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a string as input and returns the number\
    \ of characters in the string.\nIf no string is given as input then return 0.\n\
    If the string has only 1 character then return 1.\nIf the string has 2 characters\
    \ then return 2.\nIf the string has 3 characters then return 3.\nIf the string\
    \ has 4 characters then return 4.\nIf the string has 5 characters then return\
    \ 5.\nIf the string has 6 characters then return 6.\nIf the string has 7 characters\
    \ then return 7.\nIf the string has 8 characters then return 8.\nIf the string\
    \ has 9 characters then return 9.\nIf the string has 10 characters then return\
    \ 10.\nIf the string has 11 characters then return 11.\nIf the string has 12 characters\
    \ then return 12.\nIf the string has 13 characters then return 13.\nIf the string\
    \ has 14 characters then return 14.\nIf the string has 15 characters then return\
    \ 15.\nIf the string has 16 characters then return 16.\nIf the string has 17 characters\
    \ then return 17.\nIf the string has 18 characters then return 18.\nIf the string\
    \ has 19 characters then return 19.\nIf the string has 20 characters then return\
    \ 20.\nIf the string has 21 characters then return 21.\nIf the string has 22 characters\
    \ then return 22.\nIf the string has 23 characters then return 23.\nIf the string\
    \ has 24 characters then return 24.\nIf the string has 25 characters then return\
    \ 25.\nIf the string has 26 characters then return 26.\nIf the string has 27 characters\
    \ then return 27.\nIf the string has 28 characters then return 28.\nIf the string\
    \ has 29 characters then return 29.\nIf the string has 30 characters then return\
    \ 30.\nIf the string has 31 characters then return 31.\nIf the string has 32 characters\
    \ then return 32.\nIf the string has 33 characters then return 33.\nIf the string\
    \ has 34 characters then return 34.\nIf the string has 35 characters then return\
    \ 35.\nIf the string has 36 characters then return 36.\nIf the string has 37 characters\
    \ then return 37.\nIf the string has 38 characters then return 38.\nIf the string\
    \ has 39 characters then return 39.\nIf the string has 40 characters then return\
    \ 40.\nIf the string has 41 characters then return 41.\nIf the string has 42 characters\
    \ then return 42.\nIf the string has 43 characters then return 43.\nIf the string\
    \ has 44 characters then return 44.\nIf the string has 45 characters then return\
    \ 45.\nIf the string has 46 characters ", "    return a ^ b\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of characters\
    \ in the string.\nFor example, if the input string is \"hello\", the function\
    \ should return 5.\nHint: Use length() function", "    if length(a) == length(b)\
    \ then\n        local result = \"\"\n        for i in a:gmatch(\"%d\") do \n \
    \           local c = tostring(i) ^ tostring(b[i])\n            local d = tostring(i)\
    \ ^ tostring(b[i])\n            local e = tostring(i) ^ tostring(b[i])\n     \
    \       local f = tostring(i) ^ tostring(b[i])\n            local g = tostring(i)\
    \ ^ tostring(b[i])\n            local h = tostring(i) ^ tostring(b[i])\n     \
    \       local i = tostring(i) ^ tostring(b[i])\n            local j = tostring(i)\
    \ ^ tostring(b[i])\n            local k = tostring(i) ^ tostring(b[i])\n     \
    \       local l = tostring(i) ^ tostring(b[i])\n            local m = tostring(i)\
    \ ^ tostring(b[i])\n            local n = tostring(i) ^ tostring(b[i])\n     \
    \       local o = tostring(i) ^ tostring(b[i])\n            local p = tostring(i)\
    \ ^ tostring(b[i])\n            local q = tostring(i) ^ tostring(b[i])\n     \
    \       local r = tostring(i) ^ tostring(b[i])\n            local s = tostring(i)\
    \ ^ tostring(b[i])\n            local t = tostring(i) ^ tostring(b[i])\n     \
    \       local u = tostring(i) ^ tostring(b[i])\n            local v = tostring(i)\
    \ ^ tostring(b[i])\n            local w = tostring(i) ^ tostring(b[i])\n     \
    \       local x = tostring(i) ^ tostring(b[i])\n            local y = tostring(i)\
    \ ^ tostring(b[i])\n            local z = tostring(i) ^ tostring(b[i])\n     \
    \       local A = tostring(i) ^ tostring(b[i])\n            local B = tostring(i)\
    \ ^ tostring(b[i])\n            local C = tostring(i) ^ tostring(b[i])\n     \
    \       local D = tostring(i) ^ tostring(b[i])\n            local E = tostring(i)\
    \ ^ tostring(b[i])\n            local F = tostring(i) ^ tostring(b[i])\n     \
    \       local G = tostring(i) ^ tostring(b[i])\n            local H = tostring(i)\
    \ ^ tostring(b[i])\n            local I = tostring(i) ^ tostring(b[i])\n     \
    \       local J = tostring(i) ^ tostring(b[i])\n            local K = tostring(i)\
    \ ^ tostring(b[i])\n            local L = tostring(i) ^ tostring(b[i])\n     \
    \       local M = tostring(i) ^ tostring(b[i])\n            local N = tostring(i)\
    \ ^ ", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n\
    \    if length(a) == length(b) \n        \n        \n        \n        \n    \
    \    \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n", "    \n    if length(a) != length(b) \n        error(\"Strings\
    \ must have same length\")\n    \n    result =  \"\"\n    for i in each(a) \n\
    \        result .= if i == b[i] then \"0\" else \"1\"\n    return result\nend\n\
    </cell>\n<code language=julia-1.4>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that performs bitwise XOR on two strings a and b.\
    \ \nThe function should return result as a string.\nThe function should raise\
    \ an error if strings a and b are not of equal length.", "    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    \n    if length(a) == length(b) then\n\
    \        \n        local result = \"\"\n        \n        for i in a:gmatch(\"\
    %d\") do \n            \n            if i == \"1\" then\n                \n  \
    \              local j = 0\n                \n                for j in b:gmatch(\"\
    %d\") do \n                    \n                    if j == \"1\" then\n    \
    \                    \n                        result = result + \"0\"\n     \
    \                   \n                    else\n                        \n   \
    \                     result = result + \"1\"\n                        \n    \
    \                end\n                    \n                end\n            \
    \    \n            else\n                \n                result = result + \"\
    0\"\n                \n            end\n            \n        end\n        \n\
    \        return result\n        \n    else\n        \n        return \"Invalid\
    \ input\"\n        \n    end\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes two\
    \ strings a and b as input and returns the number of times each character occurs\
    \ in both strings.", "    return bin(a) xor bin(b) \nend", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    if length(a) != length(b) \n    \
    \    error(\"Strings must have same length\")\n    elseif length(a) == 0 \n  \
    \      return b\n    elseif length(b) == 0 \n        return a\n    elseif length(a)\
    \ == 1 \n        return b\n    elseif length(b) == 1 \n        return a\n    elseif\
    \ a[0] == b[0] \n        return string_xor(a[1:], b[1:])\n    else\n        error(\"\
    Strings must have same length\")\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    return bin(bin(a) xor bin(b))[2:]\n\
    end\n</cell>\n<code language=julia-1.4>\nstring_xor(\"010\", \"110\")\n</cell>\n\
    <text>\nExercise 3\nWrite a function that performs bitwise XOR on two strings\
    \ and returns the result as a string.\nThe function should take two strings as\
    \ inputs and return the result as a string.\nThe function should also accept any\
    \ number of strings as inputs and return the same number of strings as inputs.\n\
    The function should also accept any number of strings as inputs and return the\
    \ same number of strings as inputs.\nThe function should also accept any number\
    \ of strings as inputs and return the same number of strings as inputs.\nThe function\
    \ should also accept any number of strings as inputs and return the same number\
    \ of strings as inputs.\nThe function should also accept any number of strings\
    \ as inputs and return the same number of strings as inputs.\nThe function should\
    \ also accept any number of strings as inputs and return the same number of strings\
    \ as inputs.\nThe function should also accept any number of strings as inputs\
    \ and return the same number of strings as inputs.\nThe function should also accept\
    \ any number of strings as inputs and return the same number of strings as inputs.\n\
    The function should also accept any number of strings as inputs and return the\
    \ same number of strings as inputs.\nThe function should also accept any number\
    \ of strings as inputs and return the same number of strings as inputs.\nThe function\
    \ should also accept any number of strings as inputs and return the same number\
    \ of strings as inputs.\nThe function should also accept any number of strings\
    \ as inputs and return the same number of strings as inputs.\nThe function should\
    \ also accept any number of strings as inputs and return the same number of strings\
    \ as inputs.\nThe function should also accept any number of strings as inputs\
    \ and return the same number of strings as inputs.\nThe function should also accept\
    \ any number of strings as inputs and return the same number of strings as inputs.\n\
    The function should also accept any number of strings as inputs and return the\
    \ same number of strings as inputs.\nThe function should also accept any number\
    \ of strings as inputs and return the same number of strings as inputs.\nThe function\
    \ should also accept any number of strings as inputs and return the same number\
    \ of strings as inputs.\nThe function should also accept any number of strings\
    \ as inputs and return the same number of strings as inputs.\nThe function should\
    \ also accept any number of strings as inputs and return the same number of strings\
    \ as inputs.\nThe function should also accept any number of strings as inputs\
    \ and return the same number of strings as inputs.\nThe function should also accept\
    \ any number of strings as inputs and return the same number of strings as inputs.\n\
    The function should also accept any number of strings as inputs and return the\
    \ same number of strings as inputs.\nThe function should also accept any number\
    \ of strings as inputs and return the same number of strings as inputs.\nThe function\
    \ should also ", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", " \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    if length(a)\
    \ != length(b) \n        error(\"Strings must have same length\")\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "    if length(a)\
    \ == length(b) \n        then return string_xor(string_xor(a,b),a)\n        else\
    \ return \"\"\n    else return \"\"\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(a) != length(b) then return \"Error\"\n    else return string_xor(string_xor(a,b),string_xor(b,a))\n\
    end", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if length(a)\
    \ == length(b) \n        then return string_xor(string_xor(a,b),a)\n        else\
    \ return string_xor(a,string_xor(b,a))\n    else return \"\"\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string as input and returns the number of characters\
    \ in the string. \nUse this function to solve the problem of counting the number\
    \ of characters in a string.", "    if length(a) != length(b) \n        error(\"\
    Strings must have same length\")\n    elseif length(a) == 0 \n        error(\"\
    String is empty\")\n    elseif length(a) == 1 \n        return b\n    elseif length(a)\
    \ == 2 \n        return a\n    elseif length(a) == 3 \n        return string_xor(a[1:2],\
    \ b) + a[1]\n    elseif length(a) == 4 \n        return string_xor(a[1:3], b)\
    \ + a[1] + a[2]\n    elseif length(a) == 5 \n        return string_xor(a[1:4],\
    \ b) + a[1] + a[2] + a[3]\n    elseif length(a) == 6 \n        return string_xor(a[1:5],\
    \ b) + a[1] + a[2] + a[3] + a[4]\n    elseif length(a) == 7 \n        return string_xor(a[1:6],\
    \ b) + a[1] + a[2] + a[3] + a[4] + a[5]\n    elseif length(a) == 8 \n        return\
    \ string_xor(a[1:7], b) + a[1] + a[2] + a[3] + a[4] + a[5] + a[6]\n    elseif\
    \ length(a) == 9 \n        return string_xor(a[1:8], b) + a[1] + a[2] + a[3] +\
    \ a[4] + a[5] + a[6] + a[7]\n    elseif length(a) == 10 \n        return string_xor(a[1:9],\
    \ b) + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8]\n    elseif length(a)\
    \ == 11 \n        return string_xor(a[1:10], b) + a[1] + a[2] + a[3] + a[4] +\
    \ a[5] + a[6] + a[7] + a[8] + a[9]\n    elseif length(a) == 12 \n        return\
    \ string_xor(a[1:11], b) + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8]\
    \ + a[9] + a[10]\n    elseif length(a) == 13 \n        return string_xor(a[1:12],\
    \ b) + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9] + a[10] +\
    \ a[11]\n    elseif length(a) == 14 \n        return string_xor(a[1:13], b) +\
    \ a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9] + a[10] + a[11]\
    \ + a[12]\n    elseif length(a) == 15 \n        return string_xor(a[1:14], b)\
    \ + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9] + a[10] + a[11]\
    \ + a[12] + a[13]\n    elseif length(a) == 16 \n        return string_xor(a",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    if length(a)\
    \ != length(b) \n        error(\"Strings must have same length\")\n    end\n \
    \   \n    res=\"\"\n    for i in eachindex(a) \n        res=res+(a[i]^b[i])\n\
    \    end\n    return res\nend\n</cell>\n<code language=julia-1.3>", "    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    if length(a) != length(b)\
    \ \n        error(\"Strings must have same length\")\n    else \n        string_xor\
    \ = zeros(length(a))\n        for i in 1:length(a)\n            string_xor[i]\
    \ = (a[i] xor b[i])\n        end\n        return string_xor\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    if length(a) != length(b) then return \"\" \n   \
    \ else return string_xor(string_xor(a,b),string_xor(b,a))\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if length(a) !=\
    \ length(b) \n        error(\"Strings must have same length\")\n    elseif length(a)\
    \ == 0 \n        error(\"String is empty\")\n    elseif length(a) == 1 \n    \
    \    return b\n    else\n        return (a^b)\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    return bin(bin(a) ^ bin(b))[2:]\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a string as input and returns the number of 1s in the string.\n>>> count_ones(\"\
    010\")\n3\n>>> count_ones(\"10101010\")\n10\n>>> count_ones(\"101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if length(a) ==\
    \ length(b) then\n        local result = \"\"\n        for i in a:gmatch(\"%d\"\
    ) do \n            local temp = i\n            local j = 0\n            while\
    \ j < length(b) do\n                local k = j\n                while k < length(b)\
    \ and b[k] == temp do k = k + 1 end\n                local temp = temp * 2\n \
    \               j = j + 1\n            end\n            result = result + tostring(temp)\n\
    \        end\n        return result\n    else\n        return \"Invalid input\"\
    \n    end\nend\n</cell>\n<code language=julia-1.4>", "    if a==\"\" || b==\"\"\
    \n        return \"\"\n    else\n        return (a^b)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if\
    \ length(a) != length(b) \n        error(\"Strings must have same length\")\n\
    \    else if length(a) == 0 \n        error(\"String is empty\")\n    else if\
    \ length(a) == 1 \n        return b\n    else \n        return a^b\nend\n</cell>\n\
    <code language=julia-1.0>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a string and returns the number of characters\
    \ in the string. \nFor example string_length(\"hello\") should return 5.", " \
    \   return a^b\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"\
    110\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes two strings a\
    \ and b and returns their concatenation, i.e. the string formed by concatenating\
    \ a and b. \n>>> string_concat(\"hello\", \"world\")\n\"helloworld\"\n>>> string_concat(\"\
    hello\", \"world\", \"!\")\n\"helloworld!\"\n>>> string_concat(\"hello\", \"world\"\
    , \"!\", \" \", \"and\", \"goodbye\", \"!\")\n\"hello world and goodbye!\"\n>>>\
    \ string_concat(\"hello\", \"world\", \"!\", \" \", \"and\", \"goodbye\", \"!\"\
    , \" \", \"and\", \"goodbye\", \"!\")\n\"hello world and goodbye goodbye!\"\n\
    >>> string_concat(\"hello\", \"world\", \"!\", \" \", \"and\", \"goodbye\", \"\
    !\", \" \", \"and\", \"goodbye\", \"!\", \" \", \"and\", \"goodbye\", \"!\")\n\
    \"hello world and goodbye goodbye goodbye!\"\n>>> string_concat(\"hello\", \"\
    world\", \"!\", \" \", \"and\", \"goodbye\", \"!\", \" \", \"and\", \"goodbye\"\
    , \"!\", \" \", \"and\", \"goodbye\", \"!\", \" \", \"and\", \"goodbye\", \"!\"\
    )\n\"hello world and goodbye goodbye goodbye goodbye!\"\n>>> string_concat(\"\
    hello\", \"world\", \"!\", \" \", \"and\", \"goodbye\", \"!\", \" \", \"and\"\
    , \"goodbye\", \"!\", \" \", \"and\", \"goodbye\", \"!\", \" \", \"and\", \"goodbye\"\
    , \"!\", \" \", \"and\", \"goodbye\", \"!\")\n\"hello world and goodbye goodbye\
    \ goodbye goodbye goodbye!\"\n>>> string_concat(\"hello\", \"world\", \"!\", \"\
    \ \", \"and\", \"goodbye\", \"!\", \" \", \"and\", \"goodbye\", \"!\", \" \",\
    \ \"and\", \"goodbye\", \"!\", \" \", \"and\", \"goodbye\", \"!\", \" \", \"and\"\
    , \"goodbye\", \"!\", \" \", \"and\", \"goodbye\", \"!\")\n\"hello world and goodbye\
    \ goodbye goodbye goodbye goodbye goodbye!\"\n>>> string_concat(\"hello\", \"\
    world\", \"!\", \" \", \"and\", \"goodbye\", \"!\", \" \", \"and\", \"goodbye\"\
    , \"!\", \" \", \"and\", \"goodbye\", \"!\", \" \", \"and\", \"goodbye\", \"!\"\
    , \" \", \"and", "    \n    if length(a) == length(b) \n        \n        \n \
    \       if length(a) == 0 \n            return \"0\"\n        \n        if length(b)\
    \ == 0 \n            return \"0\"\n        \n        if a[0] == b[0] \n      \
    \      return string_xor(a[1:], b[1:])\n        \n        else \n            return\
    \ string_xor(a[1:], b)\n        \n    else \n        return \"0\"\n    \nend\n\
    </cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that takes as input a binary string and returns the\
    \ string with all 0s replaced by 1s and all 1s replaced by 0s.\nFor example, if\
    \ the input string is \"010\", the function should return \"100\".\nIf the input\
    \ string is \"011\", the function should return \"101\".\nIf the input string\
    \ is \"100\", the function should return \"100\".\nIf the input string is \"101\"\
    , the function should return \"101\".\nIf the input string is \"110\", the function\
    \ should return \"100\".\nIf the input string is \"111\", the function should\
    \ return \"101\".\nIf the input string is \"000\", the function should return\
    \ \"000\".\nIf the input string is \"001\", the function should return \"001\"\
    .\nIf the input string is \"010\", the function should return \"100\".\nIf the\
    \ input string is \"011\", the function should return \"101\".\nIf the input string\
    \ is \"100\", the function should return \"100\".\nIf the input string is \"101\"\
    , the function should return \"101\".\nIf the input string is \"110\", the function\
    \ should return \"100\".\nIf the input string is \"111\", the function should\
    \ return \"101\".\nIf the input string is \"000\", the function should return\
    \ \"000\".\nIf the input string is \"001\", the function should return \"001\"\
    .\nIf the input string is \"010\", the function should return \"100\".\nIf the\
    \ input string is \"011\", the function should return \"101\".\nIf the input string\
    \ is \"100\", the function should return \"100\".\nIf the input string is \"101\"\
    , the function should return \"101\".\nIf the input string is \"110\", the function\
    \ should return \"100\".\nIf the input string is \"111\", the function should\
    \ return \"101\".\nIf the input string is \"000\", the function should return\
    \ \"000\".\nIf the input string is \"001\", the function should return \"001\"\
    .\nIf the input string is \"010\", the function should return \"100\".\nIf the\
    \ input string is \"011\", the function should return \"101\".\nIf the input string\
    \ is \"100", "    if length(a) != length(b) \n        error(\"Strings must have\
    \ same length\")\n    elseif length(a) == 0 \n        error(\"Strings must have\
    \ length > 0\")\n    elseif length(a) == 1 \n        return b\n    elseif length(a)\
    \ == 2 \n        return a ^ b\n    elseif length(a) == 3 \n        return a ^\
    \ b ^ a\n    elseif length(a) == 4 \n        return a ^ b ^ a ^ b\n    elseif\
    \ length(a) == 5 \n        return a ^ b ^ a ^ b ^ a\n    elseif length(a) == 6\
    \ \n        return a ^ b ^ a ^ b ^ a ^ b\n    elseif length(a) == 7 \n       \
    \ return a ^ b ^ a ^ b ^ a ^ b ^ a\n    elseif length(a) == 8 \n        return\
    \ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b\n    elseif length(a) == 9 \n        return a\
    \ ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a\n    elseif length(a) == 10 \n        return\
    \ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b\n    elseif length(a) == 11 \n       \
    \ return a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a\n    elseif length(a) == 12\
    \ \n        return a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b\n    elseif length(a)\
    \ == 13 \n        return a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a\n \
    \   elseif length(a) == 14 \n        return a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a\
    \ ^ b ^ a ^ b ^ a\n    elseif length(a) == 15 \n        return a ^ b ^ a ^ b ^\
    \ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b\n    elseif length(a) == 16 \n       \
    \ return a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a\n    elseif\
    \ length(a) == 17 \n        return a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^\
    \ b ^ a ^ b ^ a\n    elseif length(a) == 18 \n        return a ^ b ^ a ^ b ^ a\
    \ ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a\n    elseif length(a) == 19 \n     \
    \   return a ^ ", "    return bin(bin(a) xor bin(b))[2:]\nend\n</cell>\n<code\
    \ language=julia-1.0>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string as input and returns the number of 1s\
    \ in the string.\nThe function should ignore all whitespace characters and return\
    \ 0 if the string contains no 1s.\n>>> count_ones(\"   0111 \")\n4\n>>> count_ones(\"\
    0111\")\n4\n>>> count_ones(\"0111 \")\n4\n>>> count_ones(\"0111 0\")\n4\n>>> count_ones(\"\
    0111 0 \")\n4\n>>> count_ones(\"0111 0 0\")\n4\n>>> count_ones(\"0111 0 0 \")\n\
    4\n>>> count_ones(\"0111 0 0 0 \")\n4\n>>> count_ones(\"0111 0 0 0 0\")\n4\n>>>\
    \ count_ones(\"0111 0 0 0 0 \")\n4\n>>> count_ones(\"0111 0 0 0 0    \")\n4\n\
    >>> count_ones(\"0111 0 0 0 0    0\")\n4\n>>> count_ones(\"0111 0 0 0 0    0 \"\
    )\n4\n>>> count_ones(\"0111 0 0 0 0    0 0\")\n4\n>>> count_ones(\"0111 0 0 0\
    \ 0    0 0 \")\n4\n>>> count_ones(\"0111 0 0 0 0    0 0 0 \")\n4\n>>> count_ones(\"\
    0111 0 0 0 0    0 0 0 0\")\n4\n>>> count_ones(\"0111 0 0 0 0    0 0 0 0 \")\n\
    4\n>>> count_ones(\"0111 0 0 0 0    0 0 0 0    \")\n4\n>>> count_ones(\"0111 0\
    \ 0 0 0    0 0 0 0    0\")\n4\n>>> count_ones(\"0111 0 0 0 0    0 0 0 0    0 \"\
    )\n4\n>>> count_ones(\"0111 0 0 0 0    0 0 0 0    0 0\")\n4\n>>> count_ones(\"\
    0111 0 0 0 0    0 0 0 0    0 0 \")\n4\n>>> count_ones(\"0111 0 0 0 0    0 0 0\
    \ 0    0 0 0 \")\n4\n>>> count_ones(\"0111 0 0 0 0    0 0 0 0    0 0 0 0\")\n\
    4\n>>> count_ones(\"0111 0 0 0 0    0 0 0 0    0 0 0 0    \")\n4\n>>> count_ones(\"\
    0111 0 0 0 0    0 0 0 0    0 0 0 0    0\")\n4\n>>> count_ones(\"0111 0 0 0 0 \
    \   0 0 0 0    0 0 0 0    0 \")\n4\n>>> count_ones(\"0111 0 0 0 0    0 0 0 0 \
    \   0 0 0 0    0 ", "    if length(a) == length(b) then \n        return \"\"\n\
    \    else \n        return a^b\nend\n</cell>\n<code language=julia-1.4>\nstring_xor(\"\
    010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes two\
    \ strings as inputs and returns a string consisting of the number of 1's in each\
    \ string. \nFor example, \"010\" should return \"2\". \nThe function should ignore\
    \ the case of the characters. \nThe function should ignore leading zeroes. \n\
    The function should ignore trailing zeroes. \nThe function should ignore leading\
    \ or trailing spaces. \nThe function should ignore leading or trailing commas.\
    \ \nThe function should ignore leading or trailing periods. \nThe function should\
    \ ignore leading or trailing dashes. \nThe function should ignore leading or trailing\
    \ underscores. \nThe function should ignore leading or trailing colons. \nThe\
    \ function should ignore leading or trailing colons. \nThe function should ignore\
    \ leading or trailing colons. \nThe function should ignore leading or trailing\
    \ colons. \nThe function should ignore leading or trailing colons. \nThe function\
    \ should ignore leading or trailing colons. \nThe function should ignore leading\
    \ or trailing colons. \nThe function should ignore leading or trailing colons.\
    \ \nThe function should ignore leading or trailing colons. \nThe function should\
    \ ignore leading or trailing colons. \nThe function should ignore leading or trailing\
    \ colons. \nThe function should ignore leading or trailing colons. \nThe function\
    \ should ignore leading or trailing colons. \nThe function should ignore leading\
    \ or trailing colons. \nThe function should ignore leading or trailing colons.\
    \ \nThe function should ignore leading or trailing colons. \nThe function should\
    \ ignore leading or trailing colons. \nThe function should ignore leading or trailing\
    \ colons. \nThe function should ignore leading or trailing colons. \nThe function\
    \ should ignore leading or trailing colons. \nThe function should ignore leading\
    \ or trailing colons. \nThe function should ignore leading or trailing colons.\
    \ \nThe function should ignore leading or trailing colons. \nThe function should\
    \ ignore leading or trailing colons. \nThe function should ignore leading or trailing\
    \ colons. \nThe function should ignore leading or trailing colons. \nThe function\
    \ should ignore leading or trailing colons. \nThe function should ignore leading\
    \ or trailing colons. \nThe function should ignore leading or trailing colons.\
    \ \nThe function should ignore leading or trailing colons. \nThe function should\
    \ ignore leading or trailing colons. \nThe function should ignore leading or trailing\
    \ colons. \nThe function should ignore leading or trailing colons. \nThe function\
    \ should ignore leading or trailing colons. \nThe function should ignore leading\
    \ or trailing colons. ", "    if length(a) != length(b) \n        error(\"Input\
    \ strings have different lengths\")\n    elseif length(a) == 0 \n        error(\"\
    Input strings are empty\")\n    elseif length(a) == 1 \n        return b\n   \
    \ else\n        return (a^b)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ converts a binary string to a decimal integer.\nThe function should accept a\
    \ string of 1s and 0s and return an integer representing the binary string.\n\
    The function should raise an error if the input string is not in binary form.\n\
    The function should raise an error if the input string contains more than 1 leading\
    \ 1.\nThe function should raise an error if the input string contains more than\
    \ 1 trailing 1.\nThe function should raise an error if the input string contains\
    \ more than 2 leading 0s.\nThe function should raise an error if the input string\
    \ contains more than 2 trailing 0s.\nThe function should raise an error if the\
    \ input string contains more than 4 leading 1s.\nThe function should raise an\
    \ error if the input string contains more than 4 trailing 1s.\nThe function should\
    \ raise an error if the input string contains more than 8 leading 0s.\nThe function\
    \ should raise an error if the input string contains more than 8 trailing 0s.\n\
    The function should raise an error if the input string contains more than 16 leading\
    \ 1s.\nThe function should raise an error if the input string contains more than\
    \ 16 trailing 1s.\nThe function should raise an error if the input string contains\
    \ more than 32 leading 0s.\nThe function should raise an error if the input string\
    \ contains more than 32 trailing 0s.\nThe function should raise an error if the\
    \ input string contains more than 64 leading 1s.\nThe function should raise an\
    \ error if the input string contains more than 64 trailing 1s.\nThe function should\
    \ raise an error if the input string contains more than 128 leading 0s.\nThe function\
    \ should raise an error if the input string contains more than 128 trailing 0s.\n\
    The function should raise an error if the input string contains more than 256\
    \ leading 1s.\nThe function should raise an error if the input string contains\
    \ more than 256 trailing 1s.\nThe function should raise an error if the input\
    \ string contains more than 512 leading 0s.\nThe function should raise an error\
    \ if the input string contains more than 512 trailing 0s.\nThe function should\
    \ raise an error if the input string contains more than 1024 leading 1s.\nThe\
    \ function should raise an error if the input string contains more than 1024 trailing\
    \ 1s.\nThe function should raise an error if the input string contains more than\
    \ 2048 leading 0s.\nThe function should raise an error if the input string contains\
    \ more than 2048 trailing 0s.\nThe function should raise an error if the input\
    \ string contains more than 4096 leading 1s.\nThe function should raise an error\
    \ if the input string contains more than ", "    if length(a) == length(b) then\n\
    \        local c = 0\n        for i in a:gmatch(\"%0*b\") do c = c + i end\n \
    \       return c\n    else\n        return \"Invalid input\"\n    end\nend\n</cell>\n\
    <code language=julia-1.3>", "    \n    if length(a) != length(b) \n        error(\"\
    Strings must have same length\")\n    else \n        \n        ans = \"\"\n  \
    \      for i in each(a) \n            ans = ans + char2int(i)^char2int(b[i])\n\
    \        \n        return ans\nend\n</cell>\n<code language=julia-1.5>", "   \
    \ return a^b\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    string_xor(a::String,\
    \ b::String)::String\n    Perform binary XOR on two strings a and b and return\
    \ result also as a string.\n    >>> string_xor(\"010\", \"110\")\n    \"100\"\n\
    \    \"\"\"", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", " \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    if length(a)\
    \ == length(b) \n        \n        if length(a) == 0 \n            return b \n\
    \        \n        if length(b) == 0 \n            return a \n        \n     \
    \   if a[0] == b[0] \n            return string_xor(a[1:], b[1:]) \n        \n\
    \        return string_xor(a[1:], b) + a[0] \n    \n    else \n        return\
    \ \"\"\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n\
    </cell>\n<text>\nExercise 2\nWrite a function that takes a string as input and\
    \ returns the number of 1s in the string.\nThe function should ignore leading\
    \ zeros in the string.\nThe function should ignore trailing zeros in the string.\n\
    The function should ignore spaces.\nThe function should ignore non-numeric characters.\n\
    The function should ignore leading spaces.\nThe function should ignore trailing\
    \ spaces.\nThe function should ignore leading zeros and spaces.\nThe function\
    \ should ignore trailing zeros and spaces.\nThe function should ignore leading\
    \ spaces and trailing spaces.\nThe function should ignore leading spaces and trailing\
    \ zeros and spaces.\nThe function should ignore leading zeros and trailing spaces.\n\
    The function should ignore trailing spaces and trailing zeros and spaces.\nThe\
    \ function should ignore leading spaces, trailing spaces and trailing zeros and\
    \ spaces.\nThe function should ignore leading zeros, trailing spaces and trailing\
    \ zeros and spaces.\nThe function should ignore leading spaces, trailing spaces\
    \ and trailing zeros and spaces.\nThe function should ignore leading zeros, trailing\
    \ spaces and trailing zeros and spaces.\nThe function should ignore leading spaces,\
    \ trailing spaces, trailing zeros and spaces.\nThe function should ignore leading\
    \ zeros, trailing spaces, trailing zeros and spaces.\nThe function should ignore\
    \ leading spaces, trailing spaces, trailing zeros and spaces.\nThe function should\
    \ ignore leading zeros, trailing spaces, trailing zeros and spaces.\nThe function\
    \ should ignore leading spaces, trailing spaces, trailing zeros and spaces.\n\
    The function should ignore leading zeros, trailing spaces, trailing zeros and\
    \ spaces.\nThe function should ignore leading spaces, trailing spaces, trailing\
    \ zeros and spaces.\nThe function should ignore leading zeros, trailing spaces,\
    \ trailing zeros and spaces.\nThe function should ignore leading spaces, trailing\
    \ spaces, trailing zeros and spaces.\nThe function should ignore leading zeros,\
    \ trailing spaces, trailing zeros and spaces.\nThe function should ignore leading\
    \ spaces, trailing spaces, trailing zeros and spaces.\nThe function should ignore\
    \ leading zeros, trailing spaces, trailing zeros and spaces.\nThe function should\
    \ ignore leading spaces, trailing spaces, trailing zeros and spaces.\nThe function\
    \ should ignore leading zeros, trailing ", "    if length(a) != length(b) then\
    \ return \"Invalid input\"\n    else return string_xor(string_xor(a,b),string_xor(b,a))\n\
    end\n</cell>\n<code language=julia-1.5>", "    if length(a) == length(b) then\n\
    \        local result = \"\"\n        for i in a:gmatch(\"%d\") do \n        \
    \    local c = tostring(i) ^ tostring(b[i])\n            result += tostring(c)\n\
    \        end\n        return result\n    else\n        return \"Invalid input\"\
    \n    end\nend\n</cell>\n<text>\nExercise 4\nWrite a function that performs bitwise\
    \ AND on two strings a and b consisting only of 1s and 0s.\n    Perform bitwise\
    \ AND on these inputs and return result also as a string.\n    >>> string_and(\"\
    010\", \"110\")\n    \"100\"\n    \"\"\"", "    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    if length(a) != length(b) \n        error(\"\
    Strings must have same length\")\n    elseif length(a) == 0 \n        error(\"\
    Strings must have length > 0\")\n    elseif length(a) == 1 \n        return b\n\
    \    elseif length(a) == 2 \n        return a\n    elseif length(a) == 3 \n  \
    \      return a\n    elseif length(a) == 4 \n        return a\n    elseif length(a)\
    \ == 5 \n        return a\n    elseif length(a) == 6 \n        return a\n    elseif\
    \ length(a) == 7 \n        return a\n    elseif length(a) == 8 \n        return\
    \ a\n    elseif length(a) == 9 \n        return a\n    elseif length(a) == 10\
    \ \n        return a\n    elseif length(a) == 11 \n        return a\n    elseif\
    \ length(a) == 12 \n        return a\n    elseif length(a) == 13 \n        return\
    \ a\n    elseif length(a) == 14 \n        return a\n    elseif length(a) == 15\
    \ \n        return a\n    elseif length(a) == 16 \n        return a\n    elseif\
    \ length(a) == 17 \n        return a\n    elseif length(a) == 18 \n        return\
    \ a\n    elseif length(a) == 19 \n        return a\n    elseif length(a) == 20\
    \ \n        return a\n    elseif length(a) == 21 \n        return a\n    elseif\
    \ length(a) == 22 \n        return a\n    elseif length(a) == 23 \n        return\
    \ a\n    elseif length(a) == 24 \n        return a\n    elseif length(a) == 25\
    \ \n        return a\n    elseif length(a) == 26 \n        return a\n    elseif\
    \ length(a) == 27 \n        return a\n    elseif length(a) == 28 \n        return\
    \ a\n    elseif length(a) == 29 \n        return a\n    elseif length(a) == 30\
    \ \n        return a\n    elseif length(a) == 31 \n        return a\n    elseif\
    \ length(a) == 32 \n        return a\n    elseif length(a) == 33 \n        return\
    \ a\n    elseif length(a) == 34 \n        return a\n    elseif length(a) == 35\
    \ \n        return a\n    elseif length(a) == 36 \n        return a\n    elseif\
    \ length(a) == 37 \n        return a\n    elseif length(a) == 38 \n        return\
    \ a\n    elseif length(a) == 39 \n        return a\n    elseif length(a) == 40\
    \ \n        return a\n    elseif length(a) == 41 \n        return a\n    elseif\
    \ length(a) == 42 \n        return a\n    elseif length(a) == 43 \n        return\
    \ a\n    elseif length(a) == 44 \n        return a\n    elseif length(a) == 45\
    \ \n        return a\n    elseif length(a) == 46 \n        return a\n    elseif\
    \ length(a) == 47 \n        return a\n    elseif ", "    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "    if length(a) == length(b) \n        then return string_xor(string_xor(a,b),a)\n\
    \        else return string_xor(a,string_xor(b,a))\n    else return \"\"\nend\n\
    </cell>\n<code language=julia-1.0>\n\"\"\"\n    string_xor(a::String, b::String)::String\n\
    \    Perform binary XOR on two strings a and b and return result as a string.\n\
    \    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\"\"", "    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    return a xor b\nend\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that performs bitwise XOR on two strings a and b and returns\
    \ the result as a string.\nThe function should take two strings as inputs and\
    \ return one string as output.\nThe function should perform bitwise XOR on these\
    \ inputs and return result also as a string.\nThe function should throw an error\
    \ if the inputs are not strings.\nThe function should throw an error if the inputs\
    \ are not of equal length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\nThe function\
    \ should throw an error if the inputs are not of equal length or if the inputs\
    \ are of different length.\nThe function should throw an error if the inputs are\
    \ not of equal length or if the inputs are of different length.\n", "    \n  \
    \  if length(a) != length(b) \n        error(\"Strings must have same length\"\
    )\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    ", "    if length(a) != length(b) \n        error(\"Strings must have same\
    \ length\")\n    elseif length(a) == 0 \n        error(\"Strings must have length\
    \ > 0\")\n    elseif length(a) == 1 \n        return b\n    else\n        return\
    \ (a^b)\n    end\nend\n</cell>\n<code language=julia-1.5>", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    if length(a) != length(b) \n        error(\"Input strings must be of equal\
    \ length.\")\n    elseif length(a) == 0 \n        error(\"Input strings must be\
    \ of non-zero length.\")\n    elseif length(a) == 1 \n        return b\n    elseif\
    \ length(a) == 2 \n        return a xor b\n    elseif length(a) == 3 \n      \
    \  return a xor b xor c\n    elseif length(a) == 4 \n        return a xor b xor\
    \ c xor d\n    elseif length(a) == 5 \n        return a xor b xor c xor d xor\
    \ e\n    elseif length(a) == 6 \n        return a xor b xor c xor d xor e xor\
    \ f\n    elseif length(a) == 7 \n        return a xor b xor c xor d xor e xor\
    \ f xor g\n    elseif length(a) == 8 \n        return a xor b xor c xor d xor\
    \ e xor f xor g xor h\n    elseif length(a) == 9 \n        return a xor b xor\
    \ c xor d xor e xor f xor g xor h xor i\n    elseif length(a) == 10 \n       \
    \ return a xor b xor c xor d xor e xor f xor g xor h xor i xor j\n    elseif length(a)\
    \ == 11 \n        return a xor b xor c xor d xor e xor f xor g xor h xor i xor\
    \ j xor k\n    elseif length(a) == 12 \n        return a xor b xor c xor d xor\
    \ e xor f xor g xor h xor i xor j xor k xor l\n    elseif length(a) == 13 \n \
    \       return a xor b xor c xor d xor e xor f xor g xor h xor i xor j xor k xor\
    \ l xor m\n    elseif length(a) == 14 \n        return a xor b xor c xor d xor\
    \ e xor f xor g xor h xor i xor j xor k xor l xor m xor n\n    elseif length(a)\
    \ == 15 \n        return a xor b xor c xor d xor e xor f xor g xor h xor i xor\
    \ j xor k xor l xor m xor n xor o\n    elseif length(a) == 16 \n        return\
    \ a xor ", "    if length(a) == length(b) \n        then return string_xor(string_xor(a,b),a)\n\
    \        else return string_xor(a,string_xor(b,a))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string as input and returns the number of characters\
    \ in the string. \nUse this function to find the number of characters in the string\
    \ \"Hello World\".\nHint: Use length() function.", "    if length(a) != length(b)\
    \ then return \"Invalid input\"\n    else for i in each(a) do if a[i] != b[i]\
    \ then return \"Invalid input\" end\n    return a\nend\n</cell>\n<code language=julia-1.4>",
  "    if a==\"\" || b==\"\"\n        return \"\"\n    else\n        return (a^b)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\"\
    )\n</cell>\n<code language=julia-1.5>", "    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    if length(a) == length(b) then\n        local x = 0\n\
    \        for i in a:gmatch(\"%d\") do x = x + (i == '1') end\n        return tostring(x)\n\
    \    else\n        return \"Invalid input\"\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(a) == length(b) \n        then return string_xor(string_xor(a,b),string_xor(a,b))\
    \ \n        else return string_xor(a,string_xor(b,a)) \n    else return \"\"\n\
    end\n</cell>\n<code language=julia-1.5>", "    if length(a) != length(b) \n  \
    \      error(\"Strings must have same length\")\n    else \n        return a^b\n\
    end\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string as input and returns\
    \ the number of 1s in the string.\n>>> count_ones(\"010\")\n3\n>>> count_ones(\"\
    1010\")\n2\n>>> count_ones(\"01010\")\n4\n>>> count_ones(\"010100\")\n5\n>>> count_ones(\"\
    0101001\")\n6\n>>> count_ones(\"01010010\")\n7\n>>> count_ones(\"010100100\")\n\
    8\n>>> count_ones(\"0101001000\")\n9\n>>> count_ones(\"01010010000\")\n10\n>>>\
    \ count_ones(\"010100100000\")\n11\n>>> count_ones(\"0101001000000\")\n12\n>>>\
    \ count_ones(\"01010010000000\")\n13\n>>> count_ones(\"010100100000000\")\n14\n\
    >>> count_ones(\"0101001000000000\")\n15\n>>> count_ones(\"01010010000000000\"\
    )\n16\n>>> count_ones(\"010100100000000000\")\n17\n>>> count_ones(\"0101001000000000000\"\
    )\n18\n>>> count_ones(\"01010010000000000000\")\n19\n>>> count_ones(\"010100100000000000000\"\
    )\n20\n>>> count_ones(\"0101001000000000000000\")\n21\n>>> count_ones(\"01010010000000000000000\"\
    )\n22\n>>> count_ones(\"010100100000000000000000\")\n23\n>>> count_ones(\"0101001000000000000000000\"\
    )\n24\n>>> count_ones(\"01010010000000000000000000\")\n25\n>>> count_ones(\"010100100000000000000000000\"\
    )\n26\n>>> count_ones(\"0101001000000000000000000000\")\n27\n>>> count_ones(\"\
    01010010000000000000000000000\")\n28\n>>> count_ones(\"010100100000000000000000000000\"\
    )\n29\n>>> count_ones(\"0101001000000000000000000000000\")\n30\n>>> count_ones(\"\
    01010010000000000000000000000000\")\n31\n>>> count_ones(\"010100100000000000000000000000000\"\
    )\n32\n>>> count_ones(\"0101001000000000000000000000000000\")\n33\n>>> count_ones(\"\
    01010010000000000000000000000000000\")\n34\n>>> count_ones(\"010100100000000000000000000000000000\"\
    )\n35\n>>> count_one", "    return string_to_bits(a) ^ string_to_bits(b)\nend\n\
    </cell>\n<code language=julia-1.0>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that converts a binary string to a decimal integer.\n\
    The function should take two arguments: a binary string and a base (an integer).\n\
    The function should return the decimal integer represented by the binary string.\n\
    The function should raise an error if the base is not in the range 2 to 36.\n\
    The function should raise an error if the base is zero.\nThe function should raise\
    \ an error if the base is negative (but only if the binary string contains at\
    \ least one zero).\nThe function should raise an error if the binary string contains\
    \ more than one zero.\nThe function should raise an error if the binary string\
    \ contains more than one '1'.\nThe function should raise an error if the binary\
    \ string contains more than one '0'.\nThe function should raise an error if the\
    \ binary string contains more than one '1' and more than one '0'.\nThe function\
    \ should raise an error if the binary string contains more than one '1' and more\
    \ than one '0'.\nThe function should raise an error if the binary string contains\
    \ more than one '1' and more than one '0'.\nThe function should raise an error\
    \ if the binary string contains more than one '1' and more than one '0'.\nThe\
    \ function should raise an error if the binary string contains more than one '1'\
    \ and more than one '0'.\nThe function should raise an error if the binary string\
    \ contains more than one '1' and more than one '0'.\nThe function should raise\
    \ an error if the binary string contains more than one '1' and more than one '0'.\n\
    The function should raise an error if the binary string contains more than one\
    \ '1' and more than one '0'.\nThe function should raise an error if the binary\
    \ string contains more than one '1' and more than one '0'.\nThe function should\
    \ raise an error if the binary string contains more than one '1' and more than\
    \ one '0'.\nThe function should raise an error if the binary string contains more\
    \ than one '1' and more than one '0'.\nThe function should raise an error if the\
    \ binary string contains more than one '1' and more than one '0'.\nThe function\
    \ should raise an error if the binary string contains more than one '1' and more\
    \ than one '0'.\nThe function should raise an error if the binary string contains\
    \ more than one '1' and more than one '0'.\nThe function should raise an error\
    \ if the binary string contains more than one '1' and more than one '0'.\nThe\
    \ function should raise an error if the binary string contains more than one '1'\
    \ and more than one '0'.\nThe function should raise an error if the binary string\
    \ contains more than one '1' and more than one '0'.\nThe function should raise\
    \ an error if the binary string contains more than one '1' and more than one '0'.\n\
    The function should raise an error if the binary string contains more than one\
    \ '1' and more than one '0'.\nThe function should raise ", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    if length(a) == length(b) \n    \
    \    then return string_xor(string_xor(a,b),a)\n        else return string_xor(a,string_xor(b,a))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    if length(a) == length(b)\
    \ \n        then return a\n        else return b\n    end\n    ", "    if length(a)\
    \ != length(b) then return \"Invalid input\"\n    else for i in each(a) do \n\
    \        if a[i] != b[i] then return \"Invalid input\"\n    else return a\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work if `a` and `b` are strings of different\
    \ lengths. For example, `string_xor(\"010\", \"100\")` returns `\"Invalid input\"\
    `.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it\n<|/ c |>\n<| c |>\nI\
    \ fixed it now\n<|/ c |>\n<| c |>\nI fixed it now\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "    return a^b\nend\n</cell>\n<code language=julia-1.0>\nstring_xor(\"\
    010\", \"110\")\n</cell>\n<text>\nExercise 3\nWrite a function that performs bitwise\
    \ XOR on two strings a and b and returns the result as a string.\nThe function\
    \ should take two strings a and b as input and return the same strings as output.\n\
    The function should perform bitwise XOR on two strings a and b and return the\
    \ result as a string.\nThe function should perform bitwise XOR on two strings\
    \ a and b and return the result as a string.\nThe function should perform bitwise\
    \ XOR on two strings a and b and return the result as a string.\nThe function\
    \ should perform bitwise XOR on two strings a and b and return the result as a\
    \ string.\nThe function should perform bitwise XOR on two strings a and b and\
    \ return the result as a string.\nThe function should perform bitwise XOR on two\
    \ strings a and b and return the result as a string.\nThe function should perform\
    \ bitwise XOR on two strings a and b and return the result as a string.\nThe function\
    \ should perform bitwise XOR on two strings a and b and return the result as a\
    \ string.\nThe function should perform bitwise XOR on two strings a and b and\
    \ return the result as a string.\nThe function should perform bitwise XOR on two\
    \ strings a and b and return the result as a string.\nThe function should perform\
    \ bitwise XOR on two strings a and b and return the result as a string.\nThe function\
    \ should perform bitwise XOR on two strings a and b and return the result as a\
    \ string.\nThe function should perform bitwise XOR on two strings a and b and\
    \ return the result as a string.\nThe function should perform bitwise XOR on two\
    \ strings a and b and return the result as a string.\nThe function should perform\
    \ bitwise XOR on two strings a and b and return the result as a string.\nThe function\
    \ should perform bitwise XOR on two strings a and b and return the result as a\
    \ string.\nThe function should perform bitwise XOR on two strings a and b and\
    \ return the result as a string.\nThe function should perform bitwise XOR on two\
    \ strings a and b and return the result as a string.\nThe function should perform\
    \ bitwise XOR on two strings a and b and return the result as a string.\nThe function\
    \ should perform bitwise XOR on two strings a and b and return the result as a\
    \ string.\nThe function should perform bitwise XOR on two strings a and b and\
    \ return the result as a string.\nThe function should perform bitwise XOR on two\
    \ strings a and b and return the result as a ", "    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    return bin(bin(a) xor bin(b))[2:]\nend\n</cell>\n\
    <code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a string as input and returns the number of characters\
    \ in the string. \nUse this function to find the number of characters in the string\
    \ \"hello\".", "    \n    if length(a) != length(b) \n        error(\"Length of\
    \ strings must match\")\n    else \n        \n        ans = \"\"\n        for\
    \ i in each(a)\n            ans = ans + b[i]\n        end\n        \n        return\
    \ ans\n    end\nend", "    if length(a) == length(b) \n        then return string_xor(string_xor(a,b),a)\n\
    \        else return string_xor(a,string_xor(b,a))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    return bin(bin(a) ^ bin(b))[2:]\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ converts a binary string to a decimal integer. \nFor example \"010\" -> 8, \"\
    110\" -> 17, \"100\" -> 2 etc.\nThe function should raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should also raise an exception if it encounters\
    \ a non-integer string.\nThe function should also raise an exception if it encounters\
    \ a non-binary string.\nThe function should ", "    if length(a) == length(b)\
    \ \n        then return \"\"\n        else return string_xor(string_xor(a,b),a)\n\
    \    end\n    if length(a) > length(b) \n        then return string_xor(a,string_xor(b,a))\n\
    \        else return string_xor(string_xor(a,b),b)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string as input and returns the string with\
    \ all the characters in lower case and all the characters in upper case replaced\
    \ by their respective ASCII values.", "    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    if length(a) != length(b) \n        error(\"Strings\
    \ must have same length\")\n    elseif length(a) == 0 \n        error(\"Strings\
    \ must have length > 0\")\n    elseif length(a) == 1 \n        return b\n    else\n\
    \        return (a^b)\n    end\nend\n</cell>\n<code language=julia-1.0>", "  \
    \  if length(a) != length(b) \n        error(\"Strings must have same length\"\
    )\n    elseif length(a) == 0 \n        error(\"String is empty\")\n    elseif\
    \ length(a) == 1 \n        return b\n    elseif length(a) == 2 \n        return\
    \ a\n    elseif length(a) == 3 \n        return string_xor(a[1:2], b[1:2])\n \
    \   elseif length(a) == 4 \n        return string_xor(a[1:3], b[1:3])\n    elseif\
    \ length(a) == 5 \n        return string_xor(a[1:4], b[1:4])\n    elseif length(a)\
    \ == 6 \n        return string_xor(a[1:5], b[1:5])\n    elseif length(a) == 7\
    \ \n        return string_xor(a[1:6], b[1:6])\n    elseif length(a) == 8 \n  \
    \      return string_xor(a[1:7], b[1:7])\n    elseif length(a) == 9 \n       \
    \ return string_xor(a[1:8], b[1:8])\n    elseif length(a) == 10 \n        return\
    \ string_xor(a[1:9], b[1:9])\n    elseif length(a) == 11 \n        return string_xor(a[1:10],\
    \ b[1:10])\n    elseif length(a) == 12 \n        return string_xor(a[1:11], b[1:11])\n\
    \    elseif length(a) == 13 \n        return string_xor(a[1:12], b[1:12])\n  \
    \  elseif length(a) == 14 \n        return string_xor(a[1:13], b[1:13])\n    elseif\
    \ length(a) == 15 \n        return string_xor(a[1:14], b[1:14])\n    elseif length(a)\
    \ == 16 \n        return string_xor(a[1:15], b[1:15])\n    elseif length(a) ==\
    \ 17 \n        return string_xor(a[1:16], b[1:16])\n    elseif length(a) == 18\
    \ \n        return string_xor(a[1:17], b[1:17])\n    elseif length(a) == 19 \n\
    \        return string_xor(a[1:18], b[1:18])\n    elseif length(a) == 20 \n  \
    \      return string_xor(a[1:19], b[1:19])\n    elseif length(a) == 21 \n    \
    \    return string_xor(a[1:20], b[1:20])\n    elseif length(a) == 22 \n      \
    \  return string_xor(a[1:21], b[1:21])\n    elseif length(a) == 23 \n        return\
    \ string_xor(a[1:22], b[1:22])\n    elseif length(a) == 24 \n        return string_xor(a[1:23],\
    \ b[1:23])\n    elseif length(a) == 25 \n        return string_xor(a[1:24], b[1:24])\n\
    \    elseif length(a) == 26 \n        return string_xor(a[1:25], b[1:25])\n  \
    \  elseif length(a) == 27 \n        return string_xor(a[1:26], b[1:", "    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    if length(a) != length(b)\
    \ \n        error(\"Length of strings must be equal\")\n    end\n    \n    ans\
    \ = \"\"\n    for i in eachindex(a)\n        ans = ans + char(a[i]) ^ char(b[i])\n\
    \    end\n    return ans\nend\n</cell>\n<code language=julia-1.5>", "    if length(a)\
    \ == length(b) \n        then return \"\"\n        else return string_xor(string_xor(a,b),string_xor(b,a))\n\
    \    end\n    if length(a) == 0 \n        then return b\n        else return a\n\
    \    end\n    if length(b) == 0 \n        then return a\n        else return b\n\
    \    end\n    if a[1] == '0' and b[1] == '0' \n        then return string_xor(a[2:end],\
    \ b[2:end])\n        else return string_xor(a[1:end-1], b[1:end-1])\n    end\n\
    end\n</cell>\n<code language=julia-1.5>", "    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    \n    if length(a) == length(b) \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n", "    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    if length(a) != length(b) then return \"Error\"\
    \ else return a^b end\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that checks whether\
    \ a string is a palindrome or not.\nHint: Use reverse function.", "    if length(a)\
    \ == length(b) \n        then return \"\"\n        else return string_xor(string_xor(a,b),string_xor(b,a))\n\
    \    end\n    ", "    if length(a) == length(b) then \n        return \"\"\n \
    \   else \n        return string_xor(string_xor(a,b),string_xor(b,a))\nend\n</cell>\n\
    <code language=julia-1.5>", "    if length(a) == length(b) then\n        local\
    \ result = \"\"\n        for i = 1, length(a) do\n            if a[i] == b[i]\
    \ then\n                result = result + a[i]\n            else\n           \
    \     result = result + \"0\"\n            end\n        end\n        return result\n\
    \    else\n        return \"0\"\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    return a xor b\nend\n</cell>\n<code language=julia-1.3>\nstring_xor(\"010\"\
    , \"110\")\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string\
    \ as input and returns the number of 1s in the string.\n>>> count_ones(\"010\"\
    )\n3\n>>> count_ones(\"011\")\n2\n>>> count_ones(\"1010\")\n4\n>>> count_ones(\"\
    1011\")\n1\n>>> count_ones(\"1110\")\n1\n>>> count_ones(\"1111\")\n0\n>>> count_ones(\"\
    11111\")\n1\n>>> count_ones(\"111111\")\n2\n>>> count_ones(\"1111111\")\n3\n>>>\
    \ count_ones(\"11111110\")\n4\n>>> count_ones(\"111111100\")\n5\n>>> count_ones(\"\
    1111111000\")\n6\n>>> count_ones(\"11111110000\")\n7\n>>> count_ones(\"111111100000\"\
    )\n8\n>>> count_ones(\"1111111000000\")\n9\n>>> count_ones(\"11111110000000\"\
    )\n10\n>>> count_ones(\"111111100000000\")\n11\n>>> count_ones(\"1111111000000000\"\
    )\n12\n>>> count_ones(\"11111110000000000\")\n13\n>>> count_ones(\"111111100000000000\"\
    )\n14\n>>> count_ones(\"1111111000000000000\")\n15\n>>> count_ones(\"11111110000000000000\"\
    )\n16\n>>> count_ones(\"111111100000000000000\")\n17\n>>> count_ones(\"1111111000000000000000\"\
    )\n18\n>>> count_ones(\"11111110000000000000000\")\n19\n>>> count_ones(\"111111100000000000000000\"\
    )\n20\n>>> count_ones(\"1111111000000000000000000\")\n21\n>>> count_ones(\"11111110000000000000000000\"\
    )\n22\n>>> count_ones(\"111111100000000000000000000\")\n23\n>>> count_ones(\"\
    1111111000000000000000000000\")\n24\n>>> count_ones(\"11111110000000000000000000000\"\
    )\n25\n>>> count_ones(\"111111100000000000000000000000\")\n26\n>>> count_ones(\"\
    1111111000000000000000000000000\")\n27\n>>> count_ones(\"11111110000000000000000000000000\"\
    )\n28\n>>> count_ones(\"111111100000000000000000000000000\")\n29\n>>> count_ones(\"\
    1111111000000000000000000000000000\")\n30\n>>> count_ones(\"11111110000000000000000000000000000\"\
    )\n31\n>>> count_ones(\"111111100000000000000000000000000000\")\n32\n>>> count_ones(\"\
    1111111000000000000000000000000000000\")\n33\n>>> count_", "    if length(a) !=\
    \ length(b) \n        error(\"Strings must have same length\")\n    else \n  \
    \      return bin(bitxor(bits(a), bits(b)))[2:]\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(a) == length(b) \n        then return string_xor(string_xor(a,b),a)\n\
    \        else return string_xor(a,string_xor(b,a))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of characters\
    \ in it.\n>>> count_chars(\"Hello World\")\n12\n>>> count_chars(\"Hello World!\"\
    )\n13\n>>> count_chars(\"Hello World!!\")\n14\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )\n15\n>>> count_chars(\"Hello World!!!\")\n15\n>>> count_chars(\"Hello World!!!\"\
    )", "    if length(a) != length(b) \n        error(\"Input strings have different\
    \ lengths\")\n    else \n        string_xor = zeros(length(a))\n        for i\
    \ in 1:length(a)\n            string_xor[i] = (a[i] xor b[i])\n        end\n \
    \       return string_xor\nend\n</cell>\n<code language=julia-1.4>", "    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n", "    if length(a) != length(b) then return \"\
    \" \n    else \n        local result=\"\"\n        for i=1:length(a) do \n   \
    \         result=result + tostring(a[i]) ^ tostring(b[i]) \n        end\n    \
    \    return result\n    end\nend\n</cell>\n<code language=julia-1.3>", "    if\
    \ length(a) == length(b) \n        then return \"\"\n        else return string_xor(string_xor(a,b),a)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    \n    if length(a) ==\
    \ length(b) \n        \n        if length(a) == 0 \n            return b\n   \
    \     \n        if length(b) == 0 \n            return a\n        \n        if\
    \ a[0] == b[0] \n            return string_xor(a[1:], b[1:])\n        \n     \
    \   return string_xor(a[1:], b) + a[0]\n    \n    else \n        \n        if\
    \ length(a) == 0 \n            return b\n        \n        if length(b) == 0 \n\
    \            return a\n        \n        if a[0] == b[0] \n            return\
    \ string_xor(a[1:], b)\n        \n        return string_xor(a, b) + a[0]\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    string_xor(a::String, b::String)::String",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    if length(a) != length(b) \n        error(\"Strings\
    \ must have same length\")\n    else \n        result <- \"\"\n        for i in\
    \ 1:length(a) \n            result[i] <- a[i] ^ b[i]\n        return result\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    string_xor(a::String, b::String)::String\
    \ \n    Perform binary XOR on these inputs and return result also as a string.\n\
    \    >>> string_xor(\"010\", \"110\")\n    \"100\"\n    \"\"\"", "    if length(a)\
    \ == length(b) \n        then return \"\"\n        else return string_xor(string_xor(a,\
    \ b), b)\n    end\n    if length(a) > length(b) \n        then return string_xor(a,\
    \ string_xor(b, a))\n        else return string_xor(string_xor(a, b), a)\n   \
    \ end\nend\n</cell>\n<code language=julia-1.5>", "    return bin(bin(a) xor bin(b))[2:]\n\
    end\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string as input and returns\
    \ the number of times each character appears in the string. \nFor example if the\
    \ input string is \"abcabc\" the function should return {\"a\" => 3, \"b\" =>\
    \ 2, \"c\" => 3}.\nHint: Use a dictionary to store the counts. \nHint: Use a for\
    \ loop to iterate over the characters in the string.", "    if length(a) == length(b)\
    \ \n        then return string_xor(string_xor(a,b),a)\n        else return string_xor(a,string_xor(b,a))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    if length(a) == length(b)\
    \ \n        then return string_xor(string_xor(a,b),a)\n        else return string_xor(a,string_xor(b,a))\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>", "    if length(a) != length(b)\
    \ \n        error(\"Length of both strings must match\")\n    else \n        string_xor\
    \ = zeros(length(a))\n        for i in 1:length(a)\n            string_xor[i]\
    \ = (a[i] ^ b[i])\n        end\n        return string_xor\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    \n    if length(a) == length(b) \n        \n    \
    \    \n        if length(a) == 0 \n            return b\n        \n        if\
    \ length(b) == 0 \n            return a\n        \n        if a[0] == b[0] \n\
    \            return string_xor(a[1:], b[1:])\n        \n        if a[0] == b[-1]\
    \ \n            return string_xor(a[1:], b[:-1])\n        \n        if a[-1] ==\
    \ b[0] \n            return string_xor(a[:-1], b[1:])\n        \n        if a[-1]\
    \ == b[-1] \n            return string_xor(a[:-1], b[:-1])\n        \n    else\
    \ \n        \n        if length(a) == 0 \n            return b\n        \n   \
    \     if length(b) == 0 \n            return a\n        \n        if a[0] == b[0]\
    \ \n            return string_xor(a[1:], b[1:])\n        \n        if a[0] ==\
    \ b[-1] \n            return string_xor(a[1:], b[:-1])\n        \n        if a[-1]\
    \ == b[0] \n            return string_xor(a[:-1], b[1:])\n        \n        if\
    \ a[-1] == b[-1] \n            return string_xor(a[:-1], b[:-1])\n        \n \
    \   \n    \nend\n</cell>\n<code language=julia-1.5>", "    if length(a) != length(b)\
    \ then return \"Invalid input\" else return a^b\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ checks if a number is prime or not. \nThe function should take one integer as\
    \ input and return true or false accordingly.\nThe function should use trial division\
    \ method to determine if number is prime or not.", "    if length(a) == length(b)\
    \ then \n        string_xor_res = \"\"\n        for i in eachindex(a) do \n  \
    \          string_xor_res = string_xor_res + a[i] ^ b[i]\n        return string_xor_res\n\
    \    else\n        return \"Invalid input\"\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ performs bitwise XOR on two strings given as input. \nThe function should return\
    \ result also as a string.\n>>> string_xor(\"010\", \"110\")\n\"100\"\n>>> string_xor(\"\
    010\", \"010\")\n\"000\"\n>>> string_xor(\"010\", \"100\")\n\"010\"\n>>> string_xor(\"\
    010\", \"011\")\n\"100\"\n>>> string_xor(\"010\", \"1101\")\n\"100\"\n>>> string_xor(\"\
    010\", \"0101\")\n\"010\"\n>>> string_xor(\"010\", \"0100\")\n\"010\"\n>>> string_xor(\"\
    010\", \"0101\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010\")\n\"010\"\n>>> string_xor(\"010\", \"010\")\n\"010\"\n>>> string_xor(\"\
    010\", \"010", "    return bin(bin(a) ^ bin(b))[2:]\nend\n</cell>\n<code language=julia-1.3>\n\
    string_xor(\"010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ performs bitwise XOR on two strings given as input. \nThe function should return\
    \ result also as a string.\nThe function should work for strings of any length.\n\
    The function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for strings\
    \ of any number of 1s and 0s.\nThe function should work for strings of any number\
    \ of 1s and 0s.\nThe function should work for strings of any number of 1s and\
    \ 0s.\nThe function should work for strings of any number of 1s and 0s.\nThe function\
    \ should work for strings of any number of 1s and 0s.\nThe function should work\
    \ for strings of any number of 1s and 0s.\nThe function should work for string",
  "    if length(a) == length(b) \n        then return a\n        else return b\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"110\"\
    )\n</cell>\n<text>\nExercise 3\nWrite a function that takes in two strings and\
    \ returns the number of characters that are different between the two strings.\
    \ \nFor example if string1 = \"010\" and string2 = \"110\" then the function should\
    \ return 3.\nThe function should only count the characters that are different\
    \ between the two strings.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case of the characters.\n\
    The function should ignore the case of the characters.\nThe function should ignore\
    \ the case of the characters.\nThe function should ignore the case ", "    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    return bin(bin(a) xor\
    \ bin(b))[2:]\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"010\", \"\
    110\")\n</cell>\n<text>\nExercise 2\nWrite a function that converts a binary string\
    \ to a decimal integer.", "    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    if length(a) == length(b) \n        then return a\n        else\
    \ return b\n    else return b\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    010\", \"110\")\n</cell>\n<text>\nExercise 2\nWrite a function that takes a string\
    \ as input and returns the number of 1s in the string.\n>>> count_ones(\"010\"\
    )\n3\n>>> count_ones(\"1010\")\n2\n>>> count_ones(\"01010\")\n4\n>>> count_ones(\"\
    010100\")\n5\n>>> count_ones(\"01010001\")\n6\n>>> count_ones(\"010100011010\"\
    )\n7\n>>> count_ones(\"0101000110100\")\n8\n>>> count_ones(\"010100011010001\"\
    )\n9\n>>> count_ones(\"0101000110100011010\")\n10\n>>> count_ones(\"01010001101000110100\"\
    )\n11\n>>> count_ones(\"0101000110100011010001\")\n12\n>>> count_ones(\"01010001101000110100011010\"\
    )\n13\n>>> count_ones(\"010100011010001101000110100\")\n14\n>>> count_ones(\"\
    01010001101000110100011010001\")\n15\n>>> count_ones(\"010100011010001101000110100011010\"\
    )\n16\n>>> count_ones(\"0101000110100011010001101000110100\")\n17\n>>> count_ones(\"\
    010100011010001101000110100011010001\")\n18\n>>> count_ones(\"0101000110100011010001101000110100011010\"\
    )\n19\n>>> count_ones(\"01010001101000110100011010001101000110100\")\n20\n>>>\
    \ count_ones(\"0101000110100011010001101000110100011010001\")\n21\n>>> count_ones(\"\
    01010001101000110100011010001101000110100011010\")\n22\n>>> count_ones(\"010100011010001101000110100011010001101000110100\"\
    )\n23\n>>> count_ones(\"01010001101000110100011010001101000110100011010001\")\n\
    24\n>>> count_ones(\"010100", "    \n    if length(a) == length(b) \n        \n\
    \        a_array = map(xor, a, b) \n        \n        return join(a_array, \"\"\
    )\n    \n    else \n        \n        return \"Invalid input\"\nend\n</cell>\n\
    <code language=julia-1.5>", "    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    if a==\"\" || b==\"\"\n        return \"\"\n    elseif a==b\n \
    \       return a\n    else\n        return string_xor(a[1:length(a)-1], b[1:length(b)-1])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
