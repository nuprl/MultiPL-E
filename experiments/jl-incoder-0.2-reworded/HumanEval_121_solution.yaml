name: HumanEval_121_solution
language: jl
prompt: "\"\"\"Given a non-empty vector of integers, return the sum of all of the\
  \ odd elements that are in even positions.\n    \n\n    Examples\n    >>> solution([5,\
  \ 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30,\
  \ 13, 24, 321])\n    0\n    \"\"\"\nfunction solution(lst::Vector{Int64})::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = solution;\n\t@test(candidate([5,\
  \ 8, 7, 1]) == 12)\n\t@test(candidate([3, 3, 3, 3, 3]) == 9)\n\t@test(candidate([30,\
  \ 13, 24, 321]) == 0)\n\t@test(candidate([5, 9]) == 5)\n\t@test(candidate([2, 4,\
  \ 8]) == 0)\n\t@test(candidate([30, 13, 23, 32]) == 23)\n\t@test(candidate([3, 13,\
  \ 2, 9]) == 3)\nend\n"
completions: ["    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x\
    \ -> x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum even and odd elements of\
    \ a vector", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(x\
    \ -> x % 2 == 1, lst)\n    return odd + sum(x -> x in evens, lst)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Vectorized Solutions\nThe previous sections showed how we can solve\
    \ a problem by looping over all the elements. But Julia also has some built-in\
    \ functions which can solve a problem much more efficiently. Here are some examples:",
  "    evens = lst[findall(lst .== even(lst, 2))]\n    odds = lst[findall(lst .==\
    \ odd(lst, 2))]\n    return sum(odds .+ evens)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Game of Life\n\
    In this section, you will write a function to compute the next generation of cellular\
    \ automata.", "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, even) + filter(x\
    \ -> x % 2 != 1, odd))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Numbers Except Self\n\
    Given a vector of integers, return a vector of the same length with all numbers\
    \ in the vector except the number at index position index. \nIf index is greater\
    \ than or equal to the length of the vector, return an empty vector.", "    evens\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(lst[findall(x -> x % 2 !=\
    \ 0, lst)])\n    return odd + sum(evens)\nend\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that takes a vector of integers and returns the sum of the even elements\
    \ that are in odd positions.", "    \n    sum = 0\n    for x in lst\n        if\
    \ x % 2 == 1\n            sum += x\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype solution([5, 8, 7, 1])\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([3, 3, 3, 3, 3])\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([30, 13, 24, 321])\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the sum of the even elements\
    \ in a vector. \nFor example, given [5, 8, 7, 1], return 8.", "    \n    sum =\
    \ 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n        end\n\
    \    end\n    return sum\nend", "    \n    sum = 0\n    for i in lst\n       \
    \ if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nPart II: Recursion\nNow let's look at some more advanced concepts related\
    \ to recursion.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds =\
    \ lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(evens) + sum(odds)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart III. Finding all subsets of a set\nGiven a collection\
    \ of integers, return all possible subsets (without duplicates) of that collection.",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    \n    return sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. A recursive function can\
    \ have two types of inputs: base cases and recursive cases.", "    evens = lst[findall(lst\
    \ .== 0)]\n    odds = lst[findall(lst .== 1)]\n    return sum(filter(x -> x %\
    \ 2 == 1, odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the number of elements in a list that\
    \ satisfy a predicate p.", "    evens = filter(x -> x % 2 == 0, lst)\n    odds\
    \ = filter(x -> x % 2 != 0, lst)\n    \n    return sum(filter(x -> x % 2 == 1,\
    \ odds))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7,\
    \ 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13,\
    \ 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Even Elements", "    evens\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0,\
    \ lst)]\n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x -> x % 2\
    \ == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n@time solution([5, 8,\
    \ 7, 1])\n</cell>\n<code language=julia-1.5>\n@time solution([3, 3, 3, 3, 3])\n\
    </cell>\n<code language=julia-1.5>\n@time solution([30, 13, 24, 321])\n</cell>\n\
    <text>\nPart 4: Finding the first non-repeating character in a string\nThe first\
    \ non-repeating character in a string is the one that appears the least number\
    \ of times.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x\
    \ -> x % 2 == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum square difference\nGiven\
    \ a vector of numbers, calculate the sum of the squares of the numbers in the\
    \ vector.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions\nThe previous sections focused on solving problems individually. Here\
    \ we introduce a vectorized solution that is more efficient than a for loop.",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    \n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function has two parts:", "    sum = 0\n    for i in lst\n       \
    \ if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nPart II: Recursion\nA recursive function is a function that calls itself.\
    \ A recursive function can call itself within itself, either directly or indirectly.\
    \ For example, consider the Fibonacci sequence defined as:", "    \n    sum =\
    \ 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend", "    \n    sum = 0\n    for i in lst\n       \
    \ if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype solution([5, 8, 7, 1])\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([3, 3, 3, 3, 3])\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([30, 13, 24, 321])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the product of the even elements\
    \ in a given vector.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    sum(evens) + sum(odds)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part II: More on vectorization", "    \n    sum = 0\n    for i in lst\n      \
    \  if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nProblem 3\nWrite a function that returns a list of all numbers from 1\
    \ to n that are divisible by k.", "    evens = lst[findall(lst .== 0)]\n    odds\
    \ = lst[findall(lst .== 1)]\n    sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n\
    <text>\nProblem 8\nGiven a vector of ints, return a vector where each element\
    \ is the sum of the absolute values of the original elements.", "    evens = filter(x\
    \ -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n    return sum(x\
    \ -> x % 2 == 1, odds) + sum(x -> x % 2 == 0, evens)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: More on Vectors\n\
    The Julia language has many useful features for working with vectors. One of these\
    \ is the ability to index into vectors with an Int64 index. For example, we can\
    \ get the first element of a vector by indexing into it with the number 0:", " \
    \   evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x\
    \ % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x\
    \ -> x % 2 == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n@time solution([5,\
    \ 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@time solution([3, 3, 3, 3, 3])\n\
    </cell>\n<code language=julia-1.5>\n@time solution([30, 13, 24, 321])\n</cell>\n\
    <text>\nPart 2\nThe second problem involves finding the number of ways to partition\
    \ a set of numbers into two subsets such that the sum of the subsets is as close\
    \ as possible to some target sum.", "    evens = lst[findall(lst .== 0)]\n   \
    \ odds = lst[findall(lst .== 1)]\n    sum(filter(x -> x % 2 == 1, odds))\nend\n\
    </cell>\n<text>\nProblem 9\nWrite a function that returns the number of elements\
    \ in a list that do not appear in another list. ", "    evens = lst[findall(lst\
    \ .== 0)]\n    odds = lst[findall(lst .== 1)]\n    sum(filter(x -> x % 2 == 1,\
    \ odds))\nend\n</cell>\n<code language=julia-1.5>\n@time solution(vec(1:10000));\n\
    </cell>\n<code language=julia-1.5>\n@time solution(vec(1:100000));\n</cell>\n\
    <code language=julia-1.5>\n@time solution(vec(1:1000000));\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:10000000));\n</cell>\n<code language=julia-1.5>\n@time solution(vec(1:100000000));\n\
    </cell>\n<code language=julia-1.5>\n@time solution(vec(1:1000000000));\n</cell>\n\
    <code language=julia-1.5>\n@time solution(vec(1:10000000000));\n</cell>\n<code\
    \ language=julia-1.5>\n@time solution(vec(1:100000000000));\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:1000000000000));\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:10000000000000));\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:100000000000000));\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:1000000000000000));\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:10000000000000000));\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:100000000000000000));\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:100000000000000000))\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:1000000000000000000))\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:10000000000000000000))\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:100000000000000000000))\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:1000000000000000000000))\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:10000000000000000000000))\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:100000000000000000000000))\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:1000000000000000000000000))\n</cell>", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nThe previous\
    \ sections showed how we can loop over an entire array and perform operations\
    \ on every element. Julia also has many built-in functions that can operate on\
    \ entire arrays at once.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n \
    \   odds = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x %\
    \ 2 == 1, odds)) + sum(filter(x -> x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Boolean Logic\n\
    Boolean logic is one of the most important concepts in programming, and is often\
    \ the subject of most introductory computer science courses. It is also the subject\
    \ of most computer science courses that involve the study of algorithms. In this\
    \ section, we will explore the concepts of boolean logic, which is an important\
    \ tool for solving problems in computer science.", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(evens) + sum(odds)\nend\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns the number of times a given substring appears in a given string.", " \
    \   sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n   \
    \     end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Except Self\nWrite a function that returns the sum of all integers in a given\
    \ vector except the number itself, if it is not itself included.", "    \n   \
    \ sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n   \
    \     end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([30, 13, 24, 321])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the product of all even elements in a given vector.", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions", "    even\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0,\
    \ lst)]\n    sum(filter(x -> x % 2 == 1, even))\nend\n</cell>\n<text>\nSolution\
    \ 2\nA more efficient solution is to use filter to filter out all even numbers\
    \ and then sum the remaining numbers.", "    evens = filter(x -> x % 2 == 0, lst)\n\
    \    odds = filter(x -> x % 2 != 0, lst)\n    sum(filter(x -> x % 2 == 1, odds))\n\
    end\n</cell>\n<text>\nSolution 2\nThis solution uses filter and reduce.", "  \
    \  sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.4>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum even numbers\
    \ in a vector\nGiven a vector of integers, return the sum of all of the even elements\
    \ that are in odd positions.", "    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Vectorized Solutions\nThe previous sections showed how we can loop over\
    \ an array. Julia also has some built-in functions that can do this for us.",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. A recursive function can\
    \ call itself to solve a problem that requires solving a smaller version of the\
    \ same problem.", "    sum = 0\n    for x in lst\n        if x % 2 == 1\n    \
    \        sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nExercise 2\nWrite a\
    \ function that returns the product of the even elements in a given vector.",
  "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(x -> x % 2 != 0,\
    \ lst)\n    return odd + sum(x -> x in evens, lst)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum square\
    \ difference\nGiven a vector of numbers, calculate the sum of the squares of the\
    \ numbers in the vector, except ignore the number 0 which has a squared value\
    \ of 0.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum\
    \ += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum all even\
    \ numbers in a vector", "    evens = lst[findall(lst .== 0)]\n    odds = lst[findall(lst\
    \ .== 1)]\n    sum(evens .* odds)\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nA recursive\
    \ function is a function that calls itself. A recursive function can have one\
    \ or more base cases. These base cases are the base cases for the recursion. For\
    \ example, a recursive function can have a base case that returns 0, or a base\
    \ case that returns 1.", "    evens = filter(x -> x % 2 == 0, lst)\n    odds =\
    \ filter(x -> x % 2 != 0, lst)\n    return sum(evens) + sum(odds)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Vectorized Functions\nJulia has many built-in functions that operate\
    \ on arrays. These functions are called \"vectorized\" functions. Vectorized functions\
    \ can often be more efficient than their non-vectorized counterparts. Vectorized\
    \ functions are also more concise and easier to read. Vectorized functions also\
    \ run faster.", "    \n    sum = 0\n    for x in lst\n        if x % 2 == 1\n\
    \            sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the product of the even elements that\
    \ are in odd positions.", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend", "  \
    \  evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x %\
    \ 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x\
    \ -> x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum even and odd elements of\
    \ a vector", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x ->\
    \ x % 2 != 0, lst)\n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n\
    <text>\nPart 3: Write a Julia function that takes a vector of integers and returns\
    \ the sum of the squares of the odd elements that are in even positions.\n    ",
  "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    return sum(evens)\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part II: More on Vectors\nIn this last part we will learn about vectors and how\
    \ they can be used in Julia.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x %\
    \ 2 == 1, odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum square\
    \ difference\nGiven a vector of numbers, calculate the sum of the squares of the\
    \ numbers in the vector, except ignore the number 0 which has a coefficient of\
    \ 1.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum +=\
    \ i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([30, 13, 24, 321])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns the number of elements in a vector that are less than a given value.",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Even\
    \ Elements", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(evens) + sum(odds)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@time solution(vec(1:100000));\n</cell>\n<text>\nProblem\
    \ 7\nWrite a function that returns the number of times a given substring appears\
    \ in a given string.", "    sum = 0\n    for x in lst\n        if x % 2 == 1\n\
    \            sum += x\n        end\n    end\n    return sum\nend", "    evens\
    \ = lst[findall(lst .== 0)]\n    odds = lst[findall(lst .== 1)]\n    \n    sum(evens[2:end-1]\
    \ .+ odds[2:end-1])\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([5,\
    \ 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([3, 3,\
    \ 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([30,\
    \ 13, 24, 321])\n</cell>\n<text>\nPart 2: Vectorized Solutions\nThe previous solution\
    \ was inefficient because it was iterating over every element in the vector. Vectorized\
    \ solutions avoid this by using the .== operator to find the indices of elements\
    \ that meet a certain condition. Then, we can use those indices to extract only\
    \ the elements that meet the condition. Finally, we can use these indices to sum\
    \ up the odd elements in the even positions.", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@time solution(vec(1:10000));\n</cell>\n\
    <text>\nProblem 7\nWrite a function that returns the number of times the value\
    \ 1 appears in a given vector.", "    \n    sum = 0\n    for x in lst\n      \
    \  if x % 2 == 1\n            sum += x\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart II: Vectorized Solutions\nJulia has several ways to\
    \ vectorize code. One of the most common ways is to vectorize over arrays. For\
    \ example, if we want to find the sum of all elements in a vector, we can use\
    \ sum:", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n         \
    \   sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([30, 13, 24, 321])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the sum of the even elements in a given vector of integers. You may\
    \ assume that the vector has at least two elements.", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    sum(evens)\
    \ + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([5,\
    \ 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([3, 3,\
    \ 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([30,\
    \ 13, 24, 321])\n</cell>\n<text>\nExercise 2\nWrite a function that returns the\
    \ sum of the even elements in a given vector of integers. \nFor example, given\
    \ [5, 8, 7, 1], return 13.", "    \n    sum = 0\n    for i in lst\n        if\
    \ i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nProblem 7", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n\
    \            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Problem 7", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n      \
    \      sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.4>\n\
    @test solution([5, 8, 7, 1]) == 12\n@test solution([3, 3, 3, 3, 3]) == 9\n@test\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nQuestion 3\nWrite a function\
    \ that returns the number of times a given value appears in a given vector.",
  "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(lst[findall(x ->\
    \ x % 2 != 0, lst)])\n    return odd + sum(evens)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:1000000));\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns the number of times a given value appears in a given vector.",
  "    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n  \
    \      end\n    end\n    return sum\nend", "    \n    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24,\
    \ 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@time solution(vec(1:1000000));\n\
    </cell>\n<text>\nPart III: Binary Search\nBinary search is a search algorithm\
    \ that finds an element in a sorted array by dividing the array into two halves\
    \ and searching for the middle element in the middle half.", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    sum(evens)\
    \ + sum(odds)\nend\n</cell>\n<text>\nProblem 7\nWrite a function that returns\
    \ the number of times a given substring appears in a given string.", "    sum\
    \ = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n       \
    \ end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@time\
    \ solution(vec(1:10000000));\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the sum of the numbers in the list that have even positions.", "   \
    \ evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. This can be done in Julia\
    \ by defining a function with the keyword recursive and calling it with the function\
    \ name as a parameter. For example, consider the following recursive function:",
  "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(x -> x % 2 != 0,\
    \ lst)\n    return odd + sum(x -> x in evens, lst)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Disappeared in an Array", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(filter(x ->\
    \ x % 2 == 1, odd))\nend\n</cell>\n<code language=julia-1.5>\n@time solution(vec(1:100000));\n\
    </cell>\n<text>\nProblem 7\nWrite a function that returns the number of times\
    \ a given value appears in a given vector.", "    evens = lst[findall(x -> x %\
    \ 2 == 0, lst)]\n    odd = sum(evens[2:end-1])\n    return odd\nend\n</cell>\n\
    <code language=julia-1.5>\n@time solution(vec(1:1000000));\n</cell>\n<text>\n\
    Part II: Parallelization\nJulia has several ways to parallelize code. One of the\
    \ most common is to use @parallel. Let's see how it works.", "    evens = lst[findall(lst\
    \ .== 0)]\n    odds = lst[findall(lst .== 1)]\n    sum(filter(x -> x % 2 == 1,\
    \ odds))\nend\n</cell>\n<text>\nProblem 7\nWrite a function that returns a list\
    \ of all integers between two given integers, inclusive.", "    even = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2 != 0, lst)]\n    sum(filter(x\
    \ -> x % 2 == 1, even))\nend\n</cell>\n<text>\nProblem 3\nGiven a vector of strings,\
    \ return the number of strings that start with a given prefix.", "    evens =\
    \ lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0,\
    \ lst)]\n    \n    sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum all the\
    \ numbers in a file\nIn this part of the exercise, you will write a function that\
    \ will sum the numbers in a given file. The function will take one argument, filename,\
    \ and will read the file contents into a vector of Int64 numbers. Your function\
    \ will then return the sum of all the numbers in the file.", "    even = lst[findall(lst\
    \ .== 0)]\n    odd = lst[findall(lst .== 1)]\n    sum(filter(x -> x % 2 == 1,\
    \ odd))\nend\n</cell>\n<code language=julia-1.5>\n@time solution([5, 8, 7, 1])\n\
    </cell>\n<code language=julia-1.5>\n@time solution([3, 3, 3, 3, 3])\n</cell>\n\
    <code language=julia-1.5>\n@time solution([30, 13, 24, 321])\n</cell>\n<text>\n\
    Part 2\nWrite a function that takes a vector of integers and returns the number\
    \ of elements that are odd.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = sum(lst[findall(x -> x % 2 != 0, lst)])\n    return odd + sum(evens)\n\
    end\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([5, 8, 7, 1])\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype solution([3, 3, 3, 3, 3])\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype solution([30, 13, 24, 321])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the sum of the first\
    \ n even numbers. \nFor example, if the first argument were 3, the function should\
    \ return 7.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(evens) + sum(odds)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Vectorized Solutions\nNow that we've seen how to solve a problem with\
    \ a single for loop, let's see how we could vectorize it.", "    sum = 0\n   \
    \ for i in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n\
    \    return sum\nend", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1,\
    \ odds)) + sum(filter(x -> x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:100000));\n</cell>\n<text>\nPart 2: Recursion\nA recursive\
    \ function is one that calls itself. A recursive function can often be more efficient\
    \ than a non-recursive function in some cases. A recursive function can often\
    \ be more readable than a non-recursive function in some cases.", "    \n    sum\
    \ = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nA recursive function\
    \ is a function that calls itself. A recursive function can have two types of\
    \ inputs: base cases and recursive cases.", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nThe previous section showed\
    \ how to solve a problem with a single for loop. Here we will show how to solve\
    \ a problem with a single for loop and a vectorized solution.", "    \n    sum\
    \ = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nA recursive function\
    \ is a function that calls itself. A recursive function can have two types of\
    \ inputs:", "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum\
    \ += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions\nIn this section, you will write your own functions to solve the problems\
    \ above. \nYou will need to use Julia's vectorized functions to speed up your\
    \ computations.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(lst[findall(x\
    \ -> x % 2 != 0, lst)])\n    return odd + sum(evens)\nend", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@time solution([5,\
    \ 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@time solution([3, 3, 3, 3, 3])\n\
    </cell>\n<code language=julia-1.5>\n@time solution([30, 13, 24, 321])\n</cell>\n\
    <text>\nPart 2: Vectorized Solutions\nThe previous solution was inefficient because\
    \ it iterated over every element in the vector. Vectorized solutions avoid this\
    \ by using the same operation on every element in the vector. Julia has many built-in\
    \ vectorized functions. In this exercise, you'll write your own vectorized solution.",
  "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend", "    \n    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24,\
    \ 321]) == 0\n</cell>\n<text>\nProblem 7\nWrite a function that returns the number\
    \ of times the given element appears in the given vector.", "    sum = 0\n   \
    \ for i in lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.0>\n@code_warntype solution([5,\
    \ 8, 7, 1])\n</cell>\n<code language=julia-1.0>\n@code_warntype solution([3, 3,\
    \ 3, 3, 3])\n</cell>\n<code language=julia-1.0>\n@code_warntype solution([30,\
    \ 13, 24, 321])\n</cell>\n<text>\nExercise 2\nWrite a function that returns the\
    \ product of the even elements in a given vector of integers. \n    ", "    evens\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(lst[findall(x -> x % 2 !=\
    \ 0, lst)])\n    return odd + sum(evens)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:1000000));\n</cell>\n<text>\nPart 2\nWrite a function that\
    \ returns the number of times a given element appears in a given vector.", " \
    \   \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend", "    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24,\
    \ 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odd = sum(evens[2:end-1])\n    return odd\nend\n</cell>\n\
    <text>\nProblem 3\nWrite a function that returns the sum of the numbers in the\
    \ list provided as an argument.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(evens) + sum(odds)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nA vectorized solution is\
    \ one that does not use loops. In Julia, vectorized solutions are written using\
    \ Julia's broadcasting syntax.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odds = lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(evens) +\
    \ sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8,\
    \ 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart 4: Recursion\nNow let's see how we\
    \ can use recursion to solve this problem. We'll start by writing a function that\
    \ calculates the factorial of a given number. We'll then use recursion to solve\
    \ the problem by calling this function with different values of n.", "    sum\
    \ = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nA recursive function\
    \ is a function that calls itself. A recursive function can have two types of\
    \ recursive calls: base cases and recursive cases. Base cases occur when the function\
    \ does not call itself recursively; recursive cases occur when the function calls\
    \ itself recursively.", "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1,\
    \ even) + filter(x -> x % 2 != 1, odd))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum square\
    \ difference\nGiven a vector of numbers, calculate the sum of the squares of the\
    \ numbers in the vector.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n \
    \   odds = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(evens) + sum(odds)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart III. Sum All Numbers Disappeared in an Array", "  \
    \  \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Functions\nJulia has many useful functions for performing computations on vectors\
    \ of numbers. These functions are called \"vectorized\" because they operate on\
    \ entire vectors at a time. For example, if we want to find the sum of all elements\
    \ in a vector, we could use the sum function:", "    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24,\
    \ 321]) == 0\n</cell>\n<text>\nExercise 3\nWrite a function that returns the sum\
    \ of the numbers in the list that have no duplicates.", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(evens) + sum(odds)\nend\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns the product of the elements of two vectors.", "    \n    sum = 0\n \
    \   for x in lst\n        if x % 2 == 1\n            sum += x\n        end\n \
    \   end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Numbers Except Self\n\
    Write a function that returns the sum of all integers except the number itself,\
    \ if there are multiple such numbers.", "    \n    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24,\
    \ 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nA vectorized solution\
    \ is one that uses Julia's built-in array type. Vectorized solutions are faster\
    \ than their non-vectorized counterparts, and they also use less memory. Vectorized\
    \ solutions are also more concise. Vectorized solutions are also more efficient.",
  "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nA recursive\
    \ function is a function that calls itself. In Julia, a recursive function is\
    \ defined with the function keyword.", "    evens = lst[findall(x -> x % 2 ==\
    \ 0, lst)]\n    odd = sum(x -> x % 2 != 0, lst)\n    return odd + sum(x -> x in\
    \ evens, lst)\nend\n</cell>\n<text>\nExercise 3\nWrite a function that returns\
    \ the sum of the squares of the numbers in a vector.", "    sum = 0\n    for x\
    \ in lst\n        if x % 2 == 1\n            sum += x\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.0>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Numbers Except Self\n\
    Given a vector of numbers, return a vector of the sum of all of the numbers in\
    \ the vector except the number itself.", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart II: Recursion\nA recursive function has the following\
    \ properties:", "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, even) + filter(x\
    \ -> x % 2 != 1, odd))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Numbers Within Each Range",
  "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x -> x % 2 != 0, lst)\n\
    \    \n    return sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Vectorized\
    \ Solutions\nJulia has several built-in functions that can help us solve these\
    \ problems more efficiently. One of these is sum, which can operate on arrays\
    \ of numbers. For example, if we want to find the sum of all numbers in a vector,\
    \ we can use the sum function:", "    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.0>\n@test solution([5, 8, 7, 1]) == 12\n@test solution([3,\
    \ 3, 3, 3, 3]) == 9\n@test solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Problem 7: Odd sum\nGiven a non-empty vector of integers, return the sum of all\
    \ of the odd elements that are in even positions.\n    ", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nA recursive function\
    \ is a function that calls itself. A recursive function can have two types of\
    \ recursive calls:", "    sum = 0\n    for x in lst\n        if x % 2 == 1\n \
    \           sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Sum All Numbers Except Self\nGiven a vector of integers, return a vector\
    \ consisting of the sum of all of the integers in the vector except the number\
    \ itself.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum\
    \ += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions\nThe previous sections showed how to use loops to solve a problem.\
    \ Julia also has built-in functions for doing this type of calculation. Here are\
    \ some examples:", "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 != 0, even)) + sum(filter(x\
    \ -> x % 2 == 0, odd))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nA recursive function\
    \ is a function that calls itself. A recursive function can have one or more base\
    \ cases. A base case is where a recursive function can stop calling itself and\
    \ return a value.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n    \
    \        sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. This can be done in Julia\
    \ by defining a function with the keyword recursive and calling it with the function\
    \ name as its argument. For example:", "    sum = 0\n    for x in lst\n      \
    \  if x % 2 == 1\n            sum += x\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart III. Vectorized Functions\nJulia has many built-in\
    \ functions that operate on arrays. These functions are called \"vectorized\"\
    \ because they operate on arrays of numbers. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vectorized counterparts. Vectorized functions are also more flexible\
    \ than their non-vectorized counterparts. For example, you can find the maximum\
    \ of a vector by using the max() function. Vectorized functions can often be faster\
    \ than their non-vector", "    even = lst[findall(x -> x % 2 == 0, lst)]\n   \
    \ odd = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(even) + sum(odd)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart III. Sum all the odd digits in a number", "    evens\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0,\
    \ lst)]\n    return sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum square\
    \ difference\nGiven a vector of numbers, compute the sum of the squares of the\
    \ numbers in the vector.", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype solution([3, 3, 3, 3, 3])\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype solution([30, 13, 24, 321])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the sum of the even elements in a vector. ",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions\nIn this section, you will write your own vectorized solutions to\
    \ the problems above. Your code will need to work with Julia's built-in array\
    \ types (Vector{Int64} and Vector{Float64}) and the standard library functions\
    \ sum and length.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(evens) + sum(odds)\nend",
  "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x % 2\
    \ != 0, lst)]\n    sum(filter(x -> x % 2 == 1, even))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Disappeared in an Array", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x in\
    \ odd, evens))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum square difference\nGiven\
    \ a vector of numbers, calculate the sum of the squares of the numbers in the\
    \ vector.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x\
    \ -> x % 2 == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nThe previous\
    \ solutions work well for small lists, but they suffer from poor performance for\
    \ large lists. Julia's built-in array types are optimized for working with large\
    \ vectors of numbers. In fact, Julia is optimized for working with arrays of numbers.\
    \ In fact, Julia is optimized for working with arrays of numbers. In fact, Julia\
    \ is optimized for working with arrays of numbers. In fact, Julia is optimized\
    \ for working with arrays of numbers. In fact, Julia is optimized for working\
    \ with arrays of numbers. In fact, Julia is optimized for working with arrays\
    \ of numbers. In fact, Julia is optimized for working with arrays of numbers.\
    \ In fact, Julia is optimized for working with arrays of numbers. In fact, Julia\
    \ is optimized for working with arrays of numbers. In fact, Julia is optimized\
    \ for working with arrays of numbers. In fact, Julia is optimized for working\
    \ with arrays of numbers. In fact, Julia is optimized for working with arrays\
    \ of numbers. In fact, Julia is optimized for working with arrays of numbers.\
    \ In fact, Julia is optimized for working with arrays of numbers. In fact, Julia\
    \ is optimized for working with arrays of numbers. In fact, Julia is optimized\
    \ for working with arrays of numbers. In fact, Julia is optimized for working\
    \ with arrays of numbers. In fact, Julia is optimized for working with arrays\
    \ of numbers. In fact, Julia is optimized for working with arrays of numbers.\
    \ In fact, Julia is optimized for working with arrays of numbers. In fact, Julia\
    \ is optimized for working with arrays of numbers. In fact, Julia is optimized\
    \ for working with arrays of numbers. In fact, Julia is optimized for working\
    \ with arrays of numbers. In fact, Julia is optimized for working with arrays\
    \ of numbers. In fact, Julia is optimized for working with arrays of numbers.\
    \ In fact, Julia is optimized for working with ", "    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.4>\n@time solution([5, 8, 7, 1])\n\
    </cell>\n<code language=julia-1.4>\n@time solution([3, 3, 3, 3, 3])\n</cell>\n\
    <code language=julia-1.4>\n@time solution([30, 13, 24, 321])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the sum of the first n positive integers. ",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Even\
    \ Elements", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n     \
    \       sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum all even\
    \ numbers in a vector\nGiven a non-empty vector of integers, return the sum of\
    \ all of the even elements that are in odd positions.", "    \n    sum = 0\n \
    \   for i in lst\n        if i%2 == 1\n            sum += i\n        end\n   \
    \ end\n    return sum\nend", "    even = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(filter(x ->\
    \ x % 2 == 1, even)) + sum(filter(x -> x % 2 != 1, odd))\nend\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the product of the even numbers in a\
    \ given list.", "    \n    sum = 0\n    for x in lst\n        if x % 2 == 1\n\
    \            sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part II: Vectorized Solutions\nOne of the most important parts of Julia is vectorization.\
    \ Julia is optimized for vectorized solutions. Vectorized solutions run much faster\
    \ than their non-vectorized counterparts. Vectorized solutions are also easier\
    \ to read and understand.", "    sum = 0\n    for i in lst\n        if i%2 ==\
    \ 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Vectorized Solutions\nThe previous sections showed how to solve a problem\
    \ in a single line. Julia also has built-in support for vectorized solutions.\
    \ These solutions are much faster than the single-element solutions, but they\
    \ also require a lot less code. Here are some examples:", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([3,\
    \ 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@code_warntype solution([30,\
    \ 13, 24, 321])\n</cell>\n<text>\nExercise 3\nWrite a function that returns the\
    \ sum of the first n positive integers less than or equal to n.", "    \n    sum\
    \ = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n       \
    \ end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.4>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nA recursive\
    \ function is a function that calls itself. This can be useful in many situations.\
    \ Here is an example of a recursive fibonacci function that computes the nth fibonacci\
    \ number:", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x\
    \ -> x % 2 != 1, evens))\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Dynamic Programming\nDynamic programming\
    \ is a technique for solving problems where the solution depends on the previous\
    \ results. For example, if you were trying to find the minimum distance between\
    \ any two points, you could start by looking at all the distances between the\
    \ first two points and storing them in a table. Then you could look through all\
    \ the distances between the second point and the first point and so on and so\
    \ forth.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum\
    \ += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. A recursive function can\
    \ be defined recursively, which means it calls itself. In Julia, a recursive function\
    \ is defined with the function keyword. For example, consider the following recursive\
    \ function:", "    sum = 0\n    for x in lst\n        if x % 2 == 1\n        \
    \    sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Vectorized\
    \ Solutions\nJulia has many built-in functions that operate on arrays. These include\
    \ sum, max, min, mean, median, etc.", "    \n    sum = 0\n    for i in lst\n \
    \       if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.3>\n@code_warntype solution([5, 8, 7, 1])\n\
    </cell>\n<code language=julia-1.3>\n@code_warntype solution([3, 3, 3, 3, 3])\n\
    </cell>\n<code language=julia-1.3>\n@code_warntype solution([30, 13, 24, 321])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the number of elements\
    \ in a vector that are less than a given value.", "    \n    sum = 0\n    for\
    \ x in lst\n        if x % 2 == 1\n            sum += x\n        end\n    end\n\
    \    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nProblem 7: Odd sum\nGiven a vector of integers,\
    \ find the sum of the odd integers. You may assume that the vector does not contain\
    \ any leading zero, except the number 0 itself. \nFor example, given [3, 30, 34,\
    \ 5, 9], return 15.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x % 2 == 1,\
    \ odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Vectorized\
    \ Solutions\nJulia has several ways to vectorize code. One way is to use broadcasting,\
    \ which allows you to write code that is more efficient than a for loop. Broadcasting\
    \ allows you to write code that is more efficient than a for loop, but also more\
    \ concise. Broadcasting also allows us to write code that is more readable and\
    \ maintainable. Broadcasting also allows us to write code that is more efficient\
    \ than a for loop, but also more concise. Broadcasting also allows us to write\
    \ code that is more readable and maintainable. Broadcasting also allows us to\
    \ write code that is more efficient than a for loop, but also more concise. Broadcasting\
    \ also allows us to write code that is more efficient than a for loop, but also\
    \ more concise. Broadcasting also allows us to write code that is more efficient\
    \ than a for loop, but also more concise. Broadcasting also allows us to write\
    \ code that is more efficient than a for loop, but also more concise. Broadcasting\
    \ also allows us to write code that is more efficient than a for loop, but also\
    \ more concise. Broadcasting also allows us to write code that is more efficient\
    \ than a for loop, but also more concise. Broadcasting also allows us to write\
    \ code that is more efficient than a for loop, but also more concise. Broadcasting\
    \ also allows us to write code that is more efficient than a for loop, but also\
    \ more concise. Broadcasting also allows us to write code that is more efficient\
    \ than a for loop, but also more concise. Broadcasting also allows us to write\
    \ code that is more efficient than a for loop, but also more concise. Broadcasting\
    \ also allows us to write code that is more efficient than a for loop, but also\
    \ more concise. Broadcasting also allows us to write code that is more efficient\
    \ than a for loop, but also more concise. Broadcasting also allows us to write\
    \ code that is more efficient than a for loop, but also more concise. Broadcasting\
    \ also allows us to write code that is more efficient than a for loop, but also\
    \ more concise. Broadcasting also allows us to write code that is more ", "  \
    \  \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Functions\nJulia has several built-in functions that operate on arrays. These\
    \ include sum, max, min, prod, and any that operate on any type of array. These\
    \ functions are vectorized, meaning that they operate on entire arrays instead\
    \ of operating on individual elements. For example, if we want to find the maximum\
    \ element in a vector, we would use the max function. However, if we want to find\
    \ the sum of all elements in a vector, we would use the sum function. The sum\
    \ function operates on arrays, whereas the max and min functions operate on individual\
    \ elements. To find the max and min elements in a vector, we would use the max\
    \ and min functions. For example:", "    evens = lst[findall(x -> x % 2 == 0,\
    \ lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(evens)\
    \ + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8,\
    \ 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum all even numbers in a vector",
  "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions", "    evens = lst[findall(lst .== 0)]\n    odds = lst[findall(lst\
    \ .== 1)]\n    \n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n\
    <code language=julia-1.5>\n@time solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n\
    @time solution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@time solution([30,\
    \ 13, 24, 321])\n</cell>\n<text>\nExercise 2\nWrite a function that returns the\
    \ number of times a given value appears in a given vector.", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odd = sum(lst[findall(x -> x % 2 != 0, lst)])\n  \
    \  return odd + sum(evens)\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum square difference\nGiven\
    \ a vector of numbers, calculate the sum of the squares of the numbers in the\
    \ vector.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    return sum(evens)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nIn this section we explore\
    \ the performance of vectorized solutions. We will compare the performance of\
    \ our current solution to the vectorized solutions we explored in the previous\
    \ section. Vectorized solutions are faster than their non-vectorized counterparts.\
    \ Vectorized solutions are often faster than their non-vectorized counterparts.\
    \ Vectorized solutions are often faster than their non-vectorized counterparts.\
    \ Vectorized solutions are often faster than their non-vectorized counterparts.",
  "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Vectorized Solutions\n\
    The previous sections showed how to use loops to solve a problem. Julia also has\
    \ built-in higher-level tools for solving problems such as vectorization. These\
    \ tools are often faster than the naive solution, and they also help you avoid\
    \ bugs. In this section, we'll explore the use of these tools to solve a problem\
    \ of interest.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n       \
    \     sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions\nThe previous sections showed how to use loops to solve a problem.\
    \ Julia also has built-in highly optimized functions to solve problems such as\
    \ this one. Here are some of them:", "    sum = 0\n    for i in lst\n        if\
    \ i%2 == 1\n            sum += i\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nPart III. Sum even and odd elements of a vector\nWrite a function that\
    \ returns the sum of all of the even and odd elements of a vector.", "    \n \
    \   sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n   \
    \     end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    A recursive function is a function that calls itself. A recursive function can\
    \ have one or more base cases. A base case is a case where the function does not\
    \ call itself recursively.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = sum(x -> x % 2 != 0, lst)\n    return odd - evens\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Sum all the even numbers in a vector", "    evens = lst[findall(lst\
    \ .== 0)]\n    odds = lst[findall(lst .== 1)]\n    return sum(filter(x -> x %\
    \ 2 == 1, odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum square\
    \ difference\nGiven a vector of numbers, calculate the sum of the squares of the\
    \ numbers in the vector.", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend", "  \
    \  sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend", "    \n    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart II: Vectorized Solutions\nJulia has several ways to\
    \ vectorize code. One of the most common ways is to write code in a way that Julia\
    \ can automatically vectorize it. This means that instead of writing a for loop\
    \ to iterate over an array, you can simply write code that operates on all the\
    \ elements at once.", "    even = lst[findall(x -> x % 2 == 0, lst)]\n    odd\
    \ = lst[findall(x -> x % 2 != 0, lst)]\n    \n    return sum(filter(x -> x % 2\
    \ == 1, even) + filter(x -> x % 2 != 1, odd))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Numbers\
    \ Except Self\nWrite a function that returns the sum of all integers except the\
    \ integer self. If self is not included, your function should return the number\
    \ 0.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x\
    \ -> x % 2 != 0, lst)]\n    return sum(evens) + sum(odds)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Finding the first missing positive integer in a sequence of integers\n\
    Given a sequence of integers $x_1, x_2, \\ldots, x_n$, where $x_i \\in \\mathbb{Z}^+$,\
    \ find the first missing positive integer $x$ in the sequence. \nThe first missing\
    \ positive integer $x$ is defined as the smallest positive integer $x$, such that\
    \ $x_1 + x_2 + \\cdots + x_n = x$, where $n$ is the length of the sequence.",
  "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend", "    \n    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24,\
    \ 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nThe previous sections\
    \ showed how to solve a problem in a single for loop. Vectorized solutions are\
    \ much faster and more efficient. Julia has a built-in function called v that\
    \ converts a Julia array to a vector. For example, v([1,2,3]) returns a vector\
    \ with elements 1,2,3.", "    \n    sum = 0\n    for i in lst\n        if i%2\
    \ == 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype solution([3, 3, 3, 3, 3])\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype solution([30, 13, 24, 321])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the number of times a given element\
    \ appears in a given vector.", "    even = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x %\
    \ 2 == 1, even) + filter(x -> x % 2 != 1, odd))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum all the\
    \ even numbers in a vector", "    sum = 0\n    for i in lst\n        if i%2 ==\
    \ 1\n            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n\
    <code language=julia-1.0>\n@code_warntype solution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-1.0>\n@code_warntype solution([3, 3, 3, 3, 3])\n</cell>\n<code\
    \ language=julia-1.0>\n@code_warntype solution([30, 13, 24, 321])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the sum of the numbers in the list that\
    \ are divisible by 7. ", "    sum = 0\n    for i in lst\n        if i%2 == 1\n\
    \            sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.3>\n@test solution([5, 8, 7, 1]) == 12\n@test solution([3,\
    \ 3, 3, 3, 3]) == 9\n@test solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the sum of the numbers in the list except\
    \ the first and last. Except for the first and last, all other numbers in the\
    \ list should be integers, and they should be in ascending order.", "    \n  \
    \  sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n  \
    \      end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions\nThe previous sections showed how to solve a problem in a single line\
    \ using loops. But Julia has many more ways to solve a problem in one line.",
  "    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n  \
    \      end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    Now let's try solving this problem using recursion.", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odd = sum(lst[findall(x -> x % 2 != 0, lst)])\n  \
    \  return odd + sum(evens)\nend", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return sum(filter(x -> x %\
    \ 2 == 1, odds)) + sum(filter(x -> x % 2 != 1, evens))\nend\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the number of times a given substring\
    \ appears in a given string.", "    \n    sum = 0\n    for x in lst\n        if\
    \ x % 2 == 1\n            sum += x\n        end\n    end\n    return sum\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nPart III. Vectorized Solutions\nIn this section, you will write your own\
    \ vectorized solutions. You will then compare them to other solutions that you\
    \ have written for the same problem. Finally, you will use your vectorized solutions\
    \ to benchmark against the other solutions that you have already written.", " \
    \   \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend", "    sum = 0\n    for i in lst\n\
    \        if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = sum(x -> x %\
    \ 2 != 0, lst)\n    return odd + sum(x -> x in evens, lst)\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Sum all the even-valued elements in a vector", "    \n    sum = 0\n\
    \    for x in lst\n        if x % 2 == 1\n            sum += x\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nNow that we've seen\
    \ the basics of recursion, let's see how we can use it to solve problems more\
    \ efficiently.", "    sum = 0\n    for i in lst\n        if i%2 == 1\n       \
    \     sum += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions\nNow that we've covered the basics of vectorization, let's move on\
    \ to more advanced topics. We'll cover two types of vectorization: element-wise\
    \ and matrix-wise operations. We'll also cover broadcasting.", "    \n    sum\
    \ = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odds = lst[findall(x -> x % 2 != 0, lst)]\n    sum(evens) + sum(odds)\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nPart III. Boolean Logic\nBoolean logic can be very useful in solving problems.\
    \ In this section, we will introduce two types of boolean logic: conjunction (AND)\
    \ and disjunction (OR). We will also introduce a third type of boolean logic:\
    \ negation (NOT).", "    sum = 0\n    for i in lst\n        if i%2 == 1\n    \
    \        sum += i\n        end\n    end\n    return sum\nend", "    \n    sum\
    \ = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nVectorized\
    \ solutions are faster than the for loop, but they also require more memory. Let's\
    \ compare the speed of our two solutions.", "    \n    sum = 0\n    for x in lst\n\
    \        if x % 2 == 1\n            sum += x\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24,\
    \ 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nThe previous sections\
    \ showed how to use loops to solve a problem. Julia also has built-in high-level\
    \ tools for solving problems vectorized. These tools are often faster than the\
    \ equivalent for loops, but they also require more memory and are less flexible.",
  "    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n    \
    \    end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum even and odd\
    \ numbers", "    \n    sum = 0\n    \n    for i in lst\n        if i%2 == 1\n\
    \            sum += i\n        end\n    end\n    \n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part II: Recursion\nNow let's see how we can use recursion to solve this problem.\
    \ We'll start by writing a function that takes in a vector of integers and returns\
    \ the sum of the odd elements that are in even positions.", "    \n    sum = 0\n\
    \    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n  \
    \  end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum all the even numbers in a\
    \ vector", "    \n    sum = 0\n    \n    for i in lst\n        if i%2 == 1\n \
    \           sum += i\n        end\n    end\n    \n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Vectorized Solutions\nIn this section, you will write your own vectorized\
    \ solution. Then, in the following exercises, you will use your solution to fill\
    \ in the body of the function vector_sum.", "    sum = 0\n    for i in lst\n \
    \       if i%2 == 1\n            sum += i\n        end\n    end\n    return sum\n\
    end\n</cell>\n<code language=julia-1.5>\n@time solution([5, 8, 7, 1])\n</cell>\n\
    <code language=julia-1.5>\n@time solution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n\
    @time solution([30, 13, 24, 321])\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the sum of the numbers in the vector that are divisible by 3.",
  "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x %\
    \ 2 != 0, lst)]\n    sum(filter(x -> x in evens, odd))\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: More on Vectors\n\
    Julia has many useful built-in data structures for working with vectors.  Here\
    \ are some of them:", "    evens = lst[findall(x -> x % 2 == 1, lst)]\n    odds\
    \ = lst[findall(x -> x % 2 == 0, lst)]\n    \n    return sum(filter(x -> x % 2\
    \ == 1, odds)) + sum(filter(x -> x % 2 == 0, evens))\nend\n</cell>\n<code language=julia-1.5>\n\
    @time solution(vec(1:100000));\n</cell>\n<text>\nProblem 8\nWrite a function that\
    \ returns the number of elements in a vector that are less than or equal to another\
    \ element.", "    \n    sum = 0\n    for x in lst\n        if x % 2 == 1\n   \
    \         sum += x\n        end\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part III. Vectorized Solutions\nVectorized solutions are faster than the for loop,\
    \ but they also require more memory. Here are some examples:", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    \n\
    \    sum(evens) + sum(odds)\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Sum All Even Elements",
  "    evens = lst[findall(x -> x % 2 == 0, lst)]\n    odd = lst[findall(x -> x %\
    \ 2 != 0, lst)]\n    \n    return sum(filter(x -> x % 2 == 1, evens)) + sum(filter(x\
    \ -> x % 2 != 1, odd))\nend\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns the number of times a given substring appears in a given string.", " \
    \   evens = lst[findall(x -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x\
    \ % 2 != 0, lst)]\n    \n    return sum(evens) + sum(odds)\nend\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the product of the elements of an input\
    \ vector. \n    \n    For example, given [2, 3, 4], it should return $6$. \n \
    \   \n    Use map() to solve this problem. \n    \n    Use reduce() if you prefer\
    \ to use a for loop.\n    \n    Use a while loop if you prefer to use an if statement.\n\
    \    \n    Use a recursive function if you prefer to use recursion.\n    \n  \
    \  Use a for loop if you prefer to use an if statement.\n    \n    Use a while\
    \ loop if you prefer to use an if statement.\n    \n    Use a recursive function\
    \ if you prefer to use recursion.\n    \n    Use a for loop if you prefer to use\
    \ an if statement.\n    \n    Use a while loop if you prefer to use an if statement.\n\
    \    \n    Use a recursive function if you prefer to use recursion.\n    \n  \
    \  Use a for loop if you prefer to use an if statement.\n    \n    Use a while\
    \ loop if you prefer to use an if statement.\n    \n    Use a recursive function\
    \ if you prefer to use recursion.\n    \n    Use a for loop if you prefer to use\
    \ an if statement.\n    \n    Use a while loop if you prefer to use an if statement.\n\
    \    \n    Use a recursive function if you prefer to use recursion.\n    \n  \
    \  Use a for loop if you prefer to use an if statement.\n    \n    Use a while\
    \ loop if you prefer to use an if statement.\n    \n    Use a recursive function\
    \ if you prefer to use recursion.\n    \n    Use a for loop if you prefer to use\
    \ an if statement.\n    \n    Use a while loop if you prefer to use an if statement.\n\
    \    \n    Use a recursive function if you prefer to use recursion.\n    \n  \
    \  Use a for loop if you prefer to use an if statement.\n    \n    Use a while\
    \ loop if you prefer to use an if statement.\n    \n    Use a recursive function\
    \ if you prefer to use recursion.\n    \n    Use a for loop if you prefer to use\
    \ an if statement.\n    \n    Use a while loop if you prefer to use an if statement.\n\
    \    \n    Use a recursive function if you ", "    \n    sum = 0\n    for i in\
    \ lst\n        if i%2 == 1\n            sum += i\n        end\n    end\n    return\
    \ sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1])\
    \ == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24,\
    \ 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nThe previous sections\
    \ showed how Julia can apply a function to every element of a vector. Here are\
    \ some more advanced techniques for operating on entire vectors at once.", " \
    \   sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n \
    \       end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nProblem 7\nWrite a\
    \ function that returns the sum of the numbers in the list provided as an argument.",
  "    evens = lst[findall(lst .== even(lst, 2))]\n    odds = lst[findall(lst .==\
    \ odd(lst, 2))]\n    return sum(odds .== evens)\nend\n</cell>\n<code language=julia-1.5>\n\
    @time solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@time solution([3,\
    \ 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@time solution([30, 13, 24,\
    \ 321])\n</cell>\n<text>\nPart 2: Finding all subsets of a set\nGiven a set, find\
    \ all subsets of that set. For example, given {1, 2, 3}, return [{}, {1}, {2},\
    \ {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}]. Your function should return the answer\
    \ as a vector of sets, not as a single set. \n    ", "    evens = lst[findall(x\
    \ -> x % 2 == 0, lst)]\n    odds = lst[findall(x -> x % 2 != 0, lst)]\n    return\
    \ sum(filter(x -> x % 2 == 1, odds)) + sum(filter(x -> x % 2 != 1, evens))\nend\n\
    </cell>\n<code language=julia-1.0>\n@assert solution([5, 8, 7, 1]) == 12\n@assert\
    \ solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n\
    <text>\nPart II: More on Vectors\nA vector is a structure that holds multiple\
    \ values. It has many methods that operate on it, but we'll focus on a few of\
    \ them:", "    \n    sum = 0\n    \n    for x in lst\n        if x % 2 == 1\n\
    \            sum += x\n        end\n    end\n    \n    return sum\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype solution([3, 3, 3, 3, 3])\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype solution([30, 13, 24, 321])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the number of elements in a vector that\
    \ are not in the given set. For example, if the given set is {1, 2, 3}, then the\
    \ function should return 2 since there are two elements that are not in the given\
    \ set. Write a function that returns the number of elements in a vector that are\
    \ not in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should return 2 since there are two elements that are not in the given set.\
    \ Write a function that returns the number of elements in a vector that are not\
    \ in the given set. For example, if the given set is {1, 2, 3}, then the function\
    \ should ", "    evens = filter(x -> x % 2 == 0, lst)\n    odds = filter(x ->\
    \ x % 2 != 0, lst)\n    return sum(filter(x -> x % 2 == 1, odds))\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n@assert solution([3,\
    \ 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\n\
    Part II: More on Vectors\nThe Julia language has many useful built-in data structures\
    \ for working with vectors. In this section, we will introduce three of them,\
    \ and see how they can be used.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odds = lst[findall(x -> x % 2 != 0, lst)]\n    \n    sum(evens) + sum(odds)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert solution([5, 8, 7, 1]) == 12\n\
    @assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30, 13, 24, 321]) ==\
    \ 0\n</cell>\n<text>\nPart III. Sum All Numbers Disappeared in an Array", "  \
    \  \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n\
    \        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\n\
    Recursion is a powerful tool for solving problems that involve repeating a problem\
    \ until a base case is reached.", "    evens = lst[findall(x -> x % 2 == 0, lst)]\n\
    \    odd = sum(lst[findall(x -> x % 2 != 0, lst)])\n    return odd + sum(evens)\n\
    end", "    \n    sum = 0\n    for i in lst\n        if i%2 == 1\n            sum\
    \ += i\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    @assert solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized\
    \ Solutions\nThe previous sections showed how to use loops to solve a problem.\
    \ Julia also has built-in functions to do these types of problems more efficiently.\
    \ These functions are called vectorized solutions. Vectorized solutions are faster\
    \ than their non-vectorized counterparts, but they also require more memory. Vectorized\
    \ solutions are also more difficult to read and understand.", "    sum = 0\n \
    \   for x in lst\n        if x % 2 == 1\n            sum += x\n        end\n \
    \   end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Vectorized Solutions\nOne of\
    \ the most important parts of Julia is vectorization. Vectorization is when we\
    \ use loops to operate on arrays. In Julia, vectorization is done using broadcasting\
    \ or broadcastable arrays. Broadcasting is the process of using arrays to operate\
    \ on other arrays. Broadcasting arrays is done by adding an extra dimension to\
    \ an array and using that dimension to broadcast the array. Broadcasting arrays\
    \ is done by adding an extra dimension to an array and using that dimension to\
    \ broadcast the array. Broadcasting arrays is done by adding an extra dimension\
    \ to an array and using that dimension to broadcast the array.", "    \n    sum\
    \ = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n        end\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert solution([5,\
    \ 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert solution([30,\
    \ 13, 24, 321]) == 0\n</cell>\n<text>\nPart III. Sum All Even Elements", "   \
    \ sum = 0\n    for i in lst\n        if i%2 == 1\n            sum += i\n     \
    \   end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.0>\n@assert\
    \ solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n@assert\
    \ solution([30, 13, 24, 321]) == 0\n</cell>\n<text>\nPart II: Recursion\nRecursion\
    \ is a programming technique that allows us to solve problems by breaking them\
    \ down into smaller sub-problems. For example, if we were to write a function\
    \ that calculates the factorial of a number, we might want to break it down into\
    \ smaller problems until we reach a base case. Let's see how this works in Julia.",
  "    sum = 0\n    for x in lst\n        if x % 2 == 1\n            sum += x\n  \
    \      end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solution([30, 13, 24, 321])\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes a vector of integers and returns the number of elements that are odd."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
