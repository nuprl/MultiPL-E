language: jl
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 1000 || need\
    \ > 1000 || remaining > 1000\n        error(\"invalid input\")\n    end\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7f94jqs3.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7f94jqs3.jl:1\n\
    in expression starting at /tmp/tmp7f94jqs3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    if number < 0 || need\
    \ < 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    \n    if\
    \ number == 0\n        return [need, remaining]\n    end\n    \n    if remaining\
    \ == 0\n        return [number, 0]\n    end\n    \n    if number > remaining\n\
    \        return [number, 0]\n    end\n    \n    if number == remaining\n     \
    \   return [number, 0]\n    end\n    \n    if number == need\n        return [number,\
    \ 0]\n    end\n    \n    if number > need\n        return [number, 0]\n    end\n\
    \    \n    if number == remaining\n        return [number, 0]\n    end\n    \n\
    \    if number == need\n        return [number, 0]\n    end\n    \n    if number\
    \ > need\n        return [number, 0]\n    end\n    \n    if number == remaining\n\
    \        return [number, 0]\n    end\n    \n    if number == need\n        return\
    \ [number, 0]\n    end\n    \n    if number > need\n        return [number, 0]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number == need\n        return [number, 0]\n    end\n    \n    if\
    \ number > need\n        return [number, 0]\n    end\n    \n    if number == remaining\n\
    \        return [number, 0]\n    end\n    \n    if number == need\n        return\
    \ [number, 0]\n    end\n    \n    if number > need\n        return [number, 0]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number == need\n        return [number, 0]\n    end\n    \n    if\
    \ number > need\n        return [number, 0]\n    end\n    \n    if number == remaining\n\
    \        return [number, 0]\n    end\n    \n    if number == need\n        return\
    \ [number, 0]\n    end\n    \n    if number > need\n        return [number, 0]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number == need\n        return [number, 0]\n    end\n    \n    if\
    \ number > need\n        return [number, 0]\n    end\n    \n    if number == remaining\n\
    \        return [number, 0]\n    end\n    \n    if number == need\n        return\
    \ [number, 0]\n    end\n    \n    if number > need\n        return [number, 0]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number == need\n        return [number, 0]\n    end\n    \n    if\
    \ number > need\n        return [number, 0]\n    end\n    \n    if number == remaining\n\
    \        return [number, 0]\n    end\n    \n    if number == need\n        return\
    \ [number, 0]\n    end\n    \n    if number > need\n        return [number, 0]\n\
    \    end\n    \n    if number == remaining\n        return [number, 0]\n    end\n\
    \    \n    if number == need\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph_624xxw.jl:1\nin expression starting at /tmp/tmph_624xxw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    if number ==\
    \ 0\n        return Vector{Int64}()\n    end\n    if number > remaining\n    \
    \    return Vector{Int64}(remaining, 0)\n    end\n    if need == 0\n        return\
    \ Vector{Int64}(number, 0)\n    end\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3slc0egk.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3slc0egk.jl:1\n\
    in expression starting at /tmp/tmp3slc0egk.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    while carrots[1] >\
    \ 0 && carrots[2] > 0\n        carrots[1] -= carrots[2]\n        carrots[2] -=\
    \ carrots[1]\n    end\n    \n    if carrots[1] > 0\n        carrots[1] += remaining\n\
    \    else\n        carrots[1] = remaining\n    end\n    \n    return carrots\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the number of carrots left after a meal is\
    \ completed.\nThe function should take in two inputs:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmsk2_z1r.jl:55\nin expression starting at\
    \ /tmp/tmpmsk2_z1r.jl:55\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ return Vector{Int64}()\n    if remaining < 0\n        return Vector{Int64}()\n\
    \    if remaining < need\n        return Vector{Int64}()\n    if number > remaining\n\
    \        return Vector{Int64}()\n    if number == need\n        return Vector{Int64}([number,\
    \ 0])\n    if number > need\n        return Vector{Int64}()\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa_jnus09.jl:1\nin expression starting at /tmp/tmpa_jnus09.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    # Your code\
    \ here\n    \nend\n</cell>\n<code language=julia-1.5>\n# run this cell to test\
    \ your code\neat(5, 6, 10)\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ finds the minimum number of carrots you need to eat to make the meal complete.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc7k__lh0.jl:39\nin expression starting at\
    \ /tmp/tmpc7k__lh0.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    # Your code\
    \ here\n    \n    return Vector{Int64}([number, need-remaining])\nend\n</cell>\n\
    <code language=julia-1.5>\n# run this cell to check your code\neat(5, 6, 10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns a vector of [number\
    \ of carrots left after your meals, number of carrots left after your meals]\n\
    if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\nThe function should take 3 arguments:\n@number :\
    \ integer\n    the number of carrots that you have eaten.\n@need : integer\n \
    \   the number of carrots that you need to eat.\n@remaining : integer\n    the\
    \ number of remaining carrots thet exist in stock\nThe function should return\
    \ an empty vector if there are not enough remaining carrots.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp6sck_4z.jl:40\nin expression starting at\
    \ /tmp/tmpp6sck_4z.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = need\n    \n    carrots_left = carrots_left - carrots\n    \n    carrots_left[1]\
    \ = carrots_left[1] - 1\n    \n    return carrots_left\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiy9xyrm2.jl:52\nin expression starting at\
    \ /tmp/tmpiy9xyrm2.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return error(\"Invalid input\")\n    end\n    \n    carrots = number\n \
    \   meals = need\n    \n    while carrots > 0\n        if carrots >= meals\n \
    \           carrots -= meals\n            meals = 0\n        else\n          \
    \  meals += 1\n        end\n    end\n    \n    if carrots > 0\n        carrots\
    \ = remaining\n    end\n    \n    return Vector{Int64}(carrots, meals)\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nProblem 3\n\
    Write a function that returns the number of ways you can reach a certain sum in\
    \ a given number of steps.\nThe function should take in two inputs:\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjxkc5ixj.jl:56\nin expression starting at\
    \ /tmp/tmpjxkc5ixj.jl:56\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    elseif number > remaining\n        Vector{Int64}(remaining,\
    \ 0)\n    elseif need == 0\n        Vector{Int64}(remaining, 0)\n    else\n  \
    \      Vector{Int64}(remaining, number - need)\n    end\nend\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of days left in a month.\n\
    The function should take in a year and a month as arguments and return the number\
    \ of days left in the month.\nThe function should return 0 if either the year\
    \ or the month is invalid.\nThe function should return 0 if either the year or\
    \ the month is invalid.\nThe function should return 0 if either the year or the\
    \ month is invalid.\nThe function should return 0 if either the year or the month\
    \ is invalid.\nThe function should return 0 if either the year or the month is\
    \ invalid.\nThe function should return 0 if either the year or the month is invalid.\n\
    The function should return 0 if either the year or the month is invalid.\nThe\
    \ function should return 0 if either the year or the month is invalid.\nThe function\
    \ should return 0 if either the year or the month is invalid.\nThe function should\
    \ return 0 if either the year or the month is invalid.\nThe function should return\
    \ 0 if either the year or the month is invalid.\nThe function should return 0\
    \ if either the year or the month is invalid.\nThe function should return 0 if\
    \ either the year or the month is invalid.\nThe function should return 0 if either\
    \ the year or the month is invalid.\nThe function should return 0 if either the\
    \ year or the month is invalid.\nThe function should return 0 if either the year\
    \ or the month is invalid.\nThe function should return 0 if either the year or\
    \ the month is invalid.\nThe function should return 0 if either the year or the\
    \ month is invalid.\nThe function should return 0 if either the year or the month\
    \ is invalid.\nThe function should return 0 if either the year or the month is\
    \ invalid.\nThe function should return 0 if either the year or the month is invalid.\n\
    The function should return 0 if either the year or the month is invalid.\nThe\
    \ function should return 0 if either the year or the month is invalid.\nThe function\
    \ should return 0 if either the year or the month is invalid.\nThe function should\
    \ return 0 if either the year or the month is invalid.\nThe function should return\
    \ 0 if either the year or the month is invalid.\nThe function should return 0\
    \ if either the year or the month is invalid.\nThe function should return 0 if\
    \ either the year or the month is invalid.\nThe function should return 0 if either\
    \ the year or the month is invalid.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkq09obe6.jl:44\nin expression starting at\
    \ /tmp/tmpkq09obe6.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ return Vector{Int64}()\n    \n    if number < need\n        return Vector{Int64}()\n\
    \    \n    if number > remaining\n        return Vector{Int64}()\n    \n    if\
    \ number == need\n        return Vector{Int64}([number, remaining - number])\n\
    \    \n    if number > remaining\n        return Vector{Int64}([number, 0])\n\
    \    \n    return Vector{Int64}([number, 0])\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nExercise 2\nWrite a function that returns the number\
    \ of carrots left after a meal.\nThe function should take two arguments: the number\
    \ of carrots you have eaten and the number of carrots left after your meals.\n\
    The function should return a single number.\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzw80yzxp.jl:51\nin expression starting at\
    \ /tmp/tmpzw80yzxp.jl:51\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    while carrots[1] >\
    \ 0\n        carrots[1] -= carrots[2]\n        carrots[2] += 1\n    end\n    \n\
    \    if carrots[1] > 0\n        carrots[1] -= carrots[2]\n        carrots[2] +=\
    \ 1\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of days until a rabbit eats its first meal.\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5ejdwrhm.jl:54\nin expression starting at\
    \ /tmp/tmp5ejdwrhm.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 \n  \
    \      error(\"Invalid input: number should be between 0 and 1000, need should\
    \ be between 0 and 1000, and remaining should be between 0 and 1000\")\n    else\n\
    \        Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n<code\
    \ language=julia-1.4>\n\"\"\"\n    You have a certain number of carrots, and you\
    \ know that every day you will eat at least 1 carrot.\n    You want to know how\
    \ many carrots you will need to eat to complete the day's meals.\n    \n    Example:\n\
    \    >>> days_meals(5, 6)\n    7\n    >>> days_meals(4, 8)\n    10\n    >>> days_meals(1,\
    \ 10)\n    11\n    >>> days_meals(2, 11)\n    7\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you already have.\n    @need :\
    \ integer\n        the number of carrots that you need to eat.\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    \n    Have fun :)\n \
    \   \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4kl3_0my.jl:40\nin expression starting at\
    \ /tmp/tmp4kl3_0my.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n   \
    \ \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqv_12_1e.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqv_12_1e.jl:1\n\
    in expression starting at /tmp/tmpqv_12_1e.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    if number == 0\n        return\
    \ [need, remaining]\n    end\n    \n    carrots_left = number - need\n    \n \
    \   if carrots_left == 0\n        return [number, 0]\n    end\n    \n    carrots_eaten\
    \ = remaining - carrots_left\n    \n    if carrots_eaten == 0 \n        return\
    \ [number, 0]\n    end\n    \n    return [number, carrots_eaten]\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nProblem 3\nWrite a\
    \ function that returns the number of carrots left after eating a certain number\
    \ of carrots.\nIf there are not enough carrots left after eating a certain number\
    \ of carrots, you will eat all remaining carrots, but will still be hungry.\n\
    The function should take in two inputs:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_8crerm5.jl:56\nin expression starting at\
    \ /tmp/tmp_8crerm5.jl:56\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n   \
    \ \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    \n    while carrots_left[2] > 0\n        carrots_left[1] -= 1\n\
    \        carrots_left[2] = 0\n        \n        if carrots_left[1] > 0\n     \
    \       carrots[2] += 1\n        end\n    end\n    \n    return carrots\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nProblem 3\n\
    Write a function that takes a vector of integers and returns the sum of the integers\
    \ in the vector.\nThe vector can contain any number of integers, including zero.\n\
    The function should return 0 if the vector is empty.\nThe function should return\
    \ Inf if the vector is empty.\nThe function should return Inf if the vector is\
    \ empty.\nThe function should return Inf if the vector is empty.\nThe function\
    \ should return Inf if the vector is empty.\nThe function should return Inf if\
    \ the vector is empty.\nThe function should return Inf if the vector is empty.\n\
    The function should return Inf if the vector is empty.\nThe function should return\
    \ Inf if the vector is empty.\nThe function should return Inf if the vector is\
    \ empty.\nThe function should return Inf if the vector is empty.\nThe function\
    \ should return Inf if the vector is empty.\nThe function should return Inf if\
    \ the vector is empty.\nThe function should return Inf if the vector is empty.\n\
    The function should return Inf if the vector is empty.\nThe function should return\
    \ Inf if the vector is empty.\nThe function should return Inf if the vector is\
    \ empty.\nThe function should return Inf if the vector is empty.\nThe function\
    \ should return Inf if the vector is empty.\nThe function should return Inf if\
    \ the vector is empty.\nThe function should return Inf if the vector is empty.\n\
    The function should return Inf if the vector is empty.\nThe function should return\
    \ Inf if the vector is empty.\nThe function should return Inf if the vector is\
    \ empty.\nThe function should return Inf if the vector is empty.\nThe function\
    \ should return Inf if the vector is empty.\nThe function should return Inf if\
    \ the vector is empty.\nThe function should return Inf if the vector is empty.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkrwudapt.jl:62\nin expression starting at\
    \ /tmp/tmpkrwudapt.jl:62\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    carrots_left_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals[1] = remaining\n\
    \    carrots_left_after_meals_after_meals[2] = 0\n    \n    carrots_left_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals[1] =\
    \ remaining\n    carrots_left_after_meals_after_meals_after_meals[2] = 0\n   \
    \ \n    carrots_left_after_meals_after_meals_after_meals_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals[1] = remaining\n\
    \    carrots_left_after_meals_after_meals_after_meals_after_meals[2] = 0\n   \
    \ \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals[2]\
    \ = 0\n    \n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals[1]\
    \ = remaining\n    carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwaj77ye0.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwaj77ye0.jl:1\n\
    in expression starting at /tmp/tmpwaj77ye0.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpy5o9evq0.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpy5o9evq0.jl:1\n\
    in expression starting at /tmp/tmpy5o9evq0.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    # Your code\
    \ here\n    \n    return Vector{Int64}([number, need-number])\nend\n</cell>\n\
    <code language=julia-1.4>\neat(5, 6, 10)\n</cell>\n<text>\nProblem 3\nWrite a\
    \ function that returns the number of ways to arrange a certain number of cards\
    \ into a pile of cards such that each pile's cards are in ascending order.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9yzvk67m.jl:40\nin expression starting at\
    \ /tmp/tmp9yzvk67m.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 \n  \
    \      error(\"Invalid input\") \n    else \n        Vector{Int64}([number, need])\
    \ + Vector{Int64}([remaining, 0])\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    # Test your function with the cases below:\n@test eat(5, 6, 10) == [11, 4]\n@test\
    \ eat(4, 8, 9) == [12, 1]\n@test eat(1, 10, 10) == [11, 0]\n@test eat(2, 11, 5)\
    \ == [7, 0]\n</cell>\n<text>\nProblem 2b\nWrite a function that returns the number\
    \ of minutes that you will be hungry given that you have eaten a certain number\
    \ of carrots and a certain amount of time per day. You should round the final\
    \ answer to the nearest integer.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbekktlr8.jl:40\nin expression starting at\
    \ /tmp/tmpbekktlr8.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = remaining\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = need\n    meals[2] = remaining\n    \n    carrots_left =\
    \ zeros(Int64, 2)\n    carrots_left[1] = number\n    carrots_left[2] = remaining\n\
    \    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = need\n    meals_left[2]\
    \ = remaining\n    \n    carrots_left = carrots_left[1]\n    meals_left = meals_left[1]\n\
    \    \n    while carrots_left > 0 && meals_left > 0\n        carrots_left -= 1\n\
    \        meals_left -= 1\n        if carrots_left == 0 && meals_left == 0\n  \
    \          break\n        end\n    end\n    \n    if carrots_left == 0 && meals_left\
    \ == 0\n        carrots_left = 0\n        meals_left = 0\n    end\n    \n    return\
    \ carrots, meals\nend\n</cell>\n<text>\nProblem 3\nWrite a function that returns\
    \ the number of minutes that a person has spent watching a movie.\nThe time spent\
    \ watching a movie is counted from the first minute of the movie to the last minute\
    \ of the movie.\nThe time spent watching a movie is counted from the first minute\
    \ of the movie to the last minute of the movie.\nThe time spent watching a movie\
    \ is counted from the first minute of the movie to the last minute of the movie.\n\
    The time spent watching a movie is counted from the first minute of the movie\
    \ to the last minute of the movie.\nThe time spent watching a movie is counted\
    \ from the first minute of the movie to the last minute of the movie.\nThe time\
    \ spent watching a movie is counted from the first minute of the movie to the\
    \ last minute of the movie.\nThe time spent watching a movie is counted from the\
    \ first minute of the movie to the last minute of the movie.\nThe time spent watching\
    \ a movie is counted from the first minute of the movie to the last minute of\
    \ the movie.\nThe time spent watching a movie is counted from the first minute\
    \ of the movie to the last minute of the movie.\nThe time spent watching a movie\
    \ is counted from the first minute of the movie to the \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmnscjwrv.jl:72\nin expression starting at\
    \ /tmp/tmpmnscjwrv.jl:72\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 \n  \
    \      error(\"Invalid input: number should be between 0 and 1000, need should\
    \ be between 0 and 1000, and remaining should be between 0 and 1000\")\n    end\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpyslbhfny.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyslbhfny.jl:1\n\
    in expression starting at /tmp/tmpyslbhfny.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpcmnpix2t.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcmnpix2t.jl:1\n\
    in expression starting at /tmp/tmpcmnpix2t.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    elseif remaining < need\n        Vector{Int64}(remaining,\
    \ 0)\n    else\n        Vector{Int64}(0, need - remaining)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of times a given string occurs in a given string.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2s519tf7.jl:42\nin expression starting at\
    \ /tmp/tmp2s519tf7.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 && number <= need && number <= remaining \n        then \n\
    \            Vector{Int64}([number, need-number])\n        else \n           \
    \ Vector{Int64}([number, remaining])\n    end\nend\n</cell>\n<text>\nProblem 9\n\
    Write a function that returns true if the given string is a palindrome and false\
    \ otherwise. \nThe string can contain any characters, including spaces. \nThe\
    \ function should ignore leading and trailing whitespace. \nThe function should\
    \ ignore case when comparing characters.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpng5vpox8.jl:41\nin expression starting at\
    \ /tmp/tmpng5vpox8.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return error(\"invalid input\")\n    end\n    \n    carrots = zeros(Int64,\
    \ 2)\n    carrots[1] = number\n    carrots[2] = remaining\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = need\n    meals[2] = remaining\n    \n    \n    \n    return\
    \ carrots\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpatactx9i.jl:50\nin expression starting at\
    \ /tmp/tmpatactx9i.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = need\n    \n    carrots_left = carrots_left - carrots\n    \n    return carrots_left\n\
    end\n</cell>\n<code language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphdsityci.jl:50\nin expression starting at\
    \ /tmp/tmphdsityci.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n   \
    \ \n    if number == 0\n        carrots[1] = need\n        carrots[2] = 0\n  \
    \  end\n    \n    if remaining == 0\n        carrots[1] = 0\n        carrots[2]\
    \ = 0\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzyf19d7v.jl:54\nin expression starting at\
    \ /tmp/tmpzyf19d7v.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        return Vector{Int64}()\n    end\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpyqqlbmai.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyqqlbmai.jl:1\n\
    in expression starting at /tmp/tmpyqqlbmai.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}([need, remaining])\n    else\n        Vector{Int64}([need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 9\nWrite a function that returns the number of days left in a meal plan.\n\
    The meal plan is represented as a vector of days (in days) and a vector of meals\
    \ (in carrots).\nThe function should return 0 if there are no days left.\nThe\
    \ function should return -1 if there are not enough carrots to complete the meal.\n\
    The function should return 1 if the meal is complete.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvsbhogew.jl:40\nin expression starting at\
    \ /tmp/tmpvsbhogew.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6qbosxtw.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6qbosxtw.jl:1\n\
    in expression starting at /tmp/tmp6qbosxtw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    if number\
    \ == 0 && remaining == 0\n        return Vector{Int64}()\n    end\n    if number\
    \ == 0 && remaining > 0\n        return Vector{Int64}([need, remaining])\n   \
    \ end\n    if number > 0 && remaining == 0\n        return Vector{Int64}([need,\
    \ number])\n    end\n    if number > 0 && remaining > 0\n        return Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgl6u1ry7.jl:50\nin expression starting at\
    \ /tmp/tmpgl6u1ry7.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    elseif number > remaining\n        Vector{Int64}(remaining,\
    \ 0)\n    elseif number < need\n        Vector{Int64}(0, need-number)\n    else\n\
    \        Vector{Int64}(number, need-number)\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 9\nWrite a function that returns the number\
    \ of ways to arrange n numbers in k groups of m numbers. \nThe function should\
    \ return an vector of length n+m+1 where each element of the vector is the number\
    \ of ways to arrange the numbers from 0 to n+m+1 into m groups of n numbers. \n\
    The vector should contain all possible combinations of m numbers in n groups.\
    \ \nThe function should return an empty vector if n+m+1 is not divisible by m.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0125gxl2.jl:44\nin expression starting at\
    \ /tmp/tmp0125gxl2.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return Vector{Int64}()\n    end\n    \n    carrots = Vector{Int64}()\n \
    \   carrots = Vector{Int64}([number])\n    \n    while carrots[1] < need\n   \
    \     carrots[1] += 1\n    end\n    \n    while carrots[1] > 0\n        carrots[1]\
    \ -= 1\n    end\n    \n    carrots[1] = remaining\n    \n    return carrots\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 0)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 1)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 2)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 3)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 4)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 5)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 6)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 7)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 8)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 11)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 12)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 13)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 14)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 15)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 16)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 17)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 18)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 19)\n</cell>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjwx6nyhx.jl:53\nin expression starting at\
    \ /tmp/tmpjwx6nyhx.jl:53\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = 0\n \
    \   carrots_eaten[2] = 0\n    \n    while meals[1] > 0\n        carrots_left[1]\
    \ -= meals[1]\n        carrots_eaten[1] += meals[1]\n        meals[1] = 0\n  \
    \      \n        if carrots_left[1] > 0\n            carrots[1] += carrots_left[1]\n\
    \            carrots_left[1] = 0\n        end\n        \n        if carrots_eaten[1]\
    \ > 0\n            carrots[2] += carrots_eaten[1]\n            carrots_eaten[1]\
    \ = 0\n        end\n        \n        if carrots[1] <= 0\n            carrots[1]\
    \ = number\n            carrots[2] = need\n            meals[1] = remaining\n\
    \            meals[2] = 0\n        end\n    end\n    \n    return carrots\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphrkiqpph.jl:79\nin expression starting at\
    \ /tmp/tmphrkiqpph.jl:79\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    if number >\
    \ 0 && number <= 1000 && need > 0 && need <= 1000 && remaining > 0 && remaining\
    \ <= 1000\n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz9teofmu.jl:1\nin expression starting at /tmp/tmpz9teofmu.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    if number\
    \ == 0\n        return [need, remaining]\n    end\n    if remaining == 0\n   \
    \     return [number, 0]\n    end\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgkkpsboe.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpgkkpsboe.jl:1\n\
    in expression starting at /tmp/tmpgkkpsboe.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"invalid input\")\n    end\n    if number\
    \ == 0 && remaining == 0\n        return Vector{Int64}()\n    end\n    if number\
    \ == 0 && remaining > 0\n        return Vector{Int64}(remaining, 0)\n    end\n\
    \    if need == 0 && remaining > 0\n        return Vector{Int64}(0, remaining)\n\
    \    end\n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}(number,\
    \ need - number)\n    end\n    return Vector{Int64}()\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function called hungry that takes\
    \ two integers n and k, and returns true if the rabbit you are hungry is hungry\
    \ enough to eat k carrots, otherwise returns false. \nThe function should return\
    \ false if n is less than 0 or k is less than 0.\nThe function should return false\
    \ if n is equal to 0 or k is equal to 0.\nThe function should return false if\
    \ n is greater than or equal to k and if k is greater than or equal to 0.\nThe\
    \ function should return false if n is greater than or equal to k and if k is\
    \ less than or equal to 0.\nThe function should return false if n is greater than\
    \ or equal to k and if k is less than or equal to 0.\nThe function should return\
    \ false if n is greater than or equal to k and if k is greater than or equal to\
    \ 0.\nThe function should return false if n is greater than or equal to k and\
    \ if k is less than or equal to 0.\nThe function should return false if n is greater\
    \ than or equal to k and if k is greater than or equal to 0.\nThe function should\
    \ return false if n is greater than or equal to k and if k is greater than or\
    \ equal to 0.\nThe function should return false if n is greater than or equal\
    \ to k and if k is less than or equal to 0.\nThe function should return false\
    \ if n is greater than or equal to k and if k is greater than or equal to 0.\n\
    The function should return false if n is greater than or equal to k and if k is\
    \ less than or equal to 0.\nThe function should return false if n is greater than\
    \ or equal to k and if k is greater than or equal to 0.\nThe function should return\
    \ false if n is greater than or equal to k and if k is less than or equal to 0.\n\
    The function should return false \nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzzt_zhc1.jl:51\nin expression starting at\
    \ /tmp/tmpzzt_zhc1.jl:51\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = number\n\
    \    carrots_eaten[2] = 0\n    \n    carrots_needed = zeros(Int64, 2)\n    carrots_needed[1]\
    \ = need\n    carrots_needed[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n\
    \    carrots_left[1] = remaining\n    carrots_left[2] = 0\n    \n    carrots_eaten\
    \ = zeros(Int64, 2)\n    carrots_eaten[1] = number\n    carrots_eaten[2] = 0\n\
    \    \n    carrots_needed = zeros(Int64, 2)\n    carrots_needed[1] = need\n  \
    \  carrots_needed[2] = 0\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = 0\n    \n    carrots_eaten = zeros(Int64,\
    \ 2)\n    carrots_eaten[1] = number\n    carrots_eaten[2] = 0\n    \n    carrots_needed\
    \ = zeros(Int64, 2)\n    carrots_needed[1] = need\n    carrots_needed[2] = 0\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = 0\n    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1]\
    \ = number\n    carrots_eaten[2] = 0\n    \n    carrots_needed = zeros(Int64,\
    \ 2)\n    carrots_needed[1] = need\n    carrots_needed[2] = 0\n    \n    carrots_left\
    \ = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = 0\n\
    \    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = number\n  \
    \  carrots_eaten[2] = 0\n    \n    carrots_needed = zeros(Int64, 2)\n    carrots_needed[1]\
    \ = need\n    carrots_needed[2\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp63q4_9kn.jl:1\nin expression starting at /tmp/tmp63q4_9kn.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    if remaining == 0\n        return\
    \ [number, 0]\n    end\n    \n    carrots = number\n    carrots_left = remaining\n\
    \    \n    while carrots_left > 0\n        carrots_left -= 1\n        carrots\
    \ -= 1\n    end\n    \n    return [carrots, carrots_left]\nend\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<text>\nExercise 2\nWrite a function that finds the minimum\
    \ number of carrots needed to eat all the carrots in a given meal plan.\nThe function\
    \ should take as input a vector of meal plans represented by a vector of integers\
    \ representing the number of carrots eaten for each meal plan.\nThe function should\
    \ return a single integer representing the minimum number of carrots needed to\
    \ eat all the carrots in all the meal plans.\nThe function should return 0 if\
    \ no meal plans can be eaten in such a way that all the carrots can be eaten.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_whcq391.jl:51\nin expression starting at\
    \ /tmp/tmp_whcq391.jl:51\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = number\n    meals = need\n    \n    if carrots > remaining\n        carrots\
    \ = remaining\n    end\n    \n    carrots = carrots - meals\n    \n    return\
    \ Vector{Int64}(carrots, meals)\nend\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7\nWrite a function that returns the number of ways you can reach a certain\
    \ sum from any given number.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjd2acia4.jl:49\nin expression starting at\
    \ /tmp/tmpjd2acia4.jl:49\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number should be between 0 and 1000\")\n    end\n \
    \   if need < 0 || need > 1000 \n        error(\"need should be between 0 and\
    \ 1000\")\n    end\n    if remaining < 0 || remaining > 1000 \n        error(\"\
    remaining should be between 0 and 1000\")\n    end\n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpew5x4r70.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpew5x4r70.jl:1\n\
    in expression starting at /tmp/tmpew5x4r70.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    if number > 0 && need\
    \ > 0 && remaining > 0\n        \n        carrots = number\n        \n       \
    \ if number > need\n            carrots = number-need\n        end\n        \n\
    \        if remaining > carrots\n            carrots = remaining\n        end\n\
    \        \n        if carrots > 0\n            \n            carrots = carrots\
    \ - 1\n            \n            carrots = carrots + need\n            \n    \
    \        carrots = carrots - 1\n            \n            carrots = carrots +\
    \ 1\n            \n            carrots = carrots + 1\n            \n         \
    \   carrots = carrots + 1\n            \n            carrots = carrots + 1\n \
    \           \n            carrots = carrots + 1\n            \n            carrots\
    \ = carrots + 1\n            \n            carrots = carrots + 1\n           \
    \ \n            carrots = carrots + 1\n            \n            carrots = carrots\
    \ + 1\n            \n            carrots = carrots + 1\n            \n       \
    \     carrots = carrots + 1\n            \n            carrots = carrots + 1\n\
    \            \n            carrots = carrots + 1\n            \n            carrots\
    \ = carrots + 1\n            \n            carrots = carrots + 1\n           \
    \ \n            carrots = carrots + 1\n            \n            carrots = carrots\
    \ + 1\n            \n            carrots = carrots + 1\n            \n       \
    \     carrots = carrots + 1\n            \n            carrots = carrots + 1\n\
    \            \n            carrots = carrots + 1\n            \n            carrots\
    \ = carrots + 1\n            \n            carrots = carrots + 1\n           \
    \ \n            carrots = carrots + 1\n            \n            carrots = carrots\
    \ + 1\n            \n            carrots = carrots + 1\n            \n       \
    \     carrots = carrots + 1\n            \n            carrots = carrots + 1\n\
    \            \n            carrots = carrots + 1\n            \n            carrots\
    \ = carrots + 1\n            \n            carrots = carrots + 1\n           \
    \ \n            carrots = carrots + 1\n            \n            carrots = carrots\
    \ + 1\n            \n            carrots = carrots + 1\n            \n       \
    \     carrots = carrots + 1\n            \n            carrots = carrots + 1\n\
    \            \n            carrots = carrots + 1\n            \n            carrots\
    \ = carrots + 1\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptkv4k_e9.jl:1\nin expression starting at /tmp/tmptkv4k_e9.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = need\n    \n    carrots_eaten\
    \ = zeros(Int64, 2)\n    carrots_eaten[1] = number\n    carrots_eaten[2] = need\n\
    \    \n    carrots_left = carrots_left - carrots_eaten\n    \n    carrots_left\
    \ = carrots_left - carrots\n    \n    carrots_left = carrots_left - carrots_eaten\n\
    \    \n    carrots_left = carrots_left - carrots\n    \n    carrots_left = carrots_left\
    \ - carrots_eaten\n    \n    carrots_left = carrots_left - carrots\n    \n   \
    \ carrots_left = carrots_left - carrots_eaten\n    \n    carrots_left = carrots_left\
    \ - carrots\n    \n    carrots_left = carrots_left - carrots_eaten\n    \n   \
    \ carrots_left = carrots_left - carrots\n    \n    carrots_left = carrots_left\
    \ - carrots_eaten\n    \n    carrots_left = carrots_left - carrots\n    \n   \
    \ carrots_left = carrots_left - carrots_eaten\n    \n    carrots_left = carrots_left\
    \ - carrots\n    \n    carrots_left = carrots_left - carrots_eaten\n    \n   \
    \ carrots_left = carrots_left - carrots\n    \n    carrots_left = carrots_left\
    \ - carrots_eaten\n    \n    carrots_left = carrots_left - carrots\n    \n   \
    \ carrots_left = carrots_left - carrots_eaten\n    \n    carrots_left = carrots_left\
    \ - carrots\n    \n    carrots_left = carrots_left - carrots_eaten\n    \n   \
    \ carrots_left = carrots_left - carrots\n    \n    carrots_left = carrots_left\
    \ - carrots_eaten\n    \n    carrot\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvadcjz9c.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvadcjz9c.jl:1\n\
    in expression starting at /tmp/tmpvadcjz9c.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    else if need\
    \ < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\")\n  \
    \  else if remaining < 0 || remaining > 1000 \n        error(\"remaining must\
    \ be between 0 and 1000\")\n    else if number == 0 && need == 0 && remaining\
    \ == 0 \n        Vector{Int64}()\n    else\n        Vector{Int64}([number, need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7: Write a function that returns the number of carrots left after a meal\
    \ is completed.\nExample: \n>>> carrots_left(10, 5, 10)\n5\n>>> carrots_left(10,\
    \ 5, 0)\n0\n>>> carrots_left(10, 5, 5)\n0\n>>> carrots_left(10, 5, 15)\n15\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdoqatklm.jl:36\nin expression starting at\
    \ /tmp/tmpdoqatklm.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0 \n      \
    \  Vector{Int64}([need, remaining]) \n    else \n        Vector{Int64}([need,\
    \ remaining]) \n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<text>\nProblem 3\nWrite a function that takes a vector of integers and\
    \ returns the sum of the integers in the vector.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqk199gx6.jl:40\nin expression starting at\
    \ /tmp/tmpqk199gx6.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 \n  \
    \      error(\"Invalid input\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpou1m7llc.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpou1m7llc.jl:1\n\
    in expression starting at /tmp/tmpou1m7llc.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0 \n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = 0\n \
    \   carrots_eaten[2] = 0\n    \n    \n    while carrots[1] > 0 && meals[1] > 0\n\
    \        if carrots[1] > meals[1]\n            carrots[1] -= meals[1]\n      \
    \      carrots_left[1] -= meals[1]\n            carrots_eaten[1] += meals[1]\n\
    \            meals[1] = 0\n        else\n            carrots[1] -= carrots_eaten[1]\n\
    \            carrots_left[1] -= carrots_eaten[1]\n            carrots_eaten[2]\
    \ += carrots_eaten[1]\n            meals[1] = 0\n        end\n        if carrots[1]\
    \ <= 0\n            carrots[1] = carrots_left[1]\n            carrots_left[1]\
    \ = 0\n            carrots_eaten[2] += carrots[1]\n            meals[1] = 0\n\
    \        end\n        if meals[1] <= 0\n            meals[1] = carrots_eaten[2]\n\
    \            carrots_eaten[2] = 0\n            carrots_left[2] += meals[1]\n \
    \           meals[1] = 0\n        end\n    end\n    \n    carrots[1] = carrots_left[1]\n\
    \    carrots_left[1] = 0\n    carrots_eaten[2] += carrots[1]\n    meals[1] = 0\n\
    \    \n    return carrots_eaten\nend\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that will calculate the total cost of a meal based\
    \ on its ingredients.\nThe cost of a meal is defined as the sum of the ingredients'\
    \ prices.\nThe function should take as input a vector of Ingredient objects and\
    \ return a Float64.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjensyghq.jl:88\nin expression starting at\
    \ /tmp/tmpjensyghq.jl:88\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = remaining\n    \n    carrots[2] = carrots[2]\
    \ - need\n    \n    if carrots[2] < 0\n        carrots[2] = 0\n    end\n    \n\
    \    return carrots\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.0>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.0>\neat\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphws91hmq.jl:50\nin expression starting at\
    \ /tmp/tmphws91hmq.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        answer = []\n        carrots = number\n       \
    \ carrots_left = remaining\n        while carrots > 0 \n            carrots_left\
    \ -= 1\n            answer = [carrots_left, carrots_left+need]\n            carrots\
    \ -= 1\n        end\n        return answer\n    end\n    return []\nend\n</cell>\n\
    <code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<text>\nExercise 3\nWrite a\
    \ function that returns the number of carrots left after a meal is completed.\n\
    The function should take in two arguments: the number of carrots you have eaten\
    \ so far, and the number of carrots left after your meals.\nThe function should\
    \ return an integer that is the total number of carrots left after your meals.\n\
    The function should return 0 if there aren't enough carrots left after your meals.\n\
    The function should return an empty vector if there aren't enough carrots left\
    \ after your meals.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1810px1c.jl:47\nin expression starting at\
    \ /tmp/tmp1810px1c.jl:47\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpufc3t6yy.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpufc3t6yy.jl:1\n\
    in expression starting at /tmp/tmpufc3t6yy.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    elseif remaining < need\n        Vector{Int64}(remaining,\
    \ 0)\n    else\n        Vector{Int64}(number, 0)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.1>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.1>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.1>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.1>\n\
    eat(2, 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function that returns the\
    \ number of carrots left after a meal. \nIf there are not enough carrots left\
    \ after a meal, you will still be hungry.\nIf there are not enough carrots left\
    \ after a meal, you will eat all remaining carrots, but will still be hungry.\n\
    If there are not enough carrots left after a meal, you will eat all remaining\
    \ carrots, but will still be hungry.\nIf there are not enough carrots left after\
    \ a meal, you will eat all remaining carrots, but will still be hungry.\nIf there\
    \ are not enough carrots left after a meal, you will eat all remaining carrots,\
    \ but will still be hungry.\nIf there are not enough carrots left after a meal,\
    \ you will eat all remaining carrots, but will still be hungry.\nIf there are\
    \ not enough carrots left after a meal, you will eat all remaining carrots, but\
    \ will still be hungry.\nIf there are not enough carrots left after a meal, you\
    \ will eat all remaining carrots, but will still be hungry.\nIf there are not\
    \ enough carrots left after a meal, you will eat all remaining carrots, but will\
    \ still be hungry.\nIf there are not enough carrots left after a meal, you will\
    \ eat all remaining carrots, but will still be hungry.\nIf there are not enough\
    \ carrots left after a meal, you will eat all remaining carrots, but will still\
    \ be hungry.\nIf there are not enough carrots left after a meal, you will eat\
    \ all remaining carrots, but will still be hungry.\nIf there are not enough carrots\
    \ left after a meal, you will eat all remaining carrots, but will still be hungry.\n\
    If there are not enough carrots left after a meal, you will eat all remaining\
    \ carrots, but will still be h\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsqycrjb2.jl:42\nin expression starting at\
    \ /tmp/tmpsqycrjb2.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = need\n    \n    carrots_left[1] = remaining - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = need - number\n    \n    carrots_left[2]\
    \ = need - number\n    \n    carrots_left[1] = \nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsx4qzxhu.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsx4qzxhu.jl:1\n\
    in expression starting at /tmp/tmpsx4qzxhu.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64,\
    \ 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n    carrots_left =\
    \ zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = need\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n    \n    carrots_left = carrots_left[1]\n\
    \    \n    carrots_left = carrots_left[1]\n\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9f2noiyi.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9f2noiyi.jl:1\n\
    in expression starting at /tmp/tmp9f2noiyi.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    if number == 0\n        return [need,\
    \ remaining]\n    end\n    if remaining == 0\n        return [number, 0]\n   \
    \ end\n    \n    carrots = number\n    need = need - carrots\n    remaining =\
    \ remaining - carrots\n    \n    if remaining == 0\n        return [number, 0]\n\
    \    end\n    \n    return [number, carrots + need]\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprz2q0xcg.jl:54\nin expression starting at\
    \ /tmp/tmprz2q0xcg.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 \n  \
    \      error(\"invalid input\") \n    else \n        Vector{Int64}([number, need])\
    \ + Vector{Int64}([remaining, 0])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that takes in a list of\
    \ integers and returns the sum of the even numbers in that list.\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg8ase71d.jl:40\nin expression starting at\
    \ /tmp/tmpg8ase71d.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = need\n    \n    carrots_left = carrots_left - carrots\n    \n    carrots_left[1]\
    \ = carrots_left[1] - 1\n    \n    return carrots_left\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpte3x8rrd.jl:52\nin expression starting at\
    \ /tmp/tmpte3x8rrd.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > remaining \n\
    \        number = remaining\n    end\n    if need > remaining \n        need =\
    \ remaining\n    end\n    \n    \n    return Vector{Int64}([number, need])\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nProblem 9\n\
    Write a function called eat_all that takes in a list of numbers and returns a\
    \ vector of the numbers that you eat.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5by6k9gh.jl:44\nin expression starting at\
    \ /tmp/tmp5by6k9gh.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        return Vector{Int64}()\n    \n    carrots = number\n\
    \    meals = need\n    \n    meals_left = remaining\n    \n    meals_eaten = 0\n\
    \    \n    while meals_left > 0\n        meals_eaten += 1\n        meals_left\
    \ -= 1\n        \n        if meals_eaten > meals\n            meals_eaten = meals\n\
    \            meals_left += meals - meals_eaten\n        end\n    end\n    \n \
    \   carrots_left = meals_eaten\n    \n    return Vector{Int64}(carrots_left, meals_eaten)\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\n\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp805dbqg5.jl:58\nin expression starting at\
    \ /tmp/tmp805dbqg5.jl:58\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ return [need, remaining]\n    else\n        carrots = number - need\n      \
    \  if carrots > remaining\n            carrots = remaining\n        end\n    \
    \    return [carrots, remaining]\n    end\nend\n</cell>\n<code language=julia-0.6>\n\
    eat(5, 6, 10)\n</cell>\n<text>\nExercise 3\nWrite a function called eat_all that\
    \ takes in three integers, a number of carrots you have eaten,\na number of carrots\
    \ you have left to eat, and a number of carrots you have left to eat.\nIt should\
    \ return a vector of [ total number of eaten carrots after your meals,\nthe number\
    \ of carrots left after your meals ]\nif there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\nThe function\
    \ should return an empty vector if there aren't enough carrots to eat\nExample:\
    \ \neat_all(5, 6, 10)\n[11, 4]\neat_all(4, 8, 9)\n[12, 1]\neat_all(1, 10, 10)\n\
    [11, 0]\neat_all(2, 11, 5)\n[7, 0]\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2pyiw3vg.jl:44\nin expression starting at\
    \ /tmp/tmp2pyiw3vg.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return error(\"invalid input\")\n    end\n    if remaining == 0\n      \
    \  return [number, need]\n    end\n    \n    carrots = number\n    need = need\
    \ - carrots\n    remaining = remaining - carrots\n    \n    if need == 0\n   \
    \     return [carrots, remaining]\n    end\n    \n    carrots = carrots + eat(carrots,\
    \ need, remaining)[1]\n    \n    if carrots == 0\n        return [carrots, remaining]\n\
    \    end\n    \n    return [carrots, remaining]\nend\n</cell>\n<code language=julia-1.4>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.4>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.4>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.4>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 7\nWrite a function that returns the number\
    \ of ways you can reach a certain sum from any given starting point.\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2i5cw7zn.jl:57\nin expression starting at\
    \ /tmp/tmp2i5cw7zn.jl:57\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    else\n        Vector{Int64}([number-need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the number of days in a month.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl6_4dy1b.jl:40\nin expression starting at\
    \ /tmp/tmpl6_4dy1b.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = number\n\
    \    carrots_eaten[2] = 0\n    \n    while carrots_left[1] > 0 && carrots_eaten[1]\
    \ > 0\n        carrots_left[1] -= 1\n        carrots_eaten[1] -= 1\n        \n\
    \        if carrots_left[1] > 0\n            carrots_left[2] += 1\n          \
    \  carrots_eaten[2] += 1\n        end\n        \n        if carrots_eaten[1] >\
    \ 0\n            carrots_eaten[2] += 1\n        end\n    end\n    \n    return\
    \ carrots_eaten\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjbu3ixod.jl:70\nin expression starting at\
    \ /tmp/tmpjbu3ixod.jl:70\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return error(\"invalid input\")\n    end\n    \n    carrots = zeros(Int64,\
    \ 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = 0\n    \n    while\
    \ meals[1] > 0 && carrots_left[1] > 0\n        carrots_left[1] -= 1\n        meals[1]\
    \ -= 1\n        carrots[1] += 1\n    end\n    \n    return carrots, carrots_left\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that takes a vector of integers and returns the sum of the\
    \ integers in the vector.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpodho_raa.jl:58\nin expression starting at\
    \ /tmp/tmpodho_raa.jl:58\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64,\
    \ 2)\n    carrots[1] = number\n    carrots[2] = remaining\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = need\n    meals[2] = remaining\n    \n    meals_left = zeros(Int64,\
    \ 2)\n    meals_left[1] = number\n    meals_left[2] = remaining\n    \n    meals_right\
    \ = zeros(Int64, 2)\n    meals_right[1] = number\n    meals_right[2] = remaining\n\
    \    \n    meals_total = zeros(Int64, 2)\n    meals_total[1] = number\n    meals_total[2]\
    \ = remaining\n    \n    meals_left_total = zeros(Int64, 2)\n    meals_left_total[1]\
    \ = number\n    meals_left_total[2] = remaining\n    \n    meals_right_total =\
    \ zeros(Int64, 2)\n    meals_right_total[1] = number\n    meals_right_total[2]\
    \ = remaining\n    \n    meals_total_left = zeros(Int64, 2)\n    meals_total_left[1]\
    \ = number\n    meals_total_left[2] = remaining\n    \n    meals_total_right =\
    \ zeros(Int64, 2)\n    meals_total_right[1] = number\n    meals_total_right[2]\
    \ = remaining\n    \n    meals_total_left_right = zeros(Int64, 2)\n    meals_total_left_right[1]\
    \ = number\n    meals_total_left_right[2] = remaining\n    \n    meals_total_left_right_total\
    \ = zeros(Int64, 2)\n    meals_total_left_right_total[1] = number\n    meals_total_left_right_total[2]\
    \ = remaining\n    \n    meals_total_left_right_total_left = zeros(Int64, 2)\n\
    \    meals_total_left_right_total_left[1] = number\n    meals_total_left_right_total_left[2]\
    \ = remaining\n    \n    meals_total_left_right_total_right = zeros(Int64, 2)\n\
    \    meals_total_left_right_total_right[1] = number\n    meals_total_left_right_total_right[2]\
    \ = remaining\n    \n    meals_total_left_right_total_right_left = zeros(Int64,\
    \ 2)\n    meals_total_left_right_total_right_left[1] = number\n    meals_total_left_right_total_right_left[2]\
    \ = remaining\n    \n    meals_total_left_right_total_right_right = zeros(Int64,\
    \ 2)\n    meals_total_left_right_total_right_right[1] = number\n\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvk24nk89.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvk24nk89.jl:1\n\
    in expression starting at /tmp/tmpvk24nk89.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        carrots = number\n        carrots_left = remaining\n\
    \        meals = 0\n        \n        while carrots > 0\n            meals +=\
    \ 1\n            carrots_left -= 1\n            carrots -= 1\n        end\n  \
    \      \n        if carrots_left == 0\n            carrots = remaining\n     \
    \   end\n        \n        return Vector{Int64}([meals, carrots_left])\n    else\n\
    \        return Vector{Int64}([0, 0])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that takes a vector of\
    \ integers and returns the sum of the squares of the integers in the vector.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpysv6yll7.jl:54\nin expression starting at\
    \ /tmp/tmpysv6yll7.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    else if need\
    \ < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\")\n  \
    \  else if remaining < 0 || remaining > 1000 \n        error(\"remaining must\
    \ be between 0 and 1000\")\n    else\n        Vector{Int64}([number, need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of carrots left after a meal\
    \ is completed.\nThe function should take in a vector of [ number of carrots eaten\
    \ so far, number of carrots left after your meals ]\nand return the number of\
    \ carrots left after your meals.\nIf there are not enough carrots left after your\
    \ meals, you will eat all remaining carrots, but will still be hungry.\nThe function\
    \ should return 0 if there are not enough carrots left after your meals.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgd21cdms.jl:36\nin expression starting at\
    \ /tmp/tmpgd21cdms.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return error(\"invalid input\")\n    end\n    \n    carrots = zeros(Int64,\
    \ 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n    carrots_left =\
    \ zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = need\n\
    \    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = number\n  \
    \  carrots_eaten[2] = need\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = need\n    \n    carrots_eaten = zeros(Int64,\
    \ 2)\n    carrots_eaten[1] = number\n    carrots_eaten[2] = need\n    \n    carrots_left\
    \ = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = need\n\
    \    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = number\n  \
    \  carrots_eaten[2] = need\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = need\n    \n    carrots_eaten = zeros(Int64,\
    \ 2)\n    carrots_eaten[1] = number\n    carrots_eaten[2] = need\n    \n    carrots_left\
    \ = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = need\n\
    \    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = number\n  \
    \  carrots_eaten[2] = need\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = need\n    \n    carrots_eaten = zeros(Int64,\
    \ 2)\n    carrots_eaten[1] = number\n    carrots_eaten[2] = need\n    \n    carrots_left\
    \ = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = need\n\
    \    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = number\n  \
    \  carrots_eaten[2] = need\n    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1]\
    \ = remaining\n    carrots_left[2] = need\n    \n    carrots_eaten = \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpp_qsbttk.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpp_qsbttk.jl:1\n\
    in expression starting at /tmp/tmpp_qsbttk.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number should be between 0 and 1000\")\n    end\n \
    \   if need < 0 || need > 1000 \n        error(\"need should be between 0 and\
    \ 1000\")\n    end\n    if remaining < 0 || remaining > 1000 \n        error(\"\
    remaining should be between 0 and 1000\")\n    end\n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpew5x4r70.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpew5x4r70.jl:1\n\
    in expression starting at /tmp/tmpew5x4r70.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    while carrots[1] >\
    \ 0\n        carrots[1] -= carrots[2]\n        carrots[2] += 1\n    end\n    \n\
    \    carrots[1] = remaining\n    carrots[2] = 0\n    \n    return carrots\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that finds the minimum number of carrots you need to eat to make a certain amount\
    \ of carrots diet.\nThe function should take in two inputs:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmz0oebhh.jl:52\nin expression starting at\
    \ /tmp/tmpmz0oebhh.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 && number <= need && number <= remaining\n        \n    \
    \    \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa55zaz5o.jl:1\nin expression starting at /tmp/tmpa55zaz5o.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    else\n        Vector{Int64}([number, need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of carrots left after a meal\
    \ is complete.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe6kz54pn.jl:40\nin expression starting at\
    \ /tmp/tmpe6kz54pn.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    meals_left = zeros(Int64, 2)\n    meals_left[1] = remaining\n    meals_left[2]\
    \ = 0\n    \n    meals_total = zeros(Int64, 2)\n    meals_total[1] = number\n\
    \    meals_total[2] = 0\n    \n    while meals_total[1] > 0\n        meals_left[1]\
    \ = meals_left[1] - meals[1]\n        meals_left[2] = meals_left[2] - meals[2]\n\
    \        meals_total[1] = meals_total[1] - meals[1]\n        meals_total[2] =\
    \ meals_total[2] - meals[2]\n        \n        if meals_left[1] < 0\n        \
    \    meals_left[1] = 0\n            meals_left[2] = 0\n            meals[1] =\
    \ meals[1] + meals_left[1]\n            meals[2] = meals[2] + meals_left[2]\n\
    \            meals_total[1] = meals_total[1] + meals[1]\n            meals_total[2]\
    \ = meals_total[2] + meals[2]\n        end\n        if meals_left[2] < 0\n   \
    \         meals_left[2] = 0\n            meals_left[1] = 0\n            meals[1]\
    \ = meals[1] + meals_left[1]\n            meals[2] = meals[2] + meals_left[2]\n\
    \            meals_total[1] = meals_total[1] + meals[1]\n            meals_total[2]\
    \ = meals_total[2] + meals[2]\n        end\n    end\n    \n    return meals_total\n\
    end\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmparr8y_zf.jl:80\nin expression starting at\
    \ /tmp/tmparr8y_zf.jl:80\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    carrots[2] = remaining\
    \ - carrots[2]\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of days in a month.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzctd7duo.jl:46\nin expression starting at\
    \ /tmp/tmpzctd7duo.jl:46\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}(undef, 0)\n    else\n        Vector{Int64}(eat(number - 1, need\
    \ - number, remaining), number - 1)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa6vwdo8j.jl:40\nin expression starting at\
    \ /tmp/tmpa6vwdo8j.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    if number == 0\n \
    \       return Vector{Int64}()\n    end\n    if need == 0\n        return Vector{Int64}([number,\
    \ remaining])\n    end\n    if remaining == 0\n        return Vector{Int64}([number,\
    \ 0])\n    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpn8_409s5.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpn8_409s5.jl:1\n\
    in expression starting at /tmp/tmpn8_409s5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        return Vector{Int64}()\n    end\n    \n    carrots\
    \ = number\n    need = need\n    remaining = remaining\n    \n    while carrots\
    \ > 0\n        if remaining > need\n            carrots = carrots - need\n   \
    \         need = need\n        else\n            carrots = carrots - remaining\n\
    \            remaining = remaining\n        end\n    end\n    \n    return Vector{Int64}(carrots,\
    \ remaining)\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of prime numbers less than\
    \ a given integer $n$. \nThe function should return an empty vector if $n$ is\
    \ less than 2.\nThe function should return $n$ if $n$ is prime.\nThe function\
    \ should return $n$ if $n$ is prime.\nThe function should return $n$ if $n$ is\
    \ prime.\nThe function should return $n$ if $n$ is prime.\nThe function should\
    \ return $n$ if $n$ is prime.\nThe function should return $n$ if $n$ is prime.\n\
    The function should return $n$ if $n$ is prime.\nThe function should return $n$\
    \ if $n$ is prime.\nThe function should return $n$ if $n$ is prime.\nThe function\
    \ should return $n$ if $n$ is prime.\nThe function should return $n$ if $n$ is\
    \ prime.\nThe function should return $n$ if $n$ is prime.\nThe function should\
    \ return $n$ if $n$ is prime.\nThe function should return $n$ if $n$ is prime.\n\
    The function should return $n$ if $n$ is prime.\nThe function should return $n$\
    \ if $n$ is prime.\nThe function should return $n$ if $n$ is prime.\nThe function\
    \ should return $n$ if $n$ is prime.\nThe function should return $n$ if $n$ is\
    \ prime.\nThe function should return $n$ if $n$ is prime.\nThe function should\
    \ return $n$ if $\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7zoej4pw.jl:54\nin expression starting at\
    \ /tmp/tmp7zoej4pw.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    while meals[1] > 0\n        carrots_left[1] -= 1\n        meals[1]\
    \ -= 1\n        carrots[1] -= meals[1]\n    end\n    \n    while carrots[1] >\
    \ 0\n        meals[2] -= 1\n        carrots[1] -= meals[2]\n    end\n    \n  \
    \  return carrots_left\nend\n</cell>\n<code language=julia-1.3>\neat(5, 6, 10)\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns true if the given number\
    \ is even, and false if it is odd.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp02_myoeu.jl:63\nin expression starting at\
    \ /tmp/tmp02_myoeu.jl:63\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0\n        carrots = number\n        carrots_left = remaining\n\
    \        \n        meals_left = 0\n        \n        while carrots_left > 0 &&\
    \ meals_left < need\n            carrots_left -= 1\n            meals_left +=\
    \ 1\n        end\n        \n        if carrots_left == 0\n            carrots\
    \ = remaining\n        end\n        \n        return Vector{Int64}(carrots, carrots_left)\n\
    \    else\n        return Vector{Int64}(0, 0)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange n people into k groups of m people such that each group has\
    \ exactly one member from each of the n people.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjmptg378.jl:54\nin expression starting at\
    \ /tmp/tmpjmptg378.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    carrots[2] = carrots[2]\
    \ - carrots[1]\n    \n    if carrots[2] < 0\n        carrots[2] = 0\n    end\n\
    \    \n    if carrots[2] > remaining\n        carrots[2] = remaining\n    end\n\
    \    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6,\
    \ 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=juli\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpciocrsn5.jl:54\nin expression starting at\
    \ /tmp/tmpciocrsn5.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"invalid input\")\n    end\n    if number\
    \ == 0\n        return [need, remaining]\n    end\n    if remaining < need\n \
    \       error(\"not enough carrots left\")\n    end\n    \n    carrots = zeros(Int64,\
    \ 2)\n    carrots[1] = number\n    carrots[2] = remaining\n    \n    carrots =\
    \ carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrot\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7e_uuix.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7e_uuix.jl:1\n\
    in expression starting at /tmp/tmp_7e_uuix.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    if number > 1000 ||\
    \ need > 1000 || remaining > 1000\n        return Vector{Int64}()\n    end\n \
    \   \n    carrots = number\n    meals = need\n    \n    carrots_left = remaining\n\
    \    \n    while carrots_left > 0 && meals > 0\n        carrots_left -= 1\n  \
    \      meals -= 1\n    end\n    \n    if carrots_left == 0\n        return Vector{Int64}(carrots,\
    \ carrots_left)\n    else\n        return Vector{Int64}(carrots, 0)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that returns the number of minutes you need to wait until you can eat your meals.\n\
    The function should take in two inputs:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjmenclzi.jl:55\nin expression starting at\
    \ /tmp/tmpjmenclzi.jl:55\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    else if need\
    \ < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\")\n  \
    \  else if remaining < 0 || remaining > 1000 \n        error(\"remaining must\
    \ be between 0 and 1000\")\n    else if number == 0\n        Vector{Int64}([need,\
    \ remaining])\n    else\n        Vector{Int64}([number - need, remaining])\n \
    \   end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns a vector of [ number of carrots eaten\
    \ by rabbits,\n                                    number of carrots left after\
    \ rabbits eaten ]\n    \n    Example:\n    >>> eater(5, 6, 10)\n    [11, 4]\n\
    \    >>> eater(4, 8, 9)\n    [12, 1]\n    >>> eater(1, 10, 10)\n    [11, 0]\n\
    \    >>> eater(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n    @number : integer\n\
    \        the number of carrots that you have eaten.\n    @need : integer\n   \
    \     the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg3ga73r9.jl:36\nin expression starting at\
    \ /tmp/tmpg3ga73r9.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    else\n        Vector{Int64}([number-need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to make change for\
    \ n dollars.\nThe change for 1 dollar equals 1.\nThe change for 2 dollars is 1.\n\
    The change for 3 dollars is 2.\nThe change for 4 dollars is 3.\nThe change for\
    \ 5 dollars is 4.\nThe change for 6 dollars is 5.\nThe change for 7 dollars is\
    \ 6.\nThe change for 8 dollars is 7.\nThe change for 9 dollars is 8.\nThe change\
    \ for 10 dollars is 9.\nThe change for 11 dollars is 10.\nThe change for 12 dollars\
    \ is 11.\nThe change for 13 dollars is 12.\nThe change for 14 dollars is 13.\n\
    The change for 15 dollars is 14.\nThe change for 16 dollars is 15.\nThe change\
    \ for 17 dollars is 16.\nThe change for 18 dollars is 17.\nThe change for 19 dollars\
    \ is 18.\nThe change for 20 dollars is 19.\nThe change for 21 dollars is 20.\n\
    The change for 22 dollars is 21.\nThe change for 23 dollars is 22.\nThe change\
    \ for 24 dollars is 23.\nThe change for 25 dollars is 24.\nThe change for 26 dollars\
    \ is 25.\nThe change for 27 dollars is 26.\nThe change for 28 dollars is 27.\n\
    The change for 29 dollars is 28.\nThe change for 30 dollars is 29.\nThe change\
    \ for 31 dollars is 30.\nThe change for 32 dollars is 31.\nThe change for 33 dollars\
    \ is 32.\nThe change for 34 dollars is 33.\nThe change for 35 dollars is 34.\n\
    The change for 36 dollars is 35.\nThe change for 37 dollars is 36.\nThe change\
    \ for 38 dollars is 37.\nThe change for 39 dollars is 38.\nThe change for 40 dollars\
    \ is 39.\nThe change for 41 dollars is 40.\nThe change for 42 dollars is 41.\n\
    The change for 43 dollars is 42.\nThe change for 44 dollars is 43.\nThe change\
    \ for 45 dollars is 44.\nThe change for 46 dollars is 45.\nThe change for 47 dollars\
    \ is 46.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0_qfqvft.jl:40\nin expression starting at\
    \ /tmp/tmp0_qfqvft.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    if number\
    \ == 0\n        return [need, remaining]\n    end\n    if remaining < need\n \
    \       error(\"not enough carrots left\")\n    end\n    \n    carrots = zeros(Int64,\
    \ 2)\n    carrots[1] = number\n    carrots[2] = remaining\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = need\n    meals[2] = 0\n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7aj3_rw.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7aj3_rw.jl:1\n\
    in expression starting at /tmp/tmp_7aj3_rw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = 0\n    \n    carrots_total\
    \ = zeros(Int64, 2)\n    carrots_total[1] = 0\n    carrots_total[2] = 0\n    \n\
    \    while meals[1] > 0\n        carrots_left[1] -= 1\n        meals[1] -= 1\n\
    \        carrots_total[1] += carrots[1]\n        carrots[1] = carrots_left[1]\n\
    \    end\n    \n    while meals[2] > 0\n        carrots_left[2] += 1\n       \
    \ meals[2] -= 1\n        carrots_total[2] += carrots[2]\n        carrots[2] =\
    \ carrots_left[2]\n    end\n    \n    return carrots_total\nend\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo0tgcgvc.jl:70\nin expression starting at\
    \ /tmp/tmpo0tgcgvc.jl:70\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    if number == 0 && remaining == 0\n\
    \        return Vector{Int64}[]\n    end\n    \n    carrots = Vector{Int64}[]\n\
    \    \n    if number == 0\n        carrots = [need]\n    elseif need == 0\n  \
    \      carrots = [remaining]\n    else\n        carrots = [need, remaining]\n\
    \    end\n    \n    \n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of ways to arrange n numbers in m ways.\nThe function should take in two inputs:\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc6zwxh_4.jl:55\nin expression starting at\
    \ /tmp/tmpc6zwxh_4.jl:55\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        carrots = number - need\n        carrots_left =\
    \ remaining - carrots\n        \n        if carrots_left == 0 \n            carrots_left\
    \ = 1\n            \n        return [carrots, carrots_left]\n    else\n      \
    \  carrots_left = 0\n        return [carrots_left, carrots_left]\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of times a given number appears in a given vector.\n\
    The function should take two arguments:\na vector of integers, and a number.\n\
    The function should return the number of times the given number appears in the\
    \ vector.\nIf there is no number in the vector that matches the given number,\
    \ the function should return 0.\nThe function should return 0 if the vector is\
    \ empty.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvk3ngjbp.jl:47\nin expression starting at\
    \ /tmp/tmpvk3ngjbp.jl:47\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        answer = []\n        \n        for i = 1:number\n\
    \            push!(answer, 0)\n        end\n        \n        for i = 1:need\n\
    \            push!(answer, 0)\n        end\n        \n        for i = 1:remaining\n\
    \            push!(answer, 0)\n        end\n        \n        for i = 1:number\n\
    \            answer[i] = answer[i] + 1\n        end\n        \n        for i =\
    \ 1:need\n            answer[i] = answer[i] + 1\n        end\n        \n     \
    \   for i = 1:remaining\n            answer[i] = answer[i] + 1\n        end\n\
    \        \n        return answer\n    else\n        error(\"You cannot eat negative\
    \ carrots or carrots that do not exist.\")\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 0)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 0, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 0, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 0, 0)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 0, 0)\n</cell>\n<code language=julia-\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt7r395t3.jl:66\nin expression starting at\
    \ /tmp/tmpt7r395t3.jl:66\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && number\
    \ <= 1000 && need > 0 && need <= 1000 && remaining > 0 && remaining <= 1000\n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4l9ovz3u.jl:1\nin expression starting at /tmp/tmp4l9ovz3u.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpy7vp6oxk.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpy7vp6oxk.jl:1\n\
    in expression starting at /tmp/tmpy7vp6oxk.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0 \n      \
    \  Vector{Int64}(undef, 0) \n    else \n        Vector{Int64}(undef, number -\
    \ need) \n    end\nend\n</cell>\n<text>\nProblem 3\nWrite a function that returns\
    \ the number of ways to arrange a certain number of cards into a pile of cards.\n\
    The piles are represented by a vector of integers where the i-th element of the\
    \ vector is the number of cards remaining in the i-th pile.\nThe function should\
    \ return an vector of integers where the i-th element of the vector is the number\
    \ of ways to arrange the i-th number of cards into a pile of cards.\nThe function\
    \ should return an empty vector if the number of cards cannot be arranged into\
    \ a pile of cards.\nThe function should return an vector of integers where the\
    \ i-th element of the vector is the number of ways to arrange the i-th number\
    \ of cards into a pile of cards.\nThe function should return an empty vector if\
    \ the number of cards cannot be arranged into a pile of cards.\nThe function should\
    \ return an vector of integers where the i-th element of the vector is the number\
    \ of ways to arrange the i-th number of cards into a pile of cards.\nThe function\
    \ should return an empty vector if the number of cards cannot be arranged into\
    \ a pile of cards.\nThe function should return an vector of integers where the\
    \ i-th element of the vector is the number of ways to arrange the i-th number\
    \ of cards into a pile of cards.\nThe function should return an empty vector if\
    \ the number of cards cannot be arranged into a pile of cards.\nThe function should\
    \ return an vector of integers where the i-th element of the vector is the number\
    \ of ways to arrange the i-th number of cards into a pile of cards.\nThe function\
    \ should return an empty vector if the number of cards cannot be arranged into\
    \ a pile of cards.\nThe function should return an vector of integers where the\
    \ i-th element of the vector is the number of ways to arrange the i-th number\
    \ of cards into a pile of cards.\nThe function should return an empty vector if\
    \ the number of cards cannot be arranged into a pile of cards.\nThe function should\
    \ return an vector of integers where the i-th element of the vector is the number\
    \ of ways to arrange the i-th number of cards into a pile of cards.\nThe function\
    \ should return an empty vector if the number of cards cannot be arranged into\
    \ a pile of cards.\nThe function should return an vector of integers where the\
    \ i-th element of the vector is the number of ways to arrange the i-th number\
    \ of cards into a pile of cards.\nThe function should return an empty vector if\
    \ the number of cards cannot be arranged into a \nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1kaerasr.jl:40\nin expression starting at\
    \ /tmp/tmp1kaerasr.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = remaining\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = need\n    meals[2] = 0\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = 0\n    \n    meals_left\
    \ = zeros(Int64, 2)\n    meals_left[1] = 0\n    meals_left[2] = 0\n    \n    while\
    \ carrots_left[2] > 0 || meals_left[2] > 0\n        if carrots_left[2] > 0\n \
    \           carrots_left[2] -= 1\n            meals_left[2] += 1\n        end\n\
    \        if meals_left[2] > 0\n            meals_left[2] -= 1\n            carrots_left[2]\
    \ += 1\n        end\n    end\n    \n    return carrots, meals\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 11)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 12)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 13)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 14)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 15)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 16)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 17)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 18)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 19)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 20)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 21)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 22)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 23)\n</cell>\n<code\
    \ language=juli\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8tu_sya1.jl:67\nin expression starting at\
    \ /tmp/tmp8tu_sya1.jl:67\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 1000 || need\
    \ > 1000 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp35iajxwt.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp35iajxwt.jl:1\n\
    in expression starting at /tmp/tmp35iajxwt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpufc3t6yy.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpufc3t6yy.jl:1\n\
    in expression starting at /tmp/tmpufc3t6yy.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    end\n   \
    \ if need < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\"\
    )\n    end\n    if remaining < 0 || remaining > 1000 \n        error(\"remaining\
    \ must be between 0 and 1000\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbfzatku5.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbfzatku5.jl:1\n\
    in expression starting at /tmp/tmpbfzatku5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    else if need\
    \ < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\")\n  \
    \  else if remaining < 0 || remaining > 1000 \n        error(\"remaining must\
    \ be between 0 and 1000\")\n    else \n        Vector{Int64}([number, need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the number of days until a rabbit eats\
    \ another rabbit.\nThe function should take two integer arguments: the number\
    \ of rabbits that need to be eaten and the number of rabbits that need to be eaten\
    \ again.\nThe function should return an integer that represents the number of\
    \ days until a rabbit eats another rabbit.\nThe function should return -1 if the\
    \ number of rabbits that need to be eaten is less than or equal to zero.\nThe\
    \ function should return -2 if the number of rabbits that need to be eaten is\
    \ greater than or equal to zero.\nThe function should return -3 if the number\
    \ of rabbits that need to be eaten is equal to zero.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphrj9lj69.jl:36\nin expression starting at\
    \ /tmp/tmphrj9lj69.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && number\
    \ <= 1000 && need > 0 && need <= 1000 && remaining > 0 && remaining <= 1000\n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4l9ovz3u.jl:1\nin expression starting at /tmp/tmp4l9ovz3u.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 1000 || need\
    \ > 1000 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n\
    \    carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    while carrots[1] > 0\n        carrots[1] -= carrots[2]\n        carrots[2]\
    \ += 1\n    end\n    \n    carrots[1] = remaining\n    carrots[2] = 0\n    \n\
    \    return carrots\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv35mfbyk.jl:52\nin expression starting at\
    \ /tmp/tmpv35mfbyk.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n   \
    \ \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqv_12_1e.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqv_12_1e.jl:1\n\
    in expression starting at /tmp/tmpqv_12_1e.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 1000 || need\
    \ > 1000 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n\
    \    carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = number\n    carrots_left[2]\
    \ = remaining\n    \n    meals_left = zeros(Int64, 2)\n    meals_left[1] = need\n\
    \    meals_left[2] = remaining\n    \n    while carrots_left[2] > 0 || meals_left[2]\
    \ > 0\n        if carrots_left[2] > 0\n            carrots_left[2] -= 1\n    \
    \        carrots[1] += 1\n        end\n        if meals_left[2] > 0\n        \
    \    meals_left[2] -= 1\n            meals[1] += 1\n        end\n    end\n   \
    \ \n    return carrots, meals\nend\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdq9zv9gt.jl:67\nin expression starting at\
    \ /tmp/tmpdq9zv9gt.jl:67\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        \n        \n        \n        \n        \n    \
    \    \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
    \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7hxcd2r8.jl:1\nin expression starting at /tmp/tmp7hxcd2r8.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    while carrots[1] >\
    \ 0\n        carrots[1] -= carrots[2]\n        carrots[2] += 1\n    end\n    \n\
    \    if carrots[1] > 0\n        carrots[1] -= carrots[2]\n        carrots[2] +=\
    \ 1\n    end\n    \n    return carrots\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<text>\nProblem 3\nWrite a function that returns the number\
    \ of times a given string occurs in a given string.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuw1040t_.jl:54\nin expression starting at\
    \ /tmp/tmpuw1040t_.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ return [need, remaining]\n    else\n        carrots = number\n        need =\
    \ need - carrots\n        remaining = remaining - carrots\n        \n        if\
    \ remaining < 0\n            carrots = remaining\n            need = need + carrots\n\
    \            remaining = remaining + carrots\n        end\n        \n        return\
    \ [need, remaining]\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that will return the number of carrots left after a meal is completed.\nThe\
    \ function should take in two arguments:\n@meal : integer\n    the number of carrots\
    \ left after a meal is completed\n@meals : vector of integers\n    the vector\
    \ of carrots left after a meal is completed\nThe function should return an integer\n\
    Constraints:\n* 0 <= meal <= 1000\n* 0 <= meals <= 1000\n* meals is a vector of\
    \ integers\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpokiuig1m.jl:50\nin expression starting at\
    \ /tmp/tmpokiuig1m.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    elseif number == remaining\n        Vector{Int64}(remaining,\
    \ 0)\n    else\n        Vector{Int64}(remaining, number - need)\n    end\nend\n\
    </cell>\n<text>\nProblem 7\nWrite a function that takes a vector of integers and\
    \ returns a vector of booleans indicating whether each element in the vector is\
    \ even or odd.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaeol2nx7.jl:42\nin expression starting at\
    \ /tmp/tmpaeol2nx7.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    end\n   \
    \ if need < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\"\
    )\n    end\n    if remaining < 0 || remaining > 1000 \n        error(\"remaining\
    \ must be between 0 and 1000\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbfzatku5.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbfzatku5.jl:1\n\
    in expression starting at /tmp/tmpbfzatku5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 1000 || need\
    \ > 1000 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n\
    \    carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n\
    \    \n    while carrots[1] > 0 && carrots[2] > 0\n        if carrots[1] > need\n\
    \            carrots[1] -= need\n        else\n            carrots[2] -= carrots[1]\n\
    \            carrots[1] = 0\n        end\n    end\n    \n    return carrots\n\
    end\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that finds the number of ways to arrange n integers into\
    \ k groups of m numbers each, such that the sum of the numbers in the groups is\
    \ exactly equal to the given sum.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjwi_h6_n.jl:53\nin expression starting at\
    \ /tmp/tmpjwi_h6_n.jl:53\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    \n    if\
    \ remaining == 0\n        return Vector{Int64}([number, need])\n    end\n    \n\
    \    carrots = number\n    need = need - carrots\n    remaining = remaining -\
    \ carrots\n    \n    if need == 0\n        return Vector{Int64}([number, remaining])\n\
    \    end\n    \n    return eat(number, need, remaining)\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqrjpt_j5.jl:52\nin expression starting at\
    \ /tmp/tmpqrjpt_j5.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        \n        \n        \n        \n        \n    \
    \    \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6,\
    \ 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7hxcd2r8.jl:1\nin expression starting at /tmp/tmp7hxcd2r8.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    elseif number < 0\n        error(\"number must be positive\"\
    )\n    elseif need < 0\n        error(\"need must be positive\")\n    elseif remaining\
    \ < 0\n        error(\"remaining must be positive\")\n    elseif number > remaining\n\
    \        error(\"number must be less than remaining\")\n    elseif need > remaining\n\
    \        error(\"need must be less than remaining\")\n    elseif number == remaining\n\
    \        Vector{Int64}([number, 0])\n    else\n        Vector{Int64}([number,\
    \ need-number])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzzmokouk.jl:52\nin expression starting at\
    \ /tmp/tmpzzmokouk.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    if number ==\
    \ 0\n        return Vector{Int64}()\n    end\n    \n    if remaining == 0\n  \
    \      return Vector{Int64}([number, need])\n    end\n    \n    if number > remaining\n\
    \        return Vector{Int64}()\n    end\n    \n    if need == 0\n        return\
    \ Vector{Int64}([number, remaining])\n    end\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppw4ezxlq.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppw4ezxlq.jl:1\n\
    in expression starting at /tmp/tmppw4ezxlq.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}([need, remaining])\n    else\n        Vector{Int64}([need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.3>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.3>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.3>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 7: Sum square difference\nYou are given two vectors $x$ and $y$ of size\
    \ $n$. Your task is to find the sum of square difference between $x$ and $y$.\
    \ \nThe formula for sum of square difference is:\n$$\\sum_{i=1}^{n}(x_i - y_i)^2$$\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8kg7cvxv.jl:40\nin expression starting at\
    \ /tmp/tmp8kg7cvxv.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ return [need, remaining]\n    \n    carrots = number\n    \n    if remaining\
    \ == 0\n        return [carrots, 0]\n    \n    carrots = remaining % need\n  \
    \  \n    if carrots == 0\n        return [carrots, 0]\n    \n    return [carrots,\
    \ need]\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of days in a month.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph2gr0qbi.jl:49\nin expression starting at\
    \ /tmp/tmph2gr0qbi.jl:49\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && number\
    \ <= 1000 && need > 0 && need <= 1000 && remaining > 0 && remaining <= 1000\n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4l9ovz3u.jl:1\nin expression starting at /tmp/tmp4l9ovz3u.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 \n  \
    \      error(\"Invalid input\") \n    else \n        Vector{Int64}([number, need,\
    \ remaining]) \n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns true if the given string is a palindrome\
    \ and false otherwise.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfptgzb63.jl:40\nin expression starting at\
    \ /tmp/tmpfptgzb63.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    if number < 0 || need\
    \ < 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    \n    if\
    \ number == 0 && need == 0 && remaining == 0\n        return Vector{Int64}()\n\
    \    end\n    \n    if number == 0 && need == 0 && remaining > 0\n        return\
    \ Vector{Int64}(remaining, 0)\n    end\n    \n    if number == 0 && need > 0 &&\
    \ remaining == 0\n        return Vector{Int64}(0, need)\n    end\n    \n    if\
    \ number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ 0)\n    end\n    \n    if number > 0 && need == 0 && remaining > 0\n       \
    \ return Vector{Int64}(number, need)\n    end\n    \n    if number > 0 && need\
    \ > 0 && remaining == 0\n        return Vector{Int64}(number, need)\n    end\n\
    \    \n    if number > 0 && need > 0 && remaining > 0\n        return Vector{Int64}(number,\
    \ need)\n    end\n    \n    return Vector{Int64}()\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpc0emuhxf.jl:69\nin expression starting at\
    \ /tmp/tmpc0emuhxf.jl:69\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    if number == 0 && remaining == 0\n\
    \        return Vector{Int64}[]\n    end\n    if number == 0\n        return Vector{Int64}[],\
    \ remaining\n    end\n    if remaining == 0\n        return Vector{Int64}[], number\n\
    \    end\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6tlyfyv3.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6tlyfyv3.jl:1\n\
    in expression starting at /tmp/tmp6tlyfyv3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    elseif remaining < need\n        Vector{Int64}(remaining,\
    \ 0)\n    elseif number < need\n        Vector{Int64}(0, need-number)\n    else\n\
    \        Vector{Int64}(0, need-remaining+number)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes in a vector of integers and returns the number of positive integers\
    \ less than or equal to that number.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp408thuif.jl:44\nin expression starting at\
    \ /tmp/tmp408thuif.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > remaining \n\
    \        number = remaining\n    end\n    if number == 0 \n        return Vector{Int64}(0,\
    \ 0) \n    end\n    if number > need \n        number = need\n    end\n    \n\
    \    \n    \n    return Vector{Int64}(number, number - need)\nend\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that returns the number of carrots left after a meal is complete.\nThe function\
    \ should take in two parameters: the number of carrots you have eaten so far,\
    \ and the total number of carrots left.\nThe function should return an integer\
    \ that represents the number of carrots left after a meal is complete.\nThe function\
    \ should return 0 if the number of carrots left after a meal is complete is 0.\n\
    The function should return -1 if the number of carrots left after a meal is complete\
    \ is negative.\nThe function should return an error if the number of carrots left\
    \ after a meal is complete is greater than the number of carrots you have eaten\
    \ so far.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3mavuz_0.jl:48\nin expression starting at\
    \ /tmp/tmp3mavuz_0.jl:48\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    if number == 0\n        return [need,\
    \ remaining]\n    end\n    \n    carrots_left::Int64 = remaining - need\n    carrots_eaten::Int64\
    \ = number\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_left::Int64 = remaining\
    \ - need\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_left::Int64 = remaining\
    \ - need\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_left::Int64 = remaining\
    \ - need\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_left::Int64 = remaining\
    \ - need\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_left::Int64 = remaining\
    \ - need\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_left::Int64 = remaining\
    \ - need\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_left::Int64 = remaining\
    \ - need\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_left::Int64 = remaining\
    \ - need\n    \n    if carrots_left == 0\n        return [carrots_eaten, remaining]\n\
    \    end\n    \n    carrots_eaten::Int64 = number\n    carrots_\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpx5c6g8yo.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpx5c6g8yo.jl:1\n\
    in expression starting at /tmp/tmpx5c6g8yo.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n    meals_left = zeros(Int64,\
    \ 2)\n    meals_left[1] = 0\n    meals_left[2] = 0\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = 0\n    carrots_left[2] = 0\n    \n    while meals[1]\
    \ > 0\n        carrots_left[1] += meals[1]\n        meals[1] -= meals[1]\n   \
    \     carrots[1] -= carrots[1]\n        \n        if carrots[1] > 0\n        \
    \    meals_left[1] += carrots[1]\n            carrots[1] -= carrots[1]\n     \
    \   end\n        \n        if meals_left[1] > 0\n            meals[1] -= meals_left[1]\n\
    \            meals_left[1] -= meals_left[1]\n        end\n        \n        if\
    \ carrots_left[1] > 0\n            carrots[1] -= carrots_left[1]\n           \
    \ carrots_left[1] -= carrots_left[1]\n        end\n    end\n    \n    return carrots\n\
    end\n</cell>\n<code language=julia-1.4>\neat(5, 6, 10)\n</cell>\n<text>\nProblem\
    \ 7\nWrite a function that returns a vector of [number of carrots eaten by rabbits,\n\
    number of carrots left after rabbits eat]\nif there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbmilhkpc.jl:77\nin expression starting at\
    \ /tmp/tmpbmilhkpc.jl:77\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        carrots = number\n        need = need\n       \
    \ remaining = remaining\n        \n        carrots_left = remaining\n        \n\
    \        carrots_eaten = 0\n        \n        while carrots_left > 0 \n      \
    \      carrots_eaten += 1 \n            carrots_left -= 1\n            \n    \
    \    end\n        \n        carrots_eaten\n        carrots_left\n    else\n  \
    \      0\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    You have\
    \ a certain number of carrots, and you have a certain number of meals.\n    You\
    \ want to eat as many carrots as possible, but you only have enough carrots to\
    \ eat one meal.\n    \n    Example:\n    >>> eat_meals(5, 10)\n    [5, 0]\n  \
    \  >>> eat_meals(5, 6)\n    [5, 0]\n    >>> eat_meals(5, 7)\n    [5, 0]\n    >>>\
    \ eat_meals(5, 8)\n    [5, 0]\n    >>> eat_meals(5, 9)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 10)\n    [5, 0]\n    >>> eat_meals(5, 11)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 12)\n    [5, 0]\n    >>> eat_meals(5, 13)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 14)\n    [5, 0]\n    >>> eat_meals(5, 15)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 16)\n    [5, 0]\n    >>> eat_meals(5, 17)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 18)\n    [5, 0]\n    >>> eat_meals(5, 19)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 20)\n    [5, 0]\n    >>> eat_meals(5, 21)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 22)\n    [5, 0]\n    >>> eat_meals(5, 23)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 24)\n    [5, 0]\n    >>> eat_meals(5, 25)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 26)\n    [5, 0]\n    >>> eat_meals(5, 27)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 28)\n    [5, 0]\n    >>> eat_meals(5, 29)\n    [5, 0]\n    >>> eat_meals(5,\
    \ 30)\n    [5, 0]\n    >>> eat_meals(5, 31)\n\nusing Test\n\n@testset begin\n\n\
    candidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpck4hdg_i.jl:55\nin expression starting at\
    \ /tmp/tmpck4hdg_i.jl:55\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    if\
    \ number == 0\n        return [need, remaining]\n    end\n    \n    if remaining\
    \ < need\n        error(\"not enough carrots to eat\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n   \
    \ \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n \
    \   carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpf1h1c_bs.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpf1h1c_bs.jl:1\n\
    in expression starting at /tmp/tmpf1h1c_bs.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n   \
    \ \n    meals = zeros(Int64, 2)\n    meals[1] = need\n    meals[2] = remaining\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = number\n    carrots_left[2]\
    \ = remaining\n    \n    carrots_left_after_meals = zeros(Int64, 2)\n    carrots_left_after_meals[1]\
    \ = number\n    carrots_left_after_meals[2] = remaining\n    \n    carrots_left_after_meals[1]\
    \ = carrots_left[1]\n    carrots_left_after_meals[2] = carrots_left[2]\n    \n\
    \    carrots_left_after_meals[1] = carrots_left[1]\n    carrots_left_after_meals[2]\
    \ = carrots_left[2]\n    \n    carrots_left_after_meals[1] = carrots_left[1]\n\
    \    carrots_left_after_meals[2] = carrots_left[2]\n    \n    carrots_left_after_meals[1]\
    \ = carrots_left[1]\n    carrots_left_after_meals[2] = carrots_left[2]\n    \n\
    \    carrots_left_after_meals[1] = carrots_left[1]\n    carrots_left_after_meals[2]\
    \ = carrots_left[2]\n    \n    carrots_left_after_meals[1] = carrots_left[1]\n\
    \    carrots_left_after_meals[2] = carrots_left[2]\n    \n    carrots_left_after_meals[1]\
    \ = carrots_left[1]\n    carrots_left_after_meals[2] = carrots_left[2]\n    \n\
    \    carrots_left_after_meals[1] = carrots_left[1]\n    carrots_left_after_meals[2]\
    \ = carrots_left[2]\n    \n    carrots_left_after_meals[1] = carrots_left[1]\n\
    \    carrots_left_after_meals[2] = carrots_left[2]\n    \n    carrots_left_after_meals[1]\
    \ = carrots_left[1]\n    carrots_left_after_meals[2] = carrots_left[2]\n    \n\
    \    carrots_left_after_meals[1] = carrots_left[1]\n    carrots_left_after_meals[2]\
    \ = carrots_left[2]\n    \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpte2shelm.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpte2shelm.jl:1\n\
    in expression starting at /tmp/tmpte2shelm.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        carrots = zeros(Int64, 2)\n        carrots[1] =\
    \ number\n        carrots[2] = remaining\n        \n        if number > need \n\
    \            carrots[1] = carrots[1] - need\n            carrots[2] = carrots[2]\
    \ - 1\n        end\n        \n        if carrots[1] > 0\n            carrots[1]\
    \ = carrots[1] - 1\n        end\n        \n        if carrots[2] > 0\n       \
    \     carrots[2] = carrots[2] - 1\n        end\n        \n        return carrots\n\
    \    else\n        return zeros(Int64, 2)\n    end\nend\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that returns the number of days until a rabbit eats its\
    \ first meal.\nThe rabbit starts at day 0 and needs to eat meals until day 100.\
    \ \nThe rabbit eats meals one at a time, and each day it eats one meal it eats\
    \ one carrot.\nThe rabbit eats meals until it reaches day 100. \nThe rabbit eats\
    \ meals until it reaches day 200. \nThe rabbit eats meals until it reaches day\
    \ 300. \nThe rabbit eats meals until it reaches day 400. \nThe rabbit eats meals\
    \ until it reaches day 500. \nThe rabbit eats meals until it reaches day 600.\
    \ \nThe rabbit eats meals until it reaches day 700. \nThe rabbit eats meals until\
    \ it reaches day 800. \nThe rabbit eats meals until it reaches day 900. \nThe\
    \ rabbit eats meals until it reaches day 1000. \nThe rabbit eats meals until it\
    \ reaches day 1100. \nThe rabbit eats meals until it reaches day 1200. \nThe rabbit\
    \ eats meals until it reaches day 1300. \nThe rabbit eats meals until it reaches\
    \ day 1400. \nThe rabbit eats meals until it reaches day 1500. \nThe rabbit eats\
    \ meals until it reaches day 1600. \nThe rabbit eats meals until it reaches day\
    \ 1700. \nThe rabbit eats meals until it reaches day 1800\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqp7exb33.jl:57\nin expression starting at\
    \ /tmp/tmpqp7exb33.jl:57\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvuyey6d2.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvuyey6d2.jl:1\n\
    in expression starting at /tmp/tmpvuyey6d2.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ return [need, remaining]\n    \n    if remaining < need\n        return [need,\
    \ remaining]\n    \n    if number > remaining\n        return [number, 0]\n  \
    \  \n    if number == remaining\n        return [number, 0]\n    \n    if number\
    \ < need\n        return [number, 0]\n    \n    if number == need\n        return\
    \ [number, 0]\n    \n    if number > need\n        return [number, 0]\n    \n\
    \    if number == remaining\n        return [number, 0]\n    \n    if number <\
    \ remaining\n        return [number, 0]\n    \n    if number == remaining\n  \
    \      return [number, 0]\n    \n    if number < need\n        return [number,\
    \ 0]\n    \n    if number == need\n        return [number, 0]\n    \n    if number\
    \ > need\n        return [number, 0]\n    \n    if number == remaining\n     \
    \   return [number, 0]\n    \n    if number < remaining\n        return [number,\
    \ 0]\n    \n    if number == remaining\n        return [number, 0]\n    \n   \
    \ if number < need\n        return [number, 0]\n    \n    if number == need\n\
    \        return [number, 0]\n    \n    if number > need\n        return [number,\
    \ 0]\n    \n    if number == remaining\n        return [number, 0]\n    \n   \
    \ if number < remaining\n        return [number, 0]\n    \n    if number == remaining\n\
    \        return [number, 0]\n    \n    if number < need\n        return [number,\
    \ 0]\n    \n    if number == need\n        return [number, 0]\n    \n    if number\
    \ > need\n        return [number, 0]\n    \n    if number == remaining\n     \
    \   return [number, 0]\n    \n    if number < remaining\n        return [number,\
    \ 0]\n    \n    if number == remaining\n        return [number, 0]\n    \n   \
    \ if number < need\n        return [number, 0]\n    \n    if number == need\n\
    \        return [number, 0]\n    \n    if number > need\n        return [number,\
    \ 0]\n    \n    if number == remaining\n        return [number, 0]\n    \n   \
    \ if number < remaining\n        return [number, 0]\n    \n    if number == remaining\n\
    \        return [number, 0]\n    \n    if number < need\n        return [number,\
    \ 0]\n    \n    if number == need\n        return [number, 0]\n    \n    if number\
    \ > need\n        return [number, 0]\n    \n    if number == remaining\n     \
    \   return [number, 0]\n    \n    if number < remaining\n        return [number,\
    \ 0]\n    \n    if number == remaining\n        return [number, 0]\n    \n   \
    \ if number < need\n        return [number, 0]\n    \n    if number == need\n\
    \        return [number, 0]\n    \n    if number > need\n        return [number,\
    \ 0]\n    \n    if number == remaining\n        return [number, 0]\n    \n   \
    \ if number < remaining\n        return [number, 0]\n    \n    if number == remaining\n\
    \        return [number, 0]\n    \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplynmo_bl.jl:1\nin expression starting at /tmp/tmplynmo_bl.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvuyey6d2.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvuyey6d2.jl:1\n\
    in expression starting at /tmp/tmpvuyey6d2.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 1000 || need\
    \ > 1000 || remaining > 1000\n        error(\"Invalid input\")\n    end\n    \n\
    \    carrots = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots\
    \ = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n\
    \    \n    carrots = carrots[2:end]\n    \n    carrots = carrots[2:end]\n    \n\
    \    carrots = carrots[2:end]\n    \n    carrots = carrots[2:\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn2ibdn6d.jl:119\nin expression starting at\
    \ /tmp/tmpn2ibdn6d.jl:119\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    if number\
    \ == 0\n        return Vector{Int64}([need, remaining])\n    end\n    if remaining\
    \ == 0\n        return Vector{Int64}([number, 0])\n    end\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgucg6ztd.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpgucg6ztd.jl:1\n\
    in expression starting at /tmp/tmpgucg6ztd.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        carrots = number\n        meals = need\n      \
    \  carrots_left = remaining\n        \n        carrots_eaten = 0\n        carrots_left\
    \ = 0\n        \n        while carrots_eaten < meals && carrots_left > 0 \n  \
    \          carrots_eaten += 1 \n            carrots_left -= 1\n            \n\
    \        end\n        \n        if carrots_eaten < meals \n            carrots_eaten\
    \ = meals\n            carrots_left = 0\n        end\n        \n        return\
    \ Vector{Int64}(carrots_eaten, carrots_left)\n    else\n        return Vector{Int64}(0,\
    \ 0)\n    end\nend\n</cell>\n<code language=julia-1.5>\n# Test your code\neat(5,\
    \ 6, 10)\n</cell>\n<text>\nProblem 3\nThe Fibonacci sequence is defined by the\
    \ formula:\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwk9n2aa7.jl:58\nin expression starting at\
    \ /tmp/tmpwk9n2aa7.jl:58\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 \n  \
    \      error(\"Invalid input\")\n    else \n        Vector{Int64}([number, need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.0>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.0>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange n people\
    \ into k groups of m people each, such that the total sum of people in each group\
    \ is maximized.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp25pu0dau.jl:40\nin expression starting at\
    \ /tmp/tmp25pu0dau.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    \n    while true\n        \n        if carrots[1] > 0\n     \
    \       carrots[1] -= 1\n            meals[2] += 1\n            carrots_left[1]\
    \ -= 1\n            carrots_left[2] += 1\n        else\n            break\n  \
    \      end\n    end\n    \n    \n    return carrots, carrots_left\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbzk1flpd.jl:66\nin expression starting at\
    \ /tmp/tmpbzk1flpd.jl:66\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}([need, remaining])\n    else\n        Vector{Int64}([number, need])\n\
    \    end\nend\n</cell>\n<code language=julia-0.6>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function called eat_all that takes three integers as arguments\
    \ and returns the number of carrots you would need to eat to complete the day's\
    \ meals.\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjgg88r_j.jl:40\nin expression starting at\
    \ /tmp/tmpjgg88r_j.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    if number == 0\n \
    \       Vector{Int64}([need, remaining])\n    elseif number < need\n        Vector{Int64}([number,\
    \ remaining])\n    else\n        Vector{Int64}([need, number - need])\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test your code\neat(5, 6, 10)\n</cell>\n\
    <text>\nProblem 3\nThe Fibonacci sequence is defined by the formula:\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbig_5a33.jl:43\nin expression starting at\
    \ /tmp/tmpbig_5a33.jl:43\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000 \n  \
    \      error(\"Invalid input\") \n    else \n        Vector{Int64}([number, need])\
    \ + Vector{Int64}([remaining, 0])\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_y3sxokp.jl:40\nin expression starting at\
    \ /tmp/tmp_y3sxokp.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    else\n        Vector{Int64}(remaining - need, number)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of ways to arrange a certain\
    \ number of cards into a pile of cards.\nThe piles are represented by a vector\
    \ of integers representing the number of cards in each pile.\nThe function should\
    \ return an vector of integers representing the number of ways to arrange the\
    \ cards into a pile of cards.\nThe function should return an empty vector if there\
    \ are not enough cards to arrange the cards into a pile of cards.\nThe function\
    \ should return an empty vector if there are not enough cards to arrange the cards\
    \ into a pile of cards.\nThe function should return an empty vector if there are\
    \ not enough cards to arrange the cards into a pile of cards.\nThe function should\
    \ return an empty vector if there are not enough cards to arrange the cards into\
    \ a pile of cards.\nThe function should return an empty vector if there are not\
    \ enough cards to arrange the cards into a pile of cards.\nThe function should\
    \ return an empty vector if there are not enough cards to arrange the cards into\
    \ a pile of cards.\nThe function should return an empty vector if there are not\
    \ enough cards to arrange the cards into a pile of cards.\nThe function should\
    \ return an empty vector if there are not enough cards to arrange the cards into\
    \ a pile of cards.\nThe function should return an empty vector if there are not\
    \ enough cards to arrange the cards into a pile of cards.\nThe function should\
    \ return an empty vector if there are not enough cards to arrange the cards into\
    \ a pile of cards.\nThe function should return an empty vector if there are not\
    \ enough cards to arrange the cards into a pile of cards.\nThe function should\
    \ return an empty vector if there are not enough cards to arrange the cards into\
    \ a pile of cards.\nThe function should return an empty vector if there are not\
    \ enough cards to arrange the cards into a pile of cards.\nThe function should\
    \ return an empty vector if there are not enough cards to arrange the cards into\
    \ a pile of cards.\nThe function should return an empty vector if there are not\
    \ enough cards to arrange the cards into a pile of cards.\nThe function should\
    \ return an empty vector if there are not enough cards to arrange the cards into\
    \ a pile of cards.\nThe function should return an empty vector if \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqs_9euh5.jl:40\nin expression starting at\
    \ /tmp/tmpqs_9euh5.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || need <\
    \ 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    if number\
    \ == 0 && remaining == 0\n        Vector{Int64}()\n    elseif number == 0 && remaining\
    \ > 0\n        Vector{Int64}(remaining, 0)\n    elseif number > 0 && remaining\
    \ == 0\n        Vector{Int64}(0, number)\n    elseif number > 0 && remaining >\
    \ 0\n        Vector{Int64}(number, 0)\n    else\n        Vector{Int64}(number,\
    \ need)\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Meals(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64}\n    \n    You have a certain\
    \ number of carrots, and you need to eat some carrots to complete the day's meals.\n\
    \    \n    Example:\n    >>> Meals(5, 6, 10)\n    [11, 4]\n    >>> Meals(4, 8,\
    \ 9)\n    [12, 1]\n    >>> Meals(1, 10, 10)\n    [11, 0]\n    >>> Meals(2, 11,\
    \ 5)\n    [7, 0]\n    \n    Variables:\n    @number : integer\n        the number\
    \ of carrots that you have eaten.\n    @need : integer\n        the number of\
    \ carrots that you need to eat.\n    @remaining : integer\n        the number\
    \ of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number\
    \ <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoqhfi00b.jl:49\nin expression starting at\
    \ /tmp/tmpoqhfi00b.jl:49\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && number\
    \ <= 1000 && need > 0 && need <= 1000 && remaining > 0 && remaining <= 1000\n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4l9ovz3u.jl:1\nin expression starting at /tmp/tmp4l9ovz3u.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 1000 \n    \
    \    error(\"number should be less than 1000\")\n    else if need > 1000 \n  \
    \      error(\"need should be less than 1000\")\n    else if remaining > 1000\
    \ \n        error(\"remaining should be less than 1000\")\n    else \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t\
    @test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfb4bxfpj.jl:36\nin expression starting at\
    \ /tmp/tmpfb4bxfpj.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    end\n   \
    \ if need < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\"\
    )\n    end\n    if remaining < 0 || remaining > 1000 \n        error(\"remaining\
    \ must be between 0 and 1000\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbfzatku5.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbfzatku5.jl:1\n\
    in expression starting at /tmp/tmpbfzatku5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    # Your code\
    \ here\n    \nend\n</cell>\n<text>\nProblem 3\nWrite a function that will return\
    \ the number of days until a rabbit eats all the carrots left. \nThe rabbit starts\
    \ with 5 carrots and needs to eat 6 carrots to complete the day. \nThe rabbit\
    \ eats carrots one at a time, and each time it eats one carrot, it eats another\
    \ carrot, and so on until it eats all carrots left.\nThe rabbit can only eat carrots\
    \ one at a time, and each time it eats one carrot, it eats another carrot, and\
    \ so on until it eats all carrots left.\nThe rabbit can only eat carrots one at\
    \ a time, and each time it eats one carrot, it eats another carrot, and so on\
    \ until it eats all carrots left.\nThe rabbit can only eat carrots one at a time,\
    \ and each time it eats one carrot, it eats another carrot, and so on until it\
    \ eats all carrots left.\nThe rabbit can only eat carrots one at a time, and each\
    \ time it eats one carrot, it eats another carrot, and so on until it eats all\
    \ carrots left.\nThe rabbit can only eat carrots one at a time, and each time\
    \ it eats one carrot, it eats another carrot, and so on until it eats all carrots\
    \ left.\nThe rabbit can only eat carrots one at a time, and each time it eats\
    \ one carrot, it eats another carrot, and so on until it eats all carrots left.\n\
    The rabbit can only eat carrots one at a time, and each time it eats one carrot,\
    \ it eats another carrot, and so on until it eats all carrots left.\nThe rabbit\
    \ can only eat carrots one at a time, and each time it eats one carrot, it eats\
    \ another carrot, and so on until it eats all carrots left.\nThe rabbit can only\
    \ eat carrots one at a time, and each time it eats one carrot, it eats another\
    \ carrot, and so on until it eats all carrots left.\nThe rabbit can only eat carrots\
    \ one at a time, and each time it eat\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuzd37kku.jl:39\nin expression starting at\
    \ /tmp/tmpuzd37kku.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}([need, remaining])\n    else\n        Vector{Int64}([need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpphuyyvvg.jl:40\nin expression starting at\
    \ /tmp/tmpphuyyvvg.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    meals = zeros(Int64,\
    \ 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = 0\n    \n    carrots_eaten\
    \ = zeros(Int64, 2)\n    carrots_eaten[1] = 0\n    carrots_eaten[2] = 0\n    \n\
    \    while carrots_eaten[1] < carrots[1] && carrots_eaten[2] < carrots[2]\n  \
    \      carrots_left[1] -= carrots[1]\n        carrots_left[2] -= carrots[2]\n\
    \        \n        if carrots_left[1] < 0 || carrots_left[2] < 0\n           \
    \ carrots_eaten[1] += carrots_left[1]\n            carrots_eaten[2] += carrots_left[2]\n\
    \            carrots_left[1] = 0\n            carrots_left[2] = 0\n        else\n\
    \            carrots_eaten[1] += carrots[1]\n            carrots_eaten[2] += carrots[2]\n\
    \            carrots[1] = 0\n            carrots[2] = 0\n        end\n    end\n\
    \    \n    return carrots_eaten\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo396_27r.jl:73\nin expression starting at\
    \ /tmp/tmpo396_27r.jl:73\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        return Vector{Int64}()\n    end\n    \n    carrots\
    \ = Vector{Int64}()\n    \n    if number == 0\n        carrots = Vector{Int64}()\n\
    \    elseif number <= remaining\n        carrots = Vector{Int64}([number])\n \
    \   else\n        carrots = Vector{Int64}([number])\n    end\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdthnluae.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpdthnluae.jl:1\n\
    in expression starting at /tmp/tmpdthnluae.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    else if need\
    \ < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\")\n  \
    \  else if remaining < 0 || remaining > 1000 \n        error(\"remaining must\
    \ be between 0 and 1000\")\n    else \n        Vector{Int64}([number, need, remaining])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1,\
    \ 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Problem 3\nWrite a function that returns the number of days in a month.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo2jn9nif.jl:36\nin expression starting at\
    \ /tmp/tmpo2jn9nif.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     return error(\"Invalid input\")\n    end\n    if number == 0\n        return\
    \ Vector{Int64}(0, remaining)\n    end\n    if remaining == 0\n        return\
    \ Vector{Int64}(number, 0)\n    end\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpm5b4wr3e.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpm5b4wr3e.jl:1\n\
    in expression starting at /tmp/tmpm5b4wr3e.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    if remaining == 0\n        return\
    \ [number, 0]\n    end\n    \n    carrots = number\n    carrots_left = remaining\n\
    \    \n    while carrots_left > 0\n        carrots_left -= 1\n        carrots\
    \ += 1\n    end\n    \n    return [carrots, carrots_left]\nend\n</cell>\n<code\
    \ language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4,\
    \ 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(2, 11, 5)\n</cell>\n<text>\nExercise 2\nWrite a function that returns the\
    \ number of ways to arrange a certain number of dice in n different ways.\nThe\
    \ function should take in two inputs:\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0xtyux51.jl:51\nin expression starting at\
    \ /tmp/tmp0xtyux51.jl:51\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    else\n        Vector{Int64}([number, need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7c5a414o.jl:40\nin expression starting at\
    \ /tmp/tmp7c5a414o.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = remaining\n   \
    \ \n    carrots = carrots[2:end]\n    \n    if carrots[1] > 0\n        carrots[1]\
    \ -= need\n    end\n    \n    if carrots[2] > 0\n        carrots[2] -= carrots[1]\n\
    \    end\n    \n    return carrots\nend\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that takes in a vector of integers and returns the sum of the numbers in the\
    \ vector.\nThe vector can contain any number of integers, including zero.\nThe\
    \ vector will be of length 1 or more.\nThe vector will be of length 0 or more.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2475vvkl.jl:54\nin expression starting at\
    \ /tmp/tmp2475vvkl.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"invalid input\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvuyey6d2.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvuyey6d2.jl:1\n\
    in expression starting at /tmp/tmpvuyey6d2.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        carrots = number\n        need = need\n       \
    \ remaining = remaining\n        \n        carrots_left = remaining\n        \n\
    \        meals_left = 0\n        \n        while carrots_left > 0 && meals_left\
    \ < need \n            carrots_left -= 1 \n            meals_left += 1 \n    \
    \    end\n        \n        if carrots_left == 0 \n            carrots = remaining\n\
    \        end\n        \n        return Vector{Int64}(carrots, carrots_left)\n\
    \    end\n    return Vector{Int64}(0, 0)\nend\n</cell>\n<code language=julia-1.5>\n\
    eat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code\
    \ language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2,\
    \ 11, 5)\n</cell>\n<text>\nExercise 2\nWrite a function called eat_meals that\
    \ takes in two vectors of integers (meals and carrots), and returns the number\
    \ of meals left after eating all carrots.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpntwoyjqe.jl:56\nin expression starting at\
    \ /tmp/tmpntwoyjqe.jl:56\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    else\n        Vector{Int64}([number, need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 0)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 1)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 2)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 3)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 4)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 5)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 6)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 7)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 8)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 9)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 11)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 12)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 13)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 14)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 15)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 16)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 17)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 18)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 19)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 20)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 21)\n</cell>\n\
    <code language=julia-1.5>\neat(10, 10, 22)\n</cell>\n<code language=julia-1.5>\n\
    eat(10, 10, 23)\n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx_gauj4f.jl:40\nin expression starting at\
    \ /tmp/tmpx_gauj4f.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    end\n   \
    \ if need < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\"\
    )\n    end\n    if remaining < 0 || remaining > 1000 \n        error(\"remaining\
    \ must be between 0 and 1000\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbfzatku5.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbfzatku5.jl:1\n\
    in expression starting at /tmp/tmpbfzatku5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    end\n   \
    \ if need < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\"\
    )\n    end\n    if remaining < 0 || remaining > 1000 \n        error(\"remaining\
    \ must be between 0 and 1000\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbfzatku5.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbfzatku5.jl:1\n\
    in expression starting at /tmp/tmpbfzatku5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0 \n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = number\n\
    \    \n    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n \
    \   carrots_left[2] = number\n    \n    carrots_left = carrots_left[1]\n    \n\
    \    while carrots_left > 0 \n        carrots_left = carrots_left[1]\n       \
    \ carrots_left = carrots_left[2]\n        \n        if carrots_left > 0 \n   \
    \         carrots_left = carrots_left[1]\n            carrots_left = carrots_left[2]\n\
    \            \n            if carrots_left > 0 \n                carrots_left\
    \ = carrots_left[1]\n                carrots_left = carrots_left[2]\n        \
    \        \n                if carrots_left > 0 \n                    carrots_left\
    \ = carrots_left[1]\n                    carrots_left = carrots_left[2]\n    \
    \                \n                    if carrots_left > 0 \n                \
    \        carrots_left = carrots_left[1]\n                        carrots_left\
    \ = carrots_left[2]\n                        \n                        if carrots_left\
    \ > 0 \n                            carrots_left = carrots_left[1]\n         \
    \                   carrots_left = carrots_left[2]\n                         \
    \   \n                            if carrots_left > 0 \n                     \
    \           carrots_left = carrots_left[1]\n                                carrots_left\
    \ = carrots_left[2]\n                                \n                      \
    \          if carrots_left > 0 \n                                    carrots_left\
    \ = carrots_left[1]\n                                    carrots_left = carrots_left[2]\n\
    \                                    \n                                    if\
    \ carrots_left > 0 \n                                        carrots_left = carrots_left[1]\n\
    \                                        carrots_left = carrots_left[2]\n    \
    \                                    \n                                      \
    \  if carrots_left > 0 \n                                            carrots_left\
    \ = carrots_left[1]\n                                            carrots_left\
    \ = carrots_left[2]\n                                            \n          \
    \                                  if carrots_left > 0 \n                    \
    \                            carrots_left = carrots_left[1]\n                \
    \                                carrots_left = carrots_left[2]\n            \
    \                                    \n                                      \
    \          if carrots_left > 0 \n                                            \
    \        carrots_left = carrots_left[1]\n                                    \
    \                carrots_left = carrots_left[2]\n                            \
    \                        \n                                                  \
    \  if carrots_left > 0 \n                                                    \
    \    carrot\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsxu0nirs.jl:1\nin expression starting at /tmp/tmpsxu0nirs.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 0 && need >\
    \ 0 && remaining > 0 \n        carrots = number\n        need = need - carrots\n\
    \        remaining = remaining - carrots\n        \n        if remaining <= 0\
    \ \n            carrots = remaining\n            need = need - carrots\n     \
    \       \n            return Vector{Int64}(carrots, need)\n        else \n   \
    \         return Vector{Int64}(0, need)\n    else \n        return Vector{Int64}(0,\
    \ 0)\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n\
    <code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 11)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 12)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 13)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 14)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 15)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 16)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 17)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 18)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 19)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 20)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 21)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 22)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 23)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 24)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 25)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 26)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 27)\n</cell>\n<code\
    \ language=julia-1.5>\neat(10, 10, 28)\n</cell>\n<code language=julia-1.5>\neat(10,\
    \ 10, 29)\n</cell>\n<code language=julia-1.5>\neat(10, 10, 30)\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpnagte0c0.jl:39 expected \"\
    end\", got \"else\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnagte0c0.jl:46\n\
    in expression starting at /tmp/tmpnagte0c0.jl:46\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number > 1000 \n    \
    \    error(\"number must be between 0 and 1000\")\n    else if need > 1000 \n\
    \        error(\"need must be between 0 and 1000\")\n    else if remaining > 1000\
    \ \n        error(\"remaining must be between 0 and 1000\")\n    else if number\
    \ < need \n        error(\"need must be greater than or equal to number\")\n \
    \   else if number == 0 \n        error(\"number must be greater than 0\")\n \
    \   else if need == 0 \n        error(\"need must be greater than 0\")\n    else\
    \ if remaining == 0 \n        error(\"remaining must be greater than 0\")\n  \
    \  else \n        Vector{Int64}([number, need, remaining])\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.0>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.0>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.0>\neat(2, 11, 5)\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ called hungry that takes two integers representing a number of carrots left\
    \ and number of carrots eaten and returns true if the number of carrots left is\
    \ greater than or equal to the number of carrots eaten. Otherwise it returns false.\
    \ \nHint: use if-else statements to write your function.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcflk3fbs.jl:36\nin expression starting at\
    \ /tmp/tmpcflk3fbs.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    if number < 0 || need\
    \ < 0 || remaining < 0\n        error(\"Invalid input\")\n    end\n    \n    if\
    \ number == 0 && remaining == 0\n        return Vector{Int64}(0, 0)\n    end\n\
    \    \n    if number == 0 && remaining > 0\n        return Vector{Int64}(0, remaining)\n\
    \    end\n    \n    if need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ 0)\n    end\n    \n    if need == 0 && remaining > 0\n        return Vector{Int64}(number,\
    \ remaining)\n    end\n    \n    if number > 0 && need > 0 && remaining > 0\n\
    \        \n        if number > remaining\n            \n            if number\
    \ % need == 0\n                return Vector{Int64}(number, number - need)\n \
    \           else\n                return Vector{Int64}(number, number - number\
    \ % need)\n            end\n        else\n            \n            if number\
    \ % need == 0\n                return Vector{Int64}(number, number - need)\n \
    \           else\n                return Vector{Int64}(number, number - number\
    \ % need)\n            end\n        end\n    end\n    \n    if number == 0 &&\
    \ need == 0 && remaining > 0\n        return Vector{Int64}(0, remaining)\n   \
    \ end\n    \n    if number == 0 && need > 0 && remaining == 0\n        return\
    \ Vector{Int64}(number, 0)\n    end\n    \n    if number == 0 && need == 0 &&\
    \ remaining == 0\n        return Vector{Int64}(0, number)\n    end\n    \n   \
    \ if number > 0 && need == 0 && remaining == 0\n        return Vector{Int64}(number,\
    \ number)\n    end\n    \n    if number > 0 && need > 0 && remaining == 0\n  \
    \      \n        if number % need == 0\n            return Vector{Int64}(number,\
    \ number - need)\n        else\n            return Vector{Int64}(number, number\
    \ - number % need)\n        end\n    end\n    \n    if number > 0 && need == 0\
    \ && remaining > 0\n        return Vector{Int64}(number, number - need)\n    end\n\
    \    \n    if number > 0 && need > 0 && remaining > 0\n        \n        if number\
    \ % need == 0\n            return Vector{Int64}(number, number - need)\n     \
    \   else\n            return Vector{Int64}(number, number - number % need)\n \
    \       end\n    end\n    \n    if number == 0 && need > 0 && remaining > 0\n\
    \        return Vector{Int64}(number, number - need)\n    end\n    \n    if number\
    \ == 0 && need == 0 && remaining == 0\n        return Vector{Int64}(0, number)\n\
    \    end\n    \n    if number > 0 && need > 0 && remaining == 0\n        \n  \
    \      if number % need == 0\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpednrzn3f.jl:1\nin expression starting at /tmp/tmpednrzn3f.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"invalid input\")\n    end\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6qbosxtw.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6qbosxtw.jl:1\n\
    in expression starting at /tmp/tmp6qbosxtw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number <= 0 || need <=\
    \ 0 || remaining <= 0\n        error(\"Invalid input\")\n    end\n    \n    carrots\
    \ = zeros(Int64, 2)\n    carrots[1] = number\n    carrots[2] = need\n    \n  \
    \  meals = zeros(Int64, 2)\n    meals[1] = remaining\n    meals[2] = 0\n    \n\
    \    carrots_left = zeros(Int64, 2)\n    carrots_left[1] = remaining\n    carrots_left[2]\
    \ = 0\n    \n    carrots_eaten = zeros(Int64, 2)\n    carrots_eaten[1] = number\n\
    \    carrots_eaten[2] = 0\n    \n    while meals[1] > 0\n        carrots_eaten[2]\
    \ = carrots_eaten[2] + meals[2]\n        meals[2] = meals[2] - 1\n        carrots_left[2]\
    \ = carrots_left[2] + meals[2]\n        meals[1] = meals[1] - 1\n    end\n   \
    \ \n    return carrots_eaten\nend\n</cell>\n<code language=julia-1.5>\neat(5,\
    \ 6, 10)\n</cell>\n<code language=julia-1.5>\neat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\n\
    eat(1, 10, 10)\n</cell>\n<code language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the number of carrots left after a meal\
    \ is completed.\nThe function should take 3 arguments:\n@carrots : a vector of\
    \ integers representing the number of carrots left after a meal is completed.\n\
    @meal : a vector of integers representing the number of carrots left after a meal\
    \ is completed.\n@meal_completed : a vector of integers representing the number\
    \ of carrots left after a meal is completed.\nThe function should return @carrots.\n\
    The function should return @meal.\nThe function should return @meal_completed.\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpagl_7_78.jl:63\nin expression starting at\
    \ /tmp/tmpagl_7_78.jl:63\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ return Vector{Int64}()\n    \n    if remaining < need\n        return Vector{Int64}()\n\
    \    \n    if number > remaining\n        return Vector{Int64}()\n    \n    if\
    \ number == need\n        return Vector{Int64}([number, 0])\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw93k8v4w.jl:1\nin expression starting at /tmp/tmpw93k8v4w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0 \n      \
    \  Vector{Int64}([need, remaining]) \n    else \n        Vector{Int64}([need,\
    \ number]) \n    end\nend\n</cell>\n<code language=julia-0.6>\neat(5, 6, 10)\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns the number of carrots\
    \ left after a meal is complete.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) ==\
    \ [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11,\
    \ 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5,\
    \ 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqawivya1.jl:40\nin expression starting at\
    \ /tmp/tmpqawivya1.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    else if need\
    \ < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\")\n  \
    \  else if remaining < 0 || remaining > 1000 \n        error(\"remaining must\
    \ be between 0 and 1000\")\n    else \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwi8yvhs1.jl:36\nin expression starting at\
    \ /tmp/tmpwi8yvhs1.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ return Vector{Int64}()\n    elseif number < 0\n        return Vector{Int64}()\n\
    \    elseif number > remaining\n        return Vector{Int64}()\n    elseif need\
    \ == 0\n        return Vector{Int64}([number, remaining])\n    elseif need < 0\n\
    \        return Vector{Int64}()\n    elseif need > remaining\n        return Vector{Int64}()\n\
    \    elseif number == remaining\n        return Vector{Int64}([number, 0])\n \
    \   else\n        return Vector{Int64}([number, remaining])\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that returns the number of days until a rabbit eats another rabbit.\nThe rabbit\
    \ eats another rabbit if and only if that rabbit eats another rabbit within 30\
    \ days.\nThe rabbit eats another rabbit if and only if that rabbit eats another\
    \ rabbit within 60 days.\nThe rabbit eats another rabbit if and only if that rabbit\
    \ eats another rabbit within 90 days.\nThe rabbit eats another rabbit if and only\
    \ if that rabbit eats another rabbit within 120 days.\nThe rabbit eats another\
    \ rabbit if and only if that rabbit eats another rabbit within 150 days.\nThe\
    \ rabbit eats another rabbit if and only if that rabbit eats another rabbit within\
    \ 180 days.\nThe rabbit eats another rabbit if and only if that rabbit eats another\
    \ rabbit within 210 days.\nThe rabbit eats another rabbit if and only if that\
    \ rabbit eats another rabbit within 240 days.\nThe rabbit eats another rabbit\
    \ if and only if that rabbit eats another rabbit within 270 days.\nThe rabbit\
    \ eats another rabbit if and only if that rabbit eats another rabbit within 300\
    \ days.\nThe rabbit eats another rabbit if and only if that rabb\nusing Test\n\
    \n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\
    \t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpydx36hkn.jl:52\nin expression starting at\
    \ /tmp/tmpydx36hkn.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk1w0mmp_.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk1w0mmp_.jl:1\n\
    in expression starting at /tmp/tmpk1w0mmp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 \n        error(\"number must be between 0 and 1000\")\n    end\n   \
    \ if need < 0 || need > 1000 \n        error(\"need must be between 0 and 1000\"\
    )\n    end\n    if remaining < 0 || remaining > 1000 \n        error(\"remaining\
    \ must be between 0 and 1000\")\n    end\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5,\
    \ 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1,\
    \ 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbfzatku5.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbfzatku5.jl:1\n\
    in expression starting at /tmp/tmpbfzatku5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number == 0\n       \
    \ Vector{Int64}()\n    elseif number == remaining\n        Vector{Int64}([need,\
    \ remaining])\n    else\n        Vector{Int64}([number, need])\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n</cell>\n<code language=julia-1.5>\n\
    eat(4, 8, 9)\n</cell>\n<code language=julia-1.5>\neat(1, 10, 10)\n</cell>\n<code\
    \ language=julia-1.5>\neat(2, 11, 5)\n</cell>\n<text>\nProblem 3\nWrite a function\
    \ that takes a vector of integers and returns the sum of the integers in the vector.\n\
    If there are no integers in the vector, return 0.\nIf there are multiple integers\
    \ in the vector, return the sum of the integers.\nusing Test\n\n@testset begin\n\
    \ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp49ff4j37.jl:42\nin expression starting at\
    \ /tmp/tmp49ff4j37.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    \n    if number == 0\n \
    \       Vector{Int64}([need, remaining])\n    else\n        Vector{Int64}([need,\
    \ remaining])\n    end\nend\n</cell>\n<code language=julia-1.5>\neat(5, 6, 10)\n\
    </cell>\n<text>\nProblem 3\nWrite a function that returns a vector of [number\
    \ of carrots eaten by each rabbit,\nnumber of carrots left after each rabbit]\n\
    if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\nThe function should take in two parameters: the number\
    \ of rabbits in the rabbit's house, and the number of rabbits in your house.\n\
    The function should return a vector of [ number of eaten carrots by each rabbit,\n\
    number of carrots left after each rabbit ]\nThe function should return an empty\
    \ vector if there are not enough rabbits.\nThe function should return an empty\
    \ vector if there are not enough carrots.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxojfs827.jl:41\nin expression starting at\
    \ /tmp/tmpxojfs827.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return a vector of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    >>> eat(5, 6, 10)\n    [11, 4]\n    >>> eat(4, 8, 9)\n    [12, 1]\n    >>>\
    \ eat(1, 10, 10)\n    [11, 0]\n    >>> eat(2, 11, 5)\n    [7, 0]\n    \n    Variables:\n\
    \    @number : integer\n        the number of carrots that you have eaten.\n \
    \   @need : integer\n        the number of carrots that you need to eat.\n   \
    \ @remaining : integer\n        the number of remaining carrots thet exist in\
    \ stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n\
    \    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64,\
    \ need::Int64, remaining::Int64)::Vector{Int64} \n    if number < 0 || number\
    \ > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining > 1000\n   \
    \     error(\"Invalid input\")\n    end\n    \n    carrots = zeros(Int64, 2)\n\
    \    carrots[1] = number\n    carrots[2] = need\n    \n    carrots_left = zeros(Int64,\
    \ 2)\n    carrots_left[1] = remaining\n    carrots_left[2] = need\n    \n    carrots_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals[1] = carrots[1]\n    carrots_left_after_meals[2]\
    \ = carrots[2]\n    \n    carrots_left_after_meals_left = zeros(Int64, 2)\n  \
    \  carrots_left_after_meals_left[1] = carrots[1]\n    carrots_left_after_meals_left[2]\
    \ = carrots[2]\n    \n    carrots_left_after_meals_left_after_meals = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_left_after_meals[1] = carrots[1]\n    carrots_left_after_meals_left_after_meals[2]\
    \ = carrots[2]\n    \n    carrots_left_after_meals_left_after_meals_left = zeros(Int64,\
    \ 2)\n    carrots_left_after_meals_left_after_meals_left[1] = carrots[1]\n   \
    \ carrots_left_after_meals_left_after_meals_left[2] = carrots[2]\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = carrots[1]\n    carrots_left_after_meals_left_after_meals_left_after_meals[2]\
    \ = carrots[2]\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[1]\
    \ = carrots[1]\n    carrots_left_after_meals_left_after_meals_left_after_meals_left[2]\
    \ = carrots[2]\n    \n    carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = zeros(Int64, 2)\n    carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals[1]\
    \ = carrots[1]\n    carrots_left_after_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9)\
    \ == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1by9yze9.jl:33\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1by9yze9.jl:1\n\
    in expression starting at /tmp/tmp1by9yze9.jl:1\n"
  stdout: ''
