language: jl
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb3lkmxxu.jl:85\nin expression starting at\
    \ /tmp/tmpb3lkmxxu.jl:85\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpayvb79wc.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpayvb79wc.jl:1\n\
    in expression starting at /tmp/tmpayvb79wc.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst) == 0 \n        return\
    \ [] \n    end\n    \n    rows = sort(collect(enumerate(lst)))\n    \n    rows\
    \ = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n    \n \
    \   coords = Vector{Tuple{Int64, Int64}}()\n    \n    for row in rows \n     \
    \   coords = push!(coords, Tuple(row[1], row[2]))\n    end\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphbgg41c5.jl:38\nin expression starting at\
    \ /tmp/tmphbgg41c5.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,r) in enumerate(rows)\n        coords[i,:] = (r,cols[r])\n \
    \   end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->-x[1])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpblz0boek.jl:38\nin expression starting at\
    \ /tmp/tmpblz0boek.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    columns = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n\
    \    \n    coords = zeros(length(rows), length(columns))\n    \n    for row in\
    \ rows\n        coords[row] = ((row, columns[end]), 0)\n    end\n    \n    coords\
    \ = coords[coords[:,1] .<= x]\n    \n    coords = coords[coords[:,2] .>= x]\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvvl1b42d.jl:37\nin expression starting at\
    \ /tmp/tmpvvl1b42d.jl:37\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x>0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(rows, by=x->-length(x[x==0]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(rows, by=x->-length(x[x==0]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(rows, by=x->-length(x[x==0]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(rows, by=x->-length(x[x==0]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(rows, by=x->-length(x[x==0]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(rows, by=x->-length(x[x==0]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(rows, by=x->-length(x[x==0]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(rows, by=x->-length(x[x==0]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[x==0]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[x==0]))\n    \n    rows = sort(\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpant761yq.jl:82\nin expression starting at\
    \ /tmp/tmpant761yq.jl:82\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkeliy1g5.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkeliy1g5.jl:1\n\
    in expression starting at /tmp/tmpkeliy1g5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->x)\n    \n    rows = sort(rows, by=x->x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->x)\n    \n\
    \    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows\
    \ = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n\
    \    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows\
    \ = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqtgu_uq6.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqtgu_uq6.jl:1\n\
    in expression starting at /tmp/tmpqtgu_uq6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        row_x = row[x]\n        \n        row_y = rows[end][1]\n        \n  \
    \      if row_y > row_x\n            push!(rows, (row_x, row_y))\n        end\n\
    \    end\n    \n    sort(rows)\n    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn5kv8udj.jl:40\nin expression starting at\
    \ /tmp/tmpn5kv8udj.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvu66d70b.jl:44\nin expression starting at\
    \ /tmp/tmpvu66d70b.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkeliy1g5.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkeliy1g5.jl:1\n\
    in expression starting at /tmp/tmpkeliy1g5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end-x+1:end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp51w3szha.jl:42\nin expression starting at\
    \ /tmp/tmp51w3szha.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][i]\n        cols = cols\
    \ + lst[i][1:i-1]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = ((rows[i] + 1) \xF7 2, (cols[i] + 1) \xF7 2)\n    end\n \
    \   \n    coords = sort(coords)\n    \n    return coords\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpifd0mbgs.jl:44\nin expression starting at\
    \ /tmp/tmpifd0mbgs.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    cols = sort(cols, by=x->-x[2])\n    \n    rows = sort(rows, by=x->x[3])\n\
    \    cols = sort(cols, by=x->-x[3])\n    \n    rows = sort(rows, by=x->x[4])\n\
    \    cols = sort(cols, by=x->-x[4])\n    \n    rows = sort(rows, by=x->x[5])\n\
    \    cols = sort(cols, by=x->-x[5])\n    \n    rows = sort(rows, by=x->x[6])\n\
    \    cols = sort(cols, by=x->-x[6])\n    \n    rows = sort(rows, by=x->x[7])\n\
    \    cols = sort(cols, by=x->-x[7])\n    \n    rows = sort(rows, by=x->x[8])\n\
    \    cols = sort(cols, by=x->-x[8])\n    \n    rows = sort(rows, by=x->x[9])\n\
    \    cols = sort(cols, by=x->-x[9])\n    \n    rows = sort(rows, by=x->x[10])\n\
    \    cols = sort(cols, by=x->-x[10])\n    \n    rows = sort(rows, by=x->x[11])\n\
    \    cols = sort(cols, by=x->-x[11])\n    \n    rows = sort(rows, by=x->x[12])\n\
    \    cols = sort(cols, by=x->-x[12])\n    \n    rows = sort(rows, by=x->x[13])\n\
    \    cols = sort(cols, by=x->-x[13])\n    \n    rows = sort(rows, by=x->x[14])\n\
    \    cols = sort(cols, by=x->-x[14])\n    \n    rows = sort(rows, by=x->x[15])\n\
    \    cols = sort(cols, by=x->-x[15])\n    \n    rows = sort(rows, by=x->x[16])\n\
    \    cols = sort(cols, by=x->-x[16])\n    \n    rows = sort(rows, by=x->x[17])\n\
    \    cols = sort(cols, by=x->-x[17])\n    \n    rows = sort(rows, by=x->x[18])\n\
    \    cols = sort(cols, by=x->-x[18])\n    \n    rows = sort(rows, by=x->x[19])\n\
    \    cols = sort(cols, by=x->-x\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1xcokit6.jl:80\nin expression starting at\
    \ /tmp/tmp1xcokit6.jl:80\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    else\n\
    \        rows = sort(collect(enumerate(lst)))\n        \n        row_coords =\
    \ rows[rows[1][1][1]==x]\n        \n        row_coords = sort(row_coords, by=x->x[1])\n\
    \        \n        row_coords = reverse(row_coords)\n        \n        row_coords\
    \ = sort(row_coords, by=x->x[2])\n        \n        row_coords = reverse(row_coords)\n\
    \        \n        row_coords = reverse(row_coords)\n        \n        return\
    \ row_coords\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp26ny5vvo.jl:40\nin expression starting at\
    \ /tmp/tmp26ny5vvo.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkeliy1g5.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkeliy1g5.jl:1\n\
    in expression starting at /tmp/tmpkeliy1g5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[3])\n\
    \    cols = sort(cols, by=x->x[3])\n    \n    rows = sort(rows, by=x->x[4])\n\
    \    cols = sort(cols, by=x->x[4])\n    \n    rows = sort(rows, by=x->x[5])\n\
    \    cols = sort(cols, by=x->x[5])\n    \n    rows = sort(rows, by=x->x[6])\n\
    \    cols = sort(cols, by=x->x[6])\n    \n    rows = sort(rows, by=x->x[7])\n\
    \    cols = sort(cols, by=x->x[7])\n    \n    rows = sort(rows, by=x->x[8])\n\
    \    cols = sort(cols, by=x->x[8])\n    \n    rows = sort(rows, by=x->x[9])\n\
    \    cols = sort(cols, by=x->x[9])\n    \n    rows = sort(rows, by=x->x[10])\n\
    \    cols = sort(cols, by=x->x[10])\n    \n    rows = sort(rows, by=x->x[11])\n\
    \    cols = sort(cols, by=x->x[11])\n    \n    rows = sort(rows, by=x->x[12])\n\
    \    cols = sort(cols, by=x->x[12])\n    \n    rows = sort(rows, by=x->x[13])\n\
    \    cols = sort(cols, by=x->x[13])\n    \n    rows = sort(rows, by=x->x[14])\n\
    \    cols = sort(cols, by=x->x[14])\n    \n    rows = sort(rows, by=x->x[15])\n\
    \    cols = sort(cols, by=x->x[15])\n    \n    rows = sort(rows, by=x->x[16])\n\
    \    cols = sort(cols, by=x->x[16])\n    \n    rows = sort(rows, by=x->x[17])\n\
    \    cols = sort(cols, by=x->x[17])\n    \n    rows = sort(rows, by=x->x[18])\n\
    \    cols = sort(cols, by=x->x[18])\n    \n    rows = sort(rows, by=x->x[19])\n\
    \    cols = sort(cols, by=x->x[19])\n    \n    rows = sort(\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptxf63lt6.jl:84\nin expression starting at\
    \ /tmp/tmptxf63lt6.jl:84\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    for i = 1:length(lst)\n     \
    \   coords[i] = (i-1, cols[i])\n    end\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpizce8tbo.jl:41\nin expression starting at\
    \ /tmp/tmpizce8tbo.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkeliy1g5.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkeliy1g5.jl:1\n\
    in expression starting at /tmp/tmpkeliy1g5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[3])\n\
    \    cols = sort(cols, by=x->x[3])\n    \n    rows = sort(rows, by=x->x[4])\n\
    \    cols = sort(cols, by=x->x[4])\n    \n    rows = sort(rows, by=x->x[5])\n\
    \    cols = sort(cols, by=x->x[5])\n    \n    rows = sort(rows, by=x->x[6])\n\
    \    cols = sort(cols, by=x->x[6])\n    \n    rows = sort(rows, by=x->x[7])\n\
    \    cols = sort(cols, by=x->x[7])\n    \n    rows = sort(rows, by=x->x[8])\n\
    \    cols = sort(cols, by=x->x[8])\n    \n    rows = sort(rows, by=x->x[9])\n\
    \    cols = sort(cols, by=x->x[9])\n    \n    rows = sort(rows, by=x->x[10])\n\
    \    cols = sort(cols, by=x->x[10])\n    \n    rows = sort(rows, by=x->x[11])\n\
    \    cols = sort(cols, by=x->x[11])\n    \n    rows = sort(rows, by=x->x[12])\n\
    \    cols = sort(cols, by=x->x[12])\n    \n    rows = sort(rows, by=x->x[13])\n\
    \    cols = sort(cols, by=x->x[13])\n    \n    rows = sort(rows, by=x->x[14])\n\
    \    cols = sort(cols, by=x->x[14])\n    \n    rows = sort(rows, by=x->x[15])\n\
    \    cols = sort(cols, by=x->x[15])\n    \n    rows = sort(rows, by=x->x[16])\n\
    \    cols = sort(cols, by=x->x[16])\n    \n    rows = sort(rows, by=x->x[17])\n\
    \    cols = sort(cols, by=x->x[17])\n    \n    rows = sort(rows, by=x->x[18])\n\
    \    cols = sort(cols, by=x->x[18])\n    \n    rows = sort(rows, by=x->x[19])\n\
    \    cols = sort(cols, by=x->x[19])\n    \n    rows = sort(\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptxf63lt6.jl:84\nin expression starting at\
    \ /tmp/tmptxf63lt6.jl:84\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.ndims) == 1 \n  \
    \      return [] \n    else \n        rows = sort(collect(1:lst.nrows))\n    \
    \    cols = sort(collect(1:lst.ncols))\n        \n        rows = rows[reverse\
    \ .! (rows == x)]\n        cols = cols[reverse .! (cols == x)]\n        \n   \
    \     coords = zip(rows, cols)\n        \n        return coords\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2vtu5a_y.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2vtu5a_y.jl:1\n\
    in expression starting at /tmp/tmp2vtu5a_y.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 1\n        []\n    else\n        lst = sort(lst)\n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpyq8h49d7.jl:22\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyq8h49d7.jl:1\n\
    in expression starting at /tmp/tmpyq8h49d7.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + i\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n \
    \   coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n \
    \   coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n \
    \   coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqg6_3asw.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqg6_3asw.jl:1\n\
    in expression starting at /tmp/tmpqg6_3asw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,j) in zip(rows, cols)\n        coords[i,j] = (i,j)\n    end\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuhqje23e.jl:35\nin expression starting at\
    \ /tmp/tmpuhqje23e.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end-x+1:end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = Tuple(rows[i], cols[i])\n    end\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph83fwcs8.jl:42\nin expression starting at\
    \ /tmp/tmph83fwcs8.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for element in row\n   \
    \         push!(columns, element)\n        end\n        \n        push!(rows,\
    \ (length(row), maximum(columns)))\n    end\n    \n    rows = sort(rows)\n   \
    \ \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n  \
    \  \n    rows = reverse(rows)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ sort(rows)\n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplpbopqm7.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplpbopqm7.jl:1\n\
    in expression starting at /tmp/tmplpbopqm7.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2],\
    \ rev=true)\n    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\n\
    get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n\
    <code language=julia-1.5>\nget_row([], 1)\n</cell>\n<code language=julia-1.5>\n\
    get_row([[], [1], [1, 2, 3]], 3)\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns all possible combinations of size n of elements from given vectors.\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5_vlk1t1.jl:29\nin expression starting at\
    \ /tmp/tmp5_vlk1t1.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    tuples = []\n    \n    for i = 1:length(rows)\n        tuple = Tuple(rows[i],\
    \ cols[i])\n        push!(tuples, tuple)\n    end\n    \n    return tuples\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn_k2mons.jl:43\nin expression starting at\
    \ /tmp/tmpn_k2mons.jl:43\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    coords = zip(rows, cols)\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords..<length(lst.(cols))]\n\
    \    \n    coords = coords[coords..<length(lst.(rows))]\n    \n    coords = coords[coords.\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid operator \"..<\" near column 28\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp13otde3a.jl:29\nin expression starting at\
    \ /tmp/tmp13otde3a.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x)\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfl1hmp08.jl:87\nin expression starting at\
    \ /tmp/tmpfl1hmp08.jl:87\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols .<=\
    \ x]\n    \n    rows = rows[rows .>= 0]\n    cols = cols[cols .>= 0]\n    \n \
    \   rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .>= 0]\n    cols = cols[cols .>= 0]\n    \n    rows\
    \ = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n   \
    \ \n    rows = rows[rows .>= 0]\n    cols = cols[cols .>= 0]\n    \n    rows =\
    \ rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n    \n\
    \    rows = rows[rows .>= 0]\n    cols = cols[cols .>= 0]\n    \n    rows = rows[rows\
    \ .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n    \n    rows =\
    \ rows[rows .>= 0]\n    cols = cols[cols .>= 0]\n    \n    rows = rows[rows .<=\
    \ length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows\
    \ .>= 0]\n    cols = cols[cols .>= 0]\n    \n    rows = rows[rows .<= length(lst)]\n\
    \    cols = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= 0]\n\
    \    cols = cols[cols .>= 0]\n    \n    rows = rows[rows .<= length(lst)]\n  \
    \  cols = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= 0]\n \
    \   cols = cols[cols .>= 0]\n    \n    rows = rows[rows .<= length(lst)]\n   \
    \ cols = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= 0]\n  \
    \  cols = cols[cols .>= 0]\n    \n    rows = rows[rows .<= length(lst)]\n    cols\
    \ = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= 0]\n    cols\
    \ = cols[cols .>= 0]\n    \n    rows = rows[rows .<= length(lst)]\n    cols =\
    \ cols[cols .<= length(lst[1])]\n    \n    rows = rows[row\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplapwewkz.jl:1\nin expression starting at /tmp/tmplapwewkz.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.data) == 0 \n   \
    \     return [] \n    \n    rows = sort(collect(1:length(lst)))\n    cols = sort(collect(1:length(lst[rows])),\
    \ by=desc)\n    \n    coords = zeros(length(rows), length(cols))\n    \n    for\
    \ (i,row) in enumerate(rows)\n        coords[i] = Tuple(row, lst[row])\n    end\n\
    \    \n    coords = coords[coords[:,1] .<= x]\n    coords = coords[coords[:,2]\
    \ .>= x]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppjaaurjt.jl:37\nin expression starting at\
    \ /tmp/tmppjaaurjt.jl:37\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        for j = 1:length(cols)\n            coords[i, j] = (i-1, j-1)\n     \
    \   end\n    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8znbjxag.jl:44\nin expression starting at\
    \ /tmp/tmp8znbjxag.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.) == 0 \n       \
    \ return Vector{Tuple{Int64, Int64}}() \n    else \n        rows = sort(collect(1:length(lst)))\n\
    \        cols = sort(collect(1:length(lst[rows])), by=desc)\n        \n      \
    \  coords = Vector{Tuple{Int64, Int64}}()\n        for r in rows \n          \
    \  for c in cols \n                if lst[r][c] == x \n                    push!(coords,\
    \ (r, c)) \n                end\n            end\n        end\n        return\
    \ coords\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \")\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpo49d9_m9.jl:20\nin expression starting at /tmp/tmpo49d9_m9.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        row_x = row[x]\n        \n        row_y = rows[end][1]\n        \n  \
    \      if row_y > row_x\n            push!(rows, (row_x, row_y))\n        end\n\
    \    end\n    \n    sort(rows)\n    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn5kv8udj.jl:40\nin expression starting at\
    \ /tmp/tmpn5kv8udj.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst) == 0 \n        return\
    \ Vector{Tuple{Int64, Int64}}() \n    else \n        rows = sort(collect(1:length(lst)))\n\
    \        cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n\
    \        \n        rows = rows[cols == x]\n        cols = cols[rows == x]\n  \
    \      \n        coords = zip(rows, cols)\n        coords = coords[coords[2] .<\
    \ length(lst[coords[1]])]\n        coords = coords[coords[1] .< length(lst[coords[1]])]\n\
    \        coords = coords[coords[1] .< length(lst[coords[1]])]\n        \n    \
    \    return coords\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo_al9p26.jl:37\nin expression starting at\
    \ /tmp/tmpo_al9p26.jl:37\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][i]\n        cols = cols\
    \ + lst[i][1:i-1]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[coords[2] .< x]\n    \n    coords = coords[coords[1]\
    \ .< coords[2]]\n    \n    coords = coords[coords[1] .< rows]\n    \n    coords\
    \ = coords[coords[1] .< length(lst)]\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw7sgl4h5.jl:52\nin expression starting at\
    \ /tmp/tmpw7sgl4h5.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = rows[i]\n    end\n    \n    coords = sort(coords)\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkv2ga8qa.jl:41\nin expression starting at\
    \ /tmp/tmpkv2ga8qa.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    for (i,row) in enumerate(rows)\n        coords[i, :] = [row, cols]\n    end\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy9a28mr0.jl:34\nin expression starting at\
    \ /tmp/tmpy9a28mr0.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    else\n        lst[findfirst(x->x==lst[end], lst)[1]:findfirst(x->x==lst[end],\
    \ lst)[2]]\n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkarj1b_n.jl:28\nin expression starting at\
    \ /tmp/tmpkarj1b_n.jl:28\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    end\n    \n    rows = sort(collect(enumerate(lst)))\n    \n \
    \   row = rows[findfirst(i->i[1]==x, rows)]\n    \n    columns = sort(collect(enumerate(row)))\n\
    \    \n    coords = zip(columns, rows)\n    \n    return coords\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmplyw54u55.jl:39\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Base.Iterators.Zip{Tuple{Vector{Tuple{Int64,
    Any}}, Vector{Tuple{Int64, Vector{Int64}}}}} to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmplyw54u55.jl:32\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmplyw54u55.jl:39 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmplyw54u55.jl:38\ntest set: Error
    During Test at /tmp/tmplyw54u55.jl:40\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Base.Iterators.Zip{Tuple{Vector{Tuple{Int64,
    Any}}, Vector{Tuple{Int64, Vector{Int64}}}}} to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractA'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + i\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1jvf4l5_.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1jvf4l5_.jl:1\n\
    in expression starting at /tmp/tmp1jvf4l5_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb3lkmxxu.jl:85\nin expression starting at\
    \ /tmp/tmpb3lkmxxu.jl:85\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + 1\n        \n        lst[i] = sort(lst[i])\n        \n        lst[i]\
    \ = lst[i][1:x+1]\n        \n        lst[i] = sort(lst[i])\n        \n       \
    \ lst[i] = lst[i][1:x+1]\n    end\n    \n    rows = sort(rows)\n    \n    coords\
    \ = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = Tuple(rows[i], i)\n    end\n    \n    coords = sort(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5zm6bzgg.jl:51\nin expression starting at\
    \ /tmp/tmp5zm6bzgg.jl:51\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwfhzphxu.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwfhzphxu.jl:1\n\
    in expression starting at /tmp/tmpwfhzphxu.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for col in row\n       \
    \     push!(columns, col)\n        end\n        \n        push!(rows, (row, columns))\n\
    \    end\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    columns = sort(collect(eachcol(lst)))\n    \n    columns = reverse(columns)\n\
    \    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows =\
    \ zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n\
    \    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows\
    \ = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbctkdmww.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbctkdmww.jl:1\n\
    in expression starting at /tmp/tmpbctkdmww.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjomhjyfj.jl:92\nin expression starting at\
    \ /tmp/tmpjomhjyfj.jl:92\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(rows))\n    \n    for i = 1:length(rows)\n        coords[i]\
    \ = Tuple(rows[i], i)\n    end\n    \n    coords = sort(coords, rev=true)\n  \
    \  \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6w4r8gga.jl:41\nin expression starting at\
    \ /tmp/tmp6w4r8gga.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for (i,v) in enumerate(lst)\n  \
    \      rows = v .== x\n        \n        if any(rows)\n            cols = sort(v\
    \ .- lst[rows][end])\n            \n            rows = v .== x\n            \n\
    \            lst[rows][end] = cols[end]\n            \n            lst[rows] =\
    \ v .- lst[rows][end]\n            \n            rows = v .== x\n            \n\
    \            lst[rows][end] = cols[end]\n            \n            lst[rows] =\
    \ v .- lst[rows][end]\n        end\n    end\n    \n    return lst\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd7auw6mg.jl:47\nin expression starting at\
    \ /tmp/tmpd7auw6mg.jl:47\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    else\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsax70ewy.jl:79\nin expression starting at\
    \ /tmp/tmpsax70ewy.jl:79\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   \n        rows = rows + 1\n        \n        columns = zeros(Int, length(lst[row]))\n\
    \        \n        for col in 1:length(lst[row])\n            \n            columns\
    \ = columns + 1\n            \n            if lst[row][col] == x\n           \
    \     \n                tuple = (rows, columns)\n                \n          \
    \      push!(rows, tuple)\n                \n            end\n            \n \
    \       end\n        \n    end\n    \n    rows = sort(rows)\n    \n    columns\
    \ = sort(sort(reverse(columns)))\n    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp45se7t9z.jl:53\nin expression starting at\
    \ /tmp/tmp45se7t9z.jl:53\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[rows .== x]\n    cols = cols[cols .==\
    \ x]\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkloj5xts.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkloj5xts.jl:1\n\
    in expression starting at /tmp/tmpkloj5xts.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpcyyhyu4j.jl:41\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    no method matching +(::Vector{Int64}, ::Int64)\n  For element-wise addition, use
    broadcasting with dot syntax: array .+ scalar\n  Closest candidates are:\n    +(::Any,
    ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n    +(!Matched::T,
    ::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32,
    UInt64, UInt8} at /shared/centos7/julia/1.7.3/share/julia/base/int.jl:87\n    +(!Matched::T,
    ::Integer) where T<:AbstractChar at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:237\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmpcyyhyu4j.jl:27\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcyyhyu4j.jl:41 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcyyhyu4j.jl:40\ntest set: Error
    During Test at /tmp/tmpcyyhyu4j.jl:42\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: no method matching +(::Vector{Int64}, ::Int64)\n  For
    element-wise addition, use broadcasting with dot syntax: array .+ scalar\n  Closest
    candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n    +(!Matched::T,
    ::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32,
    UInt64, UInt8} at /shared/centos7/julia/1.7.3/share/julia/base/int.jl:87\n    +(!Matched::T,
    ::Integer) where T<:AbstractCha'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        row_values = sort(row)\n        \n        row_values = reverse(row_values)\n\
    \        \n        row_values = filter(x -> x != 0, row_values)\n        \n  \
    \      row_values = reverse(row_values)\n        \n        row_values = sort(row_values)\n\
    \        \n        row_values = reverse(row_values)\n        \n        row_values\
    \ = filter(x -> x != 0, row_values)\n        \n        row_values = reverse(row_values)\n\
    \        \n        row_values = sort(row_values)\n        \n        row_values\
    \ = reverse(row_values)\n        \n        row_values = filter(x -> x != 0, row_values)\n\
    \        \n        row_values = reverse(row_values)\n        \n        row_values\
    \ = sort(row_values)\n        \n        row_values = reverse(row_values)\n   \
    \     \n        row_values = filter(x -> x != 0, row_values)\n        \n     \
    \   row_values = reverse(row_values)\n        \n        row_values = sort(row_values)\n\
    \        \n        row_values = reverse(row_values)\n        \n        row_values\
    \ = filter(x -> x != 0, row_values)\n        \n        row_values = reverse(row_values)\n\
    \        \n        row_values = sort(row_values)\n        \n        row_values\
    \ = reverse(row_values)\n        \n        row_values = filter(x -> x != 0, row_values)\n\
    \        \n        row_values = reverse(row_values)\n        \n        row_values\
    \ = sort(row_values)\n        \n        row_values = reverse(row_values)\n   \
    \     \n        row_values = filter(x -> x != 0, row_values)\n        \n     \
    \   row_values = reverse(row_values)\n        \n        row_values = sort(row_values)\n\
    \        \n        row_values = reverse(row_values)\n        \n        row_values\
    \ = filter(x -> x != 0, row_values)\n        \n        row_values = reverse(row_values)\n\
    \        \n        row_values = sort(row_values)\n        \n        row_values\
    \ = reverse(row_values)\n        \n        row_values = filter(x -> x != 0, row_values)\n\
    \        \n        row_values = reverse(row_values)\n        \n        row_values\
    \ = sort(row_values)\n        \n        row_values = reverse(row_values)\n   \
    \     \n        row_values = filter(x -> x != 0, row_values)\n        \n     \
    \   row_values = reverse(row_values)\n        \n        row_values = sort(row_values)\n\
    \        \n        row_values = reverse(row_values)\n        \n        row_values\
    \ = filter(x -> x != 0, row_values)\n        \n        row_values = reverse(row_values)\n\
    \        \n        row_values = sort(row_values)\n        \n        row_values\
    \ = reverse(row_values)\n        \n        row_values = filter(x -> x != 0, row_values)\n\
    \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmp2xezinb6.jl:25\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2xezinb6.jl:1\n\
    in expression starting at /tmp/tmp2xezinb6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[rows .<= length(lst)]\n\
    \    cols = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= x]\n\
    \    cols = cols[cols .>= x]\n    \n    rows = rows[rows .<= length(lst)]\n  \
    \  cols = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= x]\n \
    \   cols = cols[cols .>= x]\n    \n    rows = rows[rows .<= length(lst)]\n   \
    \ cols = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= x]\n  \
    \  cols = cols[cols .>= x]\n    \n    rows = rows[rows .<= length(lst)]\n    cols\
    \ = cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= x]\n    cols\
    \ = cols[cols .>= x]\n    \n    rows = rows[rows .<= length(lst)]\n    cols =\
    \ cols[cols .<= length(lst[1])]\n    \n    rows = rows[rows .>= x]\n    cols =\
    \ cols[cols .>= x]\n    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols\
    \ .<= length(lst[1])]\n    \n    rows = rows[rows .>= x]\n    cols = cols[cols\
    \ .>= x]\n    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<=\
    \ length(lst[1])]\n    \n    rows = rows[rows .>= x]\n    cols = cols[cols .>=\
    \ x]\n    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .>= x]\n    cols = cols[cols .>= x]\n    \n    rows\
    \ = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n   \
    \ \n    rows = rows[rows .>= x]\n    cols = cols[cols .>= x]\n    \n    rows =\
    \ rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n    \n\
    \    rows = rows[rows .>= x]\n    cols = cols[cols .>= x]\n    \n    rows = rows[rows\
    \ .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n    \n    rows =\
    \ rows[rows .>= x]\n    cols = col\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp22cj8sed.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp22cj8sed.jl:1\n\
    in expression starting at /tmp/tmp22cj8sed.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (r, c) in zip(rows, cols)\n        coords[r][c]\
    \ = (r, c) \n    end\n    \n    coords = coords[coords[:, 1] .== x]\n    \n  \
    \  coords = coords[coords[:, 2] .> coords[:, 1]]\n    \n    coords = coords[coords[:,\
    \ 2] .< coords[:, 1] + 1]\n    \n    coords = coords[coords[:, 1] .> 0]\n    \n\
    \    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4n6hlfjg.jl:40\nin expression starting at\
    \ /tmp/tmp4n6hlfjg.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    return [(rows[i], cols[i]) for i in 1:length(lst)]\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd_cp9gdi.jl:33\nin expression starting at\
    \ /tmp/tmpd_cp9gdi.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for i = 1:length(rows)\n        coords[i, :] = [(rows[i],\
    \ cols[i]), (rows[i], cols[length(cols)-i-1])]\n    end\n    \n    coords = coords[sortperm(coords[:,\
    \ 1]), :]\n    \n    return coords[findfirst(x->x[1] == x, coords[:, 1]), :]\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0yv3mjkk.jl:34\nin expression starting at\
    \ /tmp/tmp0yv3mjkk.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[3])\n\
    \    cols = sort(cols, by=x->x[3])\n    \n    rows = sort(rows, by=x->x[4])\n\
    \    cols = sort(cols, by=x->x[4])\n    \n    rows = sort(rows, by=x->x[5])\n\
    \    cols = sort(cols, by=x->x[5])\n    \n    rows = sort(rows, by=x->x[6])\n\
    \    cols = sort(cols, by=x->x[6])\n    \n    rows = sort(rows, by=x->x[7])\n\
    \    cols = sort(cols, by=x->x[7])\n    \n    rows = sort(rows, by=x->x[8])\n\
    \    cols = sort(cols, by=x->x[8])\n    \n    rows = sort(rows, by=x->x[9])\n\
    \    cols = sort(cols, by=x->x[9])\n    \n    rows = sort(rows, by=x->x[10])\n\
    \    cols = sort(cols, by=x->x[10])\n    \n    rows = sort(rows, by=x->x[11])\n\
    \    cols = sort(cols, by=x->x[11])\n    \n    rows = sort(rows, by=x->x[12])\n\
    \    cols = sort(cols, by=x->x[12])\n    \n    rows = sort(rows, by=x->x[13])\n\
    \    cols = sort(cols, by=x->x[13])\n    \n    rows = sort(rows, by=x->x[14])\n\
    \    cols = sort(cols, by=x->x[14])\n    \n    rows = sort(rows, by=x->x[15])\n\
    \    cols = sort(cols, by=x->x[15])\n    \n    rows = sort(rows, by=x->x[16])\n\
    \    cols = sort(cols, by=x->x[16])\n    \n    rows = sort(rows, by=x->x[17])\n\
    \    cols = sort(cols, by=x->x[17])\n    \n    rows = sort(rows, by=x->x[18])\n\
    \    cols = sort(cols, by=x->x[18])\n    \n    rows = sort(rows, by=x->x[19])\n\
    \    cols = sort(cols, by=x->x[19])\n    \n    rows = sort(\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptxf63lt6.jl:84\nin expression starting at\
    \ /tmp/tmptxf63lt6.jl:84\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    for (i,j) in zip(rows, cols)\n        coords[i, j] = (i,j)\n\
    \    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptjtgdqw8.jl:31\nin expression starting at\
    \ /tmp/tmptjtgdqw8.jl:31\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = rows[rows[2] .> x]\n    \n    rows = rows[rows[1] .> x]\n  \
    \  \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n\
    \    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n  \
    \  rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows\
    \ = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows =\
    \ rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1]\
    \ .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .>\
    \ x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n\
    \    \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n  \
    \  \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n\
    \    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n  \
    \  rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows\
    \ = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows =\
    \ rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1]\
    \ .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .>\
    \ x]\n    \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n\
    \    \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n  \
    \  \n    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n\
    \    rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1] .> x]\n    \n  \
    \  rows = rows[rows[1] .> x]\n    \n    rows = rows[rows[1]\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkna9nwis.jl:1\nin expression starting at /tmp/tmpkna9nwis.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    end\n    \n    rows = sort(collect(enumerate(lst)))\n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4lmbeuwl.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4lmbeuwl.jl:1\n\
    in expression starting at /tmp/tmp4lmbeuwl.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    columns\
    \ = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        columns\
    \ = columns + lst[i][end]\n    end\n    \n    columns = sort(columns)\n    \n\
    \    return zip(rows, columns)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpriaa6x44.jl:41\nin expression starting at\
    \ /tmp/tmpriaa6x44.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    coords = zip(rows, cols)\n\
    \    \n    coords = coords[coords..<= x]\n    \n    coords = coords[reverse .!=\
    \ coords]\n    \n    coords = coords.+(0, length(coords)-1)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid operator \"..<\" near column 28\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp66pad0gh.jl:29\nin expression starting at\
    \ /tmp/tmp66pad0gh.jl:29\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    coords = coords[coords[:,\
    \ 1] == x, :]\n    \n    coords = coords[sortperm(coords[:, 2]), :]\n    \n  \
    \  return coords\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpwbz_761r.jl:41\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    no method matching sort!(::Vector{Int64}; by=length, reverse=true)\n  Closest
    candidates are:\n    sort!(::Vector{Int64}, !Matched::Base.Sort.Algorithm, !Matched::Base.Order.Perm{<:Base.Order.DirectOrdering,
    <:Vector{<:Union{Missing, Float32, Float64}}}) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1236
    got unsupported keyword arguments "by", "reverse"\n    sort!(::AbstractVector;
    alg, lt, by, rev, order) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:707
    got unsupported keyword argument "reverse"\n    sort!(::AbstractVector, !Matched::Integer,
    !Matched::Integer, !Matched::Base.Sort.InsertionSortAlg, !Matched::Base.Order.Ordering)
    at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:502 got unsupported keyword
    arguments "by", "reverse"\n    ...\n  Stacktrace:\n   [1] kwerr(::NamedTuple{(:by,
    :reverse), Tuple{typeof(length), Bool}}, ::Function, ::Vector{Int64})\n     @
    Base ./error.jl:163\n   [2] sort(v::Vector{Int64}; kws::Base.Pairs{Symbol, Any,
    Tuple{Symbol, Symbol}, NamedTuple{(:by, :reverse), Tuple{typeof(length), Bool}}})\n     @
    Base.Sort ./sort.jl:772\n   [3] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @
    Main /tmp/tmpwbz_761r.jl:22\n   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [5] macro expansion\n     @ /tmp/tmpwbz_761r.jl:41 [inlined]\n   [6]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [7] top-level scope\n     @ /tmp/tmpwbz_761r.jl:40\ntest set: Error
    During Test at /tmp/tmpwbz_761r.jl:42\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjomhjyfj.jl:92\nin expression starting at\
    \ /tmp/tmpjomhjyfj.jl:92\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkeliy1g5.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkeliy1g5.jl:1\n\
    in expression starting at /tmp/tmpkeliy1g5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n     \
    \   \n        rows = rows + 1\n        \n        rows = sort(rows, rev=true)\n\
    \        \n        columns = zeros(Int, length(lst[row]))\n        \n        for\
    \ col in 1:length(lst[row])\n            \n            columns = columns + 1\n\
    \            \n            columns = sort(columns, rev=true)\n            \n \
    \           if lst[row][col] == x\n                \n                return [(rows\
    \ - 1, columns - 1)]\n            end\n        end\n    end\n    \n    return\
    \ []\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkdsc6kqq.jl:48\nin expression starting at\
    \ /tmp/tmpkdsc6kqq.jl:48\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = Tuple(rows[i], i)\n    end\n    \n    coords = sort(coords)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmtx64jv5.jl:41\nin expression starting at\
    \ /tmp/tmpmtx64jv5.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        for j, (col) in enumerate(cols)\n\
    \            if lst[row][col] == x\n                coords[i,j] = Tuple{Int64,\
    \ Int64}(i, j)\n            end\n        end\n    end\n    \n    coords = sort(coords,\
    \ by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7i7tc7c4.jl:30\nin expression starting at\
    \ /tmp/tmp7i7tc7c4.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        coords[i,:]\
    \ = [row, cols]\n    end\n    \n    coords = coords[coords[:,1] .== x, :]\n  \
    \  \n    coords = coords[sortperm(coords[:,2]), :]\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuv7hfhth.jl:36\nin expression starting at\
    \ /tmp/tmpuv7hfhth.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = rows[i], lst[i][x]\n    end\n    \n    coords = sort(coords)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp90ewf4ne.jl:41\nin expression starting at\
    \ /tmp/tmp90ewf4ne.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    end\n    \n    rows = sort(collect(enumerate(lst)))\n    \n \
    \   rows = rows[rows[end][1]][1]\n    \n    rows = sort(rows, by=x->x[1])\n  \
    \  \n    rows = rows[end][end][1]\n    \n    rows = sort(rows, by=x->x[2])\n \
    \   \n    rows = rows[end][end][2]\n    \n    return Vector{Tuple{Int64, Int64}}(zip(rows,\
    \ 1:length(rows)))\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4rb562jf.jl:38\nin expression starting at\
    \ /tmp/tmp4rb562jf.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + 1\n        \n        if lst[i][x] == x\n            \n            cols\
    \ = zeros(Int, length(lst[i]))\n            \n            for j = 1:length(lst[i])\n\
    \                cols = cols + 1\n            end\n            \n            tuple\
    \ = Tuple(rows, cols)\n            \n            push!(rows, tuple)\n        end\n\
    \    end\n    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nget_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n</cell>\n<code\
    \ language=julia-1.5>\nget_row([], 1)\n</cell>\n<code language=julia-1.5>\nget_row([[],\
    \ [1], [1, 2, 3]], 3)\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprzn5hcaw.jl:44\nin expression starting at\
    \ /tmp/tmprzn5hcaw.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for i = 1:length(rows)\n        coords[i, :] = [lst[rows[i],\
    \ cols[i]], i]\n    end\n    \n    coords = coords[reverse .!= coords]\n    \n\
    \    coords = coords[coords[:, 2] .<= x]\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8nk3ozr1.jl:39\nin expression starting at\
    \ /tmp/tmp8nk3ozr1.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst) == 0 \n        return\
    \ [] \n    \n    rows = sort(collect(1:length(lst)))\n    cols = sort(collect(1:length(lst[rows])),\
    \ by=length, reverse=true)\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (r,c) in zip(rows, cols) \n        coords[r][c] = (r,c)\n    end\n\
    \    \n    coords = coords[coords[:,1] .== x]\n    \n    return coords\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp67gwoz97.jl:36\nin expression starting at\
    \ /tmp/tmp67gwoz97.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb3lkmxxu.jl:85\nin expression starting at\
    \ /tmp/tmpb3lkmxxu.jl:85\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols[row] = length(lst[row])\n\
    \    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows =\
    \ rows[reverse .!=(rows == cols)]\n    cols = cols[reverse .!=(rows == cols)]\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for row in 1:length(rows)\n\
    \        for col in 1:length(cols)\n            coords[row, col] = (row, cols[col])\n\
    \        end\n    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords\
    \ = sort(coords, by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuq4sy_ia.jl:50\nin expression starting at\
    \ /tmp/tmpuq4sy_ia.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmperwwhjl3.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmperwwhjl3.jl:1\n\
    in expression starting at /tmp/tmperwwhjl3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    else\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst)]\n        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst)]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsax70ewy.jl:79\nin expression starting at\
    \ /tmp/tmpsax70ewy.jl:79\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    else\n\
    \        lst = sort(lst)\n        \n        rows = zeros(Int, length(lst))\n \
    \       cols = zeros(Int, length(lst))\n        \n        for (i, row) in enumerate(lst)\n\
    \            \n            cols = sort(row)\n            \n            for (j,\
    \ col) in enumerate(cols)\n                if col == x\n                    rows[i]\
    \ = j\n                    break\n            end\n        end\n        \n   \
    \     rows = sort(rows)\n        cols = sort(cols)\n        \n        \n     \
    \   \n        \n        \n        \n        \n        \n        \n        \n \
    \       \n        \n        \n        \n        \n        \n        \n       \
    \ \n        \n        \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"for\" at /tmp/tmp98zbam6d.jl:28\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp98zbam6d.jl:1\n\
    in expression starting at /tmp/tmp98zbam6d.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = Tuple(rows[i], i)\n    end\n    \n    coords = sort(coords)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmtx64jv5.jl:41\nin expression starting at\
    \ /tmp/tmpmtx64jv5.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[3])\n\
    \    cols = sort(cols, by=x->x[3])\n    \n    rows = sort(rows, by=x->x[4])\n\
    \    cols = sort(cols, by=x->x[4])\n    \n    rows = sort(rows, by=x->x[5])\n\
    \    cols = sort(cols, by=x->x[5])\n    \n    rows = sort(rows, by=x->x[6])\n\
    \    cols = sort(cols, by=x->x[6])\n    \n    rows = sort(rows, by=x->x[7])\n\
    \    cols = sort(cols, by=x->x[7])\n    \n    rows = sort(rows, by=x->x[8])\n\
    \    cols = sort(cols, by=x->x[8])\n    \n    rows = sort(rows, by=x->x[9])\n\
    \    cols = sort(cols, by=x->x[9])\n    \n    rows = sort(rows, by=x->x[10])\n\
    \    cols = sort(cols, by=x->x[10])\n    \n    rows = sort(rows, by=x->x[11])\n\
    \    cols = sort(cols, by=x->x[11])\n    \n    rows = sort(rows, by=x->x[12])\n\
    \    cols = sort(cols, by=x->x[12])\n    \n    rows = sort(rows, by=x->x[13])\n\
    \    cols = sort(cols, by=x->x[13])\n    \n    rows = sort(rows, by=x->x[14])\n\
    \    cols = sort(cols, by=x->x[14])\n    \n    rows = sort(rows, by=x->x[15])\n\
    \    cols = sort(cols, by=x->x[15])\n    \n    rows = sort(rows, by=x->x[16])\n\
    \    cols = sort(cols, by=x->x[16])\n    \n    rows = sort(rows, by=x->x[17])\n\
    \    cols = sort(cols, by=x->x[17])\n    \n    rows = sort(rows, by=x->x[18])\n\
    \    cols = sort(cols, by=x->x[18])\n    \n    rows = sort(rows, by=x->x[19])\n\
    \    cols = sort(cols, by=x->x[19])\n    \n    rows = sort(\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptxf63lt6.jl:84\nin expression starting at\
    \ /tmp/tmptxf63lt6.jl:84\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    columns = sort(collect(1:length(lst[rows])),\
    \ by=x->-x)\n    \n    columns = sort(columns, by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(columns))\n    \n    for i = 1:length(rows)\n        coords[i, :] = [rows,\
    \ columns]\n    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplt4s_o1t.jl:37\nin expression starting at\
    \ /tmp/tmplt4s_o1t.jl:37\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(rows))\n    \n    for i = 1:length(rows)\n        coords[i]\
    \ = (i-1, rows[i])\n    end\n    \n    coords = sort(coords)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpulgt5g71.jl:41\nin expression starting at\
    \ /tmp/tmpulgt5g71.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = Vector{Int64}()\n        \n        for col in row\n       \
    \     push!(columns, col)\n        end\n        \n        push!(rows, (row, columns))\n\
    \    end\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    columns = sort(collect(eachindex(rows[1])))\n    \n    columns = reverse(columns)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n    \n    rows =\
    \ reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n    rows = sort(rows)\n\
    \    \n    rows = reverse(rows)\n    \n    rows = zip(rows, columns)\n    \n \
    \   rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n    rows = zip(rows,\
    \ columns)\n    \n    rows = sort(rows)\n    \n    rows = reverse(rows)\n    \n\
    \    rows = zip(rows, columns)\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5k30mle3.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5k30mle3.jl:1\n\
    in expression starting at /tmp/tmp5k30mle3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    elseif x == 1\n        lst[1]\n    elseif x == 2\n \
    \       lst[2]\n    elseif x == 3\n        lst[3]\n    elseif x == 4\n       \
    \ lst[4]\n    elseif x == 5\n        lst[5]\n    elseif x == 6\n        lst[6]\n\
    \    else\n        error(\"x must be in range 0..6\")\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpghzhqvwb.jl:40\nin expression starting at\
    \ /tmp/tmpghzhqvwb.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        for (c,col)\
    \ in enumerate(cols)\n            if lst[row][c] == x\n                coords[i,c]\
    \ = (i,c)\n            end\n        end\n    end\n    \n    coords = sort(coords,\
    \ by=x->x[1], rev=true)\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnfgz13z_.jl:38\nin expression starting at\
    \ /tmp/tmpnfgz13z_.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for i = 1:length(rows)\n        coords[rows[i], cols[i]]\
    \ = (x == lst[rows[i], cols[i]])\n    end\n    \n    coords = coords[sortperm(coords[:,\
    \ 1]), :]\n    coords = coords[sortperm(coords[:, 2]), :]\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaf1cfwx5.jl:35\nin expression starting at\
    \ /tmp/tmpaf1cfwx5.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 1\n        []\n    else\n        lst = sort(lst)\n        lst = sort(lst)\n\
    \        lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n \
    \       lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n  \
    \      lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n   \
    \     lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n    \
    \    lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n     \
    \   lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n      \
    \  lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n       \
    \ lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n        lst\
    \ = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n        lst =\
    \ sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n\
    \        lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n \
    \       lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n  \
    \      lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n   \
    \     lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n    \
    \    lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n     \
    \   lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n      \
    \  lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n       \
    \ lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n        lst\
    \ = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n        lst =\
    \ sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n\
    \        lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n \
    \       lst = sort(lst)\n        lst = sort(lst)\n        lst = sort(lst)\n  \
    \      lst = \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmptszc27wl.jl:22\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmptszc27wl.jl:1\n\
    in expression starting at /tmp/tmptszc27wl.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    columns = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n\
    \    \n    coordinates = zeros(length(rows), length(columns))\n    \n    for row\
    \ in rows\n        coordinates[row] = Tuple{Int64, Int64}((row, columns[columns[row]]))\n\
    \    end\n    \n    coordinates = coordinates[coordinates[row][1]][1]\n    \n\
    \    return coordinates\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6s0dtlmp.jl:35\nin expression starting at\
    \ /tmp/tmp6s0dtlmp.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = (i-1, cols[i])\n    end\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprxxu2i6z.jl:42\nin expression starting at\
    \ /tmp/tmprxxu2i6z.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjomhjyfj.jl:92\nin expression starting at\
    \ /tmp/tmpjomhjyfj.jl:92\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows ==\
    \ x]\n    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpl8qjd4k1.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpl8qjd4k1.jl:1\n\
    in expression starting at /tmp/tmpl8qjd4k1.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwfhzphxu.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwfhzphxu.jl:1\n\
    in expression starting at /tmp/tmpwfhzphxu.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjomhjyfj.jl:92\nin expression starting at\
    \ /tmp/tmpjomhjyfj.jl:92\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    elseif x == 0\n        return Vector{Tuple{Int64, Int64}}()\n\
    \    elseif x == 1\n        return [(0,0)]\n    elseif x == 2\n        return\
    \ [(0,1)]\n    elseif x == 3\n        return [(0,2), (1,2), (2,2)]\n    elseif\
    \ x == 4\n        return [(0,3), (1,3), (2,3), (3,3)]\n    elseif x == 5\n   \
    \     return [(0,4), (1,4), (2,4), (3,4), (4,4)]\n    elseif x == 6\n        return\
    \ [(0,5), (1,5), (2,5), (3,5), (4,5), (5,5)]\n    elseif x == 7\n        return\
    \ [(0,6), (1,6), (2,6), (3,6), (4,6), (5,6), (6,6)]\n    elseif x == 8\n     \
    \   return [(0,7), (1,7), (2,7), (3,7), (4,7), (5,7), (6,7), (7,7)]\n    elseif\
    \ x == 9\n        return [(0,8), (1,8), (2,8), (3,8), (4,8), (5,8), (6,8), (7,8),\
    \ (8,8)]\n    elseif x == 10\n        return [(0,9), (1,9), (2,9), (3,9), (4,9),\
    \ (5,9), (6,9), (7,9), (8,9), (9,9)]\n    elseif x == 11\n        return [(0,10),\
    \ (1,10), (2,10), (3,10), (4,10), (5,10), (6,10), (7,10), (8,10), (9,10), (10,10)]\n\
    \    elseif x == 12\n        return [(0,11), (1,11), (2,11), (3,11), (4,11), (5,11),\
    \ (6,11), (7,11), (8,11), (9,11), (10,11), (11,11)]\n    elseif x == 13\n    \
    \    return [(0,12), (1,12), (2,12), (3,12), (4,12), (5,12), (6,12), (7,12), (8,12),\
    \ (9,12), (10,12), (11,12), (12,12)]\n    elseif x == 14\n        return [(0,13),\
    \ (1,13), (2,13), (3,13), (4,13), (5,13), (6,13), (7,13), (8,13), (9,13), (10,13),\
    \ (11,13), (12,13), (13,13)]\n    elseif x == 15\n        return [(0,14), (1,14),\
    \ (2,14), (3,14), (4,14), (5,14), (6,14), (7,14), (8,14), (9,14), (10,14), (11,14),\
    \ (12,14), (13,14), (14,14)]\n    elseif x == 16\n        return [(0,\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7tbx_rnq.jl:58\nin expression starting at\
    \ /tmp/tmp7tbx_rnq.jl:58\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    rows = sort(rows, by=x->x[3])\n    \n    rows = sort(rows, by=x->-x[3])\n\
    \    \n    rows = sort(rows, by=x->x[4])\n    \n    rows = sort(rows, by=x->-x[4])\n\
    \    \n    rows = sort(rows, by=x->x[5])\n    \n    rows = sort(rows, by=x->-x[5])\n\
    \    \n    rows = sort(rows, by=x->x[6])\n    \n    rows = sort(rows, by=x->-x[6])\n\
    \    \n    rows = sort(rows, by=x->x[7])\n    \n    rows = sort(rows, by=x->-x[7])\n\
    \    \n    rows = sort(rows, by=x->x[8])\n    \n    rows = sort(rows, by=x->-x[8])\n\
    \    \n    rows = sort(rows, by=x->x[9])\n    \n    rows = sort(rows, by=x->-x[9])\n\
    \    \n    rows = sort(rows, by=x->x[10])\n    \n    rows = sort(rows, by=x->-x[10])\n\
    \    \n    rows = sort(rows, by=x->x[11])\n    \n    rows = sort(rows, by=x->-x[11])\n\
    \    \n    rows = sort(rows, by=x->x[12])\n    \n    rows = sort(rows, by=x->-x[12])\n\
    \    \n    rows = sort(rows, by=x->x[13])\n    \n    rows = sort(rows, by=x->-x[13])\n\
    \    \n    rows = sort(rows, by=x->x[14])\n    \n    rows = sort(rows, by=x->-x[14])\n\
    \    \n    rows = sort(rows, by=x->x[15])\n    \n    rows = sort(rows, by=x->-x[15])\n\
    \    \n    rows = sort(rows, by=x->x[16])\n    \n    rows = sort(rows, by=x->-x[16])\n\
    \    \n    rows = sort(rows, by=x->x[17])\n    \n    rows = sort(rows, by=x->-x[17])\n\
    \    \n    rows = sort(rows, by=x->x[18])\n    \n    rows = sort(rows, by=x->-x[18])\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkeliy1g5.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkeliy1g5.jl:1\n\
    in expression starting at /tmp/tmpkeliy1g5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpayvb79wc.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpayvb79wc.jl:1\n\
    in expression starting at /tmp/tmpayvb79wc.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmperwwhjl3.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmperwwhjl3.jl:1\n\
    in expression starting at /tmp/tmperwwhjl3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        \n        rows = rows + 1\n        cols\
    \ = cols + length(lst[row])\n        \n    end\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    coords = zeros(Int, length(lst))\n    \n   \
    \ for row in 1:length(lst)\n        \n        coords[row] = Tuple(rows[row], cols[row])\n\
    \        \n    end\n    \n    coords = sort(coords)\n    \n    coords = coords[coords[2]\
    \ .< x]\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3sooha5c.jl:50\nin expression starting at\
    \ /tmp/tmp3sooha5c.jl:50\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end-x+1:end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = Tuple(rows[i], cols[i])\n    end\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph83fwcs8.jl:42\nin expression starting at\
    \ /tmp/tmph83fwcs8.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    columns = sort(collect(1:length(lst[rows])), by=desc)\n    \n    coords =\
    \ zeros(length(rows), length(columns))\n    for row in rows\n        for col in\
    \ columns\n            coords[row, col] = ((row, col), lst[row, col] == x)\n \
    \       end\n    end\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp363h7vjw.jl:33\nin expression starting at\
    \ /tmp/tmp363h7vjw.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows\
    \ = rows[rows..end]\n    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n\
    \    cols = cols[cols..end]\n    \n    rows = rows[rows..end]\n    cols = cols[cols..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpayvb79wc.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpayvb79wc.jl:1\n\
    in expression starting at /tmp/tmpayvb79wc.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[cols <= x]\n\
    \    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows\
    \ >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n\
    \    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >=\
    \ x]\n    \n    rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n   \
    \ rows = rows[cols <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols\
    \ <= x]\n    cols = cols[rows >= x]\n    \n    rows = rows[cols <= x]\n    cols\
    \ = col\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6hmvl9kq.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6hmvl9kq.jl:1\n\
    in expression starting at /tmp/tmp6hmvl9kq.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end-x+1:end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    return zip(rows, cols)\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp297qp95o.jl:36\nin expression starting at\
    \ /tmp/tmp297qp95o.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for row in rows\n        coords = coords + [(row, cols[cols..end-1])]\n\
    \    end\n    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n    \n    coords = coords[coords..end]\n\
    \    \n    coords = coords[coords..end]\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpsej49aqo.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpsej49aqo.jl:1\n\
    in expression starting at /tmp/tmpsej49aqo.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb3lkmxxu.jl:85\nin expression starting at\
    \ /tmp/tmpb3lkmxxu.jl:85\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 1\n        []\n    else\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x)]\n        \n        lst = reverse(lst)\n        \n  \
    \      lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst = lst[findall(lst\
    \ .== x)]\n        \n        lst = reverse(lst)\n        \n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        \n        lst = lst[findall(lst .== x)]\n\
    \        \n        lst = reverse(lst)\n        \n        lst = sort(lst)\n   \
    \     lst = reverse(lst)\n        \n        lst = lst[findall(lst .== x)]\n  \
    \      \n        lst = reverse(lst)\n        \n        lst = sort(lst)\n     \
    \   lst = reverse(lst)\n        \n        lst = lst[findall(lst .== x)]\n    \
    \    \n        lst = reverse(lst)\n        \n        lst = sort(lst)\n       \
    \ lst = reverse(lst)\n        \n        lst = lst[findall(lst .== x)]\n      \
    \  \n        lst = reverse(lst)\n        \n        lst = sort(lst)\n        lst\
    \ = reverse(lst)\n        \n        lst = lst[findall(lst .== x)]\n        \n\
    \        lst = reverse(lst)\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n        \n        lst = lst[findall(lst .== x)]\n        \n  \
    \      lst = reverse(lst)\n        \n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        \n        lst = lst[findall(lst .== x)]\n        \n        lst = reverse(lst)\n\
    \        \n        lst = sort(lst)\n        lst = reverse(lst)\n        \n   \
    \     lst = lst[findall(lst .== x)]\n        \n        lst = reverse(lst)\n  \
    \      \n        lst = sort(lst)\n        lst = reverse(lst)\n        \n     \
    \   lst = lst[findall(lst .== x)]\n        \n        lst = reverse(lst)\n    \
    \    \n        lst = sort(lst)\n        lst = reverse(lst)\n        \n       \
    \ lst = lst[findall(lst .== x)]\n        \n        lst = reverse(lst)\n      \
    \  \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpbka4dux2.jl:22\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbka4dux2.jl:1\n\
    in expression starting at /tmp/tmpbka4dux2.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    coords = zeros(length(rows), length(cols))\n\
    \    \n    for (i,row) in enumerate(rows)\n        for (c,col) in enumerate(cols)\n\
    \            coords[i,c] = Tuple{Int64, Int64}(i, c)\n        end\n    end\n \
    \   \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn5wsncm1.jl:37\nin expression starting at\
    \ /tmp/tmpn5wsncm1.jl:37\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = Tuple(rows[i], i)\n    end\n    \n    coords = sort(coords)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmtx64jv5.jl:41\nin expression starting at\
    \ /tmp/tmpmtx64jv5.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmperwwhjl3.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmperwwhjl3.jl:1\n\
    in expression starting at /tmp/tmperwwhjl3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[rows .<= cols]\n    cols = cols[cols\
    \ .<= rows]\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n\
    \    \n    rows = rows[rows .>= x]\n    cols = cols[cols .>= x]\n    \n    rows\
    \ = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n   \
    \ \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = cols[cols .<= length(lst[1])]\n\
    \    \n    rows = rows[rows .<= length(lst)]\n    cols = \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwj_05xar.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwj_05xar.jl:1\n\
    in expression starting at /tmp/tmpwj_05xar.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = rows[rows[2] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< \n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq09l6puv.jl:1\nin expression starting at /tmp/tmpq09l6puv.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprx0gxv20.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmprx0gxv20.jl:1\n\
    in expression starting at /tmp/tmprx0gxv20.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[rows .<= x]\n\
    \    cols = cols[cols .<= x]\n    \n    rows = rows[reverse .>= x]\n    cols =\
    \ cols[reverse .>= x]\n    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse\
    \ .>= x]\n    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n\
    \    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n\
    \    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows\
    \ = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows = rows[reverse\
    \ .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows = rows[reverse .>= x]\n\
    \    cols = cols[reverse .>= x]\n    \n    rows = rows[reverse .>= x]\n    cols\
    \ = cols[reverse .>= x]\n    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse\
    \ .>= x]\n    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n\
    \    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n\
    \    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows\
    \ = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows = rows[reverse\
    \ .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows = rows[reverse .>= x]\n\
    \    cols = cols[reverse .>= x]\n    \n    rows = rows[reverse .>= x]\n    cols\
    \ = cols[reverse .>= x]\n    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse\
    \ .>= x]\n    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n\
    \    \n    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n\
    \    rows = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows\
    \ = rows[reverse .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows = rows[reverse\
    \ .>= x]\n    cols = cols[reverse .>= x]\n    \n    rows = rows[reverse .>= \n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2gctq5ey.jl:1\nin expression starting at /tmp/tmp2gctq5ey.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = ((rows[i], cols[i]), i)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf_ts7ex2.jl:44\nin expression starting at\
    \ /tmp/tmpf_ts7ex2.jl:44\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpjlaqk2dm.jl:38\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Vector{Int64} to an object of type Int64\n  Closest
    candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\n    convert(::Type{T},
    !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\n    convert(::Type{T},
    !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\n    ...\n  Stacktrace:\n    [1]
    cvt1\n      @ ./essentials.jl:343 [inlined]\n    [2] ntuple\n      @ ./ntuple.jl:49
    [inlined]\n    [3] convert(#unused#::Type{Tuple{Int64, Int64}}, x::Tuple{Int64,
    Vector{Int64}})\n      @ Base ./essentials.jl:344\n    [4] setindex!(A::Vector{Tuple{Int64,
    Int64}}, x::Tuple{Int64, Vector{Int64}}, i1::Int64)\n      @ Base ./array.jl:903\n    [5]
    _unsafe_copyto!(dest::Vector{Tuple{Int64, Int64}}, doffs::Int64, src::Vector{Tuple{Int64,
    Vector{Int64}}}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [6]
    unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [7] _copyto_impl!\n      @
    ./array.jl:331 [inlined]\n    [8] copyto!\n      @ ./array.jl:317 [inlined]\n    [9]
    copyto!\n      @ ./array.jl:343 [inlined]\n   [10] copyto_axcheck!\n      @ ./abstractarray.jl:1104
    [inlined]\n   [11] Vector{Tuple{Int64, Int64}}(x::Vector{Tuple{Int64, Vector{Int64}}})\n      @
    Base ./array.jl:563\n   [12] convert\n      @ ./array.jl:554 [inlined]\n   [13]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n      @ Main /tmp/tmpjlaqk2dm.jl:31\n   [14]
    macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [15] macro expansion\n      @ /tmp/tmpjlaqk2dm.jl:38 [inlined]\n   [16]
    macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n\
    \    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows\
    \ = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n\
    \    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows\
    \ = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows,\
    \ by=x->-x)\n    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n\
    \    cols = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols\
    \ = sort(cols, by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols,\
    \ by=x->-x)\n    \n    rows = sort(rows, by=x->-x)\n    cols = sort(cols, by=x->-x)\n\
    \    \n    rows = sort(rows, by=x\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj9lbxlhh.jl:85\nin expression starting at\
    \ /tmp/tmpj9lbxlhh.jl:85\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.data) == 0 \n   \
    \     return [] \n    \n    rows = sort(collect(enumerate(lst.data)))\n    \n\
    \    rows = rows[rows[2] .> x]\n    \n    columns = sort(collect(enumerate(rows[1])))\n\
    \    \n    columns = columns[columns[2] .> x]\n    \n    coordinates = zip(rows[1],\
    \ columns[1])\n    \n    return coordinates\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuu6xv6_h.jl:35\nin expression starting at\
    \ /tmp/tmpuu6xv6_h.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb3lkmxxu.jl:85\nin expression starting at\
    \ /tmp/tmpb3lkmxxu.jl:85\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    for (r,c) in zip(rows, cols)\n        coords[r][c] = (r,c)\n\
    \    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->-x[1])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3ysibt5q.jl:34\nin expression starting at\
    \ /tmp/tmp3ysibt5q.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for (i,v) in enumerate(lst)\n  \
    \      rows[i] = v[x]\n    end\n    \n    rows = sort(rows)\n    \n    cols =\
    \ zeros(Int, length(lst))\n    \n    for (i,v) in enumerate(rows)\n        cols[i]\
    \ = v\n    end\n    \n    cols = sort(cols)\n    \n    coords = zeros(Int, length(lst))\n\
    \    \n    for (i,v) in enumerate(cols)\n        coords[i] = v\n    end\n    \n\
    \    coords = sort(coords)\n    \n    return coords\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 5 errored,
    0 broken.

    in expression starting at /tmp/tmpmv1esx8y.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmpmv1esx8y.jl:54\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: Cannot\
    \ `convert` an object of type Int64 to an object of type Tuple{Int64, Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Tuple\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:336\n    convert(::Type{T},\
    \ !Matched::Tuple{Vararg{Any, N}}) where {N, T<:Tuple} at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:337\n\
    \    convert(::Type{T}, !Matched::CartesianIndex) where T<:Tuple at /shared/centos7/julia/1.7.3/share/julia/base/multidimensional.jl:137\n\
    \    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Tuple{Int64, Int64}}, x::Int64,\
    \ i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Tuple{Int64,\
    \ Int64}}, doffs::Int64, src::Vector{Int64}, soffs::Int64, n::Int64)\n      @\
    \ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n\
    \    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n  \
    \    @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n\
    \    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Tuple{Int64,\
    \ Int64}}(x::Vector{Int64})\n      @ Base ./array.jl:563\n    [9] convert\n  \
    \    @ ./array.jl:554 [inlined]\n   [10] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \      @ Main /tmp/tmpmv1esx8y.jl:47\n   [11] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [12] macro expansion\n      @ /tmp/tmpmv1esx8y.jl:54 [inlined]\n\
    \   [13] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [14] top-level scope\n      @ /tmp/tmpmv1esx8y.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpmv1esx8y.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2"
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + 1\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = rows[cols\
    \ == x]\n    cols = cols[rows == x]\n    \n    rows = reverse(rows)\n    cols\
    \ = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(cols)\n\
    \    \n    rows = reverse(rows)\n    cols = reverse(cols)\n    \n    rows = reverse(rows)\n\
    \    cols = reverse(cols)\n    \n    rows = reverse(rows)\n    cols = reverse(\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpatbriyod.jl:146\nin expression starting at\
    \ /tmp/tmpatbriyod.jl:146\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for (i,row) in enumerate(lst)\n        rows = rows + row\n        cols =\
    \ cols + i\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    coords = zeros(Int, length(lst))\n    \n    for (i,row) in enumerate(lst)\n\
    \        coords[i] = findfirst(x->x==row, rows)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n \
    \   coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n \
    \   coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords\
    \ = reverse(coords)\n    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n\
    \    \n    coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n \
    \   coords = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords\
    \ = sort(coords)\n    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n\
    \    \n    coords = reverse(coords)\n    \n    coords = sort(coords)\n    \n \
    \   coords = reverse(coords)\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqg6_3asw.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqg6_3asw.jl:1\n\
    in expression starting at /tmp/tmpqg6_3asw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = row\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpan1lomdx.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpan1lomdx.jl:1\n\
    in expression starting at /tmp/tmpan1lomdx.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[cols == x]\n    cols = cols[rows ==\
    \ x]\n    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    \    \n    rows = rows[rows != length(lst)]\n    cols = cols[rows != length(lst[1])]\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpl8qjd4k1.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpl8qjd4k1.jl:1\n\
    in expression starting at /tmp/tmpl8qjd4k1.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = Vector{Tuple{Int64,\
    \ Int64}}[]\n    for row in rows\n        coords = coords + [(row, cols[cols..end])]\n\
    \    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords = sort(coords,\
    \ by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp51i2eulw.jl:34\nin expression starting at\
    \ /tmp/tmp51i2eulw.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        coords[i]\
    \ = rows[i]\n    end\n    \n    coords = sort(coords)\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkv2ga8qa.jl:41\nin expression starting at\
    \ /tmp/tmpkv2ga8qa.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n        rows\
    \ = rows + lst[i][x]\n    end\n    \n    rows = sort(rows)\n    \n    coords =\
    \ zeros(Int, length(rows))\n    \n    for i = 1:length(rows)\n        coords[i]\
    \ = (i-1, rows[i])\n    end\n    \n    coords = sort(coords)\n    \n    return\
    \ coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpulgt5g71.jl:41\nin expression starting at\
    \ /tmp/tmpulgt5g71.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    \n    rows = sort(rows, by=x->-x)\n    \n    rows = sort(rows, by=x->-length(x))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n   \
    \ \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows, by=x->-length(x[1]))\n\
    \    \n    rows = sort(rows, by=x->-length(x[1]))\n    \n    rows = sort(rows,\
    \ by=\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjomhjyfj.jl:92\nin expression starting at\
    \ /tmp/tmpjomhjyfj.jl:92\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[reverse .!\
    \ (rows == x)]\n    cols = cols[reverse .! (cols == x)]\n    \n    coords = zip(rows,\
    \ cols)\n    \n    coords = coords[reverse .! (coords == (x, x))]\n    \n    return\
    \ coords\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpl478p7gc.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmpl478p7gc.jl:38\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: no method\
    \ matching typed_hcat(::Vector{Int64}, ::typeof(reverse), ::Bool)\n  Closest candidates\
    \ are:\n    typed_hcat(!Matched::Type{T}, ::Any...) where T at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:1826\n\
    \    typed_hcat(!Matched::Type{T}, !Matched::Number...) where T at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:1532\n\
    \    typed_hcat(!Matched::Type{T}, !Matched::Union{Number, LinearAlgebra.Adjoint{T,\
    \ <:AbstractVector} where T}...) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/adjtrans.jl:225\n\
    \    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpl478p7gc.jl:24\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl478p7gc.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpl478p7gc.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpl478p7gc.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: no method matching typed_hcat(::Vector{Int64},\
    \ ::typeof(reverse), ::Bool)\n  Closest candidates are:\n    typed_hcat(!Matched::Type{T},\
    \ ::Any...) where T at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:1826\n\
    \    typed_hcat(!Matched::Type{T}, !Matched::Number...) where T at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:1532\n\
    \    typed_hcat(!Matched::Type{T}, !Matched::Union{Number, LinearAlgebra.Adjoint{T,\
    \ <:AbstractVector} where T}...) where T at /shared/centos7/julia/1.7.3/sha"
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols[row] = length(lst[row])\n\
    \    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    coords\
    \ = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n        coords[row]\
    \ = ((rows - row(rows)), cols[row])\n    end\n    \n    coords = sort(coords)\n\
    \    \n    coords = coords[coords[2] .< x]\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaott9ncu.jl:46\nin expression starting at\
    \ /tmp/tmpaott9ncu.jl:46\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = ((rows[i], cols[i]))\n    end\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi7neoy5a.jl:42\nin expression starting at\
    \ /tmp/tmpi7neoy5a.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    else\n        lst[findfirst(x->x==x, lst)]\n    end\n\
    end\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpicr48w7_.jl:28\nin expression starting at\
    \ /tmp/tmpicr48w7_.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        return Vector{Tuple{Int64,\
    \ Int64}}()\n    elseif x == 0\n        return Vector{Tuple{Int64, Int64}}(Tuple{0,\
    \ 0})\n    else\n        rows = sort(collect(enumerate(lst)))\n        rows =\
    \ reverse(rows)\n        rows = sort(rows, by=x->x[1])\n        rows = reverse(rows)\n\
    \        return Vector{Tuple{Int64, Int64}}(Tuple{rows[x][1], rows[x][2]})\n \
    \   end\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeuuduhuv.jl:32\nin expression starting at\
    \ /tmp/tmpeuuduhuv.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->x[2])\n    \n    rows = sort(rows, by=x\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb3lkmxxu.jl:85\nin expression starting at\
    \ /tmp/tmpb3lkmxxu.jl:85\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for row in 1:length(lst)\n        rows = rows + 1\n        cols[row] = length(lst[row])\n\
    \    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    coords\
    \ = zeros(Int, length(lst))\n    \n    for row in 1:length(lst)\n        coords[row]\
    \ = ((rows[row], cols[row]), 0)\n    end\n    \n    coords = sort(coords)\n  \
    \  \n    coords = coords[2:end]\n    \n    return coords\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvgzco5tn.jl:46\nin expression starting at\
    \ /tmp/tmpvgzco5tn.jl:46\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = rows[reverse .!=\
    \ rows]\n    cols = cols[reverse .!= cols]\n    \n    rows = row\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpan1lomdx.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpan1lomdx.jl:1\n\
    in expression starting at /tmp/tmpan1lomdx.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = rows[rows .<= cols]\n    cols = cols[cols\
    \ .<= rows]\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n\
    \    \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n    \n    rows\
    \ = rows[rows .<= x]\n    cols = cols[cols .<= x]\n    \n    rows = rows[rows\
    \ .<= x]\n    cols = cols[cols .<= x]\n    \n    rows = rows[rows .<= x]\n   \
    \ cols = cols[cols .<= x]\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols\
    \ .<= x]\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n   \
    \ \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n    \n    rows =\
    \ rows[rows .<= x]\n    cols = cols[cols .<= x]\n    \n    rows = rows[rows .<=\
    \ x]\n    cols = cols[cols .<= x]\n    \n    rows = rows[rows .<= x]\n    cols\
    \ = cols[cols .<= x]\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols\
    \ .<= x]\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n   \
    \ \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n    \n    rows =\
    \ rows[rows .<= x]\n    cols = cols[cols .<= x]\n    \n    rows = rows[rows .<=\
    \ x]\n    cols = cols[cols .<= x]\n    \n    rows = rows[rows .<= x]\n    cols\
    \ = cols[cols .<= x]\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols\
    \ .<= x]\n    \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n   \
    \ \n    rows = rows[rows .<= x]\n    cols = cols[cols .<= x]\n    \n    rows =\
    \ rows[rows .<= x]\n    cols = cols[cols .<= x]\n    \n    rows = rows[rows .<=\
    \ x]\n    cols = cols[cols .<= x]\n    \n    rows = rows[rows .<= x]\n    cols\
    \ = cols[\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt1xuwz5b.jl:1\nin expression starting at /tmp/tmpt1xuwz5b.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows)\n   \
    \ cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n    \n\
    \    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n \
    \   cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n  \
    \  \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = sort(cols)\n \
    \   \n    rows = sort(rows)\n    cols = sort(cols)\n    \n    rows = sort(rows)\n\
    \    cols = sort(cols)\n    \n    rows = sort(rows)\n    cols = \nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprx0gxv20.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmprx0gxv20.jl:1\n\
    in expression starting at /tmp/tmprx0gxv20.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    else\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = sort(lst)\n\
    \        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end], lst[end-1:end])]\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst[end-1:end])]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst[end-1:end])]\n        lst = reverse(lst)\n        lst = sort(lst)\n    \
    \    lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end], lst[end-1:end])]\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst[end-1:end])]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst[end-1:end])]\n        lst = reverse(lst)\n        lst = sort(lst)\n    \
    \    lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end], lst[end-1:end])]\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst[end-1:end])]\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end],\
    \ lst[end-1:end])]\n        lst = reverse(lst)\n        lst = sort(lst)\n    \
    \    lst = reverse(lst)\n        lst = lst[findfirst(x->x==lst[end], lst[end-1:end])]\n\
    \        lst = reverse(lst)\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = lst[findfirst(x->x==lst[end], lst[end-1:end])]\n        lst = reverse(lst)\n\
    \        lst = \nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp1vio2n6z.jl:20\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1vio2n6z.jl:1\n\
    in expression starting at /tmp/tmp1vio2n6z.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=x->-x)\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,j) in zip(rows, cols)\n        coords[i, j]\
    \ = (i,j)\n    end\n    \n    coords = sort(coords, by=x->x[1])\n    coords =\
    \ sort(coords, by=x->x[2])\n    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3wbpqpuz.jl:35\nin expression starting at\
    \ /tmp/tmp3wbpqpuz.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(lst), 2)\n    \n    for i = 1:length(lst)\n \
    \       coords[i] = ((rows[i], cols[i]), i)\n    end\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8wrs8hhz.jl:42\nin expression starting at\
    \ /tmp/tmp8wrs8hhz.jl:42\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(length(rows),\
    \ length(cols))\n    \n    for (i,row) in enumerate(rows)\n        coords[i] =\
    \ [(row, col) for col in cols]\n    end\n    \n    coords = coords[coords[:,1]\
    \ .== x]\n    \n    coords = coords[sortperm(coords[:,2], rev=true)]\n    \n \
    \   return coords\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpmo21hqx3.jl:41\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Vector{Tuple{Int64, Int64}} to an object of
    type Float64\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where
    T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\n    convert(::Type{T},
    !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\n    convert(::Type{T},
    !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\n    ...\n  Stacktrace:\n   [1]
    setindex!(A::Matrix{Float64}, x::Vector{Tuple{Int64, Int64}}, i1::Int64)\n     @
    Base ./array.jl:903\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @
    Main /tmp/tmpmo21hqx3.jl:27\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmo21hqx3.jl:41 [inlined]\n   [5]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmo21hqx3.jl:40\ntest set: Error
    During Test at /tmp/tmpmo21hqx3.jl:42\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Vector{Tuple{Int64,
    Int64}} to an object of type Float64\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::T) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\n    convert(::Type{T},
    !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\n    convert(::Type{T},
    !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/shar'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = sort(rows, by=x->x[1])\n    \n    rows = sort(rows, by=x->-x[1])\n\
    \    \n    rows = sort(rows, by=x->x[2])\n    \n    rows = sort(rows, by=x->-x[2])\n\
    \    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp52n3cigd.jl:33\nin expression starting at\
    \ /tmp/tmp52n3cigd.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.data) == 0 \n   \
    \     return [] \n    \n    rows = sort(collect(1:length(lst)))\n    cols = sort(collect(1:length(lst[rows])),\
    \ by=desc)\n    \n    coords = zeros(length(rows), length(cols))\n    \n    for\
    \ i = 1:length(rows)\n        coords[i, :] = [rows, cols]\n    end\n    \n   \
    \ coords = coords[coords[1, 1] == x, :]\n    \n    return coords\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4p3hviab.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4p3hviab.jl:1\n\
    in expression starting at /tmp/tmp4p3hviab.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if length(lst.ndims) == 1 \n  \
    \      return [] \n    \n    rows = sort(collect(1:length(lst.ndims)))\n    cols\
    \ = sort(collect(1:length(lst.ndims)))\n    \n    rows = sort(rows)\n    cols\
    \ = sort(cols)\n    \n    rows = rows[cols <= x]\n    cols = cols[rows <= x]\n\
    \    \n    rows = rows[rows > x]\n    cols = cols[cols > x]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols =\
    \ cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n\
    \    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows =\
    \ rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n\
    \    cols = cols[cols > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols\
    \ > 0]\n    \n    rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n   \
    \ rows = rows[rows > 0]\n    cols = cols[cols > 0]\n    \n    rows = rows[rows\
    \ > 0]\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxzxmoq9a.jl:1\nin expression starting at /tmp/tmpxzxmoq9a.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(enumerate(lst)))\n\
    \    \n    rows = rows[rows[2] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< rows[2]]\n\
    \    \n    rows = rows[rows[1] .< rows[3]]\n    \n    rows = rows[rows[1] .< \n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq09l6puv.jl:1\nin expression starting at /tmp/tmpq09l6puv.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = ((rows[i], cols[i]), i)\n    end\n    \n    coords = sort(coords)\n\
    \    \n    return coords\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf_ts7ex2.jl:44\nin expression starting at\
    \ /tmp/tmpf_ts7ex2.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 1\n        []\n    else\n        lst = sort(lst)\n        lst = reverse(lst)\n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x, 1)]\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n        \n        lst = lst[findall(lst .== x, 1)]\n        \n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x, 1)]\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n        \n        lst = lst[findall(lst .== x, 1)]\n        \n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x, 1)]\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n        \n        lst = lst[findall(lst .== x, 1)]\n        \n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x, 1)]\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n        \n        lst = lst[findall(lst .== x, 1)]\n        \n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x, 1)]\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n        \n        lst = lst[findall(lst .== x, 1)]\n        \n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x, 1)]\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n        \n        lst = lst[findall(lst .== x, 1)]\n        \n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x, 1)]\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n        \n        lst = lst[findall(lst .== x, 1)]\n        \n\
    \        lst = sort(lst)\n        lst = reverse(lst)\n        \n        lst =\
    \ lst[findall(lst .== x, 1)]\n        \n        lst = sort(lst)\n        lst =\
    \ reverse(lst)\n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpvu2mfc2p.jl:22\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvu2mfc2p.jl:1\n\
    in expression starting at /tmp/tmpvu2mfc2p.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][i]\n        cols = cols\
    \ + lst[i][1:i-1]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n\
    \    \n    rows = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows\
    \ = rows[cols..end]\n    cols = cols[rows..end]\n    \n    rows = rows[cols..end]\n\
    \    cols = cols[rows..end]\n    \n    rows = row\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp__ksag0p.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp__ksag0p.jl:1\n\
    in expression starting at /tmp/tmp__ksag0p.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(length(rows), length(cols))\n    \n    for i = 1:length(rows)\n\
    \        coords[i, :] = [rows, cols]\n    end\n    \n    return coords\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpzilrnx0s.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmpzilrnx0s.jl:47\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: no method\
    \ matching +(::Vector{Int64}, ::Int64)\n  For element-wise addition, use broadcasting\
    \ with dot syntax: array .+ scalar\n  Closest candidates are:\n    +(::Any, ::Any,\
    \ !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n\
    \    +(!Matched::T, ::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128,\
    \ UInt16, UInt32, UInt64, UInt8} at /shared/centos7/julia/1.7.3/share/julia/base/int.jl:87\n\
    \    +(!Matched::T, ::Integer) where T<:AbstractChar at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:237\n\
    \    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpzilrnx0s.jl:27\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzilrnx0s.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzilrnx0s.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpzilrnx0s.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: no method matching +(::Vector{Int64},\
    \ ::Int64)\n  For element-wise addition, use broadcasting with dot syntax: array\
    \ .+ scalar\n  Closest candidates are:\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n    +(!Matched::T,\
    \ ::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32,\
    \ UInt64, UInt8} at /shared/centos7/julia/1.7.3/share/julia/base/int.jl:87\n \
    \   +(!Matched::T, ::Integer) where T<:AbstractChar at /shared/centos7/julia/1.7."
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = zeros(Int, length(lst))\n    cols = zeros(Int, length(lst))\n    \n\
    \    for i = 1:length(lst)\n        rows = rows + lst[i][x]\n        cols = cols\
    \ + lst[i][end]\n    end\n    \n    rows = sort(rows)\n    cols = sort(cols)\n\
    \    \n    coords = zeros(Int, length(lst))\n    \n    for i = 1:length(lst)\n\
    \        coords[i] = Tuple(rows[i], cols[i])\n    end\n    \n    return coords\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnvow066r.jl:42\nin expression starting at\
    \ /tmp/tmpnvow066r.jl:42\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    lst = sort(lst)\n    \n \
    \   rows = Vector{Tuple{Int64, Int64}}()\n    \n    for row in lst\n        \n\
    \        columns = sort(row)\n        \n        if x == columns[1]\n         \
    \   push!(rows, (row[1], row[2]))\n        end\n        \n        if x == columns[2]\n\
    \            push!(rows, (row[2], row[1]))\n        end\n        \n    end\n \
    \   \n    sort(rows)\n    \n    return rows\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7mnlpi5s.jl:43\nin expression starting at\
    \ /tmp/tmp7mnlpi5s.jl:43\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    else\n        lst = sort(lst)\n        lst = sort(lst,\
    \ by=x->-x[1])\n        lst = sort(lst, by=x->-x[2])\n        lst = sort(lst,\
    \ by=x->-x[3])\n        lst = sort(lst, by=x->-x[4])\n        lst = sort(lst,\
    \ by=x->-x[5])\n        lst = sort(lst, by=x->-x[6])\n        lst = sort(lst,\
    \ by=x->-x[7])\n        lst = sort(lst, by=x->-x[8])\n        lst = sort(lst,\
    \ by=x->-x[9])\n        lst = sort(lst, by=x->-x[10])\n        lst = sort(lst,\
    \ by=x->-x[11])\n        lst = sort(lst, by=x->-x[12])\n        lst = sort(lst,\
    \ by=x->-x[13])\n        lst = sort(lst, by=x->-x[14])\n        lst = sort(lst,\
    \ by=x->-x[15])\n        lst = sort(lst, by=x->-x[16])\n        lst = sort(lst,\
    \ by=x->-x[17])\n        lst = sort(lst, by=x->-x[18])\n        lst = sort(lst,\
    \ by=x->-x[19])\n        lst = sort(lst, by=x->-x[20])\n        lst = sort(lst,\
    \ by=x->-x[21])\n        lst = sort(lst, by=x->-x[22])\n        lst = sort(lst,\
    \ by=x->-x[23])\n        lst = sort(lst, by=x->-x[24])\n        lst = sort(lst,\
    \ by=x->-x[25])\n        lst = sort(lst, by=x->-x[26])\n        lst = sort(lst,\
    \ by=x->-x[27])\n        lst = sort(lst, by=x->-x[28])\n        lst = sort(lst,\
    \ by=x->-x[29])\n        lst = sort(lst, by=x->-x[30])\n        lst = sort(lst,\
    \ by=x->-x[31])\n        lst = sort(lst, by=x->-x[32])\n        lst = sort(lst,\
    \ by=x->-x[33])\n        lst = sort(lst, by=x\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgtfz7vbm.jl:60\nin expression starting at\
    \ /tmp/tmpgtfz7vbm.jl:60\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    if lst == []\n        []\n    elseif\
    \ x == 0\n        []\n    else\n        lst[findfirst(x->x==x, lst)]\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr2xkmurl.jl:28\nin expression starting at\
    \ /tmp/tmpr2xkmurl.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    rows = sort(rows, by=x->x[1])\n\
    \    cols = sort(cols, by=x->-x[1])\n    \n    rows = sort(rows, by=x->x[2])\n\
    \    cols = sort(cols, by=x->-x[2])\n    \n    rows = sort(rows, by=x->x[3])\n\
    \    cols = sort(cols, by=x->-x[3])\n    \n    rows = sort(rows, by=x->x[4])\n\
    \    cols = sort(cols, by=x->-x[4])\n    \n    rows = sort(rows, by=x->x[5])\n\
    \    cols = sort(cols, by=x->-x[5])\n    \n    rows = sort(rows, by=x->x[6])\n\
    \    cols = sort(cols, by=x->-x[6])\n    \n    rows = sort(rows, by=x->x[7])\n\
    \    cols = sort(cols, by=x->-x[7])\n    \n    rows = sort(rows, by=x->x[8])\n\
    \    cols = sort(cols, by=x->-x[8])\n    \n    rows = sort(rows, by=x->x[9])\n\
    \    cols = sort(cols, by=x->-x[9])\n    \n    rows = sort(rows, by=x->x[10])\n\
    \    cols = sort(cols, by=x->-x[10])\n    \n    rows = sort(rows, by=x->x[11])\n\
    \    cols = sort(cols, by=x->-x[11])\n    \n    rows = sort(rows, by=x->x[12])\n\
    \    cols = sort(cols, by=x->-x[12])\n    \n    rows = sort(rows, by=x->x[13])\n\
    \    cols = sort(cols, by=x->-x[13])\n    \n    rows = sort(rows, by=x->x[14])\n\
    \    cols = sort(cols, by=x->-x[14])\n    \n    rows = sort(rows, by=x->x[15])\n\
    \    cols = sort(cols, by=x->-x[15])\n    \n    rows = sort(rows, by=x->x[16])\n\
    \    cols = sort(cols, by=x->-x[16])\n    \n    rows = sort(rows, by=x->x[17])\n\
    \    cols = sort(cols, by=x->-x[17])\n    \n    rows = sort(rows, by=x->x[18])\n\
    \    cols = sort(cols, by=x->-x[18])\n    \n    rows = sort(rows, by=x->x[19])\n\
    \    cols = sort(cols, by=x->-x\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1xcokit6.jl:80\nin expression starting at\
    \ /tmp/tmp1xcokit6.jl:80\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[rows])), by=length, reverse=true)\n    \n\
    \    coords = zeros(length(rows), length(cols))\n    \n    for row in rows\n \
    \       for col in cols\n            coords[row, col] = Tuple(row, col)\n    \
    \    end\n    end\n    \n    coords = coords[coords[:,1] .== x, :]\n    \n   \
    \ coords = coords[sortperm(coords[:,2]), :]\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp95dt916h.jl:38\nin expression starting at\
    \ /tmp/tmp95dt916h.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    rows = sort(collect(1:length(lst)))\n\
    \    cols = sort(collect(1:length(lst[1])))\n    \n    coords = zeros(Int, length(rows))\n\
    \    for (i,row) in enumerate(rows)\n        coords[i] = (x == row) ? i : -1\n\
    \    end\n    \n    coords = coords[reverse .! (coords .== -1)]\n    \n    coords\
    \ = coords[reverse .! (coords .== -1)]\n    \n    return coords\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8aygwjo5.jl:35\nin expression starting at\
    \ /tmp/tmp8aygwjo5.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2zpp039w.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2zpp039w.jl:1\n\
    in expression starting at /tmp/tmp2zpp039w.jl:1\n"
  stdout: ''
