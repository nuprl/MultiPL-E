language: jl
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of strings and returns a vector of strings where each string\
    \ is the concatenation of all the strings except the one that comes first in the\
    \ vector. For example, if the vector is [\"a\", \"b\", \"c\", \"d\"] then your\
    \ function should return [\"a\", \"b\", \"c\", \"d\"]. \nExample: \n    >>> my_function([\"\
    a\", \"b\", \"c\", \"d\"])\n    [\"a\", \"b\", \"c\", \"d\"]\n    \"\"\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmqp0kojc.jl:30\nin expression starting at\
    \ /tmp/tmpmqp0kojc.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,ext) in enumerate(extensions)\n        extension_strength[i]\
    \ = count_caps(ext) - count_caps(ext[1:end-1])\n    end\n    \n    idx = findfirst(x\
    \ -> x > 0, extension_strength)\n    if idx != nothing\n        idx = idx[1]\n\
    \    else\n        idx = length(extensions)\n    end\n    \n    return class_name+\"\
    .\"+extensions[idx]\nend\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a string and returns a string where all vowels are replaced by 'e's.\nExample:\
    \ \n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"\
    hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>>\
    \ vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\"\
    )\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"\
    hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>>\
    \ vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\"\
    )\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"\
    hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>>\
    \ vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\"\
    )\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"\
    hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>>\
    \ vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\"\
    )\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"\
    hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>>\
    \ vowel_replacement(\"hello\")\n\"heeelllloo\"\n>>> vowel_replacement(\"hello\"\
    )\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsj2tpvit.jl:34\nin expression starting at\
    \ /tmp/tmpsj2tpvit.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i]) - length(replace(extensions[i], uppercase(extensions[i]),\
    \ \"\"))\n    end\n    \n    idx = findfirst(extension_strength == maximum(extension_strength))\n\
    \    \n    if idx != nothing\n        return class_name+\".\"+extensions[idx]\n\
    \    else\n        return class_name\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.CC\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.EE\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.MM\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg85dn5je.jl:33\nin expression starting at\
    \ /tmp/tmpg85dn5je.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5q_ih7je.jl:30\nin expression starting at\
    \ /tmp/tmp5q_ih7je.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    \n    for extension in extensions\n        extension_strength[findall(extension\
    \ == class_name)] = length(extension) - length(findall(extension == class_name))\n\
    \    end\n    \n    sorted_extension_strength = sort(extension_strength)\n   \
    \ \n    Strongest_Extension = extensions[find(sorted_extension_strength == maximum(sorted_extension_strength))]\n\
    \    \n    return Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that returns the number of extensions\
    \ loaded for a given class name.\nThe function should take as input a class name\
    \ and a vector of extensions and return an integer\nindicating the number of extensions\
    \ loaded for the class.\nThe function should return 0 if the class name is not\
    \ in the vector or if the vector is empty.\nThe function should return -1 if the\
    \ class name is not in the vector or if the vector is empty.\nExample:\n>>> Num_Extensions(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n2\n>>> Num_Extensions(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\"])\n-1\n>>> Num_Extensions(\"my_class\", [])\n0\n\
    >>> Num_Extensions(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"])\n-1\n\
    >>> Num_Extensions(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"\
    ])\n0\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwl6shv_g.jl:32\nin expression starting at\
    \ /tmp/tmpwl6shv_g.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5q_ih7je.jl:30\nin expression starting at\
    \ /tmp/tmp5q_ih7je.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = Dict{String,\
    \ Int}()\n    \n    for extension in extensions\n        extension_strength[extension]\
    \ = length(extension) - length(replace(extension, uppercase(extension), \"\"))\n\
    \    end\n    \n    sorted_extensions = sort(collect(extension_strength.values),\
    \ by=x->x)\n    \n    Strongest_Extension = extensions[sorted_extensions[1]]\n\
    \    \n    return Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.CC\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.EE\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.MM\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphd3szz5t.jl:32\nin expression starting at\
    \ /tmp/tmphd3szz5t.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = -1 \n    \n    for extension in extensions_sorted\n    \
    \    \n        extension_upper = uppercase(extension)\n        extension_lower\
    \ = lowercase(extension)\n        \n        if extension_upper == extension_lower\n\
    \            strength = strength + 1 \n        elseif extension_upper == extension_lower[1:length(extension_lower)]\n\
    \            strength = strength + 2 \n        elseif extension_upper == extension_lower[1:length(extension_lower)-1]\n\
    \            strength = strength + 3 \n        elseif extension_upper == extension_lower[2:length(extension_lower)]\n\
    \            strength = strength + 4 \n        elseif extension_upper == extension_lower[2:length(extension_lower)-1]\n\
    \            strength = strength + 5 \n        elseif extension_upper == extension_lower[3:length(extension_lower)]\n\
    \            strength = strength + 6 \n        elseif extension_upper == extension_lower[3:length(extension_lower)-1]\n\
    \            strength = strength + 7 \n        elseif extension_upper == extension_lower[4:length(extension_lower)]\n\
    \            strength = strength + 8 \n        elseif extension_upper == extension_lower[4:length(extension_lower)-1]\n\
    \            strength = strength + 9 \n        elseif extension_upper == extension_lower[5:length(extension_lower)]\n\
    \            strength = strength + 10 \n        elseif extension_upper == extension_lower[5:length(extension_lower)-1]\n\
    \            strength = strength + 11 \n        elseif extension_upper == extension_lower[6:length(extension_lower)]\n\
    \            strength = strength + 12 \n        elseif extension_upper == extension_lower[6:length(extension_lower)-1]\n\
    \            strength = strength + 13 \n        elseif extension_upper == extension_lower[7:length(extension_lower)]\n\
    \            strength = strength + 14 \n        elseif extension_upper == extension_lower[7:length(extension_lower)-1]\n\
    \            strength = strength + 15 \n        elseif extension_upper == extension_lower[8:length(extension_lower)]\n\
    \            strength = strength + 16 \n        elseif extension_upper == extension_lower[8:length(extension_lower)-1]\n\
    \            strength = strength + 17 \n        elseif extension_upper == extension_lower[9:length(extension_lower)]\n\
    \            strength = strength + 18 \n        elseif extension_upper == extension_lower[9:length(extension_lower)-1]\n\
    \            strength = strength + 19 \n        elseif extension_upper == extension_\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsk1cim4_.jl:1\nin expression starting at /tmp/tmpsk1cim4_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = Dict{String,\
    \ Int}()\n    for extension in extensions \n        extension_strength[extension]\
    \ = length(extension) - length(replace(extension, uppercase(extension), \"\"))\n\
    \    end\n    \n    sorted_extensions = sort(collect(extension_strength.values))\n\
    \    \n    sorted_extensions[end]\nend\n</cell>\n<code language=julia-1.5>\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.CC\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) ==\
    \ \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.CC\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.CC\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"\nusing Test\n\n@testset begin\n\ncandidate =\
    \ Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7pqrd1zs.jl:29\nin expression starting at\
    \ /tmp/tmp7pqrd1zs.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ * \".\" . extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that takes a string and a vector\
    \ of strings as arguments and returns the string with the extensions replaced\
    \ by their respective classes.\nFor example, if the string is 'my_class' and the\
    \ vector is ['AA', 'Be', 'CC'] then you should return 'my_class.AA'.\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"\".\" .\"\
    \ at /tmp/tmphkaix6xr.jl:27\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphkaix6xr.jl:27\n\
    in expression starting at /tmp/tmphkaix6xr.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = -1 # default strength\n    \n    for extension in extensions\n\
    \        \n        extension = extension.trim()\n        \n        if extension\
    \ == \"\"\n            continue\n            \n        cap = length(extension)\
    \ - length(replace(extension, uppercase(extension), \"\"))\n        sm = length(extension)\
    \ - length(replace(extension, lowercase(extension), \"\"))\n        \n       \
    \ if cap > sm\n            strength = cap - sm\n        else\n            strength\
    \ = sm - cap\n        end\n        \n        if strength > 0\n            break\n\
    \        end\n    end\n    \n    return class_name * \".\" .* extensions[end]\n\
    end\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) \u2248 \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) \u2248 \"my_class.DD\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\"]) \u2248 \"my_class.EE\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) \u2248 \"my_class.FF\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\", \"HH\"]) \u2248 \"my_class.GG\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\"]) \u2248 \"my_class.HH\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) \u2248\
    \ \"my_class.II\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) \u2248\
    \ \"my_class.JJ\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"])\
    \ \u2248 \"my_class.KK\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy187xyr4.jl:47\nin expression starting at\
    \ /tmp/tmpy187xyr4.jl:47\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes a string and returns a string with the first letter\
    \ capitalized.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk9vgmbdt.jl:30\nin expression starting at\
    \ /tmp/tmpk9vgmbdt.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,extension) in enumerate(extensions)\n      \
    \  extension_strength[i] = length(extension) - length(lowercase(extension))\n\
    \    end\n    \n    Strongest_Extension = extensions[argmax(extension_strength)]\n\
    \    \n    return Strongest_Extension\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkgqzzitv.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmpkgqzzitv.jl:34\n  Expression: candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\n   Evaluated:\
    \ \"tEN\" == \"Watashi.eIGHt8OKe\"\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkgqzzitv.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkgqzzitv.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpkgqzzitv.jl:35\n  Expression: candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\n   Evaluated:\
    \ \"nani\" == \"Boku123.YEs.WeCaNe\"\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkgqzzitv.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkgqzzitv.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpkgqzzitv.jl:36\n  Expression: candidate(\"__YESIMHERE\", [\"\
    t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"\
    __YESIMHERE.NuLl__\"\n   Evaluated: \"t\" == \"__YESIMHERE.NuLl__\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkgqzzitv.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkgqzzitv.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpkgqzzitv.jl:37\n  Expression: candidate(\"K\", [\"Ta\", \"\
    TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\n   Evaluated: \"Ta\" == \"K.TAR\"\
    \nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkgqzzitv.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    \n    for e in extensions\n        \n        extension_strength[findall(e\
    \ == extensions)] .+= 1\n    end\n    \n    extension_strength = sort(extension_strength)\n\
    \    \n    if length(extension_strength) == 1\n        return class_name\n   \
    \ end\n    \n    extension_strength = extension_strength[end]\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n    end\n\
    \    \n    extension_strength = extension_strength - 1\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n    end\n\
    \    \n    extension_strength = extension_strength - 1\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n    end\n\
    \    \n    extension_strength = extension_strength - 1\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n    end\n\
    \    \n    extension_strength = extension_strength - 1\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n    end\n\
    \    \n    extension_strength = extension_strength - 1\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n    end\n\
    \    \n    extension_strength = extension_strength - 1\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n    end\n\
    \    \n    extension_strength = extension_strength - 1\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n    end\n\
    \    \n    extension_strength = extension_strength - 1\n    \n    if extension_strength\
    \ == 1\n        return class_name\n    end\n    \n    extension_strength = extension_strength\
    \ - 1\n    \n    if extension_strength == 1\n        return class_name\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe84zdat6.jl:1\nin expression starting at /tmp/tmpe84zdat6.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes a string and returns the number of uppercase letters\
    \ in it.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5y9lqr66.jl:30\nin expression starting at\
    \ /tmp/tmp5y9lqr66.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ -1\n        return class_name\n    else\n        return class_name .. \".\"\
    \ .. extensions[strength]\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@assert\
    \ Strongest_Extension\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjbykan5s.jl:30\nin expression starting at\
    \ /tmp/tmpjbykan5s.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmppsb47md8.jl:24\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppsb47md8.jl:1\n\
    in expression starting at /tmp/tmppsb47md8.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    \n    for i=1:length(extensions)\n        extension_strength[i] = length(extensions[i])\
    \ - length(lowercase(extensions[i]))\n    end\n    \n    idx = findfirst(extension_strength\
    \ == maximum(extension_strength))\n    \n    if idx == nothing\n        return\
    \ class_name\n    else\n        return string(class_name, extensions[idx])\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.II\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.KK\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.LL\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.MM\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7c6wlqga.jl:34\nin expression starting at\
    \ /tmp/tmp7c6wlqga.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5q_ih7je.jl:30\nin expression starting at\
    \ /tmp/tmp5q_ih7je.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5q_ih7je.jl:30\nin expression starting at\
    \ /tmp/tmp5q_ih7je.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name + \".\" + extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a string and a vector of strings as arguments and returns the string\
    \ with the first letter of each word capitalized.\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpglrr4fmx.jl:30\nin expression starting at\
    \ /tmp/tmpglrr4fmx.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 2\nWrite a function that takes a string and a vector\
    \ of strings as arguments and returns a string with the string repeated n times.\
    \ \nFor example, if the string \"hello\" is passed as an argument and the vector\
    \ [\"hello\", \"world\", \"!\"] is passed as an argument, the function should\
    \ return \"hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohello\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiukynsps.jl:30\nin expression starting at\
    \ /tmp/tmpiukynsps.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes as input a vector of extensions and a vector of classes and returns\
    \ a vector of strings. \nThe strings should be in the format: ClassName.StrongestExtensionName.\n\
    For example, if you are given the following vectors:\nextensions = [\"SErviNGSliCes\"\
    , \"Cheese\", \"StuFfed\"]\nclasses = [\"Slice\", \"Pizza\", \"Ham\"]\nthen you\
    \ should return a vector of the following strings:\n[\"Slices.SErviNGSliCes\"\
    , \"Slices.Cheese\", \"Slices.StuFfed\", \"Pizza.Ham\"]\nHint: Use Strongest_Extension\
    \ to find the strongest extension.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp660pw096.jl:30\nin expression starting at\
    \ /tmp/tmp660pw096.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    \n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extension_strength[i]) \n    end\n    \n    extension_strength = sort(extension_strength,\
    \ by = length) \n    \n    Strongest_Extension = extensions[extension_strength[1]]\n\
    \    \n    for i = 2:length(extension_strength)\n        if extension_strength[i]\
    \ > extension_strength[i-1]\n            Strongest_Extension = extensions[extension_strength[i]]\n\
    \            break\n        end\n    end\n    \n    return Strongest_Extension\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp853iah49.jl:39\nin expression starting at\
    \ /tmp/tmp853iah49.jl:39\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[0]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ + \".\" + extensions_sorted[strength]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.CC\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.EE\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.MM\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.NN\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaoskinc5.jl:30\nin expression starting at\
    \ /tmp/tmpaoskinc5.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[0]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ * \".\" + extensions_sorted[strength]\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    @time Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a string and a vector of strings and returns\
    \ a string with the \nextensions replaced by the strings in the vector. \nFor\
    \ example, if the string is 'my_class' and the vector is ['AA', 'Be', 'CC'] then\
    \ \nthe function should return 'my_class.AA', 'my_class.Be', 'my_class.CC'.\n\
    The function should return an empty string if the string does not have any extensions.\n\
    The function should also work for strings with multiple extensions.\nFor example,\
    \ if the string is 'my_class' and the vector is ['AA', 'Be', 'CC', 'DD'] then\
    \ \nthe function should return 'my_class.AA', 'my_class.Be', 'my_class.CC', 'my_class.DD'.\n\
    The function should return an empty string if the string does not have any extensions.\n\
    The function should also work for strings with multiple extensions.\nFor example,\
    \ if the string is 'my_class' and the vector is ['AA', 'Be', 'CC', 'DD', 'EE']\
    \ then \nthe function should return 'my_class.AA', 'my_class.Be', 'my_class.CC',\
    \ 'my_class.DD', 'my_class.EE'.\nThe function should return an empty string if\
    \ the string does not have any extensions.\nThe function should also work for\
    \ strings with multiple extensions.\nFor example, if the string is 'my_class'\
    \ and the vector is ['AA', 'Be', 'CC', 'DD', 'EE', 'FF'] then \nthe function should\
    \ return 'my_class.AA', 'my_class.Be', 'my_class.CC', 'my_class.DD', 'my_class.EE',\
    \ 'my_class.FF'.\nThe function should return an empty string if the string does\
    \ not have any extensions.\nThe function should also work for strings with multiple\
    \ extensions.\nFor example, if the string is 'my_class' and the vector is ['AA',\
    \ 'Be', 'CC', 'DD', 'EE', 'FF', 'GG'] then \nthe function should return 'my_class.AA',\
    \ 'my_class.Be', 'my_class.CC', 'my_class.DD', 'my_class.EE', 'my_class.FF', 'my_class.GG'.\n\
    The function should return an empty string if the string does not have any extensions.\n\
    The function should also work for strings with multiple extensions.\nFor example,\
    \ if the string is 'my_class' and the vector is ['AA', 'Be', 'CC', 'DD', 'EE',\
    \ 'FF', 'GG', 'HH'] then \nthe function should return 'my_class.AA', 'my_class.Be',\
    \ 'my_class.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4zw9myiy.jl:30\nin expression starting at\
    \ /tmp/tmp4zw9myiy.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ 0 \n        return class_name\n    else\n        return class_name .. \".\"\
    \ .. extensions[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a string and returns a string with the first\
    \ letter capitalized.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf9o9kxwo.jl:30\nin expression starting at\
    \ /tmp/tmpf9o9kxwo.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    \n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i])-length(replace(extensions[i], uppercase(extensions[i]),\
    \ \"\"))\n    end\n    \n    idx = findfirst(extension_strength == maximum(extension_strength))\n\
    \    \n    if idx == -1\n        return class_name\n    else\n        return class_name+\"\
    .\"+extensions[idx]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.EE\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"])\
    \ == \"my_class.GG\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.HH\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.II\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\"]) == \"my_class.JJ\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\"]) == \"my_class.KK\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.LL\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.MM\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\nusing Test\n\n@testset begin\n\ncandidate =\
    \ Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp63wpzxdj.jl:34\nin expression starting at\
    \ /tmp/tmp63wpzxdj.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extension_strength[i]) + length(extension_strength[upper(extensions[i])])\
    \ - length(extension_strength[lower(extensions[i])])\n    end\n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpq88dlqq_.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpq88dlqq_.jl:1\n\
    in expression starting at /tmp/tmpq88dlqq_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector of strings\
    \ and returns a vector of strings where each string is a concatenation of all\
    \ the strings in the original vector except the string that comes first in the\
    \ vector. For example, if the vector is [\"a\", \"b\", \"c\", \"d\"] then your\
    \ function should return a vector [\"a\", \"b\", \"c\", \"d\"]. \nThe function\
    \ should work for any number of strings in the vector. \nThe function should work\
    \ for vectors of any length. \nThe function should work for vectors of strings\
    \ of any length. \nThe function should work for vectors of strings of any length.\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprm87ksv4.jl:30\nin expression starting at\
    \ /tmp/tmprm87ksv4.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,e) in enumerate(extensions)\n        extension_strength[i]\
    \ = count_letters(e) - count_letters(lowercase(e))\n    end\n    \n    idx = findfirst(x\
    \ -> x > 0, extension_strength)\n    if idx != nothing\n        idx = idx[1]\n\
    \    else\n        idx = length(extensions)\n    end\n    \n    return lowercase(class_name)\
    \ + extensions[idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpw2vf3blj.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmpw2vf3blj.jl:39\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  UndefVarError: count_letters not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpw2vf3blj.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw2vf3blj.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw2vf3blj.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpw2vf3blj.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  UndefVarError: count_letters not defined\n  Stacktrace:\n\
    \   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpw2vf3blj.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw2vf3blj.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw2vf3blj.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpw2vf3blj.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  UndefVarError: count_letters\
    \ not defined\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpw2vf3blj.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw2vf3blj.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level sco"
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    for e in extensions\n        extension_strength[findall(e == extensions)[1]]\
    \ = \n            length(findall(e == extensions)[1]) / length(extensions)\n \
    \   end\n    \n    Strongest_Extension = extensions[argmax(extension_strength)]\n\
    \    \n    return Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @time Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that will load a class from a string and a list of\
    \ extensions. \nThe function should return the loaded class. \nThe function should\
    \ raise an error if the class is not found. \nThe function should raise an error\
    \ if the extensions are not found. \nThe function should raise an error if the\
    \ extensions are not of the correct \nlength. \nThe function should raise an error\
    \ if the extensions are not of the correct \ntype. \nThe function should raise\
    \ an error if the extensions are not of the correct \ntype. \nThe function should\
    \ raise an error if the extensions are not of the correct \ntype. \nThe function\
    \ should raise an error if the extensions are not of the correct \ntype. \nThe\
    \ function should raise an error if the extensions are not of the correct \ntype.\
    \ \nThe function should raise an error if the extensions are not of the correct\
    \ \ntype. \nThe function should raise an error if the extensions are not of the\
    \ correct \ntype. \nThe function should raise an error if the extensions are not\
    \ of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype. \nThe function should raise an error if the extensions\
    \ are not of the correct \ntype\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdenqqir7.jl:30\nin expression starting at\
    \ /tmp/tmpdenqqir7.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = -1 \n    \n    for extension in extensions_sorted \n   \
    \     \n        if isupper(extension) \n            \n            strength = strength\
    \ + length(extension) - length(extension.upper())\n            \n        else\
    \ \n            \n            strength = strength + length(extension) - length(extension.lower())\n\
    \            \n    end\n    \n    if strength == -1 \n        \n        error(\"\
    No extension has the strongest strength\")\n        \n    else \n        \n  \
    \      return class_name * \".\" .* extensions_sorted[end]\n        \n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) \u2248 \"my_class.DD\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) \u2248 \"my_class.EE\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\"]) \u2248 \"my_class.FF\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) \u2248 \"my_class.GG\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\", \"HH\"]) \u2248 \"my_class.HH\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\"]) \u2248 \"my_class.II\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) \u2248\
    \ \"my_class.JJ\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) \u2248\
    \ \"my_class.KK\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"])\
    \ \u2248 \"my_class.LL\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3oe5o3hj.jl:46\nin expression starting at\
    \ /tmp/tmp3oe5o3hj.jl:46\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,extension) in enumerate(extensions)\n      \
    \  extension_strength[i] = count_letters(extension) - count_letters(class_name[i])\n\
    \    end\n    \n    idx = findall(extension_strength == maximum(extension_strength))\n\
    \    \n    if length(idx) > 0\n        return class_name[idx[1]] + \".\" + extensions[idx[1]]\n\
    \    else\n        return class_name\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a string and a vector of strings and returns\
    \ the string with the \nlongest extension. \nFor example, if you are given \"\
    my_class\" as the class and a vector of the extensions:\n[\"AA\", \"Be\", \"CC\"\
    ] then you should return \"my_class.AA\".\nIf there are two or more extensions\
    \ with the same strength, you should choose the one that comes first in the vector.\n\
    For example, if you are given \"my_class\" as the class and a vector of the extensions:\n\
    [\"AA\", \"Be\", \"CC\", \"DD\"] then you should return \"my_class.AA\".\nIf there\
    \ are two or more extensions with the same strength, you should choose the one\
    \ that comes first in the vector.\nFor example, if you are given \"my_class\"\
    \ as the class and a vector of the extensions:\n[\"AA\", \"Be\", \"CC\", \"DD\"\
    , \"EE\"] then you should return \"my_class.AA\".\nIf there are two or more extensions\
    \ with the same strength, you should choose the one that comes first in the vector.\n\
    For example, if you are given \"my_class\" as the class and a vector of the extensions:\n\
    [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"] then you should return \"my_class.AA\"\
    .\nIf there are two or more extensions with the same strength, you should choose\
    \ the one that comes first in the vector.\nFor example, if you are given \"my_class\"\
    \ as the class and a vector of the extensions:\n[\"AA\", \"Be\", \"CC\", \"DD\"\
    , \"EE\", \"FF\", \"GG\"] then you should return \"my_class.AA\".\nIf there are\
    \ two or more extensions with the same strength, you should choose the one that\
    \ comes first in the vector.\nFor example, if you are given \"my_class\" as the\
    \ class and a vector of the extensions:\n[\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\", \"HH\"] then you should return \"my_class.AA\".\nIf there are\
    \ two or more extensions with the same strength, you should choose the one that\
    \ comes first in the vector.\nFor example, if you are given \"my_class\" as the\
    \ class and a vector of the extensions:\n[\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\", \"HH\", \"II\"] then you should return \"my_class.\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdhrt50cl.jl:33\nin expression starting at\
    \ /tmp/tmpdhrt50cl.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extension_strength[i]) \n    end\n    \n    extension_strength = sort(extension_strength)\n\
    \    \n    Strongest_Extension = extensions[extension_strength[1]]\n    \n   \
    \ for i = 2:length(extension_strength)\n        if extension_strength[i] > extension_strength[i-1]\n\
    \            Strongest_Extension = extensions[extension_strength[i]]\n       \
    \     break\n        end\n    end\n    \n    return Strongest_Extension\nend\n\
    </cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a vector of strings and a vector of integers and returns\
    \ a vector of strings.\nThe function should return the same vector but with the\
    \ strings replaced by the corresponding integers.\nFor example, if the input vector\
    \ is [\"a\", \"b\", \"c\"] and the integer vector is [10, 20, 30], then the output\
    \ vector should be [\"10\", \"20\", \"30\"].\nThe function should work for any\
    \ number of strings.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm6mupwcn.jl:38\nin expression starting at\
    \ /tmp/tmpm6mupwcn.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i=1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i])-length(replace(extensions[i], uppercase(extensions[i]),\
    \ \"\"))\n    end\n    \n    index_of_max_strength = argmax(extension_strength)\n\
    \    \n    return class_name+\".\"+extensions[index_of_max_strength]\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.II\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.KK\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.LL\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.MM\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcm101ppk.jl:29\nin expression starting at\
    \ /tmp/tmpcm101ppk.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ 0\n        return class_name\n    else\n        return class_name * \".\" +\
    \ extensions[1]\n    end\nend\n</cell>\n<code language=julia-1.0>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a string and returns a string where all uppercase\
    \ letters are replaced by \nlowercase letters and all lowercase letters are replaced\
    \ by uppercase letters.\nExample: \n>>> replace_case(\"hello\")\n\"hELLO\"\n>>>\
    \ replace_case(\"HELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\n\
    >>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case(\"HellO\")\n\"hELLO\"\
    \n>>> replace_case(\"hELLO\")\n\"hELLO\"\n>>> replace_case\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7myg2101.jl:30\nin expression starting at\
    \ /tmp/tmp7myg2101.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    for i = 1:length(extensions)\n        extension_strength[i] = length(extension_strength)\
    \ - length(findall(extension_strength, extensions[i])) \n    end\n    \n    idx\
    \ = findfirst(extension_strength == maximum(extension_strength), extension_strength)\n\
    \    if idx == nothing\n        return class_name\n    end\n    \n    return class_name..\"\
    .\"..extensions[idx]\nend\n</cell>\n<code language=julia-1.5>\n@time begin\n \
    \   Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes a string and returns a string\
    \ where all vowels \nare replaced by \"o\" and all consonants are replaced by\
    \ \"i\".\nExample: \n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n>>> vowel_consonant(\"hello\")\n\"hoilo\"\n>>> vowel_consonant(\"\
    hello\")\n\"hoilo\"\n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpesj9xrtt.jl:32\nin expression starting at\
    \ /tmp/tmpesj9xrtt.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,extension) in enumerate(extensions)\n      \
    \  extension_strength[i] = length(extension) - length(lowercase(extension))\n\
    \    end\n    \n    Strongest_Extension = extensions[argmax(extension_strength)]\n\
    \    \n    return Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @time Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a string and returns a string with the\
    \ first letter capitalized.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplqd5muhv.jl:29\nin expression starting at\
    \ /tmp/tmplqd5muhv.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i]) - length(lowercase(extensions[i]))\n    end\n    \n\
    \    idx = findfirst(extension_strength == maximum(extension_strength))\n    \n\
    \    if idx == -1\n        return class_name\n    else\n        return class_name\
    \ * \".\" + extensions[idx]\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a string and returns a string with the first letter capitalized.\
    \ \nExample: \n>>> capitalize(\"my_string\")\n\"MyString\"\n>>> capitalize(\"\
    my_string2\")\n\"MyString2\"\n>>> capitalize(\"my_string3\")\n\"MyString3\"\n\
    >>> capitalize(\"my_string4\")\n\"MyString4\"\n>>> capitalize(\"my_string5\")\n\
    \"MyString5\"\n>>> capitalize(\"my_string6\")\n\"MyString6\"\n>>> capitalize(\"\
    my_string7\")\n\"MyString7\"\n>>> capitalize(\"my_string8\")\n\"MyString8\"\n\
    >>> capitalize(\"my_string9\")\n\"MyString9\"\n>>> capitalize(\"my_string10\"\
    )\n\"MyString10\"\n>>> capitalize(\"my_string11\")\n\"MyString11\"\n>>> capitalize(\"\
    my_string12\")\n\"MyString12\"\n>>> capitalize(\"my_string13\")\n\"MyString13\"\
    \n>>> capitalize(\"my_string14\")\n\"MyString14\"\n>>> capitalize(\"my_string15\"\
    )\n\"MyString15\"\n>>> capitalize(\"my_string16\")\n\"MyString16\"\n>>> capitalize(\"\
    my_string17\")\n\"MyString17\"\n>>> capitalize(\"my_string18\")\n\"MyString18\"\
    \n>>> capitalize(\"my_string19\")\n\"MyString19\"\n>>> capitalize(\"my_string20\"\
    )\n\"MyString20\"\n>>> capitalize(\"my_string21\")\n\"MyString21\"\n>>> capitalize(\"\
    my_string22\")\n\"MyString22\"\n>>> capitalize(\"my_string23\")\n\"MyString23\"\
    \n>>> capitalize(\"my_string24\")\n\"MyString24\"\n>>> capitalize(\"my_string25\"\
    )\n\"MyString25\"\n>>> capitalize(\"my_string26\")\n\"MyString26\"\n>>> capitalize(\"\
    my_string27\")\n\"MyString27\"\n>>> capitalize(\"my_string28\")\n\"MyString28\"\
    \n>>> capitalize(\"my_string29\")\n\"MyString29\"\n>>> capitalize(\"my_string30\"\
    )\n\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnklmbri8.jl:33\nin expression starting at\
    \ /tmp/tmpnklmbri8.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    \n    for (i,e) in enumerate(extensions)\n        extension_strength[i]\
    \ = count_letters(e) - count_letters(lowercase(e))\n    end\n    \n    idx = findfirst(extension_strength\
    \ == maximum(extension_strength))\n    \n    if idx != nothing\n        return\
    \ class_name+\".\"+extensions[idx]\n    else\n        return class_name\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@time begin\n    Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a string and returns a string with the first letter of\
    \ each word capitalized.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2ibzql68.jl:34\nin expression starting at\
    \ /tmp/tmp2ibzql68.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = Dict{String,\
    \ Int}()\n    for extension in extensions\n        extension_strength[extension]\
    \ = length(extension) - length(replace(extension, uppercase(extension), \"\"))\n\
    \    end\n    \n    sorted_extensions = sort(collect(extension_strength.values))\n\
    \    \n    Strongest_Extension = extensions[sorted_extensions[1]]\n    \n    return\
    \ Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a string and a vector of strings and returns\
    \ a vector of strings. \nThe function should return the same vector if all the\
    \ strings in the vector are in the string. \nThe function should return an empty\
    \ vector if all the strings in the vector are not in the string. \nThe function\
    \ should return an empty vector if the string is not in the vector.\nExample:\n\
    >>> Vector_of_Strings(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n[\"my_class.AA\"\
    , \"my_class.Be\", \"my_class.CC\"]\n>>> Vector_of_Strings(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\"])\n[]\n>>> Vector_of_Strings(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"DD\", \"EE\"])\n[]\n>>> Vector_of_Strings(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"])\n[\"my_class.AA\", \"my_class.Be\"\
    , \"my_class.CC\", \"my_class.DD\", \"my_class.EE\", \"my_class.FF\"]\n\"\"\"\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdolfgnkl.jl:31\nin expression starting at\
    \ /tmp/tmpdolfgnkl.jl:31\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = -1 \n    \n    for extension in extensions_sorted\n    \
    \    \n        if isupper(extension)\n            \n            strength = strength\
    \ + length(extension) - length(extension.upper())\n            \n        elseif\
    \ islower(extension)\n            \n            strength = strength + length(extension)\
    \ - length(extension.lower())\n            \n        end\n        \n    end\n\
    \    \n    if strength > 0\n        \n        return class_name * \".\" . extensions_sorted[end]\n\
    \        \n    else\n        \n        return class_name\n        \n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@time Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes a string and a vector of strings as inputs and returns a string with the\
    \ first string in the vector concatenated with the second string. \nFor example,\
    \ if the input string is \"my_class\" and the input vector is [\"AA\", \"Be\"\
    , \"CC\"] then you should return \"my_class.AA\".\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"\".\" .\"\
    \ at /tmp/tmpuzqc6khi.jl:40\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpuzqc6khi.jl:40\n\
    in expression starting at /tmp/tmpuzqc6khi.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that takes a string and returns\
    \ a string with the first letter capitalized.\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_9z05q19.jl:30\nin expression starting at\
    \ /tmp/tmp_9z05q19.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<text>\nExercise 4\n\
    Write a function that takes a string and returns a string where all vowels are\
    \ replaced by \"y\".\nExample: \n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"\
    hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\"\
    )\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"\
    yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\
    \n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>>\
    \ vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"\
    hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\"\
    )\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"\
    yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\
    \n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>>\
    \ vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"\
    hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\"\
    )\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"\
    yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\n>>> vowel_y(\"hello\")\n\"yellhy\"\
    \n>>> vowel_y(\"hello\")\n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl11imqw0.jl:30\nin expression starting at\
    \ /tmp/tmpl11imqw0.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .+ Strongest_Extension(extensions_sorted[1], extensions_sorted[2:end])\n   \
    \ end\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.AED\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.AEDFF\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.AEDFFGG\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.AEDFFGGHH\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\"]) == \"my_class.AEDFFGGHHII\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"])\
    \ == \"my_class.AEDFFGGHHIIJJ\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    ]) == \"my_class.AEDFFGGHHIIJJKK\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\", \"LL\"]) == \"my_class.AEDFFGGHHIIJJKKLL\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.AEDFFGGHHIIJJKKLLMM\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwj2a84fu.jl:30\nin expression starting at\
    \ /tmp/tmpwj2a84fu.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,ext) in enumerate(extensions)\n        extension_strength[i]\
    \ = length(ext) - length(lowercase(ext))\n    end\n    \n    idx = findfirst(x\
    \ -> x > 0, extension_strength)\n    if idx != nothing\n        idx = idx[1]\n\
    \    else\n        idx = length(extensions)\n    end\n    \n    return class_name\
    \ * \".\" .* extensions[idx]\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.AA\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) \u2248 \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) \u2248 \"my_class.DD\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\"]) \u2248 \"my_class.EE\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) \u2248 \"my_class.FF\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\", \"HH\"]) \u2248 \"my_class.GG\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\"]) \u2248 \"my_class.HH\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) \u2248\
    \ \"my_class.II\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) \u2248\
    \ \"my_class.JJ\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"])\
    \ \u2248 \"my_class.KK\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\",\
    \ \"LL\", \"MM\"]) \u2248 \"my_class.LL\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt28oe81i.jl:34\nin expression starting at\
    \ /tmp/tmpt28oe81i.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[0]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name * \".\" + extensions_sorted[strength_of_extension]\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.II\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.KK\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.LL\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.MM\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"\
    , \"MM\", \"NN\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq025myy8.jl:30\nin expression starting at\
    \ /tmp/tmpq025myy8.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i=1:length(extensions)\n        extension_strength[i]\
    \ = count_letters(extensions[i]) - count_letters(extensions[i-1])\n    end\n \
    \   \n    extension_strength = sort(extension_strength)\n    \n    Strongest_Extension\
    \ = extensions[end]\n    \n    for i=length(extensions)-1:-1:1\n        if extension_strength[i]\
    \ == extension_strength[i-1]\n            Strongest_Extension = extensions[i]\n\
    \            break\n        end\n    end\n    \n    return Strongest_Extension\n\
    end\n</cell>\n<code language=julia-1.0>\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 3\n\
    Write a function that takes a string and returns the number of uppercase letters\
    \ in the string.\nExample: \n    >>> count_letters(\"my_class\")\n    2\n    \"\
    \"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpousjfkab.jl:38\nin expression starting at\
    \ /tmp/tmpousjfkab.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[end]-extensions[end]\n    \n    if strength ==\
    \ 0 \n        \n        return class_name\n    \n    else \n        \n       \
    \ idx = 1\n        \n        while idx < length(extensions)\n            \n  \
    \          if extensions[idx] == class_name\n                \n              \
    \  idx = idx+1\n                \n            elseif extensions[idx] == class_name\n\
    \                \n                idx = idx+1\n                \n           \
    \ elseif extensions[idx] > class_name\n                \n                idx =\
    \ idx+1\n                \n            elseif extensions[idx] < class_name\n \
    \               \n                idx = idx+1\n                \n            elseif\
    \ extensions[idx] == class_name\n                \n                idx = idx+1\n\
    \                \n            elseif extensions[idx] > class_name\n         \
    \       \n                idx = idx+1\n                \n            elseif extensions[idx]\
    \ < class_name\n                \n                idx = idx+1\n              \
    \  \n            elseif extensions[idx] == class_name\n                \n    \
    \            idx = idx+1\n                \n            elseif extensions[idx]\
    \ > class_name\n                \n                idx = idx+1\n              \
    \  \n            elseif extensions[idx] < class_name\n                \n     \
    \           idx = idx+1\n                \n            elseif extensions[idx]\
    \ == class_name\n                \n                idx = idx+1\n             \
    \   \n            elseif extensions[idx] > class_name\n                \n    \
    \            idx = idx+1\n                \n            elseif extensions[idx]\
    \ < class_name\n                \n                idx = idx+1\n              \
    \  \n            elseif extensions[idx] == class_name\n                \n    \
    \            idx = idx+1\n                \n            elseif extensions[idx]\
    \ > class_name\n                \n                idx = idx+1\n              \
    \  \n            elseif extensions[idx] < class_name\n                \n     \
    \           idx = idx+1\n                \n            elseif extensions[idx]\
    \ == class_name\n                \n                idx = idx+1\n             \
    \   \n            elseif extensions[idx] > class_name\n                \n    \
    \            idx = idx+1\n                \n            elseif extensions[idx]\
    \ < class_name\n                \n                idx = idx+1\n              \
    \  \n            elseif extensions[idx] == class_name\n                \n    \
    \            idx = idx+1\n                \n            elseif extensions[idx]\
    \ > class_name\n                \n                idx = idx+1\n              \
    \  \n            elseif extensions[idx] < class_name\n                \n     \
    \           idx = idx+1\n                \n            elseif extensions[idx]\
    \ == class_name\n                \n                idx = idx+1\n             \
    \   \n            elseif extensions[idx] > class_name\n                \n    \
    \            idx = idx+1\n                \n            elseif extensions[idx]\
    \ < class_name\n                \n                idx = idx+1\n              \
    \  \n            elseif extensions[idx] == class_name\n                \n    \
    \            idx = idx+1\n                \n            elseif extensions[idx]\
    \ > class_name\n                \n                idx = idx+1\n              \
    \  \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpowtbples.jl:1\nin expression starting at /tmp/tmpowtbples.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_sum = 0\n    \n    for extension in extensions_sorted\n  \
    \      strength_sum += length(extension) - length(extension.lowercase)\n    end\n\
    \    \n    if strength_sum == 0\n        return class_name\n    end\n    \n  \
    \  strength_sum .== 0\n    \n    extensions_sorted = sort(extensions)\n    \n\
    \    strength_sum = 0\n    \n    for extension in extensions_sorted\n        strength_sum\
    \ += length(extension) - length(extension.lowercase)\n    end\n    \n    if strength_sum\
    \ == 0\n        return class_name\n    end\n    \n    strength_sum .== 0\n   \
    \ \n    extensions_sorted = sort(extensions)\n    \n    strength_sum = 0\n   \
    \ \n    for extension in extensions_sorted\n        strength_sum += length(extension)\
    \ - length(extension.lowercase)\n    end\n    \n    if strength_sum == 0\n   \
    \     return class_name\n    end\n    \n    strength_sum .== 0\n    \n    extensions_sorted\
    \ = sort(extensions)\n    \n    strength_sum = 0\n    \n    for extension in extensions_sorted\n\
    \        strength_sum += length(extension) - length(extension.lowercase)\n   \
    \ end\n    \n    if strength_sum == 0\n        return class_name\n    end\n  \
    \  \n    strength_sum .== 0\n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_sum = 0\n    \n    for extension in extensions_sorted\n  \
    \      strength_sum += length(extension) - length(extension.lowercase)\n    end\n\
    \    \n    if strength_sum == 0\n        return class_name\n    end\n    \n  \
    \  strength_sum .== 0\n    \n    extensions_sorted = sort(extensions)\n    \n\
    \    strength_sum = 0\n    \n    for extension in extensions_sorted\n        strength_sum\
    \ += length(extension) - length(extension.lowercase)\n    end\n    \n    if strength_sum\
    \ == 0\n        return class_name\n    end\n    \n    strength_sum .== 0\n   \
    \ \n    extensions_sorted = sort(extensions)\n    \n    strength_sum = 0\n   \
    \ \n    for extension in extensions_sorted\n        strength_sum += length(extension)\
    \ - length(extension.lowercase)\n    end\n    \n    if strength_sum == 0\n   \
    \     return class_name\n    end\n    \n    strength_sum .== 0\n    \n    extensions_sorted\
    \ = sort(extensions)\n    \n    strength_sum = 0\n    \n    for extension in extensions_sorted\n\
    \        strength_sum += length(extension) - length(extension.lowercase)\n   \
    \ end\n    \n    if strength_sum == 0\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7dy6p3pc.jl:1\nin expression starting at /tmp/tmp7dy6p3pc.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    \n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i]) - length(lowercase(extensions[i]))\n    end\n    \n\
    \    Strongest_Extension = extensions[argmax(extension_strength)]\n    \n    return\
    \ Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.II\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.KK\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.LL\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.MM\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpub5hw56p.jl:30\nin expression starting at\
    \ /tmp/tmpub5hw56p.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = -1 # default strength\n    \n    for extension in extensions_sorted\n\
    \        \n        if extension == \"\"\n            continue\n        \n    \
    \    cap_extension = extension:sub(1, length(extension))\n        \n        if\
    \ cap_extension == \"\"\n            continue\n        \n        cap_extension_length\
    \ = length(cap_extension)\n        \n        if cap_extension_length == 0\n  \
    \          continue\n        \n        sm = cap_extension_length - 1\n       \
    \ \n        if sm == 0\n            continue\n        \n        strength = strength\
    \ + (cap_extension_length - sm)\n    end\n    \n    if strength == -1\n      \
    \  return class_name\n    end\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps57zy_jw.jl:1\nin expression starting at /tmp/tmps57zy_jw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ -1\n        return class_name\n    else\n        return class_name .. \".\"\
    \ .. extensions[strength]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @time begin\n    Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\
    end\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string and returns\
    \ a string with the first letter capitalized. \nExample: \n>>> first_letter_capitalized(\"\
    my_class\")\n\"MyClass\"\n>>> first_letter_capitalized(\"my_class2\")\n\"MyClass2\"\
    \n>>> first_letter_capitalized(\"my_class3\")\n\"MyClass3\"\n>>> first_letter_capitalized(\"\
    my_class4\")\n\"MyClass4\"\n>>> first_letter_capitalized(\"my_class5\")\n\"MyClass5\"\
    \n>>> first_letter_capitalized(\"my_class6\")\n\"MyClass6\"\n>>> first_letter_capitalized(\"\
    my_class7\")\n\"MyClass7\"\n>>> first_letter_capitalized(\"my_class8\")\n\"MyClass8\"\
    \n>>> first_letter_capitalized(\"my_class9\")\n\"MyClass9\"\n>>> first_letter_capitalized(\"\
    my_class10\")\n\"MyClass10\"\n>>> first_letter_capitalized(\"my_class11\")\n\"\
    MyClass11\"\n>>> first_letter_capitalized(\"my_class12\")\n\"MyClass12\"\n>>>\
    \ first_letter_capitalized(\"my_class13\")\n\"MyClass13\"\n>>> first_letter_capitalized(\"\
    my_class14\")\n\"MyClass14\"\n>>> first_letter_capitalized(\"my_class15\")\n\"\
    MyClass15\"\n>>> first_letter_capitalized(\"my_class16\")\n\"MyClass16\"\n>>>\
    \ first_letter_capitalized(\"my_class17\")\n\"MyClass17\"\n>>> first_letter_capitalized(\"\
    my_class18\")\n\"MyClass18\"\n>>> first_letter_capitalized(\"my_class19\")\n\"\
    MyClass19\"\n>>> first_letter_capitalized(\"my_class20\")\n\"MyClass20\"\n>>>\
    \ first_letter_capitalized(\"my_class21\")\n\"MyClass21\"\n>>> first_letter_capitalized(\"\
    my_class22\")\n\"MyClass\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp76mx6gy8.jl:30\nin expression starting at\
    \ /tmp/tmp76mx6gy8.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,extension) in enumerate(extensions)\n      \
    \  extension_strength[i] = length(extension) - length(lowercase(extension))\n\
    \    end\n    \n    extension_strength = sort(extension_strength)\n    \n    Strongest_Extension\
    \ = extensions[extension_strength[1]]\n    \n    for i=2:length(extension_strength)\n\
    \        if extension_strength[i] > extension_strength[i-1]\n            Strongest_Extension\
    \ = extensions[extension_strength[i]]\n            break\n        end\n    end\n\
    \    \n    return Strongest_Extension\nend\n</cell>\n<code language=julia-1.0>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) ==\
    \ \"my_class.CC\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.EE\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\"]) == \"my_class.FF\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.HH\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.II\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.JJ\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.KK\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.LL\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnuz7bf_3.jl:38\nin expression starting at\
    \ /tmp/tmpnuz7bf_3.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    \n    for i = 1:length(extensions)\n        extension_strength[i] = length(extensions[i])\
    \ - length(lowercase(extensions[i]))\n    end\n    \n    idx = findmax(extension_strength)\n\
    \    \n    return class_name * \".\" .* extensions[idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpzarku601.jl:32

    '
  stdout: "test set: Error During Test at /tmp/tmpzarku601.jl:35\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  ArgumentError: invalid index: (0.0, 1) of type Tuple{Float64,\
    \ Int64}\n  Stacktrace:\n    [1] to_index(i::Tuple{Float64, Int64})\n      @ Base\
    \ ./indices.jl:300\n    [2] to_index(A::Vector{String}, i::Tuple{Float64, Int64})\n\
    \      @ Base ./indices.jl:277\n    [3] to_indices\n      @ ./indices.jl:333 [inlined]\n\
    \    [4] to_indices\n      @ ./indices.jl:325 [inlined]\n    [5] getindex\n  \
    \    @ ./abstractarray.jl:1218 [inlined]\n    [6] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n      @ Main /tmp/tmpzarku601.jl:28\n    [7] macro\
    \ expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpzarku601.jl:35 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpzarku601.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpzarku601.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  ArgumentError: invalid index: (0.0, 1) of type\
    \ Tuple{Float64, Int64}\n  Stacktrace:\n    [1] to_index(i::Tuple{Float64, Int64})\n\
    \      @ Base ./indices.jl:300\n    [2] to_index(A::Vector{String}, i::Tuple{Float64,\
    \ Int64})\n      @ Base ./indices.jl:277\n    [3] to_indices\n      @ ./indices.jl:333\
    \ [inlined]\n    [4] to_indices\n      @ ./indices.jl:325 [inlined]\n    [5] getindex\n\
    \      @ ./abstractarray.jl:1218 [inlined]\n    [6] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n      @ Main /tmp/tmpzarku601.jl:28\n    [7] macro\
    \ expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpzarku601.jl:36 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[0]\n\
    \    \n    if strength_of_extension == 0 \n        return class_name\n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvlpody2c.jl:1\nin expression starting at /tmp/tmpvlpody2c.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[0]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[strength]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 2\nWrite a function that takes a vector of extensions\
    \ and a vector of classes and returns a vector of classes with the strongest extensions\
    \ removed.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb941qe2l.jl:30\nin expression starting at\
    \ /tmp/tmpb941qe2l.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that takes a string and a vector\
    \ of strings and returns a string that is the concatenation of all the strings\
    \ in the vector separated by spaces.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoucu0ur3.jl:30\nin expression starting at\
    \ /tmp/tmpoucu0ur3.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector of strings\
    \ and a vector of strings as arguments. \nThe function should return a vector\
    \ of strings that contains the strings in \nthe second argument that do not appear\
    \ in the first argument. \nThe function should return an empty vector if the second\
    \ argument contains \nno strings.\nExample: \n>>> Vector_of_Strings([1, 2, 3],\
    \ [\"a\", \"b\", \"c\", \"d\"])\n[\"b\", \"d\"]\n>>> Vector_of_Strings([1, 2,\
    \ 3], [])\n[]\n>>> Vector_of_Strings([\"a\", \"b\", \"c\", \"d\"], [])\n[]\n>>>\
    \ Vector_of_Strings([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\", \"d\"\
    ])\n[\"a\", \"b\", \"c\", \"d\"]\n>>> Vector_of_Strings([\"a\", \"b\", \"c\",\
    \ \"d\"], [\"a\", \"b\", \"d\"])\n[]\n>>> Vector_of_Strings([\"a\", \"b\", \"\
    c\", \"d\"], [\"a\", \"b\", \"c\", \"e\"])\n[]\n>>> Vector_of_Strings([\"a\",\
    \ \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\", \"d\", \"e\"])\n[\"a\", \"b\", \"\
    c\", \"d\"]\n>>> Vector_of_Strings([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\"])\n[\"a\", \"b\", \"c\", \"d\"]\n>>> Vector_of_Strings([\"\
    a\", \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n\
    [\"a\", \"b\", \"c\", \"d\"]\n>>> Vector_of_Strings([\"a\", \"b\", \"c\", \"d\"\
    ], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"])\n[\"a\", \"b\", \"\
    c\", \"d\"]\n>>> Vector_of_Strings([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"])\n[\"a\", \"b\", \"c\", \"\
    d\"]\n>>> Vector_of_Strings([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"])\n[\"a\", \"b\", \"c\", \"\
    d\"]\n>>> Vector_of_Strings([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"])\n[\"a\", \"b\", \"\
    c\", \"d\"]\n>>> Vector_of_Strings([\"a\", \"b\", \"c\", \"d\"], [\"a\", \"b\"\
    , \"c\", \"d\", \"e\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy6vo0r5t.jl:30\nin expression starting at\
    \ /tmp/tmpy6vo0r5t.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ 0\n        return class_name\n    else\n        return class_name * \".\" +\
    \ extensions[1]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpsd2_wp8w.jl:32

    '
  stdout: "test set: Error During Test at /tmp/tmpsd2_wp8w.jl:35\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  BoundsError: attempt to access 3-element Vector{String}\
    \ at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpsd2_wp8w.jl:22\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsd2_wp8w.jl:35 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsd2_wp8w.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpsd2_wp8w.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  BoundsError: attempt to access 4-element Vector{String}\
    \ at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpsd2_wp8w.jl:22\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsd2_wp8w.jl:36 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsd2_wp8w.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpsd2_wp8w.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  BoundsError: attempt to access\
    \ 6-element Vector{String} at index [0]\n  Stacktrace:\n   [1] getindex\n    \
    \ @ ./array.jl:861 [inlined]\n   [2] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpsd2_wp8w.jl:22\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/"
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[0]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        \n        extensions_sorted\
    \ = sort(extensions_sorted)\n        \n        extensions_sorted = extensions_sorted[strength]\n\
    \        \n        return class_name + \".\" + extensions_sorted\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert Strongest_Extension(\"my_class\",\
    \ [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.II\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.KK\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.LL\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.MM\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp92ajje_k.jl:35\nin expression starting at\
    \ /tmp/tmp92ajje_k.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    \n    for i = 1:length(extensions)\n        extension_strength[i] = length(extensions[i])\
    \ - length(lowercase(extensions[i]))\n    end\n    \n    idx = findfirst(extension_strength\
    \ == maximum(extension_strength))\n    \n    if idx == -1\n        return class_name\n\
    \    else\n        return class_name * \".\" .* extensions[idx]\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@time Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise 3\nWrite a function that takes\
    \ a string and returns a string with the first letter capitalized.\nExample: \n\
    >>> capitalize(\"my_class\")\n\"MyClass\"\n>>> capitalize(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\"])\n\"MyClass\"\n>>> capitalize(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\"])\n\"MyClass\"\n>>> capitalize(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"])\n\"MyClass\"\n>>> capitalize(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"])\n\"MyClass\"\n>>> capitalize(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"])\n\"MyClass\"\n>>>\
    \ capitalize(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"\
    GG\", \"HH\"])\n\"MyClass\"\n>>> capitalize(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"])\n\"MyClass\"\n>>> capitalize(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"])\n\"MyClass\"\n>>> capitalize(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"])\n\"MyClass\"\
    \n>>> capitalize(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"\
    , \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"])\n\"MyClass\"\n>>> capitalize(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\"])\n\"MyClass\"\n>>> capitalize(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\n\"MyClass\"\n>>> capitalize(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9ex4o85p.jl:34\nin expression starting at\
    \ /tmp/tmp9ex4o85p.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = Dict()\n\
    \    \n    for extension in extensions \n        extension_strength[extension]\
    \ = length(extension) - length(extension.lowercase)\n    end\n    \n    sorted_extensions\
    \ = sort(collect(extension_strength), by=x->-x)\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpogapkq3h.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpogapkq3h.jl:1\n\
    in expression starting at /tmp/tmpogapkq3h.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5q_ih7je.jl:30\nin expression starting at\
    \ /tmp/tmp5q_ih7je.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    \n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i]) - length(replace(extensions[i], uppercase(extensions[i]),\
    \ \"\"))\n    end\n    \n    extension_strength = sort(extension_strength)\n \
    \   \n    Strongest_Extension = extensions[extension_strength[1]]\n    \n    for\
    \ i = 2:length(extension_strength)\n        if extension_strength[i] > extension_strength[i-1]\n\
    \            Strongest_Extension = Strongest_Extension .. \".\" .. extensions[i]\n\
    \        end\n    end\n    \n    return Strongest_Extension\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.EE\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.HH\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.II\"\n@test Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.JJ\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.KK\"\n@test Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.LL\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"..\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp5nd2ya7u.jl:32\nin expression starting at /tmp/tmp5nd2ya7u.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that takes a string and returns\
    \ a string where all characters are capitalized.\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpboepzxks.jl:30\nin expression starting at\
    \ /tmp/tmpboepzxks.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name * \".\" . extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes a vector of extensions and a vector of classes and returns a vector\
    \ of strings. \nThe strings should be in the format: ClassName.ExtensionName.\
    \ \nFor example, if you are given the following vectors: \n[\"AA\", \"Be\", \"\
    CC\"] and [\"my_class\", \"my_class2\", \"my_class3\"] then you should\nreturn\
    \ [\"my_class.AA\", \"my_class.Be\", \"my_class.CC\", \"my_class2.my_class3\"\
    , \"my_class2.my_class3\"].\nThe function should return an empty vector if there\
    \ are no extensions or classes given.\nExample: \n>>> Extension_Vector([\"AA\"\
    , \"Be\", \"CC\"], [\"my_class\", \"my_class2\", \"my_class3\"])\n[\"my_class.AA\"\
    , \"my_class.Be\", \"my_class.CC\", \"my_class2.my_class3\", \"my_class2.my_class3\"\
    ]\n>>> Extension_Vector([], [\"my_class\", \"my_class2\", \"my_class3\"])\n[]\n\
    >>> Extension_Vector([\"AA\", \"Be\", \"CC\"], [])\n[]\n>>> Extension_Vector([],\
    \ [])\n[]\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"\".\" .\"\
    \ at /tmp/tmp0uxfqka1.jl:27\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0uxfqka1.jl:27\n\
    in expression starting at /tmp/tmp0uxfqka1.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name * \".\" . extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.Be\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.HH\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.II\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.KK\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"\
    , \"MM\", \"NN\", \"OO\"]) == \"\nusing Test\n\n@testset begin\n\ncandidate =\
    \ Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"\".\" .\"\
    \ at /tmp/tmpfddgh8dw.jl:27\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfddgh8dw.jl:27\n\
    in expression starting at /tmp/tmpfddgh8dw.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extensions = 0.0\n    \n    for extension in extensions_sorted\n\
    \        \n        extension_upper = uppercase(extension)\n        extension_lower\
    \ = lowercase(extension)\n        \n        strength_of_extensions += (length(extension)\
    \ - length(extension_upper) - length(extension_lower))\n    end\n    \n    strength_of_extensions\
    \ = strength_of_extensions / length(extensions)\n    \n    if strength_of_extensions\
    \ > 0\n        \n        strength_of_extensions = -1\n        \n        for extension\
    \ in extensions_sorted\n            \n            extension_upper = uppercase(extension)\n\
    \            extension_lower = lowercase(extension)\n            \n          \
    \  strength_of_extensions += (length(extension) - length(extension_upper) - length(extension_lower))\n\
    \        end\n        \n        strength_of_extensions = strength_of_extensions\
    \ / length(extensions)\n        \n    end\n    \n    return class_name * \".\"\
    \ .* extensions_sorted[findfirst(x -> x == strength_of_extensions, extensions_sorted)]\n\
    end\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.CC\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.EE\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"])\
    \ == \"my_class.GG\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.HH\"\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.II\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\"]) == \"my_class.JJ\"\n@test Strongest_Extension(\"my_\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpktkijpir.jl:52\nin expression starting at\
    \ /tmp/tmpktkijpir.jl:52\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,extension) in enumerate(extensions)\n      \
    \  extension_strength[i] = length(extension) - length(lowercase(extension))\n\
    \    end\n    \n    idx = findfirst(x -> x > 0, extension_strength)\n    \n  \
    \  if idx == nothing\n        return class_name\n    end\n    \n    idx = idx[1]\n\
    \    \n    if extension_strength[idx] == 0\n        return class_name\n    end\n\
    \    \n    idx = idx-1\n    \n    if extension_strength[idx] == 0\n        return\
    \ class_name\n    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx]\
    \ == 0\n        return class_name\n    end\n    \n    idx = idx-1\n    \n    if\
    \ extension_strength[idx] == 0\n        return class_name\n    end\n    \n   \
    \ idx = idx-1\n    \n    if extension_strength[idx] == 0\n        return class_name\n\
    \    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx] == 0\n \
    \       return class_name\n    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx]\
    \ == 0\n        return class_name\n    end\n    \n    idx = idx-1\n    \n    if\
    \ extension_strength[idx] == 0\n        return class_name\n    end\n    \n   \
    \ idx = idx-1\n    \n    if extension_strength[idx] == 0\n        return class_name\n\
    \    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx] == 0\n \
    \       return class_name\n    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx]\
    \ == 0\n        return class_name\n    end\n    \n    idx = idx-1\n    \n    if\
    \ extension_strength[idx] == 0\n        return class_name\n    end\n    \n   \
    \ idx = idx-1\n    \n    if extension_strength[idx] == 0\n        return class_name\n\
    \    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx] == 0\n \
    \       return class_name\n    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx]\
    \ == 0\n        return class_name\n    end\n    \n    idx = idx-1\n    \n    if\
    \ extension_strength[idx] == 0\n        return class_name\n    end\n    \n   \
    \ idx = idx-1\n    \n    if extension_strength[idx] == 0\n        return class_name\n\
    \    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx] == 0\n \
    \       return class_name\n    end\n    \n    idx = idx-1\n    \n    if extension_strength[idx]\
    \ == 0\n        return class_name\n    end\n    \n    idx = idx-1\n    \n    if\
    \ extension_strength[idx] == 0\n        return class_name\n    end\n    \n   \
    \ idx = idx-1\n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8m73dpp_.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8m73dpp_.jl:1\n\
    in expression starting at /tmp/tmp8m73dpp_.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[0]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .* \".\" .* extensions_sorted[strength]\n    end\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns the number of uppercase\
    \ letters in the string.\nExample: \n    >>> count_upper(\"my_string\")\n    2\n\
    \    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplm1q0ja5.jl:30\nin expression starting at\
    \ /tmp/tmplm1q0ja5.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ * \".\" . extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that takes a string and returns\
    \ the number of uppercase letters in it.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"\".\" .\"\
    \ at /tmp/tmphrw_w2za.jl:27\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphrw_w2za.jl:27\n\
    in expression starting at /tmp/tmphrw_w2za.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = -1 # default strength\n    \n    for extension in extensions_sorted\n\
    \        \n        if extension in extensions_sorted[1 : end]\n            \n\
    \            strength = extensions_sorted[1 : end].index(extension) - extensions_sorted[1\
    \ : end].index(extension)\n            break\n        end\n    end\n    \n   \
    \ if strength == -1\n        \n        error(\"No extension with strength found\"\
    )\n    end\n    \n    return class_name * \".\" .* extensions_sorted[1 : end][strength]\n\
    end\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a string and returns a string with the first letter\
    \ capitalized. \nExample: \n>>> first_letter_capitalized(\"my_string\")\n\"MyString\"\
    \n>>> first_letter_capitalized(\"my_string2\")\n\"MyString2\"\n>>> first_letter_capitalized(\"\
    my_string3\")\n\"MyString3\"\n>>> first_letter_capitalized(\"my_string4\")\n\"\
    MyString4\"\n>>> first_letter_capitalized(\"my_string5\")\n\"MyString5\"\n>>>\
    \ first_letter_capitalized(\"my_string6\")\n\"MyString6\"\n>>> first_letter_capitalized(\"\
    my_string7\")\n\"MyString7\"\n>>> first_letter_capitalized(\"my_string8\")\n\"\
    MyString8\"\n>>> first_letter_capitalized(\"my_string9\")\n\"MyString9\"\n>>>\
    \ first_letter_capitalized(\"my_string10\")\n\"MyString10\"\n>>> first_letter_capitalized(\"\
    my_string11\")\n\"MyString11\"\n>>> first_letter_capitalized(\"my_string12\")\n\
    \"MyString12\"\n>>> first_letter_capitalized(\"my_string13\")\n\"MyString13\"\n\
    >>> first_letter_capitalized(\"my_string14\")\n\"MyString14\"\n>>> first_letter_capitalized(\"\
    my_string15\")\n\"MyString15\"\n>>> first_letter_capitalized(\"my_string16\")\n\
    \"MyString16\"\n>>> first_letter_capitalized(\"my_string17\")\n\"MyString17\"\n\
    >>> first_letter_capitalized(\"my_string18\")\n\"MyString18\"\n>>> first_letter_cap\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptdt8az49.jl:40\nin expression starting at\
    \ /tmp/tmptdt8az49.jl:40\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i=1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i])-length(replace(extensions[i], uppercase(extensions[i]),\
    \ \"\"))\n    end\n    \n    idx = findfirst(extension_strength == maximum(extension_strength),\
    \ extension_strength)\n    \n    if idx == nothing\n        return class_name\n\
    \    else\n        return class_name+\".\"+extensions[idx]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns the number of times a substring appears in a given string.\nFor\
    \ example, if the string is: \"The quick brown fox jumps over the lazy dog\" and\
    \ the substring is: \"fox\" then the function should return 3.\nIf the substring\
    \ is not in the string, then the function should return 0.\nThe function should\
    \ work for any substring and any string.\nThe function should work for any string\
    \ and any substring.\nThe function should work for any string and any substring.\n\
    The function should work for any string and any substring.\nThe function should\
    \ work for any string and any substring.\nThe function should work for any string\
    \ and any substring.\nThe function should work for any string and any substring.\n\
    The function should work for any string and any substring.\nThe function should\
    \ work for any string and any substring.\nThe function should work for any string\
    \ and any substring.\nThe function should work for any string and any substring.\n\
    The function should work for any string and any substring.\nThe function should\
    \ work for any string and any substring.\nThe function should work for any string\
    \ and any substring.\nThe function should work for any string and any substring.\n\
    The function should work for any string and any substring.\nThe function should\
    \ work for any string and any substring.\nThe function should work for any string\
    \ and any substring.\nThe function should work for any string and any substring.\n\
    The function should work for any string and any substring.\nThe function should\
    \ work for any string and any substring.\nThe function should work for any string\
    \ and any substring.\nThe function should work for any string and any substring.\n\
    The function should work for any string and any substring.\nThe function should\
    \ work for any string and any substring.\nThe function should work for any string\
    \ and any substring.\nThe function should work for any string and any substring.\n\
    The function should work for any string and any substring.\nThe function should\
    \ work for any string and any substring.\nThe function should work for any string\
    \ \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9zmm_c22.jl:33\nin expression starting at\
    \ /tmp/tmp9zmm_c22.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    for e in extensions\n        extension_strength[findall(e == extensions)[1]]\
    \ = \n            length(findall(e == extensions)[1])/length(extensions)\n   \
    \ end\n    \n    Strongest_Extension = sort(extension_strength, by = abs)[1]\n\
    \    \n    return class_name * Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 4\nWrite a function that takes a string and returns\
    \ a string where all vowels are replaced by \"y\".\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi3z7drpp.jl:30\nin expression starting at\
    \ /tmp/tmpi3z7drpp.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[0]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .* \".\" .* extensions_sorted[strength]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 2\nWrite a function that takes a string and a vector\
    \ of strings and returns a string that is the concatenation of all the strings\
    \ in the vector separated by spaces.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu2s73d3o.jl:30\nin expression starting at\
    \ /tmp/tmpu2s73d3o.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ * \".\" . extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that takes a string and a vector\
    \ of strings as arguments and returns a string with the first letter of each string\
    \ in the vector concatenated with the rest of the strings in the vector. \nFor\
    \ example, if the string \"my_class\" and the vector [\"AA\", \"Be\", \"CC\"]\
    \ are passed as arguments to the function, you should return \"my.class\".\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"\".\" .\"\
    \ at /tmp/tmpcw7v2xdf.jl:27\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpcw7v2xdf.jl:27\n\
    in expression starting at /tmp/tmpcw7v2xdf.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5q_ih7je.jl:30\nin expression starting at\
    \ /tmp/tmp5q_ih7je.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes as input a vector of strings and returns a vector of the same length\n\
    where each element is the length of the longest string in the input vector. \n\
    The function should return an empty vector if the input vector is empty.\nExample:\n\
    >>> longest_strings([\"Hello\", \"World\"])\n[\"Hello\", 5]\n>>> longest_strings([])\n\
    []\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcijj3np8.jl:30\nin expression starting at\
    \ /tmp/tmpcijj3np8.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ 0 \n        \n        return class_name\n        \n    else\n        \n    \
    \    return class_name + \".\" + extensions[end]\n    end\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a string and a vector of strings as arguments\
    \ and returns the string with the first letter of each word capitalized.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppazg1bhz.jl:33\nin expression starting at\
    \ /tmp/tmppazg1bhz.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ 0 \n        return class_name\n    \n    else \n        return class_name ..\
    \ \".\" .. extensions[strength]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwvc4qfyz.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwvc4qfyz.jl:1\n\
    in expression starting at /tmp/tmpwvc4qfyz.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    \n    for (i,ext) in enumerate(extensions)\n      \
    \  extension_strength[i] = length(ext) - length(replace(ext, upper(ext), \"\"\
    ))\n    end\n    \n    idx = findmax(extension_strength)\n    \n    return class_name\
    \ * \".\" .* extensions[idx]\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4tgwm_s4.jl:30\nin expression starting at\
    \ /tmp/tmp4tgwm_s4.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    for e in extensions\n        extension_strength[findall(e == extensions)[1]]\
    \ = length(findall(e == extensions)[1])\n    end\n    \n    idx = findfirst(extension_strength\
    \ == maximum(extension_strength), extension_strength)\n    \n    if idx == nothing\n\
    \        return class_name\n    else\n        return string(class_name, extensions[idx])\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@time Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a string and returns a string in the following format:\n    ClassName_StrongestExtensionName\n\
    where ClassName is the name of the class (a string) and StrongestExtensionName\
    \ is the name of the strongest extension (a string).\nFor example, if you are\
    \ given \"my_class\" as the class name and a vector of extensions \n['AA', 'Be',\
    \ 'CC'] then you should return 'my_class.AA' since 'AA' is the strongest extension\
    \ (its strength is 1).\nThe function should work for any class name you give it,\
    \ and any number of extensions.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppa54z1x7.jl:33\nin expression starting at\
    \ /tmp/tmppa54z1x7.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name * \".\" + extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.Be\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.HH\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.II\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.KK\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"\
    , \"MM\", \"NN\", \"OO\"]) == \"my_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7kzx88if.jl:30\nin expression starting at\
    \ /tmp/tmp7kzx88if.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.Be\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.HH\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.II\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.KK\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"\
    , \"MM\", \"NN\", \"OO\"]) == \"\nusing Test\n\n@testset begin\n\ncandidate =\
    \ Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0keii5sn.jl:30\nin expression starting at\
    \ /tmp/tmp0keii5sn.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[0]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ + \".\" + extensions_sorted[strength]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.CC\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.EE\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.GG\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.MM\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.NN\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaoskinc5.jl:30\nin expression starting at\
    \ /tmp/tmpaoskinc5.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    for e in extensions\n        extension_strength[findall(e == extensions)[1]]\
    \ = length(findall(e == extensions)[1])/length(extensions)\n    end\n    \n  \
    \  idx = findfirst(extension_strength == maximum(extension_strength))\n    \n\
    \    if idx == -1\n        return class_name\n    else\n        return class_name+\"\
    .\"+extensions[idx]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\nusing Test\n\n@testset begin\n\
    \ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz1gu61gt.jl:33\nin expression starting at\
    \ /tmp/tmpz1gu61gt.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        \n        extensions_sorted\
    \ = sort(extensions)\n        \n        strength = extensions_sorted[1] - extensions_sorted[2]\n\
    \        \n        if strength == -1\n            return class_name\n        else\n\
    \            \n            extensions_sorted = sort(extensions)\n            \n\
    \            strength = extensions_sorted[1] - extensions_sorted[2]\n        \
    \    \n            if strength == -1\n                return class_name\n    \
    \        else\n                \n                extensions_sorted = sort(extensions)\n\
    \                \n                strength = extensions_sorted[1] - extensions_sorted[2]\n\
    \                \n                if strength == -1\n                    return\
    \ class_name\n                else\n                    \n                   \
    \ extensions_sorted = sort(extensions)\n                    \n               \
    \     strength = extensions_sorted[1] - extensions_sorted[2]\n               \
    \     \n                    if strength == -1\n                        return\
    \ class_name\n                    else\n                        \n           \
    \             extensions_sorted = sort(extensions)\n                        \n\
    \                        strength = extensions_sorted[1] - extensions_sorted[2]\n\
    \                        \n                        if strength == -1\n       \
    \                     return class_name\n                        else\n      \
    \                      \n                            extensions_sorted = sort(extensions)\n\
    \                            \n                            strength = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                            \n                     \
    \       if strength == -1\n                                return class_name\n\
    \                            else\n                                \n        \
    \                        extensions_sorted = sort(extensions)\n              \
    \                  \n                                strength = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                                \n                 \
    \               if strength == -1\n                                    return\
    \ class_name\n                                else\n                         \
    \           \n                                    extensions_sorted = sort(extensions)\n\
    \                                    \n                                    strength\
    \ = extensions_sorted[1] - extensions_sorted[2]\n                            \
    \        \n                                    if strength == -1\n           \
    \                             return class_name\n                            \
    \        else\n                                        \n                    \
    \                    extensions_sorted = sort(extensions)\n                  \
    \                      \n                                        strength = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                                        \n         \
    \                               if strength == -1\n                          \
    \                  return class_name\n                                       \
    \ else\n                                            \n                       \
    \                     extensions_sorted = sort(extensions)\n                 \
    \                           \n                                            strength\
    \ = extensions_sorted[1] - extensions_sorted[2]\n                            \
    \                \n                                            if strength ==\
    \ -1\n                                                return class_name\n    \
    \                                        else\n                              \
    \                  \n                                                extensions_sorted\
    \ = sort(extensions)\n                                                \n     \
    \                                           strength = extensions_sorted[1] -\
    \ extensions_sorted[2]\n                                                \n   \
    \                                             if strength == -1\n            \
    \                                        return class_name\n                 \
    \                               else\n                                       \
    \             \n                                                    extensions_sorted\
    \ = sort(extensions)\n                                                    \n \
    \                                                   strength = extensions_sorted[1]\
    \ - extensions_sorted[2]\n                                                   \
    \ \n                                                    if strength == -1\n  \
    \                                                      return class_name\n   \
    \                                                 else\n                     \
    \                                   \n                                       \
    \                 extensions_sorted = sort(\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa8ow_ogk.jl:127\nin expression starting at\
    \ /tmp/tmpa8ow_ogk.jl:127\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_map = Dict{String, Int}()\n    \n    for extension in extensions_sorted\n\
    \        \n        extension_upper = extension.uppercase()\n        extension_lower\
    \ = extension.lowercase()\n        \n        strength_map[extension_upper] = length(extension)\
    \ - length(extension_lower)\n        \n    end\n    \n    strength_sorted = sort(strength_map.values)\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpduf93zo5.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpduf93zo5.jl:1\n\
    in expression starting at /tmp/tmpduf93zo5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ 0 \n        return class_name\n    else \n        return class_name * \".\"\
    \ . extensions[1]\nend\n</cell>\n<code language=julia-1.5>\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.Be\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.HH\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.II\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.KK\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"\
    , \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@assert Strongest_Extension(\"\
    my_class\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t\
    @test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"\".\" .\"\
    \ at /tmp/tmpx1me9fk4.jl:27\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpx1me9fk4.jl:27\n\
    in expression starting at /tmp/tmpx1me9fk4.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\"]) == \"my_class.AA\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"]) == \"my_class.Be\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\"]) == \"my_class.DD\"\n@assert Strongest_Extension(\"my_class\", [\"AA\",\
    \ \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) ==\
    \ \"my_class.GG\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) == \"my_class.HH\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"]) == \"my_class.II\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"]) == \"my_class.JJ\"\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"]) == \"my_class.KK\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"])\
    \ == \"my_class.LL\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"\
    , \"MM\", \"NN\", \"OO\"]) == \"\nusing Test\n\n@testset begin\n\ncandidate =\
    \ Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0keii5sn.jl:30\nin expression starting at\
    \ /tmp/tmp0keii5sn.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    for (i,extension) in enumerate(extensions)\n        extension_strength[i]\
    \ = length(extension) - length(translate(extension, uppercase, lowercase))\n \
    \   end\n    \n    idx = findfirst(extension_strength .== maximum(extension_strength))\n\
    \    \n    if idx == nothing\n        return class_name\n    else\n        return\
    \ string(class_name, extensions[idx])\n    end\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that takes a string and returns a string where all characters\
    \ are capitalized. \nExample: \n>>> capitalize(\"my_class\")\n\"MyClass\"\n>>>\
    \ capitalize(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\"MyClass\"\n>>> capitalize(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"], [\"BB\", \"CC\"])\n\"MyClass\"\n>>> capitalize(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"], [\"BB\", \"CC\"], [\"DD\", \"EE\"])\n\"\
    MyClass\"\n>>> capitalize(\"my_class\", [\"AA\", \"Be\", \"CC\"], [\"BB\", \"\
    CC\"], [\"DD\", \"EE\"], [\"FF\", \"GG\"])\n\"MyClass\"\n>>> capitalize(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"], [\"BB\", \"CC\"], [\"DD\", \"EE\"], [\"FF\", \"GG\"\
    ], [\"HH\", \"II\"])\n\"MyClass\"\n>>> capitalize(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\"], [\"BB\", \"CC\"], [\"DD\", \"EE\"], [\"FF\", \"GG\"], [\"HH\", \"II\"\
    ], [\"JJ\", \"KK\"])\n\"MyClass\"\n>>> capitalize(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\"], [\"BB\", \"CC\"], [\"DD\", \"EE\"], [\"FF\", \"GG\"], [\"HH\", \"II\"\
    ], [\"JJ\", \"KK\"], [\"LL\", \"MM\"])\n\"MyClass\"\n>>> capitalize(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"], [\"BB\", \"CC\"], [\"DD\", \"EE\"], [\"FF\", \"GG\"\
    ], [\"HH\", \"II\"], [\"JJ\", \"KK\"], [\"LL\", \"MM\"], [\"NN\", \"OO\"])\n\"\
    MyClass\"\n>>> capitalize(\"my_class\", [\"AA\", \"Be\", \"CC\"], [\"BB\", \"\
    CC\"], [\"DD\", \"EE\"], [\"FF\", \"GG\"], [\"HH\", \"II\"], [\"JJ\", \"KK\"],\
    \ [\"LL\", \"MM\"], [\"NN\", \"OO\"], [\"PP\", \"QQ\"])\n\"MyClass\"\n>>> capitalize(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"], [\"BB\", \"CC\"], [\"DD\", \"EE\"], [\"\
    FF\", \"GG\"], [\"HH\", \"II\"], [\"JJ\", \"KK\"], [\"LL\", \"MM\"], [\"NN\",\
    \ \"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphfnzo_k0.jl:33\nin expression starting at\
    \ /tmp/tmphfnzo_k0.jl:33\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions.length\n    \n    for extension in extensions\n\
    \        \n        strength = strength - length(extension)\n        \n       \
    \ if strength == 0\n            return class_name\n        end\n    end\n    \n\
    \    return class_name\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a string and a vector of strings as arguments\
    \ and returns the string with the longest extension.\nFor example, if you are\
    \ given \"my_class\" as the class and a vector of the extensions: ['AA', 'Be',\
    \ 'CC'] then you should return 'my_class.AA'.\nIf the vector is empty or if the\
    \ string does not have any extensions, you should return an empty string.\nExample:\n\
    >>> Longest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\"my_class.AA\"\
    \n>>> Longest_Extension(\"my_class\", [])\n\"\"\n>>> Longest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\"])\n\"my_class.AA\"\n>>> Longest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"])\n\"my_class.AA\"\n>>> Longest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"])\n\"my_class.AA\"\
    \n>>> Longest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\"])\n\"my_class.AA\"\n>>> Longest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"])\n\"my_class.AA\"\n\
    >>> Longest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\"])\n\"my_class.AA\"\n>>> Longest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\"])\n\"my_class.AA\"\n>>> Longest_Extension(\"my_class\", [\"AA\", \"Be\",\
    \ \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"])\n\"\
    my_class.AA\"\n>>> Longest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"\
    DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\"])\n\"my_class.AA\"\
    \n>>> Longest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"\
    , \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"])\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2ws16_ir.jl:35\nin expression starting at\
    \ /tmp/tmp2ws16_ir.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,ext) in enumerate(extensions)\n        extension_strength[i]\
    \ = length(ext) - length(lowercase(ext))\n    end\n    \n    idx = findmax(extension_strength)\n\
    \    \n    return class_name * \".\" .* extensions[idx]\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) \u2248 \"my_class.AA\"\
    \n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"]) \u2248\
    \ \"my_class.Be\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"\
    CC\", \"DD\", \"EE\"]) \u2248 \"my_class.CC\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) \u2248 \"my_class.DD\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\"]) \u2248 \"my_class.EE\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) \u2248 \"\
    my_class.FF\"\n@test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    , \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\"]) \u2248 \"my_class.GG\"\n@test\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"\
    FF\", \"GG\", \"HH\", \"II\", \"JJ\"]) \u2248 \"my_class.HH\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\"]) \u2248 \"my_class.II\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\"]) \u2248 \"my_class.JJ\"\n@test Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\"]) \u2248 \"my_class.KK\"\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]\nusing Test\n\n@testset begin\n\n\
    candidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpizyvzub7.jl:29\nin expression starting at\
    \ /tmp/tmpizyvzub7.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[2]\n\
    \    \n    \n    if strength_of_extension == -1\n        return class_name\n \
    \   else\n        return class_name .+ Strongest_Extension(extensions_sorted[1],\
    \ extensions_sorted[2:end])\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpv2gucv6s.jl:33

    '
  stdout: "test set: Error During Test at /tmp/tmpv2gucv6s.jl:36\n  Test threw exception\n\
    \  Expression: candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\"\n  MethodError: no method matching -(::String, ::String)\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpv2gucv6s.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpv2gucv6s.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpv2gucv6s.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpv2gucv6s.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\"\n  MethodError: no method matching -(::String, ::String)\n\
    \  Stacktrace:\n   [1] Strongest_Extension(class_name::String, extensions::Vector{String})\n\
    \     @ Main /tmp/tmpv2gucv6s.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpv2gucv6s.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpv2gucv6s.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpv2gucv6s.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\n  MethodError: no method matching\
    \ -(::String, ::String)\n  Stacktrace:\n   [1] Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})\n     @ Main /tmp/tmpv2gucv6s.jl:22\n   [2] macro\
    \ expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpv2gucv6s.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test"
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength_of_extension = extensions_sorted[1] - extensions_sorted[0]\n\
    \    \n    if strength_of_extension == -1\n        return class_name\n    else\n\
    \        return class_name .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@test Strongest_Extension(\"my_class\", [\"AA\", \"\
    Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes a string and returns a string with the first letter capitalized.\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpffsh4krv.jl:30\nin expression starting at\
    \ /tmp/tmpffsh4krv.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i = 1:length(extensions)\n        extension_strength[i]\
    \ = length(extension_strength[i]) \n    end\n    \n    extension_strength = sort(extension_strength,\
    \ by = length) \n    \n    Strongest_Extension = extensions[extension_strength[1]]\n\
    \    \n    for i = 2:length(extension_strength)\n        if extension_strength[i]\
    \ > extension_strength[i-1]\n            Strongest_Extension = extensions[extension_strength[i]]\n\
    \            break\n        end\n    end\n    \n    return Strongest_Extension\n\
    end\n</cell>\n<code language=julia-1.3>\n@time Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ takes as input a vector of strings and returns a vector of strings where each\
    \ string is the concatenation of all the strings in the input vector except the\
    \ string itself. \nFor example, if the input vector is [\"a\", \"b\", \"c\", \"\
    d\"] then the output vector should be [\"a\", \"b\", \"c\", \"d\"]. \nIf the input\
    \ vector is [\"a\", \"b\", \"c\", \"d\", \"e\"] then the output vector should\
    \ be [\"a\", \"b\", \"c\", \"d\", \"e\"]. \nIf the input vector is [\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\"] then the output vector should be [\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\"]. \nIf the input vector is [\"a\", \"b\", \"c\",\
    \ \"d\", \"e\", \"f\", \"g\"] then the output vector should be [\"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\"]. \nIf the input vector is [\"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"] then the output vector should be [\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]. \nIf the input vector is\
    \ [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"] then the output\
    \ vector should be [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"\
    i\"]. \nIf the input vector is [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    , \"h\", \"i\", \"j\"] then the output vector should be [\"a\", \"b\", \"c\",\
    \ \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]. \nIf the input vector is [\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"] then\
    \ the output vector should be [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    , \"h\", \"i\", \"j\", \"k\"]. \nIf the input vector is [\"a\", \"b\", \"c\",\
    \ \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"] then the output\
    \ vector should be [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"\
    i\", \"j\", \"k\", \"l\"]. \nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9yun598s.jl:38\nin expression starting at\
    \ /tmp/tmp9yun598s.jl:38\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that returns the number of uppercase\
    \ letters in a given string.\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp43469fc5.jl:30\nin expression starting at\
    \ /tmp/tmp43469fc5.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ 0 \n        return class_name\n    else\n        return class_name * \".\" .*\
    \ extensions[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function that takes a string and returns a string where all occurrences\
    \ of \nthe string \"A\" have been replaced with \"B\".\nExample: \n>>> replace_A(\"\
    AABBCCC\")\n\"BBBBBBC\"\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfx6ds8ai.jl:30\nin expression starting at\
    \ /tmp/tmpfx6ds8ai.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,extension) in enumerate(extensions)\n      \
    \  extension_strength[i] = count_letters(extension) - count_letters(extension[i])\n\
    \    end\n    \n    Strongest_Extension = extensions[argmax(extension_strength)]\n\
    \    \n    return class_name * Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt0u8mlus.jl:29\nin expression starting at\
    \ /tmp/tmpt0u8mlus.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i=1:length(extensions)\n        extension_strength[i]\
    \ = length(extensions[i])-length(replace(extensions[i], uppercase(extensions[i]),\
    \ \"\"))\n    end\n    \n    Strongest_Extension = extensions[argmax(extension_strength)]\n\
    \    \n    return Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 2\nWrite a function that takes a string and returns\
    \ the number of uppercase letters in it.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2xgjero_.jl:29\nin expression starting at\
    \ /tmp/tmp2xgjero_.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions = sort(extensions)\n\
    \    \n    strength = extensions[1] - extensions[0]\n    \n    if strength ==\
    \ 0 \n        return class_name\n    \n    else \n        return class_name *\
    \ \".\" . extensions[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@assert\
    \ Strongest_\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \".\" not allowed in \"\".\" .\"\
    \ at /tmp/tmps87ilq6d.jl:28\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmps87ilq6d.jl:28\n\
    in expression starting at /tmp/tmps87ilq6d.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extensions_sorted = sort(extensions)\n\
    \    \n    strength = extensions_sorted[1] - extensions_sorted[2]\n    \n    if\
    \ strength == -1\n        return class_name\n    else\n        return class_name\
    \ .. \".\" .. extensions_sorted[1]\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\
    \ == \"my_class.Be\"\n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\"\
    , \"CC\", \"DD\", \"EE\"]) == \"my_class.CC\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"]) == \"my_class.DD\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\"]) == \"my_class.EE\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"]) == \"my_class.FF\"\
    \n@assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"\
    EE\", \"FF\", \"GG\", \"HH\", \"II\"]) == \"my_class.GG\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\"]) == \"my_class.HH\"\n@assert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\",\
    \ \"KK\"]) == \"my_class.II\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\"]) == \"my_class.JJ\"\n@assert Strongest_Extension(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\"\
    , \"LL\", \"MM\"]) == \"my_class.KK\"\n@assert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"\
    JJ\", \"KK\", \"LL\", \"MM\", \"NN\"]) == \"my_class.LL\"\n@assert Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\", \"LL\", \"MM\", \"NN\", \"OO\"]) == \"my_class.MM\"\n@\n\
    using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5q_ih7je.jl:30\nin expression starting at\
    \ /tmp/tmp5q_ih7je.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for i=1:length(extensions)\n        extension_strength[i]\
    \ = count_upper(extensions[i]) - count_lower(extensions[i])\n    end\n    \n \
    \   extension_strength = sort(extension_strength)\n    \n    Strongest_Extension\
    \ = extensions[extension_strength[1]]\n    for i=2:length(extension_strength)\n\
    \        if extension_strength[i] > extension_strength[i-1]\n            Strongest_Extension\
    \ = extensions[extension_strength[i]]\n        end\n    end\n    \n    return\
    \ Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n@test Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes a string and a vector of strings as arguments\
    \ and returns a string with the \nfirst letter of each string capitalized.\nExample:\
    \ \n>>> first_letter(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\"MyClass\"\n>>>\
    \ first_letter(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"])\n\"MyClass\"\n\
    >>> first_letter(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\"])\n\"MyClass\"\
    \n>>> first_letter(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\"\
    ])\n\"MyClass\"\n>>> first_letter(\"my_class\", [\"AA\", \"Be\", \"CC\", \"DD\"\
    , \"EE\", \"FF\", \"GG\"])\n\"MyClass\"\n>>> first_letter(\"my_class\", [\"AA\"\
    , \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\"])\n\"MyClass\"\n>>> first_letter(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\"])\n\"MyClass\"\n>>> first_letter(\"my_class\", [\"AA\", \"Be\", \"CC\", \"\
    DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\"])\n\"MyClass\"\n>>> first_letter(\"\
    my_class\", [\"AA\", \"Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"\
    II\", \"JJ\", \"KK\"])\n\"MyClass\"\n>>> first_letter(\"my_class\", [\"AA\", \"\
    Be\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\",\
    \ \"LL\"])\n\"MyClass\"\n>>> first_letter(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    , \"DD\", \"EE\", \"FF\", \"GG\", \"HH\", \"II\", \"JJ\", \"KK\", \"LL\", \"MM\"\
    ])\n\"MyClass\"\n>>> first_letter(\"my_class\", [\"AA\nusing Test\n\n@testset\
    \ begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3fv18tih.jl:36\nin expression starting at\
    \ /tmp/tmp3fv18tih.jl:36\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(length(extensions))\n\
    \    \n    for i = 1:length(extensions)\n        extension_strength[i] = length(extensions[i])\
    \ - length(replace(extensions[i], uppercase(extensions[i]), \"\"))\n    end\n\
    \    \n    Strongest_Extension = extensions[argmax(extension_strength)]\n    \n\
    \    return class_name * Strongest_Extension\nend\n</cell>\n<code language=julia-1.5>\n\
    @test Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\
    \n</cell>\n<text>\nExercise 3\nWrite a function that returns the number of characters\
    \ in a string that are not spaces.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = Strongest_Extension;\n\t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"Boku123\", [\"nani\"\
    , \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
    , \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\",\
    \ \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"\
    HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) ==\
    \ \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\"\
    )\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptg21dtst.jl:30\nin expression starting at\
    \ /tmp/tmptg21dtst.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    \n    for (i,extension) in enumerate(extensions)\n\
    \        extension_strength[i] = count_upper(extension) - count_lower(extension)\n\
    \    end\n    \n    idx = findfirst(x -> x > 0, extension_strength)\n    \n  \
    \  if idx != nothing\n        \n        idx = idx[1]\n        \n        extension_strength[idx]\
    \ = -1\n        \n        extension_strength = extension_strength .> -1\n    \
    \    \n        extension_strength[extension_strength .== true] = idx\n       \
    \ \n        idx = extension_strength .== true\n        \n        extension_strength[idx]\
    \ = idx[1]\n        \n        extension_strength = extension_strength .> -1\n\
    \        \n        extension_strength[extension_strength .== true] = idx\n   \
    \     \n        idx = extension_strength .== true\n        \n        extension_strength[idx]\
    \ = idx[1]\n        \n        extension_strength = extension_strength .> -1\n\
    \        \n        extension_strength[extension_strength .== true] = idx\n   \
    \     \n        idx = extension_strength .== true\n        \n        extension_strength[idx]\
    \ = idx[1]\n        \n        extension_strength = extension_strength .> -1\n\
    \        \n        extension_strength[extension_strength .== true] = idx\n   \
    \     \n        idx = extension_strength .== true\n        \n        extension_strength[idx]\
    \ = idx[1]\n        \n        extension_strength = extension_strength .> -1\n\
    \        \n        extension_strength[extension_strength .== true] = idx\n   \
    \     \n        idx = extension_strength .== true\n        \n        extension_strength[idx]\
    \ = idx[1]\n        \n        extension_strength = extension_strength .> -1\n\
    \        \n        extension_strength[extension_strength .== true] = idx\n   \
    \     \n        idx = extension_strength .== true\n        \n        extension_strength[idx]\
    \ = idx[1]\n        \n        extension_strength = extension_strength .> -1\n\
    \        \n        extension_strength[extension_strength .== true] = idx\n   \
    \     \n        idx = extension_strength .== true\n        \n        extension_strength[idx]\
    \ = idx[1]\n        \n        extension_strength = extension_strength .> -1\n\
    \        \n        extension_strength[extension_strength .== true] = idx\n   \
    \     \n        idx = extension_strength .== true\n        \n        extension_strength[idx]\
    \ = idx[1]\n        \n        extension_strength = extension_strength .> -1\n\
    \        \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptqr2d57n.jl:1\nin expression starting at /tmp/tmptqr2d57n.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    extension_strength = zeros(Int,\
    \ length(extensions))\n    for (i,ext) in enumerate(extensions)\n        extension_strength[i]\
    \ = length(ext) - length(replace(ext, upper(ext), \"\"))\n    end\n    \n    idx\
    \ = findfirst(x -> x > 0, extension_strength)\n    if idx != nothing\n       \
    \ idx = idx[1]\n    else\n        idx = length(extensions)\n    end\n    \n  \
    \  return class_name * \".\" .* extensions[idx]\nend\n</cell>\n<code language=julia-1.5>\n\
    @time Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes a string and a vector of strings as arguments\
    \ and returns a string with the \nextensions replaced by the strings in the vector.\
    \ \nFor example, if you are given \"my_class\" as the class name and a vector\
    \ of the \nextensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\
    \ return 'my_class.SErviNGSliCes' \nsince 'SErviNGSliCes' is the strongest extension\
    \ (its strength is -1).\nHint: Use Strongest_Extension defined above.\nusing Test\n\
    \n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\"\
    , \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) ==\
    \ \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp631tko0r.jl:34\nin expression starting at\
    \ /tmp/tmp631tko0r.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"You will be given the name of a class (a string) and a vector of\
    \ extensions.\n    The extensions are to be used to load additional classes to\
    \ the class. The\n    strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n    letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n    in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n    You should find the strongest extension\
    \ and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the vector.\n    For example, if you are\
    \ given \"Slices\" as the class and a vector of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
    \ extensions::Vector{String})::String \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nusing Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\
    \t@test(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\n\t@test(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    )\n\t@test(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\"\
    )\n\t@test(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"\
    __HAHA.123\")\n\t@test(candidate(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"\
    WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\")\n\t@test(candidate(\"\
    finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\
    \t@test(candidate(\"_\", [\"Bb\", \"91245\"]) == \"_.Bb\")\n\t@test(candidate(\"\
    Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplekh7ykt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplekh7ykt.jl:1\n\
    in expression starting at /tmp/tmplekh7ykt.jl:1\n"
  stdout: ''
