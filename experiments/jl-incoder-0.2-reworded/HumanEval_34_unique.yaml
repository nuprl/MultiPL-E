name: HumanEval_34_unique
language: jl
prompt: "\"\"\"Return sorted unique elements in a vector\n    >>> unique([5, 3, 5,\
  \ 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\nfunction unique(l::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = unique;\n\t@test(candidate([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123])\nend\n"
completions: ["    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n\
    \            unique[x] = true\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a tags=julia,set |>\n<| c |>\nThis does not answer the question.\
    \ The question is about a Julia set and not a Julia vector. Your answer does not\
    \ answer the question either.\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ a Julia set solution. Hope it helps.\n<|/ c |>\n<| c |>\nI believe that your\
    \ answer does not answer the question. The question is about a Julia set and not\
    \ a Julia vector. Your answer does not answer the question either.\n<|/ c |>\n\
    <| c |>\nI edited my answer to include a Julia set solution. Hope it helps.\n\
    <|/ c |>\n<| c |>\nI believe that your answer does not answer the question. The\
    \ question is about a Julia set and not a Julia vector. Your answer does not answer\
    \ the question either.\n<|/ c |>\n<| a |>\nThe Julia set package has a function\
    \ called Sets.unique, which does exactly what you want.\n<code>\njulia> using\
    \ Sets", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n\
    \            push!(unique, i)\n        end\n    end\n    return unique\nend\n\
    </cell>\n<code language=julia-1.5>", "    unique = Vector{Int64}()\n    unique.push!(l)\n\
    \    unique\nend\n</cell>\n<text>\nThe function unique returns a sorted unique\
    \ vector of the type Vector{Int64}", "    unique = Set()\n    for i in l\n   \
    \     if !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n\
    \    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n \
    \           push!(unique, i)\n            seen[i] = true\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n\
    \    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n \
    \           push!(unique, i)\n            seen.add(i)\n        end\n    end\n\
    \    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort\nend\nunique(l::Vector{Int64})::Vector{Int64", "    seen\
    \ = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen[i] = true\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 |>\nThe accepted answer by is very elegant and efficient, but I\
    \ thought I'd add an alternative that doesn't require a loop. \n<code>", "   \
    \ seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen[i] = true\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = sort(unique(l))\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,set |>\n<| a dscore=2 |>\nThe Julia standard library has many useful\
    \ tools for working with sets. Here are a couple examples:\n<code>\njulia> using\
    \ Sets", "    seen = Set()\n    uniques = Vector{Int64}()\n    for x in l\n  \
    \      if !seen.add(x)\n            push!(uniques, x)\n        end\n    end\n\
    \    return uniques\nend\n</cell>\n<code language=julia-1.5>", "    unique = sort(unique(l))\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.3>\n@time unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns the unique elements of a vector, sorted in ascending order.", "    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            push!(unique,\
    \ x)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis is not the fastest solution. `unique` uses `Set` internally, so\
    \ it's O(n) complexity. `sort!` uses `sort` which is O(n log n) complexity. `sort!`\
    \ also uses `unique` which is O(n) complexity. `sort!` also uses `sort` which\
    \ is O(n log n) complexity. `sort!` also uses `unique` which is O(n) complexity.\
    \ `sort!` also uses `sort` which is O(n log n) complexity. `sort!` also uses `unique`\
    \ which is O(n) complexity. `sort!` also uses `sort` which is O(n log n) complexity.\
    \ `sort!` also uses `unique` which is O(n) complexity. `sort!` also uses `sort`\
    \ which is O(n log n) complexity. `sort!` also uses `unique` which is O(n) complexity.\
    \ `sort!` also uses `sort` which is O(n log n) complexity. `sort!` also uses `unique`\
    \ which is O(n) complexity. `sort!` also uses `sort` which is O(n log n) complexity.\
    \ `sort!` also uses `unique` which is O(n) complexity. `sort!` also uses `sort`\
    \ which is O(n log n) complexity. `sort!` also uses `unique` which is O(n) complexity.\
    \ `sort!` also uses `sort` which is O(n log n) complexity. `sort!` also uses `unique`\
    \ which is O(n) complexity. `sort!` also uses `sort` which is O(n log n) complexity.\
    \ `sort!` also uses `unique` which is O(n) complexity. `sort!` also uses `sort`\
    \ which is O(n log n) complexity. `sort!` also uses `unique` which is O(n) complexity.\
    \ `sort!` also uses `sort` which is O(n log n) complexity. `sort!` also uses `unique`\
    \ which is O(n) complexity. `sort!` also uses `sort` which is O(n log n) complexity. ",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nThis doesn't work if you have repeated elements\
    \ in the vector. For example, `unique([1,1,2,3])` returns `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nYes, it does. I tested it before posting it. I just added a comment to\
    \ the question asking if that was the case.\n<|/ c |>\n<| c |>\nI tested it again\
    \ and it works. I must have done something wrong when I first tried it.\n<|/ c\
    \ |>\n<| c |>\nI tested it again and it works. I must have done something wrong\
    \ when I first tried it.\n<|/ c |>\n<| c |>\nI tested it again and it works. I\
    \ must have done something wrong when I first tried it.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI wrote a package for this:\nhttps://github.com/kamiyamane/UniqueArrays.jl\n\
    <code>\njulia> using UniqueArrays", "    unique = Vector{Int64}()\n    unique.push!(l)\n\
    \    unique\nend\n</cell>\n<code language=julia-1.3>", "    unique = sort(l)\n\
    \    unique[unique(unique)==l] = -1\n    return unique\nend\n</cell>\n<code language=julia-1.3>",
  "    seen = Set()\n    unique = Vector{Int64}()\n    for elt in l\n        if !has(seen,\
    \ elt)\n            push!(unique, elt)\n            push!(seen, elt)\n       \
    \ end\n    end\n    return unique\nend\n</cell>\n<text>\nThe unique function above\
    \ is very similar to the built-in function unique. Let's compare the performance\
    \ of both:", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n\
    \            push!(unique, i)\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a tags=julia,set |>\n<| c |>\nThis is not the most efficient solution.\
    \ `unique` has O(n) complexity, while `sort` has O(n log n). `sort` can be done\
    \ in O(n log n) by using a radix sort.\n<|/ c |>\n<| c |>\nI agree, `sort` can\
    \ be done in O(n log n) by using a radix sort, but `unique` has O(n) complexity.\
    \ `sort` can be done in O(n log n) by using a radix sort, but `unique` has O(n)\
    \ complexity. `sort` can be done in O(n log n) by using a radix sort, but `unique`\
    \ has O(n) complexity. `sort` can be done in O(n log n) by using a radix sort,\
    \ but `unique` has O(n) complexity. `sort` can be done in O(n log n) by using\
    \ a radix sort, but `unique` has O(n) complexity. `sort` can be done in O(n log\
    \ n) by using a radix sort, but `unique` has O(n) complexity. `sort` can be done\
    \ in O(n log n) by using a radix sort, but `unique` has O(n) complexity. `sort`\
    \ can be done in O(n log n) by using a radix sort, but `unique` has O(n) complexity.\
    \ `sort` can be done in O(n log n) by using a radix sort, but `unique` has O(n)\
    \ complexity. `sort` can be done in O(n log n) by using a radix sort, but `unique`\
    \ has O(n) complexity. `sort` can be done in O(n log n) by using a radix sort,\
    \ but `unique` has O(n) complexity. `sort` can be done in O(n log n) by using\
    \ a radix sort, but `unique` has O(n) complexity. `sort` can be done in O(n log\
    \ n) by using a radix sort, but `unique` has O(n) complexity. `sort` can be done\
    \ in O(n log n) by using a radix sort, but `unique` has O(n) ", "    unique =\
    \ Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't work if you have repeated elements in the vector. For example,\
    \ `unique([1,2,2,3])` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have repeated elements in the vector. For example, `unique([1,2,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work if you have repeated\
    \ elements in the vector. For example, `unique([1,2,2,3])` returns `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have repeated elements in the vector.\
    \ For example, `unique([1,2,2,3])` returns `[1,2,3]`.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "    unique = Vector{Int64}()\n    unique.push!(l)\n    while length(unique)\
    \ > length(l)\n        delete!(unique, minimum(unique))\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for x in l\n\
    \        if !haskey(unique, x)\n            unique[x] = true\n        end\n  \
    \  end\n    return unique\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThe `Set`\
    \ solution is much faster than the other solutions here.\n<|/ c |>\n<| c |>\n\
    The `Set` solution is much faster than the other solutions here.\n<|/ c |>\n<|\
    \ a dscore=3 |>\n<code>\njulia> using Statistics", "    unique = Set()\n    for\
    \ x in l\n        if !haskey(unique, x)\n            push!(unique, x)\n      \
    \  end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,unique,arrays\
    \ |>\n<| a dscore=2 |>\nI like using Sets to do this. \n<code>\njulia> using Sets",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return collect(unique)\nend\n</code>\n\
    <|/ a tags=julia,set |>\n<| c |>\nThis does not answer the question. `unique`\
    \ returns a `Set`, not an `Array`.\n<|/ c |>\n<| c |>\nI guess I misunderstood\
    \ the question. I thought he was asking for a way to convert a Vector into a Set.\
    \ I'll edit my answer to reflect this.\n<|/ c |>\n<| c |>\nI believe this answer\
    \ is now the best one. `unique` returns a `Set`, not an `Array`.\n<|/ c |>\n<|\
    \ a tags=julia,set |>\nI believe this answer is now the best one. unique returns\
    \ a Set, not an Array. \n<code>\njulia> using StatsBase", "    unique = Vector{Int64}()\n\
    \    for x in l\n        if !contains(unique, x)\n            push!(unique, x)\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,set |>\n<| a tags=julia,set |>\nThe Julia standard library has\
    \ Sets.jl which has many useful methods for working with sets. \n<code>\njulia>\
    \ using Sets", "    unique = Vector{Int64}()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            push!(unique, x)\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the number of unique\
    \ elements in a vector\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    6\n\
    \    \"\"\"", "    unique = sort(l)\n    unique = unique[unique(:) .!= l]\n  \
    \  return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nI wrote a function that does this in Julia 1.5.1:\n\
    <code>", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n\
    \            push!(unique, i)\n        end\n    end\n    return unique\nend\n\
    unique(l::Vector{Int64})::Vector{Int64} \n    unique = Set()\n    for i in l\n\
    \        if !haskey(unique, i)\n            push!(unique, i)\n        end\n  \
    \  end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64} \n   \
    \ unique = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n      \
    \      push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n      \
    \      push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n      \
    \      push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n      \
    \      push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n      \
    \      push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n      \
    \      push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n      \
    \      push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n      \
    \      push!(unique, ", "    unique = sort(unique(l))\n    return unique\nend",
  "    unique = Vector{Int64}()\n    unique.push!(l)\n    unique\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns the unique elements of a vector, sorted\
    \ and in increasing order.", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !seen.add(x)\n            push!(unique, x)\n     \
    \   end\n    end\n    return unique\nend\n</cell>\n<text>\nExercise 2\nWrite a\
    \ function that returns the unique elements of a vector, sorted in ascending order.",
  "    unique = Vector{Int64}()\n    for x in l\n        if !haskey(unique, x)\n \
    \           push!(unique, x)\n        end\n    end\n    unique\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis doesn't work if there are repeated elements\
    \ in the input vector. For example, `unique([5, 3, 5, 2, 3, 3, 9, 0, 123, 5])`\
    \ returns `[5, 3, 9, 0, 123]` instead of `[0, 2, 3, 5, 9, 123]`.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nI wrote a package called UniqueArrays.jl for Julia that does\
    \ exactly that:\n<code>\njulia> using UniqueArrays", "    unique = Set()\n   \
    \ for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n  \
    \      end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=4 |>\n<| a\
    \ dscore=3 |>\nI believe that Julia has a built-in function called unique! which\
    \ does exactly what you want.\n<|/ a tags=julia,unique,arrays |>\n<| a tags=julia,unique,arrays\
    \ |>\nThe accepted answer doesn't work for me. Here's a version that does:\n<code>",
  "    unique = sort(l)\n    unique[unique(unique)==l] = -1\n    return unique\nend\n\
    </cell>\n<code language=julia-1.5>", "    unique = Set()\n    for i in l\n   \
    \     if !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n\
    \    return unique\nend\nunique(l::Vector{Int64}) = unique(l).sorted\nunique(l::Vector{T})\
    \ where T<:Integer  = unique(sort(l))\nunique(l::Vector{T}) where T<:Float64 =\
    \ unique(sort(l))\nunique(l::Vector{T}) where T<:Complex  = unique(sort(l))\n\
    unique(l::Vector{T}) where T<:Bool = unique(sort(l))\nunique(l::Vector{T}) where\
    \ T<:String  = unique(sort(l))\nunique(l::Vector{T}) where T<:Symbol  = unique(sort(l))\n\
    unique(l::Vector{T}) where T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where\
    \ T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where T<:Any  = unique(sort(l))\n\
    unique(l::Vector{T}) where T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where\
    \ T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where T<:Any  = unique(sort(l))\n\
    unique(l::Vector{T}) where T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where\
    \ T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where T<:Any  = unique(sort(l))\n\
    unique(l::Vector{T}) where T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where\
    \ T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where T<:Any  = unique(sort(l))\n\
    unique(l::Vector{T}) where T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where\
    \ T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where T<:Any  = unique(sort(l))\n\
    unique(l::Vector{T}) where T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where\
    \ T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where T<:Any  = unique(sort(l))\n\
    unique(l::Vector{T}) where T<:Any  = unique(sort(l))\nunique(l::Vector{T}) where\
    \ T<:Any  = unique(", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis doesn't work if you have\
    \ a vector of strings or other objects that aren't comparable. For example, `unique([1,\
    \ \"a\", 2])` returns `[1, \"a\", 2]`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have a vector of strings or other objects that aren't comparable. For example,\
    \ `unique([1, \"a\", 2])` returns `[1, \"a\", 2]`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a vector of strings or other objects that aren't comparable.\
    \ For example, `unique([1, \"a\", 2])` returns `[1, \"a\", 2]`.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work if you have a vector of strings or other objects that\
    \ aren't comparable. For example, `unique([1, \"a\", 2])` returns `[1, \"a\",\
    \ 2]`.\n<|/ c |>\n<| a tags=julia,arrays |>\nI wrote a package called UniqueArrays.jl\
    \ that does exactly that. It also has a few other useful functions. You can install\
    \ it by running Pkg.add(\"UniqueArrays\") in Julia.\n<|/ a dscore=4 |>\n<| c |>\n\
    This package is no longer maintained. [UniqueArrays.jl](https://github.com/kamiyamane/UniqueArrays.jl)\
    \ has been updated.\n<|/ c |>\n<| a dscore=4 |>\nI wrote a package called UniqueArrays.jl\
    \ that does exactly that. It also has a few other useful functions. You can install\
    \ it by running Pkg.add(\"UniqueArrays\") in Julia.\n<|/ a tags=julia,arrays |>\n\
    <| c |>\nThis package is no longer maintained. [UniqueArrays.jl](https://github.com/kamiyamane/UniqueArrays.jl)\
    \ has been updated.\n<|/ c |>\n<| a dscore=3 |>\nI wrote a package called UniqueArrays.jl\
    \ that does exactly that. It also has a few other useful functions. You can install\
    \ it by running Pkg.add(\"UniqueArrays\") in Julia.\n<|/ a tags=julia,arrays |>\n\
    <| c |>\nThis package is no longer maintained. [UniqueArrays.jl](https://github.com/kamiyamane/UniqueArrays.jl)\
    \ has been updated.\n<|/ c |>\n<| a tags=julia,", "    unique = Set()\n    for\
    \ i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n      \
    \  end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nIn Julia 1.3 you can use the function unique to remove duplicates from a\
    \ vector:\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n\
    \ 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a tags=julia |>\n<| a |>\nIn Julia 1.3\
    \ you can use unique to remove duplicates from a vector:\n<code>\njulia> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n\
    \ 123\n</code>\n<|/ a tags=julia dscore=2 |>\n<| a |>\nIn Julia 1.3 you can use\
    \ unique to remove duplicates from a vector:\n<code>\njulia> unique([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n\
    </code>\n<|/ a dscore=1 tags=julia |>\n<| a dscore=1 |>\nIn Julia 1.3 you can\
    \ use unique to remove duplicates from a vector:\n<code>\njulia> unique([5, 3,\
    \ 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n\
    </code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nIn Julia 1.3 you can use unique\
    \ to remove duplicates from a vector:\n<code>\njulia> unique([5, 3, 5, 2, 3, 3,\
    \ 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nIn Julia 1.3 you can use unique to remove\
    \ duplicates from a vector:\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=1 |>\nIn Julia 1.3 you can use unique to remove duplicates from\
    \ a vector:\n<code>\njulia> unique([", "    unique = Set()\n    for x in l\n \
    \       unique += x\n    end\n    unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to avoid the for loop?\n<|/ c |>\n<| c |>\nI guess you could use [`unique`](https://docs.julialang.org/en/v1/base/collections/#Base.unique)\
    \ but that would require you to convert the `Vector{Int64}` into a `Set` first,\
    \ which would require a for loop. Another option would be to convert the `Vector{Int64}`\
    \ into a `Set` first and then convert it back to a `Vector{Int64}`, but that would\
    \ require a for loop as well.\n<|/ c |>\n<| c |>\nI added a solution that avoids\
    \ the for loop\n<|/ c |>\n<| c |>\nI added a solution that avoids the for loop\n\
    <|/ c |>\n<| a dscore=1 |>\nI like the answer by but I would suggest a slight\
    \ variation that avoids the for loop:\n<code>\njulia> function unique(l::Vector{Int64})::Vector{Int64}\n\
    \           unique = Set()\n           for i in l\n               push!(unique,\
    \ i)\n           end\n           return unique\n       end\nunique (generic function\
    \ with 1 method)", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "    unique = Set()\n\
    \    for i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the number of unique elements in a vector\n    >>> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n    6\n    \"\"\"", "    unique = Set()\n    for\
    \ i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n      \
    \  end\n    end\n    return unique\nend", "    unique = Vector{Int64}()\n    unique.push!(l)\n\
    \    while !unique.isEmpty do\n        unique.push!(unique(unique(unique.tail)))\n\
    \    end\n    return unique\nend\nunique", "    unique = sort(unique(l))\n   \
    \ return unique\nend", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a |>\n<| a tags=julia,set |>\n<code>\njulia> using Sets", " \
    \   seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if i not\
    \ in seen \n            push!(unique, i)\n            push!(seen, i)\n       \
    \ end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", " \
    \   unique = Set()\n    for x in l\n        if !haskey(unique, x)\n          \
    \  unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nThis doesn't work if you have a vector of strings or\
    \ other types that aren't comparable. For example, `unique([\"a\", \"b\", \"c\"\
    , \"c\", \"c\"])` returns `[\"a\", \"b\", \"c\"]`.\n<|/ c |>\n<| c |>\nThe question\
    \ was about sorting and unique elements. I believe this answer does exactly that.\n\
    <|/ c |>\n<| c |>\nI believe it does, but it's worth noting that this solution\
    \ doesn't work for vectors of strings or other types that aren't comparable. For\
    \ example, `unique([\"a\", \"b\", \"c\", \"c\", \"c\"])` returns `[\"a\", \"b\"\
    , \"c\"]`.\n<|/ c |>\n<| c |>\nYes, I agree. I've added a note about that.\n<|/\
    \ c |>\n<| a dscore=3 |>\nI like to use Julia's built-in Set() for this purpose:\n\
    <code>\njulia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123])\nSet{Int64}([2, 3, 5, 9, 0,\
    \ 123, 5])\n</code>\n<|/ a tags=julia,unique,sorting |>\n<| c |>\nThis doesn't\
    \ work if you have a vector of strings or other types that aren't comparable.\
    \ For example, `Set([5, 3, 5, 2, 3, 3, 9, 0, 123])` returns `Set{Int64}([2, 3,\
    \ 5, 9, 0, 123, 5])`.\n<|/ c |>\n<| c |>\nYes, I agree. I've added a note about\
    \ that.\n<|/ c |>\n<| a dscore=3 |>\nThe most efficient way is to use Sets:\n\
    <code>\njulia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123])\nSet{Int64}([2, 3, 5, 9, 0,\
    \ 123, 5])\n</code>\n<|/ a tags=julia,unique,sorting |>\n<| c |>\nThis doesn't\
    \ work if you have a vector of strings or other types that aren't comparable.\
    \ For example, `Set([5, 3, 5, 2, 3, 3, 9, 0, 123])` returns `Set{Int64}([2, 3,\
    \ 5, 9, 0, 123, 5])`.\n<|/ c |>\n<| c |>\nYes, I agree. I've added a note about\
    \ that.\n<|/ c |>\n<| a dscore=3 |>\nThe most efficient way is to use Sets:\n\
    <code>\njulia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123])\nSet{Int64}", "    unique =\
    \ Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=julia,arrays |>\nI came up with a solution that is\
    \ similar to what was proposed in the other answers, but I wanted to see how it\
    \ compared to other solutions. I used the BenchmarkTools package to compare the\
    \ different solutions.\n<code>\nusing BenchmarkTools", "    unique = Vector{Int64}()\n\
    \    for x in l\n        if !contains(unique, x)\n            push!(unique, x)\n\
    \        end\n    end\n    return unique\nend\n</code>\n<|/ a |>\n<| a tags=julia,arrays\
    \ |>\nI wrote a package called UniqueArrays.jl that does this for you:\n<code>\n\
    julia> using UniqueArrays", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !seen.add(x)\n            push!(unique, x)\n     \
    \   end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.3>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.3>", "    unique = Vector{Int64}()\n    unique.push!(l)\n \
    \   unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis does not answer\
    \ the question, which is about sorting and removing duplicates.\n<|/ c |>\n<|\
    \ c |>\nThe question was about sorting and removing duplicates. I thought this\
    \ was the answer to the question. Perhaps I misunderstood the question?\n<|/ c\
    \ |>\n<| c |>\nI believe this answer does answer the question. `unique` removes\
    \ duplicates, `sort` sorts the vector, and `sort!` sorts the vector in-place.\n\
    <|/ c |>\n<| c |>\nThe question was about sorting and removing duplicates. I thought\
    \ this was the answer to the question. Perhaps I misunderstood the question?\n\
    <|/ c |>\n<| c |>\nThe question was about sorting and removing duplicates. I thought\
    \ this was the answer to the question. Perhaps I misunderstood the question?\n\
    <|/ c |>\n<| a dscore=4 |>\nThe most efficient way is to use Sets:\n<code>\njulia>\
    \ using Sets", "    unique = Vector{Int64}()\n    unique.push!(l)\n    unique\n\
    end", "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n   \
    \         push!(unique, x)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.4>", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Vector{Int64}()\n    unique.push!(l)\n\
    \    unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = sort(unique(l))\n\
    \    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\n`unique`\
    \ already sorts the input vector, so you don't need to do that yourself.\n<|/\
    \ c |>\n<| c |>\nThanks, I didn't know that. I've updated my answer.\n<|/ c |>\n\
    <| a tags=julia,arrays |>\nI came up with a simple solution that works for me:\n\
    <code>", "    unique = sort(unique(l))\n    return unique\nend", "    unique =\
    \ Set()\n    for i in l\n        unique += [i]\n    end\n    unique\nend\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the number of unique elements\
    \ in a vector\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    6\n    \"\"\"",
  "    unique = Vector{Int64}()\n    for i in l\n        if !contains(unique, i)\n\
    \            push!(unique, i)\n        end\n    end\n    unique\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=julia,arrays |>\n<code>\njulia> using Statistics",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis doesn't work if you have repeated elements in the\
    \ vector. For example, `unique([1,1,2,3])` returns `[1,2,3]`, but should return\
    \ `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I agree. My answer was meant to be a general\
    \ solution, not a solution that would work for all cases. I should have added\
    \ a disclaimer about that.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a function that\
    \ does this in Julia. \n<code>", "    unique = Vector{Int64}()\n    unique.push!(l)\n\
    \    unique.sort()\n    unique\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ doesn't answer the question of how to sort a vector in place. Also, `unique`\
    \ returns a `Vector`, not a `Vector{Int64}`.\n<|/ c |>\n<| c |>\nI added a version\
    \ that does return an `Int64` vector\n<|/ c |>\n<| c |>\n`unique` returns a `Vector{Int64}`\
    \ because `Vector{Int64}` is an alias for `Vector{Int64}`. `Vector{Int64}` is\
    \ an alias for `Vector{Int64}`. `Vector{Int64}` is an alias for `Vector{Int64}`.\n\
    <|/ c |>\n<| c |>\n`Vector{Int64}` is an alias for `Vector{Int64}` is an alias\
    \ for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias for `Vector{Int64}`\
    \ is an alias for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias\
    \ for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias for `Vector{Int64}`\
    \ is an alias for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias\
    \ for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias for `Vector{Int64}`\
    \ is an alias for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias\
    \ for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias for `Vector{Int64}`\
    \ is an alias for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias\
    \ for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias for `Vector{Int64}`\
    \ is an alias for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias\
    \ for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias for `Vector{Int64}`\
    \ is an alias for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias\
    \ for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias for `Vector{Int64}`\
    \ is an alias for `Vector{Int64}` is an alias for `Vector{Int64}` is an alias\
    \ for `Vector{", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\nunique(l::Vector{Int64}) = unique(l).keys\nunique(l::Vector{Int64}, k::Int64)::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = true\n        end\n    end\n    return unique.keys\nend\nunique(l::Vector{Int64},\
    \ k::Int64)::Vector{Int64}\n    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique.keys\n\
    end\nunique(l::Vector{Int64}, k::Int64, v::Int64)::Vector{Int64}\n    unique =\
    \ Set()\n    for x in l\n        if !haskey(unique, x)\n            unique[x]\
    \ = true\n        end\n    end\n    return unique.keys\nend\nunique(l::Vector{Int64},\
    \ k::Int64, v::Int64, v::Int64)::Vector{Int64}\n    unique = Set()\n    for x\
    \ in l\n        if !haskey(unique, x)\n            unique[x] = true\n        end\n\
    \    end\n    return unique.keys\nend\nunique(l::Vector{Int64}, k::Int64, v::Int64,\
    \ v::Int64, v::Int64)::Vector{Int64}\n    unique = Set()\n    for x in l\n   \
    \     if !haskey(unique, x)\n            unique[x] = true\n        end\n    end\n\
    \    return unique.keys\nend\nunique(l::Vector{Int64}, k::Int64, v::Int64, v::Int64,\
    \ v::Int64, v::Int64)::Vector{Int64}\n    unique = Set()\n    for x in l\n   \
    \     if !haskey(unique, x)\n            unique[x] = true\n        end\n    end\n\
    \    return unique.keys\nend\nunique(l::Vector{Int64}, k::Int64, v::Int64, v::Int64,\
    \ v::Int64, v::Int64, v::Int64)::Vector{Int64}\n    unique = Set()\n    for x\
    \ in l\n        if !haskey(unique, x)\n            unique[x] = true\n        end\n\
    \    end\n    return unique.keys\nend\nunique(l::Vector{Int64}, k::Int64, v::Int64,\
    \ v::Int64, ", "    seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n\
    \        if !haskey(seen, i)\n            push!(unique, i)\n            seen[i]\
    \ = true\n        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a tags=julia,arrays |>\n<code>\njulia> function unique(vec)\n       \
    \    seen = Set()\n           unique = Vector{Int}()\n           for i in vec\n\
    \               if !haskey(seen, i)\n                   push!(unique, i)\n   \
    \                seen[i] = true\n               end\n           end\n        \
    \   return unique\n       end\nunique (generic function with 1 method)", "   \
    \ unique = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique.value\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is not the most efficient solution.\
    \ `unique` will have to traverse the entire list to find unique elements. A better\
    \ solution is to use `Set` as suggested by [this answer](https://stackoverflow.com/a/47708457/1090562)\n\
    <|/ c |>\n<| a dscore=2 |>\nI wanted to add an answer that uses no external packages\
    \ and is faster than the other answers. I used the Julia BenchmarkTools package\
    \ to compare the different methods. \n<code>\nusing BenchmarkTools", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64}) =\
    \ unique(l).sorted()\nunique(l::Vector{Int64}, k::Int64)::Vector{Int64} \n   \
    \ unique = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n        if i == k\n            break\n        end\n    end\n\
    \    return unique\nend\nunique(l::Vector{Int64}, k::Int64) = unique(l).sorted(k)\n\
    unique(l::Vector{Int64}, k::Int64, v::Int64)::Vector{Int64} \n    unique = Set()\n\
    \    for i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n\
    \        end\n        if i == k\n            break\n        end\n        if i\
    \ == v\n            break\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ k::Int64, v::Int64) = unique(l).sorted(k, v)\nunique(l::Vector{Int64}, k::Int64,\
    \ v::Int64, w::Int64)::Vector{Int64} \n    unique = Set()\n    for i in l\n  \
    \      if !haskey(unique, i)\n            push!(unique, i)\n        end\n    \
    \    if i == k\n            break\n        end\n        if i == v\n          \
    \  break\n        end\n        if i == w\n            break\n        end\n   \
    \ end\n    return unique\nend\nunique(l::Vector{Int64}, k::Int64, v::Int64, w::Int64)\
    \ = unique(l).sorted(k, v, w)\nunique(l::Vector{Int64}, k::Int64, v::Int64, w::Int64,\
    \ x::Int64)::Vector{Int64} \n    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n        if i == k\n         \
    \   break\n        end\n        if i == v\n            break\n        end\n  \
    \      if i == w\n            break\n        end\n        if i == x\n        \
    \    break\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ k::Int64, v::Int64, w::Int64, x::Int64) = unique(l).sorted(k, v, w, x)\nunique(l::Vector{Int64},\
    \ k::Int64, v::Int64, w::Int64, x::Int64, y::Int64)::Vector{Int64} \n    unique\
    \ = Set()\n", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\nunique(l::Vector{Int64})::Vector{Int64}\n    unique = Set()\n    for x in\
    \ l\n        if !haskey(unique, x)\n            unique[x] = true\n        end\n\
    \    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n  \
    \  unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n         \
    \   unique[x] = ", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for i in l\n        if !haskey(seen, i)\n            push!(unique, i)\n \
    \           seen[i] = true\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that takes a vector of integers and returns the number\
    \ of unique elements in the vector. For example, unique([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123]) should return 4.", "    unique = sort(l)\n    unique[unique(unique)==l]\
    \ = -1\n    return unique\nend\n</cell>\n<code language=julia-1.5>\n@time unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nExercise: Write a function that\
    \ returns the unique elements of a vector, sorted in ascending order.", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nThis doesn't work for me. `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])`\
    \ returns `[5, 3, 9, 123]` instead of `[0, 2, 3, 5, 9, 123]`.\n<|/ c |>\n<| c\
    \ |>\nIt works for me on Julia 0.6.2\n<|/ c |>\n<| c |>\nIt works for me on Julia\
    \ 0.6.2\n<|/ c |>\n<| c |>\nIt works for me on Julia 0.6.2\n<|/ c |>\n<| a dscore=4\
    \ |>\nThe most efficient way is to use Sets.jl. \n<code>\njulia> using Sets",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(unique(sort(l)))\nend\nunique(l::Vector{Int64})::Vector", "  \
    \  unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.4>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\nunique", "    seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n\
    \        if !haskey(seen, i)\n            push!(unique, i)\n            seen[i]\
    \ = true\n        end\n    end\n    return unique\nend", "    unique = Set()\n\
    \    for x in l\n        if !unique.contains(x)\n            unique.add(x)\n \
    \       end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.3>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.3>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>\nunique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns the number of unique\
    \ elements in a vector\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    6\n\
    \    \"\"\"", "    unique = Set()\n    for i in l\n        unique.add(i)\n   \
    \ end\n    unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nI believe\
    \ this should be `unique = Set()`, not `unique = Set()[]`.\n<|/ c |>\n<| c |>\n\
    Thanks, I fixed it.\n<|/ c |>\n<| a tags=julia,arrays |>\nA more Julian way of\
    \ doing this would be to use Sets:\n<code>\njulia> a = [1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2,\
    \ 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,\
    \ 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,\
    \ 1, 2, 3, 1, 2, ", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end", "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n   \
    \         unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a package that does this in Julia.\
    \ \n<code>\nusing DataFrames\nusing DataFramesMeta", "    unique = Set()\n   \
    \ for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n  \
    \      end\n    end\n    return collect(unique)\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\n`unique` doesn't preserve order, so this doesn't work as intended.\n\
    <|/ c |>\n<| c |>\nI didn't know that `unique` doesn't preserve order. Thanks\
    \ for the info!\n<|/ c |>\n<| a dscore=2 |>\nI believe that you can just use Sets:\n\
    <code>\njulia> Set([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "    unique = Set()\n    for i in l\n        unique.add(i)\n    end\n    return\
    \ unique\nend\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n    unique\
    \ = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n           \
    \ push!(unique, i)\n            seen[i] = true\n        end\n    end\n    return\
    \ unique\nend\nunique(l::Vector{Int64}) = unique(l).sorted\nunique(l::Vector{Float64})\
    \ = unique(l).sorted\nunique(l::Vector{String}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})\
    \ = unique(l).sorted\nunique(l::Vector{Any}) = unique(l).sorted\nunique(l::Vector{Any})",
  "    seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen.add(i)\n        end\n   \
    \ end\n    return unique\nend\nunique(l::Vector{Int64}) = unique(l,Set())\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend\nunique(l::Vector{Int64},\
    \ seen::Set{Int64})::Vector{Int64} \n    if !haskey(seen, l)\n        push!(unique,\
    \ l)\n        seen.add(l)\n    end\n    return unique\nend", "    seen = Set()\n\
    \    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n \
    \           push!(unique, i)\n            seen[i] = true\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<text>\nunique! modifies the original vector",
  "    unique = Set()\n    for x in l\n        push!(unique, x)\n    end\n    unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for i in l\n        if !haskey(seen, i)\n            push!(unique, i)\n \
    \           seen[i] = true\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis code does not work. `unique` returns a `Vector{Int64}`\
    \ but `unique!` expects a `Vector{Int}`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I've updated the code accordingly.\n<|/ c |>\n<| a dscore=4 |>\nThe\
    \ accepted answer does not work for me. \n<code>\njulia> unique([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])\nERROR: MethodError: no method matching unique!(::Array{Int64,1})\n\
    </code>\nI used the code from here and changed it a little bit:\n<code>", "  \
    \  unique = Set()\n    for x in l\n        if !unique.contains(x)\n          \
    \  unique.add(x)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    seen = Set()\n    unique = Set()\n    for x in l\n\
    \        if !seen.add(x)\n            unique.add(x)\n        end\n    end\n  \
    \  return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n\
    \    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n \
    \           push!(unique, i)\n            seen.add(i)\n        end\n    end\n\
    \    return unique\nend\nunique(l::Vector{Int64}) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ dim::Int) = unique(l).sorted[dim]\nunique(l::Vector{Int64}, dim::Int, dim2::Int)\
    \ = unique(l).sorted[dim][dim2]\nunique(l::Vector{Int64}, dim::Int, dim2::Int,\
    \ dim3::Int) = unique(l).sorted[dim][dim2][dim3]\nunique(l::Vector{Int64}, dim::Int,\
    \ dim2::Int, dim3::Int, dim4::Int) = unique(l).sorted[dim][dim2][dim3][dim4]\n\
    unique(l::Vector{Int64}, dim::Int, dim2::Int, dim3::Int, dim4::Int, dim5::Int)\
    \ = unique(l).sorted[dim][dim2][dim3][dim4][dim5]\nunique(l::Vector{Int64}, dim::Int,\
    \ dim2::Int, dim3::Int, dim4::Int, dim5::Int, dim6::Int) = unique(l).sorted[dim][dim2][dim3][dim4][dim5][dim6]\n\
    unique(l::Vector{Int64}, dim::Int, dim2::Int, dim3::Int, dim4::Int, dim5::Int,\
    \ dim6::Int, dim7::Int) = unique(l).sorted[dim][dim2][dim3][dim4][dim5][dim6][dim7]\n\
    unique(l::Vector{Int64}, dim::Int, dim2::Int, dim3::Int, dim4::Int, dim5::Int,\
    \ dim6::Int, dim7::Int, dim8::Int) = unique(l).sorted[dim][dim2][dim3][dim4][dim5][dim6][dim7][dim8]\n\
    unique(l::Vector{Int64}, dim::Int, dim2::Int, dim3::Int, dim4::Int, dim5::Int,\
    \ dim6::Int, dim7::Int, dim8::Int, dim9::Int) = unique(l).sorted[dim][dim2][dim3][dim4][dim5][dim6][",
  "    unique = sort(unique(l))\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        push!(unique, i)\n    end\n    return\
    \ unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for\
    \ x in l\n        if !haskey(unique, x)\n            unique[x] = true\n      \
    \  end\n    end\n    return unique\nend\nunique(l::Vector{Int64}) = unique(l).keys\n\
    unique(l::Vector{Float64}) = unique(l).keys\nunique(l::Vector{String}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique(l).keys\n\
    unique(l::Vector{Any}) = unique(l).keys\nunique(l::Vector{Any}) = unique", " \
    \   unique = Set()\n    for x in l\n        if !haskey(unique, x)\n          \
    \  unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sorted\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sorted\n\
    end\nunique(l::Vector", "    unique = Vector{Int64}()\n    for x in l\n      \
    \  if !contains(unique, x)\n            push!(unique, x)\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThe `unique` function\
    \ can be written more concisely as `unique(unique(vec))`.\n<|/ c |>\n<| c |>\n\
    `unique` can be written more concisely as `unique(vec)`.\n<|/ c |>\n<| c |>\n\
    `unique(unique(vec))` will give `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\
    \ instead of `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n<|/ c |>\n\
    <| c |>\n`unique(unique(vec))` will give `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\
    \ instead of `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n<|/ c |>\n\
    <| a tags=julia,unique,arrays |>\n<code>\njulia> using Statistics", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have repeated elements in the array. For\
    \ example, `unique([1,1,2,3])` returns `[1,2,3]` instead of `[1]`.\n<|/ c |>\n\
    <| c |>\nThanks for pointing that out. I've updated the answer to include a version\
    \ that works with repeated elements.\n<|/ c |>\n<| a tags=julia,arrays |>\nThe\
    \ most efficient way is to use Sets:\n<code>\njulia> using Sets", "    unique\
    \ = sort(unique(l))\n    return unique\nend", "    unique = Set()\n    for i in\
    \ l\n        if !haskey(unique, i)\n            push!(unique, i)\n        end\n\
    \    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if you have a vector of strings. `unique([\"a\", \"a\", \"b\", \"c\", \"\
    c\", \"c\"])` returns `[\"a\", \"b\", \"c\"]`\n<|/ c |>\n<| c |>\nThe question\
    \ was about integers, not strings. If you have a vector of strings, you can just\
    \ call `unique` on the strings. `unique([\"a\", \"a\", \"b\", \"c\", \"c\", \"\
    c\"])` returns `[\"a\", \"b\", \"c\"]`\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ My mistake.\n<|/ c |>\n<| a |>\nI wrote a function that does this for me:\n\
    <code>", "    unique = Set()\n    for x in l\n        push!(unique, x)\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Vector{Int64}()\n\
    \    unique.push!(l)\n    unique\nend\n</cell>\n<code language=julia-1.3>", " \
    \   unique = Set()\n    for x in l\n        if !haskey(unique, x)\n          \
    \  unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=julia |>\nHere is a simple and efficient solution:\n\
    <code>", "    unique = Set()\n    for e in l \n        if !haskey(unique, e) \n\
    \            unique[e] = true\n        end\n    end\n    return unique\nend\n\
    </cell>\n<code language=julia-1.3>", "    unique = Set()\n    for x in l\n   \
    \     if !unique.contains(x)\n            unique.add(x)\n        end\n    end\n\
    \    return unique\nend\nunique(l::Vector{Int64}) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ k::Int64)::Vector{Int64}\n    unique = Set()\n    for x in l\n        if !unique.contains(x)\n\
    \            unique.add(x)\n        end\n        if k > 0 && unique.size > k\n\
    \            unique = unique.sorted\n        end\n    end\n    return unique\n\
    end\nunique(l::Vector{Int64}, k::Int64) = unique(l,k).sorted\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l,k)\nunique(l::Vector{Int64}, k::Int64) = unique(l,k)\n\
    unique(l::Vector{Int64}, k::Int64) = unique(l,k)\nunique(l::Vector{Int64}, k::Int64)\
    \ = unique(l,k)\nunique(l::Vector{Int64}, k::Int64) = unique(l,k)\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l,k)\nunique(l::Vector{Int64}, k::Int64) = unique(l,k)\n\
    unique(l::Vector{Int64}, k::Int64) = unique(l,k)\nunique(l::Vector{Int64}, k::Int64)\
    \ = unique(l,k)\nunique(l::Vector{Int64}, k::Int64) = unique(l,k)\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l,k)\nunique(l::Vector{Int64}, k::Int64) = unique(l,k)\n\
    unique(l::Vector{Int64}, k::Int64) = unique(l,k)\nunique(l::Vector{Int64}, k::Int64)\
    \ = unique(l,k)\nunique(l::Vector{Int64}, k::Int64) = unique(l,k)\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l,k)\nunique(l::Vector{Int64}, k::Int64) = unique(l,k)\n\
    unique(l::Vector{Int64}, k::Int64) = unique(l,k)\nunique(l::Vector{Int64}, k::Int64)\
    \ = unique(l,k)\nunique(l::Vector{Int64}, k::Int64) = unique(l,k)\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l,k)\n", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !haskey(seen, x)\n            push!(unique, x)\n \
    \           seen[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0,\
    \ 2, 3, 5, 9, 123]\n</cell>\n<text>\nExercise 3\nWrite a function that returns\
    \ the number of unique elements in a vector\n    >>> unique([5, 3, 5, 2, 3, 3,\
    \ 9, 0, 123]) == 5\n    \"\"\"", "    unique = sort(l)\n    unique = unique[unique(unique)\
    \ .!= 0]\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for x in l\n        push!(unique, x)\n    end\n    return unique\n\
    end", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n   \
    \         push!(unique, i)\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>", "    unique = sort(unique(l))\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for x in l\n\
    \        push!(unique, x)\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nThis doesn't work if you have a `Vector{Int64}`\
    \ that contains `NaN`s.\n<|/ c |>\n<| c |>\nIt doesn't work if you have a `Vector{Int64}`\
    \ that contains `NaN`s because `NaN` is not equal to itself. `NaN != NaN` returns\
    \ `false`. To fix this, you can either use `NaN==NaN` instead of `==`, or you\
    \ can replace `NaN` with `NaN==NaN?NaN:x`.\n<|/ c |>\n<| c |>\nI added a fix for\
    \ that case.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\njulia> using Statistics",
  "    unique = Vector{Int64}()\n    for x in l\n        if !contains(unique, x)\n\
    \            push!(unique, x)\n        end\n    end\n    return unique\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\nI believe that your problem is\
    \ that you are trying to use an Int64 type to store a vector of Int64s. Int64\
    \ is only a 64-bit integer type. \nThe reason why you get an error is because\
    \ you are trying to push a Int64 onto a Vector{Int64}. \nTo fix this problem,\
    \ you can either use an Int128 type or convert your Int64 vector into a Vector{Int64}\
    \ before pushing onto the vector.\n<|/ a dscore=0 |>\n<| c |>\nThank you for your\
    \ answer! I understand that Int64 is only a 64-bit integer type, but I thought\
    \ that Vector{Int64} is also a 64-bit integer type. Do you know why this is?\n\
    <|/ c |>\n<| c |>\n`Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}`\
    \ is a type. `Int64` is a type. `Vector{Int64}` is a type. `Int64` is a type.\
    \ `Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}` is a type. `Int64`\
    \ is a type. `Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}` is\
    \ a type. `Int64` is a type. `Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}`\
    \ is a type. `Int64` is a type. `Vector{Int64}` is a type. `Int64` is a type.\
    \ `Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}` is a type. `Int64`\
    \ is a type. `Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}` is\
    \ a type. `Int64` is a type. `Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}`\
    \ is a type. `Int64` is a type. `Vector{Int64}` is a type. `Int64` is a type.\
    \ `Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}` is a type. `Int64`\
    \ is a type. `Vector{Int64}` is a type. `Int64` is a type. `Vector{Int64}` is\
    \ a type. `Int", "    seen = Set()\n    unique = Vector{Int64}()\n    for x in\
    \ l\n        if !seen.add(x)\n            push!(unique, x)\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<text>\nunique! modifies the original vector",
  "    unique = Set()\n    for x in l\n        unique.add(x)\n    end\n    return\
    \ unique\nend\n</cell>\n<text>\nThe function unique returns a sorted unique vector\
    \ of Int64s.", "    unique = Set()\n    for x in l\n        push!(unique, x)\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64}) =\
    \ unique(l).sort()\nunique(l::Vector{Int64}, k::Int64)::Vector{Int64} \n    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique.sort()[1:k]\nend\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort()\
    \ [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort()\
    \ [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort()\
    \ [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort()\
    \ [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort()\
    \ [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort()\
    \ [1:k]\nunique(l::Vector{Int64}, k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64},\
    \ k::Int64) = unique(l).sort() [1:k]\nunique(l::Vector{Int64}, k", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n   \
    \ sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n   \
    \ sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n   \
    \ sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n   \
    \ sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n   \
    \ sort(unique(l))\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    sort(unique(l))\n\
    end\nunique(l::Vector", "    seen = Set()\n    unique = Vector{Int64}()\n    for\
    \ i in l\n        if !haskey(seen, i)\n            push!(unique, i)\n        \
    \    seen.add(i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThis doesn't work if there are repeated elements in the\
    \ input vector. For example, `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5,\
    \ 3, 9, 0, 123]`.\n<|/ c |>\n<| c |>\nI believe that `unique` should return `[5,\
    \ 3, 9, 0, 123]` because `[5, 3, 9, 0, 123]` has repeated elements. Please correct\
    \ me if I am wrong.\n<|/ c |>\n<| c |>\nYes, you are right. My mistake. Thanks\
    \ for pointing out.\n<|/ c |>\n<| c |>\nI believe that `unique` should return\
    \ `[5, 3, 9, 0, 123]` because `[5, 3, 9, 0, 123]` has repeated elements. Please\
    \ correct me if I am wrong.\n<|/ c |>\n<| c |>\nYes, you are right. My mistake.\
    \ Thanks for pointing out.\n<|/ c |>\n<| a tags=julia,unique |>\nThe accepted\
    \ answer does not work when there are repeated elements in the input vector. For\
    \ example, unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) returns [5, 3, 9, 0, 123].\n\
    Here is a solution that works with repeated elements:\n<code>", "    unique =\
    \ Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64}) =\
    \ unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64)::Vector{Int64}\n    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64}, dim::Int64)\
    \ = unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\n\
    unique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\n\
    unique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\n\
    unique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\n\
    unique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\n\
    unique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\n\
    unique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\n\
    unique(l::Vector{Int64}, dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64},\
    \ dim::Int64) = unique(l).sorted\nunique(l::Vector{Int64}, dim::Int64) = unique(l).",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(unique(",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend", "    unique\
    \ = Vector{Int64}()\n    for x in l\n        if !contains(unique, x)\n       \
    \     push!(unique, x)\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like the `contains` approach, but I wonder if there\
    \ is a way to avoid the O(n) `contains` call. Maybe `find` could help?\n<|/ c\
    \ |>\n<| c |>\n`find` would still be O(n), but you could use a `Set` instead,\
    \ which would only require O(1) contains.\n<|/ c |>\n<| c |>\nYes, `find` would\
    \ be O(n), but `contains` would be O(1), so it's still better than O(n).\n<|/\
    \ c |>\n<| c |>\n`find` would still be O(n), but you could use a `Set` instead,\
    \ which would only require O(1) contains.\n<|/ c |>\n<| c |>\nYes, `find` would\
    \ be O(n), but `contains` would be O(1), so it's still better than O(n).\n<|/\
    \ c |>\n<| a dscore=2 |>\nA simple solution that doesn't require any external\
    \ packages is:\n<code>", "    unique = Set()\n    for i in l\n        push!(unique,\
    \ i)\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", " \
    \   unique = sort(unique(l))\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = true\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ \n    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n      \
    \      unique[x] = ", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis does not answer the question. OP asked for\
    \ unique elements in a vector, not unique keys in a map.\n<|/ c |>\n<| c |>\n\
    This answer does answer the question. The OP asked for unique elements in a vector,\
    \ not unique keys in a map. This answer does exactly that.\n<|/ c |>\n<| a tags=julia\
    \ |>\n<code>\njulia> using Statistics", "    unique = Set()\n    for i in l\n\
    \        if !haskey(unique, i)\n            push!(unique, i)\n        end\n  \
    \  end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    The function you are looking for is unique! which removes duplicates from a vector.\n\
    <code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n\
    </code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n<code>\njulia> unique([5, 3,\
    \ 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\nThe function you are looking for is unique! which removes duplicates\
    \ from a vector.\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element\
    \ Array{Int64,1}\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nThe function\
    \ you are looking for is unique! which removes duplicates from a vector.\n<code>\n\
    julia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nThe function you are looking for is unique!\
    \ which removes duplicates from a vector.\n<code>\njulia> unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n<|/ a tags=julia |>\n\
    <| a tags=julia |>\nThe function you are looking for is unique! which removes\
    \ duplicates from a vector.\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\
    0-element Array{Int64,1}\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia |>\n<code>\n\
    julia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nThe function you are looking for is unique!\
    \ which removes duplicates from a vector.\n<code>\njulia> unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n<|/ a tags=julia |>\n\
    <| a dscore=0 |>\nThe function you are looking for is unique! which removes duplicates\
    \ from a vector.\n<code>\njulia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element\
    \ Array{Int64,1}\n</code>\n<|/", "    unique = Set()\n    for i in l\n       \
    \ if !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n\
    \    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n \
    \           push!(unique, i)\n            seen[i] = true\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\nI wrote a package called UniqueArrays.jl that does this for you:\n<code>\n\
    julia> using UniqueArrays", "    unique = Set()\n    for i in l\n        push!(unique,\
    \ i)\n    end\n    return unique\nend", "    seen = Set()\n    uniques = Vector{Int64}()\n\
    \    for el in l \n        if !has(seen, el) \n            push!(uniques, el)\n\
    \            push!(seen, el)\n        end\n    end\n    return uniques\nend\n\
    </cell>\n<text>\nunique! modifies the original vector", "    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            push!(unique, x)\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Vector{Int64}()\n    unique.push!(l)\n    unique\nend\n</cell>\n<code\
    \ language=julia-1.3>", "    unique = Set()\n    for x in l\n        push!(unique,\
    \ x)\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", " \
    \   seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen.add(i)\n        end\n   \
    \ end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\n\
    This does not answer the question. `unique` does not sort the array, it just removes\
    \ duplicates.\n<|/ c |>\n<| c |>\nI believe this does answer the question. `unique`\
    \ removes duplicates, while `sort` sorts the array. `sort` also returns a sorted\
    \ array. `unique` does not return sorted array, but a sorted unique array.\n<|/\
    \ c |>\n<| c |>\nThis does not answer the question. `unique` does not sort the\
    \ array, it just removes duplicates.\n<|/ c |>\n<| c |>\nI believe this does answer\
    \ the question. `unique` removes duplicates, while `sort` sorts the array. `sort`\
    \ also returns a sorted array. `unique` does not return sorted array, but a sorted\
    \ unique array.\n<|/ c |>\n<| a dscore=4 |>\nThe most efficient way is to use\
    \ Sets:\n<code>\njulia> using Sets", "    unique = Set()\n    for x in l\n   \
    \     if !haskey(unique, x)\n            push!(unique, x)\n        end\n    end\n\
    \    return unique(unique(unique))\nend\nunique(a)", "    seen = Set()\n    unique\
    \ = Vector{Int64}()\n    for i in l\n        if !haskey(seen, i)\n           \
    \ push!(unique, i)\n            seen.add(i)\n        end\n    end\n    return\
    \ unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=2 |>\n<code>\n\
    julia> using Statistics", "    seen = Set()\n    unique = Vector{Int64}()\n  \
    \  for x in l\n        if !seen.add(x)\n            push!(unique, x)\n       \
    \ end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.3>", " \
    \   unique = Set()\n    for i in l\n        unique.add(i)\n    end\n    return\
    \ unique\nend\n</code>\n<|/ a tags=julia,set |>\n<| c |>\nThis doesn't work for\
    \ me. `julia> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\nERROR: MethodError: no method\
    \ matching length(::Set{Int64})`\n<|/ c |>\n<| c |>\nSorry, I forgot to mention\
    \ that this was a Julia 1.0 solution. Julia 1.0 doesn't support the Set data structure.\
    \ I've updated my answer to include a solution for Julia 1.0.\n<|/ c |>\n<| c\
    \ |>\nThanks for your answer. I've tried your solution and it works. But I still\
    \ don't understand why my code doesn't work. Could you please explain to me why\
    \ my code doesn't work?\n<|/ c |>\n<| c |>\nThe reason your code doesn't work\
    \ is that `Set` doesn't have a `length` method. `Set` has a `length` function,\
    \ which returns the number of elements in the set. `Set` also has a `add` function,\
    \ which adds an element to the set. `Set` also has a `remove` function, which\
    \ removes an element from the set. `Set` also has a `contains` function, which\
    \ checks whether an element is in the set. `Set` also has a `union` function,\
    \ which merges two sets. `Set` also has a `intersection` function, which returns\
    \ the intersection of two sets. `Set` also has a `difference` function, which\
    \ returns the difference of two sets. `Set` also has a `issubset` function, which\
    \ checks whether one set is a subset of another.\n<|/ c |>\n<| c |>\n`Set` also\
    \ has a `issuperset` function, which checks whether one set is a superset of another.\n\
    <|/ c |>\n<| a dscore=3 |>\nIn Julia 1.0 you can use the following code:\n<code>\n\
    julia> using Sets", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    unique = Set()\n    for x in l\n\
    \        if !haskey(unique, x)\n            unique[x] = true\n        end\n  \
    \  end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\n    return\
    \ unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\n\
    end\nunique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\nend\n\
    unique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n  \
    \  return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n    return\
    \ unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\n\
    end\nunique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\nend\n\
    unique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n  \
    \  return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n    return\
    \ unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\n\
    end\nunique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\nend\n\
    unique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n\
    \    return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n  \
    \  return unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n    return\
    \ unique(sort(l))\nend\nunique(l::Vector{Int64})::Vector{Int64}\n    return unique(sort(l))\n\
    end", "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n   \
    \         push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nI like using Set() for this purpose:\n<code>\n\
    julia> using Sets", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            push!(unique, x)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis doesn't work for me. `unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5, 3, 9, 0, 123]`\n<|/ c |>\n<| c |>\n\
    It works on my computer. Which Julia version are you using?\n<|/ c |>\n<| c |>\n\
    I'm using Julia 1.5.1\n<|/ c |>\n<| c |>\nI tested on 1.5.1 too. Maybe the problem\
    \ comes from your environment. Can you try the code I posted in the answer?\n\
    <|/ c |>\n<| c |>\nI tested on 1.5.1 too. Maybe the problem comes from your environment.\
    \ Can you try the code I posted in the answer?\n<|/ c |>\n<| a tags=julia,arrays\
    \ |>\nThe solution by is correct, but I wanted to add some explanation as to why\
    \ it works.\nThe reason why it works is because Sets are implemented as hash tables.\
    \ In Julia, a set is implemented as a hash table. Hash tables are implemented\
    \ as hash tables. In Julia, a set is implemented as a hash table. Hash tables\
    \ are implemented as hash tables. In Julia, a set is implemented as a hash table.\
    \ Hash tables are implemented as hash tables. In Julia, a set is implemented as\
    \ a hash table. Hash tables are implemented as hash tables.\nIn Julia, a set is\
    \ implemented as a hash table. Hash tables are implemented as hash tables. In\
    \ Julia, a set is implemented as a hash table. Hash tables are implemented as\
    \ hash tables. In Julia, a set is implemented as a hash table. Hash tables are\
    \ implemented as hash tables.\nIn Julia, a set is implemented as a hash table.\
    \ Hash tables are implemented as hash tables. In Julia, a set is implemented as\
    \ a hash table. Hash tables are implemented as hash tables. In Julia, a set is\
    \ implemented as a hash table. Hash tables are implemented as hash tables.\nIn\
    \ Julia, a set is implemented as a hash table. Hash tables are implemented as\
    \ hash tables. In Julia, a set is implemented as a hash table. Hash tables are\
    \ implemented as hash tables. In Julia, a set is implemented as a hash table.\
    \ Hash tables are implemented as hash tables.\nIn Julia, a ", "    unique = Set()\n\
    \    for x in l\n        if !haskey(unique, x)\n            unique[x] = true\n\
    \        end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work for me. `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])`\
    \ returns `[5, 3, 9, 0, 123]`.\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\
    \ and it works. What version are you using?\n<|/ c |>\n<| c |>\nI'm using Julia\
    \ 0.6.2\n<|/ c |>\n<| c |>\nI tested it on 0.6.2 too. Works fine. Are you sure\
    \ you copied the code correctly? I tested it on 0.6.2 too.\n<|/ c |>\n<| c |>\n\
    Yes, I copied the code correctly. I'm running Julia 0.6.2 on OS X. Maybe it's\
    \ an OS X issue?\n<|/ c |>\n<| a tags=julia,unique,arrays |>\nThe Julia standard\
    \ library has this functionality built in:\n<code>\njulia> unique(vec)\n5-element\
    \ Array{Int64,1}:\n 0\n 1\n 2\n 3\n 4\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ doesn't work for me. `unique(vec)` returns `[5, 3, 9, 0, 123]`.\n<|/ c |>\n\
    <| c |>\nIt works for me on Julia 0.6.2 on OS X. Are you sure you copied the code\
    \ correctly? I tested it on 0.6.2 too.\n<|/ c |>\n<| c |>\nYes, I copied the code\
    \ correctly. I'm running Julia 0.6.2 on OS X. Maybe it's an OS X issue?\n<|/ c\
    \ |>\n<| c |>\nI tested it on 0.6.2 too. Works fine. Are you sure you copied the\
    \ code correctly? I tested it on 0.6.2 too.\n<|/ c |>\n<| c |>\nYes, I copied\
    \ the code correctly. I'm running Julia 0.6.2 on OS X. Maybe it's an OS X issue?\n\
    <|/ c |>\n<| a dscore=4 |>\nThe Julia standard library has this functionality\
    \ built in:\n<code>\njulia> unique(vec)\n5-element Array{Int64,1}:\n 0\n 1\n 2\n\
    \ 3\n 4\n</code>\n<|/ a tags=julia,unique,arrays ", "    seen = Set()\n    unique\
    \ = Set()\n    for x in l \n        if !seen.add(x) \n            unique.add(x)\n\
    \        end\n    end\n    return unique\nend", "    unique = Set()\n    for i\
    \ in l\n        if !haskey(unique, i)\n            push!(unique, i)\n        end\n\
    \    end\n    return unique\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI wrote\
    \ a function to do that in Julia 1.5.\n<code>", "    unique = Set()\n    for i\
    \ in l\n        if !haskey(unique, i)\n            push!(unique, i)\n        end\n\
    \    end\n    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\n\
    This doesn't work if you have a vector of strings. `unique([\"a\", \"a\", \"b\"\
    , \"a\", \"c\"])` returns `[\"a\", \"b\", \"c\"]`\n<|/ c |>\n<| c |>\nI fixed\
    \ it by changing the `if` statement to `if !haskey(unique, i)`\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if you have a vector of strings. `unique([\"a\", \"a\"\
    , \"b\", \"a\", \"c\"])` returns `[\"a\", \"b\", \"c\"]`\n<|/ c |>\n<| a dscore=4\
    \ |>\nIn Julia 1.5 you can use the function unique:\n<code>\njulia> unique([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n\
    \ 123\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis doesn't work if you\
    \ have a vector of strings. `unique([\"a\", \"a\", \"b\", \"a\", \"c\"])` returns\
    \ `[\"a\", \"b\", \"c\"]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a\
    \ vector of strings. `unique([\"a\", \"a\", \"b\", \"a\", \"c\"])` returns `[\"\
    a\", \"b\", \"c\"]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a vector\
    \ of strings. `unique([\"a\", \"a\", \"b\", \"a\", \"c\"])` returns `[\"a\", \"\
    b\", \"c\"]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a vector of strings.\
    \ `unique([\"a\", \"a\", \"b\", \"a\", \"c\"])` returns `[\"a\", \"b\", \"c\"\
    ]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a vector of strings. `unique([\"\
    a\", \"a\", \"b\", \"a\", \"c\"])` returns `[\"a\", \"b\", \"c\"]`\n<|/ c |>\n\
    <| a dscore=4 |>\nIn Julia 1.5 you can use the function unique:\n<code>\njulia>\
    \ unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n\
    \ 5\n 9\n 123\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays |>\n\
    In Julia 1.5 you can use the function unique:\n<code>\njulia> unique([5, 3, 5,\
    \ 2, 3, ", "    seen = Set()\n    unique = Vector{Int64}()\n    for x in l\n \
    \       if !seen.add(x)\n            push!(unique, x)\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n\
    \    unique = Vector{Int64}()\n    for x in l\n        if !haskey(seen, x)\n \
    \           push!(unique, x)\n            seen[x] = true\n        end\n    end\n\
    \    return unique\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis doesn't\
    \ work if you have a vector of strings. I added a solution that works for both\
    \ cases.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\njulia> using Statistics",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ = unique(l).\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe `unique` function you\
    \ wrote is wrong. `unique` returns a `Set`, not a `Vector`. Also, `unique` doesn't\
    \ sort the vector.\n<|/ c |>\n<| c |>\nThanks for pointing out the mistakes. I\
    \ fixed the code accordingly.\n<|/ c |>\n<| a tags=julia,unique,sorting |>\nA\
    \ simple and efficient solution using Julia's built-in Sets:\n<code>\njulia> s\
    \ = Set([5,3,5,2,3,3,9,0,123])\nSet{Int64}([5, 3, 9, 123, 2])", "    unique =\
    \ Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64}) =\
    \ unique(l).sorted()\nunique(l::Vector{Float64}) = unique(l).sorted()\nunique(l::Vector{Complex{Float64}})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Int64}}) = unique(l).sorted()\nunique(l::Vector{Union{Nothing, Float64}}) =\
    \ unique(l).sorted()\nunique(l::Vector{Union{Nothing, Complex{Float64}}}) = unique(l).sorted()\n\
    unique(l::Vector{Union{Nothing, Any}}) = unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Int64}}}) = unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Float64}}}) = unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Complex{Float64}}}}) =  unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Any}}}) = unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Union{Nothing, Int64}}}}) =  unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Union{Nothing, Float64}}}}) =  unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Union{Nothing, Complex{Float64}}}}}) = unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Union{Nothing, Any}}}}) =  unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Union{Nothing, Union{Nothing, Int64}}}}}) = unique(l).sorted()\n\
    unique(l::Vector{Union{Nothing, Union{Nothing, Union{Nothing, Union{Nothing, Float64}}}}})\
    \ = unique(l).sorted()\nunique(l::Vector{Union{Nothing, Union{Nothing, Union{Nothing,\
    \ Union{Nothing, Complex{Float64}}}}}}) =  unique(l).sorted()\nunique(l::Vector{Union{Nothing,\
    \ Union{Nothing, Union{Nothing, Union{Nothing, Any}}", "    unique = Set()\n \
    \   for i in l\n        if !haskey(unique, i)\n            push!(unique, i)\n\
    \        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nI like your answer, but I think it would be more efficient to just use\
    \ `Set` instead of `Dict`\n<|/ c |>\n<| c |>\nI agree with you, `Set` would be\
    \ more efficient.\n<|/ c |>\n<| a tags=julia,arrays |>\nI like your answer, but\
    \ I think it would be more efficient to just use Set instead of Dict\n<code>",
  "    unique = sort(unique(l))\n    return unique\nend", "    unique = Vector{Int64}()\n\
    \    for x in l\n        if !haskey(unique, x)\n            push!(unique, x)\n\
    \        end\n    end\n    unique\nend\n</cell>\n<code language=julia-1.5>", " \
    \   unique = Set()\n    for i in l\n        if !haskey(unique, i)\n          \
    \  push!(unique, i)\n        end\n    end\n    return unique\nend\n</cell>\n<text>\n\
    The function unique returns a sorted unique vector of the type Vector{Int64}",
  "    unique = Set()\n    for x in l\n        if !unique.contains(x)\n          \
    \  unique.add(x)\n        end\n    end\n    return unique\nend\nunique(l::Vector{Int64})\
    \ = unique(l).sorted()\nunique(l::Vector{Float64}) = unique(l).sorted()\nunique(l::Vector{String})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::Vector{Any})\
    \ = unique(l).sorted()\nunique(l::Vector{Any}) = unique(l).sorted()\nunique(l::",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI wrote a package that does\
    \ this in Julia 1.0:\nhttps://github.com/jrockway/UniqueArrays.jl\n<code>\nusing\
    \ UniqueArrays", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(unique(l))\nend\n</cell>\n\
    <code language=julia-1.5>", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,set,arrays |>\n<| a tags=julia,set,arrays |>\n\
    A more Julian way would be to use Sets:\n<code>\njulia> using Sets", "    seen\
    \ = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen[i] = true\n        end\n\
    \    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is\
    \ not the fastest solution, since it requires O(n) memory and O(n^2) time.\n<|/\
    \ c |>\n<| c |>\nYes, I agree. My solution is more of a proof of concept, since\
    \ I didn't want to reinvent the wheel. I'll update my answer with your solution.\n\
    <|/ c |>\n<| c |>\nI updated my answer with a solution that is O(n) memory and\
    \ O(n) time.\n<|/ c |>\n<| c |>\nI updated my answer with a solution that is O(n)\
    \ memory and O(n) time.\n<|/ c |>\n<| a dscore=2 |>\nThe first thing that comes\
    \ to mind is to use an associative array (aka hash table). \n<code>", "    unique\
    \ = Set()\n    for i in l\n        if !haskey(unique, i)\n            push!(unique,\
    \ i)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=julia,sorting |>\nThe Julia standard library includes a function called\
    \ unique that does exactly what you want:\n<code>\njulia> unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n5-element Array{Int64,1}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nI like using Sets to remove duplicates:\n<code>\n\
    julia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Set{Int64}:\n 0\n 2\n 3\n\
    \ 5\n 9\n 123\n</code>\n<|/ a tags=julia,sorting dscore=2 |>\n<| a dscore=1 |>\n\
    I like using Sets to remove duplicates:\n<code>\njulia> Set([5, 3, 5, 2, 3, 3,\
    \ 9, 0, 123])\n5-element Set{Int64}:\n 0\n 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a\
    \ tags=julia,sorting |>\n<| a dscore=1 |>\nI like using Sets to remove duplicates:\n\
    <code>\njulia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123])\n5-element Set{Int64}:\n 0\n\
    \ 2\n 3\n 5\n 9\n 123\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting\
    \ |>\n<code>\njulia> using Statistics", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for i in l\n        if !haskey(seen, i)\n            push!(unique, i)\n \
    \           seen[i] = true\n        end\n    end\n    return unique\nend\n</cell>\n\
    <text>\nExercise: Write a function that takes a vector of strings and returns\
    \ a vector of unique strings. Test it by passing in a vector of strings that you\
    \ know should contain unique strings and a vector of strings that should contain\
    \ unique strings. What do you observe?", "    unique = Set()\n    for i in l\n\
    \        if !haskey(unique, i)\n            push!(unique, i)\n        end\n  \
    \  end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for i in l\n        push!(unique, i)\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,arrays |>\n<| c |>\nThis does not answer the question.\
    \ `unique` does not remove duplicates.\n<|/ c |>\n<| c |>\nIt does. `unique` removes\
    \ duplicates.\n<|/ c |>\n<| c |>\n`unique` does not remove duplicates. `unique`\
    \ removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates.\
    \ `unique` removes duplicates. `unique` removes duplicates. `unique` removes duplicates. ",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ push!(unique, x)\n        end\n    end\n    return unique\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            push!(unique, x)\n        end\n    end\n    return unique\n\
    end\n</cell>\n<text>\nThe function unique returns a sorted unique vector of the\
    \ elements in the input vector.", "    unique = Vector{Int64}()\n    unique.push!(l)\n\
    \    unique\nend", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</cell>\n<code language=julia-1.5>", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !haskey(seen, x)\n            push!(unique, x)\n \
    \           seen[x] = true\n        end\n    end\n    return unique\nend\n</cell>\n\
    <code language=julia-1.5>", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !seen.add(x)\n            push!(unique, x)\n     \
    \   end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n           \
    \ unique[x] = true\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| c |>\nThis doesn't work for me. `unique([5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123])` returns `[5, 3, 9, 123]`\n<|/ c |>\n<| c |>\nI added a version\
    \ that works with Julia 0.6.2\n<|/ c |>\n<| c |>\nThis doesn't work for me either.\
    \ `unique([5, 3, 5, 2, 3, 3, 9, 0, 123])` returns `[5, 3, 9, 123]`\n<|/ c |>\n\
    <| c |>\nI added a version that works with Julia 0.6.2\n<|/ c |>\n<| a tags=julia\
    \ |>\n<code>\njulia> using Statistics", "    seen = Set()\n    unique = Set()\n\
    \    for i in l\n        if !haskey(seen, i)\n            push!(unique, i)\n \
    \           seen[i] = true\n        end\n    end\n    return unique\nend", " \
    \   unique = Set()\n    for x in l\n        if !haskey(unique, x)\n          \
    \  unique[x] = true\n        end\n    end\n    return unique(unique(l)...)\nend\n\
    </cell>\n<code language=julia-1.5>", "    unique = Set()\n    for i in l\n   \
    \     if !haskey(unique, i)\n            push!(unique, i)\n        end\n    end\n\
    \    return unique\nend", "    unique = sort(unique(l))\n    return unique\nend\n\
    </cell>\n<code language=julia-1.5>", "    seen = Set()\n    unique = Vector{Int64}()\n\
    \    for x in l\n        if !seen.add(x)\n            push!(unique, x)\n     \
    \   end\n    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>",
  "    unique = Set()\n    for i in l\n        if !haskey(unique, i)\n           \
    \ push!(unique, i)\n        end\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nThe `Set` type was introduced in Julia v0.6.0,\
    \ so this won't work if you're using an older version.\n<|/ c |>\n<| c |>\nI believe\
    \ this would work if you replaced `Set` with `Dict`\n<|/ c |>\n<| c |>\nYes, `Dict`\
    \ works, but `Set` does not. `Set` does not allow duplicate elements. `Dict` does.\n\
    <|/ c |>\n<| a |>\nIn Julia v0.6.0 you can use Sets:\n<code>\njulia> Set([5, 3,\
    \ 5, 2, 3, 3, 9, 0, 123])\nSet{Int64}([5, 3, 9, 0, 123])\n</code>\n<|/ a dscore=5\
    \ tags=julia,arrays |>\n<| c |>\nThis should be the accepted answer. `Set` was\
    \ introduced in v0.6.0\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `Set` was introduced in v0.6.0\n<|/ c |>\n<| a |>\nIn Julia v0.6.0 you can use\
    \ Sets:\n<code>\njulia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123])\nSet{Int64}([5, 3,\
    \ 9, 0, 123])\n</code>\n<|/ a dscore=5 tags=julia,arrays |>\n<| c |>\nThis should\
    \ be the accepted answer. `Set` was introduced in v0.6.0\n<|/ c |>\n<| a dscore=5\
    \ |>\nIn Julia v0.6.0 you can use Sets:\n<code>\njulia> Set([5, 3, 5, 2, 3, 3,\
    \ 9, 0, 123])\nSet{Int64}([5, 3, 9, 0, 123])\n</code>\n<|/ a tags=julia,arrays\
    \ |>\n<| a tags=julia,arrays |>\nIn Julia v0.6.0 you can use Sets:\n<code>\njulia>\
    \ Set([5, 3, 5, 2, 3, 3, 9, 0, 123])\nSet{Int64}([5, 3, 9, 0, 123])\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=julia,arrays |>\nIn Julia v0.6.0 you can use Sets:\n\
    <code>\njulia> Set([5, 3, 5, 2, 3, 3, 9, 0, 123])\nSet{Int64}([5, 3, 9, 0, 123])\n\
    </code>\n<|/ a ", "    unique = Set()\n    for i in l\n        if !haskey(unique,\
    \ i)\n            push!(unique, i)\n        end\n    end\n    return unique\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\n\
    end\nunique(l::Vector{Int64})::Vector{Int64} =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64}\
    \ =\n    unique(l).sort()\nend\nunique(l::Vector{Int64})::Vector{Int64} =\n  \
    \  unique(l).sort()\nend\nunique(l::Vector", "    unique = Set()\n    for i in\
    \ l\n        if !haskey(unique, i)\n            push!(unique, i)\n        end\n\
    \    end\n    return unique\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI wrote\
    \ a Julia package called UniqueArrays.jl that does exactly this. It works by first\
    \ sorting the array and then removing duplicates. It's a drop-in replacement for\
    \ unique.\n<code>\njulia> using UniqueArrays", "    unique = Set()\n    for i\
    \ in l\n        push!(unique, i)\n    end\n    return unique\nend\n</code>\n<|/\
    \ a tags=julia,arrays |>\n<| c |>\nThis is not the most efficient solution, since\
    \ it creates a new set for every element in the vector. Also, it does not preserve\
    \ the order of the elements in the vector.\n<|/ c |>\n<| c |>\nYes, I agree with\
    \ you. But the question was about sorting and unique. Also I believe that `unique`\
    \ preserves the order of the elements in the vector.\n<|/ c |>\n<| c |>\nYes,\
    \ but `unique` does not preserve the order of the elements in the vector. `unique`\
    \ will sort the elements in the vector and remove duplicates. But it does this\
    \ in-place.\n<|/ c |>\n<| c |>\nYes, you are right. I missed that point. Thanks\
    \ for pointing out.\n<|/ c |>\n<| a tags=julia,arrays |>\n<code>\njulia> using\
    \ Statistics", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique(unique(l)...)\n\
    end\n</code>\n<|/ a tags=julia,set |>\n<| c |>\nThis doesn't seem to work if you\
    \ have a vector of strings. `unique([\"a\", \"b\", \"c\", \"a\", \"b\"])` returns\
    \ `[\"a\", \"b\", \"c\"]` instead of `[\"a\", \"b\"]`.\n<|/ c |>\n<| c |>\nI believe\
    \ this is because `Set` does not preserve order. `Set` does not preserve order\
    \ in Julia 1.5.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a vector of\
    \ strings. `unique([\"a\", \"b\", \"c\", \"a\", \"b\"])` returns `[\"a\", \"b\"\
    , \"c\"]` instead of `[\"a\", \"b\"]`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have a vector of strings. `unique([\"a\", \"b\", \"c\", \"a\", \"b\"])`\
    \ returns `[\"a\", \"b\", \"c\"]` instead of `[\"a\", \"b\"]`.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if you have a vector of strings. `unique([\"a\", \"b\"\
    , \"c\", \"a\", \"b\"])` returns `[\"a\", \"b\", \"c\"]` instead of `[\"a\", \"\
    b\"]`.\n<|/ c |>\n<| a |>\nI came up with this solution:\n<code>", "    unique\
    \ = Set()\n    for i in l\n        push!(unique, i)\n    end\n    return unique\n\
    end", "    unique = Set()\n    for x in l\n        if !haskey(unique, x)\n   \
    \         push!(unique, x)\n        end\n    end\n    return unique\nend\nunique",
  "    seen = Set()\n    unique = Vector{Int64}()\n    for i in l\n        if !haskey(seen,\
    \ i)\n            push!(unique, i)\n            seen[i] = true\n        end\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for x in l\n        push!(unique, x)\n    end\n    unique\nend\n\
    </cell>\n<text>\nExercise 3: Write a function that returns the unique elements\
    \ in a vector\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5,\
    \ 9, 123]\n    \"\"\"", "    unique = Vector{Int64}()\n    unique.push!(l)\n \
    \   unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = Vector{Int64}()\n\
    \    unique.push!(l)\n    while !unique.isEmpty \n        unique.push!(unique[unique.end-1])\n\
    \    end\n    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique\
    \ = Set()\n    for x in l\n        if !haskey(unique, x)\n            push!(unique,\
    \ x)\n        end\n    end\n    return unique\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThanks, this was very helpful. I'm still trying to figure out how\
    \ to get it to work with a vector of strings. I tried to change the type to Vector{String},\
    \ but that didn't work. Do you know how I could get it to work with a vector of\
    \ strings?\n<|/ c |>\n<| c |>\nI added a solution for strings. Please let me know\
    \ if it works for you.\n<|/ c |>\n<| c |>\nThanks, this works great. I'm still\
    \ trying to figure out how to get it to work with a vector of strings. I tried\
    \ to change the type to Vector{String}, but that didn't work. Do you know how\
    \ I could get it to work with a vector of strings?\n<|/ c |>\n<| c |>\nI added\
    \ a solution for strings. Please let me know if it works for you.\n<|/ c |>\n\
    <| a |>\nYou can use the function unique.\n<code>\njulia> unique([5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123])\n0-element Array{Int64,1}\n</code>\n<|/ a tags=julia dscore=3\
    \ |>\n<| c |>\nThanks, this was very helpful. I'm still trying to figure out how\
    \ to get it to work with a vector of strings. I tried to change the type to Vector{String},\
    \ but that didn't work. Do you know how I could get it to work with a vector of\
    \ strings?\n<|/ c |>\n<| c |>\nI added a solution for strings. Please let me know\
    \ if it works for you.\n<|/ c |>\n<| a dscore=3 |>\nIf you want a more general\
    \ solution that will work with any type that implements hash and eq, you can use\
    \ Base.unique:\n<code>\njulia> Base.unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n0-element\
    \ Array{Int64,1}\n</code>\n<|/ a tags=julia |>\n<| c |>\nThanks, this was very\
    \ helpful. I'm still trying to figure out how to get it to work with a vector\
    \ of strings. I tried to change the type to Vector{String}, but that didn't work.\
    \ Do you know how I could get it to work with a vector of strings?\n<|/ c |>\n\
    <| c |>\nI added a solution for strings. Please let me know if it works for you.\n\
    <|/ c |>\n<| a tags=julia |>\nFor a vector of strings:\n<code>\njulia> unique([\"\
    a\", \"b\", \"a\", \"c\", \"c\", \"c\"])\n4-element Array", "    unique = sort(unique(l))\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>", "    unique = sort(unique(l))\n\
    \    return unique\nend", "    unique = Set()\n    for x in l\n        if !haskey(unique,\
    \ x)\n            unique[x] = true\n        end\n    end\n    return unique\n\
    end\n</code>\n<|/ a tags=julia,set |>\n<| c |>\nThis is not the fastest solution.\
    \ `unique` has O(n) complexity and `Set` has O(n^2) complexity. `Set` should be\
    \ avoided if possible.\n<|/ c |>\n<| c |>\nI agree, but I thought that `Set` was\
    \ the fastest solution in Julia 1.5.\n<|/ c |>\n<| c |>\nI agree, `Set` should\
    \ be avoided if possible. `Set` should be avoided if possible. `Set` should be\
    \ avoided if possible. `Set` should be avoided if possible. `Set` should be avoided\
    \ if possible. `Set` should be avoided if possible. `Set` should be avoided if\
    \ possible. `Set` should be avoided if possible. `Set` should be avoided if possible.\
    \ `Set` should be avoided if possible. `Set` should be avoided if possible. `Set`\
    \ should be avoided if possible. `Set` should be avoided if possible. `Set` should\
    \ be avoided if possible. `Set` should be avoided if possible. `Set` should be\
    \ avoided if possible. `Set` should be avoided if possible. `Set` should be avoided\
    \ if possible. `Set` should be avoided if possible. `Set` should be avoided if\
    \ possible. `Set` should be avoided if possible. `Set` should be avoided if possible.\
    \ `Set` should be avoided if possible. `Set` should be avoided if possible. `Set`\
    \ should be avoided if possible. `Set` should be avoided if possible. `Set` should\
    \ be avoided if possible. `Set` should be avoided if possible. `Set` should be\
    \ avoided if possible. `Set` should be avoided if possible. `Set` should be avoided\
    \ if possible. `Set` should be avoided if possible. `Set` should be avoided if\
    \ possible. `Set` should be avoided if possible. `Set` should be avoided if possible.\
    \ `Set` should be avoided if possible. `Set` should be avoided if possible. `Set`\
    \ should be avoided if possible. ", "    unique = Set()\n    for x in l\n    \
    \    if !haskey(unique, x)\n            unique[x] = true\n        end\n    end\n\
    \    return unique\nend\n</cell>\n<code language=julia-1.5>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
