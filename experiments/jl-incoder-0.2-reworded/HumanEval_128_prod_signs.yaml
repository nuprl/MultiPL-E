name: HumanEval_128_prod_signs
language: jl
prompt: "\"\"\"\n    You are given a vector arr of integers and you need to return\n\
  \    sum of magnitudes of integers multiplied by product of all signs\n    of each\
  \ number in the vector, represented by 1, -1 or 0.\n    Note: return nothing for\
  \ empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n    >>>\
  \ prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    nothing\n    \"\"\"\nfunction\
  \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
  \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
  \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
  \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
  \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
completions: ["    if length(arr) == 0 \n        return nothing\n    elseif length(arr)\
    \ == 1 \n        return arr[1]\n    else\n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        sum_of_mags = sum(abs.(arr\
    \ .* signs))\n        return sum_of_mags\n    end\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns true if a number is odd and false otherwise.\
    \ \nWrite a function that returns true if a number is even and false otherwise.\
    \ \nWrite a function that returns true if a number is prime and false otherwise.\
    \ \nWrite a function that returns true if a number is composite and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and false otherwise.\
    \ \nWrite a function that returns true if a number is palindrome and ", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        for (i, x) in enumerate(arr) \n            signs[i] =\
    \ sign(x) * sign(i)\n        end\n        sum(signs)\n    end\nend\n</code>\n\
    <|/ a tags=julia,arrays |>\n<| a dscore=2 |>\nA more efficient solution would\
    \ be to first calculate the product of all signs and then sum up the magnitudes.\n\
    <code>", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = zeros(Int64, length(arr))\n        for (i, val) in enumerate(arr)\
    \ \n            signs[i] = sign(val)\n        end\n        \n        magnitudes\
    \ = map(abs, arr)\n        \n        product = prod(signs)\n        \n       \
    \ return sum(magnitudes .* product)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\n4.3 Vectorized Product of Signs\n\
    Write a function that calculates product of signs of numbers in a vector. \nThe\
    \ function should work for both scalar and vector inputs.", "    if length(arr)==0\n\
    \        return nothing\n    else\n        sum = 0\n        for n in arr\n   \
    \         sum += sign(n)\n        end\n        return sum\n    end\nend", "  \
    \  if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        sum_signs\
    \ = sum(signs)\n        product = 1\n        for i in 1:length(arr) \n       \
    \     product *= signs[i]\n        end\n        return sum_signs * product\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the vector, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing\n    else\
    \ \n        signs = zeros(Int64, length(arr))\n        for i in 1:length(arr)\n\
    \            signs[i] = sign(i) * sign(arr[i])\n        end\n        sum(signs)\n\
    \    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia |>\n<code>", "    if\
    \ length(arr)==0\n        return nothing\n    else\n        signs = zeros(Int,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        sum_of_mags\
    \ = sum(abs.(arr).*signs)\n        return sum_of_mags\n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "    if length(arr) == 0 \n    \
    \    return nothing\n    else \n        signs = map(sign, arr)\n        signs\
    \ = filter(x -> x != 0, signs)\n        signs = filter(x -> x == 0, signs)\n \
    \       signs = filter(x -> x == 1, signs)\n        signs = filter(x -> x == -1,\
    \ signs)\n        signs = prod(signs)\n        mags = map(abs, arr)\n        mags\
    \ = filter(x -> x != 0, mags)\n        mags = filter(x -> x == 0, mags)\n    \
    \    mags = filter(x -> x == 1, mags)\n        mags = filter(x -> x == -1, mags)\n\
    \        mags = prod(mags)\n        return signs * mags\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nTask 3\nWrite\
    \ a function that returns True if a number is prime and False otherwise.", " \
    \   if length(arr) == 0 \n        return nothing \n    else \n        signs =\
    \ map(sign, arr) \n        product = prod(signs) \n        return product * sum(signs)\
    \ \n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that returns True\
    \ if a number is odd and False otherwise.", "    if length(arr)==0\n        return\
    \ nothing\n    \n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[2]\
    \ = -1\n    \n    sum = 0\n    for i in 1:length(arr)\n        sum += signs[i]\
    \ * arr[i]\n    end\n    \n    return sum\nend", "    if length(arr) == 0 \n \
    \       return nothing \n    \n    sum_of_signs = 0 \n    for x in arr \n    \
    \    sum_of_signs += sign(x) \n    \n    product = 1 \n    for x in arr \n   \
    \     product *= sign(x) \n    \n    return sum_of_signs * product \nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nTask 3\nWrite\
    \ a function that checks if a number is even or odd.", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for i = 1:length(arr) \n            signs[i] = sign(arr[i])\n       \
    \ end\n        signs = signs.*ones(Int64, length(arr))\n        sum_of_mags =\
    \ sum(abs.(arr))\n        prod_of_signs = prod(signs)\n        return sum_of_mags*prod_of_signs\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs\nof each number in the vector, represented\
    \ by 1, -1 or 0.\nExample: arr = [1, 2, 2, -4] returns 14", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n\
    \        signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs,\
    \ arr)) \n        return sum_of_magnitudes * signs_product \n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=julia,arrays |>\n<code>", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for (i, v) in enumerate(arr) \n            signs[i] = sign(v) * sign(i)\n\
    \        end\n        return sum(abs2, signs)\n    end\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the product of all signs of numbers\
    \ in a vector. \nExample: \n>>> signs([1, 2, 2, -4])\n9\n>>> signs([0, 1])\n0\n\
    >>> signs([])\nnothing\nHint: use prod_signs function from above.", "    if length(arr)==0\
    \ \n        return nothing \n    else \n        signs = map(sign, arr) \n    \
    \    signs = prod(signs) \n        mags = map(abs, arr) \n        mags = prod(mags)\
    \ \n        return signs * mags \n    end\nend\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes an array of integers and returns its sum.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .== 0] = 1\n        signs[arr .== -1] = -1\n\
    \        signs[arr .== 1] = 0\n        sum_signs = sum(signs)\n        return\
    \ sum_signs * prod(signs)\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\n\
    This doesn't seem to work. `prod_signs([1, 2, 2, -4])` returns `9` instead of\
    \ `9*1*1*1`\n<|/ c |>\n<| c |>\nI edited my answer to fix the bug. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| a tags=julia |>\nI wrote a package for this:\n\
    <code>\nusing LinearAlgebra", "    if length(arr)==0\n        return nothing\n\
    \    end\n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end]\
    \ = -1\n    return sum(map(sign, arr))\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n  \
    \      product = signs .* prod(signs)\n        return sum(abs(product))\n    end\n\
    end\n</cell>\n<text>\nExercise 2\nWrite a function that returns True if a number\
    \ is odd and False otherwise.", "    if length(arr) == 0 \n        return nothing\
    \ \n    \n    sum_of_magnitudes = 0 \n    signs = zeros(length(arr)) \n    \n\
    \    for x in arr \n        signs[x] = sign(x) * sign(x) \n        sum_of_magnitudes\
    \ += sign(x) \n    \n    return sum_of_magnitudes * prod(signs) \nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nTask 2.2. Write\
    \ a function that calculates sum of squares of integers multiplied by product\
    \ of all signs of numbers in the vector, represented by 1, -1 or 0.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        for (i, x) in enumerate(arr) \n            signs[i] =\
    \ sign(x) * sign(i)\n        end\n        return sum(abs2, signs)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns product of absolute values of all numbers\
    \ in arr vector.", "    if length(arr) == 0 \n        return nothing\n    \n \
    \   signs = zeros(Int64, length(arr))\n    signs[arr .== 0] = -1\n    signs[arr\
    \ .== 1] = 1\n    \n    prod = 1\n    for i in 1:length(arr)\n        prod *=\
    \ signs[i]\n    end\n    \n    return prod\nend", "    if length(arr) == 0 \n\
    \        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = 1\n        signs[arr .> 0] = -1\n        signs = signs.prod(1)\n\
    \        return signs * prod(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squares of integers multiplied by product of all signs\nof\
    \ each number in the vector, represented by 1, -1 or 0.\nExample: \n>>> sum_signs([1,\
    \ 2, 2, -4])\n9\n>>> sum_signs([0, 1])\n0\n>>> sum_signs([])\nnothing\nHint: use\
    \ function prod_signs.", "    if length(arr)==0 \n        return nothing \n  \
    \  else \n        signs = zeros(Int64, length(arr))\n        signs[arr .== 1]\
    \ = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        sum\
    \ = 0\n        for i = 1:length(signs)\n            sum += signs[i] * prod(signs)\n\
    \        end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ calculates sum of squares of integers multiplied by product of all signs of\
    \ each number in the vector, represented by 1, -1 or 0.", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = zeros(Int, length(arr))\n\
    \        for (i, x) in enumerate(arr)\n            signs[i] = sign(x) * sign(i)\n\
    \        end\n        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nProblem 7\nWrite a function that\
    \ returns number of integers divisible by given number n.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n\
    \        signs = filter(x -> x != 0, signs) \n        signs = prod(signs) \n \
    \       mags = map(abs, arr) \n        mags = filter(x -> x != 0, mags) \n   \
    \     mags = prod(mags) \n        return signs * mags \n    end\nend\n</cell>\n\
    <code language=julia-1.5>", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .==\
    \ 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n     \
    \   sum = 0\n        for i = 1:length(signs)\n            sum = sum + signs[i]\
    \ * prod(signs)\n        end\n        return sum\n    end\nend\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\"\n    You are given a vector arr of integers and\
    \ you need to return\n    sum of magnitudes of integers multiplied by product\
    \ of all signs\n    of each number in the vector, represented by 1, -1 or 0.\n\
    \    Note: return nothing for empty arr.", "    if length(arr) == 0 \n       \
    \ return nothing\n    \n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n\
    \    signs[end] = -1\n    \n    sum_of_mags = sum(map(abs, arr))\n    \n    prod\
    \ = 1\n    for x in arr\n        prod *= signs[x]\n    end\n    \n    return sum_of_mags\
    \ * prod\nend\n</cell>\n<text>\nExercise 2\nWrite a function that calculates sum\
    \ of squares of numbers in arr using prod_signs function.", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = map(sign, arr)\n \
    \       signs = filter(x -> x != 0, signs)\n        signs = map(x -> x * prod(signs),\
    \ arr)\n        return sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        signs_prod = prod(signs) \n        sum_of_magnitudes = sum(map(abs,\
    \ arr))\n        return sum_of_magnitudes * signs_prod\n    end\nend\n</cell>\n\
    <code language=julia-1.3>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the product of all numbers in the given array arr multiplied\
    \ by product of all signs of each number in the vector, represented by 1, -1 or\
    \ 0.", "    if length(arr) == 0 \n        return nothing \n    else \n       \
    \ signs = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n        signs[arr\
    \ .== -1] = -1\n        signs[arr .== 0] = 0\n        product = signs .* prod(signs)\n\
    \        return sum(abs(product))\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of absolute values of all elements in an array.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs\
    \ .* prod(signs)\n        return sum(signs)\n    end\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\nHere's a solution using broadcasting -\n<code>", " \
    \   if length(arr) == 0 \n        return nothing \n    else \n        signs =\
    \ zeros(Int64, length(arr))\n        for i = 1:length(arr) \n            signs[i]\
    \ = sign(arr[i])\n        end\n        product = prod(signs)\n        magnitudes\
    \ = sum(signs)\n        return magnitudes * product\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates sum of squares of integers multiplied by product\
    \ of all signs of each number in the vector, represented by 1, -1 or 0.", "  \
    \  if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        sum_of_mags\
    \ = sum(abs.(arr .- signs)) \n        return sum_of_mags * prod(signs)\n    end\n\
    end\n</cell>\n<text>\nExercise 3\nWrite a function that returns number of positive\
    \ numbers in an array.", "    if length(arr) == 0 \n        return nothing \n\
    \    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .< 0]\
    \ = -1\n        signs[arr .> 0] = 1\n        signs = signs .* prod(signs)\n  \
    \      return sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that calculates sum\
    \ of squares of integers multiplied by product of all signs of each number in\
    \ the vector, represented by 1, -1 or 0.", "    if length(arr) == 0 \n       \
    \ return nothing \n    else \n        signs = zeros(Int64, length(arr))\n    \
    \    signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr .==\
    \ 0] = 0\n        sum = 0\n        for i in 1:length(signs)\n            sum +=\
    \ signs[i] * prod(signs)\n        end\n        return sum\n    end\nend\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns sum of absolute values of all\
    \ numbers in arr vector.", "    if length(arr) == 0 \n        return nothing \n\
    \    \n    signs = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end] =\
    \ -1\n    \n    prod = 1\n    for i in 1:length(arr) \n        prod *= signs[i]\
    \ \n    end\n    \n    return prod * sum(abs(arr))\nend\n</cell>\n<code language=julia-1.5>\n\
    @test prod_signs([1, 2, 2, -4]) == 9\n@test prod_signs([0, 1]) == 0\n@test prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that calculates sum\
    \ of squares of integers multiplied by product of all signs\nof each number in\
    \ the vector, represented by 1, -1 or 0.\nExample: \n>>> sum_signs([1, 2, 2, -4])\n\
    9\n>>> sum_signs([0, 1])\n0\n>>> sum_signs([])\nnothing", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = signs(arr)\n     \
    \   product = prod(signs)\n        sum_of_magnitudes = sum(abs.(arr .- product))\n\
    \        return sum_of_magnitudes * product\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squared magnitudes of integers multiplied by product of all\
    \ signs of each number in the vector, represented by 1, -1 or 0.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        signs[arr\
    \ .== -1] = 0\n        product = signs .* prod(signs)\n        return sum(abs(product))\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ arr and returns its sum of the absolute values of the difference between each\
    \ element and the mean of arr. \nIf arr is empty, return 0.", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        return sum(signs .* prod)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is odd, False otherwise.", "    if\
    \ length(arr)==0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        product\
    \ = 1\n        for el in arr \n            product *= el\n        end\n      \
    \  return signs * product\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns sum of squares of integers multiplied by product of all signs of numbers\
    \ in the vector, represented by 1, -1 or 0.", "    if length(arr) == 0 \n    \
    \    return nothing \n    else \n        signs = zeros(Int64, length(arr))\n \
    \       signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum_of_mags = sum(signs .* arr)\n        return sum_of_mags\
    \ \n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=1 |>\n<code>", " \
    \   if length(arr) == 0 \n        return nothing \n    else \n        signs =\
    \ map(sign, arr) \n        signs = prod(signs) \n        mags = map(abs, arr)\
    \ \n        mags = prod(mags) \n        return signs * mags \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is odd and False otherwise.", "   \
    \ if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n  \
    \      product = signs.*prod(signs)\n        return sum(abs(product))\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns True if a number is odd and\
    \ False otherwise.", "    if length(arr) == 0 \n        return nothing\n    else\
    \ \n        signs = map(sign, arr)\n        product = prod(signs)\n        magnitudes\
    \ = map(abs, arr)\n        return sum(magnitudes * product)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is even, False otherwise.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs,\
    \ arr)) \n        return sum_of_mags * signs_prod \n    end\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns sum of absolute values of all elements\
    \ of arr multiplied by product of all signs of elements of arr, represented by\
    \ 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing \n    else \n\
    \        signs = map(sign, arr) \n        product = prod(signs) \n        product\
    \ = product * prod(signs) \n        product = product * prod(signs) \n       \
    \ product = product * prod(signs) \n        product = product * prod(signs) \n\
    \        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(signs)\
    \ \n        product = product * prod(signs) \n        product = product * prod(sign",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        for (i,val) in enumerate(arr)\n            signs[i] =\
    \ sign(i) * sign(val)\n        end\n        signs = signs.sum\n        product\
    \ = signs * prod(signs)\n        return product\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that calculates the sum of squares of integers in a given vector.",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n\
    \        signs[arr .== 0] = 0\n        return sum(signs.*abs(arr))\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns sum of squares of integers multiplied\
    \ by product of all signs\nof each number in the vector, represented by 1, -1\
    \ or 0.\nNote: return nothing for empty arr.", "    if length(arr) == 0 \n   \
    \     return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum = 0\n        for n in arr \n            sum += signs[n]\n\
    \        end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns True if a number is even and False if it is odd.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n\
    \        signs = filter(x -> x == 1, signs) \n        signs = filter(x -> x ==\
    \ -1, signs) \n        signs = filter(x -> x == 0, signs) \n        signs = prod(signs)\
    \ \n        mags = map(abs, arr) \n        mags = filter(x -> x == 0, mags) \n\
    \        mags = filter(x -> x == 1, mags) \n        mags = filter(x -> x == -1,\
    \ mags) \n        mags = sum(mags) \n        return signs * mags \n    end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers. `prod([-1,1])`\
    \ returns `1` instead of `-1`.\n<|/ c |>\n<| c |>\nThanks for pointing that out.\
    \ I've updated the answer to include a fix for negative numbers.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nHere's a solution using Julia's built-in product and abs functions:\n\
    <code>", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = map(sign, arr) \n        signs_product = prod(signs) \n        sum_of_magnitudes\
    \ = sum(map(abs, arr))\n        return sum_of_magnitudes * signs_product \n  \
    \  end\nend\n</cell>\n<text>\nExercise 4\nWrite a function that returns sum of\
    \ squared magnitudes of integers multiplied by product of all signs\nof each number\
    \ in the vector, represented by 1, -1 or 0.", "    if length(arr) == 0 \n    \
    \    return nothing \n    else \n        signs = zeros(Int64, length(arr))\n \
    \       signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum_of_mags = sum(abs.(signs))\n        prod_of_mags = prod(signs)\n\
    \        return sum_of_mags * prod_of_mags \n    end\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=1 |>\nI wrote a function that does this for you:\n<code>", " \
    \   if length(arr) == 0 \n        return nothing \n    else \n        signs =\
    \ signs(arr) \n        signs_product = prod(signs) \n        sum_of_magnitudes\
    \ = sum(abs.(arr .- signs_product)) \n        return sum_of_magnitudes * signs_product\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nTask 3\nWrite a function that returns number of integers in arr\
    \ which are divisible by given number k.", "    if length(arr) == 0 \n       \
    \ return nothing \n    else \n        signs = map(sign, arr) \n        signs_prod\
    \ = prod(signs) \n        sum_of_mags = sum(map(abs, arr)) \n        return sum_of_mags\
    \ * signs_prod \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns sum of squares of integers multiplied by product of all signs\nof each\
    \ number in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty\
    \ arr.", "    if length(arr) == 0 \n        return nothing \n    \n    signs =\
    \ zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end] = -1\n    \n    prod\
    \ = 1\n    for i in 1:length(arr) \n        prod *= signs[i]\n    end\n    \n\
    \    return prod * sum(abs(arr))\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that takes an array of integers and returns its sum.", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = signs(arr) \n      \
    \  signs_product = prod(signs) \n        sum_of_magnitudes = sum(abs.(arr .- signs_product))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2", " \
    \   if length(arr) == 0 \n        return nothing \n    \n    signs = zeros(Int64,\
    \ length(arr))\n    signs[arr .== 0] = -1\n    signs[arr .== 1] = 1\n    \n  \
    \  prod = 1\n    for x in arr \n        prod *= signs[x]\n    end\n    \n    return\
    \ prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of integers in the vector, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        product = prod(signs)\n        sum_of_magnitudes = sum(abs.(arr\
    \ .- product))\n        return sum_of_magnitudes * product\n    end\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns True if a number is even, False\
    \ otherwise.", "    if length(arr)==0 \n        return nothing\n    end\n    \n\
    \    sum = 0\n    for i in arr\n        sum += sign(i) * i\n    end\n    return\
    \ sum\nend", "    if length(arr) == 0 \n        return nothing\n    \n    signs\
    \ = zeros(Int, length(arr))\n    signs[1] = 1\n    signs[end] = -1\n    \n   \
    \ prod = 1\n    for x in arr\n        prod *= signs[x]\n    end\n    \n    return\
    \ prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the vector, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = map(sign, arr) \n        signs_product = prod(signs) \n  \
    \      sum_of_magnitudes = sum(map(abs, arr))\n        return sum_of_magnitudes\
    \ * signs_product \n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that calculates the sum of squared magnitudes of integers multiplied by product\
    \ of all signs of numbers in the vector, represented by 1, -1 or 0.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr)) \n        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n\
    \        signs[arr .== 0] = 0\n        signs = signs .* prod(signs)\n        return\
    \ sum(signs)\n    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=0\
    \ |>\n<code>", "    if length(arr)==0 \n        return nothing \n    else \n \
    \       signs = signs(arr) \n        signs_product = prod(signs) \n        sum_of_magnitudes\
    \ = sum(abs.(arr .- signs_product)) \n        return sum_of_magnitudes * signs_product\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        product\
    \ = signs .* prod(signs)\n        return sum(abs.(product))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nTask 3\nWrite\
    \ a function that returns sum of squares of integers multiplied by product of\
    \ all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return\
    \ nothing for empty arr.", "    if length(arr) == 0 \n        return nothing \n\
    \    else \n        signs = zeros(Int64, length(arr))\n        signs[1] = 1\n\
    \        signs[end] = -1\n        product = 1\n        for i in 1:length(arr)\
    \ \n            product *= signs[i]\n        end\n        return product \n  \
    \  end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns sum of squares of integers\
    \ multiplied by product of all signs\nof each number in the vector, represented\
    \ by 1, -1 or 0.\nNote: return nothing for empty arr.", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = prod(signs)\n\
    \        magnitudes = map(abs, arr)\n        return sum(magnitudes * product)\n\
    \    end\nend\n</cell>\n<text>\nExercise 4\nWrite a function that takes a vector\
    \ arr of integers and returns its product of absolute values.", "    if length(arr)==0\n\
    \        return nothing\n    else\n        sum = 0\n        for n in arr\n   \
    \         sum += sign(n)\n        end\n        return sum * prod(map(sign, arr))\n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ arr of integers and returns its absolute value.", "    if length(arr)==0\n \
    \       return nothing\n    signs = zeros(Int, length(arr))\n    for (i,val) in\
    \ enumerate(arr)\n        signs[i] = sign(val)\n    end\n    prod = prod(signs)\n\
    \    return prod * sum(abs2, arr)\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns number\
    \ of positive numbers in a given array.", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = map(sign, arr) \n        signs = filter(x\
    \ -> x == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs\
    \ = filter(x -> x == 0, signs) \n        signs = sum(signs) \n        return signs\
    \ * prod(signs) \n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that calculates sum of squares of integers multiplied by product of all signs\
    \ of integers multiplied by product of all signs of integers multiplied by product\
    \ of all signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all ",
  "    if length(arr) == 0 \n        return nothing \n    \n    signs = zeros(Int,\
    \ length(arr))\n    signs[1] = 1\n    signs[end] = -1\n    \n    sum = 0\n   \
    \ for x in arr \n        sum += signs[x] * x\n    end\n    return sum\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that calculates the sum of squares of integers\
    \ multiplied by product of all signs of each number in the vector, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        product = prod(signs)\n        sum_of_mags = sum(abs.(arr .- product))\n\
    \        return sum_of_mags\n    end\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes two vectors of integers and returns their dot product.\
    \ \nThe dot product of two vectors $\\mathbf{a}$ and $\\mathbf{b}$ is defined\
    \ as:", "    if length(arr) == 0 \n        return nothing \n    else \n      \
    \  signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end] =\
    \ -1\n        product = prod(signs)\n        sum_of_magnitudes = sum(abs.(arr\
    \ .- product))\n        return sum_of_magnitudes * product\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns True if a number is even, False otherwise.", "    if\
    \ length(arr) == 0 \n        return nothing \n    \n    signs = zeros(Int64, length(arr))\n\
    \    signs[arr .== 0] = -1\n    signs[arr .== 1] = 1\n    \n    prod = 1\n   \
    \ for x in arr \n        prod *= signs[x]\n    end\n    \n    return prod\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Task 3", "    if length(arr) == 0 \n        return nothing\n    end\n    \n  \
    \  signs = zeros(Int, length(arr))\n    for k in 1:length(arr)\n        signs[k]\
    \ = signs[k] + arr[k]\n    end\n    \n    prod = 1\n    for k in 1:length(arr)\n\
    \        prod = prod * signs[k]\n    end\n    \n    return prod\nend\n</cell>\n\
    <code language=julia-1.5>\n@test prod_signs([1, 2, 2, -4]) == 9\n@test prod_signs([0,\
    \ 1]) == 0\n@test prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns sum of absolute values of all numbers in a vector.",
  "    if length(arr) == 0 \n        return nothing\n    else \n        signs = zeros(Int,\
    \ length(arr))\n        signs[1] = 1\n        signs[end] = -1\n        product\
    \ = 1\n        for i in 1:length(arr) \n            product *= signs[i]\n    \
    \        signs[i] = 0\n        end\n        return product\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns sum of absolute values of all elements in arr vector.",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr)) \n        signs[1] = 1 if arr[1] < 0 else -1 \n        signs[2]\
    \ = 1 if arr[2] < 0 else -1 \n        signs[3] = 1 if arr[3] < 0 else -1 \n  \
    \      signs[4] = 1 if arr[4] < 0 else -1 \n        signs[5] = 1 if arr[5] < 0\
    \ else -1 \n        signs[6] = 1 if arr[6] < 0 else -1 \n        signs[7] = 1\
    \ if arr[7] < 0 else -1 \n        signs[8] = 1 if arr[8] < 0 else -1 \n      \
    \  signs[9] = 1 if arr[9] < 0 else -1 \n        signs[10] = 1 if arr[10] < 0 else\
    \ -1 \n        signs[11] = 1 if arr[11] < 0 else -1 \n        signs[12] = 1 if\
    \ arr[12] < 0 else -1 \n        signs[13] = 1 if arr[13] < 0 else -1 \n      \
    \  signs[14] = 1 if arr[14] < 0 else -1 \n        signs[15] = 1 if arr[15] < 0\
    \ else -1 \n        signs[16] = 1 if arr[16] < 0 else -1 \n        signs[17] =\
    \ 1 if arr[17] < 0 else -1 \n        signs[18] = 1 if arr[18] < 0 else -1 \n \
    \       signs[19] = 1 if arr[19] < 0 else -1 \n        signs[20] = 1 if arr[20]\
    \ < 0 else -1 \n        signs[21] = 1 if arr[21] < 0 else -1 \n        signs[22]\
    \ = 1 if arr[22] < 0 else -1 \n        signs[23] = 1 if arr[23] < 0 else -1 \n\
    \        signs[24] = 1 if arr[24] < 0 else -1 \n        signs[25] = 1 if arr[25]\
    \ < 0 else -1 \n        signs[26] = 1 if arr[26] < 0 else -1 \n        signs[27]\
    \ = 1 if arr[27] < 0 else -1 \n        signs[28] = 1 if arr[28] < 0 else -1 \n\
    \        signs[29] = 1 if arr[29] < 0 else -1 \n        signs[30] = 1 if arr[30]\
    \ < 0 else -1 \n        signs[31] = 1 if arr[31] < 0 else -1 \n        signs[32]\
    \ = 1 if arr[32] < 0 else -1 \n        signs[33] = 1 if arr[33] < 0 else -1 \n\
    \        signs[34] = 1 if arr[34] < 0 else -1 \n        signs[35] = 1 if arr[35]\
    \ < 0 else -1 \n        signs[36] = 1 if arr[36] < 0 else -1 \n        signs[37]\
    \ = 1 if arr[37] < 0 else -1 \n        signs[38] = 1 if arr[38] < 0 else -1 \n\
    \        signs[39] = 1 if arr[39] < 0 else -1 \n        signs[40] = 1 if arr[40]\
    \ < 0 else -1 \n        signs[41] = 1 if arr[41] < 0 else ", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        signs =\
    \ signs * prod(signs)\n        return signs \n    end\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns sum of squares of integers multiplied\
    \ by product of all signs\nof each number in the vector, represented by 1, -1\
    \ or 0.\nNote: return nothing for empty arr.", "    if length(arr)==0 \n     \
    \   return nothing \n    else \n        sum = 0\n        for el in arr \n    \
    \        sum += el*sign(el) \n        return sum \n    end\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns number of integers in arr which are\
    \ divisible by k. \nIf arr is empty return 0.", "    if length(arr) == 0 \n  \
    \      return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        signs = signs .* (signs .== 1)\n        return sum(abs.(signs))\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ divisible by 3 and False otherwise. Test it on several examples:", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i in 1:length(arr) \n            product *= signs[i]\n            signs[i] *=\
    \ -1\n        end\n        return product * sum(abs.(arr))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns sum of squares of integers multiplied by product of\
    \ all signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of ", "    if length(arr)==0 \n        return nothing\n\
    \    else \n        sum = 0\n        for n in arr \n            sum += sign(n)\
    \ * prod(sign(n))\n        return sum\n    end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\n<code>", "    if length(arr) == 0 \n        return nothing \n\
    \    else \n        signs = zeros(Int, length(arr))\n        signs[arr .== 0]\
    \ = -1\n        signs[arr .== 1] = 1\n        product = signs .* prod(signs)\n\
    \        return sum(abs(product))\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squares of numbers in arr vector.", "    if length(arr) ==\
    \ 0 \n        return nothing\n    elseif length(arr) == 1 \n        return arr[1]\n\
    \    else\n        signs = zeros(Int64, length(arr))\n        signs[1] = 1\n \
    \       signs[end] = -1\n        product = 1\n        for i in 2:length(arr)\n\
    \            signs[i] = signs[i-1] * signs[i]\n            product *= signs[i]\n\
    \        end\n        return product * sum(abs(arr))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that calculates sum of squares of numbers in a given vector.", " \
    \   if length(arr) == 0 \n        return nothing \n    else \n        signs =\
    \ zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n        signs[arr .==\
    \ -1] = -1\n        signs[arr .== 0] = 0\n        signs = signs .* prod(signs)\n\
    \        return sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns True if a number is odd and False otherwise. \nThe function should work\
    \ for both positive and negative numbers.", "    if length(arr) == 0 \n      \
    \  return nothing \n    else \n        signs = zeros(Int, length(arr))\n     \
    \   signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        product = signs.*arr\n\
    \        magnitudes = sqrt(product.^2)\n        return sum(magnitudes)\n    end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThe answer by is correct, but\
    \ I wanted to add some explanation as to why it works.\nThe function prod_signs\
    \ returns a single number, which is the sum of the magnitudes of the numbers in\
    \ the array. \nThe function prod_signs takes two arguments: arr and signs. \n\
    The function prod_signs first checks to see if arr is empty. If it is, it returns\
    \ nothing. Otherwise, it creates a new array called signs, which contains -1 and\
    \ 1 for each number in the array. \nThe function prod_signs then multiplies each\
    \ number in the array by the corresponding sign and sums the magnitudes. \nThe\
    \ function prod_signs then returns the sum of the magnitudes.\n<|/ a tags=julia\
    \ |>\n<| a tags=julia |>\n<code>", "    if length(arr) == 0 \n        return nothing\
    \ \n    \n    signs = zeros(Int, length(arr))\n    signs[arr .== 1] = 1\n    signs[arr\
    \ .== -1] = -1\n    \n    prod = signs .* prod(signs)\n    \n    return sum(abs.(prod))\n\
    end\n</cell>\n<code language=julia-1.3>\n@test prod_signs([1, 2, 2, -4]) == 9\n\
    @test prod_signs([0, 1]) == 0\n@test prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns sum of absolute values of all elements\
    \ in the given array.", "    if length(arr) == 0 \n        return nothing\n  \
    \  elseif length(arr) == 1 \n        return arr[1]\n    elseif length(arr) ==\
    \ 2 \n        return arr[1]*arr[2]\n    elseif length(arr) == 3 \n        return\
    \ arr[1]*arr[2]*arr[3]\n    elseif length(arr) == 4 \n        return arr[1]*arr[2]*arr[3]*arr[4]\n\
    \    elseif length(arr) == 5 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]\n\
    \    elseif length(arr) == 6 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]\n\
    \    elseif length(arr) == 7 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]\n\
    \    elseif length(arr) == 8 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]\n\
    \    elseif length(arr) == 9 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]\n\
    \    elseif length(arr) == 10 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]\n\
    \    elseif length(arr) == 11 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]\n\
    \    elseif length(arr) == 12 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]*arr[12]\n\
    \    elseif length(arr) == 13 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]*arr[12]*arr[13]\n\
    \    elseif length(arr) == 14 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]*arr[12]*arr[13]*arr[14]\n\
    \    elseif length(arr) == 15 \n        return arr[1]*arr[2]*arr[3]*arr[4]*arr[5]*arr[6]*arr[7]*arr[8]*arr[9]*arr[10]*arr[11]*arr[12]*arr[13]*arr[14]*arr[15]\n\
    \    elseif ", "    if length(arr) == 0 \n        return nothing \n    else \n\
    \        signs = zeros(Int64, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        product = prod(signs)\n        magnitudes = sum(abs.(arr))\n \
    \       return magnitudes * product\n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\n<code>", "    if length(arr) == 0 \n        return nothing \n\
    \    else \n        signs = zeros(Int, length(arr))\n        for (i,v) in enumerate(arr)\
    \ \n            signs[i] = sign(v) * sign(i)\n        return sum(abs.(signs))\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns sum of squares of integers\
    \ multiplied by product of all signs\nof each number in the vector, represented\
    \ by 1, -1 or 0.\nExample: \n>>> sum_signs([1, 2, 2, -4])\n9\n>>> sum_signs([0,\
    \ 1])\n0\n>>> sum_signs([])\nnothing\n\"\"\"", "    if length(arr) == 0 \n   \
    \     return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum = 0\n        for s in signs \n            sum += s *\
    \ prod(signs)\n        end\n        return sum \n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that calculates sum of squares of integers multiplied by product\
    \ of all signs of numbers in the vector, represented by 1, -1 or 0.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = signs(arr)\
    \ \n        sign = signs[1] \n        signs = signs[2:end] \n        sign = signs[1]\
    \ \n        product = prod(signs) \n        magnitude = sum(abs(arr) * sign) \n\
    \        return magnitude * product \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns True if a number is odd and False otherwise.", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n  \
    \      signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs,\
    \ arr))\n        return signs_product * sum_of_magnitudes \n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns True if a number is odd and False otherwise.", "   \
    \ if length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = prod(signs)\
    \ \n        magnitudes = map(abs, arr) \n        return magnitudes * signs \n\
    \    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\nA more efficient\
    \ solution than using map and filter is to just use broadcasting by multiplying\
    \ the vector by the sign of each element in the vector:\n<code>\njulia> function\
    \ prod_signs(arr::Vector{Int64})\n           signs = signs(arr)\n           signs\
    \ = signs .* arr\n           magnitudes = map(abs, arr)\n           return magnitudes\
    \ .* signs\n       end\nprod_signs (generic function with 1 method)", "    if\
    \ length(arr) == 0 \n        return nothing \n    \n    signs = zeros(Int, length(arr))\n\
    \    signs[1] = 1\n    signs[end] = -1\n    \n    product = prod(signs)\n    \n\
    \    sum = 0\n    for x in arr \n        sum += abs(x) * product\n    end\n  \
    \  \n    return sum\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\n4.3 Sign of numbers", "    if length(arr) == 0 \n\
    \        return nothing \n    else \n        signs = map(sign, arr) \n       \
    \ product = prod(signs) \n        return product * sum(signs) \n    end\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd, False otherwise. Test it on all numbers from 1 to 20.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = signs(arr) \n   \
    \     signs_product = prod(signs) \n        sum_of_magnitudes = sum(abs.(arr .-\
    \ signs_product)) \n        return sum_of_magnitudes * signs_product \n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns number of integers in arr which\
    \ are divisible by 3.", "    if length(arr) == 0 \n        return nothing \n \
    \   else \n        signs = zeros(Int64, length(arr))\n        signs[1] = 1\n \
    \       signs[end] = -1\n        product = 1\n        for i in 1:length(arr) \n\
    \            product *= signs[i]\n            signs[i] = 0\n        end\n    \
    \    return product * sum(abs(arr))\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns True if a number is even, False otherwise. Test it on all numbers from\
    \ 0 to 20.", "    if length(arr) == 0 \n        return nothing \n    \n    signs\
    \ = zeros(Int64, length(arr))\n    signs[arr .== 1] = 1\n    signs[arr .== -1]\
    \ = -1\n    \n    prod = 1\n    for x in arr \n        prod *= signs[x]\n    end\n\
    \    \n    return prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\n4.3 Sum of magnitudes\nWrite a function that calculates\
    \ sum of magnitudes of integers multiplied by product of all signs\nof each number\
    \ in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty arr.",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n\
    \        signs = signs .* prod(signs)\n        return sum(signs)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns sum of squares of integers multiplied\
    \ by product of all signs\nof each number in the vector, represented by 1, -1\
    \ or 0.\nNote: return nothing for empty arr.", "    if length(arr) == 0 \n   \
    \     return nothing\n    \n    signs = zeros(Int, length(arr))\n    signs[arr\
    \ .< 0] = -1\n    signs[arr .> 0] = 1\n    \n    sum_of_mags = sum(abs.(arr .*\
    \ signs))\n    \n    return sum_of_mags * prod(signs)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ takes an array of integers and returns its sum of the absolute values.", " \
    \   if length(arr) == 0 \n        return nothing \n    else \n        signs =\
    \ zeros(Int64, length(arr))\n        for (i, v) in enumerate(arr) \n         \
    \   signs[i] = sign(v) * sign(i)\n        \n        sum = 0\n        for (i, v)\
    \ in enumerate(signs) \n            sum += v * arr[i]\n        return sum\n  \
    \  end\nend\n</cell>\n<code language=julia-1.4>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns sum of squares of integers\
    \ multiplied by product of all signs\nof each number in the vector, represented\
    \ by 1, -1 or 0.\nNote: return nothing for empty arr.", "    if length(arr) ==\
    \ 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * sign(i)\n\
    \        end\n        return sum(abs2, signs)\n    end\nend", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        sum_of_mags = sum(abs.(signs))\n        prod_of_signs =\
    \ prod(signs)\n        return sum_of_mags * prod_of_signs\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that calculates sum of squares of integers multiplied by product\
    \ of all signs of integers in the vector, represented by 1, -1 or 0.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        signs = prod(signs) \n        magnitudes = map(abs, arr) \n \
    \       magnitudes = prod(magnitudes) \n        return signs * magnitudes \n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\n4.3 Sum of absolute values of all numbers in a vector", "   \
    \ if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr)) \n        signs[1] = 1\n        signs[end] = -1\n        product\
    \ = 1\n        for i in 1:length(arr) \n            product *= signs[i] \n   \
    \         signs[i] *= -1 \n        end\n        return product \n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Task 2.2: Product of signs\nWrite a function that calculates product of signs\
    \ of given vector.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = signs(arr) \n        sum_signs = sum(signs) \n        product\
    \ = prod(signs) \n        return sum_signs * product \n    end\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns True if a number is even, False\
    \ otherwise. \nWrite a function that returns True if a number is odd, False otherwise.\
    \ \nWrite a function that returns True if a number is prime (a number that has\
    \ no divisors other than 1 and itself).\nWrite a function that returns True if\
    \ a number is composite (a number that has no divisors other than 1 and itself),\
    \ False otherwise.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n\
    \        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        return\
    \ sum(abs.(signs)) \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that calculates sum\
    \ of squared magnitudes of integers multiplied by product of all signs\nof each\
    \ number in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty\
    \ arr.", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = map(sign, arr) \n        signs = filter(x -> x != 0, signs) \n   \
    \     signs = prod(signs) \n        signs = signs == 0 ? 1 : signs \n        signs\
    \ = signs == 1 ? 1 : -1 \n        signs = signs == -1 ? 1 : 0 \n        return\
    \ sum(map(abs, arr) * signs) \n    end\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a tags=julia |>\n<code>", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .== 1]\
    \ = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        return\
    \ sum(abs.(signs)) \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns True if a number is even, False otherwise.", "    if length(arr)==0\
    \ \n        return nothing \n    else \n        signs = map(sign, arr) \n    \
    \    mags = map(abs, arr) \n        product = reduce(mul, signs) \n        return\
    \ product * reduce(mul, mags) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ calculates the sum of squares of integers in a given array.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = signs(arr) \n   \
    \     signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr))\n  \
    \      return sum_of_mags * signs_prod \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nProblem 3\nWrite a function that\
    \ returns true if a number is even and false if it is odd.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n\
    \        signs = prod(signs) \n        mags = map(abs, arr) \n        mags = prod(mags)\
    \ \n        return signs * mags \n    end\nend\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a vector of integers and returns the product of its\
    \ absolute values.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int64, length(arr))\n        signs[arr .< 0] = -1\n\
    \        signs[arr .> 0] = 1\n        signs = signs .* prod(signs)\n        return\
    \ sum(signs)\n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns sum of squares of integers multiplied by product of all signs\nof each\
    \ number in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty\
    \ arr.", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        product = prod(signs)\n        magnitudes = map(abs, arr)\n  \
    \      return sum(magnitudes.*product)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squares of integers multiplied by product of all signs of\
    \ each number in the vector, represented by 1, -1 or 0.", "    if length(arr)\
    \ == 0 \n        return nothing \n    \n    sum_of_magnitudes = 0 \n    for x\
    \ in arr \n        sum_of_magnitudes += sign(x) \n    \n    prod_of_signs = 1\
    \ \n    for x in arr \n        prod_of_signs *= sign(x) \n    \n    return sum_of_magnitudes\
    \ * prod_of_signs \nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nTask 6. Write a function that returns sum of squares\
    \ of integers multiplied by product of all signs of integers multiplied by product\
    \ of all signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product of all signs of integers multiplied by product of all signs of integers\
    \ multiplied by product of all signs of integers multiplied by product of all\
    \ signs of integers multiplied by product of all signs of integers multiplied\
    \ by product ", "    if length(arr) == 0 \n        return nothing \n    else \n\
    \        signs = zeros(Int64, length(arr))\n        signs[arr .== 0] = -1\n  \
    \      signs[arr .== 1] = 1\n        signs = signs .* prod(signs)\n        return\
    \ sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nTask 3\nWrite a function that calculates sum of squares\
    \ of integers multiplied by product of all signs\nof each number in the vector,\
    \ represented by 1, -1 or 0.\nNote: return nothing for empty arr.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = 1\n        signs[arr .> 0] = -1\n        signs = signs\
    \ .* prod(signs)\n        return sum(signs)\n    end\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns number of integers divisible by given number\
    \ k", "    if length(arr) == 0 \n        return nothing \n    else \n        signs\
    \ = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n        signs[arr\
    \ .== -1] = -1\n        signs[arr .== 0] = 0\n        sum_signs = sum(signs)\n\
    \        return sum_signs * prod(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns sum of absolute values of numbers in a vector.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = signs(arr) \n   \
    \     signs_product = prod(signs) \n        sum_of_magnitudes = sum(abs.(arr .-\
    \ signs_product)) \n        return sum_of_magnitudes * signs_product \n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 3\nWrite a function that calculates sum of squares of integers\
    \ multiplied by product of all signs of each number in the vector, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int, length(arr))\n        for (i, x) in enumerate(arr)\
    \ \n            signs[i] = sign(x) * signs[i]\n        end\n        sum(signs)\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\n<code>", "    if\
    \ length(arr) == 0 \n        return nothing\n    elseif length(arr) == 1 \n  \
    \      return arr[0] * signs(arr[1])\n    else\n        signs = signs(arr)\n \
    \       mags = map(abs, arr)\n        mags = filter(x -> x != 0, mags)\n     \
    \   mags = reduce(*, mags)\n        mags = prod(mags)\n        return mags * signs\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that checks if a number is prime\
    \ or not. \nThe function should take one integer number as an argument and should\
    \ return true or false accordingly.", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr\
    \ .< 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs .* prod(signs)\n\
    \        return sum(signs)\n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a\
    \ function that returns True if a number is even, False otherwise.", "    if length(arr)==0\
    \ \n        return nothing\n    else \n        signs = signs(arr)\n        signs\
    \ = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n     \
    \   signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = signs[end]\n        signs = signs[end]\n\
    \        signs = signs[end]\n        signs = ", "    if length(arr) == 0 \n  \
    \      return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs\
    \ .* prod(signs)\n        return sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nTask 2.3\nWrite a function that\
    \ returns sum of squares of integers multiplied by product of all signs\nof each\
    \ number in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty\
    \ arr.", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = zeros(Int64, length(arr))\n        signs[arr .< 0] = -1\n        signs[arr\
    \ .> 0] = 1\n        sum_of_mags = sum(abs.(arr .* signs))\n        return sum_of_mags\
    \ * prod(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 2\nWrite a function that calculates sum of\
    \ squares of numbers in arr. \nThe function should return nothing for empty arr\
    \ and a number for non-empty arr. \nThe function should work for both real and\
    \ complex numbers. ", "    if length(arr) == 0 \n        return nothing \n   \
    \ else \n        signs = zeros(Int64, length(arr))\n        signs[arr .< 0] =\
    \ -1\n        signs[arr .> 0] = 1\n        product = signs .* prod(signs)\n  \
    \      return sum(abs.(arr .* product))\n    end\nend\n</cell>\n<text>\nExercise\
    \ 9\nWrite a function that returns number of integers greater or equal to given\
    \ number in arr vector.", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = map(sign, arr)\n        signs = filter(x -> x != 0,\
    \ signs)\n        signs = map(x -> x * prod(signs), arr)\n        signs = reduce(*,\
    \ signs)\n        return signs\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nTask 3\nWrite a function that returns\
    \ sum of squares of integers multiplied by product of all signs\nof each number\
    \ in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty arr.",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n\
    \        signs[arr .== 0] = 0\n        sum_of_signs = sum(signs)\n        prod_of_signs\
    \ = signs .* signs\n        return sum_of_signs * prod(prod_of_signs)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 2", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = map(sign, arr) \n        signs = filter(x -> x != 0, signs)\
    \ \n        signs = filter(x -> x == 0, signs) \n        signs = filter(x -> x\
    \ == 1, signs) \n        signs = filter(x -> x == -1, signs) \n        signs =\
    \ filter(x -> x == 0, signs) \n        signs = sum(signs) \n        return signs\
    \ * prod(signs) \n    end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n  \
    \      signs = signs.prod(1)\n        return signs * prod(signs)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that calculates the sum of squared magnitudes of\
    \ integers multiplied by product of all signs of each number in the vector, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing\n    \n \
    \   sum_of_signs = sum(signs(arr))\n    \n    prod = 1\n    for x in arr\n   \
    \     prod *= sign(x)\n    end\n    \n    return sum_of_signs * prod\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nTask 3\nWrite\
    \ a function that returns sum of absolute values of all numbers in arr vector.",
  "    if length(arr)==0 \n        return nothing \n    else \n        sum = 0 \n\
    \        for n in arr \n            sum += sign(n) * prod(signs(n)) \n       \
    \ return sum \n    end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", " \
    \   if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        product = prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)\n        product = product * prod(signs)\n\
    \        product = product * prod(signs)", "    if length(arr)==0 \n        return\
    \ nothing \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr\
    \ .< 0] = 1\n        signs[arr .> 0] = -1\n        signs = signs .* prod(signs)\n\
    \        return sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns the product of absolute values of numbers in a given vector.", "   \
    \ if length(arr) == 0 \n        return nothing\n    else \n        signs = map(sign,\
    \ arr)\n        signs = filter(x -> x != 0, signs)\n        signs = prod(signs)\n\
    \        signs = signs / prod(arr)\n        return signs\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the number of positive numbers in a given array.", " \
    \   if length(arr) == 0 \n        return nothing\n    \n    signs = zeros(Int,\
    \ length(arr))\n    signs[1] = 1\n    signs[end] = 1\n    \n    prod = 1\n   \
    \ for x in arr\n        prod *= signs[x]\n    end\n    \n    return prod\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\n\
    4.3 Sum of absolute values", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr)) \n        signs[1] =\
    \ 1\n        signs[end] = -1\n        product = 1\n        for i in 1:length(arr)\
    \ \n            product *= signs[i] \n            signs[i] = 0\n        end\n\
    \        return product \n    end\nend\n</cell>\n<code language=julia-1.5>", " \
    \   if length(arr)==0 \n        return nothing\n    else\n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n  \
    \      signs = signs.*prod(signs)\n        return sum(abs(arr)*signs)\n    end\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) ==\
    \ 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns the product of all numbers in\
    \ a given vector.", "    if length(arr) == 0 \n        return nothing\n    end\n\
    \    signs = map(sign, arr)\n    prod = prod(signs)\n    mags = map(abs, arr)\n\
    \    return sum(mags .* signs) .* prod\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nTask 3\nWrite a function that returns\
    \ sum of squares of integers multiplied by product of all signs\nof each number\
    \ in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty arr.",
  "    if length(arr) == 0 \n        return nothing\n    elseif length(arr) == 1 \n\
    \        return arr[1]\n    else\n        signs = map(sign, arr)\n        product\
    \ = prod(signs)\n        return product * sum(signs)\n    end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = zeros(Int64, length(arr))\n        signs[1]\
    \ = 1\n        signs[end] = -1\n        product = 1\n        for i in 1:length(arr)\
    \ \n            product *= signs[i]\n        end\n        return product\n   \
    \ end\nend\n</cell>\n<code language=julia-1.3>", "    if length(arr) == 0 \n \
    \       return nothing\n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .== 0] = -1\n        signs[arr .== 1] = 1\n        signs =\
    \ signs .* prod(signs)\n        return sum(signs)\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that returns sum of squares of integers multiplied by product of\
    \ all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return\
    \ nothing for empty arr.", "    if length(arr) == 0 \n        return nothing\n\
    \    elseif length(arr) == 1 \n        return arr[1]\n    elseif length(arr) ==\
    \ 2 \n        return arr[1] * arr[1]\n    elseif length(arr) > 2 \n        signs\
    \ = zeros(length(arr))\n        for i = 1:length(arr) \n            signs[i] =\
    \ sign(arr[i])\n        end\n        signs = signs * prod(signs)\n        return\
    \ sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nTask 3\nWrite a function that returns number of\
    \ positive numbers in an array.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .==\
    \ 0] = -1\n        signs[arr .== 1] = 1\n        signs = signs .* prod(signs)\n\
    \        return sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squares of integers multiplied by product of all signs of\
    \ each number in the vector, represented by 1, -1 or 0.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[arr .< 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs\
    \ .* prod(signs)\n        return sum(abs(arr .* signs))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns product of absolute values of all numbers in arr \n\
    and sum of magnitudes of integers multiplied by product of all signs\nof each\
    \ number in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty\
    \ arr.", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = zeros(Int64, length(arr))\n        for i = 1:length(arr) \n      \
    \      signs[i] = sign(arr[i])\n        end\n        mags = map(abs, arr)\n  \
    \      mags = map(sign, mags)\n        mags = map(prod, mags)\n        return\
    \ sum(mags)\n    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\n\
    <code>", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = zeros(Int64, length(arr))\n        for (i, x) in enumerate(arr) \n\
    \            signs[i] = sign(x) * sign(i)\n        end\n        sum(signs)\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 3\nWrite a function that calculates the sum of squared\
    \ magnitudes of integers multiplied by product of all signs of each number in\
    \ the vector, represented by 1, -1 or 0.", "    if length(arr)==0 \n        return\
    \ nothing \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr\
    \ .< 0] = -1\n        signs[arr .> 0] = 1\n        product = signs .* prod(signs)\n\
    \        return sum(abs(product))\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squares of integers multiplied by product of all signs of\
    \ each number in the vector, represented by 1, -1 or 0.", "    if length(arr)==0\
    \ \n        return nothing \n    else \n        signs = map(sign, arr) \n    \
    \    signs = filter(x -> x==1, signs) \n        signs = filter(x -> x==-1, signs)\
    \ \n        signs = filter(x -> x==0, signs) \n        return sum(signs) \n  \
    \  end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns sum of squares of integers\
    \ multiplied by product of all signs\nof each number in the vector, represented\
    \ by 1, -1 or 0.\nNote: return nothing for empty arr.", "    if length(arr) ==\
    \ 0 \n        return nothing\n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        sum_of_mags = sum(abs.(arr\
    \ .* signs))\n        return sum_of_mags\n    end\nend\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes an array of integers and returns its sum of the\
    \ absolute values.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n\
    \        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        sum_of_mags\
    \ = sum(abs.(signs))\n        prod_sign = prod(signs)\n        return sum_of_mags\
    \ * prod_sign\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number\
    \ is odd or even.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[arr .< 0] = 1\n   \
    \     signs[arr .> 0] = -1\n        signs = signs * prod(signs)\n        return\
    \ signs\n    end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a tags=julia,arrays\
    \ |>\nI like your solution, however I find it a bit more elegant to use map and\
    \ sum:\n<code>", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        product = 1\n        for i in 1:length(arr) \n            product\
    \ *= signs[i]\n            signs[i] = 0\n        end\n        return product\n\
    \    end\nend\n</cell>\n<code language=julia-1.3>", "    if length(arr) == 0 \n\
    \        return nothing\n    elseif length(arr) == 1 \n        return arr[1]\n\
    \    elseif length(arr) == 2 \n        return arr[1] * arr[1]\n    elseif length(arr)\
    \ > 2 \n        return arr[1] * prod([prod_signs(arr[2:end-1]), arr[1]])\n   \
    \ end\nend\n</code>\n<|/ a tags=julia,arrays |>\n<| a dscore=2 |>\nI came up with\
    \ this:\n<code>", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int64, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        product = signs * prod(signs)\n        sum_of_magnitudes = sum(abs.(arr\
    \ .- product))\n        return sum_of_magnitudes \n    end\nend\n</cell>\n<text>\n\
    Exercise 7\nWrite a function that returns sum of squares of integers multiplied\
    \ by product of all signs\nof each number in the vector, represented by 1, -1\
    \ or 0.\nExample: \n>>> square_signs([1, 2, 2, -4])\n9\n>>> square_signs([0, 1])\n\
    0\n>>> square_signs([])\nnothing\nHint: use function prod_signs.", "    if length(arr)==0\n\
    \        return nothing\n    end\n    signs = zeros(Int64, length(arr))\n    signs[1]\
    \ = 1\n    signs[end] = -1\n    prod = 1\n    for i in 1:length(arr)\n       \
    \ prod = prod * signs[i]\n    end\n    return prod\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns sum of squares of integers multiplied by product of all signs\nof each\
    \ number in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty\
    \ arr.", "    if length(arr)==0 \n        return nothing \n    else \n       \
    \ signs = map(sign, arr) \n        product = prod(signs) \n        return product\
    \ * sum(signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 3\nWrite a function that returns true if\
    \ a number is odd and false otherwise. \nWrite a function that returns true if\
    \ a number is even and false otherwise. \nWrite a function that returns true if\
    \ a number is prime and false otherwise. \nWrite a function that returns true\
    \ if a number is divisible by 7 and false otherwise. \nWrite a function that returns\
    \ true if a number is divisible by 3 and false otherwise. \nWrite a function that\
    \ returns true if a number is divisible by 5 and false otherwise. \nWrite a function\
    \ that returns true if a number is divisible by both 3 and 5 and false otherwise.\
    \ \nWrite a function that returns true if a number is divisible by both 3 and\
    \ 7 and false otherwise. \nWrite a function that returns true if a number is divisible\
    \ by both 3 and 5 and 7 and false otherwise. \nWrite a function that returns true\
    \ if a number is divisible by both 3 and 7 and 5 and false otherwise. \nWrite\
    \ a function that returns true if a number is divisible by both 3 and 5 and 7\
    \ and 3 and false otherwise. \nWrite a function that returns true if a number\
    \ is divisible by both 3 and 7 and 5 and 3 and false otherwise. \nWrite a function\
    \ that returns true if a number is divisible by both 3 and 5 and 7 and 3 and 5\
    \ and false otherwise. \nWrite a function that returns true if a number is divisible\
    \ by both 3 and 7 and 5 and 3 and 5 and false otherwise. \nWrite a function that\
    \ returns true if a number is divisible by both 3 and 5 and 7 and 3 and 5 and\
    \ 7 and false otherwise. \nWrite a function that returns true if a number is divisible\
    \ by both 3 and 7 and 5 and 3 and 5 and 7 and false otherwise. \nWrite a function\
    \ that returns true if a number is divisible by both 3 and 5 and 7 and 3 and 5\
    \ and 7 and 7 and false otherwise. \nWrite a function that returns true if a number\
    \ is divisible by both 3 and 7 and 5 and 3 and 5 and 7 and 7 and 7 and false otherwise.\
    \ \nWrite a function that returns true if a number is divisible by both 3 and\
    \ 5 and 7 and 3 and 5 and 7 and 7 and 7 and 7 and false otherwise. \nWrite a function\
    \ that returns true if a number is divisible by both 3 and 7 and 5 and 3 and 5\
    \ and 7 and 7 and 7 and 7 and 7 and false otherwise. \nWrite a function that returns ",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = signs(arr)\
    \ \n        sum_signs = sum(signs) \n        product = prod(signs) \n        return\
    \ sum_signs * product \n    end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns True if a number is odd, False otherwise.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        signs[arr < 0] = 0\n \
    \       signs[arr > 0] = 1\n        sum_of_mags = sum(abs.(arr).^signs)\n    \
    \    prod_of_mags = prod(signs)\n        return sum_of_mags * prod_of_mags \n\
    \    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a vector\
    \ arr of integers and returns its sum of the absolute values.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n        signs[arr\
    \ .== 0] = 0\n        prod_signs = prod(signs)\n        return prod_signs \n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\n4.5 Product of absolute values", "    if length(arr) == 0 \n\
    \        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        sum_signs = sum(signs)\n\
    \        prod_signs = signs.*arr\n        return sum_signs*prod(prod_signs)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns sum of absolute values\
    \ of numbers in arr vector.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .<\
    \ 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs.product\n      \
    \  return signs * prod(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns true if a number is even, false otherwise. \nWrite a function that returns\
    \ true if a number is odd, false otherwise. \nWrite a function that returns true\
    \ if a number is prime (a number that has no divisors other than 1 and itself).\n\
    Write a function that returns true if a number is composite (has no divisors other\
    \ than 1 and itself).\nWrite a function that returns true if a number is perfect\
    \ square (has all its divisors equal to itself).\nWrite a function that returns\
    \ true if a number is perfect cube.\nWrite a function that returns true if a number\
    \ is perfect fibonacci.\nWrite a function that returns true if a number is perfect\
    \ triangular number.\nWrite a function that returns true if a number is perfect\
    \ pentagonal number.\nWrite a function that returns true if a number is perfect\
    \ hexagonal number.\nWrite a function that returns true if a number is perfect\
    \ heptagonal number.\nWrite a function that returns true if a number is perfect\
    \ octagonal number.\nWrite a function that returns true if a number is perfect\
    \ nonagonal number.\nWrite a function that returns true if a number is perfect\
    \ obtuse number.\nWrite a function that returns true if a number is perfect semiagonal\
    \ number.\nWrite a function that returns true if a number is perfect square root\
    \ of x.\nWrite a function that returns true if a number is perfect cube root of\
    \ x.\nWrite a function that returns true if a number is perfect triangular root\
    \ of x.\nWrite a function that returns true if a number is perfect pentagonal\
    \ root of x.\nWrite a function that returns true if a number is perfect hexagonal\
    \ root of x.\nWrite a function that returns true if a number is perfect heptagonal\
    \ root of x.\nWrite a function that returns true if a number is perfect octagonal\
    \ root of x.\nWrite a function that returns true if a number is perfect nonagonal\
    \ root of x.\nWrite a function that returns true if a number is perfect obtuse\
    \ root of x.\nWrite a function that returns true if a number is perfect semiagonal\
    \ root of x.\nWrite a function that returns true if a number is perfect square\
    \ root ", "    if length(arr) == 0 \n        return nothing\n    else \n     \
    \   signs = map(sign, arr)\n        signs = filter(x -> x != 0, signs)\n     \
    \   signs = prod(signs)\n        signs = signs / prod(arr)\n        return signs\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    if length(arr) == 0 \n\
    \        return nothing \n    else \n        signs = map(sign, arr) \n       \
    \ signs_product = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that returns number of positive numbers in\
    \ an array.", "    if length(arr) == 0 \n        return nothing \n    else \n\
    \        signs = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n   \
    \     signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        sum = 0\n\
    \        for i = 1:length(signs)\n            sum = sum + signs[i] * prod(signs)\n\
    \        end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squares of integers multiplied by product of all signs of\
    \ each number in the vector, represented by 1, -1 or 0.", "    if length(arr)==0\
    \ \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ i = 2:length(arr) \n            product *= signs[i] \n            signs[i] =\
    \ product \n        end\n        return product\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nTask 2.3\nWrite\
    \ a function that returns sum of squares of numbers in arr vector.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = map(sign, arr) \n\
    \        signs = filter(x -> x != 0, signs) \n        signs = filter(x -> x ==\
    \ 0, signs) \n        signs = filter(x -> x == 1, signs) \n        signs = filter(x\
    \ -> x == -1, signs) \n        signs = map(prod, signs) \n        signs = map(abs,\
    \ signs) \n        signs = filter(x -> x == 1, signs) \n        signs = sum(signs)\
    \ \n        return signs \n    end\nend\n</cell>\n<code language=julia-1.5>",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = signs(arr)\
    \ \n        signs_prod = prod(signs) \n        sum_of_mags = sum(map(abs, arr))\
    \ \n        return sum_of_mags * signs_prod \n    end\nend\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that returns product of absolute values of all elements\
    \ of arr except the first one.", "    if length(arr) == 0 \n        return nothing\n\
    \    else \n        signs = zeros(Int, length(arr))\n        signs[arr .== 1]\
    \ = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        signs\
    \ = signs * prod(signs)\n        return signs\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates the sum of squared magnitudes of integers multiplied by product of\
    \ all signs of each number in the vector, represented by 1, -1 or 0.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        signs = prod(signs) \n        mags = map(abs, arr) \n       \
    \ mags = prod(mags) \n        return signs * mags \n    end\nend\n</code>\n<|/\
    \ a tags=julia |>\n<| a dscore=0 |>\n<code>", "    if length(arr) == 0 \n    \
    \    return nothing \n    else \n        signs = signs(arr) \n        signs_product\
    \ = prod(signs) \n        sum_of_magnitudes = sum(abs.(arr .- signs_product))\
    \ \n        return sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes an array of integers and returns\
    \ its sum of the absolute values.", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = zeros(Int, length(arr))\n        signs[arr\
    \ .== 0] = -1\n        signs[arr .== 1] = 1\n        sum_of_mags = sum(abs.(signs))\n\
    \        prod_of_signs = prod(signs)\n        return sum_of_mags * prod_of_signs\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2,\
    \ 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 3\nWrite a function that returns True if a number is\
    \ odd and False otherwise.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = map(sign, arr) \n        signs = filter(x -> x\
    \ != 0, signs) \n        signs = prod(signs) \n        mags = map(abs, arr) \n\
    \        mags = filter(x -> x != 0, mags) \n        mags = prod(mags) \n     \
    \   return signs * mags \n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([])\
    \ == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that calculates sum\
    \ of squares of integers multiplied by product of all signs of each number in\
    \ the vector, represented by 1, -1 or 0.", "    if length(arr) == 0 \n       \
    \ return nothing \n    else \n        signs = map(sign, arr) \n        signs =\
    \ prod(signs) \n        mags = map(abs, arr) \n        mags = prod(mags) \n  \
    \      return signs * mags \n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=julia,performance\
    \ |>\nThe accepted answer by is very nice, but I wanted to add my two cents. \n\
    The accepted answer by is very nice, but I wanted to add my two cents. \nThe accepted\
    \ answer by is very nice, but I wanted to add my two cents. \nThe accepted answer\
    \ by is very nice, but I wanted to add my two cents. \nThe accepted answer by\
    \ is very nice, but I wanted to add my two cents. \nThe accepted answer by is\
    \ very nice, but I wanted to add my two cents. \nThe accepted answer by is very\
    \ nice, but I wanted to add my two cents. \nThe accepted answer by is very nice,\
    \ but I wanted to add my two cents. \nThe accepted answer by is very nice, but\
    \ I wanted to add my two cents. \nThe accepted answer by is very nice, but I wanted\
    \ to add my two cents. \nThe accepted answer by is very nice, but I wanted to\
    \ add my two cents. \nThe accepted answer by is very nice, but I wanted to add\
    \ my two cents. \nThe accepted answer by is very nice, but I wanted to add my\
    \ two cents. \nThe accepted answer by is very nice, but I wanted to add my two\
    \ cents. \nThe accepted answer by is very nice, but I wanted to add my two cents.\
    \ \nThe accepted answer by is very nice, but I wanted to add my two cents. \n\
    The accepted answer by is very nice, but I wanted to add my two cents. \nThe accepted\
    \ answer by is very nice, but I wanted to add my two cents. \nThe accepted answer\
    \ by is very nice, but I wanted to add my two cents. \nThe accepted answer by\
    \ is very nice, but I wanted to add my two cents. \nThe accepted answer by is\
    \ very nice, but I wanted to add my two cents. \nThe accepted answer by is very\
    \ nice, but I wanted to add my two cents. \nThe accepted answer by is very nice,\
    \ but I wanted to add my two cents. \nThe accepted answer by is very nice, but\
    \ I wanted to add my two cents. \nThe accepted answer by is very nice, but I wanted\
    \ to add my two cents. \nThe accepted answer by is very nice, but I wanted to\
    \ add my two ", "    if length(arr) == 0 \n        return nothing\n    else \n\
    \        signs = map(sign, arr)\n        signs = filter(x -> x != 0, signs)\n\
    \        signs = map(x -> x * prod(signs), arr)\n        signs = map(abs, signs)\n\
    \        signs = filter(x -> x != 0, signs)\n        signs = sum(signs)\n    \
    \    return signs\n    end\nend\n</cell>\n<code language=julia-1.5>", "    if\
    \ length(arr) == 0 \n        return nothing\n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        signs[arr .== 1] = 1\n        signs[arr .== -1] = -1\n\
    \        signs[arr .== 0] = 0\n        product = signs .* prod(signs)\n      \
    \  return sum(abs(product))\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns number of positive numbers in a given array.", "    if length(arr) ==\
    \ 0 \n        return nothing\n    end\n    \n    signs = zeros(Int, length(arr))\n\
    \    signs[1] = 1\n    signs[end] = -1\n    \n    sum_of_mags = sum(map(abs, arr))\n\
    \    \n    prod = 1\n    for x in arr\n        prod *= signs[x]\n    end\n   \
    \ \n    return sum_of_mags * prod\nend\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ that returns True if a number is odd and False otherwise.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int, length(arr))\n\
    \        for (i, x) in enumerate(arr) \n            signs[i] = sign(x) * sign(i)\n\
    \        end\n        return sum(abs2, signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nProblem 3\nWrite a function that\
    \ returns True if a number is even, False otherwise.", "    if length(arr) ==\
    \ 0 \n        return nothing\n    end\n    \n    signs = zeros(Int, length(arr))\n\
    \    signs[1] = 1\n    signs[end] = -1\n    \n    sum = 0\n    for i in 1:length(arr)\n\
    \        sum += signs[i] * arr[i]\n    end\n    return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that calculates sum of squares of integers multiplied by product\
    \ of all signs of each number in the vector, represented by 1, -1 or 0.", "  \
    \  if length(arr) == 0 \n        return nothing \n    else \n        signs = map(sign,\
    \ arr) \n        signs = filter(x -> x != 0, signs) \n        signs = prod(signs)\
    \ \n        return sum(map(abs, arr) * signs) \n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ returns sum of squares of integers multiplied by product of all signs\nof each\
    \ number in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty\
    \ arr.", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = map(sign, arr) \n        signs = prod(signs) \n        product = prod(arr)\
    \ \n        return signs * product \n    end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\n<code>", "    if length(arr) == 0 \n        return nothing \n\
    \    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .== 1]\
    \ = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        sum_of_signs\
    \ = sum(signs)\n        product = signs .* prod(signs)\n        return sum_of_signs\
    \ * product\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 2\nWrite a function that returns sum of squares\
    \ of integers multiplied by product of all signs\nof each number in the vector,\
    \ represented by 1, -1 or 0.\nNote: return nothing for empty arr.", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        sum_signs = sum(signs)\n\
    \        product = 1\n        for n in arr\n            product *= signs[end]\n\
    \            product *= n\n        end\n        return sum_signs * product\n \
    \   end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that returns number of integers\
    \ multiplied by product of all signs of numbers in the given array.", "    if\
    \ length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int,\
    \ length(arr))\n        for (i,x) in enumerate(arr)\n            signs[i] = sign(x)\
    \ * sign(i)\n        end\n        sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.3>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2", "    if length(arr)\
    \ == 0 \n        return nothing\n    else \n        signs = zeros(Int64, length(arr))\n\
    \        signs[1] = 1\n        signs[end] = -1\n        product = 1\n        for\
    \ n in arr\n            product *= signs[n]\n        end\n        return product\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers in arr \nand returns sum of squares of integers multiplied by product\
    \ of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote:\
    \ return nothing for empty arr.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .<\
    \ 0] = 1\n        signs[arr .> 0] = -1\n        signs = signs .* prod(signs)\n\
    \        return sum(signs)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns sum of squares of integers multiplied by product of all signs\nof each\
    \ number in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty\
    \ arr.", "    if length(arr) == 0 \n        return nothing \n    else \n     \
    \   signs = map(sign, arr) \n        signs = filter(x -> x != 0, signs) \n   \
    \     signs = map(x -> x * prod(signs), arr) \n        return sum(signs) \n  \
    \  end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers multiplied by product of all signs of each number in the vector, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        product = prod(signs)\n        sum_of_magnitudes = sum(abs.(arr\
    \ .- product))\n        return sum_of_magnitudes * product\n    end\nend\n</cell>\n\
    <text>\nExercise 2\nWrite a function that calculates the sum of squares of integers\
    \ multiplied by product of all signs of each number in the vector, represented\
    \ by 1, -1 or 0.", "    if length(arr) == 0 \n        return nothing\n    else\
    \ \n        signs = zeros(Int64, length(arr))\n        signs[arr .== 1] = 1\n\
    \        signs[arr .== -1] = -1\n        signs[arr .== 0] = 0\n        return\
    \ sum(signs.*arr)\n    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 3\nWrite a function that returns sum of all\
    \ elements in the given array arr multiplied by product of all signs of each number\
    \ in the vector, represented by 1, -1 or 0.", "    if length(arr) == 0 \n    \
    \    return nothing \n    \n    signs = zeros(Int, length(arr))\n    signs[arr\
    \ .== 0] = -1\n    signs[arr .== 1] = 1\n    \n    prod = prod(signs)\n    \n\
    \    sum = 0\n    for x in arr \n        sum += signs[x] * x\n    end\n    \n\
    \    return sum * prod\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1,\
    \ 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) ==\
    \ nothing\n</cell>\n<text>\nExercise 3\nWrite a function that returns sum of absolute\
    \ values of all elements of a vector.", "    if length(arr) == 0 \n        return\
    \ nothing \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr\
    \ .< 0] = -1\n        signs[arr .> 0] = 1\n        product = signs .* prod(signs)\n\
    \        sum_of_magnitudes = sum(abs.(arr .- product))\n        return sum_of_magnitudes\
    \ \n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that returns number\
    \ of positive numbers in a given array.", "    if length(arr)==0 \n        return\
    \ nothing \n    else \n        signs = zeros(Int, length(arr))\n        signs[1]\
    \ = 1\n        signs[end] = -1\n        product = 1\n        for i in 1:length(arr)\
    \ \n            product *= signs[i]\n        end\n        return product\n   \
    \ end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that calculates sum\
    \ of squares of integers in arr \nand returns sum of squares multiplied by product\
    \ of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote:\
    \ return nothing for empty arr.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr))\n        signs[1] = 1\n\
    \        signs[end] = -1\n        product = 1\n        for i in 1:length(arr)\
    \ \n            product *= signs[i]\n        end\n        return product * sum(abs2,\
    \ arr)\n    end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that returns\
    \ sum of squares of integers multiplied by product of all signs\nof each number\
    \ in the vector, represented by 1, -1 or 0.\nNote: return nothing for empty arr.",
  "    if length(arr) == 0 \n        return nothing \n    else \n        signs = zeros(Int64,\
    \ length(arr))\n        for i = 1:length(arr) \n            signs[i] = sign(arr[i])\n\
    \        end\n        product = prod(signs)\n        magnitudes = map(abs, arr)\n\
    \        return sum(magnitudes.*product)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite a function that\
    \ calculates sum of squared magnitudes of integers multiplied by product of all\
    \ signs of each number in the vector, represented by 1, -1 or 0.", "    if length(arr)\
    \ == 0 \n        return nothing \n    else \n        signs = zeros(Int64, length(arr))\n\
    \        for (i,val) in enumerate(arr)\n            signs[i] = sign(val)\n   \
    \     end\n        signs = signs.prod(1)\n        return sum(abs(arr) * signs)\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>\n@assert prod_signs([1, 2, 2,\
    \ -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\n\
    </cell>\n<text>\nExercise 2\nWrite a function that calculates sum of squares of\
    \ integers in a given vector.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .<\
    \ 0] = -1\n        signs[arr .> 0] = 1\n        signs = signs .* prod(signs)\n\
    \        return sum(abs2, signs)\n    end\nend\n</cell>\n<text>\nExercise 2\n\
    Write a function that returns sum of squares of integers multiplied by product\
    \ of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote:\
    \ return nothing for empty arr.", "    if length(arr) == 0 \n        return nothing\
    \ \n    else \n        signs = zeros(Int64, length(arr))\n        signs[arr .==\
    \ 0] = 1\n        signs[arr .== -1] = -1\n        signs[arr .== 1] = 0\n     \
    \   \n        sum = 0\n        for i = 1:length(arr) \n            sum += signs[i]\
    \ * abs(arr[i])\n        end\n        return sum\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0,\
    \ 1]) == 0\n@assert prod_signs([]) == nothing\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that checks if a number is prime or not. \nThe function should take\
    \ one integer number as argument. \nThe function should return true if the number\
    \ is prime and false otherwise.", "    if length(arr) == 0 \n        return nothing\n\
    \    elseif length(arr) == 1 \n        return arr[0] * sign(arr[0])\n    else\n\
    \        sum = 0\n        for v in arr\n            sum += v * sign(v)\n     \
    \   end\n        return sum\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert prod_signs([1, 2, 2, -4]) == 9\n@assert prod_signs([0, 1]) == 0\n@assert\
    \ prod_signs([]) == nothing\n</cell>\n<text>\nExercise 3\nWrite a function that\
    \ returns the sum of squared magnitudes of integers multiplied by product of all\
    \ signs\nof each number in the vector, represented by 1, -1 or 0.\nExample: \n\
    >>> sum_signs([1, 2, 2, -4])\n9\n>>> sum_signs([0, 1])\n0\n>>> sum_signs([])\n\
    nothing\n\"\"\"", "    if length(arr) == 0 \n        return nothing \n    else\
    \ \n        signs = zeros(Int, length(arr))\n        signs[1] = 1\n        signs[end]\
    \ = -1\n        sum_signs = sum(signs)\n        product = 1\n        for i in\
    \ 1:length(arr) \n            product *= signs[i]\n        end\n        return\
    \ sum_signs * product\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nI came up with this solution:\n<code>", "    if length(arr) == 0 \n    \
    \    return nothing \n    else \n        signs = map(sign, arr) \n        signs_product\
    \ = prod(signs) \n        sum_of_magnitudes = sum(map(abs, arr)) \n        return\
    \ sum_of_magnitudes * signs_product \n    end\nend\n</cell>\n<text>\nExercise\
    \ 4\nWrite a function that takes a vector arr of integers and returns its sum\
    \ of the absolute values."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
