language: jl
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"0\" || value == \"-0\" \n        then return 0\n \
    \   \n    else if value == \"1\" || value == \"-1\" \n        then return 1\n\
    \    \n    else if value == \"2\" || value == \"-2\" \n        then return 2\n\
    \    \n    else if value == \"3\" || value == \"-3\" \n        then return 3\n\
    \    \n    else if value == \"4\" || value == \"-4\" \n        then return 4\n\
    \    \n    else if value == \"5\" || value == \"-5\" \n        then return 5\n\
    \    \n    else if value == \"6\" || value == \"-6\" \n        then return 6\n\
    \    \n    else if value == \"7\" || value == \"-7\" \n        then return 7\n\
    \    \n    else if value == \"8\" || value == \"-8\" \n        then return 8\n\
    \    \n    else if value == \"9\" || value == \"-9\" \n        then return 9\n\
    \    \n    else if value == \"10\" || value == \"-10\" \n        then return 10\n\
    \    \n    else if value == \"11\" || value == \"-11\" \n        then return 11\n\
    \    \n    else if value == \"12\" || value == \"-12\" \n        then return 12\n\
    \    \n    else if value == \"13\" || value == \"-13\" \n        then return 13\n\
    \    \n    else if value == \"14\" || value == \"-14\" \n        then return 14\n\
    \    \n    else if value == \"15\" || value == \"-15\" \n        then return 15\n\
    \    \n    else if value == \"16\" || value == \"-16\" \n        then return 16\n\
    \    \n    else if value == \"17\" || value == \"-17\" \n        then return 17\n\
    \    \n    else if value == \"18\" || value == \"-18\" \n        then return 18\n\
    \    \n    else if value == \"19\" || value == \"-19\" \n        then return 19\n\
    \    \n    else if value == \"20\" || value == \"-20\" \n        then return 20\n\
    \    \n    else if value == \"21\" || value == \"-21\" \n        then return 21\n\
    \    \n    else if value == \"22\" || value == \"-22\" \n        then return 22\n\
    \    \n    else if value == \"23\" || value == \"-23\" \n        then return 23\n\
    \    \n    else if value == \"24\" || value == \"-24\" \n        then return 24\n\
    \    \n    else if value == \"25\" || value == \"-25\" \n        then return 25\n\
    \    \n    else if value == \"26\" || value == \"-26\" \n        \nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvqav9tl0.jl:21\nin expression starting at /tmp/tmpvqav9tl0.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\n\
    \        closest_integer\n    else\n        closest_integer\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n\"\"\"\n    closest_integers(values::Vector{String})\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp91ghf68.jl:26\nin expression starting at\
    \ /tmp/tmpp91ghf68.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        local value = tonumber(value)\n        if value == 0\n            error(\"\
    value cannot be 0\")\n        else\n            local closest = value\n      \
    \      local closestDiff = abs(value - closest)\n            for i = 1, closestDiff\
    \ do\n                local nextClosest = closest + i\n                local nextDiff\
    \ = abs(value - nextClosest)\n                if nextDiff < closestDiff\n    \
    \                then\n                    closest = nextClosest\n           \
    \         closestDiff = nextDiff\n                end\n            end\n     \
    \       return closest\n        end\n    end\nend\n\"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ float to it. If the number is equidistant\n    from two floats, round it away\
    \ from zero.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnw_9szlq.jl:28\nin expression starting at\
    \ /tmp/tmpnw_9szlq.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\
    \ \n        closest_integer = Int64(math.floor(value))\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpytq2xhji.jl:25\nin expression starting at\
    \ /tmp/tmpytq2xhji.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpolriadua.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpolriadua.jl:1\n\
    in expression starting at /tmp/tmpolriadua.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        0\n    else\n        closest_integer(value[end-1])\
    \ + 1 \nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ real number to it. If the number is equidistant\n    from two integers, round\
    \ it away from zero.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6ziyn2gb.jl:24\nin expression starting at\
    \ /tmp/tmp6ziyn2gb.jl:24\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ else\n        \n        local digits = value.split(\".\")\n        local digits_int\
    \ = digits[1]\n        local digits_frac = digits[2]\n        \n        if digits_int\
    \ == \"\"\n            error(\"value cannot be empty\")\n        else\n      \
    \      \n            local digits_int_int = digits_int.split(\".\")[1]\n     \
    \       local digits_int_frac = digits_int.split(\".\")[2]\n            \n   \
    \         if digits_frac == \"\"\n                error(\"value cannot be empty\"\
    )\n            else\n                \n                local digits_frac_int =\
    \ digits_frac.split(\".\")[1]\n                local digits_frac_frac = digits_frac.split(\"\
    .\")[2]\n                \n                if digits_frac_int == \"\"\n      \
    \              error(\"value cannot be empty\")\n                else\n      \
    \              \n                    local digits_frac_frac_int = digits_frac_frac.split(\"\
    .\")[1]\n                    local digits_frac_frac_frac = digits_frac_frac.split(\"\
    .\")[2]\n                    \n                    if digits_frac_frac_int ==\
    \ \"\"\n                        error(\"value cannot be empty\")\n           \
    \         else\n                        \n                        local digits_frac_frac_frac_int\
    \ = digits_frac_frac_frac.split(\".\")[1]\n                        local digits_frac_frac_frac_frac\
    \ = digits_frac_frac_frac.split(\".\")[2]\n                        \n        \
    \                if digits_frac_frac_frac_int == \"\"\n                      \
    \      error(\"value cannot be empty\")\n                        else\n      \
    \                      \n                            local digits_frac_frac_frac_frac_int\
    \ = digits_frac_frac_frac_frac.split(\".\")[1]\n                            local\
    \ digits_frac_frac_frac_frac_frac = digits_frac_frac_frac_frac.split(\".\")[2]\n\
    \                            \n                            if digits_frac_frac_frac_frac_int\
    \ == \"\"\n                                error(\"value cannot be empty\")\n\
    \                            else\n                                \n        \
    \                        local digits_frac_frac_frac_frac_frac_int = digits_frac_frac_frac_frac_frac.split(\"\
    .\")[1]\n                                local digits_frac_frac_frac_frac_frac_frac\
    \ = digits_frac_frac_frac_frac_frac.split(\".\")[2]\n                        \
    \        \n                                if digits_frac_frac_frac_frac_frac_int\
    \ == \"\"\n                                    error(\"value cannot be empty\"\
    )\n                                else\n                                    \n\
    \                                    local digits_frac_frac_frac_frac_frac_frac_int\
    \ = digits_frac_frac_frac_frac_frac_frac.split(\".\")[1]\n                   \
    \                 local digits_frac_frac_frac_frac_frac_frac_frac = digits_frac_frac_frac_frac_frac_frac.split(\"\
    .\")[2]\n                                    \n                              \
    \      if digits_frac_frac_frac_frac_frac_frac_int == \"\"\n                 \
    \                       error(\"value cannot be empty\")\n                   \
    \                 else\n                                        \n           \
    \                             local digits_frac_frac_frac_frac_frac_frac_frac_int\
    \ = digits_frac_frac_frac_frac_frac_frac_frac_frac_frac.split(\".\")[1]\n    \
    \                                    local digits_frac_frac_frac_frac_\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpkrrzrigw.jl:77\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkrrzrigw.jl:1\n\
    in expression starting at /tmp/tmpkrrzrigw.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpat52emjn.jl:21\nin expression starting at\
    \ /tmp/tmpat52emjn.jl:21\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        closest_integer(value::String)::Int64\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    if value == \"0\"\n        return closest_integer\n\
    \    \n    if value == \"1\"\n        return closest_integer\n    \n    if value\
    \ == \"2\"\n        return closest_integer\n    \n    if value == \"3\"\n    \
    \    return closest_integer\n    \n    if value == \"4\"\n        return closest_integer\n\
    \    \n    if value == \"5\"\n        return closest_integer\n    \n    if value\
    \ == \"6\"\n        return closest_integer\n    \n    if value == \"7\"\n    \
    \    return closest_integer\n    \n    if value == \"8\"\n        return closest_integer\n\
    \    \n    if value == \"9\"\n        return closest_integer\n    \n    if value\
    \ == \"10\"\n        return closest_integer\n    \n    if value == \"11\"\n  \
    \      return closest_integer\n    \n    if value == \"12\"\n        return closest_integer\n\
    \    \n    if value == \"13\"\n        return closest_integer\n    \n    if value\
    \ == \"14\"\n        return closest_integer\n    \n    if value == \"15\"\n  \
    \      return closest_integer\n    \n    if value == \"16\"\n        return closest_integer\n\
    \    \n    if value == \"17\"\n        return closest_integer\n    \n    if value\
    \ == \"18\"\n        return closest_integer\n    \n    if value == \"19\"\n  \
    \      return closest_integer\n    \n    if value == \"20\"\n        return closest_integer\n\
    \    \n    if value == \"21\"\n        return closest_integer\n    \n    if value\
    \ == \"22\"\n        return closest_integer\n    \n    if value == \"23\"\n  \
    \      return closest_integer\n    \n    if value == \"24\"\n        return closest_integer\n\
    \    \n    if value == \"25\"\n        return closest_integer\n    \n    if value\
    \ == \"26\"\n        return closest_integer\n    \n    if value == \"27\"\n  \
    \      return closest_integer\n    \n    if value == \"28\"\n        return closest_integer\n\
    \    \n    if value == \"29\"\n        return closest_integer\n    \n    if value\
    \ == \"30\"\n        return closest_integer\n    \n    if value == \"31\"\n  \
    \      return closest_integer\n    \n    if value == \"32\"\n        return closest_integer\n\
    \    \n    if value == \"33\"\n        return closest_integer\n    \n    if value\
    \ == \"34\"\n        return closest_integer\n    \n    if value == \"35\"\n  \
    \      return closest_integer\n    \n    if value == \"36\"\n        return closest_integer\n\
    \    \n    if value == \"37\"\n        return closest_integer\n    \n    if value\
    \ == \"38\"\n        return closest_integer\n    \n    if value == \"39\"\n  \
    \      return closest_integer\n    \n    if value == \"40\"\n        return closest_integer\n\
    \    \n    if value == \"41\"\n        return closest_\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpocxdd7y1.jl:1\nin expression starting at /tmp/tmpocxdd7y1.jl:1\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\
    \ \n        closest_integer = Int64(math.floor(value))\n    end\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpzxe3iqd5.jl:30\n  Test threw
    exception\n  Expression: candidate("10") == 10\n  UndefVarError: math not defined\n  Stacktrace:\n   [1]
    closest_integer(value::String)\n     @ Main /tmp/tmpzxe3iqd5.jl:19\n   [2] macro
    expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzxe3iqd5.jl:30 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzxe3iqd5.jl:29\ntest set: Error
    During Test at /tmp/tmpzxe3iqd5.jl:31\n  Test threw exception\n  Expression: candidate("14.5")
    == 15\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpzxe3iqd5.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzxe3iqd5.jl:31 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzxe3iqd5.jl:29\ntest set: Error
    During Test at /tmp/tmpzxe3iqd5.jl:32\n  Test threw exception\n  Expression: candidate("-15.5")
    == -16\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpzxe3iqd5.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzxe3iqd5.jl:32 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzxe3iqd5.jl:29\ntest set: Error
    During Test at /tmp/tmpzxe3iqd5.jl:33\n  Test threw exception\n  Expression: candidate("15.3")
    == 15\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpzxe3iqd5.jl:19\n   [2] macro expansio'
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" \n        then return -Inf \n    else if value ==\
    \ \"inf\" \n        then return Inf \n    else if value == \"nan\" \n        then\
    \ return NaN \n    else if value == \"-nan\" \n        then return NaN \n    else\
    \ if value == \"0\" \n        then return 0 \n    else if value == \"1\" \n  \
    \      then return 1 \n    else if value == \"2\" \n        then return 2 \n \
    \   else if value == \"3\" \n        then return 3 \n    else if value == \"4\"\
    \ \n        then return 4 \n    else if value == \"5\" \n        then return 5\
    \ \n    else if value == \"6\" \n        then return 6 \n    else if value ==\
    \ \"7\" \n        then return 7 \n    else if value == \"8\" \n        then return\
    \ 8 \n    else if value == \"9\" \n        then return 9 \n    else if value ==\
    \ \"10\" \n        then return 10 \n    else if value == \"11\" \n        then\
    \ return 11 \n    else if value == \"12\" \n        then return 12 \n    else\
    \ if value == \"13\" \n        then return 13 \n    else if value == \"14\" \n\
    \        then return 14 \n    else if value == \"15\" \n        then return 15\
    \ \n    else if value == \"16\" \n        then return 16 \n    else if value ==\
    \ \"17\" \n        then return 17 \n    else if value == \"18\" \n        then\
    \ return 18 \n    else if value == \"19\" \n        then return 19 \n    else\
    \ if value == \"20\" \n        then return 20 \n    else if value == \"21\" \n\
    \        then return 21 \n    else if value == \"22\" \n        then return 22\
    \ \n    else if value == \"23\" \n        then return 23 \n    else if value ==\
    \ \"24\" \n        then return 24 \n    else if value == \"25\" \n        then\
    \ return 25 \n    else if value == \"26\" \n        then return 26 \n    else\
    \ if value == \"27\" \n        then return 27 \n    else if value == \"28\" \n\
    \        then return 28 \n    else if value == \"29\" \n        then return 29\
    \ \n    else if value == \"30\" \n        then return 30 \n    else if value ==\
    \ \"31\" \n        then return 31 \n    else if value == \"32\" \n        then\
    \ return 32 \n    else if value == \"33\" \n        then return 33 \n    else\
    \ if value == \"34\" \n        then return 34 \n    else \nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpqy5dbxhy.jl:20\nin expression starting at /tmp/tmpqy5dbxhy.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        throw(ArgumentError(\"value cannot be\
    \ an empty string\"))\n    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp54j9tq22.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp54j9tq22.jl:1\n\
    in expression starting at /tmp/tmp54j9tq22.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\n\
    \        closest_integer\n    else\n        closest_integer\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkh8_wdt8.jl:26\nin expression starting at\
    \ /tmp/tmpkh8_wdt8.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(Int64(value)))\n    if closest_integer\
    \ == Int64(math.floor(value)):\n        closest_integer = Int64(math.floor(value))\n\
    \    return closest_integer\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5rzy3jbw.jl:21\nin expression starting at\
    \ /tmp/tmp5rzy3jbw.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    if value == \"0\" || value == \"\
    -0\" \n        then return 0\n    elseif value == \"1\" || value == \"-1\" \n\
    \        then return 1\n    elseif value == \"2\" || value == \"-2\" \n      \
    \  then return 2\n    elseif value == \"3\" || value == \"-3\" \n        then\
    \ return 3\n    elseif value == \"4\" || value == \"-4\" \n        then return\
    \ 4\n    elseif value == \"5\" || value == \"-5\" \n        then return 5\n  \
    \  elseif value == \"6\" || value == \"-6\" \n        then return 6\n    elseif\
    \ value == \"7\" || value == \"-7\" \n        then return 7\n    elseif value\
    \ == \"8\" || value == \"-8\" \n        then return 8\n    elseif value == \"\
    9\" || value == \"-9\" \n        then return 9\n    elseif value == \"10\" ||\
    \ value == \"-10\" \n        then return 10\n    elseif value == \"11\" || value\
    \ == \"-11\" \n        then return 11\n    elseif value == \"12\" || value ==\
    \ \"-12\" \n        then return 12\n    elseif value == \"13\" || value == \"\
    -13\" \n        then return 13\n    elseif value == \"14\" || value == \"-14\"\
    \ \n        then return 14\n    elseif value == \"15\" || value == \"-15\" \n\
    \        then return 15\n    elseif value == \"16\" || value == \"-16\" \n   \
    \     then return 16\n    elseif value == \"17\" || value == \"-17\" \n      \
    \  then return 17\n    elseif value == \"18\" || value == \"-18\" \n        then\
    \ return 18\n    elseif value == \"19\" || value == \"-19\" \n        then return\
    \ 19\n    elseif value == \"20\" || value == \"-20\" \n        then return 20\n\
    \    elseif value == \"21\" || value == \"-21\" \n        then return 21\n   \
    \ elseif value == \"22\" || value == \"-22\" \n        then return 22\n    elseif\
    \ value == \"23\" || value == \"-23\" \n        then return 23\n    elseif value\
    \ == \"24\" || value == \"-24\" \n        then return 24\n    elseif value ==\
    \ \"25\" || value == \"-25\" \n        then return 25\n    elseif value == \"\
    26\" || value == \"-26\" \n        then return 26\n    elseif value == \"27\"\
    \ || value == \"-27\" \n        then return 27\n    elseif value == \"28\" ||\
    \ value == \"-28\" \n        then return 28\n    elseif value == \"29\" || value\
    \ == \"-29\" \n        then return 29\n    elseif value == \"30\" || value ==\
    \ \"-30\" \n        then return 30\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpljwvuiuq.jl:22\nin expression starting at /tmp/tmpljwvuiuq.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    closest_integer = Int(value) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_integer = Int(closest_integer) \n    closest_integer\
    \ = Int(closest_integer) \n    closest_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpf3smd2dt.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpf3smd2dt.jl:1\n\
    in expression starting at /tmp/tmpf3smd2dt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ \n    number = parse(Float64, value)\n    \n    if number == 0\n        error(\"\
    value cannot be 0\")\n    \n    closest_integer = number\n    \n    if number\
    \ < 0\n        closest_integer = -number\n    \n    if number == 1\n        error(\"\
    value cannot be 1\")\n    \n    if number == 2\n        error(\"value cannot be\
    \ 2\")\n    \n    if number == 3\n        error(\"value cannot be 3\")\n    \n\
    \    if number == 4\n        error(\"value cannot be 4\")\n    \n    if number\
    \ == 5\n        error(\"value cannot be 5\")\n    \n    if number == 6\n     \
    \   error(\"value cannot be 6\")\n    \n    if number == 7\n        error(\"value\
    \ cannot be 7\")\n    \n    if number == 8\n        error(\"value cannot be 8\"\
    )\n    \n    if number == 9\n        error(\"value cannot be 9\")\n    \n    if\
    \ number == 10\n        error(\"value cannot be 10\")\n    \n    if number ==\
    \ 11\n        error(\"value cannot be 11\")\n    \n    if number == 12\n     \
    \   error(\"value cannot be 12\")\n    \n    if number == 13\n        error(\"\
    value cannot be 13\")\n    \n    if number == 14\n        error(\"value cannot\
    \ be 14\")\n    \n    if number == 15\n        error(\"value cannot be 15\")\n\
    \    \n    if number == 16\n        error(\"value cannot be 16\")\n    \n    if\
    \ number == 17\n        error(\"value cannot be 17\")\n    \n    if number ==\
    \ 18\n        error(\"value cannot be 18\")\n    \n    if number == 19\n     \
    \   error(\"value cannot be 19\")\n    \n    if number == 20\n        error(\"\
    value cannot be 20\")\n    \n    if number == 21\n        error(\"value cannot\
    \ be 21\")\n    \n    if number == 22\n        error(\"value cannot be 22\")\n\
    \    \n    if number == 23\n        error(\"value cannot be 23\")\n    \n    if\
    \ number == 24\n        error(\"value cannot be 24\")\n    \n    if number ==\
    \ 25\n        error(\"value cannot be 25\")\n    \n    if number == 26\n     \
    \   error(\"value cannot be 26\")\n    \n    if number == 27\n        error(\"\
    value cannot be 27\")\n    \n    if number == 28\n        error(\"value cannot\
    \ be 28\")\n    \n    if number == 29\n        error(\"value cannot be 29\")\n\
    \    \n    if number == 30\n        error(\"value cannot be 30\")\n    \n    if\
    \ number == 31\n        error(\"value cannot be 31\")\n    \n    if number ==\
    \ 32\n        error(\"value cannot be 32\")\n    \n    if number == 33\n     \
    \   error(\"value cannot be 33\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaoikl_9v.jl:136\nin expression starting at\
    \ /tmp/tmpaoikl_9v.jl:136\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"-inf\" or value == \"\
    inf\" or value == \"\"\n        closest_integer = Int(0)\n    elseif value ==\
    \ \"0\"\n        closest_integer = Int(0)\n    elseif value == \"1\"\n       \
    \ closest_integer = Int(1)\n    elseif value == \"2\"\n        closest_integer\
    \ = Int(2)\n    elseif value == \"3\"\n        closest_integer = Int(3)\n    elseif\
    \ value == \"4\"\n        closest_integer = Int(4)\n    elseif value == \"5\"\n\
    \        closest_integer = Int(5)\n    elseif value == \"6\"\n        closest_integer\
    \ = Int(6)\n    elseif value == \"7\"\n        closest_integer = Int(7)\n    elseif\
    \ value == \"8\"\n        closest_integer = Int(8)\n    elseif value == \"9\"\n\
    \        closest_integer = Int(9)\n    elseif value == \"10\"\n        closest_integer\
    \ = Int(10)\n    elseif value == \"11\"\n        closest_integer = Int(11)\n \
    \   elseif value == \"12\"\n        closest_integer = Int(12)\n    elseif value\
    \ == \"13\"\n        closest_integer = Int(13)\n    elseif value == \"14\"\n \
    \       closest_integer = Int(14)\n    elseif value == \"15\"\n        closest_integer\
    \ = Int(15)\n    elseif value == \"16\"\n        closest_integer = Int(16)\n \
    \   elseif value == \"17\"\n        closest_integer = Int(17)\n    elseif value\
    \ == \"18\"\n        closest_integer = Int(18)\n    elseif value == \"19\"\n \
    \       closest_integer = Int(19)\n    elseif value == \"20\"\n        closest_integer\
    \ = Int(20)\n    elseif value == \"21\"\n        closest_integer = Int(21)\n \
    \   elseif value == \"22\"\n        closest_integer = Int(22)\n    elseif value\
    \ == \"23\"\n        closest_integer = Int(23)\n    elseif value == \"24\"\n \
    \       closest_integer = Int(24)\n    elseif value == \"25\"\n        closest_integer\
    \ = Int(25)\n    elseif value == \"26\"\n        closest_integer = Int(26)\n \
    \   elseif value == \"27\"\n        closest_integer = Int(27)\n    elseif value\
    \ == \"28\"\n        closest_integer = Int(28)\n    elseif value == \"29\"\n \
    \       closest_integer = Int(29)\n    elseif value == \"30\"\n        closest_integer\
    \ = Int(30)\n    elseif value == \"31\"\n        closest_integer = Int(31)\n \
    \   elseif value == \"32\"\n        closest_integer = Int(32)\n    elseif value\
    \ == \"33\"\n        closest_integer = Int(33)\n    elseif value == \"34\"\n\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"value\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsddfgmb1.jl:21\nin expression starting at /tmp/tmpsddfgmb1.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    \n    if value == \"0\":\n     \
    \   return int64(0)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqtc59jee.jl:23\nin expression starting at\
    \ /tmp/tmpqtc59jee.jl:23\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \ \n        then return 0\n    \n    if value == \"1\" || value == \"-1\" \n \
    \       then return 1\n    \n    if value == \"2\" || value == \"-2\" \n     \
    \   then return 2\n    \n    if value == \"3\" || value == \"-3\" \n        then\
    \ return 3\n    \n    if value == \"4\" || value == \"-4\" \n        then return\
    \ 4\n    \n    if value == \"5\" || value == \"-5\" \n        then return 5\n\
    \    \n    if value == \"6\" || value == \"-6\" \n        then return 6\n    \n\
    \    if value == \"7\" || value == \"-7\" \n        then return 7\n    \n    if\
    \ value == \"8\" || value == \"-8\" \n        then return 8\n    \n    if value\
    \ == \"9\" || value == \"-9\" \n        then return 9\n    \n    if value == \"\
    10\" || value == \"-10\" \n        then return 10\n    \n    if value == \"11\"\
    \ || value == \"-11\" \n        then return 11\n    \n    if value == \"12\" ||\
    \ value == \"-12\" \n        then return 12\n    \n    if value == \"13\" || value\
    \ == \"-13\" \n        then return 13\n    \n    if value == \"14\" || value ==\
    \ \"-14\" \n        then return 14\n    \n    if value == \"15\" || value == \"\
    -15\" \n        then return 15\n    \n    if value == \"16\" || value == \"-16\"\
    \ \n        then return 16\n    \n    if value == \"17\" || value == \"-17\" \n\
    \        then return 17\n    \n    if value == \"18\" || value == \"-18\" \n \
    \       then return 18\n    \n    if value == \"19\" || value == \"-19\" \n  \
    \      then return 19\n    \n    if value == \"20\" || value == \"-20\" \n   \
    \     then return 20\n    \n    if value == \"21\" || value == \"-21\" \n    \
    \    then return 21\n    \n    if value == \"22\" || value == \"-22\" \n     \
    \   then return 22\n    \n    if value == \"23\" || value == \"-23\" \n      \
    \  then return 23\n    \n    if value == \"24\" || value == \"-24\" \n       \
    \ then return 24\n    \n    if value == \"25\" || value == \"-25\" \n        then\
    \ return 25\n    \n    if value == \"26\" || value == \"-26\" \n        then return\
    \ 26\n    \n    if value == \"27\" || value == \"-27\" \n        then return 27\n\
    \    \n    if value == \"28\" || value == \"-28\" \n        then return 28\n \
    \   \n    if value == \"\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpnfx40o13.jl:22\nin expression starting at /tmp/tmpnfx40o13.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        closest_integer(tostring(value))\n    end\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"\n    closest_integer(value::Float64)\nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvoijwj4l.jl:25\nin expression starting at\
    \ /tmp/tmpvoijwj4l.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        0\n    else\n        closest_integer(value[end-1])\
    \ + 1 \n    end\nend\n</cell>\n<text>\nNow let's test it out!\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpquwgqih3.jl:25\nin expression starting at\
    \ /tmp/tmpquwgqih3.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    elseif\
    \ value == \"0\"\n        error(\"value cannot be 0\")\n    elseif value == \"\
    1\"\n        error(\"value cannot be 1\")\n    elseif value == \"-1\"\n      \
    \  error(\"value cannot be -1\")\n    elseif value == \"-2\"\n        error(\"\
    value cannot be -2\")\n    elseif value == \"-3\"\n        error(\"value cannot\
    \ be -3\")\n    elseif value == \"-4\"\n        error(\"value cannot be -4\")\n\
    \    elseif value == \"-5\"\n        error(\"value cannot be -5\")\n    elseif\
    \ value == \"-6\"\n        error(\"value cannot be -6\")\n    elseif value ==\
    \ \"-7\"\n        error(\"value cannot be -7\")\n    elseif value == \"-8\"\n\
    \        error(\"value cannot be -8\")\n    elseif value == \"-9\"\n        error(\"\
    value cannot be -9\")\n    elseif value == \"-10\"\n        error(\"value cannot\
    \ be -10\")\n    elseif value == \"-11\"\n        error(\"value cannot be -11\"\
    )\n    elseif value == \"-12\"\n        error(\"value cannot be -12\")\n    elseif\
    \ value == \"-13\"\n        error(\"value cannot be -13\")\n    elseif value ==\
    \ \"-14\"\n        error(\"value cannot be -14\")\n    elseif value == \"-15\"\
    \n        error(\"value cannot be -15\")\n    elseif value == \"-16\"\n      \
    \  error(\"value cannot be -16\")\n    elseif value == \"-17\"\n        error(\"\
    value cannot be -17\")\n    elseif value == \"-18\"\n        error(\"value cannot\
    \ be -18\")\n    elseif value == \"-19\"\n        error(\"value cannot be -19\"\
    )\n    elseif value == \"-20\"\n        error(\"value cannot be -20\")\n    elseif\
    \ value == \"-21\"\n        error(\"value cannot be -21\")\n    elseif value ==\
    \ \"-22\"\n        error(\"value cannot be -22\")\n    elseif value == \"-23\"\
    \n        error(\"value cannot be -23\")\n    elseif value == \"-24\"\n      \
    \  error(\"value cannot be -24\")\n    elseif value == \"-25\"\n        error(\"\
    value cannot be -25\")\n    elseif value == \"-26\"\n        error(\"value cannot\
    \ be -26\")\n    elseif value == \"-27\"\n        error(\"value cannot be -27\"\
    )\n    elseif value == \"-28\"\n        error(\"value cannot be -28\")\n    elseif\
    \ value == \"-29\"\n        error(\"value cannot be -29\")\n    elseif value ==\
    \ \"-30\"\n        error(\"value cannot be -30\")\n    elseif value == \"-31\"\
    \n        error(\"value cannot be -31\")\n    elseif value == \"-32\"\n      \
    \  error(\"value cannot be -32\")\n    elseif value == \"-33\"\n        error(\"\
    value \nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptbvp48l7.jl:96\nin expression starting at\
    \ /tmp/tmptbvp48l7.jl:96\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    closest_integer = Int64(math.ceil(Int64(value)))\n    if closest_integer\
    \ == Int64(value) \n        closest_integer = Int64(value) \n    \n    return\
    \ closest_integer\nend\n</cell>\n<code language=julia-1.1>\n\"\"\"\n    closest_integer_with_tolerance(value::String,\
    \ tolerance::Real)::Int64\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9soti1jv.jl:26\nin expression starting at\
    \ /tmp/tmp9soti1jv.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" \n        closest_integer\
    \ = Int(0)\n    elseif value == \"1\" \n        closest_integer = Int(1)\n   \
    \ elseif value == \"2\" \n        closest_integer = Int(2)\n    elseif value ==\
    \ \"3\" \n        closest_integer = Int(3)\n    elseif value == \"4\" \n     \
    \   closest_integer = Int(4)\n    elseif value == \"5\" \n        closest_integer\
    \ = Int(5)\n    elseif value == \"6\" \n        closest_integer = Int(6)\n   \
    \ elseif value == \"7\" \n        closest_integer = Int(7)\n    elseif value ==\
    \ \"8\" \n        closest_integer = Int(8)\n    elseif value == \"9\" \n     \
    \   closest_integer = Int(9)\n    elseif value == \"10\" \n        closest_integer\
    \ = Int(10)\n    elseif value == \"11\" \n        closest_integer = Int(11)\n\
    \    elseif value == \"12\" \n        closest_integer = Int(12)\n    elseif value\
    \ == \"13\" \n        closest_integer = Int(13)\n    elseif value == \"14\" \n\
    \        closest_integer = Int(14)\n    elseif value == \"15\" \n        closest_integer\
    \ = Int(15)\n    elseif value == \"16\" \n        closest_integer = Int(16)\n\
    \    elseif value == \"17\" \n        closest_integer = Int(17)\n    elseif value\
    \ == \"18\" \n        closest_integer = Int(18)\n    elseif value == \"19\" \n\
    \        closest_integer = Int(19)\n    elseif value == \"20\" \n        closest_integer\
    \ = Int(20)\n    elseif value == \"21\" \n        closest_integer = Int(21)\n\
    \    elseif value == \"22\" \n        closest_integer = Int(22)\n    elseif value\
    \ == \"23\" \n        closest_integer = Int(23)\n    elseif value == \"24\" \n\
    \        closest_integer = Int(24)\n    elseif value == \"25\" \n        closest_integer\
    \ = Int(25)\n    elseif value == \"26\" \n        closest_integer = Int(26)\n\
    \    elseif value == \"27\" \n        closest_integer = Int(27)\n    elseif value\
    \ == \"28\" \n        closest_integer = Int(28)\n    elseif value == \"29\" \n\
    \        closest_integer = Int(29)\n    elseif value == \"30\" \n        closest_integer\
    \ = Int(30)\n    elseif value == \"31\" \n        closest_integer = Int(31)\n\
    \    elseif value == \"32\" \n        closest_integer = Int(32)\n    elseif value\
    \ == \"33\" \n        closest_integer = Int(33)\n    elseif value == \"34\" \n\
    \        closest_integer = Int(34)\n    elseif value == \"35\" \n        \nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw5fo_ggf.jl:1\nin expression starting at /tmp/tmpw5fo_ggf.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3o6cy5kj.jl:21\nin expression starting at\
    \ /tmp/tmp3o6cy5kj.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"The value cannot be empty\")\n\
    \    elseif value == \"-\"\n        error(\"The value cannot be a negative number\"\
    )\n    elseif value == \"+\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"0\"\n        error(\"The value cannot be zero\")\n  \
    \  elseif value == \"1\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"2\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"3\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"4\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"5\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"6\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"7\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"8\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"9\"\n        error(\"The value cannot be a positive number\"\
    )\n    else\n        error(\"The value cannot be a positive number\")\n    end\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8gfq4r36.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8gfq4r36.jl:1\n\
    in expression starting at /tmp/tmp8gfq4r36.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    elseif\
    \ value == \"0\"\n        error(\"value cannot be 0\")\n    elseif value == \"\
    1\"\n        error(\"value cannot be 1\")\n    elseif value == \"-1\"\n      \
    \  error(\"value cannot be -1\")\n    elseif value == \"-2\"\n        error(\"\
    value cannot be -2\")\n    elseif value == \"-3\"\n        error(\"value cannot\
    \ be -3\")\n    elseif value == \"-4\"\n        error(\"value cannot be -4\")\n\
    \    elseif value == \"-5\"\n        error(\"value cannot be -5\")\n    elseif\
    \ value == \"-6\"\n        error(\"value cannot be -6\")\n    elseif value ==\
    \ \"-7\"\n        error(\"value cannot be -7\")\n    elseif value == \"-8\"\n\
    \        error(\"value cannot be -8\")\n    elseif value == \"-9\"\n        error(\"\
    value cannot be -9\")\n    elseif value == \"-10\"\n        error(\"value cannot\
    \ be -10\")\n    elseif value == \"-11\"\n        error(\"value cannot be -11\"\
    )\n    elseif value == \"-12\"\n        error(\"value cannot be -12\")\n    elseif\
    \ value == \"-13\"\n        error(\"value cannot be -13\")\n    elseif value ==\
    \ \"-14\"\n        error(\"value cannot be -14\")\n    elseif value == \"-15\"\
    \n        error(\"value cannot be -15\")\n    elseif value == \"-16\"\n      \
    \  error(\"value cannot be -16\")\n    elseif value == \"-17\"\n        error(\"\
    value cannot be -17\")\n    elseif value == \"-18\"\n        error(\"value cannot\
    \ be -18\")\n    elseif value == \"-19\"\n        error(\"value cannot be -19\"\
    )\n    elseif value == \"-20\"\n        error(\"value cannot be -20\")\n    elseif\
    \ value == \"-21\"\n        error(\"value cannot be -21\")\n    elseif value ==\
    \ \"-22\"\n        error(\"value cannot be -22\")\n    elseif value == \"-23\"\
    \n        error(\"value cannot be -23\")\n    elseif value == \"-24\"\n      \
    \  error(\"value cannot be -24\")\n    elseif value == \"-25\"\n        error(\"\
    value cannot be -25\")\n    elseif value == \"-26\"\n        error(\"value cannot\
    \ be -26\")\n    elseif value == \"-27\"\n        error(\"value cannot be -27\"\
    )\n    elseif value == \"-28\"\n        error(\"value cannot be -28\")\n    elseif\
    \ value == \"-29\"\n        error(\"value cannot be -29\")\n    elseif value ==\
    \ \"-30\"\n        error(\"value cannot be -30\")\n    elseif value == \"-31\"\
    \n        error(\"value cannot be -31\")\n    elseif value == \"-32\"\n      \
    \  error(\"value cannot be -32\")\n    elseif value == \"-33\"\n        error(\"\
    value \nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptbvp48l7.jl:96\nin expression starting at\
    \ /tmp/tmptbvp48l7.jl:96\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \ \n        then return 0\n    \n    if value == \"1\" || value == \"-1\" \n \
    \       then return -1\n    \n    if value == \"2\" || value == \"-2\" \n    \
    \    then return -2\n    \n    if value == \"3\" || value == \"-3\" \n       \
    \ then return -3\n    \n    if value == \"4\" || value == \"-4\" \n        then\
    \ return -4\n    \n    if value == \"5\" || value == \"-5\" \n        then return\
    \ -5\n    \n    if value == \"6\" || value == \"-6\" \n        then return -6\n\
    \    \n    if value == \"7\" || value == \"-7\" \n        then return -7\n   \
    \ \n    if value == \"8\" || value == \"-8\" \n        then return -8\n    \n\
    \    if value == \"9\" || value == \"-9\" \n        then return -9\n    \n   \
    \ if value == \"10\" || value == \"-10\" \n        then return 10\n    \n    if\
    \ value == \"11\" || value == \"-11\" \n        then return 11\n    \n    if value\
    \ == \"12\" || value == \"-12\" \n        then return 12\n    \n    if value ==\
    \ \"13\" || value == \"-13\" \n        then return 13\n    \n    if value == \"\
    14\" || value == \"-14\" \n        then return 14\n    \n    if value == \"15\"\
    \ || value == \"-15\" \n        then return 15\n    \n    if value == \"16\" ||\
    \ value == \"-16\" \n        then return 16\n    \n    if value == \"17\" || value\
    \ == \"-17\" \n        then return 17\n    \n    if value == \"18\" || value ==\
    \ \"-18\" \n        then return 18\n    \n    if value == \"19\" || value == \"\
    -19\" \n        then return 19\n    \n    if value == \"20\" || value == \"-20\"\
    \ \n        then return 20\n    \n    if value == \"21\" || value == \"-21\" \n\
    \        then return 21\n    \n    if value == \"22\" || value == \"-22\" \n \
    \       then return 22\n    \n    if value == \"23\" || value == \"-23\" \n  \
    \      then return 23\n    \n    if value == \"24\" || value == \"-24\" \n   \
    \     then return 24\n    \n    if value == \"25\" || value == \"-25\" \n    \
    \    then return 25\n    \n    if value == \"26\" || value == \"-26\" \n     \
    \   then return 26\n    \n    if value == \"27\" || value == \"-27\" \n      \
    \  then return 27\n    \n    if value == \"28\" || value == \"-28\" \n       \
    \ then return 28\n    \n    if value == \"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9mew5l5l.jl:22\nin expression starting at /tmp/tmp9mew5l5l.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"0\"\n        return closest_integer\n\
    \    \n    \n    if value == \"1\"\n        return Int64(10)\n    \n    \n   \
    \ if value == \"2\"\n        return Int64(15)\n    \n    \n    if value == \"\
    3\"\n        return Int64(20)\n    \n    \n    if value == \"4\"\n        return\
    \ Int64(25)\n    \n    \n    if value == \"5\"\n        return Int64(30)\n   \
    \ \n    \n    if value == \"6\"\n        return Int64(35)\n    \n    \n    if\
    \ value == \"7\"\n        return Int64(40)\n    \n    \n    if value == \"8\"\n\
    \        return Int64(45)\n    \n    \n    if value == \"9\"\n        return Int64(50)\n\
    \    \n    \n    if value == \"10\"\n        return Int64(55)\n    \n    \n  \
    \  if value == \"11\"\n        return Int64(60)\n    \n    \n    if value == \"\
    12\"\n        return Int64(65)\n    \n    \n    if value == \"13\"\n        return\
    \ Int64(70)\n    \n    \n    if value == \"14\"\n        return Int64(75)\n  \
    \  \n    \n    if value == \"15\"\n        return Int64(80)\n    \n    \n    if\
    \ value == \"16\"\n        return Int64(85)\n    \n    \n    if value == \"17\"\
    \n        return Int64(90)\n    \n    \n    if value == \"18\"\n        return\
    \ Int64(95)\n    \n    \n    if value == \"19\"\n        return Int64(100)\n \
    \   \n    \n    if value == \"20\"\n        return Int64(105)\n    \n    \n  \
    \  if value == \"21\"\n        return Int64(110)\n    \n    \n    if value ==\
    \ \"22\"\n        return Int64(115)\n    \n    \n    if value == \"23\"\n    \
    \    return Int64(120)\n    \n    \n    if value == \"24\"\n        return Int64(125)\n\
    \    \n    \n    if value == \"25\"\n        return Int64(130)\n    \n    \n \
    \   if value == \"26\"\n        return Int64(135)\n    \n    \n    if value ==\
    \ \"27\"\n        return Int64(140)\n    \n    \n    if value == \"28\"\n    \
    \    return Int64(145)\n    \n    \n    if value == \"29\"\n        return Int64(150)\n\
    \    \n    \n    if value == \"30\"\n        return Int64(155)\n    \n    \n \
    \   if value == \"31\"\n        return Int64(160)\n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2k3x5gq5.jl:1\nin expression starting at /tmp/tmp2k3x5gq5.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        throw(ArgumentError(\"Value cannot be\
    \ an empty string\"))\n    elseif value == \"-\"\n        throw(ArgumentError(\"\
    Value cannot be a negative number\"))\n    elseif value == \"+\"\n        throw(ArgumentError(\"\
    Value cannot be a positive number\"))\n    elseif value == \"0\"\n        throw(ArgumentError(\"\
    Value cannot be zero\"))\n    elseif value == \"1\"\n        throw(ArgumentError(\"\
    Value cannot be one\"))\n    elseif value == \"2\"\n        throw(ArgumentError(\"\
    Value cannot be two\"))\n    elseif value == \"3\"\n        throw(ArgumentError(\"\
    Value cannot be three\"))\n    elseif value == \"4\"\n        throw(ArgumentError(\"\
    Value cannot be four\"))\n    elseif value == \"5\"\n        throw(ArgumentError(\"\
    Value cannot be five\"))\n    elseif value == \"6\"\n        throw(ArgumentError(\"\
    Value cannot be six\"))\n    elseif value == \"7\"\n        throw(ArgumentError(\"\
    Value cannot be seven\"))\n    elseif value == \"8\"\n        throw(ArgumentError(\"\
    Value cannot be eight\"))\n    elseif value == \"9\"\n        throw(ArgumentError(\"\
    Value cannot be nine\"))\n    else\n        throw(ArgumentError(\"Value cannot\
    \ be a number\"))\n    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_adgy9wp.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_adgy9wp.jl:1\n\
    in expression starting at /tmp/tmp_adgy9wp.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw7ncs4li.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw7ncs4li.jl:1\n\
    in expression starting at /tmp/tmpw7ncs4li.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ else\n        \n        if isnumeric(value) == true\n            \n        \
    \    number = tonumber(value)\n            \n            if number == 0\n    \
    \            error(\"value cannot be 0\")\n            else\n                \n\
    \                closest = 0\n                \n                for i in 1..number\n\
    \                    \n                    if abs(i - number) < abs(closest -\
    \ number)\n                        closest = i\n                    end\n    \
    \            end\n                \n                return closest\n         \
    \   end\n        end\n    end\nend\n</cell>\n<text>\nThe function closest_integer\
    \ takes in a value (string) representing a number and returns the closest integer\
    \ to it. If the number is equidistant from two integers, round it away from zero.\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyd2uowr6.jl:46\nin expression starting at\
    \ /tmp/tmpyd2uowr6.jl:46\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpat52emjn.jl:21\nin expression starting at\
    \ /tmp/tmpat52emjn.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integers(values::Vector{String})\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphrjdmkfj.jl:21\nin expression starting at\
    \ /tmp/tmphrjdmkfj.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" || value == \"inf\" || value == \"nan\" \n    then\
    \ return value \n    else \n        local closest::Int64 = math.ceil(value)\n\
    \        if math.abs(value - closest) < math.abs(closest - value) \n        then\
    \ return closest\n        else return closest\n    end\nend\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"\n    Create a function that takes a value (string) representing a number\n\
    \    and returns the closest float to it. If the number is equidistant\n    from\
    \ two floats, round it away from zero.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpp37kl5cp.jl:20\nin expression starting at /tmp/tmpp37kl5cp.jl:20\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        closest_integer(parse(Float64, value))\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpofiv73fp.jl:30\n  Test threw
    exception\n  Expression: candidate("10") == 10\n  MethodError: no method matching
    closest_integer(::Float64)\n  Closest candidates are:\n    closest_integer(!Matched::String)
    at /tmp/tmpofiv73fp.jl:18\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpofiv73fp.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpofiv73fp.jl:30 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpofiv73fp.jl:29\ntest set: Error
    During Test at /tmp/tmpofiv73fp.jl:31\n  Test threw exception\n  Expression: candidate("14.5")
    == 15\n  MethodError: no method matching closest_integer(::Float64)\n  Closest
    candidates are:\n    closest_integer(!Matched::String) at /tmp/tmpofiv73fp.jl:18\n  Stacktrace:\n   [1]
    closest_integer(value::String)\n     @ Main /tmp/tmpofiv73fp.jl:22\n   [2] macro
    expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpofiv73fp.jl:31 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpofiv73fp.jl:29\ntest set: Error
    During Test at /tmp/tmpofiv73fp.jl:32\n  Test threw exception\n  Expression: candidate("-15.5")
    == -16\n  MethodError: no method matching closest_integer(::Float64)\n  Closest
    candidates are:\n    closest_integer(!Matched::String) at /tmp/tmpofiv73fp.jl:18\n  Stacktrace:\n   [1]
    closest_integer(value::String)\n     @ Main /tmp/tmpofiv73fp.jl:22\n   [2] macro
    expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpofiv73fp.jl:32 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/'
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ \n    local num = tonumber(value)\n    if num == nil\n        error(\"value\
    \ must be a number\")\n    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptw2tmd00.jl:1\nin expression starting at /tmp/tmptw2tmd00.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ end\n    \n    local num = tonumber(value)\n    if num == nil\n        error(\"\
    value cannot be converted to a number\")\n    end\n    \n    local closest\n \
    \   local diff\n    \n    if num == 0 \n        closest = 0\n        diff = 0\n\
    \    else\n        closest = num\n        diff = num\n    end\n    \n    if num\
    \ > 0\n        local i = 1\n        while i <= num\n            local diff = abs(closest\
    \ - i)\n            if diff < diff\n                closest = i\n            \
    \    diff = diff\n            end\n            i = i + 1\n        end\n    end\n\
    \    \n    return closest\nend\n</cell>\n<text>\nThe function above is called\
    \ a closure in Julia. Closures are a powerful feature of Julia that allows us\
    \ to pass functions as arguments to other functions. Closures are also a powerful\
    \ feature of Julia that allows us to pass functions as arguments to other functions.\
    \ Closures are also a powerful feature of Julia that allows us to pass functions\
    \ as arguments to other functions. Closures are also a powerful feature of Julia\
    \ that allows us to pass functions as arguments to other functions. Closures are\
    \ also a powerful feature of Julia that allows us to pass functions as arguments\
    \ to other functions. Closures are also a powerful feature of Julia that allows\
    \ us to pass functions as arguments to other functions. Closures are also a powerful\
    \ feature of Julia that allows us to pass functions as arguments to other functions.\
    \ Closures are also a powerful feature of Julia that allows us to pass functions\
    \ as arguments to other functions. Closures are also a powerful feature of Julia\
    \ that allows us to pass functions as arguments to other functions. Closures are\
    \ also a powerful feature of Julia that allows us to pass functions as arguments\
    \ to other functions. Closures are also a powerful feature of Julia that allows\
    \ us to pass functions as arguments to other functions. Closures are also a powerful\
    \ feature of Julia that allows us to pass functions as arguments to other functions.\
    \ Closures are also a powerful feature of Julia that allows us to pass functions\
    \ as arguments to other functions. Closures are also a powerful feature of Julia\
    \ that allows us to pass functions as arguments to other functions. Closures are\
    \ also a powerful feature of Julia that allows us to pass functions as arguments\
    \ to other functions. Closures are also a powerful feature of Julia that allows\
    \ us to pass functions as arguments to other functions. Closures are also a powerful\
    \ feature of Julia that allows us to pass functions as arguments to other functions.\
    \ Closures are also a powerful feature of Julia that allows us to pass functions\
    \ as arguments to other functions. \nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp153zqgbd.jl:54\nin expression starting at\
    \ /tmp/tmp153zqgbd.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ elseif value == \"0\"\n        error(\"value cannot be 0\")\n    elseif value\
    \ == \"-\"\n        error(\"value cannot be negative\")\n    elseif value == \"\
    +\"\n        error(\"value cannot be positive\")\n    elseif value == \".\"\n\
    \        error(\"value cannot be a decimal point\")\n    elseif value == \"e\"\
    \n        error(\"value cannot be an exponent\")\n    elseif value == \"E\"\n\
    \        error(\"value cannot be an exponent\")\n    elseif value == \"+\"\n \
    \       error(\"value cannot be an exponent\")\n    elseif value == \"-\"\n  \
    \      error(\"value cannot be an exponent\")\n    elseif value == \"*\"\n   \
    \     error(\"value cannot be an exponent\")\n    elseif value == \"/\"\n    \
    \    error(\"value cannot be an exponent\")\n    elseif value == \"%\"\n     \
    \   error(\"value cannot be an exponent\")\n    elseif value == \"^\"\n      \
    \  error(\"value cannot be an exponent\")\n    elseif value == \"~\"\n       \
    \ error(\"value cannot be an exponent\")\n    elseif value == \"-\"\n        error(\"\
    value cannot be an exponent\")\n    elseif value == \"+\"\n        error(\"value\
    \ cannot be an exponent\")\n    elseif value == \"*\"\n        error(\"value cannot\
    \ be an exponent\")\n    elseif value == \"/\"\n        error(\"value cannot be\
    \ an exponent\")\n    elseif value == \"%\"\n        error(\"value cannot be an\
    \ exponent\")\n    elseif value == \"^\"\n        error(\"value cannot be an exponent\"\
    )\n    elseif value == \"~\"\n        error(\"value cannot be an exponent\")\n\
    \    elseif value == \"+\"\n        error(\"value cannot be an exponent\")\n \
    \   elseif value == \"-\"\n        error(\"value cannot be an exponent\")\n  \
    \  elseif value == \"*\"\n        error(\"value cannot be an exponent\")\n   \
    \ elseif value == \"/\"\n        error(\"value cannot be an exponent\")\n    elseif\
    \ value == \"%\"\n        error(\"value cannot be an exponent\")\n    elseif value\
    \ == \"^\"\n        error(\"value cannot be an exponent\")\n    elseif value ==\
    \ \"~\"\n        error(\"value cannot be an exponent\")\n    elseif value == \"\
    +\"\n        error(\"value cannot be an exponent\")\n    elseif value == \"-\"\
    \n        error(\"value cannot be an exponent\")\n    elseif value == \"*\"\n\
    \        error(\"value cannot be an exponent\")\n    elseif value == \"/\"\n \
    \       error(\"value cannot be an exponent\")\n    elseif value == \"%\"\n  \
    \      error(\"value cannot be an exponent\")\n    elseif value == \"^\"\n   \
    \     error(\"value cannot be an exponent\")\n    elseif value == \"~\"\n    \
    \    error(\"value cannot be an exponent\")\n    elseif value == \"+\"\n     \
    \   error(\"value cannot be an exponent\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo_rjm712.jl:97\nin expression starting at\
    \ /tmp/tmpo_rjm712.jl:97\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    elseif\
    \ value == \"-\"\n        error(\"value cannot be negative\")\n    elseif value\
    \ == \"+\"\n        error(\"value cannot be positive\")\n    elseif value == \"\
    0\"\n        error(\"value cannot be 0\")\n    elseif value == \"1\"\n       \
    \ error(\"value cannot be 1\")\n    elseif value == \"2\"\n        error(\"value\
    \ cannot be 2\")\n    elseif value == \"3\"\n        error(\"value cannot be 3\"\
    )\n    elseif value == \"4\"\n        error(\"value cannot be 4\")\n    elseif\
    \ value == \"5\"\n        error(\"value cannot be 5\")\n    elseif value == \"\
    6\"\n        error(\"value cannot be 6\")\n    elseif value == \"7\"\n       \
    \ error(\"value cannot be 7\")\n    elseif value == \"8\"\n        error(\"value\
    \ cannot be 8\")\n    elseif value == \"9\"\n        error(\"value cannot be 9\"\
    )\n    elseif value == \"10\"\n        error(\"value cannot be 10\")\n    elseif\
    \ value == \"11\"\n        error(\"value cannot be 11\")\n    elseif value ==\
    \ \"12\"\n        error(\"value cannot be 12\")\n    elseif value == \"13\"\n\
    \        error(\"value cannot be 13\")\n    elseif value == \"14\"\n        error(\"\
    value cannot be 14\")\n    elseif value == \"15\"\n        error(\"value cannot\
    \ be 15\")\n    elseif value == \"16\"\n        error(\"value cannot be 16\")\n\
    \    elseif value == \"17\"\n        error(\"value cannot be 17\")\n    elseif\
    \ value == \"18\"\n        error(\"value cannot be 18\")\n    elseif value ==\
    \ \"19\"\n        error(\"value cannot be 19\")\n    elseif value == \"20\"\n\
    \        error(\"value cannot be 20\")\n    elseif value == \"21\"\n        error(\"\
    value cannot be 21\")\n    elseif value == \"22\"\n        error(\"value cannot\
    \ be 22\")\n    elseif value == \"23\"\n        error(\"value cannot be 23\")\n\
    \    elseif value == \"24\"\n        error(\"value cannot be 24\")\n    elseif\
    \ value == \"25\"\n        error(\"value cannot be 25\")\n    elseif value ==\
    \ \"26\"\n        error(\"value cannot be 26\")\n    elseif value == \"27\"\n\
    \        error(\"value cannot be 27\")\n    elseif value == \"28\"\n        error(\"\
    value cannot be 28\")\n    elseif value == \"29\"\n        error(\"value cannot\
    \ be 29\")\n    elseif value == \"30\"\n        error(\"value cannot be 30\")\n\
    \    elseif value == \"31\"\n        error(\"value cannot be 31\")\n    elseif\
    \ value == \"32\"\n        error(\"value cannot be 32\")\n    elseif value ==\
    \ \"33\"\n        error(\"value cannot be 33\")\n    elseif value == \"34\"\n\
    \        error(\"value cannot be 34\")\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcus4o94p.jl:1\nin expression starting at /tmp/tmpcus4o94p.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \ \n        then return 0\n    \n    digits = split(value, \".\")\n    \n    if\
    \ length(digits) == 2\n        then return digits[1]\n    \n    if length(digits)\
    \ == 1 \n        then return digits[0]\n    \n    if length(digits) == 0\n   \
    \     then return 0\n    \n    digits = digits[2:end]\n    \n    if length(digits)\
    \ == 2\n        then return digits[1]\n    \n    if length(digits) == 1 \n   \
    \     then return digits[0]\n    \n    if length(digits) == 0\n        then return\
    \ 0\n    \n    digits = digits[2:end]\n    \n    if length(digits) == 2\n    \
    \    then return digits[1]\n    \n    if length(digits) == 1 \n        then return\
    \ digits[0]\n    \n    if length(digits) == 0\n        then return 0\n    \n \
    \   digits = digits[2:end]\n    \n    if length(digits) == 2\n        then return\
    \ digits[1]\n    \n    if length(digits) == 1 \n        then return digits[0]\n\
    \    \n    if length(digits) == 0\n        then return 0\n    \n    digits = digits[2:end]\n\
    \    \n    if length(digits) == 2\n        then return digits[1]\n    \n    if\
    \ length(digits) == 1 \n        then return digits[0]\n    \n    if length(digits)\
    \ == 0\n        then return 0\n    \n    digits = digits[2:end]\n    \n    if\
    \ length(digits) == 2\n        then return digits[1]\n    \n    if length(digits)\
    \ == 1 \n        then return digits[0]\n    \n    if length(digits) == 0\n   \
    \     then return 0\n    \n    digits = digits[2:end]\n    \n    if length(digits)\
    \ == 2\n        then return digits[1]\n    \n    if length(digits) == 1 \n   \
    \     then return digits[0]\n    \n    if length(digits) == 0\n        then return\
    \ 0\n    \n    digits = digits[2:end]\n    \n    if length(digits) == 2\n    \
    \    then return digits[1]\n    \n    if length(digits) == 1 \n        then return\
    \ digits[0]\n    \n    if length(digits) == 0\n        then return 0\n    \n \
    \   digits = digits[2:end]\n    \n    if length(digits) == 2\n        then return\
    \ digits[1]\n    \n    if length(digits) == 1 \n        then return digits[0]\n\
    \    \n    if length(digits) == 0\n        then return 0\n    \n    digits = digits[2:end]\n\
    \    \n    if length(digits) == 2\n        then return digits[1]\n    \n    if\
    \ length(digit\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp0fb709qo.jl:22\nin expression starting at /tmp/tmp0fb709qo.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    elseif\
    \ value == \"-\"\n        error(\"value cannot be negative\")\n    elseif value\
    \ == \"+\"\n        error(\"value cannot be positive\")\n    elseif value == \"\
    0\"\n        error(\"value cannot be zero\")\n    elseif value == \"1\"\n    \
    \    error(\"value cannot be one\")\n    elseif value == \"2\"\n        error(\"\
    value cannot be two\")\n    elseif value == \"3\"\n        error(\"value cannot\
    \ be three\")\n    elseif value == \"4\"\n        error(\"value cannot be four\"\
    )\n    elseif value == \"5\"\n        error(\"value cannot be five\")\n    elseif\
    \ value == \"6\"\n        error(\"value cannot be six\")\n    elseif value ==\
    \ \"7\"\n        error(\"value cannot be seven\")\n    elseif value == \"8\"\n\
    \        error(\"value cannot be eight\")\n    elseif value == \"9\"\n       \
    \ error(\"value cannot be nine\")\n    elseif value == \".\"\n        error(\"\
    value cannot be a decimal point\")\n    elseif value == \"e\"\n        error(\"\
    value cannot be an exponent\")\n    elseif value == \"E\"\n        error(\"value\
    \ cannot be an exponent\")\n    elseif value == \"+\"\n        error(\"value cannot\
    \ be an exponent\")\n    elseif value == \"-\"\n        error(\"value cannot be\
    \ an exponent\")\n    elseif value == \"*\"\n        error(\"value cannot be an\
    \ exponent\")\n    elseif value == \"/\"\n        error(\"value cannot be an exponent\"\
    )\n    elseif value == \"%\"\n        error(\"value cannot be an exponent\")\n\
    \    elseif value == \"^\"\n        error(\"value cannot be an exponent\")\n \
    \   elseif value == \"~\"\n        error(\"value cannot be an exponent\")\n  \
    \  elseif value == \"(\"\n        error(\"value cannot be an exponent\")\n   \
    \ elseif value == \")\"\n        error(\"value cannot be an exponent\")\n    elseif\
    \ value == \"[\"\n        error(\"value cannot be an exponent\")\n    elseif value\
    \ == \"]\"\n        error(\"value cannot be an exponent\")\n    elseif value ==\
    \ \"(\"\n        error(\"value cannot be an exponent\")\n    elseif value == \"\
    )\"\n        error(\"value cannot be an exponent\")\n    elseif value == \"{\"\
    \n        error(\"value cannot be an exponent\")\n    elseif value == \"}\"\n\
    \        error(\"value cannot be an exponent\")\n    elseif value == \"[\"\n \
    \       error(\"value cannot be an exponent\")\n    elseif value == \"]\"\n  \
    \      error(\"value cannot be an exponent\")\n    elseif value == \"{\"\n   \
    \     error(\"value cannot be an exponent\")\n    elseif value == \"}\"\n    \
    \    error(\"value cannot be an exponent\")\n    elseif value == \"{\"\n     \
    \   error(\"value cannot be an exponent\")\n    elseif value == \"}\"\n      \
    \  error(\"\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpftcbllb3.jl:98\nin expression starting at\
    \ /tmp/tmpftcbllb3.jl:98\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        local closest, closest2 = 0, math.inf\n        for n in string.split(value)\n\
    \            if n ~= \"\"\n                local n = tonumber(n)\n           \
    \     if n < closest\n                    closest, closest2 = n, closest\n   \
    \             elseif n > closest2\n                    closest, closest2 = closest2,\
    \ n\n            end\n        end\n        return closest\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppg2qz0d3.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmppg2qz0d3.jl:1\n\
    in expression starting at /tmp/tmppg2qz0d3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    closest_integer = Int(0)\n    \n    if value == \"-inf\" or value\
    \ == \"inf\" or value == \"nan\" then\n        return Int64(closest_integer)\n\
    \    end\n    \n    digits = split(value, \".\")\n    \n    if length(digits)\
    \ < 2 then\n        return Int64(closest_integer)\n    end\n    \n    digits_int\
    \ = Int64(0)\n    \n    for d in digits\n        digits_int *= 10\n        digits_int\
    \ += Int64(d)\n    end\n    \n    if digits_int == 0 then\n        return Int64(closest_integer)\n\
    \    end\n    \n    digits_int -= 1\n    \n    if digits_int < 0 then\n      \
    \  digits_int *= -1\n    end\n    \n    if digits_int == 0 then\n        return\
    \ Int64(closest_integer)\n    end\n    \n    if digits_int == 1 then\n       \
    \ return Int64(digits[1])\n    end\n    \n    if digits_int == 2 then\n      \
    \  return Int64(digits[2])\n    end\n    \n    if digits_int == 3 then\n     \
    \   return Int64(digits[2])\n    end\n    \n    if digits_int == 4 then\n    \
    \    return Int64(digits[2])\n    end\n    \n    if digits_int == 5 then\n   \
    \     return Int64(digits[2])\n    end\n    \n    if digits_int == 6 then\n  \
    \      return Int64(digits[2])\n    end\n    \n    if digits_int == 7 then\n \
    \       return Int64(digits[2])\n    end\n    \n    if digits_int == 8 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 9 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 10 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 11 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 12 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 13 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 14 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 15 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 16 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 17 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 18 then\n\
    \        return Int64(digits[2])\n    end\n    \n    if digits_int == 19 \nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"value\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpssatpkmp.jl:22\nin expression starting at /tmp/tmpssatpkmp.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be an empty string\")\n\
    \    elseif value == \"-\"\n        error(\"value cannot be a negative number\"\
    )\n    elseif value == \"+\"\n        error(\"value cannot be a positive number\"\
    )\n    elseif value == \"0\"\n        error(\"value cannot be zero\")\n    elseif\
    \ value == \"1\"\n        error(\"value cannot be one\")\n    elseif value ==\
    \ \"2\"\n        error(\"value cannot be two\")\n    elseif value == \"3\"\n \
    \       error(\"value cannot be three\")\n    elseif value == \"4\"\n        error(\"\
    value cannot be four\")\n    elseif value == \"5\"\n        error(\"value cannot\
    \ be five\")\n    elseif value == \"6\"\n        error(\"value cannot be six\"\
    )\n    elseif value == \"7\"\n        error(\"value cannot be seven\")\n    elseif\
    \ value == \"8\"\n        error(\"value cannot be eight\")\n    elseif value ==\
    \ \"9\"\n        error(\"value cannot be nine\")\n    else\n        error(\"value\
    \ cannot be a number\")\n    end\n    if value == \"-\"\n        return -Int64(round(Int64(value,\
    \ base=10)))\n    else\n        return Int64(round(Int64(value, base=10)))\n \
    \   end\nend\n</cell>\n<text>\nThe function closest_integer takes a string representing\
    \ a number and returns the closest integer to it.\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplf0ig3r0.jl:54\nin expression starting at\
    \ /tmp/tmplf0ig3r0.jl:54\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integer_with_tolerance(value::String)::Int64\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgekx1o_l.jl:21\nin expression starting at\
    \ /tmp/tmpgekx1o_l.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    </cell>\n<code language=julia-1.3>\n\"\"\"\n    closest_integer_with_ifelse(value::String)::Int64\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe8n7jjay.jl:21\nin expression starting at\
    \ /tmp/tmpe8n7jjay.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    end\n\
    \    \n    number = parse(Float64, value)\n    if number == 0\n        error(\"\
    value cannot be 0\")\n    end\n    \n    diff = abs(number - number)\n    if diff\
    \ < 1e-10\n        error(\"value cannot be equidistant from two integers\")\n\
    \    end\n    \n    if diff < 1e-5\n        return number\n    end\n    \n   \
    \ diff = round(diff)\n    if diff == 0\n        return number\n    end\n    \n\
    \    return number - diff\nend\n</cell>\n<text>\nNow let's test our function by\
    \ passing it some random numbers and seeing what we get:\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz8ng67yf.jl:44\nin expression starting at\
    \ /tmp/tmpz8ng67yf.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        return -1\n    \n    number = parse_value(value)\n\
    \    \n    if number == -1\n        return -1\n    \n    closest_integer = math.ceil(number)\n\
    \    \n    if number == closest_integer\n        return closest_integer\n    \n\
    \    return closest_integer\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfqxf3hbq.jl:1\nin expression starting at /tmp/tmpfqxf3hbq.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpolriadua.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpolriadua.jl:1\n\
    in expression starting at /tmp/tmpolriadua.jl:1\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\
    \ \n        closest_integer = Int64(math.floor(value))\n    end\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpzxe3iqd5.jl:30\n  Test threw
    exception\n  Expression: candidate("10") == 10\n  UndefVarError: math not defined\n  Stacktrace:\n   [1]
    closest_integer(value::String)\n     @ Main /tmp/tmpzxe3iqd5.jl:19\n   [2] macro
    expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzxe3iqd5.jl:30 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzxe3iqd5.jl:29\ntest set: Error
    During Test at /tmp/tmpzxe3iqd5.jl:31\n  Test threw exception\n  Expression: candidate("14.5")
    == 15\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpzxe3iqd5.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzxe3iqd5.jl:31 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzxe3iqd5.jl:29\ntest set: Error
    During Test at /tmp/tmpzxe3iqd5.jl:32\n  Test threw exception\n  Expression: candidate("-15.5")
    == -16\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpzxe3iqd5.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzxe3iqd5.jl:32 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzxe3iqd5.jl:29\ntest set: Error
    During Test at /tmp/tmpzxe3iqd5.jl:33\n  Test threw exception\n  Expression: candidate("15.3")
    == 15\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpzxe3iqd5.jl:19\n   [2] macro expansio'
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    closest_integer = if value == \"0\"\
    \ then 0 else if value == \"1\" then 1 else if value == \"2\" then 2 else if value\
    \ == \"3\" then 3 else if value == \"4\" then 4 else if value == \"5\" then 5\
    \ else if value == \"6\" then 6 else if value == \"7\" then 7 else if value ==\
    \ \"8\" then 8 else if value == \"9\" then 9 else if value == \"10\" then 10 else\
    \ if value == \"11\" then 11 else if value == \"12\" then 12 else if value ==\
    \ \"13\" then 13 else if value == \"14\" then 14 else if value == \"15\" then\
    \ 15 else if value == \"16\" then 16 else if value == \"17\" then 17 else if value\
    \ == \"18\" then 18 else if value == \"19\" then 19 else if value == \"20\" then\
    \ 20 else if value == \"21\" then 21 else if value == \"22\" then 22 else if value\
    \ == \"23\" then 23 else if value == \"24\" then 24 else if value == \"25\" then\
    \ 25 else if value == \"26\" then 26 else if value == \"27\" then 27 else if value\
    \ == \"28\" then 28 else if value == \"29\" then 29 else if value == \"30\" then\
    \ 30 else if value == \"31\" then 31 else if value == \"32\" then 32 else if value\
    \ == \"33\" then 33 else if value == \"34\" then 34 else if value == \"35\" then\
    \ 35 else if value == \"36\" then 36 else if value == \"37\" then 37 else if value\
    \ == \"38\" then 38 else if value == \"39\" then 39 else if value == \"40\" then\
    \ 40 else if value == \"41\" then 41 else if value == \"42\" then 42 else if value\
    \ == \"43\" then 43 else if value == \"44\" then 44 else if value == \"45\" then\
    \ 45 else if value == \"46\" then 46 else if value == \"47\" then 47 else if value\
    \ == \"48\" then 48 else if value == \"49\" then 49 else if value == \"50\" then\
    \ 50 else if value == \"51\" then 51 else if value == \"52\" then 52 else if value\
    \ == \"53\" then 53 else if value == \"54\" then 54 else if value == \"55\" then\
    \ 55 else if value == \"56\" then 56 else if value == \"57\" then 57 else if value\
    \ == \"58\" then 58 else if value == \"59\" then 59 else if value == \"60\" then\
    \ 60 else if value == \"61\" then 61 else if value == \"62\" then 6\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpx9fztwmy.jl:21\nin expression starting at /tmp/tmpx9fztwmy.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \ || value == \"+0\" || value == \"+-0\" || value == \"++0\"\n        return Int(0)\n\
    \    \n    digits = split(value, \".\")\n    \n    if digits.length == 0 || digits.length\
    \ == 1\n        return Int(value)\n    \n    digits_int = digits[1]\n    \n  \
    \  if digits_int == \"0\"\n        return Int(value)\n    \n    digits_int = digits_int.toInt()\n\
    \    \n    if digits_int == 0\n        return Int(value)\n    \n    digits_int\
    \ = digits_int - 1\n    \n    if digits_int == 0\n        return Int(value)\n\
    \    \n    digits_int = digits_int + 1\n    \n    if digits_int == 0\n       \
    \ return Int(value)\n    \n    digits_int = digits_int - 1\n    \n    if digits_int\
    \ == 0\n        return Int(value)\n    \n    digits_int = digits_int + 1\n   \
    \ \n    if digits_int == 0\n        return Int(value)\n    \n    digits_int =\
    \ digits_int - 1\n    \n    if digits_int == 0\n        return Int(value)\n  \
    \  \n    digits_int = digits_int + 1\n    \n    if digits_int == 0\n        return\
    \ Int(value)\n    \n    digits_int = digits_int - 1\n    \n    if digits_int ==\
    \ 0\n        return Int(value)\n    \n    digits_int = digits_int + 1\n    \n\
    \    if digits_int == 0\n        return Int(value)\n    \n    digits_int = digits_int\
    \ - 1\n    \n    if digits_int == 0\n        return Int(value)\n    \n    digits_int\
    \ = digits_int + 1\n    \n    if digits_int == 0\n        return Int(value)\n\
    \    \n    digits_int = digits_int - 1\n    \n    if digits_int == 0\n       \
    \ return Int(value)\n    \n    digits_int = digits_int + 1\n    \n    if digits_int\
    \ == 0\n        return Int(value)\n    \n    digits_int = digits_int - 1\n   \
    \ \n    if digits_int == 0\n        return Int(value)\n    \n    digits_int =\
    \ digits_int + 1\n    \n    if digits_int == 0\n        return Int(value)\n  \
    \  \n    digits_int = digits_int - 1\n    \n    if digits_int == 0\n        return\
    \ Int(value)\n    \n    digits_int = digits_int + 1\n    \n    if digits_int ==\
    \ 0\n        return Int(value)\n    \n    digits_int = digits_int - 1\n    \n\
    \    if digits_int == \nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr53qqvp3.jl:1\nin expression starting at /tmp/tmpr53qqvp3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.floor(value))\n    if closest_integer ==\
    \ value:\n        closest_integer = Int64(math.ceil(value))\n        if closest_integer\
    \ == value:\n            closest_integer = Int64(math.round(value))\n    return\
    \ closest_integer\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpst5e2hz9.jl:21\nin expression starting at\
    \ /tmp/tmpst5e2hz9.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        0\n    else\n        closest_integer(value[end-1])\
    \ + 1 \nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    Create a function\
    \ that takes a value (string) representing a number\n    and returns the closest\
    \ float to it. If the number is equidistant\n    from two floats, round it away\
    \ from zero.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwqaocqv3.jl:24\nin expression starting at\
    \ /tmp/tmpwqaocqv3.jl:24\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" \n        then return -Inf \n    else if value ==\
    \ \"inf\" \n        then return Inf \n    else if value == \"nan\" \n        then\
    \ return NaN \n    else if value == \"0\" \n        then return 0 \n    else if\
    \ value == \"1\" \n        then return 1 \n    else if value == \"2\" \n     \
    \   then return 2 \n    else if value == \"3\" \n        then return 3 \n    else\
    \ if value == \"4\" \n        then return 4 \n    else if value == \"5\" \n  \
    \      then return 5 \n    else if value == \"6\" \n        then return 6 \n \
    \   else if value == \"7\" \n        then return 7 \n    else if value == \"8\"\
    \ \n        then return 8 \n    else if value == \"9\" \n        then return 9\
    \ \n    else if value == \"10\" \n        then return 10 \n    else if value ==\
    \ \"11\" \n        then return 11 \n    else if value == \"12\" \n        then\
    \ return 12 \n    else if value == \"13\" \n        then return 13 \n    else\
    \ if value == \"14\" \n        then return 14 \n    else if value == \"15\" \n\
    \        then return 15 \n    else if value == \"16\" \n        then return 16\
    \ \n    else if value == \"17\" \n        then return 17 \n    else if value ==\
    \ \"18\" \n        then return 18 \n    else if value == \"19\" \n        then\
    \ return 19 \n    else if value == \"20\" \n        then return 20 \n    else\
    \ if value == \"21\" \n        then return 21 \n    else if value == \"22\" \n\
    \        then return 22 \n    else if value == \"23\" \n        then return 23\
    \ \n    else if value == \"24\" \n        then return 24 \n    else if value ==\
    \ \"25\" \n        then return 25 \n    else if value == \"26\" \n        then\
    \ return 26 \n    else if value == \"27\" \n        then return 27 \n    else\
    \ if value == \"28\" \n        then return 28 \n    else if value == \"29\" \n\
    \        then return 29 \n    else if value == \"30\" \n        then return 30\
    \ \n    else if value == \"31\" \n        then return 31 \n    else if value ==\
    \ \"32\" \n        then return 32 \n    else if value == \"33\" \n        then\
    \ return 33 \n    else if value == \"34\" \n        then return 34 \n    else\
    \ if value == \"35\" \n        then return 35 \n    else if value \nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8t_u2iv7.jl:20\nin expression starting at /tmp/tmp8t_u2iv7.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        0\n    else\n        closest_integer(value[end-1])\
    \ + 1 \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg67ila9c.jl:25\nin expression starting at\
    \ /tmp/tmpg67ila9c.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" \n        then return -Inf \n    else if value ==\
    \ \"inf\" \n        then return Inf \n    else if value == \"nan\" \n        then\
    \ return NaN \n    else if value == \"0\" \n        then return 0 \n    else if\
    \ value == \"1\" \n        then return 1 \n    else if value == \"2\" \n     \
    \   then return 2 \n    else if value == \"3\" \n        then return 3 \n    else\
    \ if value == \"4\" \n        then return 4 \n    else if value == \"5\" \n  \
    \      then return 5 \n    else if value == \"6\" \n        then return 6 \n \
    \   else if value == \"7\" \n        then return 7 \n    else if value == \"8\"\
    \ \n        then return 8 \n    else if value == \"9\" \n        then return 9\
    \ \n    else if value == \"10\" \n        then return 10 \n    else if value ==\
    \ \"11\" \n        then return 11 \n    else if value == \"12\" \n        then\
    \ return 12 \n    else if value == \"13\" \n        then return 13 \n    else\
    \ if value == \"14\" \n        then return 14 \n    else if value == \"15\" \n\
    \        then return 15 \n    else if value == \"16\" \n        then return 16\
    \ \n    else if value == \"17\" \n        then return 17 \n    else if value ==\
    \ \"18\" \n        then return 18 \n    else if value == \"19\" \n        then\
    \ return 19 \n    else if value == \"20\" \n        then return 20 \n    else\
    \ if value == \"21\" \n        then return 21 \n    else if value == \"22\" \n\
    \        then return 22 \n    else if value == \"23\" \n        then return 23\
    \ \n    else if value == \"24\" \n        then return 24 \n    else if value ==\
    \ \"25\" \n        then return 25 \n    else if value == \"26\" \n        then\
    \ return 26 \n    else if value == \"27\" \n        then return 27 \n    else\
    \ if value == \"28\" \n        then return 28 \n    else if value == \"29\" \n\
    \        then return 29 \n    else if value == \"30\" \n        then return 30\
    \ \n    else if value == \"31\" \n        then return 31 \n    else if value ==\
    \ \"32\" \n        then return 32 \n    else if value == \"33\" \n        then\
    \ return 33 \n    else if value == \"34\" \n        then return 34 \n    else\
    \ if value == \"35\" \n        then return 35 \n    else if value \nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp8t_u2iv7.jl:20\nin expression starting at /tmp/tmp8t_u2iv7.jl:20\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        closest_integer(parse(Float64, value))\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpofiv73fp.jl:30\n  Test threw
    exception\n  Expression: candidate("10") == 10\n  MethodError: no method matching
    closest_integer(::Float64)\n  Closest candidates are:\n    closest_integer(!Matched::String)
    at /tmp/tmpofiv73fp.jl:18\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpofiv73fp.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpofiv73fp.jl:30 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpofiv73fp.jl:29\ntest set: Error
    During Test at /tmp/tmpofiv73fp.jl:31\n  Test threw exception\n  Expression: candidate("14.5")
    == 15\n  MethodError: no method matching closest_integer(::Float64)\n  Closest
    candidates are:\n    closest_integer(!Matched::String) at /tmp/tmpofiv73fp.jl:18\n  Stacktrace:\n   [1]
    closest_integer(value::String)\n     @ Main /tmp/tmpofiv73fp.jl:22\n   [2] macro
    expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpofiv73fp.jl:31 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpofiv73fp.jl:29\ntest set: Error
    During Test at /tmp/tmpofiv73fp.jl:32\n  Test threw exception\n  Expression: candidate("-15.5")
    == -16\n  MethodError: no method matching closest_integer(::Float64)\n  Closest
    candidates are:\n    closest_integer(!Matched::String) at /tmp/tmpofiv73fp.jl:18\n  Stacktrace:\n   [1]
    closest_integer(value::String)\n     @ Main /tmp/tmpofiv73fp.jl:22\n   [2] macro
    expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpofiv73fp.jl:32 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/'
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"0\" || value == \"-0\"\n        return 0 \n    \n\
    \    digits = value.digits\n    \n    if digits[1] == 0 && digits[2] == 0\n  \
    \      return 0 \n    \n    digits[1] -= 1\n    digits[2] -= 1\n    \n    if digits[1]\
    \ == 0 && digits[2] == 0\n        return 0 \n    \n    if digits[1] == 0 && digits[2]\
    \ == 1\n        return digits[0] \n    \n    if digits[1] == 1 && digits[2] ==\
    \ 0\n        return digits[0] \n    \n    if digits[1] == 1 && digits[2] == 1\n\
    \        return digits[0] \n    \n    if digits[1] == 2 && digits[2] == 0\n  \
    \      return digits[0] \n    \n    if digits[1] == 2 && digits[2] == 1\n    \
    \    return digits[0] \n    \n    if digits[1] == 2 && digits[2] == 2\n      \
    \  return digits[1] \n    \n    if digits[1] == 3 && digits[2] == 0\n        return\
    \ digits[1] \n    \n    if digits[1] == 3 && digits[2] == 1\n        return digits[1]\
    \ \n    \n    if digits[1] == 3 && digits[2] == 2\n        return digits[1] \n\
    \    \n    if digits[1] == 3 && digits[2] == 3\n        return digits[2] \n  \
    \  \n    if digits[1] == 4 && digits[2] == 0\n        return digits[2] \n    \n\
    \    if digits[1] == 4 && digits[2] == 1\n        return digits[2] \n    \n  \
    \  if digits[1] == 4 && digits[2] == 2\n        return digits[2] \n    \n    if\
    \ digits[1] == 4 && digits[2] == 3\n        return digits[2] \n    \n    if digits[1]\
    \ == 5 && digits[2] == 0\n        return digits[2] \n    \n    if digits[1] ==\
    \ 5 && digits[2] == 1\n        return digits[2] \n    \n    if digits[1] == 5\
    \ && digits[2] == 2\n        return digits[2] \n    \n    if digits[1] == 5 &&\
    \ digits[2] == 3\n        return digits[2] \n    \n    if digits[1] == 6 && digits[2]\
    \ == 0\n        return digits[2] \n    \n    if digits[1] == 6 && digits[2] ==\
    \ 1\n        return digits[2] \n    \n    if digits[1] == 6 && digits[2] == 2\n\
    \        return digits[2] \n    \n    if digits[1] == 6 && digits[2] == 3\n  \
    \      return digits[2] \n    \n    if digits[1] == 7 && digits[2] == 0\n    \
    \    return digits[2] \n    \n    if digits[1] == 7 && digits[2] == 1\n      \
    \  return digits[2] \n    \n    if digits[1] == 7 && digits[2] == 2\n        return\
    \ digits[2] \n    \n    if digits[1] == 7 && digits[2] == 3\n        return digits[2]\
    \ \n    \n    if digits[1] == 8 && digits[2] == 0\n        return digits[2] \n\
    \    \n    if digits[1] == 8 && digits[2] == 1\n        return digits[2] \n\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw1nhm1lc.jl:1\nin expression starting at /tmp/tmpw1nhm1lc.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    if value == \"\"\n        return\
    \ int64(0)\n    \n    if value == \"-\"\n        return int64(0)\n    \n    if\
    \ value == \"0\"\n        return int64(0)\n    \n    if value == \"1\"\n     \
    \   return int64(1)\n    \n    if value == \"2\"\n        return int64(2)\n  \
    \  \n    if value == \"3\"\n        return int64(3)\n    \n    if value == \"\
    4\"\n        return int64(4)\n    \n    if value == \"5\"\n        return int64(5)\n\
    \    \n    if value == \"6\"\n        return int64(6)\n    \n    if value == \"\
    7\"\n        return int64(7)\n    \n    if value == \"8\"\n        return int64(8)\n\
    \    \n    if value == \"9\"\n        return int64(9)\n    \n    if value == \"\
    10\"\n        return int64(10)\n    \n    if value == \"11\"\n        return int64(11)\n\
    \    \n    if value == \"12\"\n        return int64(12)\n    \n    if value ==\
    \ \"13\"\n        return int64(13)\n    \n    if value == \"14\"\n        return\
    \ int64(14)\n    \n    if value == \"15\"\n        return int64(15)\n    \n  \
    \  if value == \"16\"\n        return int64(16)\n    \n    if value == \"17\"\n\
    \        return int64(17)\n    \n    if value == \"18\"\n        return int64(18)\n\
    \    \n    if value == \"19\"\n        return int64(19)\n    \n    if value ==\
    \ \"20\"\n        return int64(20)\n    \n    if value == \"21\"\n        return\
    \ int64(21)\n    \n    if value == \"22\"\n        return int64(22)\n    \n  \
    \  if value == \"23\"\n        return int64(23)\n    \n    if value == \"24\"\n\
    \        return int64(24)\n    \n    if value == \"25\"\n        return int64(25)\n\
    \    \n    if value == \"26\"\n        return int64(26)\n    \n    if value ==\
    \ \"27\"\n        return int64(27)\n    \n    if value == \"28\"\n        return\
    \ int64(28)\n    \n    if value == \"29\"\n        return int64(29)\n    \n  \
    \  if value == \"30\"\n        return int64(30)\n    \n    if value == \"31\"\n\
    \        return int64(31)\n    \n    if value == \"32\"\n        return int64(32)\n\
    \    \n    if value == \"33\"\n        return int64(33)\n    \n    if value ==\
    \ \"34\"\n        return int64(34)\n    \n    if value == \"35\"\n        return\
    \ int64(35)\n    \n    if value == \"36\"\n        return int64(36)\n    \n  \
    \  if value == \"37\"\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjvjxy_wa.jl:1\nin expression starting at /tmp/tmpjvjxy_wa.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    closest_integer = if value == \"\"\
    \ then 0 else Int(value)\n    \n    closest_integer = if closest_integer == 0\
    \ then 1 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 1 then 1 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 2 then 2 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 3 then 3 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 4 then 4 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 5 then 5 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 6 then 6 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 7 then 7 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 8 then 8 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 9 then 9 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 10 then 10 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 11 then 11 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 12 then 12 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 13 then 13 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 14 then 14 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 15 then 15 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 16 then 16 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 17 then 17 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 18 then 18 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 19 then 19 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 20 then 20 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 21 then 21 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 22 then 22 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 23 then 23 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 24 then 24 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 25 then 25 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 26 then 26 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 27 then 27 else closest_integer\n    \n    closest_integer = if closest_integer\
    \ == 28 then 28 else closest_integer\n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp_0yppe0r.jl:21\nin expression starting at /tmp/tmp_0yppe0r.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\":\n        return\
    \ closest_integer\n    \n    digits = value.digits\n    \n    if digits.length\
    \ == 0 or digits.length == 1:\n        return closest_integer\n    \n    digits_sum\
    \ = digits[digits.length-1]\n    \n    if digits_sum < digits[0]:\n        closest_integer\
    \ = Int(digits[0])\n        return closest_integer\n    \n    digits_sum = digits[digits.length-2]\n\
    \    \n    if digits_sum < digits[1]:\n        closest_integer = Int(digits[1])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-3]\n\
    \    \n    if digits_sum < digits[2]:\n        closest_integer = Int(digits[2])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-4]\n\
    \    \n    if digits_sum < digits[3]:\n        closest_integer = Int(digits[3])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-5]\n\
    \    \n    if digits_sum < digits[4]:\n        closest_integer = Int(digits[4])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-6]\n\
    \    \n    if digits_sum < digits[5]:\n        closest_integer = Int(digits[5])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-7]\n\
    \    \n    if digits_sum < digits[6]:\n        closest_integer = Int(digits[6])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-8]\n\
    \    \n    if digits_sum < digits[7]:\n        closest_integer = Int(digits[7])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-9]\n\
    \    \n    if digits_sum < digits[8]:\n        closest_integer = Int(digits[8])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-10]\n\
    \    \n    if digits_sum < digits[9]:\n        closest_integer = Int(digits[9])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-11]\n\
    \    \n    if digits_sum < digits[10]:\n        closest_integer = Int(digits[10])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-12]\n\
    \    \n    if digits_sum < digits[11]:\n        closest_integer = Int(digits[11])\n\
    \        return closest_integer\n    \n    digits_sum = digits[digits.length-13]\n\
    \    \n    if digits_sum\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqqnkc7a9.jl:22\nin expression starting at\
    \ /tmp/tmpqqnkc7a9.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8dw21um_.jl:21\nin expression starting at\
    \ /tmp/tmp8dw21um_.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"Value cannot be empty\")\n   \
    \ elseif value == \"-\"\n        error(\"Value cannot be negative\")\n    elseif\
    \ value == \"+\"\n        error(\"Value cannot be positive\")\n    elseif value\
    \ == \"0\"\n        error(\"Value cannot be zero\")\n    elseif value == \"1\"\
    \n        error(\"Value cannot be one\")\n    elseif value == \"2\"\n        error(\"\
    Value cannot be two\")\n    elseif value == \"3\"\n        error(\"Value cannot\
    \ be three\")\n    elseif value == \"4\"\n        error(\"Value cannot be four\"\
    )\n    elseif value == \"5\"\n        error(\"Value cannot be five\")\n    elseif\
    \ value == \"6\"\n        error(\"Value cannot be six\")\n    elseif value ==\
    \ \"7\"\n        error(\"Value cannot be seven\")\n    elseif value == \"8\"\n\
    \        error(\"Value cannot be eight\")\n    elseif value == \"9\"\n       \
    \ error(\"Value cannot be nine\")\n    elseif value == \".\"\n        error(\"\
    Value cannot be a decimal point\")\n    elseif value == \"e\"\n        error(\"\
    Value cannot be an exponent\")\n    elseif value == \"E\"\n        error(\"Value\
    \ cannot be an exponent with capital E\")\n    elseif value == \"+\"\n       \
    \ error(\"Value cannot be an exponent with plus sign\")\n    elseif value == \"\
    -\"\n        error(\"Value cannot be an exponent with minus sign\")\n    elseif\
    \ value == \"*\"\n        error(\"Value cannot be an exponent with asterisk\"\
    )\n    elseif value == \"/\"\n        error(\"Value cannot be an exponent with\
    \ division sign\")\n    elseif value == \"%\"\n        error(\"Value cannot be\
    \ an exponent with percent sign\")\n    elseif value == \"^\"\n        error(\"\
    Value cannot be an exponent with caret sign\")\n    elseif value == \"~\"\n  \
    \      error(\"Value cannot be an exponent with tilde sign\")\n    elseif value\
    \ == \"(\"\n        error(\"Value cannot be an exponent with left parenthesis\"\
    )\n    elseif value == \")\"\n        error(\"Value cannot be an exponent with\
    \ right parenthesis\")\n    elseif value == \"[\"\n        error(\"Value cannot\
    \ be an exponent with left square bracket\")\n    elseif value == \"]\"\n    \
    \    error(\"Value cannot be an exponent with right square bracket\")\n    elseif\
    \ value == \"{\"\n        error(\"Value cannot be an exponent with left curly\
    \ bracket\")\n    elseif value == \"}\"\n        error(\"Value cannot be an exponent\
    \ with right curly bracket\")\n    elseif value == \"<\"\n        error(\"Value\
    \ cannot be an exponent with left angle bracket\")\n    elseif value == \">\"\n\
    \        error(\"Value cannot be an exponent with right angle bracket\")\n   \
    \ elseif value == \"=\"\n        error(\"Value cannot be an exponent \nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp80besl01.jl:89\nin expression starting at\
    \ /tmp/tmp80besl01.jl:89\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"Value cannot be empty\")\n   \
    \ elseif value == \"-\"\n        error(\"Value cannot be negative\")\n    elseif\
    \ value == \"+\"\n        error(\"Value cannot be positive\")\n    elseif value\
    \ == \"0\"\n        error(\"Value cannot be zero\")\n    elseif value == \"1\"\
    \n        error(\"Value cannot be one\")\n    elseif value == \"2\"\n        error(\"\
    Value cannot be two\")\n    elseif value == \"3\"\n        error(\"Value cannot\
    \ be three\")\n    elseif value == \"4\"\n        error(\"Value cannot be four\"\
    )\n    elseif value == \"5\"\n        error(\"Value cannot be five\")\n    elseif\
    \ value == \"6\"\n        error(\"Value cannot be six\")\n    elseif value ==\
    \ \"7\"\n        error(\"Value cannot be seven\")\n    elseif value == \"8\"\n\
    \        error(\"Value cannot be eight\")\n    elseif value == \"9\"\n       \
    \ error(\"Value cannot be nine\")\n    else\n        \n        local num = tonumber(value)\n\
    \        local closest\n        local diff\n        \n        if num == NaN\n\
    \            error(\"Value cannot be converted to a number\")\n        elseif\
    \ num == 0\n            error(\"Value cannot be zero\")\n        elseif num ==\
    \ 1\n            error(\"Value cannot be one\")\n        elseif num == 2\n   \
    \         error(\"Value cannot be two\")\n        elseif num == 3\n          \
    \  error(\"Value cannot be three\")\n        elseif num == 4\n            error(\"\
    Value cannot be four\")\n        elseif num == 5\n            error(\"Value cannot\
    \ be five\")\n        elseif num == 6\n            error(\"Value cannot be six\"\
    )\n        elseif num == 7\n            error(\"Value cannot be seven\")\n   \
    \     elseif num == 8\n            error(\"Value cannot be eight\")\n        elseif\
    \ num == 9\n            error(\"Value cannot be nine\")\n        else\n      \
    \      \n            closest = num\n            diff = abs(num - closest)\n  \
    \          \n            if diff == 0\n                error(\"Value cannot be\
    \ equidistant from two integers\")\n            elseif diff == 1\n           \
    \     closest = closest + 1\n            elseif diff == 2\n                closest\
    \ = closest + 2\n            elseif diff == 3\n                closest = closest\
    \ + 3\n            elseif diff == 4\n                closest = closest + 4\n \
    \           elseif diff == 5\n                closest = closest + 5\n        \
    \    elseif diff == 6\n                closest = closest + 6\n            elseif\
    \ diff == 7\n                closest = closest + 7\n            elseif diff ==\
    \ 8\n                closest = closest + 8\n            elseif diff == 9\n   \
    \             closest = closest + 9\n            else\n                closest\
    \ = closest + 1\n            end\n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpl3c_31qr.jl:72\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpl3c_31qr.jl:1\n\
    in expression starting at /tmp/tmpl3c_31qr.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    local closest_value = int64(0)\n\
    \    local closest_difference = int64(0)\n    \n    for value in string.gmatch(value,\
    \ \"%d+\") do \n        local difference = int64(value - closest_value)\n    \
    \    if difference < closest_difference then\n            closest_value = value\n\
    \            closest_difference = difference\n        end\n    end\n    \n   \
    \ return closest_value\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4qkue0r0.jl:34\nin expression starting at\
    \ /tmp/tmp4qkue0r0.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    closest_integer = if value == \"0\" then\
    \ 0 else value\n    closest_integer = if value == \"1\" then 1 else value\n  \
    \  closest_integer = if value == \"2\" then 2 else value\n    closest_integer\
    \ = if value == \"3\" then 3 else value\n    closest_integer = if value == \"\
    4\" then 4 else value\n    closest_integer = if value == \"5\" then 5 else value\n\
    \    closest_integer = if value == \"6\" then 6 else value\n    closest_integer\
    \ = if value == \"7\" then 7 else value\n    closest_integer = if value == \"\
    8\" then 8 else value\n    closest_integer = if value == \"9\" then 9 else value\n\
    \    closest_integer = if value == \"10\" then 10 else value\n    closest_integer\
    \ = if value == \"11\" then 11 else value\n    closest_integer = if value == \"\
    12\" then 12 else value\n    closest_integer = if value == \"13\" then 13 else\
    \ value\n    closest_integer = if value == \"14\" then 14 else value\n    closest_integer\
    \ = if value == \"15\" then 15 else value\n    closest_integer = if value == \"\
    16\" then 16 else value\n    closest_integer = if value == \"17\" then 17 else\
    \ value\n    closest_integer = if value == \"18\" then 18 else value\n    closest_integer\
    \ = if value == \"19\" then 19 else value\n    closest_integer = if value == \"\
    20\" then 20 else value\n    closest_integer = if value == \"21\" then 21 else\
    \ value\n    closest_integer = if value == \"22\" then 22 else value\n    closest_integer\
    \ = if value == \"23\" then 23 else value\n    closest_integer = if value == \"\
    24\" then 24 else value\n    closest_integer = if value == \"25\" then 25 else\
    \ value\n    closest_integer = if value == \"26\" then 26 else value\n    closest_integer\
    \ = if value == \"27\" then 27 else value\n    closest_integer = if value == \"\
    28\" then 28 else value\n    closest_integer = if value == \"29\" then 29 else\
    \ value\n    closest_integer = if value == \"30\" then 30 else value\n    closest_integer\
    \ = if value == \"31\" then 31 else value\n    closest_integer = if value == \"\
    32\" then 32 else value\n    closest_integer = if value == \"33\" then 33 else\
    \ value\n    closest_integer = if value == \"34\" then 34 else value\n    closest_integer\
    \ = if value == \"35\" then 35 else value\n    closest_integer = if value == \"\
    \nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfobu6ogu.jl:20\nin expression starting at /tmp/tmpfobu6ogu.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"Value cannot be empty\")\n    else\n\
    \        closest_integer(parse(Float64, value))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.4>\n\"\"\"\n    closest_integer(value::Float64)\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcagw18gh.jl:25\nin expression starting at\
    \ /tmp/tmpcagw18gh.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ elseif value == \"-\"\n        error(\"value cannot be -, use 0 instead\")\n\
    \    elseif value == \"0\"\n        error(\"value cannot be 0, use 1 instead\"\
    )\n    elseif value == \"1\"\n        error(\"value cannot be 1, use 2 instead\"\
    )\n    elseif value == \"2\"\n        error(\"value cannot be 2, use 3 instead\"\
    )\n    elseif value == \"3\"\n        error(\"value cannot be 3, use 4 instead\"\
    )\n    elseif value == \"4\"\n        error(\"value cannot be 4, use 5 instead\"\
    )\n    elseif value == \"5\"\n        error(\"value cannot be 5, use 6 instead\"\
    )\n    elseif value == \"6\"\n        error(\"value cannot be 6, use 7 instead\"\
    )\n    elseif value == \"7\"\n        error(\"value cannot be 7, use 8 instead\"\
    )\n    elseif value == \"8\"\n        error(\"value cannot be 8, use 9 instead\"\
    )\n    elseif value == \"9\"\n        error(\"value cannot be 9, use 10 instead\"\
    )\n    elseif value == \"10\"\n        error(\"value cannot be 10, use 11 instead\"\
    )\n    elseif value == \"11\"\n        error(\"value cannot be 11, use 12 instead\"\
    )\n    elseif value == \"12\"\n        error(\"value cannot be 12, use 13 instead\"\
    )\n    elseif value == \"13\"\n        error(\"value cannot be 13, use 14 instead\"\
    )\n    elseif value == \"14\"\n        error(\"value cannot be 14, use 15 instead\"\
    )\n    elseif value == \"15\"\n        error(\"value cannot be 15, use 16 instead\"\
    )\n    elseif value == \"16\"\n        error(\"value cannot be 16, use 17 instead\"\
    )\n    elseif value == \"17\"\n        error(\"value cannot be 17, use 18 instead\"\
    )\n    elseif value == \"18\"\n        error(\"value cannot be 18, use 19 instead\"\
    )\n    elseif value == \"19\"\n        error(\"value cannot be 19, use 20 instead\"\
    )\n    elseif value == \"20\"\n        error(\"value cannot be 20, use 21 instead\"\
    )\n    elseif value == \"21\"\n        error(\"value cannot be 21, use 22 instead\"\
    )\n    elseif value == \"22\"\n        error(\"value cannot be 22, use 23 instead\"\
    )\n    elseif value == \"23\"\n        error(\"value cannot be 23, use 24 instead\"\
    )\n    elseif value == \"24\"\n        error(\"value cannot be 24, use 25 instead\"\
    )\n    elseif value == \"25\"\n        error(\"value cannot be 25, use 26 instead\"\
    )\n    elseif value == \"26\"\n        error(\"value cannot be 26, use 27 instead\"\
    )\n    elseif value == \"27\"\n        error(\"value cannot be 27, use 28 instead\"\
    )\n    elseif value == \"28\"\n        error(\"value cannot be 28, use \nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5q2olt6y.jl:87\nin expression starting at\
    \ /tmp/tmp5q2olt6y.jl:87\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    closest_integer = int64(math.floor(value))\n\
    \    if closest_integer == int64(0)\n        closest_integer = int64(math.ceil(value))\n\
    \    return closest_integer\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n\
    \    closest_integer_with_tolerance(value::String, tolerance::Real)::Int64\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8lv7ebei.jl:25\nin expression starting at\
    \ /tmp/tmp8lv7ebei.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"0\" || value == \"-0\" \n        then return 0\n \
    \   else if value == \"1\" || value == \"-1\" \n        then return -1\n    else\
    \ if value == \"2\" || value == \"-2\" \n        then return -2\n    else if value\
    \ == \"3\" || value == \"-3\" \n        then return -3\n    else if value == \"\
    4\" || value == \"-4\" \n        then return -4\n    else if value == \"5\" ||\
    \ value == \"-5\" \n        then return -5\n    else if value == \"6\" || value\
    \ == \"-6\" \n        then return -6\n    else if value == \"7\" || value == \"\
    -7\" \n        then return -7\n    else if value == \"8\" || value == \"-8\" \n\
    \        then return -8\n    else if value == \"9\" || value == \"-9\" \n    \
    \    then return -9\n    else if value == \"10\" || value == \"-10\" \n      \
    \  then return -10\n    else if value == \"11\" || value == \"-11\" \n       \
    \ then return -11\n    else if value == \"12\" || value == \"-12\" \n        then\
    \ return -12\n    else if value == \"13\" || value == \"-13\" \n        then return\
    \ -13\n    else if value == \"14\" || value == \"-14\" \n        then return -14\n\
    \    else if value == \"15\" || value == \"-15\" \n        then return -15\n \
    \   else if value == \"16\" || value == \"-16\" \n        then return -16\n  \
    \  else if value == \"17\" || value == \"-17\" \n        then return -17\n   \
    \ else if value == \"18\" || value == \"-18\" \n        then return -18\n    else\
    \ if value == \"19\" || value == \"-19\" \n        then return -19\n    else if\
    \ value == \"20\" || value == \"-20\" \n        then return -20\n    else if value\
    \ == \"21\" || value == \"-21\" \n        then return -21\n    else if value ==\
    \ \"22\" || value == \"-22\" \n        then return -22\n    else if value == \"\
    23\" || value == \"-23\" \n        then return -23\n    else if value == \"24\"\
    \ || value == \"-24\" \n        then return -24\n    else if value == \"25\" ||\
    \ value == \"-25\" \n        then return -25\n    else if value == \"26\" || value\
    \ == \"-26\" \n        then return -26\n    else if value == \"27\" || value ==\
    \ \"-27\" \n        then return -27\n    else if value == \"28\" || value == \"\
    -28\" \n        then return -28\n    else if value \nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpt29iz276.jl:21\nin expression starting at /tmp/tmpt29iz276.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    closest_integer = int64(math.floor(value))\n\
    \    if closest_integer == int64(0):\n        closest_integer = int64(math.ceil(value))\n\
    \    return closest_integer\nend\n</cell>\n<code language=julia-1.3>\n\"\"\"\n\
    \    closest_integers(values::Vector{String})\nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppgisixns.jl:22\nin expression starting at\
    \ /tmp/tmppgisixns.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"The value cannot be an empty string\"\
    )\n    end\n    \n    if value == \"-\"\n        return -closest_integer(value[end])\n\
    \    end\n    \n    digits = split(value, \".\")\n    \n    if length(digits)\
    \ < 2\n        error(\"The value cannot be an empty string\")\n    end\n    \n\
    \    digits[1] = digits[1] * 10\n    \n    digits[1] = digits[1] + digits[2]\n\
    \    \n    digits[1] = digits[1] / 10\n    \n    digits[1] = digits[1] % 10\n\
    \    \n    digits[1] = digits[1] + digits[3]\n    \n    digits[1] = digits[1]\
    \ / 10\n    \n    digits[1] = digits[1] % 10\n    \n    digits[1] = digits[1]\
    \ + digits[4]\n    \n    digits[1] = digits[1] / 10\n    \n    digits[1] = digits[1]\
    \ % 10\n    \n    digits[1] = digits[1] + digits[5]\n    \n    digits[1] = digits[1]\
    \ / 10\n    \n    digits[1] = digits[1] % 10\n    \n    digits[1] = digits[1]\
    \ + digits[6]\n    \n    digits[1] = digits[1] / 10\n    \n    digits[1] = digits[1]\
    \ % 10\n    \n    digits[1] = digits[1] + digits[7]\n    \n    digits[1] = digits[1]\
    \ / 10\n    \n    digits[1] = digits[1] % 10\n    \n    digits[1] = digits[1]\
    \ + digits[8]\n    \n    digits[1] = digits[1] / 10\n    \n    digits[1] = digits[1]\
    \ % 10\n    \n    digits[1] = digits[1] + digits[9]\n    \n    digits[1] = digits[1]\
    \ / 10\n    \n    digits[1] = digits[1] % 10\n    \n    digits[1] = digits[1]\
    \ + digits[10]\n    \n    digits[1] = digits[1] / 10\n    \n    digits[1] = digits[1]\
    \ % 10\n    \n    digits[1] = digits[1] + digits[11]\n    \n    digits[1] = digits[1]\
    \ / 10\n    \n    digits[1] = digits[1] % 10\n    \n    digits[1] = digits[1]\
    \ + digits[12]\n    \n    digits[1] = digits[1] / 10\n    \n    digits[1] = digits[1]\
    \ % 10\n    \n    digits[1] = digits[1] + digits[13]\n    \n    digits[1] = digits[1]\
    \ / 10\n    \n    digits[1] = digits[1] % 10\n    \n    digits[1] = digits[1]\
    \ + digits[14]\n    \nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpurba28ss.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpurba28ss.jl:1\n\
    in expression starting at /tmp/tmpurba28ss.jl:1\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(Int64(value)))\n    if closest_integer\
    \ == Int64(value) \n        closest_integer = Int64(0)\n    end\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpoqer1oun.jl:30\n  Test threw
    exception\n  Expression: candidate("10") == 10\n  UndefVarError: math not defined\n  Stacktrace:\n   [1]
    closest_integer(value::String)\n     @ Main /tmp/tmpoqer1oun.jl:19\n   [2] macro
    expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpoqer1oun.jl:30 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpoqer1oun.jl:29\ntest set: Error
    During Test at /tmp/tmpoqer1oun.jl:31\n  Test threw exception\n  Expression: candidate("14.5")
    == 15\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpoqer1oun.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpoqer1oun.jl:31 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpoqer1oun.jl:29\ntest set: Error
    During Test at /tmp/tmpoqer1oun.jl:32\n  Test threw exception\n  Expression: candidate("-15.5")
    == -16\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpoqer1oun.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpoqer1oun.jl:32 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpoqer1oun.jl:29\ntest set: Error
    During Test at /tmp/tmpoqer1oun.jl:33\n  Test threw exception\n  Expression: candidate("15.3")
    == 15\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpoqer1oun.jl:19\n   [2] macro expansio'
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpat52emjn.jl:21\nin expression starting at\
    \ /tmp/tmpat52emjn.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be an empty string\")\n\
    \    elseif value == \"0\"\n        error(\"value cannot be 0\")\n    elseif value\
    \ == \"1\"\n        error(\"value cannot be 1\")\n    elseif value == \"-1\"\n\
    \        error(\"value cannot be -1\")\n    elseif value == \"-2\"\n        error(\"\
    value cannot be -2\")\n    elseif value == \"-99\"\n        error(\"value cannot\
    \ be -99\")\n    elseif value == \"-99.9\"\n        error(\"value cannot be -99.9\"\
    )\n    elseif value == \"-999\"\n        error(\"value cannot be -999\")\n   \
    \ elseif value == \"-999.9\"\n        error(\"value cannot be -999.9\")\n    elseif\
    \ value == \"-9999\"\n        error(\"value cannot be -9999\")\n    elseif value\
    \ == \"-9999.9\"\n        error(\"value cannot be -9999.9\")\n    elseif value\
    \ == \"-99999\"\n        error(\"value cannot be -99999\")\n    elseif value ==\
    \ \"-99999.9\"\n        error(\"value cannot be -99999.9\")\n    elseif value\
    \ == \"-999999\"\n        error(\"value cannot be -999999\")\n    elseif value\
    \ == \"-999999.9\"\n        error(\"value cannot be -999999.9\")\n    elseif value\
    \ == \"-9999999\"\n        error(\"value cannot be -9999999\")\n    elseif value\
    \ == \"-9999999.9\"\n        error(\"value cannot be -9999999.9\")\n    elseif\
    \ value == \"-99999999\"\n        error(\"value cannot be -99999999\")\n    elseif\
    \ value == \"-99999999.9\"\n        error(\"value cannot be -99999999.9\")\n \
    \   elseif value == \"-999999999\"\n        error(\"value cannot be -999999999\"\
    )\n    elseif value == \"-999999999.9\"\n        error(\"value cannot be -999999999.9\"\
    )\n    elseif value == \"-99999999999\"\n        error(\"value cannot be -99999999999\"\
    )\n    elseif value == \"-99999999999.9\"\n        error(\"value cannot be -99999999999.9\"\
    )\n    elseif value == \"-9999999999\"\n        error(\"value cannot be -9999999999\"\
    )\n    elseif value == \"-9999999999.9\"\n        error(\"value cannot be -9999999999.9\"\
    )\n    elseif value == \"-99999999999999\"\n        error(\"value cannot be -99999999999999\"\
    )\n    elseif value == \"-99999999999999.9\"\n        error(\"value cannot be\
    \ -99999999999999.9\")\n    elseif value == \"-999999999999999\"\n        error(\"\
    value cannot be -999999999999999\")\n    elseif value == \"-999999999999999.9\"\
    \n        error(\"value cannot be -999999999999999.9\")\n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpal7oiz9e.jl:1\nin expression starting at /tmp/tmpal7oiz9e.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.floor(Int64(value)))\n    if closest_integer\
    \ == Int64(value) \n        closest_integer = Int64(0)\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpok3xic2l.jl:25\nin expression starting at\
    \ /tmp/tmpok3xic2l.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ end\n    \n    if value == \"0\"\n        return 0\n    end\n    \n    if value\
    \ == \"1\"\n        return 1\n    end\n    \n    if value == \"2\"\n        return\
    \ 2\n    end\n    \n    if value == \"3\"\n        return 3\n    end\n    \n \
    \   if value == \"4\"\n        return 4\n    end\n    \n    if value == \"5\"\n\
    \        return 5\n    end\n    \n    if value == \"6\"\n        return 6\n  \
    \  end\n    \n    if value == \"7\"\n        return 7\n    end\n    \n    if value\
    \ == \"8\"\n        return 8\n    end\n    \n    if value == \"9\"\n        return\
    \ 9\n    end\n    \n    if value == \"10\"\n        return 10\n    end\n    \n\
    \    if value == \"11\"\n        return 11\n    end\n    \n    if value == \"\
    12\"\n        return 12\n    end\n    \n    if value == \"13\"\n        return\
    \ 13\n    end\n    \n    if value == \"14\"\n        return 14\n    end\n    \n\
    \    if value == \"15\"\n        return 15\n    end\n    \n    if value == \"\
    16\"\n        return 16\n    end\n    \n    if value == \"17\"\n        return\
    \ 17\n    end\n    \n    if value == \"18\"\n        return 18\n    end\n    \n\
    \    if value == \"19\"\n        return 19\n    end\n    \n    if value == \"\
    20\"\n        return 20\n    end\n    \n    if value == \"21\"\n        return\
    \ 21\n    end\n    \n    if value == \"22\"\n        return 22\n    end\n    \n\
    \    if value == \"23\"\n        return 23\n    end\n    \n    if value == \"\
    24\"\n        return 24\n    end\n    \n    if value == \"25\"\n        return\
    \ 25\n    end\n    \n    if value == \"26\"\n        return 26\n    end\n    \n\
    \    if value == \"27\"\n        return 27\n    end\n    \n    if value == \"\
    28\"\n        return 28\n    end\n    \n    if value == \"29\"\n        return\
    \ 29\n    end\n    \n    if value == \"30\"\n        return 30\n    end\n    \n\
    \    if value == \"31\"\n        return 31\n    end\n    \n    if value == \"\
    32\"\n        return 32\n    end\n    \n    if value == \"33\"\n        return\
    \ 33\n    end\n    \n    if value == \"34\"\n        return 34\n    end\n    \n\
    \    if value == \"35\"\n        return 35\n    end\n    \n    if value == \"\
    36\"\n        return 36\n    end\n    \n    if value == \"37\"\n        return\
    \ 37\n    end\n    \n    if value == \"38\"\n        return 38\n    end\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplpi4doah.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplpi4doah.jl:1\n\
    in expression starting at /tmp/tmplpi4doah.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    closest_integer = Int64(math.floor(value))\n    if closest_integer\
    \ == value:\n        closest_integer = Int64(math.ceil(value))\n        if closest_integer\
    \ == value:\n            closest_integer = Int64(math.round(value))\n        \
    \    if closest_integer == value:\n                closest_integer = Int64(math.trunc(value))\n\
    \                if closest_integer == value:\n                    closest_integer\
    \ = Int64(math.floor(value))\n                    if closest_integer == value:\n\
    \                        closest_integer = Int64(math.ceil(value))\n         \
    \               if closest_integer == value:\n                            closest_integer\
    \ = Int64(math.round(value))\n                            if closest_integer ==\
    \ value:\n                                closest_integer = Int64(math.trunc(value))\n\
    \                                if closest_integer == value:\n              \
    \                      closest_integer = Int64(math.floor(value))\n          \
    \                          if closest_integer == value:\n                    \
    \                    closest_integer = Int64(math.ceil(value))\n             \
    \                           if closest_integer == value:\n                   \
    \                         closest_integer = Int64(math.round(value))\n       \
    \                                     if closest_integer == value:\n         \
    \                                       closest_integer = Int64(math.trunc(value))\n\
    \                                                if closest_integer == value:\n\
    \                                                    closest_integer = Int64(math.floor(value))\n\
    \                                                    if closest_integer == value:\n\
    \                                                        closest_integer = Int64(math.ceil(value))\n\
    \                                                        if closest_integer ==\
    \ value:\n                                                            closest_integer\
    \ = Int64(math.round(value))\n                                               \
    \             if closest_integer == value:\n                                 \
    \                               closest_integer = Int64(math.trunc(value))\n \
    \                                                               if closest_integer\
    \ == value:\n                                                                \
    \    closest_integer = Int64(math.floor(value))\n                            \
    \                                        if closest_integer == value:\n      \
    \                                                                  closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \        if closest_integer == value:\n                                      \
    \                      closest_integer = Int64(math.round(value))\n          \
    \                                                  if closest_integer == value:\n\
    \                                                                closest_integer\
    \ = Int64(math.trunc(value))\n                                               \
    \                 if closest_integer == value:\n                             \
    \                                       closest_integer = Int64(math.floor(value))\n\
    \                                                                    if closest_integer\
    \ == value:\n                                                                \
    \        closest_integer = Int64(math.ceil(value))\n                         \
    \                               if closest_integer == value:\n               \
    \                                             closest_integer = Int64(math.round(value))\n\
    \                                                            if closest_integer\
    \ == value:\n                                                                closest_integer\
    \ = Int64(math.trunc(value))\n                                               \
    \                 if closest_integer == value:\n                             \
    \                                       closest_integer = Int64(math.floor(value))\n\
    \                                                                    if closest_integer\
    \ == value:\n                                                                \
    \        closest_integer = Int64(math.ceil(value))\n                         \
    \                               if closest_integer == value:\n               \
    \                                             closest_integer = Int64(math.round(value))\n\
    \                                                            if closest_integer\
    \ == value:\n                                                                closest_integer\
    \ = Int64(math.trunc(value))\n                                               \
    \                 if closest_integer == value:\n                             \
    \                                       closest_integer = \nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3wkj6sqr.jl:22\nin expression starting at\
    \ /tmp/tmp3wkj6sqr.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ elseif value == \"-\"\n        error(\"value cannot be -\")\n    elseif value\
    \ == \"+\"\n        error(\"value cannot be +\")\n    elseif value == \"0\"\n\
    \        error(\"value cannot be 0\")\n    elseif value == \"1\"\n        error(\"\
    value cannot be 1\")\n    elseif value == \"2\"\n        error(\"value cannot\
    \ be 2\")\n    elseif value == \"3\"\n        error(\"value cannot be 3\")\n \
    \   elseif value == \"4\"\n        error(\"value cannot be 4\")\n    elseif value\
    \ == \"5\"\n        error(\"value cannot be 5\")\n    elseif value == \"6\"\n\
    \        error(\"value cannot be 6\")\n    elseif value == \"7\"\n        error(\"\
    value cannot be 7\")\n    elseif value == \"8\"\n        error(\"value cannot\
    \ be 8\")\n    elseif value == \"9\"\n        error(\"value cannot be 9\")\n \
    \   else\n        error(\"value cannot be converted to Int64\")\n    end\n   \
    \ \n    local digits = split(value, \".\")\n    local digits_int = map(tostring,\
    \ digits)\n    local digits_int_len = length(digits_int)\n    \n    if digits_int_len\
    \ == 1\n        return tointeger(digits_int[1])\n    elseif digits_int_len ==\
    \ 2\n        return tointeger(digits_int[1]) + tointeger(digits_int[2])\n    elseif\
    \ digits_int_len == 3\n        return tointeger(digits_int[1]) + tointeger(digits_int[2])\
    \ + tointeger(digits_int[3])\n    elseif digits_int_len == 4\n        return tointeger(digits_int[1])\
    \ + tointeger(digits_int[2]) + tointeger(digits_int[3]) + tointeger(digits_int[4])\n\
    \    elseif digits_int_len == 5\n        return tointeger(digits_int[1]) + tointeger(digits_int[2])\
    \ + tointeger(digits_int[3]) + tointeger(digits_int[4]) + tointeger(digits_int[5])\n\
    \    elseif digits_int_len == 6\n        return tointeger(digits_int[1]) + tointeger(digits_int[2])\
    \ + tointeger(digits_int[3]) + tointeger(digits_int[4]) + tointeger(digits_int[5])\
    \ + tointeger(digits_int[6])\n    elseif digits_int_len == 7\n        return tointeger(digits_int[1])\
    \ + tointeger(digits_int[2]) + tointeger(digits_int[3]) + tointeger(digits_int[4])\
    \ + tointeger(digits_int[5]) + tointeger(digits_int[6]) + tointeger(digits_int[7])\n\
    \    elseif digits_int_len == 8\n\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqy2qs15s.jl:1\nin expression starting at /tmp/tmpqy2qs15s.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\
    \ \n        closest_integer = Int64(math.floor(value))\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integer(value::Float64)\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6bmpm56l.jl:25\nin expression starting at\
    \ /tmp/tmp6bmpm56l.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" || value == \"inf\" || value == \"nan\" \n    then\
    \ return value \n    else \n        val :: Float64 = Float64(value)\n        if\
    \ val == 0.0 \n        then return value \n        else \n            val :: Float64\
    \ = val - Float64(math.floor(val))\n            if val == 0.0 \n            then\
    \ return value \n            else \n                val :: Float64 = val + Float64(math.ceil(val))\n\
    \                return val\n    end\nend\n\"\"\"\n    Create a function that\
    \ takes a value (string) representing a number\n    and returns the closest float\
    \ to it. If the number is equidistant\n    from two floats, round it away from\
    \ zero.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2oz13oip.jl:20\nin expression starting at /tmp/tmp2oz13oip.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" \n        then return -Inf \n    else if value ==\
    \ \"inf\" \n        then return Inf \n    else if value == \"nan\" \n        then\
    \ return NaN \n    else if value == \"-nan\" \n        then return NaN \n    else\
    \ if value == \"0\" \n        then return 0 \n    else if value == \"1\" \n  \
    \      then return 1 \n    else if value == \"2\" \n        then return 2 \n \
    \   else if value == \"3\" \n        then return 3 \n    else if value == \"4\"\
    \ \n        then return 4 \n    else if value == \"5\" \n        then return 5\
    \ \n    else if value == \"6\" \n        then return 6 \n    else if value ==\
    \ \"7\" \n        then return 7 \n    else if value == \"8\" \n        then return\
    \ 8 \n    else if value == \"9\" \n        then return 9 \n    else if value ==\
    \ \"10\" \n        then return 10 \n    else if value == \"11\" \n        then\
    \ return 11 \n    else if value == \"12\" \n        then return 12 \n    else\
    \ if value == \"13\" \n        then return 13 \n    else if value == \"14\" \n\
    \        then return 14 \n    else if value == \"15\" \n        then return 15\
    \ \n    else if value == \"16\" \n        then return 16 \n    else if value ==\
    \ \"17\" \n        then return 17 \n    else if value == \"18\" \n        then\
    \ return 18 \n    else if value == \"19\" \n        then return 19 \n    else\
    \ if value == \"20\" \n        then return 20 \n    else if value == \"21\" \n\
    \        then return 21 \n    else if value == \"22\" \n        then return 22\
    \ \n    else if value == \"23\" \n        then return 23 \n    else if value ==\
    \ \"24\" \n        then return 24 \n    else if value == \"25\" \n        then\
    \ return 25 \n    else if value == \"26\" \n        then return 26 \n    else\
    \ if value == \"27\" \n        then return 27 \n    else if value == \"28\" \n\
    \        then return 28 \n    else if value == \"29\" \n        then return 29\
    \ \n    else if value == \"30\" \n        then return 30 \n    else if value ==\
    \ \"31\" \n        then return 31 \n    else if value == \"32\" \n        then\
    \ return 32 \n    else if value == \"33\" \n        then return 33 \n    else\
    \ if value == \"34\" \n        then return 34 \n    else \nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpqy5dbxhy.jl:20\nin expression starting at /tmp/tmpqy5dbxhy.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5107sro0.jl:21\nin expression starting at\
    \ /tmp/tmp5107sro0.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \ \n        then return 0\n    \n    digits = split(value, \".\")\n    \n    if\
    \ digits.length == 2\n        then return Int(digits[1]) \n    \n    digits_int\
    \ = digits[1]\n    \n    if digits_int == \"0\"\n        then return Int(digits[0])\n\
    \    \n    digits_int = digits_int.toInt()\n    \n    if digits_int == 0\n   \
    \     then return Int(digits[0])\n    \n    digits_int = digits_int - 1\n    \n\
    \    if digits_int == 0\n        then return Int(digits[0])\n    \n    digits_int\
    \ = digits_int + 1\n    \n    if digits_int == 0\n        then return Int(digits[0])\n\
    \    \n    digits_int = digits_int - 1\n    \n    if digits_int == 0\n       \
    \ then return Int(digits[0])\n    \n    digits_int = digits_int + 1\n    \n  \
    \  if digits_int == 0\n        then return Int(digits[0])\n    \n    digits_int\
    \ = digits_int - 1\n    \n    if digits_int == 0\n        then return Int(digits[0])\n\
    \    \n    digits_int = digits_int + 1\n    \n    if digits_int == 0\n       \
    \ then return Int(digits[0])\n    \n    digits_int = digits_int - 1\n    \n  \
    \  if digits_int == 0\n        then return Int(digits[0])\n    \n    digits_int\
    \ = digits_int + 1\n    \n    if digits_int == 0\n        then return Int(digits[0])\n\
    \    \n    digits_int = digits_int - 1\n    \n    if digits_int == 0\n       \
    \ then return Int(digits[0])\n    \n    digits_int = digits_int + 1\n    \n  \
    \  if digits_int == 0\n        then return Int(digits[0])\n    \n    digits_int\
    \ = digits_int - 1\n    \n    if digits_int == 0\n        then return Int(digits[0])\n\
    \    \n    digits_int = digits_int + 1\n    \n    if digits_int == 0\n       \
    \ then return Int(digits[0])\n    \n    digits_int = digits_int - 1\n    \n  \
    \  if digits_int == 0\n        then return Int(digits[0])\n    \n    digits_int\
    \ = digits_int + 1\n    \n    if digits_int == 0\n        then return Int(digits[0])\n\
    \    \n    digits_int = digits_int - 1\n    \n    if digits_int == 0\n       \
    \ then return Int(digits[0])\n    \n    digit\nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp9a11z2qc.jl:22\nin expression starting at /tmp/tmp9a11z2qc.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(Int64(value)))\n    if closest_integer\
    \ == Int64(value)\n        closest_integer = Int64(0)\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl9vahs45.jl:25\nin expression starting at\
    \ /tmp/tmpl9vahs45.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    closest_integer = if value == \"0\" then\
    \ 0 else if value == \"1\" then 1 else if value == \"2\" then 2 else if value\
    \ == \"3\" then 3 else if value == \"4\" then 4 else if value == \"5\" then 5\
    \ else if value == \"6\" then 6 else if value == \"7\" then 7 else if value ==\
    \ \"8\" then 8 else if value == \"9\" then 9 else if value == \"10\" then 10 else\
    \ if value == \"11\" then 11 else if value == \"12\" then 12 else if value ==\
    \ \"13\" then 13 else if value == \"14\" then 14 else if value == \"15\" then\
    \ 15 else if value == \"16\" then 16 else if value == \"17\" then 17 else if value\
    \ == \"18\" then 18 else if value == \"19\" then 19 else if value == \"20\" then\
    \ 20 else if value == \"21\" then 21 else if value == \"22\" then 22 else if value\
    \ == \"23\" then 23 else if value == \"24\" then 24 else if value == \"25\" then\
    \ 25 else if value == \"26\" then 26 else if value == \"27\" then 27 else if value\
    \ == \"28\" then 28 else if value == \"29\" then 29 else if value == \"30\" then\
    \ 30 else if value == \"31\" then 31 else if value == \"32\" then 32 else if value\
    \ == \"33\" then 33 else if value == \"34\" then 34 else if value == \"35\" then\
    \ 35 else if value == \"36\" then 36 else if value == \"37\" then 37 else if value\
    \ == \"38\" then 38 else if value == \"39\" then 39 else if value == \"40\" then\
    \ 40 else if value == \"41\" then 41 else if value == \"42\" then 42 else if value\
    \ == \"43\" then 43 else if value == \"44\" then 44 else if value == \"45\" then\
    \ 45 else if value == \"46\" then 46 else if value == \"47\" then 47 else if value\
    \ == \"48\" then 48 else if value == \"49\" then 49 else if value == \"50\" then\
    \ 50 else if value == \"51\" then 51 else if value == \"52\" then 52 else if value\
    \ == \"53\" then 53 else if value == \"54\" then 54 else if value == \"55\" then\
    \ 55 else if value == \"56\" then 56 else if value == \"57\" then 57 else if value\
    \ == \"58\" then 58 else if value == \"59\" then 59 else if value == \"60\" then\
    \ 60 else if value == \"61\" then 61 else if value == \"62\" then 62 else if \n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"0\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgvxjd5n2.jl:20\nin expression starting at /tmp/tmpgvxjd5n2.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \ \n        then return 0\n    \n    if value == \"1\" || value == \"-1\" \n \
    \       then return 1\n    \n    if value == \"2\" || value == \"-2\" \n     \
    \   then return 2\n    \n    if value == \"3\" || value == \"-3\" \n        then\
    \ return 3\n    \n    if value == \"4\" || value == \"-4\" \n        then return\
    \ 4\n    \n    if value == \"5\" || value == \"-5\" \n        then return 5\n\
    \    \n    if value == \"6\" || value == \"-6\" \n        then return 6\n    \n\
    \    if value == \"7\" || value == \"-7\" \n        then return 7\n    \n    if\
    \ value == \"8\" || value == \"-8\" \n        then return 8\n    \n    if value\
    \ == \"9\" || value == \"-9\" \n        then return 9\n    \n    if value == \"\
    10\" || value == \"-10\" \n        then return 10\n    \n    if value == \"11\"\
    \ || value == \"-11\" \n        then return 11\n    \n    if value == \"12\" ||\
    \ value == \"-12\" \n        then return 12\n    \n    if value == \"13\" || value\
    \ == \"-13\" \n        then return 13\n    \n    if value == \"14\" || value ==\
    \ \"-14\" \n        then return 14\n    \n    if value == \"15\" || value == \"\
    -15\" \n        then return 15\n    \n    if value == \"16\" || value == \"-16\"\
    \ \n        then return 16\n    \n    if value == \"17\" || value == \"-17\" \n\
    \        then return 17\n    \n    if value == \"18\" || value == \"-18\" \n \
    \       then return 18\n    \n    if value == \"19\" || value == \"-19\" \n  \
    \      then return 19\n    \n    if value == \"20\" || value == \"-20\" \n   \
    \     then return 20\n    \n    if value == \"21\" || value == \"-21\" \n    \
    \    then return 21\n    \n    if value == \"22\" || value == \"-22\" \n     \
    \   then return 22\n    \n    if value == \"23\" || value == \"-23\" \n      \
    \  then return 23\n    \n    if value == \"24\" || value == \"-24\" \n       \
    \ then return 24\n    \n    if value == \"25\" || value == \"-25\" \n        then\
    \ return 25\n    \n    if value == \"26\" || value == \"-26\" \n        then return\
    \ 26\n    \n    if value == \"27\" || value == \"-27\" \n        then return 27\n\
    \    \n    if value == \"28\" || value == \"-28\" \n        then return 28\n \
    \   \n    if value == \"\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpnfx40o13.jl:22\nin expression starting at /tmp/tmpnfx40o13.jl:22\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(Int64(value)))\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmphndgiyio.jl:27\n  Test threw
    exception\n  Expression: candidate("10") == 10\n  UndefVarError: math not defined\n  Stacktrace:\n   [1]
    closest_integer(value::String)\n     @ Main /tmp/tmphndgiyio.jl:19\n   [2] macro
    expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmphndgiyio.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmphndgiyio.jl:26\ntest set: Error
    During Test at /tmp/tmphndgiyio.jl:28\n  Test threw exception\n  Expression: candidate("14.5")
    == 15\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmphndgiyio.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmphndgiyio.jl:28 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmphndgiyio.jl:26\ntest set: Error
    During Test at /tmp/tmphndgiyio.jl:29\n  Test threw exception\n  Expression: candidate("-15.5")
    == -16\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmphndgiyio.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmphndgiyio.jl:29 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmphndgiyio.jl:26\ntest set: Error
    During Test at /tmp/tmphndgiyio.jl:30\n  Test threw exception\n  Expression: candidate("15.3")
    == 15\n  UndefVarError: math not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmphndgiyio.jl:19\n   [2] macro expansio'
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\
    \ \n        closest_integer = Int64(math.floor(value))\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integer(value::Float64)\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6bmpm56l.jl:25\nin expression starting at\
    \ /tmp/tmp6bmpm56l.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    elseif\
    \ value == \"-\"\n        error(\"value cannot be negative\")\n    elseif value\
    \ == \"+\"\n        error(\"value cannot be positive\")\n    elseif value == \"\
    0\"\n        error(\"value cannot be 0\")\n    elseif value == \"1\"\n       \
    \ error(\"value cannot be 1\")\n    elseif value == \"2\"\n        error(\"value\
    \ cannot be 2\")\n    elseif value == \"3\"\n        error(\"value cannot be 3\"\
    )\n    elseif value == \"4\"\n        error(\"value cannot be 4\")\n    elseif\
    \ value == \"5\"\n        error(\"value cannot be 5\")\n    elseif value == \"\
    6\"\n        error(\"value cannot be 6\")\n    elseif value == \"7\"\n       \
    \ error(\"value cannot be 7\")\n    elseif value == \"8\"\n        error(\"value\
    \ cannot be 8\")\n    elseif value == \"9\"\n        error(\"value cannot be 9\"\
    )\n    elseif value == \"10\"\n        error(\"value cannot be 10\")\n    elseif\
    \ value == \"11\"\n        error(\"value cannot be 11\")\n    elseif value ==\
    \ \"12\"\n        error(\"value cannot be 12\")\n    elseif value == \"13\"\n\
    \        error(\"value cannot be 13\")\n    elseif value == \"14\"\n        error(\"\
    value cannot be 14\")\n    elseif value == \"15\"\n        error(\"value cannot\
    \ be 15\")\n    elseif value == \"16\"\n        error(\"value cannot be 16\")\n\
    \    elseif value == \"17\"\n        error(\"value cannot be 17\")\n    elseif\
    \ value == \"18\"\n        error(\"value cannot be 18\")\n    elseif value ==\
    \ \"19\"\n        error(\"value cannot be 19\")\n    elseif value == \"20\"\n\
    \        error(\"value cannot be 20\")\n    elseif value == \"21\"\n        error(\"\
    value cannot be 21\")\n    elseif value == \"22\"\n        error(\"value cannot\
    \ be 22\")\n    elseif value == \"23\"\n        error(\"value cannot be 23\")\n\
    \    elseif value == \"24\"\n        error(\"value cannot be 24\")\n    elseif\
    \ value == \"25\"\n        error(\"value cannot be 25\")\n    elseif value ==\
    \ \"26\"\n        error(\"value cannot be 26\")\n    elseif value == \"27\"\n\
    \        error(\"value cannot be 27\")\n    elseif value == \"28\"\n        error(\"\
    value cannot be 28\")\n    elseif value == \"29\"\n        error(\"value cannot\
    \ be 29\")\n    elseif value == \"30\"\n        error(\"value cannot be 30\")\n\
    \    elseif value == \"31\"\n        error(\"value cannot be 31\")\n    elseif\
    \ value == \"32\"\n        error(\"value cannot be 32\")\n    elseif value ==\
    \ \"33\"\n        error(\"value cannot be 33\")\n    elseif value == \"34\"\n\
    \        error(\"value cannot be 34\")\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcus4o94p.jl:1\nin expression starting at /tmp/tmpcus4o94p.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    if value == \"\"\n        return\
    \ int64(0)\n    \n    digits = split(value, \".\")\n    \n    if digits.length\
    \ == 2\n        digits = digits[1..]\n    \n    digits = digits[0..]\n    \n \
    \   digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits\
    \ = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n\
    \    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n  \
    \  digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits\
    \ = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n\
    \    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n  \
    \  digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits\
    \ = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n\
    \    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n  \
    \  digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits\
    \ = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n\
    \    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n  \
    \  digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits\
    \ = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n\
    \    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n  \
    \  digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits\
    \ = digits[0..-2]\n    \n    digits = digits[0..-2]\n    \n    digits = digits[0..-2]\n\
    \    \n    digits = digits[0..-2]\n    \n    digits = digits[\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"]\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp58x799zy.jl:27\nin expression starting at /tmp/tmp58x799zy.jl:27\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    if value == \"0\" \n        closest_integer\
    \ = Int(0)\n    elseif value == \"1\" \n        closest_integer = Int(1)\n   \
    \ elseif value == \"2\" \n        closest_integer = Int(2)\n    elseif value ==\
    \ \"3\" \n        closest_integer = Int(3)\n    elseif value == \"4\" \n     \
    \   closest_integer = Int(4)\n    elseif value == \"5\" \n        closest_integer\
    \ = Int(5)\n    elseif value == \"6\" \n        closest_integer = Int(6)\n   \
    \ elseif value == \"7\" \n        closest_integer = Int(7)\n    elseif value ==\
    \ \"8\" \n        closest_integer = Int(8)\n    elseif value == \"9\" \n     \
    \   closest_integer = Int(9)\n    elseif value == \"10\" \n        closest_integer\
    \ = Int(10)\n    elseif value == \"11\" \n        closest_integer = Int(11)\n\
    \    elseif value == \"12\" \n        closest_integer = Int(12)\n    elseif value\
    \ == \"13\" \n        closest_integer = Int(13)\n    elseif value == \"14\" \n\
    \        closest_integer = Int(14)\n    elseif value == \"15\" \n        closest_integer\
    \ = Int(15)\n    elseif value == \"16\" \n        closest_integer = Int(16)\n\
    \    elseif value == \"17\" \n        closest_integer = Int(17)\n    elseif value\
    \ == \"18\" \n        closest_integer = Int(18)\n    elseif value == \"19\" \n\
    \        closest_integer = Int(19)\n    elseif value == \"20\" \n        closest_integer\
    \ = Int(20)\n    elseif value == \"21\" \n        closest_integer = Int(21)\n\
    \    elseif value == \"22\" \n        closest_integer = Int(22)\n    elseif value\
    \ == \"23\" \n        closest_integer = Int(23)\n    elseif value == \"24\" \n\
    \        closest_integer = Int(24)\n    elseif value == \"25\" \n        closest_integer\
    \ = Int(25)\n    elseif value == \"26\" \n        closest_integer = Int(26)\n\
    \    elseif value == \"27\" \n        closest_integer = Int(27)\n    elseif value\
    \ == \"28\" \n        closest_integer = Int(28)\n    elseif value == \"29\" \n\
    \        closest_integer = Int(29)\n    elseif value == \"30\" \n        closest_integer\
    \ = Int(30)\n    elseif value == \"31\" \n        closest_integer = Int(31)\n\
    \    elseif value == \"32\" \n        closest_integer = Int(32)\n    elseif value\
    \ == \"33\" \n        closest_integer = Int(33)\n    elseif value == \"34\" \n\
    \        closest_integer = Int(34)\n    elseif value == \"35\" \n        closest_integ\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6dmgxg9o.jl:1\nin expression starting at /tmp/tmp6dmgxg9o.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    if value == \"-\"\n        return -closest_integer\n\
    \    \n    if value == \"+\"\n        return closest_integer\n    \n    if value\
    \ == \"0\"\n        return 0\n    \n    if value == \"1\"\n        return 1\n\
    \    \n    if value == \"2\"\n        return 2\n    \n    if value == \"3\"\n\
    \        return 3\n    \n    if value == \"4\"\n        return 4\n    \n    if\
    \ value == \"5\"\n        return 5\n    \n    if value == \"6\"\n        return\
    \ 6\n    \n    if value == \"7\"\n        return 7\n    \n    if value == \"8\"\
    \n        return 8\n    \n    if value == \"9\"\n        return 9\n    \n    if\
    \ value == \"10\"\n        return 10\n    \n    if value == \"11\"\n        return\
    \ 11\n    \n    if value == \"12\"\n        return 12\n    \n    if value == \"\
    13\"\n        return 13\n    \n    if value == \"14\"\n        return 14\n   \
    \ \n    if value == \"15\"\n        return 15\n    \n    if value == \"16\"\n\
    \        return 16\n    \n    if value == \"17\"\n        return 17\n    \n  \
    \  if value == \"18\"\n        return 18\n    \n    if value == \"19\"\n     \
    \   return 19\n    \n    if value == \"20\"\n        return 20\n    \n    if value\
    \ == \"21\"\n        return 21\n    \n    if value == \"22\"\n        return 22\n\
    \    \n    if value == \"23\"\n        return 23\n    \n    if value == \"24\"\
    \n        return 24\n    \n    if value == \"25\"\n        return 25\n    \n \
    \   if value == \"26\"\n        return 26\n    \n    if value == \"27\"\n    \
    \    return 27\n    \n    if value == \"28\"\n        return 28\n    \n    if\
    \ value == \"29\"\n        return 29\n    \n    if value == \"30\"\n        return\
    \ 30\n    \n    if value == \"31\"\n        return 31\n    \n    if value == \"\
    32\"\n        return 32\n    \n    if value == \"33\"\n        return 33\n   \
    \ \n    if value == \"34\"\n        return 34\n    \n    if value == \"35\"\n\
    \        return 35\n    \n    if value == \"36\"\n        return 36\n    \n  \
    \  if value == \"37\"\n        return 37\n    \n    if value == \"38\"\n     \
    \   return 38\n    \n    if value == \"39\"\n        return 39\n    \n    if value\
    \ == \"40\"\n        return 40\n    \n    if value == \"41\"\n        return 41\n\
    \    \n    if value == \"42\"\n        return 42\n    \n    if value == \"43\"\
    \n\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnp9s9g47.jl:1\nin expression starting at /tmp/tmpnp9s9g47.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \ \n        then return 0\n    \n    digits = split(value, \".\")\n    \n    if\
    \ digits.length < 2 \n        then return Int(value)\n    \n    digits_int = digits[1]\n\
    \    \n    if digits_int == \"0\" \n        then return Int(digits[0])\n    \n\
    \    digits_int = digits_int[digits_int.length-1]\n    \n    if digits_int ==\
    \ \"0\" \n        then return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\" \n        then return Int(digits[0])\n    \n\
    \    digits_int = digits_int[digits_int.length-1]\n    \n    if digits_int ==\
    \ \"0\" \n        then return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\" \n        then return Int(digits[0])\n    \n\
    \    digits_int = digits_int[digits_int.length-1]\n    \n    if digits_int ==\
    \ \"0\" \n        then return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\" \n        then return Int(digits[0])\n    \n\
    \    digits_int = digits_int[digits_int.length-1]\n    \n    if digits_int ==\
    \ \"0\" \n        then return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\" \n        then return Int(digits[0])\n    \n\
    \    digits_int = digits_int[digits_int.length-1]\n    \n    if digits_int ==\
    \ \"0\" \n        then return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\" \n        then return Int(digits[0])\n    \n\
    \    digits_int = digits_int[digits_int.length-1]\n    \n    if digits_int ==\
    \ \"0\" \n        then return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\" \n        then return Int(digits[0])\n    \n\
    \    digits_int = digits_int[digits_int.length-1]\n    \n    if digits_int ==\
    \ \"0\" \n        then return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp7m2lgmy2.jl:22\nin expression starting at /tmp/tmp7m2lgmy2.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(Int64(value)))\n    if closest_integer\
    \ == Int64(value)\n        closest_integer = Int64(0)\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integer_with_ifelse(value::String)::Int64\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp25_y15zn.jl:25\nin expression starting at\
    \ /tmp/tmp25_y15zn.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" \n    then return -Inf \n    else if value == \"\
    inf\" \n    then return Inf \n    else if value == \"nan\" \n    then return NaN\
    \ \n    else \n        local num = tonumber(value)\n        if num == 0 \n   \
    \     then return 0 \n        else if num < 0 \n        then return -closest_integer(-num)\
    \ \n        else \n            local diff = abs(num - floor(num))\n          \
    \  if diff < 0.5 \n            then return floor(num) \n            else \n  \
    \              return ceil(num) \n        end\n    end\nend\n</cell>\n<text>\n\
    The function above is called closest_integer. Let's see how it works.\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpt2bmx9mj.jl:20\nin expression starting at /tmp/tmpt2bmx9mj.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \ \n        then return 0\n    \n    digits = split(value, \".\")\n    \n    if\
    \ length(digits) == 2\n        then digits[1] = digits[1] * -1\n    \n    digits[1]\
    \ = digits[1] * -1\n    \n    if digits[1] < 0\n        then digits[1] = digits[1]\
    \ * -1\n    \n    if digits[1] < 0\n        then return 0\n    \n    if digits[1]\
    \ > 0\n        then return digits[1]\n    \n    if digits[1] > 0\n        then\
    \ return digits[1]\n    \n    if digits[1] > 0\n        then return digits[1]\n\
    \    \n    if digits[1] > 0\n        then return digits[1]\n    \n    if digits[1]\
    \ > 0\n        then return digits[1]\n    \n    if digits[1] > 0\n        then\
    \ return digits[1]\n    \n    if digits[1] > 0\n        then return digits[1]\n\
    \    \n    if digits[1] > 0\n        then return digits[1]\n    \n    if digits[1]\
    \ > 0\n        then return digits[1]\n    \n    if digits[1] > 0\n        then\
    \ return digits[1]\n    \n    if digits[1] > 0\n        then return digits[1]\n\
    \    \n    if digits[1] > 0\n        then return digits[1]\n    \n    if digits[1]\
    \ > 0\n        then return digits[1]\n    \n    if digits[1] > 0\n        then\
    \ return digits[1]\n    \n    if digits[1] > 0\n        then return digits[1]\n\
    \    \n    if digits[1] > 0\n        then return digits[1]\n    \n    if digits[1]\
    \ > 0\n        then return digits[1]\n    \n    if digits[1] > 0\n        then\
    \ return digits[1]\n    \n    if digits[1] > 0\n        then return digits[1]\n\
    \    \n    if digits[1] > 0\n        then return digits[1]\n    \n    if digits[1]\
    \ > 0\n        then return digits[1]\n    \n    if digits[1] > 0\n        then\
    \ return digits[1]\n    \n    if digits[1] > 0\n        then return digits[1]\n\
    \    \n    if digits[1] > 0\n        then return digits[1]\n    \n    if digits[1]\
    \ > 0\n        then return digits[1]\n    \n    if digits[1] > 0\n        then\
    \ return digits[1]\n    \n    if digits[1] > 0\n        then return digits[1]\n\
    \    \n    if digits[1] > 0\n        then return digits[1]\n    \n    if digits[1]\
    \ > 0\n        then return digits[1]\n    \n    if digits[1] > 0\n        then\
    \ return digit\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsga39ikl.jl:22\nin expression starting at /tmp/tmpsga39ikl.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    end\n\
    \    \n    local value::Int64 = tonumber(value)\n    if value == 0\n        return\
    \ 0\n    end\n    \n    local closest::Int64 = math.abs(value)\n    local closest::Int64\
    \ = math.abs(closest)\n    \n    if closest == 0\n        return 0\n    end\n\
    \    \n    if closest == 1\n        return value\n    end\n    \n    if closest\
    \ % 2 == 0\n        return math.floor(closest)\n    end\n    \n    return math.ceil(closest)\n\
    end\n</cell>\n<text>\nThe function closest_integer takes one argument, value::String.\
    \ It checks if value is empty and throws an error if it is not. It then converts\
    \ value to an integer using tonumber which checks if the string can be converted\
    \ to a number. If it can, it converts it to a number. If it cannot, it throws\
    \ an error.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: local variable name \"value\" conflicts with\
    \ an argument\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp80es5o6e.jl:1\n\
    in expression starting at /tmp/tmp80es5o6e.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        val =  parse_value(value)\n        if val == \"\"\n            error(\"\
    value cannot be parsed\")\n        else\n            closest_integer(val)\n  \
    \  end\nend\n\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzt9l2j87.jl:1\nin expression starting at /tmp/tmpzt9l2j87.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    elseif\
    \ value == \"-\"\n        error(\"value cannot be -, use 0 instead\")\n    elseif\
    \ value == \"0\"\n        error(\"value cannot be 0, use 1 instead\")\n    elseif\
    \ value == \"1\"\n        1\n    elseif value == \"2\"\n        2\n    elseif\
    \ value == \"3\"\n        3\n    elseif value == \"4\"\n        4\n    elseif\
    \ value == \"5\"\n        5\n    elseif value == \"6\"\n        6\n    elseif\
    \ value == \"7\"\n        7\n    elseif value == \"8\"\n        8\n    elseif\
    \ value == \"9\"\n        9\n    else\n        error(\"value must be an integer,\
    \ use 0 instead\")\n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"\n\
    \    closest_integer(value::Int64)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw7xsjb49.jl:47\nin expression starting at\
    \ /tmp/tmpw7xsjb49.jl:47\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"0\" \n        then return 0\n    else if value ==\
    \ \"1\" \n        then return 1\n    else if value == \"2\" \n        then return\
    \ 2\n    else if value == \"3\" \n        then return 3\n    else if value ==\
    \ \"4\" \n        then return 4\n    else if value == \"5\" \n        then return\
    \ 5\n    else if value == \"6\" \n        then return 6\n    else if value ==\
    \ \"7\" \n        then return 7\n    else if value == \"8\" \n        then return\
    \ 8\n    else if value == \"9\" \n        then return 9\n    else if value ==\
    \ \"10\" \n        then return 10\n    else if value == \"11\" \n        then\
    \ return 11\n    else if value == \"12\" \n        then return 12\n    else if\
    \ value == \"13\" \n        then return 13\n    else if value == \"14\" \n   \
    \     then return 14\n    else if value == \"15\" \n        then return 15\n \
    \   else if value == \"16\" \n        then return 16\n    else if value == \"\
    17\" \n        then return 17\n    else if value == \"18\" \n        then return\
    \ 18\n    else if value == \"19\" \n        then return 19\n    else if value\
    \ == \"20\" \n        then return 20\n    else if value == \"21\" \n        then\
    \ return 21\n    else if value == \"22\" \n        then return 22\n    else if\
    \ value == \"23\" \n        then return 23\n    else if value == \"24\" \n   \
    \     then return 24\n    else if value == \"25\" \n        then return 25\n \
    \   else if value == \"26\" \n        then return 26\n    else if value == \"\
    27\" \n        then return 27\n    else if value == \"28\" \n        then return\
    \ 28\n    else if value == \"29\" \n        then return 29\n    else if value\
    \ == \"30\" \n        then return 30\n    else if value == \"31\" \n        then\
    \ return 31\n    else if value == \"32\" \n        then return 32\n    else if\
    \ value == \"33\" \n        then return 33\n    else if value == \"34\" \n   \
    \     then return 34\n    else if value == \"35\" \n        then return 35\n \
    \   else if value == \"36\" \n        then return 36\n    else if value == \"\
    37\" \n        then return 37\n    else if value == \"38\" \n        then return\
    \ 38\n    else if value == \"39\" \n\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpswtiagql.jl:21\nin expression starting at /tmp/tmpswtiagql.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    if value == \"0\" || value == \"-0\" \n\
    \        then return closest_integer\n    else if value == \"1\" || value == \"\
    -1\" \n        then return Int(1)\n    else if value == \"2\" || value == \"-2\"\
    \ \n        then return Int(2)\n    else if value == \"3\" || value == \"-3\"\
    \ \n        then return Int(3)\n    else if value == \"4\" || value == \"-4\"\
    \ \n        then return Int(4)\n    else if value == \"5\" || value == \"-5\"\
    \ \n        then return Int(5)\n    else if value == \"6\" || value == \"-6\"\
    \ \n        then return Int(6)\n    else if value == \"7\" || value == \"-7\"\
    \ \n        then return Int(7)\n    else if value == \"8\" || value == \"-8\"\
    \ \n        then return Int(8)\n    else if value == \"9\" || value == \"-9\"\
    \ \n        then return Int(9)\n    else if value == \"10\" || value == \"-10\"\
    \ \n        then return Int(10)\n    else if value == \"11\" || value == \"-11\"\
    \ \n        then return Int(11)\n    else if value == \"12\" || value == \"-12\"\
    \ \n        then return Int(12)\n    else if value == \"13\" || value == \"-13\"\
    \ \n        then return Int(13)\n    else if value == \"14\" || value == \"-14\"\
    \ \n        then return Int(14)\n    else if value == \"15\" || value == \"-15\"\
    \ \n        then return Int(15)\n    else if value == \"16\" || value == \"-16\"\
    \ \n        then return Int(16)\n    else if value == \"17\" || value == \"-17\"\
    \ \n        then return Int(17)\n    else if value == \"18\" || value == \"-18\"\
    \ \n        then return Int(18)\n    else if value == \"19\" || value == \"-19\"\
    \ \n        then return Int(19)\n    else if value == \"20\" || value == \"-20\"\
    \ \n        then return Int(20)\n    else if value == \"21\" || value == \"-21\"\
    \ \n        then return Int(21)\n    else if value == \"22\" || value == \"-22\"\
    \ \n        then return Int(22)\n    else if value == \"23\" || value == \"-23\"\
    \ \n        then return Int(23)\n    else if value == \"24\" || value == \"-24\"\
    \ \n        then return Int(24)\n    else if value == \"25\" || value == \"-25\"\
    \ \n        then return Int(25)\n    else if value == \"26\" || value == \"-26\"\
    \ \n        then return Int(26)\n    else if value == \"27\" || value == \"-27\"\
    \ \n\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpkhk7spzt.jl:21\nin expression starting at /tmp/tmpkhk7spzt.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    end\n\
    \    \n    local num = tonumber(value)\n    if num == nil\n        error(\"value\
    \ must be a number\")\n    end\n    \n    if num == 0.0\n        error(\"value\
    \ cannot be 0\")\n    end\n    \n    local closest\n    local closestDistance\n\
    \    \n    if num < 0\n        closest = -num\n        closestDistance = abs(num)\n\
    \    else\n        closest = 0\n        closestDistance = abs(num)\n    end\n\
    \    \n    for i = 1, closestDistance\n        do\n            local newNum =\
    \ closest + i\n            local newDistance = abs(newNum)\n            if newDistance\
    \ < closestDistance\n                closest = newNum\n                closestDistance\
    \ = newDistance\n            end\n        end\n    end\n    \n    return closest\n\
    end\n</cell>\n<text>\nThe function closest_integer takes in a string and returns\
    \ the closest integer to the given number. If the number is equidistant from two\
    \ integers, round it away from zero.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdv_optaw.jl:44\nin expression starting at\
    \ /tmp/tmpdv_optaw.jl:44\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" \n        then return -Inf \n        else if value\
    \ == \"inf\" \n            then return Inf \n            else if value == \"nan\"\
    \ \n                then return NaN \n                else return closest_integer(value[end-1])\
    \ \n    else if value == \"0\" \n        then return 0 \n        else if value\
    \ == \"1\" \n            then return 1 \n            else if value == \"2\" \n\
    \                then return 2 \n                else if value == \"3\" \n   \
    \                 then return 3 \n                    else if value == \"4\" \n\
    \                        then return 4 \n                        else if value\
    \ == \"5\" \n                            then return 5 \n                    \
    \        else if value == \"6\" \n                                then return\
    \ 6 \n                                else if value == \"7\" \n              \
    \                      then return 7 \n                                    else\
    \ if value == \"8\" \n                                        then return 8 \n\
    \                                        else if value == \"9\" \n           \
    \                                 then return 9 \n                           \
    \                 else return closest_integer(value[end-1]) \n    else if value\
    \ == \"-1\" \n        then return -1 \n        else if value == \"-2\" \n    \
    \        then return -2 \n            else if value == \"-3\" \n             \
    \   then return -3 \n                else if value == \"-4\" \n              \
    \      then return -4 \n                    else if value == \"-5\" \n       \
    \                 then return -5 \n                        else if value == \"\
    -6\" \n                            then return -6 \n                         \
    \   else if value == \"-7\" \n                                then return -7 \n\
    \                                else if value == \"-8\" \n                  \
    \                  then return -8 \n                                    else if\
    \ value == \"-9\" \n                                        then return -9 \n\
    \                                        else return closest_integer(value[end-1])\
    \ \n    else if value == \"0\" \n        then return 0 \n        else if value\
    \ == \"1\" \n            then return 1 \n            else if value == \"2\" \n\
    \                then return 2 \n                else if value == \"3\" \n   \
    \                 then return 3 \n                    else if value == \"4\" \n\
    \                        then return 4 \n                        else if value\
    \ == \"5\" \n                            then return 5 \n                    \
    \        else if value == \"6\" \n                                then return\
    \ 6 \n                                else if value == \"7\" \n              \
    \                      then return 7 \n                                    else\
    \ if value == \"8\" \n                                        then return 8 \n\
    \                                        else if value == \"9\" \n           \
    \                                 then return 9 \n                           \
    \                 else return closest_integer(value[end-1]) \n    else if value\
    \ == \"-1\" \n        then return -1 \n        else if value == \"-2\" \n    \
    \        then return -2 \n            else if value == \"-3\" \n             \
    \   then return -3 \n                else if value == \"-4\" \n              \
    \      then return -4 \n                    else if \nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpmjbd8qvj.jl:20\nin expression starting at /tmp/tmpmjbd8qvj.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        local closest = 0\n        local closestDiff = math.abs(math.floor(value))\n\
    \        for n in string.gmatch(value, \"%d+\") do\n            local diff = math.abs(math.floor(n))\n\
    \            if diff < closestDiff then\n                closest = n\n       \
    \         closestDiff = diff\n            end\n        end\n        return closest\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nThe answer by\
    \ is very good, but I wanted to add an alternative that doesn't require any packages.\
    \ I wrote a function that does this in two lines of code. \n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpuqi233fl.jl:34\nin expression starting at\
    \ /tmp/tmpuqi233fl.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3o6cy5kj.jl:21\nin expression starting at\
    \ /tmp/tmp3o6cy5kj.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    if value == \"\"\n        closest_integer\
    \ = Int64(0)\n    elseif value == \"0\"\n        closest_integer = Int64(0)\n\
    \    elseif value == \"1\"\n        closest_integer = Int64(1)\n    elseif value\
    \ == \"-1\"\n        closest_integer = Int64(-1)\n    elseif value == \"-2\"\n\
    \        closest_integer = Int64(-2)\n    elseif value == \"-3\"\n        closest_integer\
    \ = Int64(-3)\n    elseif value == \"-4\"\n        closest_integer = Int64(-4)\n\
    \    elseif value == \"-5\"\n        closest_integer = Int64(-5)\n    elseif value\
    \ == \"-6\"\n        closest_integer = Int64(-6)\n    elseif value == \"-7\"\n\
    \        closest_integer = Int64(-7)\n    elseif value == \"-8\"\n        closest_integer\
    \ = Int64(-8)\n    elseif value == \"-9\"\n        closest_integer = Int64(-9)\n\
    \    elseif value == \"-10\"\n        closest_integer = Int64(-10)\n    elseif\
    \ value == \"-11\"\n        closest_integer = Int64(-11)\n    elseif value ==\
    \ \"-12\"\n        closest_integer = Int64(-12)\n    elseif value == \"-13\"\n\
    \        closest_integer = Int64(-13)\n    elseif value == \"-14\"\n        closest_integer\
    \ = Int64(-14)\n    elseif value == \"-15\"\n        closest_integer = Int64(-15)\n\
    \    elseif value == \"-16\"\n        closest_integer = Int64(-16)\n    elseif\
    \ value == \"-17\"\n        closest_integer = Int64(-17)\n    elseif value ==\
    \ \"-18\"\n        closest_integer = Int64(-18)\n    elseif value == \"-19\"\n\
    \        closest_integer = Int64(-19)\n    elseif value == \"-20\"\n        closest_integer\
    \ = Int64(-20)\n    elseif value == \"-21\"\n        closest_integer = Int64(-21)\n\
    \    elseif value == \"-22\"\n        closest_integer = Int64(-22)\n    elseif\
    \ value == \"-23\"\n        closest_integer = Int64(-23)\n    elseif value ==\
    \ \"-24\"\n        closest_integer = Int64(-24)\n    elseif value == \"-25\"\n\
    \        closest_integer = Int64(-25)\n    elseif value == \"-26\"\n        closest_integer\
    \ = Int64(-26)\n    elseif value == \"-27\"\n        closest_integer = Int64(-27)\n\
    \    elseif value == \"-28\"\n        closest_integer = Int64(-28)\n    elseif\
    \ value == \"\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: cannot juxtapose string literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx346egl2.jl:89\nin expression starting at\
    \ /tmp/tmpx346egl2.jl:89\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    </cell>\n<code language=julia-1.0>\n\"\"\"\n    closest_integer_with_tolerance(value::String)::Int64\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps_t45js2.jl:21\nin expression starting at\
    \ /tmp/tmps_t45js2.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"The value cannot be an empty string\"\
    )\n    \n    number = parse(Float64, value)\n    \n    if number == 0.0\n    \
    \    error(\"The value cannot be 0.0\")\n    \n    if number == 1.0\n        error(\"\
    The value cannot be 1.0\")\n    \n    if number == -1.0\n        error(\"The value\
    \ cannot be -1.0\")\n    \n    if number == -number\n        error(\"The value\
    \ cannot be -number\")\n    \n    if number == number\n        error(\"The value\
    \ cannot be number\")\n    \n    if number == number + 1\n        error(\"The\
    \ value cannot be number + 1\")\n    \n    if number == number - 1\n        error(\"\
    The value cannot be number - 1\")\n    \n    if number == number / 2\n       \
    \ error(\"The value cannot be number / 2\")\n    \n    if number == number / 2.0\n\
    \        error(\"The value cannot be number / 2.0\")\n    \n    if number == number\
    \ / 2.0 + 1\n        error(\"The value cannot be number / 2.0 + 1\")\n    \n \
    \   if number == number / 2.0 - 1\n        error(\"The value cannot be number\
    \ / 2.0 - 1\")\n    \n    if number == number / 2.0 + 1\n        error(\"The value\
    \ cannot be number / 2.0 + 1\")\n    \n    if number == number / 2.0 - 1\n   \
    \     error(\"The value cannot be number / 2.0 - 1\")\n    \n    if number ==\
    \ number / 2.0 + 1\n        error(\"The value cannot be number / 2.0 + 1\")\n\
    \    \n    if number == number / 2.0 - 1\n        error(\"The value cannot be\
    \ number / 2.0 - 1\")\n    \n    if number == number / 2.0 + 1\n        error(\"\
    The value cannot be number / 2.0 + 1\")\n    \n    if number == number / 2.0 -\
    \ 1\n        error(\"The value cannot be number / 2.0 - 1\")\n    \n    if number\
    \ == number / 2.0 + 1\n        error(\"The value cannot be number / 2.0 + 1\"\
    )\n    \n    if number == number / 2.0 - 1\n        error(\"The value cannot be\
    \ number / 2.0 - 1\")\n    \n    if number == number / 2.0 + 1\n        error(\"\
    The value cannot be number / 2.0 + 1\")\n    \n    if number == number / 2.0 -\
    \ 1\n        error(\"The value cannot be number / 2.0 - 1\")\n    \n    if number\
    \ == number / 2.0 + 1\n        error(\"The value cannot be number / 2.0 + 1\"\
    )\n    \n    if number == number / 2.0 - 1\n        error(\"The value cannot be\
    \ number / 2.0 - 1\")\n    \n    if number == number / 2.0 + 1\n        error(\"\
    The value cannot be number / 2.0 + 1\")\n    \n    if number == number / 2.0 -\
    \ 1\n        error(\"The value cannot be number / \nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpahaluhx9.jl:104\nin expression starting at\
    \ /tmp/tmpahaluhx9.jl:104\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    closest_integer = Int64(math.ceil(value))\n\
    \    if closest_integer == value \n        closest_integer = Int64(math.floor(value))\n\
    \    end\n    return closest_integer\nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"\n    closest_integer(value::Float64)\nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgvb7cex9.jl:26\nin expression starting at\
    \ /tmp/tmpgvb7cex9.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ else\n        \n        local value = tonumber(value)\n        local closest\n\
    \        local closestDistance\n        \n        if value == 0\n            closest\
    \ = 0\n            closestDistance = 0\n        else\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\n            \n         \
    \   local closest\n            local closestDistance\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp0w6q8bo3.jl:28\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0w6q8bo3.jl:1\n\
    in expression starting at /tmp/tmp0w6q8bo3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"Value cannot be empty\")\n   \
    \ elseif value == \"-\"\n        error(\"Value cannot be negative\")\n    elseif\
    \ value == \"+\"\n        error(\"Value cannot be positive\")\n    elseif value\
    \ == \"0\"\n        error(\"Value cannot be 0\")\n    elseif value == \"1\"\n\
    \        error(\"Value cannot be 1\")\n    elseif value == \"2\"\n        error(\"\
    Value cannot be 2\")\n    elseif value == \"3\"\n        error(\"Value cannot\
    \ be 3\")\n    elseif value == \"4\"\n        error(\"Value cannot be 4\")\n \
    \   elseif value == \"5\"\n        error(\"Value cannot be 5\")\n    elseif value\
    \ == \"6\"\n        error(\"Value cannot be 6\")\n    elseif value == \"7\"\n\
    \        error(\"Value cannot be 7\")\n    elseif value == \"8\"\n        error(\"\
    Value cannot be 8\")\n    elseif value == \"9\"\n        error(\"Value cannot\
    \ be 9\")\n    else\n        error(\"Value must be an integer or decimal\")\n\
    \    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpppamyblf.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpppamyblf.jl:1\n\
    in expression starting at /tmp/tmpppamyblf.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"The value must be a string\")\n\
    \    end\n    \n    if value == \"0\"\n        return 0\n    end\n    \n    if\
    \ value == \"1\"\n        return 1\n    end\n    \n    if value == \"2\"\n   \
    \     return 2\n    end\n    \n    if value == \"3\"\n        return 3\n    end\n\
    \    \n    if value == \"4\"\n        return 4\n    end\n    \n    if value ==\
    \ \"5\"\n        return 5\n    end\n    \n    if value == \"6\"\n        return\
    \ 6\n    end\n    \n    if value == \"7\"\n        return 7\n    end\n    \n \
    \   if value == \"8\"\n        return 8\n    end\n    \n    if value == \"9\"\n\
    \        return 9\n    end\n    \n    if value == \"10\"\n        return 10\n\
    \    end\n    \n    if value == \"11\"\n        return 11\n    end\n    \n   \
    \ if value == \"12\"\n        return 12\n    end\n    \n    if value == \"13\"\
    \n        return 13\n    end\n    \n    if value == \"14\"\n        return 14\n\
    \    end\n    \n    if value == \"15\"\n        return 15\n    end\n    \n   \
    \ if value == \"16\"\n        return 16\n    end\n    \n    if value == \"17\"\
    \n        return 17\n    end\n    \n    if value == \"18\"\n        return 18\n\
    \    end\n    \n    if value == \"19\"\n        return 19\n    end\n    \n   \
    \ if value == \"20\"\n        return 20\n    end\n    \n    if value == \"21\"\
    \n        return 21\n    end\n    \n    if value == \"22\"\n        return 22\n\
    \    end\n    \n    if value == \"23\"\n        return 23\n    end\n    \n   \
    \ if value == \"24\"\n        return 24\n    end\n    \n    if value == \"25\"\
    \n        return 25\n    end\n    \n    if value == \"26\"\n        return 26\n\
    \    end\n    \n    if value == \"27\"\n        return 27\n    end\n    \n   \
    \ if value == \"28\"\n        return 28\n    end\n    \n    if value == \"29\"\
    \n        return 29\n    end\n    \n    if value == \"30\"\n        return 30\n\
    \    end\n    \n    if value == \"31\"\n        return 31\n    end\n    \n   \
    \ if value == \"32\"\n        return 32\n    end\n    \n    if value == \"33\"\
    \n        return 33\n    end\n    \n    if value == \"34\"\n        return 34\n\
    \    end\n    \n    if value == \"35\"\n        return 35\n    end\n    \n   \
    \ if value == \"36\"\n        return 36\n    end\n    \n    if value == \"37\"\
    \n        return 37\n    end\n    \n    if value == \"38\"\n        return 38\n\
    \    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqtere1fg.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqtere1fg.jl:1\n\
    in expression starting at /tmp/tmpqtere1fg.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\
    \ \n        closest_integer = Int64(math.floor(value))\n    else \n        closest_integer\
    \ = Int64(math.floor(closest_integer))\n    return closest_integer\nend\n</cell>\n\
    <code language=julia-1.0>\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr1tgbc34.jl:26\nin expression starting at\
    \ /tmp/tmpr1tgbc34.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    if value == \"-inf\" \n        closest_integer\
    \ = Int64(-Inf)\n    else if value == \"inf\" \n        closest_integer = Int64(Inf)\n\
    \    else if value == \"nan\" \n        closest_integer = Int64(0)\n    else if\
    \ value == \"-nan\" \n        closest_integer = Int64(-Inf)\n    else if value\
    \ == \"0\"\n        closest_integer = Int64(0)\n    else if value == \"1\"\n \
    \       closest_integer = Int64(1)\n    else if value == \"2\"\n        closest_integer\
    \ = Int64(2)\n    else if value == \"3\"\n        closest_integer = Int64(3)\n\
    \    else if value == \"4\"\n        closest_integer = Int64(4)\n    else if value\
    \ == \"5\"\n        closest_integer = Int64(5)\n    else if value == \"6\"\n \
    \       closest_integer = Int64(6)\n    else if value == \"7\"\n        closest_integer\
    \ = Int64(7)\n    else if value == \"8\"\n        closest_integer = Int64(8)\n\
    \    else if value == \"9\"\n        closest_integer = Int64(9)\n    else if value\
    \ == \"10\"\n        closest_integer = Int64(10)\n    else if value == \"11\"\n\
    \        closest_integer = Int64(11)\n    else if value == \"12\"\n        closest_integer\
    \ = Int64(12)\n    else if value == \"13\"\n        closest_integer = Int64(13)\n\
    \    else if value == \"14\"\n        closest_integer = Int64(14)\n    else if\
    \ value == \"15\"\n        closest_integer = Int64(15)\n    else if value == \"\
    16\"\n        closest_integer = Int64(16)\n    else if value == \"17\"\n     \
    \   closest_integer = Int64(17)\n    else if value == \"18\"\n        closest_integer\
    \ = Int64(18)\n    else if value == \"19\"\n        closest_integer = Int64(19)\n\
    \    else if value == \"20\"\n        closest_integer = Int64(20)\n    else if\
    \ value == \"21\"\n        closest_integer = Int64(21)\n    else if value == \"\
    22\"\n        closest_integer = Int64(22)\n    else if value == \"23\"\n     \
    \   closest_integer = Int64(23)\n    else if value == \"24\"\n        closest_integer\
    \ = Int64(24)\n    else if value == \"25\"\n        closest_integer = Int64(25)\n\
    \    else if value == \"26\"\n        closest_integer = Int64(26)\n    else if\
    \ value == \"\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: use \"elseif\" instead of \"else if\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn1b_clvn.jl:23\nin expression starting at\
    \ /tmp/tmpn1b_clvn.jl:23\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(to_integer(value)))\n    if closest_integer\
    \ == to_integer(value)\n        closest_integer = Int64(math.floor(to_integer(value)))\n\
    \    end\n    return closest_integer\nend\n</cell>\n<code language=julia-1.0>\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwi2o71g7.jl:25\nin expression starting at\
    \ /tmp/tmpwi2o71g7.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"The value cannot be empty\")\n    else\n\
    \        local closest, closest2 = 0, math.inf\n        for n in string.split(value)\n\
    \            if n ~= \"\"\n                local n = tonumber(n)\n           \
    \     if n < closest2\n                    closest, closest2 = n, closest\n  \
    \              end\n            end\n        end\n        return closest\n   \
    \ end\nend\n</cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpen_76qbo.jl:34\nin expression starting at\
    \ /tmp/tmpen_76qbo.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"The value cannot be an empty string\"\
    )\n    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpo5d_b66w.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpo5d_b66w.jl:1\n\
    in expression starting at /tmp/tmpo5d_b66w.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5107sro0.jl:21\nin expression starting at\
    \ /tmp/tmp5107sro0.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    if value == \"0\" || value == \"\
    -0\" \n        then return int64(0)\n    \n    digits = split(value, \".\")\n\
    \    \n    if digits.length == 0 \n        then return int64(value)\n    \n  \
    \  digits_int = int64(0)\n    \n    for d in digits\n        digits_int *= 10\n\
    \        digits_int += int64(d)\n    \n    if digits_int == int64(0)\n       \
    \ then return int64(value)\n    \n    digits_int /= int64(digits.length)\n   \
    \ \n    if digits_int == int64(0)\n        then return int64(value)\n    \n  \
    \  if digits_int < int64(digits.length)\n        then return int64(digits[digits.length\
    \ - 1])\n    \n    return int64(digits[digits.length - 1])\nend\n</cell>\n<code\
    \ language=julia-1.3>\n\"\"\"\n    closest_integer(value::Int64)\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpl96dcqaz.jl:22\nin expression starting at /tmp/tmpl96dcqaz.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"\"\n        closest_integer\
    \ = Int(0)\n    else\n        \n        digits = value.digits\n        \n    \
    \    if digits[1] == \"\"\n            closest_integer = Int(0)\n        else\n\
    \            \n            digits = digits[1].digits\n            \n         \
    \   if digits[1] == \"\"\n                closest_integer = Int(0)\n         \
    \   else\n                \n                digits = digits[1].digits\n      \
    \          \n                if digits[1] == \"\"\n                    closest_integer\
    \ = Int(0)\n                else\n                    \n                    digits\
    \ = digits[1].digits\n                    \n                    if digits[1] ==\
    \ \"\"\n                        closest_integer = Int(0)\n                   \
    \ else\n                        \n                        digits = digits[1].digits\n\
    \                        \n                        if digits[1] == \"\"\n    \
    \                        closest_integer = Int(0)\n                        else\n\
    \                            \n                            digits = digits[1].digits\n\
    \                            \n                            if digits[1] == \"\"\
    \n                                closest_integer = Int(0)\n                 \
    \           else\n                                \n                         \
    \       digits = digits[1].digits\n                                \n        \
    \                        if digits[1] == \"\"\n                              \
    \      closest_integer = Int(0)\n                                else\n      \
    \                              \n                                    digits =\
    \ digits[1].digits\n                                    \n                   \
    \                 if digits[1] == \"\"\n                                     \
    \   closest_integer = Int(0)\n                                    else\n     \
    \                                   \n                                       \
    \ digits = digits[1].digits\n                                        \n      \
    \                                  if digits[1] == \"\"\n                    \
    \                        closest_integer = Int(0)\n                          \
    \              else\n                                            \n          \
    \                                  digits = digits[1].digits\n               \
    \                             \n                                            if\
    \ digits[1] == \"\"\n                                                closest_integer\
    \ = Int(0)\n                                            else\n               \
    \                                 \n                                         \
    \       digits = digits[1].digits\n                                          \
    \      \n                                                if digits[1] == \"\"\n\
    \                                                    closest_integer = Int(0)\n\
    \                                                else\n                      \
    \                              \n                                            \
    \        digits = digits[1].digits\n                                         \
    \           \n                                                    if digits[1]\
    \ == \"\"\n                                                        closest_integer\
    \ = Int(0)\n                                                    else\n       \
    \                                                 \n                         \
    \                               digits = digits[1].digits\n                  \
    \                                      \n                                    \
    \                    if digits[1] == \"\"\n                                  \
    \                          closest_integer = Int(0)\n                        \
    \                                else\n                                      \
    \                      \n                                                    \
    \        digits = digits[1].digits\n                                         \
    \                   \n                                                       \
    \     if digits[1] == \"\"\n                                                 \
    \               closest_integer = Int(0)\n                                   \
    \                         else\n                                             \
    \                   \n                                                       \
    \         digits = digits[1].digits\n                                        \
    \                        \n                                                  \
    \              if digits[1] == \"\"\n                                        \
    \                            closest_integer = Int(0)\n                      \
    \                                          else\n                            \
    \                                        \n                                  \
    \                                  digits = digits[1].digits\n               \
    \                                                     \n                     \
    \                                               if digits[1] == \"\"\n       \
    \                                                                 closest_integer\
    \ = Int(0)\n                                                                 \
    \   else\n                                                                   \
    \     \n                                                                     \
    \   digits = digits[1].digits\n                                              \
    \                          \n                                                \
    \                        if digits[1] == \"\"\n                              \
    \                                              closest_integer = Int(0)\n    \
    \                                                                    else\n  \
    \                                                                          \n\
    \                                                                            digits\
    \ = digits[1].digits\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpwn6zmpan.jl:123\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwn6zmpan.jl:1\n\
    in expression starting at /tmp/tmpwn6zmpan.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.floor(value))\n    if closest_integer ==\
    \ value:\n        closest_integer = Int64(math.ceil(value))\n        if closest_integer\
    \ == value:\n            closest_integer = Int64(math.round(value))\n        \
    \    if closest_integer == value:\n                closest_integer = Int64(math.trunc(value))\n\
    \    return closest_integer\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp05e_5pi6.jl:21\nin expression starting at\
    \ /tmp/tmp05e_5pi6.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        local value = tonumber(value)\n        if value == 0\n            error(\"\
    value cannot be 0\")\n        elseif value == 1\n            return value\n  \
    \      else\n            local closest = 0\n            local closestDistance\
    \ = abs(value - closest)\n            local closestDistanceSquared = closestDistance\
    \ * closestDistance\n            for i = 2, value\n                if closestDistance\
    \ > abs(value - i)\n                    closestDistance = abs(value - i)\n   \
    \                 closestDistanceSquared = closestDistance * closestDistance\n\
    \                end\n            end\n            return closest\n        end\n\
    \    end\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nHere is a solution\
    \ using Julia's built-in function findclosest:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyi7x4g__.jl:32\nin expression starting at\
    \ /tmp/tmpyi7x4g__.jl:32\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        0\n    else\n        closest_integer(value[end-1])\
    \ + 1 \n    end\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg67ila9c.jl:25\nin expression starting at\
    \ /tmp/tmpg67ila9c.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw7ncs4li.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw7ncs4li.jl:1\n\
    in expression starting at /tmp/tmpw7ncs4li.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.floor(Int64(value)))\n    if closest_integer\
    \ == Int64(value) \n        closest_integer = Int64(value) \n    else \n     \
    \   closest_integer = Int64(math.ceil(Int64(value)))\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpc_2vxtyn.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpc_2vxtyn.jl:1\n\
    in expression starting at /tmp/tmpc_2vxtyn.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    \n    if value == \"\"\n       \
    \ return closest_integer\n    \n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    \n    if value == \"\"\n        return closest_integer\n    \n    \n\
    \    if value == \"\"\n        return closest_integer\n    \n    \n    if value\
    \ == \"\"\n        return closest_integer\n    \n    \n    if value == \"\"\n\
    \        return closest_integer\n    \n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    \n    if value == \"\"\n        return closest_integer\n    \n    \n\
    \    if value == \"\"\n        return closest_integer\n    \n    \n    if value\
    \ == \"\"\n        return closest_integer\n    \n    \n    if value == \"\"\n\
    \        return closest_integer\n    \n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    \n    if value == \"\"\n        return closest_integer\n    \n    \n\
    \    if value == \"\"\n        return closest_integer\n    \n    \n    if value\
    \ == \"\"\n        return closest_integer\n    \n    \n    if value == \"\"\n\
    \        return closest_integer\n    \n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    \n    if value == \"\"\n        return closest_integer\n    \n    \n\
    \    if value == \"\"\n        return closest_integer\n    \n    \n    if value\
    \ == \"\"\n        return closest_integer\n    \n    \n    if value == \"\"\n\
    \        return closest_integer\n    \n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    \n    if value == \"\"\n        return closest_integer\n    \n    \n\
    \    if value == \"\"\n        return closest_integer\n    \n    \n    if value\
    \ == \"\"\n        return closest_integer\n    \n    \n    if value == \"\"\n\
    \        return closest_integer\n    \n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    \n    if value == \"\"\n        return closest_integer\n    \n    \n\
    \    if value == \"\"\n        return closest_integer\n    \n    \n    if value\
    \ == \"\"\n        return closest_integer\n    \n    \n    if value == \"\"\n\
    \        return closest_integer\n    \n    \n    if value == \"\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    \n    if value == \"\"\n        return closest_integer\n    \n    \n\
    \    if value == \"\"\n        return closest_integer\n    \n    \n    if value\
    \ == \"\"\n        return closest_integer\n    \n    \n    if value == \"\"\n\
    \        return closest_integer\n\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfla8f38g.jl:1\nin expression starting at /tmp/tmpfla8f38g.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpat52emjn.jl:21\nin expression starting at\
    \ /tmp/tmpat52emjn.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" \n        then return -Infinity \n    else if value\
    \ == \"inf\" \n        then return Infinity \n    else if value == \"nan\" \n\
    \        then return NaN \n    else if value == \"-nan\" \n        then return\
    \ NaN \n    else if value == \"0\" \n        then return 0 \n    else if value\
    \ == \"1\" \n        then return 1 \n    else if value == \"2\" \n        then\
    \ return 2 \n    else if value == \"3\" \n        then return 3 \n    else if\
    \ value == \"4\" \n        then return 4 \n    else if value == \"5\" \n     \
    \   then return 5 \n    else if value == \"6\" \n        then return 6 \n    else\
    \ if value == \"7\" \n        then return 7 \n    else if value == \"8\" \n  \
    \      then return 8 \n    else if value == \"9\" \n        then return 9 \n \
    \   else if value == \"10\" \n        then return 10 \n    else if value == \"\
    11\" \n        then return 11 \n    else if value == \"12\" \n        then return\
    \ 12 \n    else if value == \"13\" \n        then return 13 \n    else if value\
    \ == \"14\" \n        then return 14 \n    else if value == \"15\" \n        then\
    \ return 15 \n    else if value == \"16\" \n        then return 16 \n    else\
    \ if value == \"17\" \n        then return 17 \n    else if value == \"18\" \n\
    \        then return 18 \n    else if value == \"19\" \n        then return 19\
    \ \n    else if value == \"20\" \n        then return 20 \n    else if value ==\
    \ \"21\" \n        then return 21 \n    else if value == \"22\" \n        then\
    \ return 22 \n    else if value == \"23\" \n        then return 23 \n    else\
    \ if value == \"24\" \n        then return 24 \n    else if value == \"25\" \n\
    \        then return 25 \n    else if value == \"26\" \n        then return 26\
    \ \n    else if value == \"27\" \n        then return 27 \n    else if value ==\
    \ \"28\" \n        then return 28 \n    else if value == \"29\" \n        then\
    \ return 29 \n    else if value == \"30\" \n        then return 30 \n    else\
    \ if value == \"31\" \n        then return 31 \n    else if value == \"32\" \n\
    \        then return 32 \n    else if value == \"33\" \n        then return 33\
    \ \n    else if value == \"34\" \n        then return 34 \n    else \nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgwvktgjz.jl:20\nin expression starting at /tmp/tmpgwvktgjz.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        0\n    else\n        closest_integer(value[end-1])\
    \ + 1 \nend\n</cell>\n<text>\nExercise\nWrite a function that takes a string representing\
    \ a floating point number\nand returns the closest floating point number to it.\
    \ If the number\nis equidistant from two floating point numbers, round it away\
    \ from zero.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq_6iulvf.jl:24\nin expression starting at\
    \ /tmp/tmpq_6iulvf.jl:24\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        return -1\n    \n    number = parse(Float64,\
    \ value)\n    \n    if number == 0\n        return -1\n    \n    diff = abs(number\
    \ - 1)\n    \n    if diff < abs(number - 2)\n        return number\n    \n   \
    \ return number - 1\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbf4t2kbg.jl:35\nin expression starting at\
    \ /tmp/tmpbf4t2kbg.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"0\" \n        then return 0\n    else if value == \"1\"\
    \ \n        then return 1\n    else if value == \"2\" \n        then return 2\n\
    \    else if value == \"3\" \n        then return 3\n    else if value == \"4\"\
    \ \n        then return 4\n    else if value == \"5\" \n        then return 5\n\
    \    else if value == \"6\" \n        then return 6\n    else if value == \"7\"\
    \ \n        then return 7\n    else if value == \"8\" \n        then return 8\n\
    \    else if value == \"9\" \n        then return 9\n    else if value == \"10\"\
    \ \n        then return 10\n    else if value == \"11\" \n        then return\
    \ 11\n    else if value == \"12\" \n        then return 12\n    else if value\
    \ == \"13\" \n        then return 13\n    else if value == \"14\" \n        then\
    \ return 14\n    else if value == \"15\" \n        then return 15\n    else if\
    \ value == \"16\" \n        then return 16\n    else if value == \"17\" \n   \
    \     then return 17\n    else if value == \"18\" \n        then return 18\n \
    \   else if value == \"19\" \n        then return 19\n    else if value == \"\
    20\" \n        then return 20\n    else if value == \"21\" \n        then return\
    \ 21\n    else if value == \"22\" \n        then return 22\n    else if value\
    \ == \"23\" \n        then return 23\n    else if value == \"24\" \n        then\
    \ return 24\n    else if value == \"25\" \n        then return 25\n    else if\
    \ value == \"26\" \n        then return 26\n    else if value == \"27\" \n   \
    \     then return 27\n    else if value == \"28\" \n        then return 28\n \
    \   else if value == \"29\" \n        then return 29\n    else if value == \"\
    30\" \n        then return 30\n    else if value == \"31\" \n        then return\
    \ 31\n    else if value == \"32\" \n        then return 32\n    else if value\
    \ == \"33\" \n        then return 33\n    else if value == \"34\" \n        then\
    \ return 34\n    else if value == \"35\" \n        then return 35\n    else if\
    \ value == \"36\" \n        then return 36\n    else if value == \"37\" \n   \
    \     then return 37\n    else if value == \"38\" \n        then return 38\n \
    \   else if value == \"39\" \n        then \nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcrutpf7z.jl:20\nin expression starting at /tmp/tmpcrutpf7z.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ \n    number = parse_value(value)\n    \n    if number == 0\n        error(\"\
    value cannot be 0\")\n    \n    closest_integer = number\n    \n    if number\
    \ < 0\n        closest_integer = -number\n    \n    if number == 1\n        error(\"\
    value cannot be 1\")\n    \n    if number == 2\n        error(\"value cannot be\
    \ 2\")\n    \n    if number == 3\n        error(\"value cannot be 3\")\n    \n\
    \    if number == 4\n        error(\"value cannot be 4\")\n    \n    if number\
    \ == 5\n        error(\"value cannot be 5\")\n    \n    if number == 6\n     \
    \   error(\"value cannot be 6\")\n    \n    if number == 7\n        error(\"value\
    \ cannot be 7\")\n    \n    if number == 8\n        error(\"value cannot be 8\"\
    )\n    \n    if number == 9\n        error(\"value cannot be 9\")\n    \n    if\
    \ number == 10\n        error(\"value cannot be 10\")\n    \n    if number ==\
    \ 11\n        error(\"value cannot be 11\")\n    \n    if number == 12\n     \
    \   error(\"value cannot be 12\")\n    \n    if number == 13\n        error(\"\
    value cannot be 13\")\n    \n    if number == 14\n        error(\"value cannot\
    \ be 14\")\n    \n    if number == 15\n        error(\"value cannot be 15\")\n\
    \    \n    if number == 16\n        error(\"value cannot be 16\")\n    \n    if\
    \ number == 17\n        error(\"value cannot be 17\")\n    \n    if number ==\
    \ 18\n        error(\"value cannot be 18\")\n    \n    if number == 19\n     \
    \   error(\"value cannot be 19\")\n    \n    if number == 20\n        error(\"\
    value cannot be 20\")\n    \n    if number == 21\n        error(\"value cannot\
    \ be 21\")\n    \n    if number == 22\n        error(\"value cannot be 22\")\n\
    \    \n    if number == 23\n        error(\"value cannot be 23\")\n    \n    if\
    \ number == 24\n        error(\"value cannot be 24\")\n    \n    if number ==\
    \ 25\n        error(\"value cannot be 25\")\n    \n    if number == 26\n     \
    \   error(\"value cannot be 26\")\n    \n    if number == 27\n        error(\"\
    value cannot be 27\")\n    \n    if number == 28\n        error(\"value cannot\
    \ be 28\")\n    \n    if number == 29\n        error(\"value cannot be 29\")\n\
    \    \n    if number == 30\n        error(\"value cannot be 30\")\n    \n    if\
    \ number == 31\n        error(\"value cannot be 31\")\n    \n    if number ==\
    \ 32\n        error(\"value cannot be 32\")\n    \n    if number == 33\n     \
    \   error(\"value cannot be 33\")\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2m8znp4b.jl:1\nin expression starting at /tmp/tmp2m8znp4b.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"Value cannot be empty\")\n   \
    \ elseif value == \"-\"\n        error(\"Value cannot be negative\")\n    elseif\
    \ value == \"+\"\n        error(\"Value cannot be positive\")\n    elseif value\
    \ == \"0\"\n        error(\"Value cannot be 0\")\n    elseif value == \"1\"\n\
    \        error(\"Value cannot be 1\")\n    elseif value == \"2\"\n        error(\"\
    Value cannot be 2\")\n    elseif value == \"3\"\n        error(\"Value cannot\
    \ be 3\")\n    elseif value == \"4\"\n        error(\"Value cannot be 4\")\n \
    \   elseif value == \"5\"\n        error(\"Value cannot be 5\")\n    elseif value\
    \ == \"6\"\n        error(\"Value cannot be 6\")\n    elseif value == \"7\"\n\
    \        error(\"Value cannot be 7\")\n    elseif value == \"8\"\n        error(\"\
    Value cannot be 8\")\n    elseif value == \"9\"\n        error(\"Value cannot\
    \ be 9\")\n    else\n        error(\"Value must be an integer, not $value\")\n\
    \    end\n    \n    local digits = value.digits\n    local minimum = digits[1]\n\
    \    local maximum = digits[end]\n    local closest\n    local index\n    \n \
    \   if minimum == maximum\n        error(\"Value cannot be equidistant from two\
    \ integers\")\n    elseif minimum == maximum - 1\n        closest = minimum\n\
    \    elseif minimum == maximum + 1\n        closest = maximum\n    else\n    \
    \    closest = minimum\n        for i = minimum + 1, maximum\n            do\n\
    \                if digits[i] == digits[minimum]\n                    closest\
    \ = i\n                    break\n                end\n            end\n     \
    \   end\n    end\n    \n    return closest\nend\n</cell>\n<text>\nExercise 2\n\
    Write a function that takes a string representing a number and returns the number\
    \ of digits in it.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp21i00i7f.jl:65\nin expression starting at\
    \ /tmp/tmp21i00i7f.jl:65\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(Int64(value)))\n    if closest_integer\
    \ == Int64(value)\n        closest_integer = Int64(0)\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integers(values::Vector{String})\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_3wdmt7d.jl:25\nin expression starting at\
    \ /tmp/tmp_3wdmt7d.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"The value cannot be empty\")\n    else\n\
    \        closest_integer(parse(Float64, value))\n    end\nend\n</cell>\n<code\
    \ language=julia-1.5>\n\"\"\"\n    closest_integer(value::Float64)\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpawue4tu1.jl:25\nin expression starting at\
    \ /tmp/tmpawue4tu1.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    for number in value.split(\".\"\
    ):\n        closest_integer = int64(closest_integer) + int64(number)\n    \n \
    \   if closest_integer == int64(0):\n        closest_integer = int64(1)\n    \n\
    \    return closest_integer\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpap6u27ya.jl:22\nin expression starting at\
    \ /tmp/tmpap6u27ya.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"-inf\" or value == \"\
    inf\" or value == \"\"\n        return closest_integer\n    \n    split_value\
    \ = value.split(\".\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"-\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    +\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"e\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    -\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"+\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    e\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"-\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    +\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"e\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    -\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"+\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    e\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"-\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    +\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"e\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    -\")\n    \n    if split_value[1] == \"0\"\n        return Int(split_value[0])\n\
    \    \n    split_value = split_value[0].split(\"+\")\n    \n    if split_value[1]\
    \ == \"0\"\n        return Int(split_value[0])\n    \n    split_value = split_value[0].split(\"\
    e\")\n    \n    if split_\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"value\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp70wc5k0j.jl:21\nin expression starting at /tmp/tmp70wc5k0j.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    if value == \"-inf\" \n        closest_integer\
    \ = -Int64(Inf.max)\n    elseif value == \"inf\" \n        closest_integer = Int64(Inf.max)\n\
    \    elseif value == \"nan\" \n        closest_integer = Int64(Inf.max)\n    elseif\
    \ value == \"-nan\" \n        closest_integer = -Int64(Inf.max)\n    elseif value\
    \ == \"0\" \n        closest_integer = Int64(0)\n    elseif value == \"1\" \n\
    \        closest_integer = Int64(1)\n    elseif value == \"2\" \n        closest_integer\
    \ = Int64(2)\n    elseif value == \"3\" \n        closest_integer = Int64(3)\n\
    \    elseif value == \"4\" \n        closest_integer = Int64(4)\n    elseif value\
    \ == \"5\" \n        closest_integer = Int64(5)\n    elseif value == \"6\" \n\
    \        closest_integer = Int64(6)\n    elseif value == \"7\" \n        closest_integer\
    \ = Int64(7)\n    elseif value == \"8\" \n        closest_integer = Int64(8)\n\
    \    elseif value == \"9\" \n        closest_integer = Int64(9)\n    elseif value\
    \ == \"10\" \n        closest_integer = Int64(10)\n    elseif value == \"11\"\
    \ \n        closest_integer = Int64(11)\n    elseif value == \"12\" \n       \
    \ closest_integer = Int64(12)\n    elseif value == \"13\" \n        closest_integer\
    \ = Int64(13)\n    elseif value == \"14\" \n        closest_integer = Int64(14)\n\
    \    elseif value == \"15\" \n        closest_integer = Int64(15)\n    elseif\
    \ value == \"16\" \n        closest_integer = Int64(16)\n    elseif value == \"\
    17\" \n        closest_integer = Int64(17)\n    elseif value == \"18\" \n    \
    \    closest_integer = Int64(18)\n    elseif value == \"19\" \n        closest_integer\
    \ = Int64(19)\n    elseif value == \"20\" \n        closest_integer = Int64(20)\n\
    \    elseif value == \"21\" \n        closest_integer = Int64(21)\n    elseif\
    \ value == \"22\" \n        closest_integer = Int64(22)\n    elseif value == \"\
    23\" \n        closest_integer = Int64(23)\n    elseif value == \"24\" \n    \
    \    closest_integer = Int64(24)\n    elseif value == \"25\" \n        closest_integer\
    \ = Int64(25)\n    elseif value == \"26\" \n        closest_integer = Int64(26)\n\
    \    elseif value == \"27\" \n        closest_integer = Int64(27)\n    elseif\
    \ value == \"28\" \n        closest_integ\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp35x3e7ac.jl:1\nin expression starting at /tmp/tmp35x3e7ac.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"0\" \n        then return 0\n    else if value == \"1\"\
    \ \n        then return 1\n    else if value == \"2\" \n        then return 2\n\
    \    else if value == \"3\" \n        then return 3\n    else if value == \"4\"\
    \ \n        then return 4\n    else if value == \"5\" \n        then return 5\n\
    \    else if value == \"6\" \n        then return 6\n    else if value == \"7\"\
    \ \n        then return 7\n    else if value == \"8\" \n        then return 8\n\
    \    else if value == \"9\" \n        then return 9\n    else if value == \"10\"\
    \ \n        then return 10\n    else if value == \"11\" \n        then return\
    \ 11\n    else if value == \"12\" \n        then return 12\n    else if value\
    \ == \"13\" \n        then return 13\n    else if value == \"14\" \n        then\
    \ return 14\n    else if value == \"15\" \n        then return 15\n    else if\
    \ value == \"16\" \n        then return 16\n    else if value == \"17\" \n   \
    \     then return 17\n    else if value == \"18\" \n        then return 18\n \
    \   else if value == \"19\" \n        then return 19\n    else if value == \"\
    20\" \n        then return 20\n    else if value == \"21\" \n        then return\
    \ 21\n    else if value == \"22\" \n        then return 22\n    else if value\
    \ == \"23\" \n        then return 23\n    else if value == \"24\" \n        then\
    \ return 24\n    else if value == \"25\" \n        then return 25\n    else if\
    \ value == \"26\" \n        then return 26\n    else if value == \"27\" \n   \
    \     then return 27\n    else if value == \"28\" \n        then return 28\n \
    \   else if value == \"29\" \n        then return 29\n    else if value == \"\
    30\" \n        then return 30\n    else if value == \"31\" \n        then return\
    \ 31\n    else if value == \"32\" \n        then return 32\n    else if value\
    \ == \"33\" \n        then return 33\n    else if value == \"34\" \n        then\
    \ return 34\n    else if value == \"35\" \n        then return 35\n    else if\
    \ value == \"36\" \n        then return 36\n    else if value == \"37\" \n   \
    \     then return 37\n    else if value == \"38\" \n        then return 38\n \
    \   else if value == \"39\" \n        then \nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcrutpf7z.jl:20\nin expression starting at /tmp/tmpcrutpf7z.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    if value == \"-inf\" \n        closest_integer\
    \ = Int(-Inf)\n    elseif value == \"inf\" \n        closest_integer = Int(Inf)\n\
    \    elseif value == \"nan\" \n        closest_integer = Int(nan)\n    elseif\
    \ value == \"-nan\" \n        closest_integer = Int(nan)\n    elseif value ==\
    \ \"0\" \n        closest_integer = Int(0)\n    elseif value == \"1\" \n     \
    \   closest_integer = Int(1)\n    elseif value == \"2\" \n        closest_integer\
    \ = Int(2)\n    elseif value == \"3\" \n        closest_integer = Int(3)\n   \
    \ elseif value == \"4\" \n        closest_integer = Int(4)\n    elseif value ==\
    \ \"5\" \n        closest_integer = Int(5)\n    elseif value == \"6\" \n     \
    \   closest_integer = Int(6)\n    elseif value == \"7\" \n        closest_integer\
    \ = Int(7)\n    elseif value == \"8\" \n        closest_integer = Int(8)\n   \
    \ elseif value == \"9\" \n        closest_integer = Int(9)\n    elseif value ==\
    \ \"10\" \n        closest_integer = Int(10)\n    elseif value == \"11\" \n  \
    \      closest_integer = Int(11)\n    elseif value == \"12\" \n        closest_integer\
    \ = Int(12)\n    elseif value == \"13\" \n        closest_integer = Int(13)\n\
    \    elseif value == \"14\" \n        closest_integer = Int(14)\n    elseif value\
    \ == \"15\" \n        closest_integer = Int(15)\n    elseif value == \"16\" \n\
    \        closest_integer = Int(16)\n    elseif value == \"17\" \n        closest_integer\
    \ = Int(17)\n    elseif value == \"18\" \n        closest_integer = Int(18)\n\
    \    elseif value == \"19\" \n        closest_integer = Int(19)\n    elseif value\
    \ == \"20\" \n        closest_integer = Int(20)\n    elseif value == \"21\" \n\
    \        closest_integer = Int(21)\n    elseif value == \"22\" \n        closest_integer\
    \ = Int(22)\n    elseif value == \"23\" \n        closest_integer = Int(23)\n\
    \    elseif value == \"24\" \n        closest_integer = Int(24)\n    elseif value\
    \ == \"25\" \n        closest_integer = Int(25)\n    elseif value == \"26\" \n\
    \        closest_integer = Int(26)\n    elseif value == \"27\" \n        closest_integer\
    \ = Int(27)\n    elseif value == \"28\" \n        closest_integer = Int(28)\n\
    \    elseif value == \"29\" \n        closest_integer = Int(29)\n    elseif value\
    \ == \"30\" \n        closest_integer = Int(30)\n    elseif value == \"31\" \n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb8bggxh3.jl:1\nin expression starting at /tmp/tmpb8bggxh3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3o6cy5kj.jl:21\nin expression starting at\
    \ /tmp/tmp3o6cy5kj.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"Value cannot be empty\")\n    elseif\
    \ value == \"-\"\n        error(\"Value cannot be negative\")\n    elseif value\
    \ == \"+\"\n        error(\"Value cannot be positive\")\n    elseif value == \"\
    0\"\n        error(\"Value cannot be zero\")\n    elseif value == \"1\"\n    \
    \    error(\"Value cannot be one\")\n    elseif value == \"2\"\n        error(\"\
    Value cannot be two\")\n    elseif value == \"3\"\n        error(\"Value cannot\
    \ be three\")\n    elseif value == \"4\"\n        error(\"Value cannot be four\"\
    )\n    elseif value == \"5\"\n        error(\"Value cannot be five\")\n    elseif\
    \ value == \"6\"\n        error(\"Value cannot be six\")\n    elseif value ==\
    \ \"7\"\n        error(\"Value cannot be seven\")\n    elseif value == \"8\"\n\
    \        error(\"Value cannot be eight\")\n    elseif value == \"9\"\n       \
    \ error(\"Value cannot be nine\")\n    elseif value == \".\"\n        error(\"\
    Value cannot be a decimal point\")\n    elseif value == \"e\"\n        error(\"\
    Value cannot be an exponent\")\n    elseif value == \"E\"\n        error(\"Value\
    \ cannot be an exponent with capital E\")\n    elseif value == \"+\"\n       \
    \ error(\"Value cannot be an exponent with plus sign\")\n    elseif value == \"\
    -\"\n        error(\"Value cannot be an exponent with minus sign\")\n    elseif\
    \ value == \"*\"\n        error(\"Value cannot be an exponent with asterisk\"\
    )\n    elseif value == \"/\"\n        error(\"Value cannot be an exponent with\
    \ division\")\n    elseif value == \"%\"\n        error(\"Value cannot be an exponent\
    \ with modulo\")\n    elseif value == \"^\"\n        error(\"Value cannot be an\
    \ exponent with caret\")\n    elseif value == \"~\"\n        error(\"Value cannot\
    \ be an exponent with tilde\")\n    elseif value == \"(\"\n        error(\"Value\
    \ cannot be an exponent with left parenthesis\")\n    elseif value == \")\"\n\
    \        error(\"Value cannot be an exponent with right parenthesis\")\n    elseif\
    \ value == \"[\"\n        error(\"Value cannot be an exponent with left square\
    \ bracket\")\n    elseif value == \"]\"\n        error(\"Value cannot be an exponent\
    \ with right square bracket\")\n    elseif value == \"(\"\n        error(\"Value\
    \ cannot be an exponent with left parenthesis\")\n    elseif value == \")\"\n\
    \        error(\"Value cannot be an exponent with right parenthesis\")\n    elseif\
    \ value == \"{\"\n        error(\"Value cannot be an exponent with left curly\
    \ bracket\")\n    elseif value == \"}\"\n        error(\"Value cannot be an exponent\
    \ with right curly bracket\")\n    elseif value == \"<\"\n        error(\"Value\
    \ cannot be an exponent with left angle\")\n    elseif value \nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1bvzg8pk.jl:1\nin expression starting at /tmp/tmp1bvzg8pk.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\
    \ \n        closest_integer = Int64(math.floor(value))\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.1>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmd4atbcx.jl:25\nin expression starting at\
    \ /tmp/tmpmd4atbcx.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    end\n\
    \    \n    number = parse(Float64, value)\n    if number == 0.0\n        error(\"\
    value cannot be 0\")\n    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6c5rcaux.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6c5rcaux.jl:1\n\
    in expression starting at /tmp/tmp6c5rcaux.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    \n    if value == \"-inf\" or value\
    \ == \"inf\" or value == \"\"\n        return int64(0)\n    \n    \n    \n   \
    \ if value == \"0\"\n        return int64(0)\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"value\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpch4_1l8y.jl:22\nin expression starting at /tmp/tmpch4_1l8y.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integers(values::Vector{String})\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphrjdmkfj.jl:21\nin expression starting at\
    \ /tmp/tmphrjdmkfj.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        throw(ArgumentError(\"Value cannot be\
    \ empty\"))\n    end\n    \n    if value == \"-\"\n        return -closest_integer(value[1:end])\n\
    \    end\n    \n    if value == \"+\"\n        return closest_integer(value[1:end])\n\
    \    end\n    \n    if value == \"0\"\n        return 0\n    end\n    \n    if\
    \ value == \"1\"\n        return 1\n    end\n    \n    if value == \"2\"\n   \
    \     return 2\n    end\n    \n    if value == \"3\"\n        return 3\n    end\n\
    \    \n    if value == \"4\"\n        return 4\n    end\n    \n    if value ==\
    \ \"5\"\n        return 5\n    end\n    \n    if value == \"6\"\n        return\
    \ 6\n    end\n    \n    if value == \"7\"\n        return 7\n    end\n    \n \
    \   if value == \"8\"\n        return 8\n    end\n    \n    if value == \"9\"\n\
    \        return 9\n    end\n    \n    if value == \"10\"\n        return 10\n\
    \    end\n    \n    if value == \"11\"\n        return 11\n    end\n    \n   \
    \ if value == \"12\"\n        return 12\n    end\n    \n    if value == \"13\"\
    \n        return 13\n    end\n    \n    if value == \"14\"\n        return 14\n\
    \    end\n    \n    if value == \"15\"\n        return 15\n    end\n    \n   \
    \ if value == \"16\"\n        return 16\n    end\n    \n    if value == \"17\"\
    \n        return 17\n    end\n    \n    if value == \"18\"\n        return 18\n\
    \    end\n    \n    if value == \"19\"\n        return 19\n    end\n    \n   \
    \ if value == \"20\"\n        return 20\n    end\n    \n    if value == \"21\"\
    \n        return 21\n    end\n    \n    if value == \"22\"\n        return 22\n\
    \    end\n    \n    if value == \"23\"\n        return 23\n    end\n    \n   \
    \ if value == \"24\"\n        return 24\n    end\n    \n    if value == \"25\"\
    \n        return 25\n    end\n    \n    if value == \"26\"\n        return 26\n\
    \    end\n    \n    if value == \"27\"\n        return 27\n    end\n    \n   \
    \ if value == \"28\"\n        return 28\n    end\n    \n    if value == \"29\"\
    \n        return 29\n    end\n    \n    if value == \"30\"\n        return 30\n\
    \    end\n    \n    if value == \"31\"\n        return 31\n    end\n    \n   \
    \ if value == \"32\"\n        return 32\n    end\n    \n    if value == \"33\"\
    \n        return 33\n    end\n    \n    if value == \"34\"\n        return 34\n\
    \    end\n    \n    if value == \"35\"\n        return 35\n    end\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp8utpjqgk.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp8utpjqgk.jl:1\n\
    in expression starting at /tmp/tmp8utpjqgk.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"The value you provided is empty\"\
    )\n    elseif value == \"-\"\n        error(\"The value you provided is negative\"\
    )\n    elseif value == \"+\"\n        error(\"The value you provided is positive\"\
    )\n    elseif value == \"0\"\n        error(\"The value you provided is zero\"\
    )\n    elseif value == \"1\"\n        error(\"The value you provided is one\"\
    )\n    elseif value == \"2\"\n        error(\"The value you provided is two\"\
    )\n    elseif value == \"3\"\n        error(\"The value you provided is three\"\
    )\n    elseif value == \"4\"\n        error(\"The value you provided is four\"\
    )\n    elseif value == \"5\"\n        error(\"The value you provided is five\"\
    )\n    elseif value == \"6\"\n        error(\"The value you provided is six\"\
    )\n    elseif value == \"7\"\n        error(\"The value you provided is seven\"\
    )\n    elseif value == \"8\"\n        error(\"The value you provided is eight\"\
    )\n    elseif value == \"9\"\n        error(\"The value you provided is nine\"\
    )\n    elseif value == \".\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"e\"\n        error(\"The value you provided is exponential\"\
    )\n    elseif value == \"E\"\n        error(\"The value you provided is exponential\"\
    )\n    elseif value == \"+\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"-\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"*\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"/\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"%\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"^\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"~\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"(\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \")\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"+\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"-\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"*\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"/\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"%\"\n        error(\"The value you provided is invalid\"\
    )\n    elseif value == \"^\"\n        error(\"The value you provided is invalid\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpip94l7g4.jl:87\nin expression starting at\
    \ /tmp/tmpip94l7g4.jl:87\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" \n        then return -Infinity \n    else if value\
    \ == \"inf\" \n        then return Infinity \n    else if value == \"nan\" \n\
    \        then return NaN \n    else if value == \"-nan\" \n        then return\
    \ NaN \n    else if value == \"0\" \n        then return 0 \n    else if value\
    \ == \"1\" \n        then return 1 \n    else if value == \"2\" \n        then\
    \ return 2 \n    else if value == \"3\" \n        then return 3 \n    else if\
    \ value == \"4\" \n        then return 4 \n    else if value == \"5\" \n     \
    \   then return 5 \n    else if value == \"6\" \n        then return 6 \n    else\
    \ if value == \"7\" \n        then return 7 \n    else if value == \"8\" \n  \
    \      then return 8 \n    else if value == \"9\" \n        then return 9 \n \
    \   else if value == \"10\" \n        then return 10 \n    else if value == \"\
    11\" \n        then return 11 \n    else if value == \"12\" \n        then return\
    \ 12 \n    else if value == \"13\" \n        then return 13 \n    else if value\
    \ == \"14\" \n        then return 14 \n    else if value == \"15\" \n        then\
    \ return 15 \n    else if value == \"16\" \n        then return 16 \n    else\
    \ if value == \"17\" \n        then return 17 \n    else if value == \"18\" \n\
    \        then return 18 \n    else if value == \"19\" \n        then return 19\
    \ \n    else if value == \"20\" \n        then return 20 \n    else if value ==\
    \ \"21\" \n        then return 21 \n    else if value == \"22\" \n        then\
    \ return 22 \n    else if value == \"23\" \n        then return 23 \n    else\
    \ if value == \"24\" \n        then return 24 \n    else if value == \"25\" \n\
    \        then return 25 \n    else if value == \"26\" \n        then return 26\
    \ \n    else if value == \"27\" \n        then return 27 \n    else if value ==\
    \ \"28\" \n        then return 28 \n    else if value == \"29\" \n        then\
    \ return 29 \n    else if value == \"30\" \n        then return 30 \n    else\
    \ if value == \"31\" \n        then return 31 \n    else if value == \"32\" \n\
    \        then return 32 \n    else if value == \"33\" \n        then return 33\
    \ \n    else if value == \"34\" \n        then return 34 \n    else \nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgwvktgjz.jl:20\nin expression starting at /tmp/tmpgwvktgjz.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.floor(Int64(value)))\n    if closest_integer\
    \ == value \n        closest_integer = Int64(math.ceil(Int64(value)))\n    end\n\
    \    return closest_integer\nend\n</cell>\n<code language=julia-1.5>\n# TEST closest_integer\
    \ (5b)\n# BEGIN closest_integer(\"10\")\n@test closest_integer(\"10\") == 10\n\
    @test closest_integer(\"15.3\") == 15\n# END closest_integer(\"10\")\n# BEGIN\
    \ closest_integer(\"15.3\")\n@test closest_integer(\"15.3\") == 15\n@test closest_integer(\"\
    -15.3\") == -15\n# END closest_integer(\"15.3\")\n# BEGIN closest_integer(\"-15.3\"\
    )\n@test closest_integer(\"-15.3\") == -15\n@test closest_integer(\"14.5\") ==\
    \ 15\n# END closest_integer(\"-15.3\")\n# BEGIN closest_integer(\"14.5\")\n@test\
    \ closest_integer(\"14.5\") == 15\n@test closest_integer(\"-14.5\") == -15\n#\
    \ END closest_integer(\"14.5\")\n# BEGIN closest_integer(\"-14.5\")\n@test closest_integer(\"\
    -14.5\") == -15\n@test closest_integer(\"14.4\") == 15\n# END closest_integer(\"\
    -14.5\")\n# BEGIN closest_integer(\"14.4\")\n@test closest_integer(\"14.4\") ==\
    \ 15\n@test closest_integer(\"-14.4\") == -15\n# END closest_integer(\"14.4\"\
    )\n# BEGIN closest_integer(\"-14.4\")\n@test closest_integer(\"-14.4\") == -15\n\
    @test closest_integer(\"14.3\") == 15\n# END closest_integer(\"-14.4\")\n# BEGIN\
    \ closest_integer(\"14.3\")\n@test closest_integer(\"14.3\") == 15\n@test closest_integer(\"\
    -14.3\") == -15\n# END closest_integer(\"14.3\")\n# BEGIN closest_integer(\"-14.3\"\
    )\n@test closest_integer(\"-14.3\") == -15\n@test closest_integer(\"14.2\") ==\
    \ 15\n# END closest_integer(\"-14.3\")\n# BEGIN closest_integer(\"14.2\")\n@test\
    \ closest_integer(\"14.2\") == 15\n@test closest_integer(\"-14.2\") == -15\n#\
    \ END closest_integer(\"14.2\")\n# BEGIN closest_integer(\"-14.2\")\n@test closest_integer(\"\
    -14.2\") == -15\n@test closest_integer(\"14.1\") == 15\n# END closest_integer(\"\
    -14.2\")\n# BEGIN closest_integer(\"14.1\")\n@test closest_integer(\"14.1\") ==\
    \ 15\n@test closest_integer(\"-14.1\") == -15\n# END closest_integer(\"14.1\"\
    )\n# BEGIN closest_integer(\"-14.1\")\n@test closest_integer(\"-14.1\") == -15\n\
    \nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1vnatbc8.jl:25\nin expression starting at\
    \ /tmp/tmp1vnatbc8.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    if value == \"\"\n        return\
    \ int64(0)\n    \n    if value == \"-\"\n        return int64(0)\n    \n    if\
    \ value == \"+\"\n        return int64(0)\n    \n    if value == \"0\"\n     \
    \   return int64(0)\n    \n    if value == \"1\"\n        return int64(1)\n  \
    \  \n    if value == \"2\"\n        return int64(2)\n    \n    if value == \"\
    3\"\n        return int64(3)\n    \n    if value == \"4\"\n        return int64(4)\n\
    \    \n    if value == \"5\"\n        return int64(5)\n    \n    if value == \"\
    6\"\n        return int64(6)\n    \n    if value == \"7\"\n        return int64(7)\n\
    \    \n    if value == \"8\"\n        return int64(8)\n    \n    if value == \"\
    9\"\n        return int64(9)\n    \n    if value == \"10\"\n        return int64(10)\n\
    \    \n    if value == \"11\"\n        return int64(11)\n    \n    if value ==\
    \ \"12\"\n        return int64(12)\n    \n    if value == \"13\"\n        return\
    \ int64(13)\n    \n    if value == \"14\"\n        return int64(14)\n    \n  \
    \  if value == \"15\"\n        return int64(15)\n    \n    if value == \"16\"\n\
    \        return int64(16)\n    \n    if value == \"17\"\n        return int64(17)\n\
    \    \n    if value == \"18\"\n        return int64(18)\n    \n    if value ==\
    \ \"19\"\n        return int64(19)\n    \n    if value == \"20\"\n        return\
    \ int64(20)\n    \n    if value == \"21\"\n        return int64(21)\n    \n  \
    \  if value == \"22\"\n        return int64(22)\n    \n    if value == \"23\"\n\
    \        return int64(23)\n    \n    if value == \"24\"\n        return int64(24)\n\
    \    \n    if value == \"25\"\n        return int64(25)\n    \n    if value ==\
    \ \"26\"\n        return int64(26)\n    \n    if value == \"27\"\n        return\
    \ int64(27)\n    \n    if value == \"28\"\n        return int64(28)\n    \n  \
    \  if value == \"29\"\n        return int64(29)\n    \n    if value == \"30\"\n\
    \        return int64(30)\n    \n    if value == \"31\"\n        return int64(31)\n\
    \    \n    if value == \"32\"\n        return int64(32)\n    \n    if value ==\
    \ \"33\"\n        return int64(33)\n    \n    if value == \"34\"\n        return\
    \ int64(34)\n    \n    if value == \"35\"\n        return int64(35)\n    \n  \
    \  if value == \"36\"\n        return int64\nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpz2mv6nr8.jl:1\nin expression starting at /tmp/tmpz2mv6nr8.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"The value cannot be an empty string\"\
    )\n    else\n        closest_integer(parse(Float64, value))\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzu_lhmz9.jl:25\nin expression starting at\
    \ /tmp/tmpzu_lhmz9.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" || value == \"inf\" \n        then return value\n\
    \    \n    local digits = value.split('.')\n    local digits_int = digits[1]:split('.')\n\
    \    local digits_int_int = digits_int[1]:split('.')\n    local digits_int_int_int\
    \ = digits_int_int[1]:split('.')\n    local digits_int_int_int_int = digits_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int = digits_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int = digits_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int = digits_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int = digits_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int = digits_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int_int = digits_int_int_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int_int_int = digits_int_int_int_int_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int_int_int_int = digits_int_int_int_int_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int = digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int\
    \ = digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int\
    \ = digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int\
    \ = digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int\
    \ = digits_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int[1]:split('.')\n\
    \    local digits_int_int_int_int_int_int_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsjemq4v_.jl:20\nin expression starting at /tmp/tmpsjemq4v_.jl:20\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"The value cannot be empty\")\n    else\n\
    \        closest_integer(tostring(value))\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmpvbhlxvuq.jl:30\n  Test threw
    exception\n  Expression: candidate("10") == 10\n  UndefVarError: tostring not
    defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @ Main /tmp/tmpvbhlxvuq.jl:22\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvbhlxvuq.jl:30 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvbhlxvuq.jl:29\ntest set: Error
    During Test at /tmp/tmpvbhlxvuq.jl:31\n  Test threw exception\n  Expression: candidate("14.5")
    == 15\n  UndefVarError: tostring not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpvbhlxvuq.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvbhlxvuq.jl:31 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvbhlxvuq.jl:29\ntest set: Error
    During Test at /tmp/tmpvbhlxvuq.jl:32\n  Test threw exception\n  Expression: candidate("-15.5")
    == -16\n  UndefVarError: tostring not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpvbhlxvuq.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvbhlxvuq.jl:32 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvbhlxvuq.jl:29\ntest set: Error
    During Test at /tmp/tmpvbhlxvuq.jl:33\n  Test threw exception\n  Expression: candidate("15.3")
    == 15\n  UndefVarError: tostring not defined\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @
    Main /tmp/tmpvbhlxvuq.jl:22\n   [2'
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.floor(Int64(value)))\n    if closest_integer\
    \ == value \n        closest_integer = Int64(math.ceil(Int64(value)))\n    end\n\
    \    return closest_integer\nend\n</cell>\n<code language=julia-1.4>\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptylbc7wd.jl:25\nin expression starting at\
    \ /tmp/tmptylbc7wd.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        0\n    else\n        closest_integer(value[end-1])\
    \ + 1 \nend\n</cell>\n<text>\nExercise: Write a function that takes a string representing\
    \ a number and returns the closest floating point number to it. If the number\
    \ is equidistant from two floating point numbers, round it away from zero.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdnrc0ym3.jl:24\nin expression starting at\
    \ /tmp/tmpdnrc0ym3.jl:24\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    closest_integer = Int64(math.floor(Int64(value)))\n    \n    if\
    \ closest_integer == Int64(value) \n        closest_integer = Int64(0)\n    end\n\
    \    \n    return closest_integer\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpaswih1lb.jl:28\nin expression starting at\
    \ /tmp/tmpaswih1lb.jl:28\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        return -1\n    \n    number = parse_value(value)\n\
    \    if number == -1\n        return -1\n    \n    diff = abs(number - 1)\n  \
    \  if diff < abs(number - 2)\n        return number\n    \n    diff = abs(number\
    \ - 2)\n    if diff < abs(number - 3)\n        return number + 1\n    \n    diff\
    \ = abs(number - 3)\n    if diff < abs(number - 4)\n        return number + 2\n\
    \    \n    diff = abs(number - 4)\n    if diff < abs(number - 5)\n        return\
    \ number + 3\n    \n    diff = abs(number - 5)\n    if diff < abs(number - 6)\n\
    \        return number + 4\n    \n    diff = abs(number - 6)\n    if diff < abs(number\
    \ - 7)\n        return number + 5\n    \n    diff = abs(number - 7)\n    if diff\
    \ < abs(number - 8)\n        return number + 6\n    \n    diff = abs(number -\
    \ 8)\n    if diff < abs(number - 9)\n        return number + 7\n    \n    diff\
    \ = abs(number - 9)\n    if diff < abs(number - 10)\n        return number + 8\n\
    \    \n    diff = abs(number - 10)\n    if diff < abs(number - 11)\n        return\
    \ number + 9\n    \n    diff = abs(number - 11)\n    if diff < abs(number - 12)\n\
    \        return number + 10\n    \n    diff = abs(number - 12)\n    if diff <\
    \ abs(number - 13)\n        return number + 11\n    \n    diff = abs(number -\
    \ 13)\n    if diff < abs(number - 14)\n        return number + 12\n    \n    diff\
    \ = abs(number - 14)\n    if diff < abs(number - 15)\n        return number +\
    \ 13\n    \n    diff = abs(number - 15)\n    if diff < abs(number - 16)\n    \
    \    return number + 14\n    \n    diff = abs(number - 16)\n    if diff < abs(number\
    \ - 17)\n        return number + 15\n    \n    diff = abs(number - 17)\n    if\
    \ diff < abs(number - 18)\n        return number + 16\n    \n    diff = abs(number\
    \ - 18)\n    if diff < abs(number - 19)\n        return number + 17\n    \n  \
    \  diff = abs(number - 19)\n    if diff < abs(number - 20)\n        return number\
    \ + 18\n    \n    diff = abs(number - 20)\n    if diff < abs(number - 21)\n  \
    \      return number + 19\n    \n    diff = abs(number - 21)\n    if diff < abs(number\
    \ - 22)\n        return number + 20\n    \n    diff = abs(number - 22)\n    if\
    \ diff < abs(number - 23)\n        return number + 21\n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp9jqpkm9.jl:1\nin expression starting at /tmp/tmpp9jqpkm9.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.floor(value))\n    if closest_integer ==\
    \ value:\n        closest_integer = Int64(math.ceil(value))\n        if closest_integer\
    \ == value:\n            closest_integer = Int64(math.round(value))\n    return\
    \ closest_integer\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8onz6onw.jl:21\nin expression starting at\
    \ /tmp/tmp8onz6onw.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"The value provided cannot be empty\"\
    )\n    \n    digits = value.digits\n    \n    if digits == 0\n        error(\"\
    The value provided cannot be empty\")\n    \n    smallest_digit = digits[0]\n\
    \    \n    for digit in digits[1..]\n        if digit < smallest_digit\n     \
    \       smallest_digit = digit\n    \n    if smallest_digit == 0\n        error(\"\
    The value provided cannot be empty\")\n    \n    largest_digit = digits[end]\n\
    \    \n    for digit in digits[1..end]\n        if digit > largest_digit\n   \
    \         largest_digit = digit\n    \n    if largest_digit == 0\n        error(\"\
    The value provided cannot be empty\")\n    \n    if smallest_digit == largest_digit\n\
    \        return smallest_digit\n    \n    difference = largest_digit - smallest_digit\n\
    \    \n    if difference < 0\n        return smallest_digit - difference\n   \
    \ else\n        return largest_digit + difference\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"]\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp2oti3b11.jl:30\nin expression starting at /tmp/tmp2oti3b11.jl:30\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be an empty string\"\
    )\n    elseif value == \"-\"\n        error(\"value cannot be a negative number\"\
    )\n    elseif value == \"+\"\n        error(\"value cannot be a positive number\"\
    )\n    elseif value == \"0\"\n        error(\"value cannot be a zero\")\n    elseif\
    \ value == \"1\"\n        error(\"value cannot be a one\")\n    elseif value ==\
    \ \"2\"\n        error(\"value cannot be a two\")\n    elseif value == \"3\"\n\
    \        error(\"value cannot be a three\")\n    elseif value == \"4\"\n     \
    \   error(\"value cannot be a four\")\n    elseif value == \"5\"\n        error(\"\
    value cannot be a five\")\n    elseif value == \"6\"\n        error(\"value cannot\
    \ be a six\")\n    elseif value == \"7\"\n        error(\"value cannot be a seven\"\
    )\n    elseif value == \"8\"\n        error(\"value cannot be a eight\")\n   \
    \ elseif value == \"9\"\n        error(\"value cannot be a nine\")\n    elseif\
    \ value == \".\"\n        error(\"value cannot be a decimal point\")\n    elseif\
    \ value == \"e\"\n        error(\"value cannot be an exponent\")\n    else\n \
    \       error(\"value cannot be a number\")\n    end\n    \n    digits = split(value,\
    \ \".\")\n    \n    if length(digits) < 2\n        error(\"value cannot be equidistant\
    \ from two integers\")\n    elseif digits[1] == \"0\"\n        error(\"value cannot\
    \ be equidistant from two integers\")\n    else\n        digits[1] = digits[1][1:end-1]\n\
    \    end\n    \n    digits[1] = digits[1] * 10\n    \n    digits[1] = digits[1]\
    \ + digits[2]\n    \n    digits[1] = digits[1] / 10\n    \n    digits[1] = digits[1]\
    \ % 10\n    \n    return digits[1]\nend\n</cell>\n<text>\nExercise 3\nWrite a\
    \ function that takes a string representing a number and returns the number of\
    \ digits in that number.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6j6z8zw7.jl:74\nin expression starting at\
    \ /tmp/tmp6j6z8zw7.jl:74\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5107sro0.jl:21\nin expression starting at\
    \ /tmp/tmp5107sro0.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    closest_integer = Int64(math.floor(value))\n    if closest_integer\
    \ == value:\n        closest_integer = Int64(math.ceil(value))\n        if closest_integer\
    \ == value:\n            closest_integer = Int64(math.round(value))\n        \
    \    if closest_integer == value:\n                closest_integer = Int64(math.trunc(value))\n\
    \                if closest_integer == value:\n                    closest_integer\
    \ = Int64(math.floor(value))\n                    if closest_integer == value:\n\
    \                        closest_integer = Int64(math.ceil(value))\n         \
    \               if closest_integer == value:\n                            closest_integer\
    \ = Int64(math.round(value))\n                            if closest_integer ==\
    \ value:\n                                closest_integer = Int64(math.trunc(value))\n\
    \                                if closest_integer == value:\n              \
    \                      closest_integer = Int64(math.floor(value))\n          \
    \                          if closest_integer == value:\n                    \
    \                    closest_integer = Int64(math.ceil(value))\n             \
    \                           if closest_integer == value:\n                   \
    \                         closest_integer = Int64(math.round(value))\n       \
    \                                     if closest_integer == value:\n         \
    \                                       closest_integer = Int64(math.trunc(value))\n\
    \                                                if closest_integer == value:\n\
    \                                                    closest_integer = Int64(math.floor(value))\n\
    \                                                    if closest_integer == value:\n\
    \                                                        closest_integer = Int64(math.ceil(value))\n\
    \                                                        if closest_integer ==\
    \ value:\n                                                            closest_integer\
    \ = Int64(math.round(value))\n                                               \
    \             if closest_integer == value:\n                                 \
    \                               closest_integer = Int64(math.trunc(value))\n \
    \                                                               if closest_integer\
    \ == value:\n                                                                \
    \    closest_integer = Int64(math.floor(value))\n                            \
    \                                        if closest_integer == value:\n      \
    \                                                                  closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \                        if closest_integer == value:\n                      \
    \                                                      closest_integer = Int64(math.round(value))\n\
    \                                                                            if\
    \ closest_integer == value:\n                                                \
    \                                closest_integer = Int64(math.trunc(value))\n\
    \                                                                            \
    \    if closest_integer == value:\n                                          \
    \                                          closest_integer = Int64(math.floor(value))\n\
    \                                                                            \
    \        if closest_integer == value:\n                                      \
    \                                                  closest_integer = Int64(math.ceil(value))\n\
    \                                                                            \
    \            if closest_integer == value:\n                                  \
    \                                                          closest_integer = Int64(math.round(value))\n\
    \                                                                            \
    \                if closest_integer == value:\n                              \
    \                                                                  closest_integer\
    \ = Int64(math.trunc(value))\n                                               \
    \                                                 if closest_integer == value:\n\
    \                                                                            \
    \                        closest_integer = Int64(math.floor(value))\n        \
    \                                                                            \
    \                if closest_integer == value:\n                              \
    \                                                                          closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \                                                        if closest_integer ==\
    \ value:\n                                                                   \
    \                                         closest_integer = Int64(math.round(value))\n\
    \                                                                            \
    \                                if closest_integer == value:\n              \
    \                                                                            \
    \                      closest_integer = Int64(math.trunc(value))\n          \
    \                                                                            \
    \                          if closest_integer \nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp90ud0za5.jl:22\nin expression starting at\
    \ /tmp/tmp90ud0za5.jl:22\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"-inf\" or value == \"\
    inf\" or value == \"nan\" \n        then return value\n    elseif value == \"\
    0\" \n        then return 0\n    elseif value == \"1\" \n        then return 1\n\
    \    elseif value == \"2\" \n        then return 2\n    elseif value == \"3\"\
    \ \n        then return 3\n    elseif value == \"4\" \n        then return 4\n\
    \    elseif value == \"5\" \n        then return 5\n    elseif value == \"6\"\
    \ \n        then return 6\n    elseif value == \"7\" \n        then return 7\n\
    \    elseif value == \"8\" \n        then return 8\n    elseif value == \"9\"\
    \ \n        then return 9\n    elseif value == \"10\" \n        then return 10\n\
    \    elseif value == \"11\" \n        then return 11\n    elseif value == \"12\"\
    \ \n        then return 12\n    elseif value == \"13\" \n        then return 13\n\
    \    elseif value == \"14\" \n        then return 14\n    elseif value == \"15\"\
    \ \n        then return 15\n    elseif value == \"16\" \n        then return 16\n\
    \    elseif value == \"17\" \n        then return 17\n    elseif value == \"18\"\
    \ \n        then return 18\n    elseif value == \"19\" \n        then return 19\n\
    \    elseif value == \"20\" \n        then return 20\n    elseif value == \"21\"\
    \ \n        then return 21\n    elseif value == \"22\" \n        then return 22\n\
    \    elseif value == \"23\" \n        then return 23\n    elseif value == \"24\"\
    \ \n        then return 24\n    elseif value == \"25\" \n        then return 25\n\
    \    elseif value == \"26\" \n        then return 26\n    elseif value == \"27\"\
    \ \n        then return 27\n    elseif value == \"28\" \n        then return 28\n\
    \    elseif value == \"29\" \n        then return 29\n    elseif value == \"30\"\
    \ \n        then return 30\n    elseif value == \"31\" \n        then return 31\n\
    \    elseif value == \"32\" \n        then return 32\n    elseif value == \"33\"\
    \ \n        then return 33\n    elseif value == \"34\" \n        then return 34\n\
    \    elseif value == \"35\" \n        then return 35\n    elseif value == \"36\"\
    \ \n        then return 36\n    elseif value == \"37\" \n        then return 37\n\
    \    elseif value == \"38\" \n        then return 38\n    elseif value == \"39\"\
    \ \n        then return 39\n    elseif value == \"40\" \nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"value\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcnos3x3x.jl:21\nin expression starting at /tmp/tmpcnos3x3x.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be an empty string\")\n\
    \    elseif value == \"0\"\n        error(\"value cannot be 0\")\n    elseif value\
    \ == \"-\"\n        error(\"value cannot be a negative number\")\n    elseif value\
    \ == \"+\"\n        error(\"value cannot be a positive number\")\n    elseif value\
    \ == \".\"\n        error(\"value cannot be a decimal number\")\n    else\n  \
    \      local num = tonumber(value)\n        if num == nil\n            error(\"\
    value cannot be converted to a number\")\n        else\n            if num < 0\n\
    \                error(\"value cannot be negative\")\n            elseif num >\
    \ 0\n                error(\"value cannot be positive\")\n            else\n \
    \               if num == Int(num)\n                    error(\"value cannot be\
    \ an integer\")\n                else\n                    if num == Int(num +\
    \ 0.5)\n                        error(\"value cannot be equidistant from two integers\"\
    )\n                    else\n                        local closest = Int(num -\
    \ 0.5)\n                        if closest < 0\n                            error(\"\
    value cannot be equidistant from two integers\")\n                        else\n\
    \                            return closest\n                    end\n       \
    \         end\n            end\n        end\n    end\nend\n</cell>\n<text>\nThe\
    \ function closest_integer takes a string representing a number and returns the\
    \ closest integer to it.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkuzko8vf.jl:56\nin expression starting at\
    \ /tmp/tmpkuzko8vf.jl:56\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        return 0 \n    \n    digits = value.chars\n\
    \    \n    smallest_digit = digits[0]\n    \n    for digit in digits[1..]\n  \
    \      if digit < smallest_digit\n            smallest_digit = digit\n    \n \
    \   smallest_digit_index = digits.indexOf(smallest_digit)\n    \n    if smallest_digit_index\
    \ == 0\n        return 0 \n    \n    closest_integer = digits[smallest_digit_index\
    \ - 1]\n    \n    for digit in digits[smallest_digit_index..]\n        if digit\
    \ < closest_integer\n            closest_integer = digit\n    \n    closest_integer_index\
    \ = digits.indexOf(closest_integer)\n    \n    if closest_integer_index == 0 \n\
    \        return 0 \n    \n    closest_integer = digits[closest_integer_index -\
    \ 1]\n    \n    if closest_integer == 0\n        return 0 \n    \n    if closest_integer\
    \ == smallest_digit\n        return closest_integer_index \n    \n    if closest_integer\
    \ == digits[smallest_digit_index - 1]\n        return closest_integer_index \n\
    \    \n    if closest_integer == digits[closest_integer_index - 1]\n        return\
    \ closest_integer_index \n    \n    if closest_integer == digits[closest_integer_index\
    \ - 2]\n        return closest_integer_index \n    \n    if closest_integer ==\
    \ digits[closest_integer_index - 3]\n        return closest_integer_index \n \
    \   \n    if closest_integer == digits[closest_integer_index - 4]\n        return\
    \ closest_integer_index \n    \n    if closest_integer == digits[closest_integer_index\
    \ - 5]\n        return closest_integer_index \n    \n    if closest_integer ==\
    \ digits[closest_integer_index - 6]\n        return closest_integer_index \n \
    \   \n    if closest_integer == digits[closest_integer_index - 7]\n        return\
    \ closest_integer_index \n    \n    if closest_integer == digits[closest_integer_index\
    \ - 8]\n        return closest_integer_index \n    \n    if closest_integer ==\
    \ digits[closest_integer_index - 9]\n        return closest_integer_index \n \
    \   \n    if closest_integer == digits[closest_integer_index - 10]\n        return\
    \ closest_integer_index \n    \n    if closest_integer == digits[closest_integer_index\
    \ - 11]\n        return closest_integer_index \n    \n    if closest_integer ==\
    \ digits[closest_integer_index - 12]\n        return closest_integer_index \n\
    \    \n    if closest_integer == digits[closest_integer_index - 13]\n        return\
    \ closest_integer_index \n    \n    if closest_integer == digits[closest_integer_index\
    \ - 14]\n        return closest_integer_index \n    \n    if closest_integer ==\
    \ digits[closest_integer_index - 15]\n        return closest_integer_index \n\
    \    \n    if closest_integer == digit\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"]\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpc1_dtat2.jl:26\nin expression starting at /tmp/tmpc1_dtat2.jl:26\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n        if closest_integer\
    \ == value:\n            closest_integer = Int64(math.ceil(value))\n         \
    \   if closest_integer == value:\n                closest_integer = Int64(math.floor(value))\n\
    \                if closest_integer == value:\n                    closest_integer\
    \ = Int64(math.ceil(value))\n                    if closest_integer == value:\n\
    \                        closest_integer = Int64(math.floor(value))\n        \
    \                if closest_integer == value:\n                            closest_integer\
    \ = Int64(math.ceil(value))\n                            if closest_integer ==\
    \ value:\n                                closest_integer = Int64(math.floor(value))\n\
    \                                if closest_integer == value:\n              \
    \                      closest_integer = Int64(math.ceil(value))\n           \
    \                         if closest_integer == value:\n                     \
    \                   closest_integer = Int64(math.floor(value))\n             \
    \                           if closest_integer == value:\n                   \
    \                         closest_integer = Int64(math.ceil(value))\n        \
    \                                    if closest_integer == value:\n          \
    \                                      closest_integer = Int64(math.floor(value))\n\
    \                                                if closest_integer == value:\n\
    \                                                    closest_integer = Int64(math.ceil(value))\n\
    \                                                    if closest_integer == value:\n\
    \                                                        closest_integer = Int64(math.floor(value))\n\
    \                                                        if closest_integer ==\
    \ value:\n                                                            closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \                if closest_integer == value:\n                              \
    \                                      closest_integer = Int64(math.floor(value))\n\
    \                                                                    if closest_integer\
    \ == value:\n                                                                \
    \        closest_integer = Int64(math.ceil(value))\n                         \
    \                                               if closest_integer == value:\n\
    \                                                                            closest_integer\
    \ = Int64(math.floor(value))\n                                               \
    \                             if closest_integer == value:\n                 \
    \                                                               closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \                                if closest_integer == value:\n              \
    \                                                                      closest_integer\
    \ = Int64(math.floor(value))\n                                               \
    \                                     if closest_integer == value:\n         \
    \                                                                            \
    \   closest_integer = Int64(math.ceil(value))\n                              \
    \                                                          if closest_integer\
    \ == value:\n                                                                \
    \                            closest_integer = Int64(math.floor(value))\n    \
    \                                                                            \
    \            if closest_integer == value:\n                                  \
    \                                                              closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \                                                if closest_integer == value:\n\
    \                                                                            \
    \                        closest_integer = Int64(math.floor(value))\n        \
    \                                                                            \
    \                if closest_integer == value:\n                              \
    \                                                                          closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \                                                        if closest_integer ==\
    \ value:\n                                                                   \
    \                                         closest_integer = Int64(math.floor(value))\n\
    \                                                                            \
    \                                if closest_integer == value:\n              \
    \                                                                            \
    \                      closest_integer = Int64(math.ceil(value))\n           \
    \                                                                            \
    \                         if closest_integer == value:\n                     \
    \                                                                            \
    \                   closest_integer = Int64(math.floor(value))\n             \
    \                                                                            \
    \                           if closest_integer \nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzvzedlvl.jl:21\nin expression starting at\
    \ /tmp/tmpzvzedlvl.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.floor(value))\n    if closest_integer ==\
    \ value:\n        closest_integer = Int64(math.ceil(value))\n        if closest_integer\
    \ == value:\n            closest_integer = Int64(math.round(value))\n        \
    \    if closest_integer == value:\n                closest_integer = Int64(math.trunc(value))\n\
    \                if closest_integer == value:\n                    closest_integer\
    \ = Int64(math.floor(value))\n                    if closest_integer == value:\n\
    \                        closest_integer = Int64(math.ceil(value))\n         \
    \               if closest_integer == value:\n                            closest_integer\
    \ = Int64(math.round(value))\n                            if closest_integer ==\
    \ value:\n                                closest_integer = Int64(math.trunc(value))\n\
    \                                if closest_integer == value:\n              \
    \                      closest_integer = Int64(math.floor(value))\n          \
    \                          if closest_integer == value:\n                    \
    \                    closest_integer = Int64(math.ceil(value))\n             \
    \                           if closest_integer == value:\n                   \
    \                         closest_integer = Int64(math.round(value))\n       \
    \                                     if closest_integer == value:\n         \
    \                                       closest_integer = Int64(math.trunc(value))\n\
    \                                                if closest_integer == value:\n\
    \                                                    closest_integer = Int64(math.floor(value))\n\
    \                                                    if closest_integer == value:\n\
    \                                                        closest_integer = Int64(math.ceil(value))\n\
    \                                                        if closest_integer ==\
    \ value:\n                                                            closest_integer\
    \ = Int64(math.round(value))\n                                               \
    \             if closest_integer == value:\n                                 \
    \                               closest_integer = Int64(math.trunc(value))\n \
    \                                                               if closest_integer\
    \ == value:\n                                                                \
    \    closest_integer = Int64(math.floor(value))\n                            \
    \                                        if closest_integer == value:\n      \
    \                                                                  closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \        if closest_integer == value:\n                                      \
    \                      closest_integer = Int64(math.round(value))\n          \
    \                                                  if closest_integer == value:\n\
    \                                                                closest_integer\
    \ = Int64(math.trunc(value))\n                                               \
    \                 if closest_integer == value:\n                             \
    \                                       closest_integer = Int64(math.floor(value))\n\
    \                                                                    if closest_integer\
    \ == value:\n                                                                \
    \        closest_integer = Int64(math.ceil(value))\n                         \
    \                               if closest_integer == value:\n               \
    \                                             closest_integer = Int64(math.round(value))\n\
    \                                                            if closest_integer\
    \ == value:\n                                                                closest_integer\
    \ = Int64(math.trunc(value))\n                                               \
    \                 if closest_integer == value:\n                             \
    \                                       closest_integer = Int64(math.floor(value))\n\
    \                                                                    if closest_integer\
    \ == value:\n                                                                \
    \        closest_integer = Int64(math.ceil(value))\n                         \
    \                               if closest_integer == value:\n               \
    \                                             closest_integer = Int64(math.round(value))\n\
    \                                                            if closest_integer\
    \ == value:\n                                                                closest_integer\
    \ = Int64(math.trunc(value))\n                                               \
    \                 if closest_integer == value:\n                             \
    \                                       closest_integer = Int64(\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqvsb7ci4.jl:21\nin expression starting at\
    \ /tmp/tmpqvsb7ci4.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3o6cy5kj.jl:21\nin expression starting at\
    \ /tmp/tmp3o6cy5kj.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    </cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integer_with_error(value::String)::Int64\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpur0o4_pp.jl:21\nin expression starting at\
    \ /tmp/tmpur0o4_pp.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw7ncs4li.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw7ncs4li.jl:1\n\
    in expression starting at /tmp/tmpw7ncs4li.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    \n    if value == \"0\":\n     \
    \   return Int64(0)\n    \n    if value == \"1\":\n        return Int64(1)\n \
    \   \n    if value == \"2\":\n        return Int64(2)\n    \n    if value == \"\
    3\":\n        return Int64(3)\n    \n    if value == \"4\":\n        return Int64(4)\n\
    \    \n    if value == \"5\":\n        return Int64(5)\n    \n    if value ==\
    \ \"6\":\n        return Int64(6)\n    \n    if value == \"7\":\n        return\
    \ Int64(7)\n    \n    if value == \"8\":\n        return Int64(8)\n    \n    if\
    \ value == \"9\":\n        return Int64(9)\n    \n    if value == \"10\":\n  \
    \      return Int64(10)\n    \n    if value == \"11\":\n        return Int64(11)\n\
    \    \n    if value == \"12\":\n        return Int64(12)\n    \n    if value ==\
    \ \"13\":\n        return Int64(13)\n    \n    if value == \"14\":\n        return\
    \ Int64(14)\n    \n    if value == \"15\":\n        return Int64(15)\n    \n \
    \   if value == \"16\":\n        return Int64(16)\n    \n    if value == \"17\"\
    :\n        return Int64(17)\n    \n    if value == \"18\":\n        return Int64(18)\n\
    \    \n    if value == \"19\":\n        return Int64(19)\n    \n    if value ==\
    \ \"20\":\n        return Int64(20)\n    \n    if value == \"21\":\n        return\
    \ Int64(21)\n    \n    if value == \"22\":\n        return Int64(22)\n    \n \
    \   if value == \"23\":\n        return Int64(23)\n    \n    if value == \"24\"\
    :\n        return Int64(24)\n    \n    if value == \"25\":\n        return Int64(25)\n\
    \    \n    if value == \"26\":\n        return Int64(26)\n    \n    if value ==\
    \ \"27\":\n        return Int64(27)\n    \n    if value == \"28\":\n        return\
    \ Int64(28)\n    \n    if value == \"29\":\n        return Int64(29)\n    \n \
    \   if value == \"30\":\n        return Int64(30)\n    \n    if value == \"31\"\
    :\n        return Int64(31)\n    \n    if value == \"32\":\n        return Int64(32)\n\
    \    \n    if value == \"33\":\n        return Int64(33)\n    \n    if value ==\
    \ \"34\":\n        return Int64(34)\n    \n    if value == \"35\":\n        return\
    \ Int64(35)\n    \n    if value == \"36\":\n        return Int64(36)\n    \n \
    \   if value == \"37\":\n        return Int\nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgmpzzsmy.jl:23\nin expression starting at\
    \ /tmp/tmpgmpzzsmy.jl:23\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"value cannot be empty\")\n   \
    \ end\n    \n    try\n        number = parse(Float64(value))\n    catch e\n  \
    \      error(\"value must be a number\")\n    end\n    \n    if number < 0\n \
    \       error(\"value cannot be negative\")\n    end\n    \n    closest = number\n\
    \    \n    if number == 0\n        error(\"value cannot be 0\")\n    end\n   \
    \ \n    if number == 1\n        error(\"value cannot be 1\")\n    end\n    \n\
    \    if number == 2\n        error(\"value cannot be 2\")\n    end\n    \n   \
    \ if number == 3\n        error(\"value cannot be 3\")\n    end\n    \n    if\
    \ number == 4\n        error(\"value cannot be 4\")\n    end\n    \n    if number\
    \ == 5\n        error(\"value cannot be 5\")\n    end\n    \n    if number ==\
    \ 6\n        error(\"value cannot be 6\")\n    end\n    \n    if number == 7\n\
    \        error(\"value cannot be 7\")\n    end\n    \n    if number == 8\n   \
    \     error(\"value cannot be 8\")\n    end\n    \n    if number == 9\n      \
    \  error(\"value cannot be 9\")\n    end\n    \n    if number == 10\n        error(\"\
    value cannot be 10\")\n    end\n    \n    if number == 11\n        error(\"value\
    \ cannot be 11\")\n    end\n    \n    if number == 12\n        error(\"value cannot\
    \ be 12\")\n    end\n    \n    if number == 13\n        error(\"value cannot be\
    \ 13\")\n    end\n    \n    if number == 14\n        error(\"value cannot be 14\"\
    )\n    end\n    \n    if number == 15\n        error(\"value cannot be 15\")\n\
    \    end\n    \n    if number == 16\n        error(\"value cannot be 16\")\n \
    \   end\n    \n    if number == 17\n        error(\"value cannot be 17\")\n  \
    \  end\n    \n    if number == 18\n        error(\"value cannot be 18\")\n   \
    \ end\n    \n    if number == 19\n        error(\"value cannot be 19\")\n    end\n\
    \    \n    if number == 20\n        error(\"value cannot be 20\")\n    end\n \
    \   \n    if number == 21\n        error(\"value cannot be 21\")\n    end\n  \
    \  \n    if number == 22\n        error(\"value cannot be 22\")\n    end\n   \
    \ \n    if number == 23\n        error(\"value cannot be 23\")\n    end\n    \n\
    \    if number == 24\n        error(\"value cannot be 24\")\n    end\n    \n \
    \   if number == 25\n        error(\"value cannot be 25\")\n    end\n    \n  \
    \  if number == 26\n        error(\"value cannot be 26\")\n    end\n    \n   \
    \ if number == 27\n        error(\"value cannot be 27\")\n    end\n    \n    if\
    \ number == 28\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvvt93ayt.jl:1\nin expression starting at /tmp/tmpvvt93ayt.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = int64(0)\n    \n    for x in string.split(value)\n \
    \       if x != \"\"\n            closest_integer = int64(math.ceil(closest_integer))\n\
    \        end\n    end\n    \n    return closest_integer\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbmvzitjl.jl:29\nin expression starting at\
    \ /tmp/tmpbmvzitjl.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value\
    \ \n        closest_integer = Int64(math.floor(value))\n    end\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\n\"\"\"\n    closest_integers(values::Vector{String})\n\
    \    \n    Create a function that takes a vector of strings representing numbers\n\
    \    and returns the closest integer to each number. If the number is equidistant\n\
    \    from two integers, round it away from zero.\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwdofiihb.jl:25\nin expression starting at\
    \ /tmp/tmpwdofiihb.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    else\n\
    \        local num = tonumber(value)\n        if num == nil\n            error(\"\
    value is not a number\")\n        else\n            if num < 0\n             \
    \   error(\"value cannot be negative\")\n            else\n                if\
    \ num == 0\n                    error(\"value cannot be 0\")\n               \
    \ else\n                    local closest = 0\n                    local closestDiff\
    \ = abs(num - closest)\n                    for i = 1, 10 do\n               \
    \         local diff = abs(num - i)\n                        if diff < closestDiff\
    \ then\n                            closest = i\n                            closestDiff\
    \ = diff\n                        end\n                    end\n             \
    \       return closest\n                end\n            end\n        end\n  \
    \  end\nend\n</cell>\n<text>\nExercise 3\nWrite a function that takes a string\
    \ representing a number and returns the number of characters in it.\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid iteration specification\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpifxch11f.jl:34\nin expression starting at\
    \ /tmp/tmpifxch11f.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"0\" || value == \"-0\"\
    \n        return Int(0)\n    end\n    \n    if value == \"1\" || value == \"-1\"\
    \n        return Int(1)\n    end\n    \n    if value == \"2\" || value == \"-2\"\
    \n        return Int(2)\n    end\n    \n    if value == \"3\" || value == \"-3\"\
    \n        return Int(3)\n    end\n    \n    if value == \"4\" || value == \"-4\"\
    \n        return Int(4)\n    end\n    \n    if value == \"5\" || value == \"-5\"\
    \n        return Int(5)\n    end\n    \n    if value == \"6\" || value == \"-6\"\
    \n        return Int(6)\n    end\n    \n    if value == \"7\" || value == \"-7\"\
    \n        return Int(7)\n    end\n    \n    if value == \"8\" || value == \"-8\"\
    \n        return Int(8)\n    end\n    \n    if value == \"9\" || value == \"-9\"\
    \n        return Int(9)\n    end\n    \n    if value == \"10\"\n        return\
    \ Int(10)\n    end\n    \n    if value == \"11\"\n        return Int(11)\n   \
    \ end\n    \n    if value == \"12\"\n        return Int(12)\n    end\n    \n \
    \   if value == \"13\"\n        return Int(13)\n    end\n    \n    if value ==\
    \ \"14\"\n        return Int(14)\n    end\n    \n    if value == \"15\"\n    \
    \    return Int(15)\n    end\n    \n    if value == \"16\"\n        return Int(16)\n\
    \    end\n    \n    if value == \"17\"\n        return Int(17)\n    end\n    \n\
    \    if value == \"18\"\n        return Int(18)\n    end\n    \n    if value ==\
    \ \"19\"\n        return Int(19)\n    end\n    \n    if value == \"20\"\n    \
    \    return Int(20)\n    end\n    \n    if value == \"21\"\n        return Int(21)\n\
    \    end\n    \n    if value == \"22\"\n        return Int(22)\n    end\n    \n\
    \    if value == \"23\"\n        return Int(23)\n    end\n    \n    if value ==\
    \ \"24\"\n        return Int(24)\n    end\n    \n    if value == \"25\"\n    \
    \    return Int(25)\n    end\n    \n    if value == \"26\"\n        return Int(26)\n\
    \    end\n    \n    if value == \"27\"\n        return Int(27)\n    end\n    \n\
    \    if value == \"28\"\n        return Int(28)\n    end\n    \n    if value ==\
    \ \"29\"\n        return Int(29)\n    end\n    \n    if value == \"30\"\n    \
    \    return Int(30)\n    end\n    \n    if value == \"31\"\n        return Int(31)\n\
    \    end\n    \n    if value == \"32\"\n        return Int(32)\n    end\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpp9kyp6yq.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpp9kyp6yq.jl:1\n\
    in expression starting at /tmp/tmpp9kyp6yq.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"Value cannot be empty\")\n    else\n\
    \        closest_integer(tostring(value))\n    end\nend\n</cell>\n<text>\nExercise\n\
    Write a function that takes a value (string) representing a number\nand returns\
    \ the closest integer to it. If the number is equidistant\n    from two integers,\
    \ round it away from zero.\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjsigrje0.jl:25\nin expression starting at\
    \ /tmp/tmpjsigrje0.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(0)\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpo2zg1h8h.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpo2zg1h8h.jl:1\n\
    in expression starting at /tmp/tmpo2zg1h8h.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8dw21um_.jl:21\nin expression starting at\
    \ /tmp/tmp8dw21um_.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"\"\n        closest_integer\
    \ = Int(0)\n    else\n        closest_integer = Int(value)\n        \n       \
    \ if closest_integer == Int(0)\n            closest_integer = Int(value)\n   \
    \     elseif closest_integer == Int(value)\n            closest_integer = Int(value)\n\
    \        else\n            closest_integer = Int(value)\n            \n      \
    \      if closest_integer == Int(0)\n                closest_integer = Int(value)\n\
    \            elseif closest_integer == Int(value)\n                closest_integer\
    \ = Int(value)\n            else\n                closest_integer = Int(value)\n\
    \                \n                if closest_integer == Int(0)\n            \
    \        closest_integer = Int(value)\n                elseif closest_integer\
    \ == Int(value)\n                    closest_integer = Int(value)\n          \
    \      else\n                    closest_integer = Int(value)\n              \
    \      \n                    if closest_integer == Int(0)\n                  \
    \      closest_integer = Int(value)\n                    elseif closest_integer\
    \ == Int(value)\n                        closest_integer = Int(value)\n      \
    \              else\n                        closest_integer = Int(value)\n  \
    \                      \n                        if closest_integer == Int(0)\n\
    \                            closest_integer = Int(value)\n                  \
    \      elseif closest_integer == Int(value)\n                            closest_integer\
    \ = Int(value)\n                        else\n                            closest_integer\
    \ = Int(value)\n                            \n                            if closest_integer\
    \ == Int(0)\n                                closest_integer = Int(value)\n  \
    \                          elseif closest_integer == Int(value)\n            \
    \                    closest_integer = Int(value)\n                          \
    \  else\n                                closest_integer = Int(value)\n      \
    \                          \n                                if closest_integer\
    \ == Int(0)\n                                    closest_integer = Int(value)\n\
    \                                elseif closest_integer == Int(value)\n      \
    \                              closest_integer = Int(value)\n                \
    \                else\n                                    closest_integer = Int(value)\n\
    \                                    \n                                    if\
    \ closest_integer == Int(0)\n                                        closest_integer\
    \ = Int(value)\n                                    elseif closest_integer ==\
    \ Int(value)\n                                        closest_integer = Int(value)\n\
    \                                    else\n                                  \
    \      closest_integer = Int(value)\n                                        \n\
    \                                        if closest_integer == Int(0)\n      \
    \                                      closest_integer = Int(value)\n        \
    \                                elseif closest_integer == Int(value)\n      \
    \                                      closest_integer = Int(value)\n        \
    \                                else\n                                      \
    \      closest_integer = Int(value)\n                                        \
    \    \n                                            if closest_integer == Int(0)\n\
    \                                                closest_integer = Int(value)\n\
    \                                            elseif closest_integer == Int(value)\n\
    \                                                closest_integer = Int(value)\n\
    \                                            else\n                          \
    \                      closest_integer = Int(value)\n                        \
    \                        \n                                                if\
    \ closest_integer == Int(0)\n                                                \
    \    closest_integer = Int(value)\n                                          \
    \      elseif closest_integer == Int(value)\n                                \
    \                    closest_integer = Int(value)\n                          \
    \                      else\n                                                \
    \    closest_integer = Int(value)\n                                          \
    \          \n                                                    if closest_integer\
    \ == Int(0)\n                                                        closest_integer\
    \ = Int(value)\n                                                    else\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpuoogx25v.jl:103\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpuoogx25v.jl:1\n\
    in expression starting at /tmp/tmpuoogx25v.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    if value == \"-\"\n        return -closest_integer\n    \n    digits\
    \ = split(value, \".\")\n    \n    if digits.length == 1\n        return Int(digits[0])\n\
    \    \n    digits_int = digits[1]\n    \n    if digits_int == \"0\"\n        return\
    \ Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n   \
    \ \n    if digits_int == \"0\"\n        return Int(digits[0])\n    \n    digits_int\
    \ = digits_int[digits_int.length-1]\n    \n    if digits_int == \"0\"\n      \
    \  return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\"\n        return Int(digits[0])\n    \n    digits_int\
    \ = digits_int[digits_int.length-1]\n    \n    if digits_int == \"0\"\n      \
    \  return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\"\n        return Int(digits[0])\n    \n    digits_int\
    \ = digits_int[digits_int.length-1]\n    \n    if digits_int == \"0\"\n      \
    \  return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\"\n        return Int(digits[0])\n    \n    digits_int\
    \ = digits_int[digits_int.length-1]\n    \n    if digits_int == \"0\"\n      \
    \  return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\"\n        return Int(digits[0])\n    \n    digits_int\
    \ = digits_int[digits_int.length-1]\n    \n    if digits_int == \"0\"\n      \
    \  return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\"\n        return Int(digits[0])\n    \n    digits_int\
    \ = digits_int[digits_int.length-1]\n    \n    if digits_int == \"0\"\n      \
    \  return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n    if digits_int == \"0\"\n        return Int(digits[0])\n    \n    digits_int\
    \ = digits_int[digits_int.length-1]\n    \n    if digits_int == \"0\"\n      \
    \  return Int(digits[0])\n    \n    digits_int = digits_int[digits_int.length-1]\n\
    \    \n\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph_9t5_e3.jl:1\nin expression starting at /tmp/tmph_9t5_e3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    closest_integer = Int64(0)\n    \n    if value == \"\"\n       \
    \ return closest_integer\n    \n    digits = value.digits\n    \n    if digits.length\
    \ == 1\n        return Int64(digits[0])\n    \n    closest_digit = Int64(0)\n\
    \    \n    for digit in digits\n        if digit < closest_digit\n           \
    \ closest_digit = digit\n    \n    if closest_digit == 0\n        return Int64(0)\n\
    \    \n    closest_digit = Int64(closest_digit)\n    \n    if digits.length ==\
    \ 2\n        if digits[1] == closest_digit\n            return Int64(digits[0])\n\
    \        else\n            return Int64(digits[1])\n    \n    if digits.length\
    \ == 3\n        if digits[1] == closest_digit\n            if digits[2] == closest_digit\n\
    \                return Int64(digits[0])\n            else\n                return\
    \ Int64(digits[2])\n        else\n            if digits[2] == closest_digit\n\
    \                return Int64(digits[1])\n            else\n                return\
    \ Int64(digits[2])\n    \n    if digits.length == 4\n        if digits[1] == closest_digit\n\
    \            if digits[2] == closest_digit\n                if digits[3] == closest_digit\n\
    \                    return Int64(digits[0])\n                else\n         \
    \           return Int64(digits[3])\n            else\n                if digits[3]\
    \ == closest_digit\n                    return Int64(digits[1])\n            \
    \    else\n                    return Int64(digits[3])\n        else\n       \
    \     if digits[2] == closest_digit\n                if digits[3] == closest_digit\n\
    \                    if digits[4] == closest_digit\n                        return\
    \ Int64(digits[0])\n                    else\n                        return Int64(digits[4])\n\
    \                else\n                    if digits[4] == closest_digit\n   \
    \                     return Int64(digits[1])\n                    else\n    \
    \                    return Int64(digits[4])\n            else\n             \
    \   if digits[3] == closest_digit\n                    if digits[4] == closest_digit\n\
    \                        if digits[5] == closest_digit\n                     \
    \       return Int64(digits[0])\n                        else\n              \
    \              return Int64(digits[5])\n                    else\n           \
    \             if digits[5] == closest_digit\n                            return\
    \ Int64(digits[1])\n                        else\n                           \
    \ return Int64(digits[5])\n                else\n                    if digits[4]\
    \ == closest_digit\n                        if digits[5] == closest_digit\n  \
    \                          if digits[6] == closest_digit\n                   \
    \             return Int64(digits[0])\n                            else\n    \
    \                            return Int64(digits[6])\n                       \
    \ else\n                            if digits[6] == closest_digit\n          \
    \                      return Int64(digits[1])\n                            else\n\
    \                                return Int64(digits[6])\n                   \
    \ else\n                        if digits[5] == closest_digit\n              \
    \              if digits[6] == closest_digit\n                               \
    \ if digits[7] == closest_digit\n                                    return Int64(digits[0])\n\
    \                                else\n                                    return\
    \ Int64(digits[7])\n                            else\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpm9_khurm.jl:49 expected \"\
    end\", got \"else\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpm9_khurm.jl:53\n\
    in expression starting at /tmp/tmpm9_khurm.jl:53\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3o6cy5kj.jl:21\nin expression starting at\
    \ /tmp/tmp3o6cy5kj.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    if value == \"\"\n        error(\"The value cannot be empty\")\n\
    \    elseif value == \"-\"\n        error(\"The value cannot be a negative number\"\
    )\n    elseif value == \"+\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"0\"\n        error(\"The value cannot be zero\")\n  \
    \  elseif value == \"1\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"2\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"3\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"4\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"5\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"6\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"7\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"8\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"9\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"10\"\n        error(\"The value cannot be a positive\
    \ number\")\n    elseif value == \"11\"\n        error(\"The value cannot be a\
    \ positive number\")\n    elseif value == \"12\"\n        error(\"The value cannot\
    \ be a positive number\")\n    elseif value == \"13\"\n        error(\"The value\
    \ cannot be a positive number\")\n    elseif value == \"14\"\n        error(\"\
    The value cannot be a positive number\")\n    elseif value == \"15\"\n       \
    \ error(\"The value cannot be a positive number\")\n    elseif value == \"16\"\
    \n        error(\"The value cannot be a positive number\")\n    elseif value ==\
    \ \"17\"\n        error(\"The value cannot be a positive number\")\n    elseif\
    \ value == \"18\"\n        error(\"The value cannot be a positive number\")\n\
    \    elseif value == \"19\"\n        error(\"The value cannot be a positive number\"\
    )\n    elseif value == \"20\"\n        error(\"The value cannot be a positive\
    \ number\")\n    elseif value == \"21\"\n        error(\"The value cannot be a\
    \ positive number\")\n    elseif value == \"22\"\n        error(\"The value cannot\
    \ be a positive number\")\n    elseif value == \"23\"\n        error(\"The value\
    \ cannot be a positive number\")\n    elseif value == \"24\"\n        error(\"\
    The value cannot be a positive number\")\n    elseif value == \"25\"\n       \
    \ error(\"The value cannot be a positive number\")\n    elseif value == \"26\"\
    \n        error(\"The value cannot be a positive number\")\n    elseif value ==\
    \ \"27\"\n        error(\"The value cannot be a positive number\")\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2s8p0un3.jl:1\nin expression starting at /tmp/tmp2s8p0un3.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n        if closest_integer\
    \ == value:\n            closest_integer = Int64(math.round(value))\n        \
    \    if closest_integer == value:\n                closest_integer = Int64(math.trunc(value))\n\
    \                if closest_integer == value:\n                    closest_integer\
    \ = Int64(math.floor(value))\n                    if closest_integer == value:\n\
    \                        closest_integer = Int64(math.ceil(value))\n         \
    \               if closest_integer == value:\n                            closest_integer\
    \ = Int64(math.floor(value))\n                            if closest_integer ==\
    \ value:\n                                closest_integer = Int64(math.ceil(value))\n\
    \                                if closest_integer == value:\n              \
    \                      closest_integer = Int64(math.floor(value))\n          \
    \                          if closest_integer == value:\n                    \
    \                    closest_integer = Int64(math.ceil(value))\n             \
    \                           if closest_integer == value:\n                   \
    \                         closest_integer = Int64(math.floor(value))\n       \
    \                                     if closest_integer == value:\n         \
    \                                       closest_integer = Int64(math.ceil(value))\n\
    \                                                if closest_integer == value:\n\
    \                                                    closest_integer = Int64(math.floor(value))\n\
    \                                                    if closest_integer == value:\n\
    \                                                        closest_integer = Int64(math.ceil(value))\n\
    \                                                        if closest_integer ==\
    \ value:\n                                                            closest_integer\
    \ = Int64(math.floor(value))\n                                               \
    \                 if closest_integer == value:\n                             \
    \                                       closest_integer = Int64(math.ceil(value))\n\
    \                                                                    if closest_integer\
    \ == value:\n                                                                \
    \        closest_integer = Int64(math.floor(value))\n                        \
    \                                                if closest_integer == value:\n\
    \                                                                            closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \                            if closest_integer == value:\n                  \
    \                                                              closest_integer\
    \ = Int64(math.floor(value))\n                                               \
    \                                 if closest_integer == value:\n             \
    \                                                                       closest_integer\
    \ = Int64(math.ceil(value))\n                                                \
    \                                    if closest_integer == value:\n          \
    \                                                                            \
    \  closest_integer = Int64(math.floor(value))\n                              \
    \                                                          if closest_integer\
    \ == value:\n                                                                \
    \                            closest_integer = Int64(math.ceil(value))\n     \
    \                                                                            \
    \           if closest_integer == value:\n                                   \
    \                                                             closest_integer\
    \ = Int64(math.floor(value))\n                                               \
    \                                                 if closest_integer == value:\n\
    \                                                                            \
    \                        closest_integer = Int64(math.ceil(value))\n         \
    \                                                                            \
    \               if closest_integer == value:\n                               \
    \                                                                         closest_integer\
    \ = Int64(math.floor(value))\n                                               \
    \                                                         if closest_integer ==\
    \ value:\n                                                                   \
    \                                         closest_integer = Int64(math.ceil(value))\n\
    \                                                                            \
    \                                if closest_integer == value:\n              \
    \                                                                            \
    \                      closest_integer = Int64(math.floor(value))\n          \
    \                                                                            \
    \                          if closest_integer == value:\n                    \
    \                                                                            \
    \                    closest_integer = Int64(math.ceil(value))\n             \
    \                                                                            \
    \                           if closest_integer \nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu_400bdn.jl:21\nin expression starting at\
    \ /tmp/tmpu_400bdn.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.3>\n\"\"\"\n    closest_integer(value::Float64)\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxcdq8g78.jl:21\nin expression starting at\
    \ /tmp/tmpxcdq8g78.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"0\" \n        then return 0\n    else if value == \"1\"\
    \ \n        then return 1\n    else if value == \"2\" \n        then return 2\n\
    \    else if value == \"3\" \n        then return 3\n    else if value == \"4\"\
    \ \n        then return 4\n    else if value == \"5\" \n        then return 5\n\
    \    else if value == \"6\" \n        then return 6\n    else if value == \"7\"\
    \ \n        then return 7\n    else if value == \"8\" \n        then return 8\n\
    \    else if value == \"9\" \n        then return 9\n    else if value == \"10\"\
    \ \n        then return 10\n    else if value == \"11\" \n        then return\
    \ 11\n    else if value == \"12\" \n        then return 12\n    else if value\
    \ == \"13\" \n        then return 13\n    else if value == \"14\" \n        then\
    \ return 14\n    else if value == \"15\" \n        then return 15\n    else if\
    \ value == \"16\" \n        then return 16\n    else if value == \"17\" \n   \
    \     then return 17\n    else if value == \"18\" \n        then return 18\n \
    \   else if value == \"19\" \n        then return 19\n    else if value == \"\
    20\" \n        then return 20\n    else if value == \"21\" \n        then return\
    \ 21\n    else if value == \"22\" \n        then return 22\n    else if value\
    \ == \"23\" \n        then return 23\n    else if value == \"24\" \n        then\
    \ return 24\n    else if value == \"25\" \n        then return 25\n    else if\
    \ value == \"26\" \n        then return 26\n    else if value == \"27\" \n   \
    \     then return 27\n    else if value == \"28\" \n        then return 28\n \
    \   else if value == \"29\" \n        then return 29\n    else if value == \"\
    30\" \n        then return 30\n    else if value == \"31\" \n        then return\
    \ 31\n    else if value == \"32\" \n        then return 32\n    else if value\
    \ == \"33\" \n        then return 33\n    else if value == \"34\" \n        then\
    \ return 34\n    else if value == \"35\" \n        then return 35\n    else if\
    \ value == \"36\" \n        then return 36\n    else if value == \"37\" \n   \
    \     then return 37\n    else if value == \"38\" \n        then return 38\n \
    \   else if value == \"39\" \n        then \nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"return\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpcrutpf7z.jl:20\nin expression starting at /tmp/tmpcrutpf7z.jl:20\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    elseif\
    \ value == \"-\"\n        error(\"value cannot be negative\")\n    elseif value\
    \ == \"+\"\n        error(\"value cannot be positive\")\n    elseif value == \"\
    0\"\n        error(\"value cannot be zero\")\n    elseif value == \"1\"\n    \
    \    error(\"value cannot be 1\")\n    elseif value == \"2\"\n        error(\"\
    value cannot be 2\")\n    elseif value == \"3\"\n        error(\"value cannot\
    \ be 3\")\n    elseif value == \"4\"\n        error(\"value cannot be 4\")\n \
    \   elseif value == \"5\"\n        error(\"value cannot be 5\")\n    elseif value\
    \ == \"6\"\n        error(\"value cannot be 6\")\n    elseif value == \"7\"\n\
    \        error(\"value cannot be 7\")\n    elseif value == \"8\"\n        error(\"\
    value cannot be 8\")\n    elseif value == \"9\"\n        error(\"value cannot\
    \ be 9\")\n    elseif value == \"10\"\n        error(\"value cannot be 10\")\n\
    \    elseif value == \"11\"\n        error(\"value cannot be 11\")\n    elseif\
    \ value == \"12\"\n        error(\"value cannot be 12\")\n    elseif value ==\
    \ \"13\"\n        error(\"value cannot be 13\")\n    elseif value == \"14\"\n\
    \        error(\"value cannot be 14\")\n    elseif value == \"15\"\n        error(\"\
    value cannot be 15\")\n    elseif value == \"16\"\n        error(\"value cannot\
    \ be 16\")\n    elseif value == \"17\"\n        error(\"value cannot be 17\")\n\
    \    elseif value == \"18\"\n        error(\"value cannot be 18\")\n    elseif\
    \ value == \"19\"\n        error(\"value cannot be 19\")\n    elseif value ==\
    \ \"20\"\n        error(\"value cannot be 20\")\n    elseif value == \"21\"\n\
    \        error(\"value cannot be 21\")\n    elseif value == \"22\"\n        error(\"\
    value cannot be 22\")\n    elseif value == \"23\"\n        error(\"value cannot\
    \ be 23\")\n    elseif value == \"24\"\n        error(\"value cannot be 24\")\n\
    \    elseif value == \"25\"\n        error(\"value cannot be 25\")\n    elseif\
    \ value == \"26\"\n        error(\"value cannot be 26\")\n    elseif value ==\
    \ \"27\"\n        error(\"value cannot be 27\")\n    elseif value == \"28\"\n\
    \        error(\"value cannot be 28\")\n    elseif value == \"29\"\n        error(\"\
    value cannot be 29\")\n    elseif value == \"30\"\n        error(\"value cannot\
    \ be 30\")\n    elseif value == \"31\"\n        error(\"value cannot be 31\")\n\
    \    elseif value == \"32\"\n        error(\"value cannot be 32\")\n    elseif\
    \ value == \"33\"\n        error(\"value cannot be 33\")\n    elseif value ==\
    \ \"34\"\n        error(\"value cannot be 34\nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbti22utp.jl:100\nin expression starting at\
    \ /tmp/tmpbti22utp.jl:100\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(Int64(value)))\n    if closest_integer\
    \ == Int64(value) \n        closest_integer = Int64(math.floor(Int64(value)))\n\
    \    end\n    return closest_integer\nend\n</cell>\n<code language=julia-1.1>\n\
    \"\"\"\n    closest_integer(value::Float64)\nusing Test\n\n@testset begin\n\n\
    candidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw3bihrwm.jl:25\nin expression starting at\
    \ /tmp/tmpw3bihrwm.jl:25\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = math.ceil(value)\n    if closest_integer == value:\n\
    \        closest_integer = math.floor(value)\n    return closest_integer\nend\n\
    </cell>\n<code language=julia-1.1>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptir2a0g3.jl:21\nin expression starting at\
    \ /tmp/tmptir2a0g3.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"\"\n        error(\"value cannot be empty\")\n    end\n\
    \    \n    number = parse(value) \n    if number == 0\n        error(\"value cannot\
    \ be 0\")\n    end\n    \n    closest = 0\n    \n    for n in 1:length(number)\n\
    \        diff = abs(number[n] - closest)\n        if diff == 0\n            closest\
    \ = number[n]\n        elseif diff > abs(number[n] - closest)\n            closest\
    \ = number[n]\n        end\n    end\n    \n    return closest\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkgbymij6.jl:41\nin expression starting at\
    \ /tmp/tmpkgbymij6.jl:41\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int64(math.ceil(value))\n    if closest_integer == value:\n\
    \        closest_integer = Int64(math.floor(value))\n    return closest_integer\n\
    end\n</cell>\n<code language=julia-1.5>\n# Test the function\n@test closest_integer(\"\
    10\") == 10\n@test closest_integer(\"15.3\") == 15\n@test closest_integer(\"14.5\"\
    ) == 15\n@test closest_integer(\"-14.5\") == -15\n</cell>\n<text>\nThe function\
    \ closest_integer is now ready to use. Let's see how it works on a few examples:\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpel_nnf22.jl:21\nin expression starting at\
    \ /tmp/tmpel_nnf22.jl:21\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw7ncs4li.jl:18\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw7ncs4li.jl:1\n\
    in expression starting at /tmp/tmpw7ncs4li.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    closest_integer = Int(0)\n    \n    if value == \"\"\n        return closest_integer\n\
    \    \n    \n    if value == \"0\"\n        return closest_integer\n    \n   \
    \ \n    if value == \"1\"\n        return closest_integer\n    \n    \n    if\
    \ value == \"2\"\n        return closest_integer\n    \n    \n    if value ==\
    \ \"3\"\n        return closest_integer\n    \n    \n    if value == \"4\"\n \
    \       return closest_integer\n    \n    \n    if value == \"5\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"6\"\n        return closest_integer\n\
    \    \n    \n    if value == \"7\"\n        return closest_integer\n    \n   \
    \ \n    if value == \"8\"\n        return closest_integer\n    \n    \n    if\
    \ value == \"9\"\n        return closest_integer\n    \n    \n    if value ==\
    \ \"10\"\n        return closest_integer\n    \n    \n    if value == \"11\"\n\
    \        return closest_integer\n    \n    \n    if value == \"12\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"13\"\n        return closest_integer\n\
    \    \n    \n    if value == \"14\"\n        return closest_integer\n    \n  \
    \  \n    if value == \"15\"\n        return closest_integer\n    \n    \n    if\
    \ value == \"16\"\n        return closest_integer\n    \n    \n    if value ==\
    \ \"17\"\n        return closest_integer\n    \n    \n    if value == \"18\"\n\
    \        return closest_integer\n    \n    \n    if value == \"19\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"20\"\n        return closest_integer\n\
    \    \n    \n    if value == \"21\"\n        return closest_integer\n    \n  \
    \  \n    if value == \"22\"\n        return closest_integer\n    \n    \n    if\
    \ value == \"23\"\n        return closest_integer\n    \n    \n    if value ==\
    \ \"24\"\n        return closest_integer\n    \n    \n    if value == \"25\"\n\
    \        return closest_integer\n    \n    \n    if value == \"26\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"27\"\n        return closest_integer\n\
    \    \n    \n    if value == \"28\"\n        return closest_integer\n    \n  \
    \  \n    if value == \"29\"\n        return closest_integer\n    \n    \n    if\
    \ value == \"30\"\n        return closest_integer\n    \n    \n    if value ==\
    \ \"31\"\n        return closest_integer\n    \n    \n    if value == \"32\"\n\
    \        return closest_integer\n    \n    \n    if value == \"33\"\n        return\
    \ closest_integer\n    \n    \n    if value == \"34\"\n        return closest_integer\n\
    \    \n    \n    if value == \"35\"\n        return closest_integer\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2b9q9rqn.jl:1\nin expression starting at /tmp/tmp2b9q9rqn.jl:1\n"
  stdout: ''
