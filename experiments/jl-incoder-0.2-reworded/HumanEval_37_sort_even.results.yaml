language: jl
name: HumanEval_37_sort_even
results:
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes a vector l and returns a vector l' such that\n    l' is\
    \ identical to l in the even indicies, while its values at the odd indicies are\
    \ equal\n    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 6, 5, 3]\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5_sh7rvv.jl:16\nin expression starting at\
    \ /tmp/tmp5_sh7rvv.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    l = even .+ odd\n    return l\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpijm4cq9n.jl:17\nin expression starting at\
    \ /tmp/tmpijm4cq9n.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work if there are duplicates in the input vector. For example,\
    \ `sort_even([1, 1, 2])` returns `[1, 1, 2]` instead of `[1, 2]`.\n<|/ c |>\n\
    <| c |>\nI fixed the problem you mentioned\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if there are duplicates in the input vector. For example, `sort_even([1, 1,\
    \ 2])` returns `[1, 1, 2]` instead of `[1, 2]`.\n<|/ c |>\n<| a tags=sorting,julia,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpix077o2r.jl:17\nin expression starting at\
    \ /tmp/tmpix077o2r.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    l = even\n    l .= odd\n    return l\nend\n</cell>\n<code\
    \ language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7codp38j.jl:18\nin expression starting at\
    \ /tmp/tmp7codp38j.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nI like your solution, but I believe it can be improved by using\
    \ [`sortperm`](http://docs.julialang.org/en/stable/stdlib/arrays/#Base.sortperm).\n\
    <|/ c |>\n<| c |>\nI agree that `sortperm` would be a better solution. I've edited\
    \ my answer to include it.\n<|/ c |>\n<| a tags=julia,sorting |>\nHere's a solution\
    \ using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n     \
    \      even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 != 0)]\n\
    \           even.sort()\n           odd.sort()\n           return even .+ odd\n\
    \       end\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2cldsa1l.jl:16\nin expression starting at\
    \ /tmp/tmp2cldsa1l.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work for `sort_even([5, 6, 3, 4])` which should return `[3,\
    \ 6, 5, 4]`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've fixed the\
    \ code now.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkp07ua4_.jl:16\nin expression starting at\
    \ /tmp/tmpkp07ua4_.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2824cnf.jl:17\nin expression starting at\
    \ /tmp/tmpt2824cnf.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't work for `sort_even([5, 6, 3, 4])` which should return `[3, 6, 5, 4]`\n\
    <|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out\n<|/ c |>\n<| a\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8th7zrk_.jl:16\nin expression starting at\
    \ /tmp/tmp8th7zrk_.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfav56a55.jl:16\nin expression starting at\
    \ /tmp/tmpfav56a55.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to\
    \ work. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nI tested it on julia 0.6.2 and it works. I guess it depends on the version\
    \ of julia you are using.\n<|/ c |>\n<| c |>\nI tested it on julia 0.6.2 and it\
    \ works. I guess it depends on the version of julia you are using.\n<|/ c |>\n\
    <| c |>\nI tested it on julia 0.6.2 and it works. I guess it depends on the version\
    \ of julia you are using.\n<|/ c |>\n<| c |>\nI tested it on julia 0.6.2 and it\
    \ works. I guess it depends on the version of julia you are using.\n<|/ c |>\n\
    <| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2hofz99.jl:17\nin expression starting at\
    \ /tmp/tmpt2hofz99.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nI like your solution, but I wonder if there is a way to do this without\
    \ having to use an anonymous function?\n<|/ c |>\n<| c |>\nI added a solution\
    \ without an anonymous function\n<|/ c |>\n<| c |>\nI added a solution without\
    \ an anonymous function\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution without\
    \ an anonymous function:\n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbtl3eapp.jl:16\nin expression starting at\
    \ /tmp/tmpbtl3eapp.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprie9k6c9.jl:17\nin expression starting at\
    \ /tmp/tmprie9k6c9.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0or3z5x7.jl:17\nin expression starting at\
    \ /tmp/tmp0or3z5x7.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI like your\
    \ solution, but I thought I'd add my own because I like recursion.\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4l8qr2dl.jl:17\nin expression starting at\
    \ /tmp/tmp4l8qr2dl.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the input vector.\
    \ For example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]` instead of `[1,\
    \ 2, 3]`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I fixed the code by\
    \ sorting the odd indicies first and then the even indicies.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmps8ayb6v2.jl:17\nin expression starting at\
    \ /tmp/tmps8ayb6v2.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([5,6,3,4])` returns `[3,6,5,4]`\
    \ instead of `[3,6,4,5]`.\n<|/ c |>\n<| c |>\nI tested it and it works for me.\
    \ Are you sure you copied the code correctly? I tested it on Julia 0.6.2\n<|/\
    \ c |>\n<| c |>\nI copied it exactly as you wrote it. I also tested it on Julia\
    \ 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested\
    \ it on Julia 0.6.2\n<|/ c |>\n<| a tags=julia |>\nA simple solution:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf4hvhnis.jl:17\nin expression starting at\
    \ /tmp/tmpf4hvhnis.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work if there are duplicates in the input vector. For example,\
    \ `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/\
    \ c |>\n<| c |>\nI added a version that works with duplicates.\n<|/ c |>\n<| a\
    \ tags=julia |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .== 0)]\n           odd = l[findall(l .!= 0)]\n\
    \           even.sort()\n           odd.sort()\n           return even .+ odd\n\
    \       end\nsort_even (generic function with 1 method)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8dm7iwva.jl:16\nin expression starting at\
    \ /tmp/tmp8dm7iwva.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<text>\nExercise\nWrite a function that takes a vector l and returns\
    \ a vector l' such that\n    l' is identical to l in the even indicies, while\
    \ its values at the odd indicies are equal\n    to the values of the odd indicies\
    \ of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5,\
    \ 6, 3, 4])\n    [4, 6, 5, 3]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp40pvybq0.jl:17\nin expression starting at\
    \ /tmp/tmp40pvybq0.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]` instead\
    \ of `[5, 6, 3, 4]`.\n<|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing\
    \ that out. I've edited my answer to fix it.\n<|/ c |>\n<| a dscore=1 |>\nI came\
    \ up with a solution that is quite similar to what was proposed in the comments,\
    \ but I thought I'd post it here for completeness.\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyy3r_kqm.jl:16\nin expression starting at\
    \ /tmp/tmpyy3r_kqm.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis doesn't work for me. `sort_even([5, 6, 3, 4])` returns `[3, 5, 6, 4]`\
    \ instead of `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.1 and\
    \ it works. What version are you using?\n<|/ c |>\n<| c |>\nI'm using 0.6.1. I\
    \ guess it's an issue with my version of Julia. I'll try it on another machine\
    \ and see if it works.\n<|/ c |>\n<| c |>\nIt works fine for me on 0.6.1 on OS\
    \ X. Perhaps try reinstalling Julia?\n<|/ c |>\n<| c |>\nI reinstalled Julia and\
    \ it still doesn't work. I'm on 0.6.1 on OS X. I'll try it on another machine\
    \ and see if it works.\n<|/ c |>\n<| a tags=julia |>\nI wrote a package called\
    \ Sorting.jl that does exactly this. It sorts even and odd numbers in an array:\n\
    <code>\njulia> using Sorting\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkqd8bfqg.jl:16\nin expression starting at\
    \ /tmp/tmpkqd8bfqg.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   even = sort(even)\n    return even\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp94hsnnym.jl:18\nin expression starting at\
    \ /tmp/tmp94hsnnym.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a dscore=2 |>\nHere's a solution using sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even.sort()\n           odd.sort()\n           return even\
    \ .+ odd\n       end\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf0kc0h1x.jl:16\nin expression starting at\
    \ /tmp/tmpf0kc0h1x.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia |>\n\
    I came up with a solution that is similar to what was proposed in the comments\
    \ above. \n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo2ut0pyw.jl:17\nin expression starting at\
    \ /tmp/tmpo2ut0pyw.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a |>\nI like to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element\
    \ Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a tags=julia,sorting,arrays dscore=3\
    \ |>\n<| c |>\nThis should be the accepted answer. `sortperm` is designed for\
    \ this purpose.\n<|/ c |>\n<| a dscore=3 |>\nI like to use sortperm:\n<code>\n\
    julia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/\
    \ a tags=julia,sorting,arrays |>\n<| a dscore=3 |>\nI like to use sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| a dscore=3 |>\nI like to use sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| a dscore=3 |>\nI like to use sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n\
    <|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays |>\nI like\
    \ to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia,sorting,arrays |>\nI\
    \ like to use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia,sorting,arrays |>\nI\
    \ like to use sortperm:\n<code>\njulia> sortperm\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwj4_8kih.jl:17\nin expression starting at\
    \ /tmp/tmpwj4_8kih.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    sort_even([5, 6, 3, 4])\n</cell>\n<text>\nExercise 2\nWrite a function that takes\
    \ a vector l and returns a vector l' such that\n    l' is identical to l in the\
    \ even indicies, while its values at the odd indicies are equal\n    to the values\
    \ of the odd indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1,\
    \ 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgvih8x3j.jl:16\nin expression starting at\
    \ /tmp/tmpgvih8x3j.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=julia,sorting,arrays |>\nThis can be done using sortperm:\n<code>\n\
    julia> sortperm(1:10)\n10-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n\
    \ 9\n10\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp80zkgg0t.jl:17\nin expression starting at\
    \ /tmp/tmp80zkgg0t.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    l = copy(even)\n    l[findall(l .== even)]\
    \ = odd\n    l\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\nThis can\
    \ be done with a single line of code using sortperm:\n<code>\njulia> sortperm([1,2,3])\n\
    3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia\
    \ |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n   \
    \        even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 .==\
    \ 1)]\n           even = sort(even)\n           odd = sort(odd)\n           l\
    \ = copy(even)\n           l[findall(l .== even)] = odd\n           l\n      \
    \ end\nsort_even (generic function with 1 method)\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8y_1ftxu.jl:18\nin expression starting at\
    \ /tmp/tmp8y_1ftxu.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpral_knq3.jl:16\nin expression starting at\
    \ /tmp/tmpral_knq3.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp16kxwgt_.jl:17\nin expression starting at\
    \ /tmp/tmp16kxwgt_.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=2 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpthkbxree.jl:17\nin expression starting at\
    \ /tmp/tmpthkbxree.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</cell>\n<code language=julia-1.3>\n\
    sort_even([5, 6, 3, 4])\n</cell>\n<text>\nExercise: Write a function that takes\
    \ a vector l and returns a vector l' such that\n    l' is identical to l in the\
    \ even indicies, while its values at the odd indicies are equal\n    to the values\
    \ of the odd indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1,\
    \ 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf0uhpuiy.jl:14\nin expression starting at\
    \ /tmp/tmpf0uhpuiy.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`, not `[2,1,3]`.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks\
    \ for pointing it out. Now it works as intended.\n<|/ c |>\n<| a dscore=2 |>\n\
    I believe this can be done in O(n) time using two pointers, one to iterate over\
    \ the even numbers and one to iterate over the odd numbers. \n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp32jxyyt1.jl:17\nin expression starting at\
    \ /tmp/tmp32jxyyt1.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7c0vqyza.jl:17\nin expression starting at\
    \ /tmp/tmp7c0vqyza.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=0 |>\nThe answer by is correct and should be accepted but since\
    \ I wanted to add some explanation I thought I'd add my own.\nThe reason why Julia\
    \ is so slow is because of the way it handles vectors. Vectors are stored as pointers\
    \ to their elements. When you do l[findall(l .% 2 == 0)] you get a vector of pointers\
    \ to all the even numbers in l. Now when you do even.sort() you sort the pointers\
    \ in even, not the numbers in l. \nTo fix this you need to do even.sort() on the\
    \ numbers in l instead. \n<code>\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpedod_qoa.jl:16\nin expression starting at\
    \ /tmp/tmpedod_qoa.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the input vector.\
    \ For example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]` instead of `[1,\
    \ 2, 3]`.\n<|/ c |>\n<| c |>\nYes, it does. I edited my answer to include a version\
    \ that does that.\n<|/ c |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the input vector. For example, `sort_even([1, 1, 2, 3])` returns `[1, 1,\
    \ 2, 3]` instead of `[1, 2, 3]`.\n<|/ c |>\n<| c |>\nYes, it does. I edited my\
    \ answer to include a version that does that.\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ |>\nThis should work:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj352vs6f.jl:16\nin expression starting at\
    \ /tmp/tmpj352vs6f.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nI came up with a solution using Julia arrays:\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpre8woupz.jl:17\nin expression starting at\
    \ /tmp/tmpre8woupz.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nYes, it does. `sort`\
    \ will sort `l` by `Int64`\n<|/ c |>\n<| c |>\nI guess you meant `sort` instead\
    \ of `sort!`\n<|/ c |>\n<| c |>\nYes, I meant `sort` instead of `sort!`\n<|/ c\
    \ |>\n<| a tags=julia,sorting |>\nI like using sort! for this.\n<code>\njulia>\
    \ sort!([1,4,2,5,3,6,7,8,9])\n1-element Array{Int64,1}:\n 9\n 8\n 7\n 6\n 5\n\
    \ 4\n 3\n 2\n 1\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if `l`\
    \ is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n\
    <| a dscore=4 |>\nFor a general case where you want to sort an array by some criteria,\
    \ you can use the sort! function and pass a custom comparison function to the\
    \ key argument:\n<code>\njulia> sort!([1,4,2,5,3,6,7,8,9], by=x->x%2)\n1-element\
    \ Array{Int64,1}:\n 9\n 8\n 7\n 6\n 5\n 4\n 3\n 2\n 1\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| a\
    \ dscore=4 |>\nI like using sort! for this.\n<code>\njulia> sort!([1,4,2,5,3,6,7,8,9])\n\
    1-element Array{Int64,1}:\n 9\n 8\n \nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp8b5to3d.jl:17\nin expression starting at\
    \ /tmp/tmpp8b5to3d.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp60r1mc3.jl:16\nin expression starting at\
    \ /tmp/tmpp60r1mc3.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=julia |>\nI came up with a solution using\
    \ sortperm:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t\
    @test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7ak8h4qr.jl:17\nin expression starting at\
    \ /tmp/tmp7ak8h4qr.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=julia,sorting |>\nI like using sortperm:\n<code>\njulia> sortperm([1,2,3])\n\
    3-element Array{Int64,1}:\n 3\n 1\n 2\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzzpot0ss.jl:17\nin expression starting at\
    \ /tmp/tmpzzpot0ss.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5,\
    \ 4]`, but `sort_even([5, 6, 3, 2])` returns `[3, 6, 5, 2]`.\n<|/ c |>\n<| c |>\n\
    Yes, I noticed that and fixed it. I was thinking about it too much. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_4ofct9j.jl:16\nin expression starting at\
    \ /tmp/tmp_4ofct9j.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    l = copy(even)\n    l[findall(l .% 2\
    \ == 0)] = odd\n    l[findall(l .% 2 != 0)] = even\n    return l\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis does not work if `l` is an `Int64` array. `sort` returns\
    \ a `Vector{Int64}`, not a `Vector{Int}`.\n<|/ c |>\n<| a dscore=2 |>\nThe accepted\
    \ answer does not work for me. Here is a version that does:\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvz_7c75t.jl:19\nin expression starting at\
    \ /tmp/tmpvz_7c75t.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=sorting,julia |>\nI wrote a package for sorting arrays\
    \ of arbitrary dimensions, including sorting by multiple dimensions.\nhttps://github.com/jrfonseca/MultiDimensionalArrays.jl\n\
    <code>\nusing MultiDimensionalArrays\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp28471u0.jl:16\nin expression starting at\
    \ /tmp/tmpp28471u0.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work if `l` is an `Int64` array. `sort` will sort `Int64` arrays lexicographically,\
    \ which is not what OP wants.\n<|/ c |>\n<| c |>\nI believe this answer was written\
    \ before `sort` was added to Julia. `sort` was added after this answer was written.\n\
    <|/ c |>\n<| c |>\nI believe this answer was written before `sort` was added to\
    \ Julia. `sort` was added after this answer was written.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nThe answer by is correct, but I thought I'd add some explanation as to why\
    \ it works.\nThe function sort_even is defined as:\n<code>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpy92rvq84.jl:17\nin expression starting at\
    \ /tmp/tmpy92rvq84.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    even = sort(even)\n\
    \    return even\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdx58snj5.jl:18\nin expression starting at\
    \ /tmp/tmpdx58snj5.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nI like the idea of using an anonymous function, but I get the following\
    \ error when I try to use it: ```ERROR: LoadError: MethodError: no method matching\
    \ sort_even()```\n<|/ c |>\n<| c |>\nI edited my answer to include a working example\
    \ and to fix the error you were getting.\n<|/ c |>\n<| a dscore=2 |>\nThe easiest\
    \ way is to use sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| a tags=julia,sorting,arrays\
    \ |>\nYou can use the function sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,sorting,arrays |>\nI like to use sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,sorting,arrays |>\nI like to use sortperm:\n<code>\njulia> sortperm([5,4,3,2,1])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=julia,sorting,arrays |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n\
    \ 3\n 4\n 5\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,sorting,arrays |>\n\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp08wp9d43.jl:17\nin expression starting at\
    \ /tmp/tmp08wp9d43.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjftab2nn.jl:16\nin expression starting at\
    \ /tmp/tmpjftab2nn.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2824cnf.jl:17\nin expression starting at\
    \ /tmp/tmpt2824cnf.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a dscore=2 |>\nThe easiest way is to use sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 2\n 1\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\nThe other answers are\
    \ good, but I thought I'd add my own, since I find it more readable and more efficient.\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 2\n 1\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=julia,sorting |>\nI like to use sortperm:\n<code>\n\
    julia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 2\n 1\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw2eyz0um.jl:16\nin expression starting at\
    \ /tmp/tmpw2eyz0um.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't seem to work if there are duplicates in the array.\
    \ For example, `sort_even([5, 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]`.\n<|/ c\
    \ |>\n<| c |>\nI see what you mean. I've edited my answer to fix the problem.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if there are duplicates in the array.\
    \ For example, `sort_even([5, 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]`.\n<|/ c\
    \ |>\n<| c |>\nI see what you mean. I've edited my answer to fix the problem.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyugmfnb9.jl:16\nin expression starting at\
    \ /tmp/tmpyugmfnb9.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpki_j7w55.jl:16\nin expression starting at\
    \ /tmp/tmpki_j7w55.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp62s4mca6.jl:17\nin expression starting at\
    \ /tmp/tmp62s4mca6.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=0 |>\nI came up with a solution that is quite simple, although\
    \ it does require a little bit of extra memory (it uses two vectors). \n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmzk4a9qa.jl:17\nin expression starting at\
    \ /tmp/tmpmzk4a9qa.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a tags=julia |>\nThe answer by is great and works well for small vectors. However,\
    \ for large vectors, it becomes very slow and memory intensive. \nHere is a solution\
    \ using sortperm:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsfhzyp07.jl:16\nin expression starting at\
    \ /tmp/tmpsfhzyp07.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return union(even, odd)\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqjumwj6t.jl:16\nin expression starting at\
    \ /tmp/tmpqjumwj6t.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}` because `sort`\
    \ sorts in-place.\n<|/ c |>\n<| c |>\nYes, you are right. I was thinking about\
    \ `sort!` but didn't want to change my answer too much. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdsr7h041.jl:16\nin expression starting at\
    \ /tmp/tmpdsr7h041.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7c0vqyza.jl:17\nin expression starting at\
    \ /tmp/tmp7c0vqyza.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr_yy2zbc.jl:17\nin expression starting at\
    \ /tmp/tmpr_yy2zbc.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if there are duplicate elements in the array. For example, `sort_even([1,1,2,3])`\
    \ returns `[1,1,2,3]`.\n<|/ c |>\n<| c |>\nI edited the answer to include a version\
    \ that works with duplicate elements.\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpftlyf_89.jl:17\nin expression starting at\
    \ /tmp/tmpftlyf_89.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr3evogpa.jl:17\nin expression starting at\
    \ /tmp/tmpr3evogpa.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`.\n<|/ c |>\n<|\
    \ c |>\nI added a version that works for `Array{Int64,1}`\n<|/ c |>\n<| c |>\n\
    This doesn't work for `l = [1, 4, 2, 3]`\n<|/ c |>\n<| c |>\nIt works for me.\
    \ `l = [1, 4, 2, 3]; sort_even(l); l` gives `[1, 2, 3, 4]`.\n<|/ c |>\n<| c |>\n\
    I added a version that works for `Array{Int64,1}`\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nI came up with this solution:\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmposegyvye.jl:17\nin expression starting at\
    \ /tmp/tmposegyvye.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work if there are duplicate elements in the input vector.\
    \ For example, `sort_even([1, 1, 2])` returns `[1, 1, 2]` instead of `[1, 2, 1]`.\n\
    <|/ c |>\n<| c |>\nI see your point, but I believe this can be solved by sorting\
    \ on the even indicies first, then on the odd indicies and finally concatenating\
    \ the two lists.\n<|/ c |>\n<| c |>\nYes, but that would require a lot of extra\
    \ memory and would not scale well for large vectors.\n<|/ c |>\n<| c |>\nYes,\
    \ I agree. My solution was meant as a quick fix for small vectors. I believe that\
    \ for large vectors, a more efficient solution would be needed.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nI believe that this is what you are looking for:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9mt8rkdh.jl:17\nin expression starting at\
    \ /tmp/tmp9mt8rkdh.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c\
    \ |>\nI tested it on `Array{Int64,1}` and it worked fine.\n<|/ c |>\n<| c |>\n\
    I tested it on `Array{Int64,1}` and it worked fine.\n<|/ c |>\n<| c |>\nI tested\
    \ it on `Array{Int64,1}` and it worked fine.\n<|/ c |>\n<| c |>\nI tested it on\
    \ `Array{Int64,1}` and it worked fine.\n<|/ c |>\n<| a dscore=3 |>\nI believe\
    \ that this is what you are looking for:\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ != 0)]\n           even.sort()\n           odd.sort()\n           even.extend(odd)\n\
    \           return even\n       end\nsort_even (generic function with 1 method)\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphrxfe_uq.jl:17\nin expression starting at\
    \ /tmp/tmphrxfe_uq.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=julia |>\nHere's a solution using sortperm:\n<code>\njulia> function\
    \ sort_even(l::Vector{Int64})::Vector{Int64}\n           even = l[findall(l .==\
    \ 0)]\n           odd = l[findall(l .!= 0)]\n           even.sort()\n        \
    \   odd.sort()\n           even.extend(odd)\n           return even\n       end\n\
    sort_even (generic function with 1 method)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgzmvjyyl.jl:17\nin expression starting at\
    \ /tmp/tmpgzmvjyyl.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    even = even[findall(even .!= 0)]\n    odd = odd[findall(odd\
    \ .!= 0)]\n    even = union(even, odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa_9aiwmo.jl:19\nin expression starting at\
    \ /tmp/tmpa_9aiwmo.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7c0vqyza.jl:17\nin expression starting at\
    \ /tmp/tmp7c0vqyza.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpojbf3lda.jl:16\nin expression starting at\
    \ /tmp/tmpojbf3lda.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting,arrays |>\n<| c |>\nThis doesn't work for me.\
    \ `sort_even([5,6,3,4])` returns `[3,4,5,6]` instead of `[3,6,5,4]`.\n<|/ c |>\n\
    <| c |>\nIt works for me on Julia 0.6.2. I think it might be a bug in 0.6.1, which\
    \ I tested on 0.6.2 as well. I'll try to reproduce this on 0.6.2.\n<|/ c |>\n\
    <| c |>\nI tested on 0.6.2 as well. I'm on 0.6.1 as well. I'll try to reproduce\
    \ this on 0.6.2.\n<|/ c |>\n<| c |>\nI tested on 0.6.2 as well. I'm on 0.6.1 as\
    \ well. I'll try to reproduce this on 0.6.2.\n<|/ c |>\n<| c |>\nI tested on 0.6.2\
    \ as well. I'm on 0.6.1 as well. I'll try to reproduce this on 0.6.2.\n<|/ c |>\n\
    <| a tags=julia,sorting,arrays |>\nThe answer by is correct, but I thought I'd\
    \ add an explanation as to why it works.\nThe reason why it works is because Julia\
    \ is smart enough to realize that your function sort_even is pure, and therefore\
    \ it can safely be inlined into your code. \nThe reason why it works is because\
    \ Julia is smart enough to realize that your function sort_even is pure, and therefore\
    \ it can safely be inlined into your code. \nThe reason why it works is because\
    \ Julia is smart enough to realize that your function sort_even is pure, and therefore\
    \ it can safely be inlined into your code. \nThe reason why it works is because\
    \ Julia is smart enough to realize that your function sort_even is pure, and therefore\
    \ it can safely be inlined into your code. \nThe reason why it works is because\
    \ Julia is smart enough to realize that your function sort_even is pure, and therefore\
    \ it can safely be inlined into your code. \nThe reason why it works is because\
    \ Julia is smart enough to realize that your function sort_even is pure, and therefore\
    \ it can saf\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiboy0him.jl:17\nin expression starting at\
    \ /tmp/tmpiboy0him.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis doesn't work if there are repeated elements in the input vector. For\
    \ example, `sort_even([1, 1, 2, 3])` returns `[1, 1, 2, 3]`.\n<|/ c |>\n<| c |>\n\
    I see what you mean. Thanks for pointing that out. I edited my answer to account\
    \ for that case.\n<|/ c |>\n<| a tags=sorting,julia |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp21krnzn7.jl:16\nin expression starting at\
    \ /tmp/tmp21krnzn7.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't seem to work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<|\
    \ a |>\nI like to use sortperms to get an ordered permutation of an array:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphnbnm1gu.jl:17\nin expression starting at\
    \ /tmp/tmphnbnm1gu.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't seem\
    \ to work. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c\
    \ |>\n<| c |>\nAh, I see what you're saying. I think I misunderstood the question.\
    \ I'll edit my answer.\n<|/ c |>\n<| c |>\nI edited my answer to include a solution\
    \ that should work. Let me know if it doesn't.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nAh, I see what you're saying. I think I misunderstood the question. I'll\
    \ edit my answer.\n<|/ c |>\n<| a dscore=1 |>\nThis should work:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp500bjajh.jl:17\nin expression starting at\
    \ /tmp/tmp500bjajh.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[5,\
    \ 6, 3, 4]` instead of `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works fine for me. Are you sure you copied the code correctly? It works for\
    \ me on Julia 0.6.2\n<|/ c |>\n<| c |>\nI copied it exactly as you wrote it. I\
    \ also tested it on 0.6.2 and it still doesn't work. I'm running 0.6.2 on OS X\
    \ 10.10.5\n<|/ c |>\n<| c |>\nI tested it on 0.6.2 on OS X 10.10.5 and it works\
    \ fine. Are you sure you copied the code correctly? It works for me on Julia 0.6.2\n\
    <|/ c |>\n<| c |>\nI copied it exactly as you wrote it. I also tested it on 0.6.2\
    \ and it still doesn't work. I'm running 0.6.2 on OS X 10.10.5\n<|/ c |>\n<| a\
    \ tags=julia,sorting,arrays |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpupn199z5.jl:16\nin expression starting at\
    \ /tmp/tmpupn199z5.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    sort_even([5, 6, 3, 4])\n</cell>\n<text>\nExercise: Write a function that takes\
    \ a vector l and returns a vector l' such that\n    l' is identical to l in the\
    \ even indicies, while its values at the odd indicies are equal\n    to the values\
    \ of the odd indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1,\
    \ 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [5, 6, 3, 4]\n    \"\"\"\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwhmwghlg.jl:16\nin expression starting at\
    \ /tmp/tmpwhmwghlg.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7c0vqyza.jl:17\nin expression starting at\
    \ /tmp/tmp7c0vqyza.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph3etans0.jl:16\nin expression starting at\
    \ /tmp/tmph3etans0.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8if7lwgj.jl:16\nin expression starting at\
    \ /tmp/tmp8if7lwgj.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj_p0ox1b.jl:16\nin expression starting at\
    \ /tmp/tmpj_p0ox1b.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<text>\nExercise 3\nWrite\
    \ a function that takes a vector l and returns a vector l' such that\n    l' is\
    \ identical to l in the even indicies, while its values at the odd indicies are\
    \ equal\n    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 5, 6, 3]\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpub9ukqw0.jl:16\nin expression starting at\
    \ /tmp/tmpub9ukqw0.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcpwvr615.jl:16\nin expression starting at\
    \ /tmp/tmpcpwvr615.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\nI like using mapslices for this:\n<code>\njulia> mapslices(sort,[1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a tags=julia,sorting |>\n<|\
    \ a dscore=2 |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a tags=julia,sorting |>\n<|\
    \ a tags=julia,sorting |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a tags=julia,sorting |>\n<|\
    \ a tags=julia,sorting |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a dscore=1 |>\n<| a tags=julia,sorting\
    \ |>\nI like using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n\
    3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI like\
    \ using sortslices for this:\n<code>\njulia> sortslices([1,2,3],dims=2)\n3-element\
    \ Vector{Int64}:\n 2\n 1\n 3\n</code>\n<|/ a tags=julia,sorting dscore=1 |>\n\
    <| a tags=julia,sorting |>\nI like using sortslices for this:\n<code>\njulia>\
    \ sortslices([1,2,3],dims=2)\n3-element Vector{Int64}:\n 2\n 1\n 3\n</code>\n\
    <|/ a dscore=1 \nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2_1_2utj.jl:16\nin expression starting at\
    \ /tmp/tmp2_1_2utj.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkp2so21c.jl:16\nin expression starting at\
    \ /tmp/tmpkp2so21c.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if there are duplicate\
    \ elements in the input vector. For example, `sort_even([1, 1, 2, 3])` returns\
    \ `[1, 1, 2, 3]` instead of `[1, 2, 3]`.\n<|/ c |>\n<| c |>\nYes, I realized that\
    \ after I wrote my answer. I've added a version that doesn't have that problem.\n\
    <|/ c |>\n<| c |>\nI added a version that doesn't have that problem and also a\
    \ version that doesn't have that problem but is faster.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\nI wrote a version that doesn't have that problem but is faster:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp59dcpsjs.jl:16\nin expression starting at\
    \ /tmp/tmp59dcpsjs.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere's a solution\
    \ using sortperm:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9baxfdpr.jl:17\nin expression starting at\
    \ /tmp/tmp9baxfdpr.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` returns a\
    \ `Vector{Int64}`, so `even = sort(l)` will fail.\n<|/ c |>\n<| c |>\nI fixed\
    \ the code so it works with `Int64` arrays. Thanks for pointing that out.\n<|/\
    \ c |>\n<| a tags=julia,sorting |>\nHere's a solution using sortperm:\n<code>\n\
    julia> function sort_even(l::Vector{Int64})\n           even = l[findall(l .==\
    \ 0)]\n           odd = l[findall(l .!= 0)]\n           even.sort()\n        \
    \   odd.sort()\n           even.extend(odd)\n           return even\n       end\n\
    sort_even (generic function with 1 method)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp94prxbeg.jl:17\nin expression starting at\
    \ /tmp/tmp94prxbeg.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2824cnf.jl:17\nin expression starting at\
    \ /tmp/tmpt2824cnf.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a tags=julia,sorting,arrays |>\nThe answer by is correct but can be simplified\
    \ a bit:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_21xx2n1.jl:17\nin expression starting at\
    \ /tmp/tmp_21xx2n1.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ c |>\nThis does not answer the question. The question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\n<|/ c |>\n\
    <| c |>\nThe question was how to sort a vector in Julia by even and odd indices.\
    \ Your answer does not do that.\n<|/ c |>\n<| c |>\nThe question was how to sort\
    \ a vector in Julia by even and odd indices. Your answer does not do that.\n<|/\
    \ c |>\n<| c |>\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\n<|/ c |>\n<| a tags=julia |>\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by even and odd indices. Your answer does not do that.\nThe question\
    \ was how to sort a vector in Julia by even and odd indices. Your answer does\
    \ not do that.\nThe question was how to sort a vector in Julia by even and odd\
    \ indices. Your answer does not do that.\nThe question was how to sort a vector\
    \ in Julia by \nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxw8spzmv.jl:16\nin expression starting at\
    \ /tmp/tmpxw8spzmv.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=0 |>\nThis can be done with sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 2\n 1\n 4\n 5\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe0fmoh3p.jl:17\nin expression starting at\
    \ /tmp/tmpe0fmoh3p.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa1ow_n8h.jl:16\nin expression starting at\
    \ /tmp/tmpa1ow_n8h.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| c |>\nI like your solution, but I believe\
    \ that `sort` should be used instead of `sort_even`.\n<|/ c |>\n<| c |>\nI agree,\
    \ `sort` would be more efficient.\n<|/ c |>\n<| c |>\nI agree, `sort` would be\
    \ more efficient.\n<|/ c |>\n<| c |>\nI agree, `sort` would be more efficient.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is a solution using sort:\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvf5oget9.jl:17\nin expression starting at\
    \ /tmp/tmpvf5oget9.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphgqars1y.jl:16\nin expression starting at\
    \ /tmp/tmphgqars1y.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}` because `sort`\
    \ returns a `Vector{Int64}`.\n<|/ c |>\n<| c |>\nYes, I noticed that and edited\
    \ my answer to include a version that works with `Array{Int64,1}`\n<|/ c |>\n\
    <| a tags=julia,sorting |>\nThe answer by is correct but can be simplified a bit:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprfx4mc7_.jl:17\nin expression starting at\
    \ /tmp/tmprfx4mc7_.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=julia,sorting,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv60rv1_z.jl:17\nin expression starting at\
    \ /tmp/tmpv60rv1_z.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\nI came up with this:\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxjt5kp8g.jl:16\nin expression starting at\
    \ /tmp/tmpxjt5kp8g.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpckrk0xwy.jl:16\nin expression starting at\
    \ /tmp/tmpckrk0xwy.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplkwc1w0s.jl:16\nin expression starting at\
    \ /tmp/tmplkwc1w0s.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    l = even\n    l .= odd\n    return l\nend\n</code>\n<|/ a\
    \ tags=julia,sorting |>\n<| c |>\nThis does not work for me. `sort_even([5, 6,\
    \ 3, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nIt does work for me. Are\
    \ you sure you copied it correctly? It works for me on Julia 0.6.2\n<|/ c |>\n\
    <| c |>\nYes, I copied it correctly. I just tried it again and it works. I must\
    \ have done something wrong the first time I tried it. Thanks!\n<|/ c |>\n<| c\
    \ |>\nI added a version that works on Julia 0.6.2\n<|/ c |>\n<| a dscore=2 |>\n\
    A simple and efficient solution is to use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 2\n 1\n 4\n</code>\n<|/ a tags=julia,sorting |>\n\
    <| a dscore=1 |>\nThe answer by is correct, but I wanted to add that you can also\
    \ use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n\
    \ 3\n 2\n 1\n 4\n</code>\n<|/ a tags=julia,sorting |>\n<| a tags=julia,sorting\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8ngycd4i.jl:18\nin expression starting at\
    \ /tmp/tmp8ngycd4i.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x[1] }\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])` returns `[1,2,3]`\
    \ instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work for me either. `sort_even([1,2,3])`\
    \ returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for me either. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for me either. `sort_even([1,2,3])` returns\
    \ `[1,2,3]` instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work for me\
    \ either. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c\
    \ |>\n<| a dscore=5 |>\nThe accepted answer doesn't work for me. sort_even([1,2,3])\
    \ returns [1,2,3] instead of [1,2,3].\nHere's a version that does:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4f5bes51.jl:14\nin expression starting at\
    \ /tmp/tmp4f5bes51.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to\
    \ work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\n\
    I added a version that works with vectors of any length.\n<|/ c |>\n<| c |>\n\
    I added a version that works with vectors of any length.\n<|/ c |>\n<| a tags=julia\
    \ |>\nHere's a version that works with vectors of any length. \n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp65e9wkiw.jl:17\nin expression starting at\
    \ /tmp/tmp65e9wkiw.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpthf87g16.jl:14\nin expression starting at\
    \ /tmp/tmpthf87g16.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=sorting,julia |>\nA simple and efficient solution is to use sortperm:\n\
    <code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n 3\n 1\n 2\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/27812697)\n<|/ c |>\n<| c |>\n\
    The question was \"How to sort a vector in Julia?\" and the answer is \"Use sortperm\"\
    . The question was \"How to sort a vector in Julia?\" and the answer is \"Use\
    \ sortperm\". The question was \"How to sort a vector in Julia?\" and the answer\
    \ is \"Use sortperm\". The question was \"How to sort a vector in Julia?\" and\
    \ the answer is \"Use sortperm\". The question was \"How to sort a vector in Julia?\"\
    \ and the answer is \"Use sortperm\". The question was \"How to sort a vector\
    \ in Julia?\" and the answer is \"Use sortperm\". The question was \"How to sort\
    \ a vector in Julia?\" and the answer is \"Use sortperm\". The question was \"\
    How to sort a vector in Julia?\" and the answer is \"Use sortperm\". The question\
    \ was \"How to sort a vector in Julia?\" and the answer is \"Use sortperm\". The\
    \ question was \"How to sort a vector in Julia?\" and the answer is \"Use sortperm\"\
    . The question was \"How to sort a vector in Julia?\" and the answer is \"Use\
    \ sortperm\". The question was \"How to sort a vector in Julia?\" and the answer\
    \ is \"Use sortperm\". The question was \"How to sort a vector in Julia?\" and\
    \ the answer is \"Use sortperm\". The question was \"How to sort a vector in Julia?\"\
    \ and the answer is \"Use sortperm\". The question was \"How to sort a vector\
    \ in Julia?\" and the answer is \"Use sortperm\". The question was \"How to sort\
    \ a vector in Julia?\" and the answer is \"Use sortperm\"\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_ckk6udh.jl:16\nin expression starting at\
    \ /tmp/tmp_ckk6udh.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a dscore=2 |>\nHere's a solution that doesn't require any packages:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp79hqixc.jl:17\nin expression starting at\
    \ /tmp/tmpp79hqixc.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\n\
    It does work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt does work if\
    \ `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt does work if `l` is an `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nIt does work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| a\
    \ tags=sorting,julia |>\nThe answer by is correct, but I wanted to add that you\
    \ can also use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. `sortperm` is much more efficient than `sort` and also works on `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `sortperm` is much more\
    \ efficient than `sort` and also works on `Array{Int64,1}`\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer. `sortperm` is much more efficient than `sort`\
    \ and also works on `Array{Int64,1}`\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. `sortperm` is much more efficient than `sort` and also works on `Array{Int64,1}`\n\
    <|/ c |>\n<| a dscore=5 |>\nThe answer by is correct, but I wanted to add that\
    \ you can also use sortperm:\n<code>\njulia> sortperm([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 3\n 1\n 2\n</code>\n<|/ a tags=sorting,julia |>\n<| c |>\nThis should be the\
    \ accepted answer. `sortperm` is much more efficient than `sort` and also works\
    \ on `Array{Int64,1}`\n<|/ c |>\n\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprb2nptw_.jl:17\nin expression starting at\
    \ /tmp/tmprb2nptw_.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiotc0cum.jl:16\nin expression starting at\
    \ /tmp/tmpiotc0cum.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work if `l` is an `Int64` array. `sort` sorts the array in\
    \ place, so `even` and `odd` will point to the same array and `even.sort()` will\
    \ sort the same array twice.\n<|/ c |>\n<| c |>\nThanks for the comment. I've\
    \ edited my answer to include a version that works with `Int64` arrays.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nHere's a solution using sort!\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqh_ri11s.jl:16\nin expression starting at\
    \ /tmp/tmpqh_ri11s.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])` returns `[1,2,3]`\
    \ instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works for me on Julia 0.6.2\n<|/\
    \ c |>\n<| c |>\nIt works for me on Julia 0.6.2\n<|/ c |>\n<| c |>\nIt works for\
    \ me on Julia 0.6.2\n<|/ c |>\n<| c |>\nIt works for me on Julia 0.6.2\n<|/ c\
    \ |>\n<| a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnbkm5lin.jl:17\nin expression starting at\
    \ /tmp/tmpnbkm5lin.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort(even)\n\
    \    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6,\
    \ 5, 4]`.\n<|/ c |>\n<| c |>\nI tested it and it works. I must have missed something\
    \ when I first tried it.\n<|/ c |>\n<| c |>\nI tested it again and it works. I\
    \ must have missed something when I first tried it.\n<|/ c |>\n<| c |>\nI tested\
    \ it again and it works. I must have missed something when I first tried it.\n\
    <|/ c |>\n<| a tags=julia,sorting |>\nHere is a solution using sortperm:\n<code>\n\
    julia> function sort_even(l::Vector{Int64})::Vector{Int64}\n           even =\
    \ l[findall(l .== 0)]\n           odd = l[findall(l .== 1)]\n           even =\
    \ sort(even)\n           odd = sort(odd)\n           return even .+ odd\n    \
    \   end\nsort_even (generic function with 1 method)\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnvwtk1km.jl:16\nin expression starting at\
    \ /tmp/tmpnvwtk1km.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's a solution\
    \ that doesn't require any sorting:\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjq0crdym.jl:17\nin expression starting at\
    \ /tmp/tmpjq0crdym.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis doesn't work if there are duplicate elements in the input vector. For\
    \ example, `sort_even([5, 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]`.\n<|/ c |>\n\
    <| c |>\nYes, it does. I didn't realize that OP wanted the even indicies sorted.\n\
    <|/ c |>\n<| c |>\nYes, I didn't realize that OP wanted the even indicies sorted.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a solution using sortperm:\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpq0hc3h60.jl:16\nin expression starting at\
    \ /tmp/tmpq0hc3h60.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr3evogpa.jl:17\nin expression starting at\
    \ /tmp/tmpr3evogpa.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| a tags=julia,sorting |>\nI came up with this solution:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmnvu52fi.jl:16\nin expression starting at\
    \ /tmp/tmpmnvu52fi.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for `sort_even([1,3,5,2,4,6])` which should return\
    \ `[1,2,3,4,5,6]`.\n<|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing\
    \ it out. I've updated the answer.\n<|/ c |>\n<| a |>\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpihazbco0.jl:17\nin expression starting at\
    \ /tmp/tmpihazbco0.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0boiywzs.jl:17\nin expression starting at\
    \ /tmp/tmp0boiywzs.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   even = sort(even)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to avoid the\
    \ copying by using a mutable vector and `push!`ing into it.\n<|/ c |>\n<| c |>\n\
    I haven't thought about that, but I suspect that would require a more complicated\
    \ version of this solution, since you would need to keep track of which indices\
    \ are even and which are odd.\n<|/ c |>\n<| c |>\nI added a solution that avoids\
    \ copying by using a mutable vector and `push!`ing into it.\n<|/ c |>\n<| c |>\n\
    I added a solution that avoids copying by using a mutable vector and `push!`ing\
    \ into it.\n<|/ c |>\n<| a tags=julia,sorting,arrays |>\nHere's a solution using\
    \ sortperm:\n<code>\njulia> function sort_even(l::Vector{Int64})\n           even\
    \ = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2 != 0)]\n      \
    \     even = sort_even(even)\n           odd = sort_even(odd)\n           even\
    \ = union(even, odd)\n           even = sortperm(even)\n           return even\n\
    \       end\nsort_even (generic function with 1 method)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfiw0ydgp.jl:18\nin expression starting at\
    \ /tmp/tmpfiw0ydgp.jl:18\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp60r1mc3.jl:16\nin expression starting at\
    \ /tmp/tmpp60r1mc3.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis does\
    \ not answer the question. `sort_even` does not sort the even indicies of `l`\
    \ but rather sorts the even indicies of `l` itself. This is not what the OP asked\
    \ for.\n<|/ c |>\n<| c |>\nThe question was \"How can I sort a vector in Julia\
    \ such that the even indicies are sorted and the odd indicies are not?\" The answer\
    \ is \"You can't\". The question was \"How can I sort a vector in Julia such that\
    \ the even indicies are sorted and the odd indicies are not?\" The answer is \"\
    You can't\". The question was \"How can I sort a vector in Julia such that the\
    \ even indicies are sorted and the odd indicies are not?\" The answer is \"You\
    \ can't\". The question was \"How can I sort a vector in Julia such that the even\
    \ indicies are sorted and the odd indicies are not?\" The answer is \"You can't\"\
    . The question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\" The answer is \"You can't\". The\
    \ question was \"How can I sort a vector in Julia such that the even indicies\
    \ are sorted and the odd indicies are not?\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpldmeng1c.jl:17\nin expression starting at\
    \ /tmp/tmpldmeng1c.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer.\
    \ Your code works perfectly for me. Could you please explain me the logic behind\
    \ your code? I understand that you are sorting odd numbers and even numbers and\
    \ then concatenating them. But, I am not able to understand how you did that.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI added some comments to the code. Hope it helps.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpclip4jzc.jl:17\nin expression starting at\
    \ /tmp/tmpclip4jzc.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis doesn't work for me. `sort_even([1,2,3])` returns `[1,2,3]` instead\
    \ of `[2,1,3]`.\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| c\
    \ |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 0.6.2\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu8dp2ih0.jl:16\nin expression starting at\
    \ /tmp/tmpu8dp2ih0.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).collect{|x| x}\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a tags=julia,sorting,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw7_lucfz.jl:14\nin expression starting at\
    \ /tmp/tmpw7_lucfz.jl:14\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are duplicates in the input\
    \ vector. For example, `sort_even([5, 6, 3, 6, 5, 4])` returns `[3, 6, 5, 4]`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out. I've edited\
    \ my answer to account for that case.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpetpzmqvy.jl:16\nin expression starting at\
    \ /tmp/tmpetpzmqvy.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't work for `sort_even([5, 6, 3, 4])` which should return `[3, 6, 5, 4]`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've updated the answer to include a more\
    \ general solution.\n<|/ c |>\n<| c |>\nThis doesn't work for `sort_even([5, 6,\
    \ 3, 4])` which should return `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I updated the answer to include a more general solution.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for `sort_even([5, 6, 3, 4])` which should return `[3,\
    \ 6, 5, 4]`.\n<|/ c |>\n<| a |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9bvcs56i.jl:16\nin expression starting at\
    \ /tmp/tmp9bvcs56i.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis does not answer the question. He asked for something that works\
    \ with any type of vector, not just Int64.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ my answer was more of a \"quick and dirty\" solution to his problem. I'll edit\
    \ my answer to include a more general solution.\n<|/ c |>\n<| a dscore=1 |>\n\
    I believe that your problem can be solved using sortperm. \n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyn2ek641.jl:17\nin expression starting at\
    \ /tmp/tmpyn2ek641.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI like your solution, but I wonder why you used `sort` instead\
    \ of `sort!`?\n<|/ c |>\n<| c |>\nI used `sort` because I wanted to preserve the\
    \ original order of the even elements. `sort!` would not do that. `sort!` would\
    \ sort the even elements and leave the odd elements untouched.\n<|/ c |>\n<| c\
    \ |>\nI see. Thanks for clarifying.\n<|/ c |>\n<| a |>\nHere is a solution using\
    \ sort!:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl28ut4gy.jl:16\nin expression starting at\
    \ /tmp/tmpl28ut4gy.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\nThe solutions above are all good, but I wanted to add my own solution,\
    \ which is more efficient and uses less memory than other solutions:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfl10v0h4.jl:16\nin expression starting at\
    \ /tmp/tmpfl10v0h4.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't seem to work if there are duplicate values in the\
    \ original array. For example, `sort_even([1,2,2,3])` returns `[1,2,3]` instead\
    \ of `[1,2,2,3]`.\n<|/ c |>\n<| c |>\nI believe this should work, since `sort`\
    \ sorts in place. `sort!` would not work since it returns a new array.\n<|/ c\
    \ |>\n<| c |>\nI tested this and it does work. `sort!` returns a new array and\
    \ `sort` sorts in place. `sort!` would not work since it returns a new array.\n\
    <|/ c |>\n<| c |>\nI tested this and it does work. `sort!` returns a new array\
    \ and `sort` sorts in place. `sort!` would not work since it returns a new array.\n\
    <|/ c |>\n<| c |>\nI tested this and it does work. `sort!` returns a new array\
    \ and `sort` sorts in place. `sort!` would not work since it returns a new array.\n\
    <|/ c |>\n<| a dscore=3 |>\nThe answer by is correct, but I thought I'd add an\
    \ alternative solution that is more efficient than sorting.\n<code>\njulia> function\
    \ sort_even(l::Vector{Int64})::Vector{Int64}\n           even = l[findall(l .%\
    \ 2 == 0)]\n           odd = l[findall(l .% 2 .== 1)]\n           even.sort()\n\
    \           odd.sort()\n           even.extend(odd)\n           return even\n\
    \       end\nsort_even (generic function with 1 method)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp20xnhuat.jl:17\nin expression starting at\
    \ /tmp/tmp20xnhuat.jl:17\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa1ow_n8h.jl:16\nin expression starting at\
    \ /tmp/tmpa1ow_n8h.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=1 |>\nI like to use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 5\n 6\n 4\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi6hpk1ig.jl:17\nin expression starting at\
    \ /tmp/tmpi6hpk1ig.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    l = copy(even)\n    l[findall(l .% 2\
    \ == 0)] = odd\n    l[findall(l .% 2 != 0)] = even\n    return l\nend\n</code>\n\
    <|/ a tags=julia |>\n<| a tags=julia |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbg2g3cgg.jl:19\nin expression starting at\
    \ /tmp/tmpbg2g3cgg.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.3>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp55o9qpuo.jl:16\nin expression starting at\
    \ /tmp/tmp55o9qpuo.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<code language=julia-1.3>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn3ou0cy3.jl:17\nin expression starting at\
    \ /tmp/tmpn3ou0cy3.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_h46c35n.jl:17\nin expression starting at\
    \ /tmp/tmp_h46c35n.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThanks, I didn't know about `sortperm` until now. I've added a\
    \ benchmark comparison to my answer.\n<|/ c |>\n<| a dscore=3 |>\nThe answer by\
    \ is correct, but I thought I'd add some benchmarking results. I used the benchmarking\
    \ package to benchmark several methods. I used the function sort_even from that\
    \ answer, but also used the function sort_even2 from my answer, which was based\
    \ on sortperm. \n<code>\nusing BenchmarkTools\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxd0zrj_s.jl:17\nin expression starting at\
    \ /tmp/tmpxd0zrj_s.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't answer the question. The question asks how to sort a vector\
    \ by its even indices. Your answer sorts the even indices first, then the odd\
    \ indices. That doesn't answer the question.\n<|/ c |>\n<| c |>\nThe question\
    \ asks how to sort a vector by its even indices. Your answer sorts the even indices\
    \ first, then the odd indices. That doesn't answer the question.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI believe that this is what you are looking for:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0awp3muv.jl:16\nin expression starting at\
    \ /tmp/tmp0awp3muv.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5,\
    \ 4]`, but `sort_even([5, 6, 3, 1])` returns `[5, 6, 3, 1]`.\n<|/ c |>\n<| c |>\n\
    It does work. `sort_even([5, 6, 3, 1])` returns `[5, 6, 3, 1]`.\n<|/ c |>\n<|\
    \ c |>\nI guess I misunderstood your question. My apologies.\n<|/ c |>\n<| c |>\n\
    No worries. I appreciate your help.\n<|/ c |>\n<| a tags=julia,sorting |>\nThe\
    \ answer by is correct, but I thought I'd add some explanation.\nThe reason why\
    \ your function doesn't work is that you are trying to sort a vector of Int64\
    \ and Int32 types. In Julia, sorting is done by converting both elements to their\
    \ corresponding floating point types and then comparing them. Since your elements\
    \ are Int64, this conversion will always succeed and your elements will remain\
    \ unchanged. To fix this, you can convert your elements to Float64 or Float32\
    \ types. \n<code>\njulia> sort_even([5, 6, 3, 1])\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 1\n</code>\n<code>\njulia> sort_even([5, 6, 3, 1] .|> Float64)\n\
    5-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n 1.0\n</code>\n<code>\njulia> sort_even([5,\
    \ 6, 3, 1] .|> Float32)\n5-element Array{Float32,1}:\n 1.0\n 2.0\n 3.0\n 1.0\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for the explanation. I appreciate\
    \ it.\n<|/ c |>\n<| a tags=julia,sorting |>\nThe answer by is correct, but I thought\
    \ I'd add some explanation.\nThe reason why your function doesn't work is that\
    \ you are trying to sort a vector of Int64 and Int32 types. In Julia, sorting\
    \ is done by converting both elements to their corresponding floating point types\
    \ and then comparing them. Since your elements are Int64, this conversion will\
    \ always succeed and your elements will remain unchanged. To \nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmwyh7j4e.jl:16\nin expression starting at\
    \ /tmp/tmpmwyh7j4e.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort`\
    \ will sort `Int64` arrays lexicographically and `sort_even` will sort `Int64`\
    \ arrays numerically.\n<|/ c |>\n<| c |>\nI see what you mean. I was thinking\
    \ about a general solution that would work for any type of array. I'll edit my\
    \ answer to include a solution that works for any type of array.\n<|/ c |>\n<|\
    \ c |>\nI edited my answer to include a solution that works for any type of array.\n\
    <|/ c |>\n<| a tags=julia |>\nHere is a solution using sortperm:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0h37oqnh.jl:16\nin expression starting at\
    \ /tmp/tmp0h37oqnh.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr3evogpa.jl:17\nin expression starting at\
    \ /tmp/tmpr3evogpa.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work\
    \ if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c |>\nIt works fine for me on `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nI guess you meant `sort` instead of `sort!`\n<|/ c |>\n<| c\
    \ |>\nYes, I meant `sort`. Thanks for pointing that out.\n<|/ c |>\n<| a tags=julia\
    \ |>\nHere's a solution using sort!:\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmwuo3u_s.jl:17\nin expression starting at\
    \ /tmp/tmpmwuo3u_s.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` will sort\
    \ `Int64` arrays lexicographically, not numerically.\n<|/ c |>\n<| c |>\nI didn't\
    \ know that. Thanks for pointing that out. I've edited my answer to include a\
    \ version that works with `Int64` arrays.\n<|/ c |>\n<| a tags=julia,sorting |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv0xk03ev.jl:17\nin expression starting at\
    \ /tmp/tmpv0xk03ev.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThanks for your answer! I didn't know about `sortperm` so I learned\
    \ something new today. Unfortunately, the code you provided doesn't work. `sortperm`\
    \ doesn't work on vectors of Int64. `sortperm` only works on vectors of Int. `sortperm`\
    \ doesn't work on vectors of Float64. `sortperm` only works on vectors of Float.\
    \ `sortperm` doesn't work on vectors of Complex. `sortperm` only works on vectors\
    \ of ComplexF64. `sortperm` doesn't work on vectors of ComplexF32. `sortperm`\
    \ only works on vectors of ComplexF16. `sortperm` only works on vectors of ComplexF8.\
    \ `sortperm` only works on vectors of ComplexF32. `sortperm` only works on vectors\
    \ of ComplexF16. `sortperm` only works on vectors of ComplexF8. `sortperm` only\
    \ works on vectors of ComplexF32. `sortperm` only works on vectors of ComplexF16.\
    \ `sortperm` only works on vectors of ComplexF8. `sortperm` only works on vectors\
    \ of ComplexF32. `sortperm` only works on vectors of ComplexF16. `sortperm` only\
    \ works on vectors of ComplexF8. `sortperm` only works on vectors of ComplexF32.\
    \ `sortperm` only works on vectors of ComplexF16. `sortperm` only works on vectors\
    \ of ComplexF8. `sortperm` only works on vectors of ComplexF32. `sortperm` only\
    \ works on vectors of ComplexF16. `sortperm` only works on vectors of ComplexF8.\
    \ `sortperm` only works on vectors of ComplexF32. `sortperm` only works on vectors\
    \ of ComplexF16. `sortperm` only works on vectors of ComplexF8. `sortperm` only\
    \ works on vectors of ComplexF32. `sortperm` only works on vectors of ComplexF16.\
    \ `sortperm` only works on vectors of ComplexF8. `sortperm` only works on vectors\
    \ of ComplexF32. `sortperm` only works on vectors of ComplexF16. `sortperm` only\
    \ works on vectors of ComplexF8. \nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj7b57cah.jl:17\nin expression starting at\
    \ /tmp/tmpj7b57cah.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n\
    <code language=julia-1.5>\nsort_even([5, 6, 3, 4])\n</cell>\n<text>\nExercise:\
    \ Write a function that takes a vector l and returns a vector l' such that\n \
    \   l' is identical to l in the even indicies, while its values at the odd indicies\
    \ are equal\n    to the values of the odd indicies of l, but sorted.\n    >>>\
    \ sort_odd([1, 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n    [5,\
    \ 6, 3, 4]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmgsy0psm.jl:16\nin expression starting at\
    \ /tmp/tmpmgsy0psm.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even + odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\nHere is a solution using sortperm:\n<code>\n\
    julia> sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n 3\n 5\n 6\n 4\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1pcm4xs9.jl:16\nin expression starting at\
    \ /tmp/tmp1pcm4xs9.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI came up\
    \ with a solution that is more efficient than sorting the entire vector and also\
    \ more readable than the other solutions posted so far.\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9k_r895_.jl:17\nin expression starting at\
    \ /tmp/tmp9k_r895_.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c\
    \ |>\n`sort` doesn't work for `Array{Int64,1}` either. `sort!` does, though.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe accepted answer doesn't work for me. Here's a\
    \ version that does:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3e4nztpo.jl:16\nin expression starting at\
    \ /tmp/tmp3e4nztpo.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</cell>\n<code language=julia-1.5>\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf6jb5uee.jl:17\nin expression starting at\
    \ /tmp/tmpf6jb5uee.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5,\
    \ 4]`\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1dz0mfzw.jl:17\nin expression starting at\
    \ /tmp/tmp1dz0mfzw.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like the idea of sorting in place, but this doesn't work for\
    \ me. `sort_even([5, 6, 3, 4])` returns `[3, 6, 5, 4]` instead of `[5, 6, 3, 4]`.\n\
    <|/ c |>\n<| c |>\nAh, I see what you're saying. You're right. I misunderstood\
    \ the question. I'll edit my answer.\n<|/ c |>\n<| c |>\nI edited my answer. Sorry\
    \ for the confusion.\n<|/ c |>\n<| a dscore=2 |>\nI like James' answer, but here's\
    \ another approach:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp1xb5ke6f.jl:16\nin expression starting at\
    \ /tmp/tmp1xb5ke6f.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    l = even .+ odd\n    return l\nend\n</cell>\n<text>\nExercise\n\
    Write a function that takes a vector l and returns a vector l' such that\n   \
    \ l' is identical to l in the even indicies, while its values at the odd indicies\
    \ are equal\n    to the values of the odd indicies of l, but sorted.\n    >>>\
    \ sort_odd([1, 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n    [4,\
    \ 6, 5, 3]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppw6esk3g.jl:17\nin expression starting at\
    \ /tmp/tmppw6esk3g.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't seem\
    \ to work. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n<|/ c\
    \ |>\n<| c |>\nI edited the answer to fix the bug. Thanks for pointing it out.\n\
    <|/ c |>\n<| c |>\nI edited the answer to fix the bug. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| a tags=julia |>\nI believe that you can do this in one line:\n\
    <code>\njulia> sort(collect(1:10))\n10-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\
    \ 5\n 6\n 7\n 8\n 9\n10\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem\
    \ to work. `sort(collect(1:10))` returns `[1,2,3,4,5,6,7,8,9,10]` instead of `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| c |>\nI edited the answer to fix the bug. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| a tags=julia |>\n<code>\njulia> sort(collect(1:10))\n10-element\
    \ Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\
    \t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2,\
    \ -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12,\
    \ -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl59eitf0.jl:17\nin expression starting at\
    \ /tmp/tmpl59eitf0.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd).map(x -> x[1])\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpady0f633.jl:16\nin expression starting at\
    \ /tmp/tmpady0f633.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp60r1mc3.jl:16\nin expression starting at\
    \ /tmp/tmpp60r1mc3.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp60r1mc3.jl:16\nin expression starting at\
    \ /tmp/tmpp60r1mc3.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThanks for your answer. Your solution is very elegant, but unfortunately\
    \ it takes too much time for my arrays. I guess it would be better to implement\
    \ a sorting algorithm myself and use that for my arrays. But thanks anyway!\n\
    <|/ c |>\n<| c |>\nI added a solution that uses `sort` instead of `sort!`\n<|/\
    \ c |>\n<| c |>\nThanks for your answer! I tested it and it works perfectly! I\
    \ guess it would be better to implement a sorting algorithm myself and use that\
    \ for my arrays. But thanks anyway!\n<|/ c |>\n<| c |>\nI added a solution that\
    \ uses `sort` instead of `sort!`\n<|/ c |>\n<| c |>\nThanks for your answer! I\
    \ tested it and it works perfectly! I guess it would be better to implement a\
    \ sorting algorithm myself and use that for my arrays. But thanks anyway!\n<|/\
    \ c |>\n<| a tags=julia,sorting,arrays |>\nThe accepted answer by is very elegant,\
    \ but unfortunately it takes too much time for my arrays. I guess it would be\
    \ better to implement a sorting algorithm myself and use that for my arrays. But\
    \ thanks anyway!\nI implemented a sorting algorithm myself and used that for my\
    \ arrays. I used the merge sort algorithm from Wikipedia to sort my arrays. Here\
    \ is the code:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4kklnor1.jl:16\nin expression starting at\
    \ /tmp/tmp4kklnor1.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nI like your solution, but I believe it can be simplified\
    \ a bit. `sort_even` can be written as `sort_even = l -> sort(l[findall(l .% 2\
    \ == 0)])`.\n<|/ c |>\n<| c |>\nI agree, that is a much better solution. Thank\
    \ you for pointing that out.\n<|/ c |>\n<| a tags=julia,sorting |>\nI like your\
    \ solution, but I believe it can be simplified a bit. sort_even can be written\
    \ as sort_even = l -> sort(l[findall(l .% 2 == 0)]). \u2013 Jeff P. Bosch May\
    \ 7 at 20:39\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI like your solution, but I\
    \ believe it can be simplified a bit. sort_even can be written as sort_even =\
    \ l -> sort(l[findall(l .% 2 == 0)]). \u2013 Jeff P. Bosch May 7 at 20:39\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnmqn5igq.jl:16\nin expression starting at\
    \ /tmp/tmpnmqn5igq.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=1 |>\nThe answer by is great, but I wanted to add that you can also use\
    \ sort! to sort the even indices:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfa36f_q5.jl:16\nin expression starting at\
    \ /tmp/tmpfa36f_q5.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<text>\nExercise\nWrite\
    \ a function that takes a vector l and returns a vector l' such that\n    l' is\
    \ identical to l in the even indicies, while its values at the odd indicies are\
    \ equal\n    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 6, 5, 3]\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpndeyphf7.jl:16\nin expression starting at\
    \ /tmp/tmpndeyphf7.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't work if you have a\
    \ vector of NaNs. I added an answer that does work if you have NaNs.\n<|/ c |>\n\
    <| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9ie3dc15.jl:17\nin expression starting at\
    \ /tmp/tmp9ie3dc15.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2824cnf.jl:17\nin expression starting at\
    \ /tmp/tmpt2824cnf.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a tags=julia,sorting |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a more efficient way to do this.\n<|/ c |>\n<| c |>\nI doubt that there is\
    \ a more efficient way to do this. But you can try `@inbounds` instead of `findall`.\n\
    <|/ c |>\n<| c |>\nI added a more efficient solution that uses `@inbounds` instead\
    \ of `findall`.\n<|/ c |>\n<| a dscore=2 |>\nI believe that this is an example\
    \ of when to use broadcasting instead of looping.\n<code>\njulia> function sort_even(l::Vector{Int64})\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ .== 1)]\n           even = sort_even(even)\n           odd = sort_even(odd)\n\
    \           return even .+ odd\n       end\nsort_even (generic function with 1\
    \ method)\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpor6rq0ir.jl:16\nin expression starting at\
    \ /tmp/tmpor6rq0ir.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp60r1mc3.jl:16\nin expression starting at\
    \ /tmp/tmpp60r1mc3.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpywyfokcb.jl:16\nin expression starting at\
    \ /tmp/tmpywyfokcb.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even ++ odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't work if `l` is an `Int64` array. `sort` doesn't work on `Int64` arrays.\
    \ `sort!` does, but that doesn't help because `sort!` doesn't work on `Int64`\
    \ arrays. `sort!` works on `Array{Int64,1}` arrays, but that doesn't help because\
    \ `sort!` doesn't work on `Array{Int64,1}` arrays. `sort!` works on `Array{Int64,2}`\
    \ arrays, but that doesn't help because `sort!` doesn't work on `Array{Int64,2}`\
    \ arrays. `sort!` works on `Array{Int64,3}` arrays, but that doesn't help because\
    \ `sort!` doesn't work on `Array{Int64,3}` arrays. `sort!` works on `Array{Int64,4}`\
    \ arrays, but that doesn't help because `sort!` doesn't work on `Array{Int64,4}`\
    \ arrays. `sort!` works on `Array{Int64,5}` arrays, but that doesn't help because\
    \ `sort!` doesn't work on `Array{Int64,5}` arrays. `sort!` works on `Array{Int64,6}`\
    \ arrays, but that doesn't help because `sort!` doesn't work on `Array{Int64,6}`\
    \ arrays. `sort!` works on `Array{Int64,7}` arrays, but that doesn't help because\
    \ `sort!` doesn't work on `Array{Int64,7}` arrays. `sort!` works on `Array{Int64,8}`\
    \ arrays, but that doesn't help because `sort!` doesn't work on `Array{Int64,8}`\
    \ arrays. `sort!` works on `Array{Int64,9}` arrays, but that doesn't help because\
    \ `sort!` doesn't work on `Array{Int64,9}` arrays. `sort!` works on `Array{Int64,10}`\
    \ arrays, but that doesn't help because `sort!` doesn't work on `Array{Int64,10}`\
    \ arrays. `sort!` works on `Array{Int64,11}` arrays, but that doesn't help because\
    \ `sort!` doesn't work on `Array{Int64,11}` arrays. `sort!` works on `Array{Int64,12}`\
    \ arrays, but that doesn't help because `sort!` doesn't work on `Array{Int64,12}`\
    \ arrays. `\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvq59js2v.jl:16\nin expression starting at\
    \ /tmp/tmpvq59js2v.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| c |>\nThis doesn't work if the vector contains negative numbers. `sort_even([-5,\
    \ -4, -3, -2, -1, 0, 1, 2, 3, 4])` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]`\
    \ instead of `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nI added\
    \ a version that works with negative numbers. I tested it on Julia 0.6.2\n<|/\
    \ c |>\n<| c |>\nI added a version that works with negative numbers. I tested\
    \ it on Julia 0.6.2\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution that doesn't\
    \ require any packages:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpon1q04mf.jl:17\nin expression starting at\
    \ /tmp/tmpon1q04mf.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpdhtrgogu.jl:16\nin expression starting at\
    \ /tmp/tmpdhtrgogu.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a tags=julia |>\n<| c |>\nThis doesn't work for me. `sort_even([5,\
    \ 6, 3, 4])` returns `[3, 6, 5, 4]`\n<|/ c |>\n<| c |>\nI tested it on Julia 1.5.1\
    \ and it works. I guess it might have been fixed in later versions.\n<|/ c |>\n\
    <| c |>\nYes, it works in Julia 1.5.1. I guess it might have been fixed in later\
    \ versions.\n<|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 and it works. I guess\
    \ it might have been fixed in later versions.\n<|/ c |>\n<| a tags=julia |>\n\
    I came up with a solution using sortperm:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnycx624h.jl:17\nin expression starting at\
    \ /tmp/tmpnycx624h.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp60r1mc3.jl:16\nin expression starting at\
    \ /tmp/tmpp60r1mc3.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])` returns `[1,2,3]`\n\
    <|/ c |>\n<| c |>\nIt works for me. `julia> sort_even([1,2,3])\n3-element Array{Int64,1}:\n\
    \ 1\n 2\n 3`\n<|/ c |>\n<| c |>\nI guess I misunderstood your question. I've edited\
    \ my answer to reflect your question.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ Thanks for your answer!\n<|/ c |>\n<| a |>\nThe answer by is correct but can\
    \ be simplified a bit:\n<code>\nsort_even(l::Vector{Int64}) = sort(l)[findall(l\
    \ .== 0)]\n</code>\n<|/ a tags=julia,sorting,arrays dscore=2 |>\n<| a tags=julia,sorting,arrays\
    \ |>\nI believe that this is what you are looking for:\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbw2g1dr1.jl:17\nin expression starting at\
    \ /tmp/tmpbw2g1dr1.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=julia,sorting |>\nI like using sortperm:\n\
    <code>\njulia> sortperm([5,4,3,2,1])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n\
    \ 4\n 5\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzq7hwjck.jl:17\nin expression starting at\
    \ /tmp/tmpzq7hwjck.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia,sorting |>\n<| c |>\nThis doesn't\
    \ work for me. `sort_even([5,6,3,4])` returns `[3,6,5,4]` instead of `[3,6,4,5]`.\n\
    <|/ c |>\n<| c |>\nIt works for me in Julia 0.6.2\n<|/ c |>\n<| c |>\nI tested\
    \ it on Julia 0.6.2 and 0.6.3\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and\
    \ 0.6.3\n<|/ c |>\n<| c |>\nI tested it on Julia 0.6.2 and 0.6.3\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbob9tmkt.jl:17\nin expression starting at\
    \ /tmp/tmpbob9tmkt.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting it. The only difference\
    \ is that I used `sort` instead of `sort_even`.\n<|/ c |>\n<| c |>\nOh sorry,\
    \ I missed the `.` before `%`. My bad.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with `Array{Int64,1}`\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution that\
    \ works with Array{Int64,1} and does not require any packages:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj_xg5uhx.jl:16\nin expression starting at\
    \ /tmp/tmpj_xg5uhx.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<text>\nExercise: Write\
    \ a function that takes a vector l and returns a vector l' such that\n    l' is\
    \ identical to l in the even indicies, while its values at the odd indicies are\
    \ equal\n    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1,\
    \ 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5, 6, 3, 4])\n    [4, 5, 6, 3]\n  \
    \  \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphoszkfa5.jl:16\nin expression starting at\
    \ /tmp/tmphoszkfa5.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| a tags=sorting,julia\
    \ |>\nI like to use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n\
    \ 3\n 5\n 6\n 4\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphlxm016z.jl:16\nin expression starting at\
    \ /tmp/tmphlxm016z.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=sorting,julia |>\nThe answer by is correct,\
    \ but I thought I'd add some explanation as to why it works.\nThe function sort_even\
    \ is defined as:\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgnaeclc5.jl:17\nin expression starting at\
    \ /tmp/tmpgnaeclc5.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't seem to work. `sort_even([1,2,3])` returns `[1,2,3]`\
    \ instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt does work, try it out. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt doesn't work for me. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works for me too. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works for me too. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| a dscore=1 |>\nI wrote a function that sorts\
    \ an array in O(n) time complexity:\n<code>\nusing Test\n\n@testset begin\n\n\
    candidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf8_up13p.jl:16\nin expression starting at\
    \ /tmp/tmpf8_up13p.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = sort(even)\n    odd = sort(odd)\n    even\
    \ = union(even, odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't seem to work. `sort_even([5, 6, 3, 4])` returns `[3,\
    \ 6, 5, 4]` instead of `[5, 6, 3, 4]`.\n<|/ c |>\n<| c |>\nYes, I missed the fact\
    \ that `sort` sorts even numbers too. Fixed now.\n<|/ c |>\n<| a tags=julia,sorting\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpor0we3tu.jl:19\nin expression starting at\
    \ /tmp/tmpor0we3tu.jl:19\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`, not `[2,1,3]`.\n<|/ c |>\n<| c |>\nIt does work. `sort_even([1,2,3])`\
    \ returns `[1,2,3]`. `sort_even([5,6,3,4])` returns `[3,6,5,4]`.\n<|/ c |>\n<|\
    \ c |>\nOh sorry, I misread your code. Yes, it does work. Thanks!\n<|/ c |>\n\
    <| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6juaxjhw.jl:17\nin expression starting at\
    \ /tmp/tmp6juaxjhw.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=julia,sorting,arrays |>\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe98fo2n4.jl:17\nin expression starting at\
    \ /tmp/tmpe98fo2n4.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work for me. `sort_even([1,2,3])` returns `[1,2,3]`\
    \ instead of `[2,1,3]`\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing\
    \ it out. Now it works.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpajon3wnm.jl:16\nin expression starting at\
    \ /tmp/tmpajon3wnm.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| a dscore=2 |>\nI like using sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 2\n 1\n 4\n 5\n</code>\n<|/ a tags=julia,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if your array has duplicates. `sortperm([5,5,6,3,4])`\
    \ returns `5-element Array{Int64,1}:\n 3\n 2\n 1\n 4\n 5`\n<|/ c |>\n<| a tags=julia,sorting,arrays\
    \ |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpn9cbndfg.jl:16\nin expression starting at\
    \ /tmp/tmpn9cbndfg.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a tags=julia |>\n<| a tags=julia |>\nThe answer\
    \ by is correct, but I wanted to add some explanation as to why it works.\nThe\
    \ reason why it works is because Julia's sort function sorts the array in-place.\
    \ \n<code>\njulia> sort([1,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp3dzmljn2.jl:17\nin expression starting at\
    \ /tmp/tmp3dzmljn2.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\n<code>\njulia> function sort_even(l::Vector{Int64})::Vector{Int64}\n\
    \           even = l[findall(l .% 2 == 0)]\n           odd = l[findall(l .% 2\
    \ != 0)]\n           even.sort()\n           odd.sort()\n           return even\
    \ .+ odd\n       end\nsort_even (generic function with 1 method)\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd7x5i_fb.jl:16\nin expression starting at\
    \ /tmp/tmpd7x5i_fb.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia |>\n<|\
    \ c |>\nI like the idea of using `.%` to get the even and odd indices, but this\
    \ doesn't work if `l` is an `Int64` array. `sort` will sort `Int64` arrays lexicographically,\
    \ not numerically.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted my\
    \ answer. Thanks for pointing it out. I've edited my answer to reflect this.\n\
    <|/ c |>\n<| a tags=julia |>\nHere's a solution that uses sortperm:\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp80o978yl.jl:16\nin expression starting at\
    \ /tmp/tmp80o978yl.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` will sort\
    \ it lexicographically, not numerically.\n<|/ c |>\n<| c |>\nI fixed the code\
    \ so that it works with `Int64` arrays. Thanks for pointing that out.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if `l` is an `Int64` array. `sort` will sort it lexicographically,\
    \ not numerically.\n<|/ c |>\n<| c |>\nI fixed the code so that it works with\
    \ `Int64` arrays. Thanks for pointing that out.\n<|/ c |>\n<| a dscore=3 |>\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp0tq1p6ey.jl:16\nin expression starting at\
    \ /tmp/tmp0tq1p6ey.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6qf6b_vj.jl:16\nin expression starting at\
    \ /tmp/tmp6qf6b_vj.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort(even)\n    odd = sort(odd)\n    return even .+ odd\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnik9mp3l.jl:16\nin expression starting at\
    \ /tmp/tmpnik9mp3l.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .== 1)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia\
    \ |>\n<| a dscore=2 |>\nI came up with this solution:\n<code>\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzpriegp7.jl:16\nin expression starting at\
    \ /tmp/tmpzpriegp7.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    even = union(even, odd)\n \
    \   return even\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for `sort_even([5,\
    \ 6, 3, 4])` which should return `[3, 6, 5, 4]`.\n<|/ c |>\n<| c |>\nI fixed the\
    \ bug and added a test case. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere's a solution that doesn't require any extra packages:\n<code>\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3])\
    \ == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) ==\
    \ [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23,\
    \ 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6p006jy9.jl:17\nin expression starting at\
    \ /tmp/tmp6p006jy9.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</cell>\n\
    <code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj_p0ox1b.jl:16\nin expression starting at\
    \ /tmp/tmpj_p0ox1b.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<text>\nExercise 3\nWrite a function that takes a vector l and returns\
    \ a vector l' such that\n    l' is identical to l in the even indicies, while\
    \ its values at the odd indicies are equal\n    to the values of the odd indicies\
    \ of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 3, 2]\n    >>> sort_odd([5,\
    \ 6, 3, 4])\n    [4, 6, 5, 3]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnj3vrcvd.jl:17\nin expression starting at\
    \ /tmp/tmpnj3vrcvd.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if the vector is sorted in descending order.\
    \ For example, `sort_even([5, 6, 3, 4])` returns `[4, 3, 6, 5]`.\n<|/ c |>\n<|\
    \ c |>\nYes, I noticed that and fixed it. I also added a version that doesn't\
    \ require the vector to be sorted.\n<|/ c |>\n<| a dscore=2 |>\nThis should work:\n\
    <code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_um8tbfq.jl:17\nin expression starting at\
    \ /tmp/tmp_um8tbfq.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't seem to work. `sort_even([1,2,3])` returns `[1,2,3]` instead of `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now it should\
    \ work.\n<|/ c |>\n<| a dscore=1 |>\nI wrote a function to sort a vector in O(n)\
    \ time complexity and O(1) space complexity:\n<code>\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpoh3xmjer.jl:16\nin expression starting at\
    \ /tmp/tmpoh3xmjer.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=julia,sorting |>\nI like using sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 2\n 3\n 1\n 4\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nI like using sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n5-element Array{Int64,1}:\n\
    \ 2\n 3\n 1\n 4\n</code>\n<|/ a tags=julia,sorting |>\n<| a dscore=0 |>\n<code>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp22f2dk4e.jl:17\nin expression starting at\
    \ /tmp/tmp22f2dk4e.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even\
    \ = sort_even(even)\n    odd = sort_even(odd)\n    return even .+ odd\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work if there are duplicates in the input\
    \ vector. For example, sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3].\n<|/ c |>\n\
    <| c |>\nIt does work if there are duplicates in the input vector. For example,\
    \ sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns\
    \ [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1,\
    \ 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2,\
    \ 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2,\
    \ 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or\
    \ sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns\
    \ [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1,\
    \ 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2,\
    \ 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2,\
    \ 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or\
    \ sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns\
    \ [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1,\
    \ 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2,\
    \ 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2,\
    \ 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or\
    \ sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns\
    \ [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1,\
    \ 1, 2, 3]) returns [1, 1, 2, 3]. Or sort_even([1, 1, 2, 3]) returns \nusing Test\n\
    \n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1,\
    \ 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4, 23, 2,\
    \ 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpm6k1qqgj.jl:16\nin expression starting at\
    \ /tmp/tmpm6k1qqgj.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\nThe answer by is great, but I thought I'd add\
    \ my own solution, since I needed it for something else and I wanted to share\
    \ it.\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9_mn0q1e.jl:16\nin expression starting at\
    \ /tmp/tmp9_mn0q1e.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    return even .+ odd\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| a tags=julia,sorting |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp74c80epb.jl:16\nin expression starting at\
    \ /tmp/tmp74c80epb.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even = sort_even(even)\n\
    \    odd = sort_even(odd)\n    even = union(even, odd)\n    return even\nend\n\
    </cell>\n<code language=julia-1.5>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7c0vqyza.jl:17\nin expression starting at\
    \ /tmp/tmp7c0vqyza.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .== 0)]\n    odd = l[findall(l .!= 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test\n\n@testset begin\n\ncandidate = sort_even;\n\t@test(candidate([1,\
    \ 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\
    \ == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5, 8, -12, 4,\
    \ 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpt2824cnf.jl:17\nin expression starting at\
    \ /tmp/tmpt2824cnf.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 .== 1)]\n    even.sort()\n\
    \    odd.sort()\n    even.zip(odd) |> collect\nend\n</code>\n<|/ a tags=julia,sorting\
    \ |>\n<| c |>\nThis doesn't work if `l` is an `Array{Int64,1}`\n<|/ c |>\n<| c\
    \ |>\nI believe this should work for both `Array{Int64,1}` and `Array{Int64,2}`\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it on Julia 1.5.1\n<|/ c |>\n<| c |>\n\
    I tested it on Julia 1.5.1 too. `sort_even([5,6,3,4])` returns `[3, 6, 5, 4]`\n\
    <|/ c |>\n<| c |>\nI tested it on Julia 1.5.1 too. `sort_even([5,6,3,4])` returns\
    \ `[3, 6, 5, 4]`\n<|/ c |>\n<| a tags=julia,sorting |>\nThe answer by is correct,\
    \ but I wanted to add that you can also use sortperm:\n<code>\njulia> sortperm([5,6,3,4])\n\
    5-element Array{Int64,1}:\n 3\n 6\n 5\n 4\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This should be the accepted answer. `sortperm` does exactly what OP asked for,\
    \ while `sort` does something completely different.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `sortperm` does exactly what OP asked for, while `sort`\
    \ does something completely different.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `sortperm` does exactly what OP asked for, while `sort` does\
    \ something completely different.\n<|/ c |>\n<| a tags=julia,sorting |>\n<code>\n\
    julia> sort!([5,6,3,4])\n5-element Array{Int64,1}:\n 3\n 6\n 5\n 4\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer. `sort!` does exactly\
    \ what OP asked for, while `sort` does something completely different.\n<|/ c\
    \ |>\n<| c |>\nThis should be the accepted answer. `\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcqwgwoos.jl:16\nin expression starting at\
    \ /tmp/tmpcqwgwoos.jl:16\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nusing Test\n\n@testset begin\n\ncandidate = sort_even;\n\
    \t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\t@test(candidate([5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8o2q9ll3.jl:17\nin expression starting at\
    \ /tmp/tmp8o2q9ll3.jl:17\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"This function takes a vector l and returns a vector l' such that\n\
    \    l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n    to the values of the even indicies of l, but sorted.\n    >>>\
    \ sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3,\
    \ 6, 5, 4]\n    \"\"\"\nfunction sort_even(l::Vector{Int64})::Vector{Int64} \n\
    \    even = l[findall(l .% 2 == 0)]\n    odd = l[findall(l .% 2 != 0)]\n    even.sort()\n\
    \    odd.sort()\n    even.extend(odd)\n    return even\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=julia |>\nI came up with a solution that is quite simple and does\
    \ not require any packages:\n<code>\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_even;\n\t@test(candidate([1, 2, 3]) == [1, 2, 3])\n\t@test(candidate([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n\
    \t@test(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5,\
    \ 2, 12, 11, 23, -10])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"<\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpi6eifsi9.jl:17\nin expression starting at\
    \ /tmp/tmpi6eifsi9.jl:17\n"
  stdout: ''
