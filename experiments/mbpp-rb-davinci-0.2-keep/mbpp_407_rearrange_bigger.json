{
  "name": "mbpp_407_rearrange_bigger",
  "language": "rb",
  "prompt": "# Write a function to create the next bigger number by rearranging the digits of a given number.\ndef rearrange_bigger(n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "verbatim",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rearrange_bigger\n    candidate = method(:rearrange_bigger)\n    assert_equal(21, candidate.call(12))\n    assert_equal(false, candidate.call(10))\n    assert_equal(120, candidate.call(102))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "  n = n.to_s.split('')\n  n.each_with_index do |num, idx|\n    if idx < n.length - 1\n      if n[idx].to_i > n[idx + 1].to_i\n        n[idx], n[idx + 1] = n[idx + 1], n[idx]\n        break\n      end\n    end\n  end\n  n.join('').to_i\nend",
    "  n = n.to_s.split('').map(&:to_i)\n  (n.size - 2).downto(0) do |i|\n    if n[i] < n[i + 1]\n      n[i], n[i + 1] = n[i + 1], n[i]\n      return n.join.to_i\n    end\n  end\n  -1\nend",
    "  # n = n.to_s.split('').map(&:to_i)\n  # n.permutation.to_a.map(&:join).map(&:to_i).select { |num| num > n }.min\n  n.to_s.chars.sort.reverse.join.to_i\nend",
    "  n_arr = n.to_s.split('')\n  i = n_arr.length - 1\n  while i > 0\n    if n_arr[i] > n_arr[i-1]\n      n_arr[i], n_arr[i-1] = n_arr[i-1], n_arr[i]\n      return n_arr.join('').to_i\n    end\n    i -= 1\n  end\n  -1\nend",
    "  return -1 if n.to_s.size == 1\n  n = n.to_s.split('').map(&:to_i)\n  i = n.size - 1\n  while i > 0\n    if n[i] > n[i - 1]\n      n[i], n[i - 1] = n[i - 1], n[i]\n      return n.join.to_i\n    end\n    i -= 1\n  end\n  -1\nend",
    "  # convert to string, split into array of chars, sort in descending order, join and convert back to integer\n  n.to_s.chars.sort.reverse.join.to_i\nend",
    "  # convert to array of digits\n  digits = n.to_s.split('')\n  # find the first digit that is smaller than the digit to its right\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i + 1]\n    i -= 1\n  end\n  # if no such digit exists, the number is already the biggest possible\n  return -1 if i == -1\n  # find the smallest digit to the right of the pivot that is bigger than the pivot\n  j = digits.length - 1\n  while j >= 0 && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap the pivot with the smallest digit to its right\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i + 1..-1] = digits[i + 1..-1].reverse\n  # convert back to integer and return\n  digits.join.to_i\nend",
    "  # convert to array of digits\n  digits = n.to_s.split('').map(&:to_i)\n  # find the first digit that is smaller than the digit to its right\n  i = digits.length - 2\n  while i >= 0\n    if digits[i] < digits[i + 1]\n      break\n    end\n    i -= 1\n  end\n  # if no such digit exists, return -1\n  return -1 if i < 0\n  # find the smallest digit to the right of the pivot that is greater than the pivot\n  j = digits.length - 1\n  while j >= 0\n    if digits[j] > digits[i]\n      break\n    end\n    j -= 1\n  end\n  # swap the pivot with the smallest digit to its right\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i + 1..-1] = digits[i + 1..-1].reverse\n  # return the number\n  digits.join.to_i\nend",
    "  n = n.to_s.split('')\n  n.each_with_index do |num, index|\n    if n[index + 1] && num < n[index + 1]\n      n[index], n[index + 1] = n[index + 1], n[index]\n      return n.join.to_i\n    end\n  end\n  -1\nend",
    "  n_arr = n.to_s.split('')\n  n_arr.each_with_index do |num, i|\n    if n_arr[i+1] && n_arr[i+1].to_i > num.to_i\n      n_arr[i], n_arr[i+1] = n_arr[i+1], n_arr[i]\n      return n_arr.join('').to_i\n    end\n  end\n  -1\nend",
    "  # Convert the number to an array of digits\n  digits = n.to_s.split('').map(&:to_i)\n  # Find the first digit that is smaller than the digit to its right\n  (digits.length - 2).downto(0) do |i|\n    if digits[i] < digits[i + 1]\n      # Find the smallest digit to the right of the pivot that is greater than the pivot\n      swap_index = i + 1\n      (i + 1).upto(digits.length - 1) do |j|\n        swap_index = j if digits[j] > digits[i] && digits[j] < digits[swap_index]\n      end\n      # Swap the pivot with the smallest digit to its right that is greater than the pivot\n      digits[i], digits[swap_index] = digits[swap_index], digits[i]\n      # Reverse the digits to the right of the pivot\n      digits[i + 1..-1] = digits[i + 1..-1].reverse\n      # Return the number\n      return digits.join.to_i\n    end\n  end\n  # Return -1 if no bigger number exists\n  -1\nend",
    "  # convert to array of digits\n  digits = n.to_s.split('').map(&:to_i)\n  # find the first digit that is smaller than the digit to its right\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i+1]\n    i -= 1\n  end\n  # if no such digit exists, return -1\n  return -1 if i < 0\n  # find the smallest digit to the right of the pivot that is larger than the pivot\n  j = digits.length - 1\n  while j >= 0 && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap the pivot with the smallest digit to its right\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i+1..-1] = digits[i+1..-1].reverse\n  # convert back to integer and return\n  digits.join.to_i\nend",
    "  n = n.to_s.split('')\n  i = n.length - 1\n  while i > 0\n    if n[i] > n[i-1]\n      n[i], n[i-1] = n[i-1], n[i]\n      return n.join.to_i\n    end\n    i -= 1\n  end\n  -1\nend",
    "  # get the digits of the number\n  digits = n.to_s.split('').map(&:to_i)\n  # find the first digit that is smaller than the digit to its right\n  i = 0\n  while i < digits.length - 1\n    if digits[i] < digits[i + 1]\n      break\n    end\n    i += 1\n  end\n  # if i is at the end of the array, then there is no bigger number\n  return -1 if i == digits.length - 1\n  # find the smallest digit to the right of i that is larger than digits[i]\n  j = i + 1\n  while j < digits.length\n    if digits[j] > digits[i]\n      break\n    end\n    j += 1\n  end\n  # swap digits[i] and digits[j]\n  digits[i], digits[j] = digits[j], digits[i]\n  # sort the digits to the right of i\n  digits[i + 1..-1] = digits[i + 1..-1].sort\n  # return the number\n  digits.join.to_i\nend",
    "  n_arr = n.to_s.split('')\n  n_arr.each_with_index do |num, i|\n    if n_arr[i + 1] && n_arr[i + 1].to_i > num.to_i\n      n_arr[i], n_arr[i + 1] = n_arr[i + 1], n_arr[i]\n      return n_arr.join.to_i\n    end\n  end\n  -1\nend",
    "  # find the first digit that is not in descending order\n  # find the next largest digit to the right of that digit\n  # swap the two digits\n  # sort the digits to the right of the swapped digits\n  # join the digits together\n  # return the number\n  digits = n.to_s.split('').map(&:to_i)\n  i = 0\n  while i < digits.length - 1\n    if digits[i] < digits[i + 1]\n      break\n    end\n    i += 1\n  end\n  if i == digits.length - 1\n    return -1\n  end\n  j = i + 1\n  while j < digits.length\n    if digits[j] <= digits[i]\n      break\n    end\n    j += 1\n  end\n  j -= 1\n  digits[i], digits[j] = digits[j], digits[i]\n  digits[i + 1..-1] = digits[i + 1..-1].sort\n  digits.join.to_i\nend",
    "  n_arr = n.to_s.split('')\n  n_arr.each_with_index do |num, i|\n    n_arr.each_with_index do |num2, j|\n      if num2 > num && j > i\n        n_arr[i], n_arr[j] = n_arr[j], n_arr[i]\n        return n_arr.join.to_i\n      end\n    end\n  end\n  -1\nend",
    "  # convert to string\n  # split into array\n  # sort array\n  # join array\n  # convert to integer\n  n.to_s.split('').sort.join.to_i\nend",
    "  n = n.to_s.split('')\n  n.each_with_index do |num, i|\n    if n[i+1] && num < n[i+1]\n      n[i], n[i+1] = n[i+1], n[i]\n      return n.join.to_i\n    end\n  end\n  -1\nend",
    "  # get the digits of the number\n  digits = n.to_s.split('').map(&:to_i)\n  # find the first digit that is smaller than the digit to its right\n  i = digits.length - 2\n  while i >= 0 && digits[i] >= digits[i + 1]\n    i -= 1\n  end\n  # if no such digit exists, the number is the largest possible\n  return -1 if i < 0\n  # find the smallest digit to the right of the pivot that is greater than the pivot\n  j = digits.length - 1\n  while j >= 0 && digits[j] <= digits[i]\n    j -= 1\n  end\n  # swap the pivot with the smallest digit to its right\n  digits[i], digits[j] = digits[j], digits[i]\n  # reverse the digits to the right of the pivot\n  digits[i + 1..-1] = digits[i + 1..-1].reverse\n  # return the number\n  digits.join.to_i\nend"
  ]
}