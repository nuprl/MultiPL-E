{
  "name": "mbpp_141_pancake_sort",
  "language": "rb",
  "prompt": "# Write a function to sort a list of elements.\ndef pancake_sort(nums)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py",
  "prompt_terminology": "verbatim",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pancake_sort\n    candidate = method(:pancake_sort)\n    assert_equal([15, 25, 38, 69, 79], candidate.call([15, 79, 25, 38, 69]))\n    assert_equal([12, 36, 54, 85, 98], candidate.call([98, 12, 54, 36, 85]))\n    assert_equal([12, 23, 32, 41, 42], candidate.call([41, 42, 32, 12, 23]))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "  # Write your code here.\n  i = nums.length\n  while i > 1\n    max_index = find_max(nums, i)\n    flip(nums, max_index)\n    flip(nums, i - 1)\n    i -= 1\n  end\n  nums\nend",
    "  # Write your code here.\n  current_size = nums.length\n  while current_size > 1\n    mi = find_max(nums, current_size)\n    if mi != current_size - 1\n      flip(nums, mi)\n      flip(nums, current_size - 1)\n    end\n    current_size -= 1\n  end\n  nums\nend",
    "  i = nums.length - 1\n  while i > 0\n    max_index = 0\n    (0..i).each do |j|\n      max_index = j if nums[j] > nums[max_index]\n    end\n    flip(nums, max_index)\n    flip(nums, i)\n    i -= 1\n  end\n  nums\nend",
    "  n = nums.length\n  for i in (1..n)\n    max_index = find_max_index(nums, n - i)\n    flip(nums, max_index)\n    flip(nums, n - i)\n  end\n  nums\nend",
    "  n = nums.length\n  (n - 1).downto(1) do |i|\n    max_index = nums[0..i].each_with_index.max[1]\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  for i in (0..nums.length-1)\n    max_index = nums.index(nums[0..i].max)\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  # Write your code here.\n  i = nums.length - 1\n  while i > 0\n    max_index = find_max(nums, i)\n    flip(nums, max_index)\n    flip(nums, i)\n    i -= 1\n  end\n  nums\nend",
    "  n = nums.length\n  (n-1).downto(1) do |i|\n    max_index = find_max(nums, i)\n    if max_index != i\n      flip(nums, max_index)\n      flip(nums, i)\n    end\n  end\n  nums\nend",
    "  for i in (0..nums.length-1)\n    max_index = nums.each_with_index.max[1]\n    nums = flip(nums, max_index)\n    nums = flip(nums, i)\n  end\n  nums\nend",
    "  nums.length.downto(2).each do |size|\n    max_index = nums[0...size].each_with_index.max[1]\n    flip(nums, max_index)\n    flip(nums, size - 1)\n  end\n  nums\nend",
    "  # Write your code here\n  return nums if nums.length <= 1\n  (nums.length - 1).downto(1) do |i|\n    max_index = 0\n    (0..i).each do |j|\n      max_index = j if nums[j] > nums[max_index]\n    end\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  # Write your code here.\n  sorted = false\n  until sorted\n    sorted = true\n    (nums.length-1).times do |i|\n      if nums[i] > nums[i+1]\n        sorted = false\n        nums[0..i] = nums[0..i].reverse\n        nums[0..i+1] = nums[0..i+1].reverse\n      end\n    end\n  end\n  nums\nend",
    "  n = nums.length\n  (n-1).downto(1) do |i|\n    max_index = find_max_index(nums, i)\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  n = nums.length\n  (n - 1).downto(1) do |i|\n    max_index = find_max(nums, i)\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  # Write your code here\n  return nums if nums.length <= 1\n  (nums.length - 1).downto(1) do |i|\n    max_index = 0\n    (0..i).each do |j|\n      max_index = j if nums[j] > nums[max_index]\n    end\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  n = nums.length\n  (n - 1).downto(1) do |i|\n    max_index = nums[0...i].each_with_index.max[1]\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend",
    "  (nums.length - 1).downto(1) do |size|\n    max_index = find_max_index(nums, size)\n    flip(nums, max_index)\n    flip(nums, size)\n  end\nend",
    "  i = nums.length - 1\n  while i > 0\n    max_index = find_max(nums, i)\n    if max_index != i\n      flip(nums, max_index)\n      flip(nums, i)\n    end\n    i -= 1\n  end\n  nums\nend",
    "  # Write your code here\n  return nums if nums.length <= 1\n  (nums.length - 1).downto(1) do |i|\n    max_index = 0\n    (0..i).each do |j|\n      max_index = j if nums[j] > nums[max_index]\n    end\n    nums = flip(nums, max_index)\n    nums = flip(nums, i)\n  end\n  nums\nend",
    "  for i in 0..nums.length-1\n    max_index = find_max(nums, i)\n    flip(nums, max_index)\n    flip(nums, i)\n  end\n  nums\nend"
  ]
}