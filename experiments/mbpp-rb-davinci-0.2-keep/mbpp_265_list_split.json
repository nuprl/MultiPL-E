{
  "name": "mbpp_265_list_split",
  "language": "rb",
  "prompt": "# Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\ndef list_split(s, step)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py",
  "prompt_terminology": "verbatim",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_list_split\n    candidate = method(:list_split)\n    assert_equal([[\"a\", \"d\", \"g\", \"j\", \"m\"], [\"b\", \"e\", \"h\", \"k\", \"n\"], [\"c\", \"f\", \"i\", \"l\"]], candidate.call([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"], 3))\n    assert_equal([[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], 3))\n    assert_equal([[\"python\", \"C\", \"DBMS\"], [\"java\", \"C++\", \"SQL\"]], candidate.call([\"python\", \"java\", \"C\", \"C++\", \"DBMS\", \"SQL\"], 2))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "  result = []\n  s.each_slice(step) { |slice| result << slice }\n  result\nend",
    "  result = []\n  i = 0\n  while i < s.length\n    result << s[i..i+step-1]\n    i += step\n  end\n  result\nend",
    "  if s.length <= step\n    return [s]\n  else\n    return [s[0..step-1]] + list_split(s[step..-1], step)\n  end\nend",
    "  new_array = []\n  s.each_slice(step) { |a| new_array << a }\n  new_array\nend",
    "  result = []\n  i = 0\n  while i < s.length\n    result << s[i..i+step-1]\n    i += step\n  end\n  result\nend",
    "  result = []\n  s.each_slice(step) { |x| result << x }\n  result\nend",
    "  result = []\n  s.each_slice(step) {|a| result << a}\n  result\nend",
    "  result = []\n  i = 0\n  while i < s.length\n    result << s[i, step]\n    i += step\n  end\n  result\nend",
    "  result = []\n  s.each_slice(step) { |a| result << a }\n  result\nend",
    "  result = []\n  s.each_slice(step) {|a| result << a}\n  result\nend",
    "  result = []\n  s.each_slice(step) { |x| result << x }\n  result\nend",
    "  result = []\n  s.each_slice(step) { |x| result << x }\n  result\nend",
    "  result = []\n  s.each_slice(step) { |x| result << x }\n  result\nend",
    "  result = []\n  s.each_slice(step) { |a| result << a }\n  result\nend",
    "  result = []\n  (0..s.length-1).step(step) do |i|\n    result << s[i..i+step-1]\n  end\n  result\nend",
    "  result = []\n  s.each_slice(step) { |x| result << x }\n  result\nend",
    "  result = []\n  start = 0\n  while start < s.length\n    result << s[start, step]\n    start += step\n  end\n  result\nend",
    "  result = []\n  (0..s.length-1).step(step) { |i| result << s[i..i+step-1] }\n  result\nend",
    "  result = []\n  s.each_slice(step) { |a| result << a }\n  result\nend",
    "  result = []\n  s.each_slice(step) { |x| result << x }\n  result\nend"
  ]
}