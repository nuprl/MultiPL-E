name: HumanEval_149_sorted_list_sum
language: ts
prompt: "//Write a function that accepts an array of strings as a parameter,\n// deletes\
  \ the strings that have odd lengths from it,\n// and returns the resulted array\
  \ with a sorted order,\n// The array is always an array of strings and never an\
  \ array of numbers,\n// and it may contain duplicates.\n// The order of the array\
  \ should be ascending by length of each word, and you\n// should return the array\
  \ sorted by that rule.\n// If two words have the same length, sort the array alphabetically.\n\
  // The function should return an array of strings in sorted order.\n// You may assume\
  \ that all words will have the same length.\n// For example:\n// >>> list_sort([\"\
  aa\", \"a\", \"aaa\"])\n// [\"aa\"]\n// >>> list_sort([\"ab\", \"a\", \"aaa\", \"\
  cd\"])\n// [\"ab\", \"cd\"]\nfunction sorted_list_sum(lst: string[]): string[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = sorted_list_sum;\n  assert.deepEqual(candidate([\"\
  aa\", \"a\", \"aaa\"]),[\"aa\"]);\n  assert.deepEqual(candidate([\"school\", \"\
  AI\", \"asdf\", \"b\"]),[\"AI\", \"asdf\", \"school\"]);\n  assert.deepEqual(candidate([\"\
  d\", \"b\", \"c\", \"a\"]),[]);\n  assert.deepEqual(candidate([\"d\", \"dcba\",\
  \ \"abcd\", \"a\"]),[\"abcd\", \"dcba\"]);\n  assert.deepEqual(candidate([\"AI\"\
  , \"ai\", \"au\"]),[\"AI\", \"ai\", \"au\"]);\n  assert.deepEqual(candidate([\"\
  a\", \"b\", \"b\", \"c\", \"c\", \"a\"]),[]);\n  assert.deepEqual(candidate([\"\
  aaaa\", \"bbbb\", \"dd\", \"cc\"]),[\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\n\n\
  test();"
completions: ["  const sorted = lst.sort((a, b) => a.length - b.length);\n  return\
    \ sorted.sort((a, b) => a.localeCompare(b));\n}\n", "  const newArr: string[]\
    \ = [];\n  for (let i = 0; i < lst.length; i++) {\n    const word = lst[i];\n\
    \    if (newArr.indexOf(word) === -1) {\n      newArr.push(word);\n    }\n  }\n\
    \  newArr.sort();\n  return newArr;\n}\n", "  const sorted: number[] = [];\n \
    \ for (let i = 0; i < lst.length; i++) {\n    sorted.push(lst[i].length);\n  }\n\
    \  sorted.sort((a, b) => a - b);\n  const result: string[] = [];\n  for (let i\
    \ = 0; i < sorted.length; i++) {\n    for (let j = 0; j < lst.length; j++) {\n\
    \      if (sorted[i] === lst[j].length) {\n        result.push(lst[j]);\n    \
    \  }\n    }\n  }\n  return result;\n}\n", "  let sorted_lst: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length != lst[i + 1].length)\
    \ {\n      sorted_lst.push(lst[i]);\n    } else {\n      sorted_lst.push(lst[i]);\n\
    \    }\n  }\n  sorted_lst.sort();\n  return sorted_lst;\n}\n", "  const sorted\
    \ = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return a.localeCompare(b);\n\
    \    }\n    return a.length - b.length;\n  });\n  return sorted;\n}\n", "  const\
    \ sorted = lst.sort((a, b) => {\n    if (a.length === b.length) {\n      return\
    \ a.localeCompare(b);\n    }\n    return a.length - b.length;\n  });\n  return\
    \ sorted;\n}\n", "  const result: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const word = lst[i];\n    if (word.length % 2 === 1) {\n      result.push(word);\n\
    \    }\n  }\n  result.sort();\n  return result;\n}\n", "\tlet sorted: string[]\
    \ = [];\n\tfor (let i = 0; i < lst.length; i++) {\n\t\tlet word = lst[i];\n\t\t\
    let index = sorted.findIndex(x => x.includes(word));\n\t\tif (index === -1) {\n\
    \t\t\tsorted.push(word);\n\t\t} else {\n\t\t\tsorted[index] += word;\n\t\t}\n\t\
    }\n\tsorted = sorted.sort();\n\treturn sorted;\n}\n", "  const sorted = lst.sort((a,\
    \ b) => a.length - b.length);\n  return sorted.sort((a, b) => a > b);\n}\n", " \
    \ const result: string[] = [];\n  for (let i = 0; i < lst.length; i++) {\n   \
    \ if (lst[i].length % 2 !== 0) {\n      result.push(lst[i]);\n    }\n  }\n  result.sort();\n\
    \  return result;\n}\n", "  let sorted: string[] = [];\n  for (let i = 0; i <\
    \ lst.length; i++) {\n    if (lst[i].length < sorted[i].length) {\n      sorted\
    \ = lst;\n    }\n  }\n  return sorted;\n}\n", "  const result: string[] = [];\n\
    \  const map = new Map<string, number>();\n  for (const word of lst) {\n    const\
    \ key = word.length;\n    if (map.has(key)) {\n      map.set(key, map.get(key)\
    \ + 1);\n    } else {\n      map.set(key, 1);\n    }\n  }\n  for (const [key,\
    \ value] of map.entries()) {\n    if (value % 2 === 0) {\n      result.push(key);\n\
    \    }\n  }\n  return result.sort();\n}\n", "  const result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const word = lst[i];\n    if (result.length\
    \ === 0) {\n      result.push(word);\n    } else if (word.length !== result[result.length\
    \ - 1].length) {\n      result.push(word);\n    } else {\n      result[result.length\
    \ - 1].push(word);\n    }\n  }\n  return result.sort((a, b) => {\n    const aLen\
    \ = a.length;\n    const bLen = b.length;\n    if (aLen > bLen) {\n      return\
    \ 1;\n    } else if (aLen < bLen) {\n      return -1;\n    } else {\n      return\
    \ a.localeCompare(b);\n    }\n  });\n}\n", "\tconst sorted_list = lst.sort((a,\
    \ b) => {\n\t\tconst a_length = a.length;\n\t\tconst b_length = b.length;\n\t\t\
    if (a_length < b_length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (a_length > b_length)\
    \ {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\treturn sorted_list;\n}\n",
  "  const result: string[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if\
    \ (lst[i].length % 2 !== 0) {\n      result.push(lst[i]);\n    }\n  }\n  result.sort();\n\
    \  return result;\n}\n", "  const sorted: number[] = [];\n  for (let i = 0; i\
    \ < lst.length; i++) {\n    const word = lst[i];\n    const index = sorted.indexOf(word);\n\
    \    if (index === -1) {\n      sorted.push(word);\n    } else {\n      sorted[index]\
    \ += 1;\n    }\n  }\n  return sorted.sort((a, b) => b.length - a.length);\n}\n",
  "  const sorted = lst.sort((a, b) => a.length - b.length);\n  return sorted.sort((a,\
    \ b) => a.localeCompare(b));\n}\n", "  const sorted = lst\n    .map(word => word.length)\n\
    \    .sort((a, b) => a - b)\n    .map(length => lst.filter(word => word.length\
    \ === length))\n    .flat()\n    .sort();\n  return sorted;\n}\n", "  const sorted:\
    \ number[] = [];\n  const result: string[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    sorted.push(lst[i].length);\n  }\n  sorted.sort((a, b) => a - b);\n\
    \  for (let i = 0; i < sorted.length; i++) {\n    for (let j = 0; j < lst.length;\
    \ j++) {\n      if (sorted[i] === lst[j].length) {\n        result.push(lst[j]);\n\
    \      }\n    }\n  }\n  return result;\n}\n", "  const result: string[] = [];\n\
    \  const map = new Map<string, number>();\n  for (const word of lst) {\n    const\
    \ key = word.length;\n    if (map.has(key)) {\n      map.set(key, map.get(key)\
    \ + 1);\n    } else {\n      map.set(key, 1);\n    }\n  }\n  for (const [key,\
    \ value] of map) {\n    if (value % 2 === 0) {\n      result.push(key);\n    }\n\
    \  }\n  result.sort();\n  return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
