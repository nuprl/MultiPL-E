name: HumanEval_47_median
language: ts
prompt: "//Return median of elements in the array l.\n// >>> median([3, 1, 2, 4, 5])\n\
  // 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunction median(l: number[]):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4,\
  \ 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n\
  \  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1,\
  \ 3, 9, 9, 2, 7]),7);\n}\n\ntest();"
completions: ["  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n\
    \  const mid = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const\
    \ right = median(l.slice(mid));\n  return ((left + right) / 2) | 0;\n}\n", " \
    \ if (l.length === 0) {\n    throw new Error('Cannot compute median of an empty\
    \ array');\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
    \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
    \  const right = median(l.slice(half));\n  return left + right;\n}\n", "  if (l.length\
    \ % 2 === 0) {\n    return l[l.length / 2 - 1]\n  }\n  const mid = l.length /\
    \ 2\n  const left = l.slice(0, mid)\n  const right = l.slice(mid)\n  return median(left)\
    \ + median(right)\n}\n", "  if (l.length === 0) {\n    throw new Error(\"Cannot\
    \ calculate median of an empty array\");\n  }\n  const n = l.length;\n  if (n\
    \ % 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = n / 2;\n\
    \  const left = median(l.slice(0, half));\n  const right = median(l.slice(half));\n\
    \  return left + right / 2;\n}\n", "  if (l.length === 0) {\n    throw new Error(\"\
    Cannot calculate median of an empty array\");\n  }\n  const n = l.length;\n  if\
    \ (n % 2 === 0) {\n    return l[Math.floor(n / 2)];\n  }\n  const half = Math.floor(n\
    \ / 2);\n  return median(l.slice(0, half), l.slice(half));\n}\n", "  if (l.length\
    \ === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a\
    \ - b);\n  if (sorted.length % 2 === 0) {\n    return sorted[(sorted.length /\
    \ 2) - 1];\n  }\n  return sorted[Math.floor(sorted.length / 2)];\n}\n", "  if\
    \ (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
    \ array\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
    \ / 2)];\n  }\n  const half = n / 2;\n  let left = median(l.slice(0, half));\n\
    \  let right = median(l.slice(half));\n  return ((left + right) / 2) | 0;\n}\n",
  "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  const\
    \ left = l.slice(0, mid);\n  const right = l.slice(mid);\n  return median(left)\
    \ + median(right);\n}\n", "  if (l.length === 0) {\n    return NaN;\n  }\n  const\
    \ mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n\
    \  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
    \  return (left + right) / 2;\n}\n", "  if (l.length === 0) {\n    return NaN;\n\
    \  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n /\
    \ 2)];\n  }\n  const mid = Math.floor(n / 2);\n  const left = median(l.slice(0,\
    \ mid));\n  const right = median(l.slice(mid));\n  return Math.ceil((left + right)\
    \ / 2);\n}\n", "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length\
    \ / 2;\n  if (l.length % 2) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
    \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2)\
    \ | 0;\n}\n", "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate\
    \ median of an empty array\");\n  }\n  const sorted = l.slice().sort((a, b) =>\
    \ a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[(len\
    \ - 1) / 2];\n  }\n  const middle = Math.floor(len / 2);\n  const medianOfMiddle\
    \ = Math.floor(len / 2);\n  const medianOfMiddle2 = Math.floor(len / 2);\n  if\
    \ (sorted[middle] >= sorted[medianOfMiddle]) {\n    return sorted[middle];\n \
    \ }\n  if (sorted[middle] >= sorted[medianOfMiddle2]) {\n    return sorted[medianOfMiddle];\n\
    \  }\n  return sorted[medianOfMiddle2];\n}\n", "  if (l.length === 0) {\n    return\
    \ NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len =\
    \ sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n  }\n\
    \  const middle = Math.floor(len / 2);\n  const median1 = sorted[middle - 1];\n\
    \  const median2 = sorted[middle];\n  return (median1 + median2) / 2;\n}\n", " \
    \ if (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
    \ array\");\n  }\n  const n = l.length;\n  if (n % 2 === 0) {\n    return l[Math.floor(n\
    \ / 2)];\n  }\n  const half = n / 2;\n  const left = median(l.slice(0, half));\n\
    \  const right = median(l.slice(half));\n  return left + right;\n}\n", "  if (l.length\
    \ === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if (l.length\
    \ % 2) {\n    return l[mid];\n  }\n  const left = median(l.slice(0, mid));\n \
    \ const right = median(l.slice(mid));\n  return ((left + right) / 2) | 0;\n}\n",
  "  if (l.length === 0) {\n    return NaN;\n  }\n  const mid = l.length / 2;\n  if\
    \ (l.length % 2 === 0) {\n    return l[mid];\n  }\n  const left = median(l.slice(0,\
    \ mid));\n  const right = median(l.slice(mid));\n  return ((left + right) / 2);\n\
    }\n", "  if (l.length % 2 === 0) {\n    return l[Math.floor(l.length / 2)];\n\
    \  }\n  const mid = l.length / 2;\n  const left = l.slice(0, mid);\n  const right\
    \ = l.slice(mid);\n  return median(left) + median(right);\n}\n", "  if (l.length\
    \ === 0) {\n    throw new Error(\"Cannot calculate median of an empty array\"\
    );\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
    \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
    \  return ((left + right) / 2);\n}\n", "  if (l.length === 0) {\n    throw new\
    \ Error('Cannot calculate median of an empty array');\n  }\n  const sorted = l.slice().sort((a,\
    \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
    \ sorted[(len - 1) / 2];\n  }\n  const middle = Math.floor(len / 2);\n  const\
    \ median1 = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1\
    \ + median2) / 2;\n}\n", "  if (l.length === 0) {\n    throw new Error(\"Cannot\
    \ calculate median of an empty array\");\n  }\n  const sortedArray = l.slice().sort((a,\
    \ b) => a - b);\n  const mid = sortedArray.length / 2;\n  if (sortedArray.length\
    \ % 2 === 0) {\n    return sortedArray[mid];\n  }\n  return sortedArray[mid] +\
    \ sortedArray[mid + 1];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
