name: HumanEval_61_correct_bracketing
language: ts
prompt: "//brackets is a string of \"(\" and \")\".\n// return true if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
  )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
  (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunction correct_bracketing(brackets:\
  \ string): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"\
  ()\"),true);\n  assert.deepEqual(candidate(\"(()())\"),true);\n  assert.deepEqual(candidate(\"\
  ()()(()())()\"),true);\n  assert.deepEqual(candidate(\"()()((()()())())(()()(()))\"\
  ),true);\n  assert.deepEqual(candidate(\"((()())))\"),false);\n  assert.deepEqual(candidate(\"\
  )(()\"),false);\n  assert.deepEqual(candidate(\"(\"),false);\n  assert.deepEqual(candidate(\"\
  ((((\"),false);\n  assert.deepEqual(candidate(\")\"),false);\n  assert.deepEqual(candidate(\"\
  (()\"),false);\n  assert.deepEqual(candidate(\"()()(()())())(()\"),false);\n  assert.deepEqual(candidate(\"\
  ()()(()())()))()\"),false);\n}\n\ntest();"
completions: ["\tlet stack: string[] = [];\n\tfor (let i = 0; i < brackets.length;\
    \ i++) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket === \"(\") {\n\t\t\t\
    stack.push(bracket);\n\t\t} else if (bracket === \")\") {\n\t\t\tif (stack.length\
    \ === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet opening = stack.pop();\n\
    \t\t\tif (opening !== bracket) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\
    \tif (stack.length > 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "\tlet\
    \ opening_brackets = brackets.split(\"\");\n\tlet closing_brackets = brackets.split(\"\
    \").reverse();\n\tlet opening_brackets_set = opening_brackets.reduce((acc, curr)\
    \ => {\n\t\tacc[curr] = true;\n\t\treturn acc;\n\t}, {});\n\tlet closing_brackets_set\
    \ = closing_brackets.reduce((acc, curr) => {\n\t\tacc[curr] = true;\n\t\treturn\
    \ acc;\n\t}, {});\n\tlet opening_brackets_keys = Object.keys(opening_brackets_set);\n\
    \tlet closing_brackets_keys = Object.keys(closing_brackets_set);\n\tfor (let i\
    \ = 0; i < opening_brackets_keys.length; i++) {\n\t\tlet opening_bracket = opening_brackets_keys[i];\n\
    \t\tlet closing_bracket = closing_brackets_keys[i];\n\t\tif (opening_bracket !==\
    \ closing_bracket) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\t\
    let opening_brackets: number[] = [];\n\tlet closing_brackets: number[] = [];\n\
    \tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\
    \t\tif (bracket.match(/[()]/)) {\n\t\t\topening_brackets.push(i);\n\t\t} else\
    \ if (bracket.match(/[)]/)) {\n\t\t\tclosing_brackets.push(i);\n\t\t}\n\t}\n\t\
    return (opening_brackets.length === closing_brackets.length);\n}\n", "\tlet stack:\
    \ string[] = [];\n\tlet opening_brackets: number[] = [];\n\tlet closing_brackets:\
    \ number[] = [];\n\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket\
    \ = brackets[i];\n\t\tif (bracket.match(/[()]/)) {\n\t\t\tstack.push(bracket);\n\
    \t\t\topening_brackets.push(i);\n\t\t} else if (bracket.match(/[)]/)) {\n\t\t\t\
    closing_brackets.push(i);\n\t\t}\n\t}\n\n\tfor (let i = 0; i < opening_brackets.length;\
    \ i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket\
    \ = closing_brackets[i];\n\t\tif (opening_bracket === closing_bracket) {\n\t\t\
    \tcontinue;\n\t\t}\n\t\tlet opening_brackets_count = opening_brackets.length;\n\
    \t\tlet closing_brackets_count = closing_brackets.length;\n\t\tlet opening_brackets_index\
    \ = opening_bracket;\n\t\tlet closing_brackets_index = closing_bracket;\n\t\t\
    while (opening_brackets_count > 0 && closing_brackets_count > 0) {\n\t\t\tlet\
    \ opening_brackets_index = opening_brackets[opening_brackets_index - 1];\n\t\t\
    \tlet closing_brackets_index = closing_brackets[closing_brackets_index - 1];\n\
    \t\t\tif (opening_brackets_index === closing_brackets_index) {\n\t\t\t\topening_brackets_count--;\n\
    \t\t\t\tclosing_brackets_count--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\
    \t}\n\t\tif (opening_brackets_count === 0 && closing_brackets_count === 0) {\n\
    \t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet opening_brackets\
    \ = brackets.split(\"(\");\n\tlet closing_brackets = brackets.split(\")\");\n\t\
    let opening_brackets_count = opening_brackets.length;\n\tlet closing_brackets_count\
    \ = closing_brackets.length;\n\n\tif (opening_brackets_count < closing_brackets_count)\
    \ {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < opening_brackets_count; i++)\
    \ {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket =\
    \ closing_brackets[i];\n\n\t\tif (opening_bracket !== closing_bracket) {\n\t\t\
    \treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "\tlet stack: string[] =\
    \ [];\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\
    \t\tif (bracket === \"(\") {\n\t\t\tstack.push(bracket);\n\t\t} else if (bracket\
    \ === \")\") {\n\t\t\tif (stack.length === 0) {\n\t\t\t\treturn false;\n\t\t\t\
    }\n\t\t\tlet opening = stack.pop();\n\t\t\tif (opening !== bracket) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.length === 0;\n}\n", "\tlet\
    \ opening_brackets = brackets.split(\"\");\n\tlet closing_brackets = brackets.split(\"\
    \").reverse();\n\tlet opening_brackets_count = opening_brackets.length;\n\tlet\
    \ closing_brackets_count = closing_brackets.length;\n\tfor (let i = 0; i < opening_brackets_count;\
    \ i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket\
    \ = closing_brackets[i];\n\t\tif (opening_bracket !== closing_bracket) {\n\t\t\
    \treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet opening_brackets: number[]\
    \ = [];\n\tlet closing_brackets: number[] = [];\n\tfor (let i = 0; i < brackets.length;\
    \ ++i) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket.match(/[()]/)) {\n\t\
    \t\topening_brackets.push(i);\n\t\t} else if (bracket.match(/[)]/)) {\n\t\t\t\
    closing_brackets.push(i);\n\t\t}\n\t}\n\tfor (let i = 0; i < opening_brackets.length;\
    \ ++i) {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet next_opening_bracket\
    \ = opening_brackets[i + 1] || brackets.length;\n\t\tlet next_closing_bracket\
    \ = closing_brackets[i + 1] || brackets.length;\n\t\tif (next_opening_bracket\
    \ < next_closing_bracket) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\
    }\n", "\tlet stack: string[] = [];\n\tfor (let i = 0; i < brackets.length; i++)\
    \ {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket === \"(\") {\n\t\t\tstack.push(bracket);\n\
    \t\t} else if (bracket === \")\") {\n\t\t\tif (stack.length === 0) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\tlet opening = stack.pop();\n\t\t\tif (opening !==\
    \ bracket) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.length >\
    \ 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n", "\tlet opening_brackets:\
    \ number[] = [];\n\tlet closing_brackets: number[] = [];\n\tfor (let i = 0; i\
    \ < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket.match(/[\\\
    (\\)]/)) {\n\t\t\topening_brackets.push(i);\n\t\t} else {\n\t\t\tclosing_brackets.push(i);\n\
    \t\t}\n\t}\n\tfor (let i = 0; i < opening_brackets.length; i++) {\n\t\tlet opening_bracket\
    \ = opening_brackets[i];\n\t\tlet closing_bracket = closing_brackets[i];\n\t\t\
    if (opening_bracket === closing_bracket) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\
    return true;\n}\n", "\tlet opening_brackets = brackets.split(\"\");\n\tlet closing_brackets\
    \ = brackets.split(\"\").reverse();\n\tlet opening_brackets_count = opening_brackets.length;\n\
    \tlet closing_brackets_count = closing_brackets.length;\n\tfor (let i = 0; i <\
    \ opening_brackets_count; i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\
    \t\tlet closing_bracket = closing_brackets[i];\n\t\tif (opening_bracket != closing_bracket)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet opening_brackets\
    \ = brackets.split(\"\");\n\tlet closing_brackets = brackets.split(\"\").reverse();\n\
    \tlet opening_brackets_count = opening_brackets.length;\n\tlet closing_brackets_count\
    \ = closing_brackets.length;\n\tfor (let i = 0; i < opening_brackets_count; i++)\
    \ {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket =\
    \ closing_brackets[i];\n\t\tif (opening_bracket !== closing_bracket) {\n\t\t\t\
    return false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet opening_brackets = brackets.split(\"\
    \");\n\tlet closing_brackets = brackets.split(\"\").reverse();\n\tlet opening_brackets_set\
    \ = opening_brackets.reduce((set, opening_bracket) => {\n\t\tset.add(opening_bracket);\n\
    \t\treturn set;\n\t}, new Set<string>());\n\tlet closing_brackets_set = closing_brackets.reduce((set,\
    \ closing_bracket) => {\n\t\tset.add(closing_bracket);\n\t\treturn set;\n\t},\
    \ new Set<string>());\n\treturn opening_brackets_set.size == closing_brackets_set.size;\n\
    }\n", "\tlet stack: string[] = [];\n\tlet opening_brackets: number[] = [];\n\t\
    let closing_brackets: number[] = [];\n\n\tfor (let i = 0; i < brackets.length;\
    \ i++) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket === \"(\") {\n\t\t\t\
    opening_brackets.push(i);\n\t\t} else if (bracket === \")\") {\n\t\t\tclosing_brackets.push(i);\n\
    \t\t}\n\t}\n\n\twhile (opening_brackets.length > 0) {\n\t\tlet opening_bracket\
    \ = opening_brackets.pop();\n\t\tlet closing_bracket = closing_brackets.pop();\n\
    \n\t\tif (opening_bracket === closing_bracket) {\n\t\t\tcontinue;\n\t\t}\n\n\t\
    \tstack.push(bracket);\n\t\tbracket = brackets[opening_bracket];\n\t\tif (bracket\
    \ === \"(\") {\n\t\t\topening_brackets.push(i);\n\t\t} else if (bracket === \"\
    )\") {\n\t\t\tclosing_brackets.push(i);\n\t\t}\n\t}\n\n\treturn (opening_brackets.length\
    \ === 0 && closing_brackets.length === 0);\n}\n", "\tlet stack: string[] = [];\n\
    \tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\
    \t\tif (bracket === \"(\") {\n\t\t\tstack.push(bracket);\n\t\t} else if (bracket\
    \ === \")\") {\n\t\t\tif (stack.length === 0) {\n\t\t\t\treturn false;\n\t\t\t\
    }\n\t\t\tlet opening = stack.pop();\n\t\t\tif (opening !== bracket) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.length > 0) {\n\t\treturn false;\n\
    \t}\n\treturn true;\n}\n", "\tlet opening_brackets = brackets.split(\"\");\n\t\
    let closing_brackets = brackets.split(\"\").reverse();\n\tlet opening_brackets_set\
    \ = opening_brackets.reduce((set, opening_bracket) => {\n\t\tset.add(opening_bracket);\n\
    \t\treturn set;\n\t}, new Set<string>());\n\tlet closing_brackets_set = closing_brackets.reduce((set,\
    \ closing_bracket) => {\n\t\tset.add(closing_bracket);\n\t\treturn set;\n\t},\
    \ new Set<string>());\n\treturn opening_brackets_set.size == closing_brackets_set.size;\n\
    }\n", "\tlet opening_brackets = brackets.split(\"\");\n\tlet closing_brackets\
    \ = brackets.split(\"\").reverse();\n\tfor (let i = 0; i < opening_brackets.length;\
    \ i++) {\n\t\tif (opening_brackets[i] !== closing_brackets[i]) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet opening_brackets: number[]\
    \ = [];\n\tlet closing_brackets: number[] = [];\n\n\tfor (let i = 0; i < brackets.length;\
    \ i += 1) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket === \"(\") {\n\t\t\
    \topening_brackets.push(i);\n\t\t} else if (bracket === \")\") {\n\t\t\tclosing_brackets.push(i);\n\
    \t\t}\n\t}\n\n\tif (opening_brackets.length !== closing_brackets.length) {\n\t\
    \treturn false;\n\t}\n\n\tfor (let i = 0; i < opening_brackets.length; i += 1)\
    \ {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket =\
    \ closing_brackets[i];\n\n\t\tif (opening_bracket === closing_bracket) {\n\t\t\
    \tcontinue;\n\t\t}\n\n\t\tlet opening_brackets_length = opening_brackets.length\
    \ - 1;\n\t\tlet closing_brackets_length = closing_brackets.length - 1;\n\n\t\t\
    let opening_brackets_index = opening_bracket;\n\t\tlet closing_brackets_index\
    \ = closing_bracket;\n\n\t\twhile (opening_brackets_index >= 0 && closing_brackets_index\
    \ >= 0) {\n\t\t\tif (opening_brackets[opening_brackets_index] === closing_brackets[closing_brackets_index])\
    \ {\n\t\t\t\topening_brackets_index -= 1;\n\t\t\t\tclosing_brackets_index -= 1;\n\
    \t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (opening_brackets_index\
    \ < 0 || closing_brackets_index < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet\
    \ opening_brackets_length = opening_brackets.length - 1;\n\t\tlet closing_brackets_length\
    \ = closing_brackets.length - 1;\n\n\t\tlet opening_brackets_index = opening_bracket;\n\
    \t\tlet closing_brackets_index = closing_bracket;\n\n\t\twhile (opening_brackets_index\
    \ >= 0 && closing_brackets_index >= 0) {\n\t\t\tif (opening_brackets[opening_brackets_index]\
    \ === closing_brackets[closing_brackets_index]) {\n\t\t\t\topening_brackets_index\
    \ -= 1;\n\t\t\t\tclosing_brackets_index -= 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\n\t\tif (opening_brackets_index < 0 || closing_brackets_index\
    \ < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet opening_brackets_length = opening_brackets.length\
    \ - 1;\n\t\tlet closing_brackets_length = closing_brackets.length", "\tlet opening_brackets\
    \ = brackets.split(\"(\");\n\tlet closing_brackets = brackets.split(\")\");\n\t\
    let opening_brackets_length = opening_brackets.length;\n\tlet closing_brackets_length\
    \ = closing_brackets.length;\n\tfor (let i = 0; i < opening_brackets_length; i++)\
    \ {\n\t\tif (closing_brackets_length < opening_brackets_length) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tif (opening_brackets[i] === closing_brackets[closing_brackets_length\
    \ - 1]) {\n\t\t\tclosing_brackets_length--;\n\t\t}\n\t}\n\treturn true;\n}\n",
  "\tlet opening_brackets = brackets.split(\"\");\n\tlet closing_brackets = brackets.split(\"\
    \").reverse();\n\tlet opening_brackets_length = opening_brackets.length;\n\tlet\
    \ closing_brackets_length = closing_brackets.length;\n\n\tfor (let i = 0; i <\
    \ opening_brackets_length; i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\
    \t\tlet closing_bracket = closing_brackets[i];\n\t\tif (opening_bracket !== closing_bracket)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
