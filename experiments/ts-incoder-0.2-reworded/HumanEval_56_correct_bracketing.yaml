name: HumanEval_56_correct_bracketing
language: ts
prompt: "//brackets is a string of \"<\" and \">\".\n// return true if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\"\
  )\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"\
  <<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunction correct_bracketing(brackets:\
  \ string): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"\
  <>\"),true);\n  assert.deepEqual(candidate(\"<<><>>\"),true);\n  assert.deepEqual(candidate(\"\
  <><><<><>><>\"),true);\n  assert.deepEqual(candidate(\"<><><<<><><>><>><<><><<>>>\"\
  ),true);\n  assert.deepEqual(candidate(\"<<<><>>>>\"),false);\n  assert.deepEqual(candidate(\"\
  ><<>\"),false);\n  assert.deepEqual(candidate(\"<\"),false);\n  assert.deepEqual(candidate(\"\
  <<<<\"),false);\n  assert.deepEqual(candidate(\">\"),false);\n  assert.deepEqual(candidate(\"\
  <<>\"),false);\n  assert.deepEqual(candidate(\"<><><<><>><>><<>\"),false);\n  assert.deepEqual(candidate(\"\
  <><><<><>><>>><>\"),false);\n}\n\ntest();"
completions: ["\tlet opening_brackets = brackets.split(\"\");\n\tlet closing_brackets\
    \ = brackets.split(\"\").reverse();\n\tlet opening_brackets_count = opening_brackets.length;\n\
    \tlet closing_brackets_count = closing_brackets.length;\n\tlet correct_bracketing\
    \ = true;\n\tfor (let i = 0; i < opening_brackets_count; i++) {\n\t\tif (closing_brackets_count\
    \ > i) {\n\t\t\tif (opening_brackets[i] != closing_brackets[i]) {\n\t\t\t\tcorrect_bracketing\
    \ = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn correct_bracketing;\n\
    }\n", "\tlet stack: string[] = [];\n\tfor (let i = 0; i < brackets.length; ++i)\
    \ {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket === \"<\") {\n\t\t\tstack.push(bracket);\n\
    \t\t} else if (bracket === \">\") {\n\t\t\tif (stack.length !== 1) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t} else {\n\t\t\tif (stack.length\
    \ !== 0 || bracket !== stack[stack.length - 1]) {\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn stack.length === 0;\n}\n", "\tlet open_brackets = brackets.split(\"\
    \");\n\tlet closed_brackets: string[] = [];\n\tfor (let i = 0; i < open_brackets.length;\
    \ i++) {\n\t\tlet open_bracket = open_brackets[i];\n\t\tif (open_bracket === \"\
    <\") {\n\t\t\tclosed_brackets.push(\"</\" + open_bracket.substr(1) + \">\");\n\
    \t\t} else {\n\t\t\tclosed_brackets.push(\"</\" + open_bracket + \">\");\n\t\t\
    }\n\t}\n\tlet open_brackets_string = open_brackets.join(\"\");\n\tlet closed_brackets_string\
    \ = closed_brackets.join(\"\");\n\treturn open_brackets_string === closed_brackets_string;\n\
    }\n", "\tlet stack: string[] = [];\n\tfor (let i = 0; i < brackets.length; ++i)\
    \ {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket === \"<\") {\n\t\t\tif (stack.length\
    \ !== 0) return false;\n\t\t\tstack.push(bracket);\n\t\t} else if (bracket ===\
    \ \">\") {\n\t\t\tif (stack.length !== 1) return false;\n\t\t\tstack.pop();\n\t\
    \t} else {\n\t\t\tif (stack.length !== 0) return false;\n\t\t}\n\t}\n\treturn\
    \ (stack.length === 0);\n}\n", "\tlet stack: string[] = [];\n\tfor (let i = 0;\
    \ i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket\
    \ === \"<\") {\n\t\t\tif (stack.length !== 0) return false;\n\t\t\tstack.push(bracket);\n\
    \t\t} else if (bracket === \">\") {\n\t\t\tif (stack.length !== 1) return false;\n\
    \t\t\tstack.pop();\n\t\t} else {\n\t\t\tif (stack.length !== 0) return false;\n\
    \t\t}\n\t}\n\treturn (stack.length === 0);\n}\n", "\tlet stack: string[] = [];\n\
    \tlet opening_brackets: number[] = [];\n\tlet closing_brackets: number[] = [];\n\
    \tfor (let i = 0; i < brackets.length; ++i) {\n\t\tlet bracket = brackets[i];\n\
    \t\tif (bracket.match(/</)) {\n\t\t\tstack.push(bracket);\n\t\t\topening_brackets.push(i);\n\
    \t\t} else if (bracket.match(/>/)) {\n\t\t\tif (stack.length == 0) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t\tlet opening_bracket = opening_brackets.pop();\n\t\
    \t\tclosing_brackets.push(opening_bracket);\n\t\t\tstack.splice(opening_bracket,\
    \ 1);\n\t\t} else if (bracket.match(/>/>/)) {\n\t\t\tif (stack.length == 0) {\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet opening_bracket = opening_brackets.pop();\n\
    \t\t\tclosing_brackets.push(opening_bracket);\n\t\t\tstack.splice(opening_bracket,\
    \ 1);\n\t\t\tstack.push(bracket);\n\t\t} else if (bracket.match(/>/)) {\n\t\t\t\
    if (stack.length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet opening_bracket\
    \ = opening_brackets.pop();\n\t\t\tclosing_brackets.push(opening_bracket);\n\t\
    \t\tstack.push(bracket);\n\t\t} else if (bracket.match(/</)) {\n\t\t\tif (stack.length\
    \ == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet opening_bracket = opening_brackets.pop();\n\
    \t\t\tclosing_brackets.push(opening_bracket);\n\t\t\tstack.push(bracket);\n\t\t\
    } else if (bracket.match(/</)) {\n\t\t\tif (stack.length == 0) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\tlet opening_bracket = opening_brackets.pop();\n\t\t\t\
    closing_brackets.push(opening_bracket);\n\t\t\tstack.push(bracket);\n\t\t} else\
    \ if (bracket.match(/>/>/)) {\n\t\t\tif (stack.length == 0) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\tlet opening_bracket = opening_brackets.pop();\n\t\t\t\
    closing_brackets.push(opening_bracket);\n\t\t\tstack.push(bracket);\n\t\t} else\
    \ if (bracket.match(/>/)) {\n\t\t\tif (stack.length == 0) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\tlet opening_bracket = opening_brackets.pop();\n\t\t\tclosing_brackets.push(opening_bracket);\n\
    \t\t\tstack.push(bracket);\n\t\t} else if (bracket.match(/</)) {\n\t\t\tif (stack.length\
    \ == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet opening_bracket = opening_brackets.pop();\n\
    \t\t\tclosing_brackets.push(opening_bracket", "\tlet stack: string[] = [];\n\t\
    for (let i = 0; i < brackets.length; ++i) {\n\t\tlet bracket = brackets[i];\n\t\
    \tif (bracket === \"<\") {\n\t\t\tstack.push(bracket);\n\t\t} else if (bracket\
    \ === \">\") {\n\t\t\tif (stack.length === 0) {\n\t\t\t\treturn false;\n\t\t\t\
    }\n\t\t\tlet opening = stack.pop();\n\t\t\tif (opening !== bracket) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.length > 0) {\n\t\treturn false;\n\
    \t}\n\treturn true;\n}\n", "\tlet opening_brackets = brackets.split(\"\");\n\t\
    let closing_brackets = brackets.split(\"\").reverse();\n\tfor (let i = 0; i <\
    \ opening_brackets.length; i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\
    \t\tlet closing_bracket = closing_brackets[i];\n\t\tif (opening_bracket != closing_bracket)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet stack: string[]\
    \ = [];\n\tlet opening_brackets: number[] = [];\n\tlet closing_brackets: number[]\
    \ = [];\n\tfor (let i = 0; i < brackets.length; ++i) {\n\t\tlet bracket = brackets[i];\n\
    \t\tif (bracket === \"<\") {\n\t\t\tstack.push(bracket);\n\t\t\topening_brackets.push(i);\n\
    \t\t} else if (bracket === \">\") {\n\t\t\tlet start = opening_brackets.pop();\n\
    \t\t\tlet end = i;\n\t\t\twhile (opening_brackets.length > 0) {\n\t\t\t\tlet opening\
    \ = opening_brackets.pop();\n\t\t\t\tif (opening < start) {\n\t\t\t\t\tend = opening;\n\
    \t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosing_brackets.push(end);\n\
    \t\t}\n\t}\n\tfor (let i = 0; i < opening_brackets.length; ++i) {\n\t\tlet opening\
    \ = opening_brackets[i];\n\t\tlet end = closing_brackets[i];\n\t\tif (opening\
    \ > end) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet opening_brackets:\
    \ string[] = [];\n\tlet closing_brackets: string[] = [];\n\n\tbrackets.split('<').forEach((bracket:\
    \ string) => {\n\t\tlet opening = bracket.substr(0, 1);\n\t\tlet closing = bracket.substr(1,\
    \ 1);\n\n\t\tif (opening === closing) {\n\t\t\topening_brackets.push(opening);\n\
    \t\t\tclosing_brackets.push(closing);\n\t\t}\n\t});\n\n\treturn opening_brackets.length\
    \ === closing_brackets.length;\n}\n", "\tlet opening_brackets: number[] = [];\n\
    \tlet closing_brackets: number[] = [];\n\tfor (let i = 0; i < brackets.length;\
    \ ++i) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket.match(/[<>]/)) {\n\t\
    \t\topening_brackets.push(i);\n\t\t} else if (bracket.match(/[<>]/)) {\n\t\t\t\
    closing_brackets.push(i);\n\t\t}\n\t}\n\tif (opening_brackets.length !== closing_brackets.length)\
    \ {\n\t\treturn false;\n\t}\n\tfor (let i = 0; i < opening_brackets.length; ++i)\
    \ {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket =\
    \ closing_brackets[i];\n\t\tif (opening_bracket > closing_bracket) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet stack: string[] = [];\n\tfor\
    \ (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\t\t\
    if (bracket.match(/[<>]/)) {\n\t\t\tstack.push(bracket);\n\t\t} else if (bracket.match(/<>/))\
    \ {\n\t\t\tif (stack.length > 0 && stack[stack.length - 1] === bracket) {\n\t\t\
    \t\tstack.pop();\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\
    \t\t\treturn false;\n\t\t}\n\t}\n\treturn stack.length === 0;\n}\n", "\tlet opening_brackets\
    \ = brackets.split(\"\");\n\tlet closing_brackets = brackets.split(\"\").reverse();\n\
    \tlet opening_brackets_set = opening_brackets.reduce((set, opening_bracket) =>\
    \ {\n\t\tset.add(opening_bracket);\n\t\treturn set;\n\t}, new Set<string>());\n\
    \tlet closing_brackets_set = closing_brackets.reduce((set, closing_bracket) =>\
    \ {\n\t\tset.add(closing_bracket);\n\t\treturn set;\n\t}, new Set<string>());\n\
    \treturn opening_brackets_set.size == closing_brackets_set.size;\n}\n", "\tlet\
    \ stack: string[] = [];\n\tfor (let i = 0; i < brackets.length; ++i) {\n\t\tlet\
    \ c = brackets[i];\n\t\tif (c == '<') {\n\t\t\tstack.push(c);\n\t\t} else if (c\
    \ == '>') {\n\t\t\tif (stack.length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\
    \t\tlet top = stack.pop();\n\t\t\tif (top != c) {\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t}\n\t}\n\tif (stack.length != 0) {\n\t\treturn false;\n\t}\n\treturn\
    \ true;\n}\n", "\tlet opening_brackets: number[] = [];\n\tlet closing_brackets:\
    \ number[] = [];\n\tfor (let i = 0; i < brackets.length; ++i) {\n\t\tlet bracket\
    \ = brackets[i];\n\t\tif (bracket === \"<\") {\n\t\t\topening_brackets.push(i);\n\
    \t\t} else if (bracket === \">\") {\n\t\t\tclosing_brackets.push(i);\n\t\t}\n\t\
    }\n\tfor (let i = 0; i < opening_brackets.length; ++i) {\n\t\tlet opening_bracket\
    \ = opening_brackets[i];\n\t\tlet closing_bracket = closing_brackets[i];\n\t\t\
    if (opening_bracket === closing_bracket) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\
    return true;\n}\n", "\tlet stack: string[] = [];\n\tfor (let i = 0; i < brackets.length;\
    \ i++) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket === \"<\") {\n\t\t\t\
    if (stack.length > 0) {\n\t\t\t\tlet last = stack[stack.length - 1];\n\t\t\t\t\
    if (last === \"<\") {\n\t\t\t\t\tstack.pop();\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(bracket);\n\
    \t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstack.push(bracket);\n\t\t\t}\n\t\t} else if\
    \ (bracket === \">\") {\n\t\t\tif (stack.length > 0) {\n\t\t\t\tlet last = stack[stack.length\
    \ - 1];\n\t\t\t\tif (last === \">\") {\n\t\t\t\t\tstack.pop();\n\t\t\t\t} else\
    \ {\n\t\t\t\t\tstack.push(bracket);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstack.push(bracket);\n\
    \t\t\t}\n\t\t} else {\n\t\t\tstack.push(bracket);\n\t\t}\n\t}\n\treturn stack.length\
    \ === 0;\n}\n", "\tlet stack: string[] = [];\n\tfor (let i = 0; i < brackets.length;\
    \ ++i) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket.match(/[<>]/)) {\n\t\
    \t\tif (stack.length && stack[stack.length - 1] === bracket) {\n\t\t\t\tstack.pop();\n\
    \t\t\t} else {\n\t\t\t\tstack.push(bracket);\n\t\t\t}\n\t\t} else {\n\t\t\tif\
    \ (stack.length && stack[stack.length - 1] === bracket) {\n\t\t\t\tstack.pop();\n\
    \t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn !stack.length;\n\
    }\n", "\tlet stack: string[] = [];\n\tfor (let i = 0; i < brackets.length; ++i)\
    \ {\n\t\tlet c = brackets[i];\n\t\tif (c == '<') {\n\t\t\tstack.push(c);\n\t\t\
    } else if (c == '>') {\n\t\t\tif (stack.length == 0) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t\tlet top = stack.pop();\n\t\t\tif (top != c) {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn stack.length == 0;\n}\n", "\tlet stack: string[]\
    \ = [];\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\
    \t\tif (bracket === \"<\") {\n\t\t\tstack.push(bracket);\n\t\t} else if (bracket\
    \ === \">\") {\n\t\t\tif (stack.length === 0) {\n\t\t\t\treturn false;\n\t\t\t\
    }\n\t\t\tlet opening = stack.pop();\n\t\t\tif (opening !== bracket) {\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;\n}\n", "\tlet opening_brackets: string[] = brackets.split(\"\");\n\tlet\
    \ closing_brackets: string[] = brackets.split(\"\");\n\tlet opening_brackets_length:\
    \ number = opening_brackets.length;\n\tlet closing_brackets_length: number = closing_brackets.length;\n\
    \tlet i: number;\n\tlet j: number;\n\tlet opening_bracket: string;\n\tlet closing_bracket:\
    \ string;\n\tlet opening_brackets_set: Set<string>;\n\tlet closing_brackets_set:\
    \ Set<string>;\n\tlet opening_brackets_set_length: number;\n\tlet closing_brackets_set_length:\
    \ number;\n\tlet opening_brackets_set_length_set: Set<number>;\n\tlet closing_brackets_set_length_set:\
    \ Set<number>;\n\tlet opening_brackets_set_length_min: number;\n\tlet closing_brackets_set_length_min:\
    \ number;\n\tlet opening_brackets_set_length_max: number;\n\tlet closing_brackets_set_length_max:\
    \ number;\n\tlet opening_brackets_set_length_min_inclusive: boolean;\n\tlet closing_brackets_set_length_min_inclusive:\
    \ boolean;\n\tlet opening_brackets_set_length_max_exclusive: boolean;\n\tlet closing_brackets_set_length_max_exclusive:\
    \ boolean;\n\tlet opening_brackets_set_length_min_inclusive_inclusive: boolean;\n\
    \tlet closing_brackets_set_length_min_inclusive_inclusive: boolean;\n\tlet opening_brackets_set_length_max_exclusive_inclusive:\
    \ boolean;\n\tlet closing_brackets_set_length_max_exclusive_inclusive: boolean;\n\
    \tlet opening_brackets_set_length_min_inclusive_exclusive: boolean;\n\tlet closing_brackets_set_length_min_inclusive_exclusive:\
    \ boolean;\n\tlet opening_brackets_set_length_max_inclusive: boolean;\n\tlet closing_brackets_set_length_max_inclusive:\
    \ boolean;\n\tlet opening_brackets_set_length_min_inclusive_inclusive_inclusive:\
    \ boolean;\n\tlet closing_brackets_set_length_min_inclusive_inclusive_inclusive:\
    \ boolean;\n\tlet opening_brackets_set_length_max_exclusive_inclusive_inclusive:\
    \ boolean;\n\tlet closing_brackets_set_length_max_exclusive_inclusive_inclusive:\
    \ boolean;"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
