name: HumanEval_49_modp
language: ts
prompt: "//Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n\
  // >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n//\
  \ 8\n// >>> modp(100, 101)\n// 1\nfunction modp(n: number, p: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101,\
  \ 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3,\
  \ 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30,\
  \ 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"
completions: ["  if (n < p) {\n    return n;\n  }\n  return n % p;\n}\n", "  if (n\
    \ < p) {\n    return n;\n  }\n  return n % p;\n}\n", "  if (n < p) {\n    return\
    \ n;\n  }\n  if (n === p || n !== n) {\n    return n;\n  }\n  if (n === (p | 0))\
    \ {\n    return p;\n  }\n  if (n === (p + p | 0)) {\n    return (p + p | 0);\n\
    \  }\n  if (n === (p | 0) - 1) {\n    return p;\n  }\n  if (n === (p + p | 0)\
    \ - 1) {\n    return (p + p | 0);\n  }\n  if (n === (p | 0) - 2) {\n    return\
    \ p;\n  }\n  if (n === (p + p | 0) - 2) {\n    return (p + p | 0);\n  }\n  if\
    \ (n === (p | 0) - 3) {\n    return p;\n  }\n  if (n === (p + p | 0) - 3) {\n\
    \    return (p + p | 0);\n  }\n  if (n === (p | 0) - 4) {\n    return p;\n  }\n\
    \  if (n === (p + p | 0) - 4) {\n    return (p + p | 0);\n  }\n  if (n === (p\
    \ | 0) - 5) {\n    return p;\n  }\n  if (n === (p + p | 0) - 5) {\n    return\
    \ (p + p | 0);\n  }\n  if (n === (p | 0) - 6) {\n    return p;\n  }\n  if (n ===\
    \ (p + p | 0) - 6) {\n    return (p + p | 0);\n  }\n  if (n === (p | 0) - 7) {\n\
    \    return p;\n  }\n  if (n === (p + p | 0) - 7) {\n    return (p + p | 0);\n\
    \  }\n  if (n === (p | 0) - 8) {\n    return p;\n  }\n  if (n === (p + p | 0)\
    \ - 8) {\n    return (p + p | 0);\n  }\n  if (n === (p | 0) - 9) {\n    return\
    \ p;\n  }\n  if (n === (p + p | 0) - 9) {\n    return (p + p | 0);\n  }\n  if\
    \ (n === (p | 0) - 10) {\n    return p;\n  }\n  if (n === (p + p | 0) - 10) {\n\
    \    return (p + p | 0);\n  }\n  if (n === (p | 0) - 11) {\n    return p;\n  }\n\
    \  if (n === (p + p | 0) - 11) {\n    return (p + p | 0);\n  }\n  return n;\n\
    }\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  let res =\
    \ 1;\n  for (let i = 0; i < p; i++) {\n    res *= n;\n  }\n  return res;\n}\n",
  "  if (n < p) {\n    return n;\n  }\n  if (n === p) {\n    return n;\n  }\n  if\
    \ (n < 1) {\n    return 1;\n  }\n  if (n > 1) {\n    return modp(n - 1, p);\n\
    \  }\n  return p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n\
    }\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  let res =\
    \ 1;\n  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return\
    \ res;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if\
    \ (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  return ((n % p) + p)\
    \ % p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  return n % p;\n}\n", "  return\
    \ ((n % p) + p) % p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  let r = n -\
    \ (n & p);\n  return (r & p) | (r & ~p);\n}\n", "  if (n < p) {\n    return n\
    \ - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  if (n ===\
    \ p || n === p % p) {\n    return n;\n  }\n  if (n % p === 0) {\n    return p;\n\
    \  }\n  if (p * p < n) {\n    return p + (n - p);\n  }\n  if (p % p === 0) {\n\
    \    return p;\n  }\n  return modp(p - 1, p);\n}\n", "  if (n < p) {\n    return\
    \ n - p;\n  }\n  return p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++)\
    \ {\n    res *= n;\n  }\n  return res;\n}\n", "  return ((n % p) + p) % p;\n}\n",
  "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n  \
    \  return n;\n  }\n  if (n > p) {\n    return p;\n  }\n  if (n === p) {\n    return\
    \ 0;\n  }\n  return ((n % p) + p) % p;\n}\n", "  if (n < p) {\n    return n;\n\
    \  }\n  return n % p;\n}\n", "  let r = p % n;\n  return r === 0 ? n : r;\n}\n",
  "  let res = 1;\n  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n\
    \  return res;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  return ((n % p) +\
    \ p) % p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", " \
    \ if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  let res = 1;\n \
    \ for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n\
    }\n", "  if (n < p) {\n    return p;\n  }\n\n  return n % p;\n}\n", "  if (n <\
    \ p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return\
    \ n - p;\n  }\n  return p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++)\
    \ {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", "  if (n < p) {\n   \
    \ return n;\n  }\n  let r = n % (p - 1); // The remainder is less than our modulus\n\
    \  if (r < 0) {\n    return p + r;\n  }\n  return r;\n}\n", "  let res = 1;\n\
    \  for (let i = 0; i < p; i++) {\n    res *= n;\n  }\n  return res;\n}\n", " \
    \ let res = 1;\n  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n\
    \  return res;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  if (n < p) {\n  \
    \  return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return p;\n  }\n\
    \n  return n % p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  let r = n % (p\
    \ - 1); // The result will always be positive.\n  if (r < 0) {\n    return p +\
    \ 1;\n  }\n  return r;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return\
    \ p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if\
    \ (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  return ((n % p) + p)\
    \ % p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  let r = n - (p % n);\n  if\
    \ (r < 0) {\n    return p - r;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return\
    \ n - p;\n  }\n  return p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  let res\
    \ = 1;\n  for (let i = 0; i < p; i++) {\n    res *= n;\n  }\n  return res;\n}\n",
  "  let res = 1;\n  for (let i = 0; i < p; i++) {\n    res *= n;\n  }\n  return res;\n\
    }\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n    res = (res % n) +\
    \ n;\n  }\n  return res;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return\
    \ p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  return\
    \ ((n % p) + p) % p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n\
    \    res *= n;\n  }\n  return res;\n}\n", "  let res = 1;\n  for (let i = 0; i\
    \ < p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", "  if (n <\
    \ p) {\n    return n;\n  }\n  const r = n % p;\n  return r === 0 ? p : r + p;\n\
    }\n", "  return ((n % p) + p) % p;\n}\n", "  if (n < p) {\n    return n - p;\n\
    \  }\n  return p;\n}\n", "  if (n < p) {\n    return p;\n  }\n  if (n > p) {\n\
    \    return n;\n  }\n  return n % p;\n}\n", "  if (n < p) {\n    return n - p;\n\
    \  }\n  return p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  if (n === p) {\n\
    \    return n;\n  }\n  if (n < 1) {\n    return p;\n  }\n  if (n > 1) {\n    return\
    \ 1;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return\
    \ p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if\
    \ (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  let result = 1;\n \
    \ while (n > p) {\n    result *= n;\n    n -= p;\n  }\n  return result;\n}\n",
  "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  let res = 1;\n  for\
    \ (let i = 0; i < p; i++) {\n    res *= n;\n  }\n  return res;\n}\n", "  let r\
    \ = p % n;\n  return r === 0 ? n : r;\n}\n", "  let result = n;\n  while (result\
    \ % p !== 0) result /= p;\n  return result;\n}\n", "  let res = 1;\n  for (let\
    \ i = 0; i < p; i++) {\n    res *= n;\n  }\n  return res;\n}\n", "  if (n < p)\
    \ {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return p;\n\
    \  }\n  if (n > p) {\n    return n;\n  }\n  if (n === p) {\n    return 0;\n  }\n\
    \  return ((n % p) + p) % p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p;\
    \ i++) {\n    res *= n;\n  }\n  return res;\n}\n", "  if (n < p) {\n    return\
    \ n;\n  }\n  const r = n % p;\n  return r === 0 ? p : r === p ? r : n % p + p;\n\
    }\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p)\
    \ {\n    return n;\n  }\n  let r = 1;\n  for (let i = 1; i < p; i++) {\n    r\
    \ *= n;\n  }\n  return r % p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p;\
    \ i++) {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", "  if (n < p) {\n\
    \    return n;\n  }\n  if (n === p) {\n    return n;\n  }\n  if (n < 1) {\n  \
    \  return p;\n  }\n  if (n > 1) {\n    return 1;\n  }\n  return p;\n}\n", "  if\
    \ (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return\
    \ n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  if (n\
    \ === p) {\n    return n;\n  }\n  if (n < 1) {\n    return p;\n  }\n  if (n >\
    \ 1) {\n    return modp(n - 1, p);\n  }\n  return p;\n}\n", "  let res = 1;\n\
    \  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n\
    }\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n    res *= n;\n  }\n \
    \ return res;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n",
  "  let res = 1;\n  for (let i = 1; i <= n; i++) {\n    res = (res % p + p) % p;\n\
    \  }\n  return res;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  let res = 1;\n\
    \  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n\
    }\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  return ((n\
    \ % p) + p) % p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  if (n === p) {\n\
    \    return n;\n  }\n  if (n < 1) {\n    return p;\n  }\n  if (n > 1) {\n    return\
    \ 1;\n  }\n  return modp(n - 1, p);\n}\n", "  let r = p % n;\n  return r === 0\
    \ ? n : r;\n}\n", "  if (n < p) {\n    return n;\n  }\n  return n % p;\n}\n",
  "  let r = p % n;\n  return r === 0 ? r : n % r;\n}\n", "  if (n < p) {\n    return\
    \ n;\n  }\n  return n % p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  if (n\
    \ === p) {\n    return n;\n  }\n  if (n < 1) {\n    return p;\n  }\n  if (n >\
    \ 1) {\n    return 1;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return p;\n\
    \  }\n  if (n > p) {\n    return n;\n  }\n  if (n === p) {\n    return n;\n  }\n\
    \  if (n === p || n === p % p) {\n    return n;\n  }\n  if (n % p === 0) {\n \
    \   return p;\n  }\n  if (p % n === 0) {\n    return n;\n  }\n  if (p % n ===\
    \ 0 && n !== p) {\n    return n;\n  }\n  return modp(n - p, p);\n}\n", "  let\
    \ res = 1;\n  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n \
    \ return res;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n",
  "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  let res = 1;\n  for\
    \ (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n}\n",
  "  if (n < p) {\n    return n;\n  }\n  if (n === p) {\n    return n;\n  }\n  if\
    \ (n < 1) {\n    return 1;\n  }\n  if (n > p) {\n    return p;\n  }\n  if (n ===\
    \ 1) {\n    return 1;\n  }\n  if (n === p) {\n    return n;\n  }\n  if (n ===\
    \ 0 || n === 1) {\n    return n;\n  }\n  if (n === p) {\n    return n;\n  }\n\
    \  if (n % p === 0) {\n    return n % p;\n  }\n  if (n !== 0 && n % p === 0) {\n\
    \    return n / p;\n  }\n  if (n / p === 0) {\n    return n;\n  }\n  if (isEven(n))\
    \ {\n    return mod2(n);\n  }\n  if (isOdd(n)) {\n    return mod3(n);\n  }\n \
    \ return mod5(n);\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n  \
    \  res = (res % n) + n;\n  }\n  return res;\n}\n", "  let result = 1;\n  for (let\
    \ i = 0; i < p; i++) {\n    if (n % i == 0) {\n      result *= i;\n      result\
    \ %= p;\n    }\n  }\n  return result;\n}\n", "  if (n < p) {\n    return n - p;\n\
    \  }\n  return p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n  \
    \  res = (res % n) + n;\n  }\n  return res;\n}\n", "  if (n < p) {\n    return\
    \ n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  return\
    \ n % p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  let r = p % n;\n  return\
    \ r === 0 ? n : r;\n}\n", "  let result = 1;\n  for (let i = 0; i < p; i++) {\n\
    \    if (n % i == 0) {\n      result *= i;\n      result %= p;\n    }\n  }\n \
    \ return result;\n}\n", "  if (n < p) {\n    return n;\n  }\n  if (n === p) {\n\
    \    return n;\n  }\n  if (n === p || n === p % p) {\n    return n % p;\n  }\n\
    \  return NaN;\n}\n", "  if (n < p) {\n    return n;\n  }\n  if (n === p) {\n\
    \    return n;\n  }\n  if (n < 1) {\n    return p;\n  }\n  if (n > 1) {\n    return\
    \ 1;\n  }\n  return p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n\
    \    res = (res % n) + n;\n  }\n  return res;\n}\n", "  let res = 1;\n  for (let\
    \ i = 1; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", " \
    \ if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n \
    \   return n;\n  }\n  let r = n % (p - 1); // The remainder is less than our modulus,\
    \ but\n  // the difference is at most p, so it's safe to divide evenly.\n  //\
    \ If the remainder is larger than p, then we'll get an extra digit.\n  // That\
    \ will happen when n % p == 0, which happens when the remainder\n  // is exactly\
    \ half of p.\n  if (r == 0 || r == p / 2) {\n    return r;\n  }\n  return n %\
    \ p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  let r = n % (p - 1); // The\
    \ % operator in JavaScript returns the remainder of the division.\n  // If the\
    \ remainder is less than 0, the number is negative.\n  // If the remainder is\
    \ greater than 0, the number is positive.\n  // If r is 0, the number is 0.\n\
    \  // If r is 1, the number is 1.\n  // If r is -1, the number is -1.\n  // If\
    \ r is -2, the number is -2.\n  // If r is -3, the number is -3.\n  // If r is\
    \ -4, the number is -4.\n  // If r is -5, the number is -5.\n  // If r is -6,\
    \ the number is -6.\n  // If r is -7, the number is -7.\n  // If r is -8, the\
    \ number is -8.\n  // If r is -9, it is -6.\n  // If r is -10, it is -5.\n  //\
    \ If r is -11, it is -4.\n  // If r is -12, it is -3.\n  // If r is -13, the number\
    \ is -2.\n  // If r is -14, the number is -1.\n  // If r is -15, the number is\
    \ 0.\n  // If r is -16, the number is 1.\n  // If r is -17, the number is 2.\n\
    \  // If r is -18, the number is 3.\n  // If r is -19, the number is 4.\n  //\
    \ If r is -20, the number is 5.\n  // If r is -21, the number is 6.\n  // If r\
    \ is -22, the number is 7.\n  // If r is -23, the number is 8.\n  // If r is -24,\
    \ the number is 9.\n  // If r is -25, the number is 10.\n  // If r is -26, the\
    \ number is 11.\n  // If r is -27, the number is 12.\n  // If r is -28, the number\
    \ is 13.\n  // If r is -29, the number is 14.\n  // If r is -300, the number is\
    \ 15.\n  // If r is -301, the number is 16.\n  // If r is -302, the number is\
    \ 17.\n  // If r is -303, the number is 18.\n  // If r is -304, the number is\
    \ 19.\n  // If r is -305, the number is 20.\n  // If r is -306, the number is\
    \ 21.\n  // If r is -307, the number is 22.\n  // If r is -308, the number is\
    \ 23.\n  // If r is -309, the number is 24.\n  // If r is -310, the number is\
    \ 25.\n  // If r is -311, the number is 26.\n  // If r is -312, the number is\
    \ 27.\n  // If r is -313, the number is 28.\n  // If r is -314, the number is\
    \ 29.\n  // If r is -315, the number is 30.\n  // If r is -", "  if (n < p) {\n\
    \    return n;\n  }\n  let res = 1;\n  for (let i = 1; i < p; i++) {\n    res\
    \ *= n;\n  }\n  return res - 1;\n}\n", "  let res = 1;\n  for (let i = 0; i <\
    \ p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", "  if (n < p)\
    \ {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n\
    \ - p;\n  }\n  return p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++)\
    \ {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", "  if (n < p) {\n   \
    \ return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n;\n  }\n\
    \  const q = p / n;\n  const r = n % p;\n  return r === 0 ? q : q + modp(q, p);\n\
    }\n", "  if (n < p) {\n    return n;\n  }\n  let r = n % (p - 1); // The % operator\
    \ in JavaScript returns the remainder of the division.\n  // If the remainder\
    \ is negative then the number is negative.\n  // If the remainder is 0 then the\
    \ number is 0.\n  // If the number is positive then the number is positive.\n\
    \  // If the number is negative then the number is negative.\n  // If the number\
    \ is NaN then the number is NaN.\n  // If the number is Infinity then the number\
    \ is Infinity.\n  // If the number is -Infinity then the number is -Infinity.\n\
    \  // If the number is undefined then the number is undefined.\n  return (r >\
    \ 0) ? (r + 1) : r;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  if (n < p) {\n\
    \    return n;\n  }\n  if (n === p) {\n    return n;\n  }\n  if (n === p || n\
    \ === p - 1) {\n    return n;\n  }\n  if (n === p - 2) {\n    return n % p;\n\
    \  }\n  if (n % p === 0) {\n    return p;\n  }\n  if (p * p < n) {\n    return\
    \ p + (n - p);\n  }\n  if (p % 2 === 0) {\n    return p / 2;\n  }\n  return Math.ceil(p\
    \ * Math.pow(1 / p, 1 / 2));\n}\n", "  let r = 1;\n  while (p) {\n    if (p &\
    \ 1) r = r * n;\n    n >>= 1;\n    p >>= 1;\n  }\n  return r;\n}\n", "  if (n\
    \ < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return\
    \ n - p;\n  }\n  return p;\n}\n", "  let r = p % n;\n  return r === 0 ? n : r;\n\
    }\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n    res *= n;\n  }\n \
    \ return res;\n}\n", "  let r = p % n;\n  return r === 0 ? r : n % r;\n}\n", " \
    \ return ((n % p) + p) % p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++)\
    \ {\n    res *= n;\n  }\n  return res;\n}\n", "  return ((n % p) + p) % p;\n}\n",
  "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n  \
    \  return n;\n  }\n  return n % p;\n}\n", "  if (n < p) {\n    return n;\n  }\n\
    \  return n % p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n   \
    \ res = (res % n) + n;\n  }\n  return res;\n}\n", "  let res = 1;\n  for (let\
    \ i = 0; i < p; i++) {\n    res *= n;\n  }\n  return res;\n}\n", "  let result\
    \ = 1;\n  for (let i = 0; i < p; i++) {\n    result *= n;\n  }\n  return result\
    \ % p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if\
    \ (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return\
    \ n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return\
    \ p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  return\
    \ ((n % p) + p) % p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  let r = p %\
    \ n;\n  return r === 0 ? n : r;\n}\n", "  if (n < p) {\n    return n;\n  }\n \
    \ let r = n % (p - 1); // The % operator in JavaScript returns the remainder of\
    \ the division.\n  // If the remainder is nonzero, that means the number is not\
    \ divisible by p.\n  // So we need to check if r is zero before returning it.\n\
    \  // We use !! just in case r is undefined.\n  return !!r ? r : n % p;\n}\n",
  "  let res = 1;\n  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n\
    \  return res;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n",
  "  return ((n % p) + p) % p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++)\
    \ {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", "  if (n < p) {\n   \
    \ return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return p;\n  }\n\
    \  if (n > p) {\n    return n;\n  }\n  if (n === p) {\n    return 0;\n  }\n  if\
    \ (n === p || n === p % p) {\n    return n;\n  }\n  if (n % p === 0) {\n    return\
    \ p / p;\n  }\n  if (p % p === 0) {\n    return p / n;\n  }\n  return modp(p /\
    \ n, p);\n}\n", "  return ((n % p) + p) % p;\n}\n", "  let res = 1;\n  for (let\
    \ i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", " \
    \ let r = p % n;\n  return r === 0 ? n : r;\n}\n", "  let res = 1;\n  for (let\
    \ i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", " \
    \ if (n < p) {\n    return n;\n  }\n  let res = 1;\n  for (let i = 1; i < p; i++)\
    \ {\n    res *= n;\n  }\n  return res;\n}\n", "  return ((n % p) + p) % p;\n}\n",
  "  let res = 1;\n  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n\
    \  return res;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n",
  "  return ((n % p) + p) % p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  let res\
    \ = 1;\n  for (let i = 0; i < p; i++) {\n    res = (res % n) + n;\n  }\n  return\
    \ res;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  let\
    \ res = 1;\n  for (let i = 0; i < p; i++) {\n    res *= n;\n  }\n  return res;\n\
    }\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p)\
    \ {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n\
    \ - p;\n  }\n  return p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++)\
    \ {\n    res = (res % n) + n;\n  }\n  return res;\n}\n", "  if (n < p) {\n   \
    \ return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n    return n;\n  }\n\
    \  let r = p % n;\n  return r === 0 ? n : r;\n}\n", "  if (n < p) {\n    return\
    \ n;\n  }\n  const r = n % p;\n  return r === 0 ? p : r;\n}\n", "  if (n < p)\
    \ {\n    return n;\n  }\n  if (n === p) {\n    return n;\n  }\n  if (n < 1) {\n\
    \    return 1;\n  }\n  if (n > 1) {\n    return modp(n - 1, p);\n  }\n  return\
    \ p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if\
    \ (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  let result = 1;\n \
    \ for (let i = 0; i < p; i++) {\n    if (n & (1 << i)) {\n      result *= p;\n\
    \    }\n  }\n  return result;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n\
    \  return p;\n}\n", "  let res = 1;\n  for (let i = 0; i < p; i++) {\n    res\
    \ = (res % n) + n;\n  }\n  return res;\n}\n", "  return ((n % p) + p) % p;\n}\n",
  "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p) {\n  \
    \  return n;\n  }\n  let r = n % (p - 1); // The % operator in JavaScript returns\
    \ the remainder of the division.\n  // If the remainder is negative then the number\
    \ must be evenly divisible by p.\n  // If the remainder is positive then the number\
    \ must be odd and greater than p.\n  // In other words, a number x is divisible\
    \ by p if and only if x % p == 0.\n  // This means that x is divisible by p if\
    \ and only if x % 1 == 0.\n  // This also means that x is divisible by p if and\
    \ only if x % 2 == 0.\n  // This also means that x is divisible by p if and only\
    \ if x % 3 == 0.\n  // This also means that x is divisible by p if and only if\
    \ x % 4 == 0.\n  // This also means that x is divisible by p if and only if x\
    \ % 5 == 0.\n  // This also means that x is divisible by p if and only if x %\
    \ 6 == 0.\n  // This also means that x is divisible by p if and only if x % 7\
    \ == 0.\n  // This also means that x is divisible by p if and only if x % 8 ==\
    \ 0.\n  // This also means that x is divisible by p if and only if x % 9 == 0.\n\
    \  // This also means that x is divisible by p if and only if x % 10 == 0.\n \
    \ // This also means that x is divisible by p if and only if x % 11 == 0.\n  //\
    \ This also means that x is divisible by p if and only if x % 12 == 0.\n  // This\
    \ also means that x is divisible by p if and only if x % 13 == 0.\n  // This also\
    \ means that x is divisible by p if and only if x % 14 == 0.\n  // This also means\
    \ that x is divisible by p if and only if x % 15 == 0.\n  // This also means that\
    \ x is divisible by p if and only if x % 16 == 0.\n  // This also means that x\
    \ is divisible by p if and only if x % 17 == 0.\n  // This also means that x is\
    \ divisible by p if and only if x % 18 == 0.\n  // This also means that x is divisible\
    \ by p if and only if x % 19 == 0.\n  // This also means that x is divisible by\
    \ p if and only if x % 20 == 0.\n  // This also means that x is divisible by p\
    \ if and only if x % 21 == 0.\n  // This also means that x is divisible by p if\
    \ and only if x % 22 == 0.\n  // This also means that x is divisible by p if and\
    \ only if x % 23 == 0.\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n\
    }\n", "  if (n < p) {\n    return n - p;\n  }\n  return p;\n}\n", "  if (n < p)\
    \ {\n    return n;\n  }\n  let res = 1;\n  for (let i = 1; i < p; i++) {\n   \
    \ res *= n;\n  }\n  return res;\n}\n", "  return ((n % p) + p) % p;\n}\n", " \
    \ return ((n % p) + p) % p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n \
    \ return p;\n}\n", "  if (n < p) {\n    return n;\n  }\n  let r = n % (p - 1);\
    \ // r = ((n % p) + p) % p\n  if (r === 0) {\n    return p;\n  }\n  return r;\n\
    }\n", "  if (n < p) {\n    return n;\n  }\n  return n % p;\n}\n", "  if (n < p)\
    \ {\n    return n;\n  }\n  return n % p;\n}\n", "  if (n < p) {\n    return n\
    \ - p;\n  }\n  return p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  return\
    \ ((n % p) + p) % p;\n}\n", "  if (n < p) {\n    return n - p;\n  }\n  return\
    \ p;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
