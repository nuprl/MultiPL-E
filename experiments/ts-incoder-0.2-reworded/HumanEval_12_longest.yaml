name: HumanEval_12_longest
language: ts
prompt: "//Out of array of strings, return the longest one. Return the first one in\
  \ case of multiple\n// strings of the same length. Return undefined in case the\
  \ input array is empty.\n// >>> longest([])\n// undefined\n// >>> longest([\"a\"\
  , \"b\", \"c\"])\n// \"a\"\n// >>> longest([\"a\", \"bb\", \"ccc\"])\n// \"ccc\"\
  \nfunction longest(strings: string[]): string | undefined {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = longest;\n  assert.deepEqual(candidate([]),undefined);\n\
  \  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"x\");\n  assert.deepEqual(candidate([\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\");\n}\n\ntest();"
completions: ["  if (strings.length === 0) {\n    return undefined;\n  }\n  return\
    \ strings.reduce((prev, curr) => {\n    return prev.length > curr.length ? prev\
    \ : curr;\n  });\n}\n", "  if (strings.length === 0) {\n    return undefined;\n\
    \  }\n  return strings[0].length > strings[1].length ? strings[0] : strings[1];\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1];\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings.reduce(\n    (longest,\
    \ string) =>\n      string.length > longest.length ? string : longest,\n    strings[0]\n\
    \  );\n}\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return\
    \ strings.reduce(\n    (longest, string) =>\n      string.length > longest.length\
    \ ? string : longest,\n    strings[0]\n  );\n}\n", "  if (strings.length === 0)\
    \ {\n    return undefined;\n  }\n  return strings[0].length > strings[1].length\
    \ ? strings[0] : strings[1];\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n  return strings.reduce(\n    (longest, str) =>\n      str.length\
    \ > longest.length ? str : longest,\n    strings[0]\n  );\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings[0].length > strings[1].length\
    \ ? strings[0] : strings[1];\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n  return strings[0].length > strings[1].length ? strings[0]\
    \ : strings[1];\n}\n", "  if (strings.length === 0) {\n    return undefined;\n\
    \  }\n  return strings[0].length > strings[1].length ? strings[0] : strings[1];\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings.reduce(\n\
    \    (longest, str) =>\n      str.length > longest.length ? str : longest,\n \
    \   strings[0]\n  );\n}\n", "  if (strings.length === 0) {\n    return undefined;\n\
    \  }\n  return strings.reduce(\n    (longest, str) =>\n      str.length > longest.length\
    \ ? str : longest,\n    strings[0]\n  );\n}\n", "  if (strings.length === 0) {\n\
    \    return undefined;\n  }\n  return strings[0].length > strings[1].length ?\
    \ strings[0] : strings[1];\n}\n", "  if (strings.length === 0) {\n    return undefined;\n\
    \  }\n  return strings[0].length > strings[1].length ? strings[0] : strings[1];\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings.reduce((prev,\
    \ cur) => {\n    if (prev === undefined || prev.length < cur.length) {\n     \
    \ return cur;\n    }\n    return prev;\n  });\n}\n", "  if (strings.length ===\
    \ 0) {\n    return undefined;\n  }\n  return strings.reduce((prev, curr) => {\n\
    \    return prev.length > curr.length ? prev : curr;\n  });\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings[strings.length - 1].length\
    \ >= strings[0].length ? strings[strings.length - 1] : strings[0];\n}\n", "  if\
    \ (strings.length === 0) {\n    return undefined;\n  }\n  return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1];\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n\n  return strings.reduce(\n    (longest,\
    \ str) =>\n      str.length > longest.length ? str : longest,\n    strings[0]\n\
    \  );\n}\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n  return\
    \ strings[strings.length - 1].length >= strings[0].length ? strings[strings.length\
    \ - 1] : strings[0];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
