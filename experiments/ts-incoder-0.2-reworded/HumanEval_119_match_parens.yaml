name: HumanEval_119_match_parens
language: ts
prompt: "//You are given an array of two strings, both strings consist of open\n//\
  \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
  \ is possible to concatenate the two strings in\n// some order, that the resulting\
  \ string will be good.\n// A string S is considered to be good if and only if all\
  \ parentheses in S\n// are balanced. For example: the string '(())()' is good, while\
  \ the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good\
  \ string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([\"()(\"\
  , \")\"])\n// \"Yes\"\n// >>> match_parens([\")\", \")\"])\n// \"No\"\nfunction\
  \ match_parens(lst: string[]): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = match_parens;\n  assert.deepEqual(candidate([\"()(\"\
  , \")\"]),\"Yes\");\n  assert.deepEqual(candidate([\")\", \")\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  (()(())\", \"())())\"]),\"No\");\n  assert.deepEqual(candidate([\")())\", \"(()()(\"\
  ]),\"Yes\");\n  assert.deepEqual(candidate([\"(())))\", \"(()())((\"]),\"Yes\");\n\
  \  assert.deepEqual(candidate([\"()\", \"())\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  (()(\", \"()))()\"]),\"Yes\");\n  assert.deepEqual(candidate([\"((((\", \"((())\"\
  ]),\"No\");\n  assert.deepEqual(candidate([\")(()\", \"(()(\"]),\"No\");\n  assert.deepEqual(candidate([\"\
  )(\", \")(\"]),\"No\");\n  assert.deepEqual(candidate([\"(\", \")\"]),\"Yes\");\n\
  \  assert.deepEqual(candidate([\")\", \"(\"]),\"Yes\");\n}\n\ntest();"
completions: ["  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n   \
    \ if (lst[i] == \"(\") {\n      stack.push(i);\n    } else if (lst[i] == \")\"\
    ) {\n      if (stack.length === 0) {\n        return \"No\";\n      }\n      const\
    \ top = stack.pop();\n      if (top < i) {\n        return \"No\";\n      }\n\
    \    }\n  }\n  return \"Yes\";\n}\n", "  const stack: Stack<string> = new Stack<string>();\n\
    \  const result: string[] = [];\n  for (let i = 0; i < lst.length; i++) {\n  \
    \  const cur = lst[i];\n    if (stack.isEmpty()) {\n      stack.push(cur);\n \
    \     result.push(cur);\n    } else {\n      const top = stack.pop();\n      if\
    \ (top === ')') {\n        stack.push(cur);\n        result.push(cur);\n     \
    \ } else if (top === '(') {\n        stack.push(cur);\n        result.push(cur);\n\
    \      } else {\n        result.push(top);\n      }\n    }\n  }\n  return result.length\
    \ === lst.length ? \"Yes\" : \"No\";\n}\n", "  const stack = new Stack();\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n    if (char ===\
    \ '(') {\n      stack.push(char);\n    } else if (char === ')') {\n      if (stack.isEmpty())\
    \ {\n        return 'No';\n      }\n      const top = stack.pop();\n      if (top\
    \ !== char) {\n        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n",
  "  let stack: string[] = [];\n  let result: string = \"\";\n  for (let i = 0; i\
    \ < lst.length; i++) {\n    if (lst[i] == \"(\") {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] == \")\") {\n      if (stack.length == 0) {\n        return\
    \ \"No\";\n      }\n      stack.pop();\n    } else {\n      if (stack.length !=\
    \ 0) {\n        return \"No\";\n      }\n    }\n  }\n  if (stack.length != 0)\
    \ {\n    return \"No\";\n  }\n  return \"Yes\";\n}\n", "  let stack = [];\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] == \"(\") {\n      stack.push(i);\n\
    \    } else if (lst[i] == \")\") {\n      if (stack.length === 0) {\n        return\
    \ \"No\";\n      }\n      let top = stack.pop();\n      if (lst[top] != \")\"\
    ) {\n        return \"No\";\n      }\n    }\n  }\n  return \"Yes\";\n}\n", " \
    \ if (lst.length < 2) {\n    return \"No\";\n  }\n  let stack: number[] = [];\n\
    \  let index = 0;\n  while (index < lst.length) {\n    if (lst[index] === \"(\"\
    ) {\n      stack.push(index);\n    }\n    if (lst[index] === \")\") {\n      if\
    \ (stack.length === 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    }\n    index++;\n  }\n  if (stack.length === 0) {\n    return \"Yes\";\n\
    \  }\n  return \"No\";\n}\n", "  const stack: string[] = [];\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] === \"(\") {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] === \")\") {\n      if (stack.length === 0) {\n       \
    \ return \"No\";\n      }\n      stack.pop();\n    } else {\n      if (stack.length\
    \ === 0) {\n        return \"Yes\";\n      }\n    }\n  }\n  return \"No\";\n}\n",
  "  let stack: string[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ == \"(\") {\n      stack.push(\"(\");\n    } else if (lst[i] == \")\") {\n \
    \     if (stack.length == 0) {\n        return \"No\";\n      }\n      stack.pop();\n\
    \    } else {\n      if (stack.length != 0) {\n        return \"No\";\n      }\n\
    \    }\n  }\n  return \"Yes\";\n}\n", "  const stack = [];\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    const str = lst[i];\n    if (str === \"(\") {\n\
    \      stack.push(i);\n    } else if (str === \")\") {\n      if (stack.length\
    \ === 0) {\n        return \"No\";\n      }\n      const top = stack.pop();\n\
    \      if (top === i) {\n        return \"Yes\";\n      }\n    }\n  }\n  return\
    \ \"No\";\n}\n", "  let stack = [];\n  for (let i = 0; i < lst.length; i++) {\n\
    \    if (lst[i] == \"(\") {\n      stack.push(i);\n    } else if (lst[i] == \"\
    )\") {\n      if (stack.length === 0) {\n        return \"No\";\n      }\n   \
    \   stack.pop();\n    } else {\n      return \"No\";\n    }\n  }\n  return \"\
    Yes\";\n}\n", "  const stack = new Stack<string>();\n  const stack2 = new Stack<string>();\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == \"(\") {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] == \")\") {\n      while (!stack.isEmpty() && stack.peek()\
    \ != \"(\") {\n        stack2.push(stack.pop());\n      }\n      if (!stack2.isEmpty())\
    \ {\n        stack.push(stack2.pop());\n      } else {\n        return \"No\"\
    ;\n      }\n    }\n  }\n  while (!stack.isEmpty()) {\n    stack2.push(stack.pop());\n\
    \  }\n  return stack2.isEmpty() ? \"Yes\" : \"No\";\n}\n", "  let stack: number[]\
    \ = [];\n  let result: string = \"\";\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] == \"(\") {\n      stack.push(i);\n    } else if (lst[i] ==\
    \ \")\") {\n      if (stack.length == 0) {\n        return \"No\";\n      }\n\
    \      let top = stack.pop();\n      if (top < i) {\n        return \"No\";\n\
    \      }\n      result += lst[i];\n    }\n  }\n  return \"Yes\";\n}\n", "  const\
    \ stack: Stack<string> = new Stack<string>();\n  const result: string[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const str = lst[i];\n    if (str\
    \ === \"(\") {\n      stack.push(str);\n    } else if (str === \")\") {\n    \
    \  if (stack.length === 0) {\n        result.push(str);\n      } else {\n    \
    \    const top = stack.pop();\n        if (top !== str) {\n          result.push(str);\n\
    \        }\n      }\n    } else {\n      if (stack.length > 0) {\n        const\
    \ top = stack.pop();\n        if (top !== str) {\n          result.push(str);\n\
    \        }\n      }\n    }\n  }\n  return result.length === lst.length ? \"Yes\"\
    \ : \"No\";\n}\n", "  const stack = new Stack();\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const str = lst[i];\n    if (str === '(') {\n      stack.push(str);\n\
    \    } else if (str === ')') {\n      if (stack.isEmpty()) {\n        return 'No';\n\
    \      }\n      const top = stack.pop();\n      if (top !== str) {\n        return\
    \ 'No';\n      }\n    }\n  }\n  return 'Yes';\n}\n", "  let stack: string[] =\
    \ [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n  \
    \    stack.push(lst[i]);\n    } else if (lst[i] == ')') {\n      if (stack.length\
    \ == 0) {\n        return 'No';\n      }\n      let top = stack.pop();\n     \
    \ if (top != '(') {\n        return 'No';\n      }\n    }\n  }\n  return 'Yes';\n\
    }\n", "  let stack: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n\
    \    if (lst[i] == \"(\") {\n      stack.push(i);\n    } else if (lst[i] == \"\
    )\") {\n      if (stack.length === 0) {\n        return \"No\";\n      }\n   \
    \   let top = stack.pop();\n      if (top < i) {\n        return \"No\";\n   \
    \   }\n    }\n  }\n  return \"Yes\";\n}\n", "  let stack: string[] = [];\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] == \"(\") {\n      stack.push(lst[i]);\n\
    \    } else if (lst[i] == \")\") {\n      if (stack.length === 0) {\n        return\
    \ \"No\";\n      }\n      stack.pop();\n    } else {\n      if (stack.length ===\
    \ 0) {\n        return \"No\";\n      }\n    }\n  }\n  return \"Yes\";\n}\n",
  "  const stack: string[] = [];\n  let open = 0;\n  let close = 0;\n  for (let i\
    \ = 0; i < lst.length; i++) {\n    if (lst[i] == \"(\") {\n      open++;\n   \
    \ } else if (lst[i] == \")\") {\n      close++;\n    } else {\n      if (open\
    \ > close) {\n        return \"No\";\n      }\n      stack.push(lst[i]);\n   \
    \ }\n  }\n  if (open > close) {\n    return \"No\";\n  }\n  while (open > 0 &&\
    \ close > 0) {\n    if (stack.length < 2) {\n      return \"No\";\n    }\n   \
    \ if (stack[stack.length - 1] == \"(\") {\n      open--;\n    } else {\n     \
    \ close--;\n    }\n    stack.pop();\n  }\n  return \"Yes\";\n}\n", "  const stack:\
    \ Stack<string> = new Stack<string>();\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const str = lst[i];\n    if (str === \"(\") {\n      stack.push(str);\n\
    \    } else if (str === \")\") {\n      if (stack.isEmpty()) {\n        return\
    \ \"No\";\n      }\n      const top = stack.pop();\n      if (top !== str) {\n\
    \        return \"No\";\n      }\n    } else {\n      if (stack.isEmpty()) {\n\
    \        return \"No\";\n      }\n      const top = stack.pop();\n      if (top\
    \ !== str) {\n        return \"No\";\n      }\n    }\n  }\n  return \"Yes\";\n\
    }\n", "  const stack = [];\n  let index = 0;\n  while (index < lst.length) {\n\
    \    const char = lst[index];\n    if (char === '(') {\n      stack.push(char);\n\
    \    } else if (char === ')') {\n      if (stack.length === 0) {\n        return\
    \ 'No';\n      }\n      const top = stack.pop();\n      if (top === '(') {\n \
    \       stack.push(char);\n      } else {\n        return 'No';\n      }\n   \
    \ } else {\n      if (stack.length === 0) {\n        return 'No';\n      }\n \
    \     const top = stack.pop();\n      if (top === ')') {\n        stack.push(char);\n\
    \      } else {\n        return 'No';\n      }\n    }\n    index++;\n  }\n  return\
    \ 'Yes';\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
