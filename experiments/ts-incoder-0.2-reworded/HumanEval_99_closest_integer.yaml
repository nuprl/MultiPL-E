name: HumanEval_99_closest_integer
language: ts
prompt: "//Create a function that takes a value (string) representing a number\n//\
  \ and returns the closest integer to it. If the number is equidistant\n// from two\
  \ integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\"\
  )\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from\
  \ zero means that if the given number is equidistant\n// from two integers, the\
  \ one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunction closest_integer(value: string): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = closest_integer;\n  assert.deepEqual(candidate(\"\
  10\"),10);\n  assert.deepEqual(candidate(\"14.5\"),15);\n  assert.deepEqual(candidate(\"\
  -15.5\"),-16);\n  assert.deepEqual(candidate(\"15.3\"),15);\n  assert.deepEqual(candidate(\"\
  0\"),0);\n}\n\ntest();"
completions: ["  const [integer, decimal] = value.split(\".\");\n  const [integerPart,\
    \ decimalPart] = integer.split(\".\");\n  const [integerPart2, decimalPart2] =\
    \ decimal.split(\".\");\n\n  if (decimalPart === decimalPart2) {\n    return parseInt(integerPart,\
    \ 10);\n  }\n\n  const closest = Math.abs(decimalPart - decimalPart2);\n  const\
    \ closest2 = Math.abs(decimalPart - decimalPart2);\n  const closest3 = Math.abs(decimalPart\
    \ - decimalPart2);\n  const closest4 = Math.abs(decimalPart - decimalPart2);\n\
    \n  if (closest === closest2) {\n    return parseInt(integerPart, 10);\n  }\n\n\
    \  if (closest === closest3) {\n    return parseInt(integerPart, 10) + 1;\n  }\n\
    \n  if (closest === closest4) {\n    return parseInt(integerPart, 10) + 2;\n \
    \ }\n\n  return parseInt(integerPart, 10);\n}\n", "  const [integer1, integer2]\
    \ = value.split('.');\n  const [integer1int, integer2int] = [parseInt(integer1),\
    \ parseInt(integer2)];\n  if (Math.abs(integer1int - integer2int) < 1) {\n   \
    \ return integer1int;\n  }\n  return integer2int;\n}\n", "  const num = parseFloat(value);\n\
    \  const isNegative = num < 0;\n  const absNum = Math.abs(num);\n  let closestNum\
    \ = absNum;\n  if (absNum < 1) {\n    closestNum = Math.ceil(absNum);\n  } else\
    \ {\n    closestNum = Math.floor(absNum);\n  }\n  if (isNegative) {\n    closestNum\
    \ = -closestNum;\n  }\n  return closestNum;\n}\n", "  const num = Number(value);\n\
    \  const diff = Math.abs(num - Math.floor(num));\n  return diff < 0.5 ? Math.floor(num)\
    \ : Math.ceil(num);\n}\n", "  const [integer, decimal] = value.split('.')\n  const\
    \ [integer2, decimal2] = integer.split('.')\n  const [integer3, decimal3] = integer2.split('.')\n\
    \  const [integer4, decimal4] = integer3.split('.')\n  const [integer5, decimal5]\
    \ = integer4.split('.')\n  const [integer6, decimal6] = integer5.split('.')\n\
    \  const [integer7, decimal7] = integer6.split('.')\n  const [integer8, decimal8]\
    \ = integer7.split('.')\n  const [integer9, decimal9] = integer8.split('.')\n\
    \  const [integer10, decimal10] = integer9.split('.')\n  const [integer11, decimal11]\
    \ = integer10.split('.')\n  const [integer12, decimal12] = integer11.split('.')\n\
    \  const [integer13, decimal13] = integer12.split('.')\n  const [integer14, decimal14]\
    \ = integer13.split('.')\n  const [integer15, decimal15] = integer14.split('.')\n\
    \  const [integer16, decimal16] = integer15.split('.')\n  const [integer17, decimal17]\
    \ = integer16.split('.')\n  const [integer18, decimal18] = integer17.split('.')\n\
    \  const [integer19, decimal19] = integer18.split('.')\n  const [integer20, decimal20]\
    \ = integer19.split('.')\n  const [integer21, decimal21] = integer20.split('.')\n\
    \  const [integer22, decimal22] = integer21.split('.')\n  const [integer23, decimal23]\
    \ = integer22.split('.')\n  const [integer24, decimal24] = integer23.split('.')\n\
    \  const [integer25, decimal25] = integer24.split('.')\n  const [integer26, decimal26]\
    \ = integer25.split('.')\n  const [integer27, decimal27] = integer26.split('.')\n\
    \  const [integer28, decimal28] = integer27.split('.')\n  const [integer29, decimal29]\
    \ = integer28.split('.')\n  const [integer30, decimal30] = integer29.split('.')\n\
    \  const [integer31, decimal31] = integer30.split('.')\n  const [integer32, decimal32]\
    \ = integer31.split('.')\n  const [integer33, decimal33] = integer32.split('.')\n\
    \  const [integer34, decimal34] = integer33.split('.')\n  const [integer35, decimal35]\
    \ = integer34.split('.')\n  const [integer36, decimal36] = integer35.split('.')\n\
    \  const [integer37, decimal37] = integer36.split('.')\n  const [integer38, decimal38]\
    \ = integer37.split('.')\n  const [integer39, decimal39] = integer38.split('.')\n\
    \  const [integer40, decimal40] = integer39.split('.')\n  const [integer41, decimal41]\
    \ = integer40.split('.')\n  const [integer42, decimal42] = integer41.split('.')\n\
    \  const [integer43, decimal43] = integer42.split('.')\n  const [integer44, decimal44]\
    \ = integer43.split('.')\n  const [integer45, decimal45] = integer44", "  const\
    \ num = parseFloat(value);\n  const closest = Math.round(Math.abs(num));\n  if\
    \ (closest === 0) {\n    return num;\n  }\n  return closest;\n}\n", "  const num\
    \ = parseFloat(value);\n  const closest = Math.round(num / 10) * 10;\n  return\
    \ closest < num ? closest : num;\n}\n", "  const num = Number(value);\n  if (Number.isNaN(num))\
    \ {\n    throw new Error(`Invalid number ${value}`);\n  }\n  const diff = Math.abs(num\
    \ - Math.floor(num));\n  if (diff < 0.5) {\n    return Math.floor(num);\n  }\n\
    \  return Math.ceil(num);\n}\n", "  const num = Number(value);\n  if (Number.isNaN(num))\
    \ {\n    throw new Error(`Invalid number ${value}`);\n  }\n  if (num === 0) {\n\
    \    return 0;\n  }\n  if (num === 1) {\n    return 1;\n  }\n  if (num === -1)\
    \ {\n    return -1;\n  }\n  const diff = num - Math.floor(num);\n  if (Math.abs(diff)\
    \ < Number.EPSILON) {\n    return num;\n  }\n  if (diff > 0) {\n    return Math.floor(num);\n\
    \  }\n  return Math.ceil(num);\n}\n", "  const num = parseFloat(value);\n  const\
    \ isNegative = num < 0;\n  const isPositive = num > 0;\n  const isEquidistant\
    \ = Math.abs(num - Math.floor(num)) < 0.1;\n  if (isEquidistant) {\n    return\
    \ Math.floor(num);\n  }\n  if (isNegative) {\n    return Math.ceil(num);\n  }\n\
    \  return Math.floor(num);\n}\n", "  const num = Number(value);\n  if (Number.isNaN(num))\
    \ {\n    throw new Error(`Invalid number ${value}`);\n  }\n  if (num === 0) {\n\
    \    return 0;\n  }\n  const difference = Math.abs(num - Math.floor(num));\n \
    \ if (difference <= Number.EPSILON) {\n    return Math.floor(num);\n  }\n  return\
    \ num - difference < 0 ? Math.floor(num) + 1 : Math.floor(num);\n}\n", "  let\
    \ closest: number = Number.MAX_SAFE_INTEGER;\n  let closestIndex: number = -1;\n\
    \  for (let i = 0; i < value.length; i++) {\n    const current: number = parseInt(value[i]);\n\
    \    if (current < closest) {\n      closest = current;\n      closestIndex =\
    \ i;\n    }\n  }\n  return closest;\n}\n", "  const number = parseFloat(value);\n\
    \  const integers = Math.floor(number).toString().split(\".\");\n  const integersLength\
    \ = integers.length;\n  const closestInteger = Math.ceil(number);\n  const closestIntegers\
    \ = Math.floor(closestInteger).toString().split(\".\");\n  const closestIntegersLength\
    \ = closestIntegers.length;\n  if (closestIntegerLength > integersLength) {\n\
    \    return closestInteger;\n  }\n  if (closestIntegerLength < integersLength)\
    \ {\n    return closestIntegers;\n  }\n  if (closestIntegerLength === integersLength)\
    \ {\n    if (closestIntegers[0] === integers[0]) {\n      return closestInteger;\n\
    \    }\n    return closestIntegers;\n  }\n  return closestInteger;\n}\n", "  const\
    \ [intValue, decValue] = value.split(\".\");\n  const [intValue, decValue] = intValue.split(\"\
    -\");\n  const [intValue, decValue] = intValue.split(\"+\");\n  const [intValue,\
    \ decValue] = intValue.split(\"/\");\n  const [intValue, decValue] = intValue.split(\"\
    %\");\n\n  if (intValue === \"\") {\n    return parseInt(decValue);\n  }\n  if\
    \ (decValue === \"\") {\n    return parseInt(intValue);\n  }\n  return parseInt(decValue)\
    \ < parseInt(intValue) ? parseInt(decValue) : parseInt(intValue);\n}\n", "  const\
    \ num = Number(value);\n  if (Number.isNaN(num)) {\n    throw new Error(`Invalid\
    \ number ${value}`);\n  }\n  if (num === 0) {\n    return 0;\n  }\n  if (num <\
    \ 0) {\n    return Math.ceil(num);\n  }\n  return Math.floor(num);\n}\n", "  const\
    \ num = Number(value);\n  const diff = Math.abs(num - Math.floor(num));\n  if\
    \ (diff > 0.5) {\n    return Math.floor(num);\n  }\n  return Math.ceil(num);\n\
    }\n", "  const num = Number(value);\n  if (isNaN(num)) {\n    throw new Error(`Invalid\
    \ number ${value}`);\n  }\n  if (num === 0) {\n    return 0;\n  }\n  if (num >\
    \ 0) {\n    return num;\n  }\n  if (num < 0) {\n    return -num;\n  }\n  const\
    \ diff = num - Math.floor(num);\n  if (Math.abs(diff) < Number.EPSILON) {\n  \
    \  return num;\n  }\n  return Math.floor(num) + Math.sign(diff) * Math.floor(Math.abs(diff));\n\
    }\n", "  const num = parseFloat(value);\n  const diff = Math.abs(num - Math.floor(num));\n\
    \  if (diff < 1) {\n    return Math.floor(num);\n  }\n  return Math.ceil(num);\n\
    }\n", "  const [int1, int2] = value.split(\".\");\n  const [int1int, int2int]\
    \ = [parseInt(int1), parseInt(int2)];\n  if (int1int < int2int) {\n    return\
    \ int1int;\n  }\n  return int2int;\n}\n", "  const num = Number(value);\n  const\
    \ diff = Math.abs(num - Math.floor(num));\n  return diff < 0.5 ? Math.floor(num)\
    \ : Math.ceil(num);\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
