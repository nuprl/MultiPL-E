name: HumanEval_10_make_palindrome
language: ts
prompt: "//Find the shortest palindrome that begins with a supplied string.\n// Algorithm\
  \ idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n\
  // - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"\
  cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunction make_palindrome(string:\
  \ string): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = make_palindrome;\n  assert.deepEqual(candidate(\"\"\
  ),\"\");\n  assert.deepEqual(candidate(\"x\"),\"x\");\n  assert.deepEqual(candidate(\"\
  xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"\
  jerry\"),\"jerryrrej\");\n}\n\ntest();"
completions: ["  let reverse: string = string\n  let longest: string = string\n  let\
    \ prefix: string = string\n  let suffix: string = string\n  let palindrome: string\
    \ = string\n  let i: number = 0\n  let j: number = 0\n  while (i < string.length)\
    \ {\n    longest = longest.substring(0, longest.length - 1) + string[i]\n    i++\n\
    \  }\n  while (j < string.length) {\n    prefix = prefix.substring(0, prefix.length\
    \ - 1) + string[j]\n    j++\n  }\n  while (i < string.length) {\n    suffix =\
    \ suffix.substring(0, suffix.length - 1) + string[i]\n    i++\n  }\n  reverse\
    \ = reverse.substring(0, reverse.length - 1) + suffix\n  reverse = reverse.substring(0,\
    \ reverse.length - 1) + prefix\n  reverse = reverse.substring(0, reverse.length\
    \ - 1) + longest\n  reverse = reverse.substring(0, reverse.length - 1) + string\n\
    \  reverse = reverse.substring(0, reverse.length - 1) + palindrome\n  reverse\
    \ = reverse.substring(0, reverse.length - 1) + suffix\n  reverse = reverse.substring(0,\
    \ reverse.length - 1) + prefix\n  reverse = reverse.substring(0, reverse.length\
    \ - 1) + longest\n  reverse = reverse.substring(0, reverse.length - 1) + string\n\
    \  reverse = reverse.substring(0, reverse.length - 1) + palindrome\n  reverse\
    \ = reverse.substring(0, reverse.length - 1) + suffix\n  reverse = reverse.substring(0,\
    \ reverse.length - 1) + prefix\n  reverse = reverse.substring(0, reverse.length\
    \ - 1) + longest\n  reverse = reverse.substring(0, reverse.length - 1) + string\n\
    \  reverse = reverse.substring(0, reverse.length - 1) + palindrome\n  return reverse\n\
    }\n", "  const reverse: string = string\n    .split('')\n    .reverse()\n    .join('');\n\
    \n  const prefix: string = string\n    .split('')\n    .slice(0, -1)\n    .join('');\n\
    \n  return reverse + prefix;\n}\n", "  let reverse: string = string\n  let prefix:\
    \ string = string\n  let suffix: string = string\n  let palindrome: string = string\n\
    \  let i: number = 0\n  let j: number = 0\n  while (i < string.length && j < string.length)\
    \ {\n    if (string[i] !== string[j]) {\n      reverse = reverse + string[j]\n\
    \      j++\n    } else {\n      reverse = reverse + string[i]\n      i++\n   \
    \ }\n  }\n  while (i < string.length) {\n    reverse = reverse + string[i]\n \
    \   i++\n  }\n  while (j < string.length) {\n    prefix = prefix + string[j]\n\
    \    j++\n  }\n  while (i < string.length) {\n    suffix = suffix + string[i]\n\
    \    i++\n  }\n  reverse = reverse + suffix\n  reverse = reverse + prefix\n  return\
    \ reverse\n}\n", "  const reverse: string = string\n    .split('')\n    .reverse()\n\
    \    .join('');\n  const prefix: string = string.slice(0, string.length - reverse.length);\n\
    \  return `${prefix}${reverse}`;\n}\n", "  let longestPalindrome = string\n  let\
    \ longestPalindromeLength = string.length\n  for (let i = 0; i < string.length;\
    \ i++) {\n    let currentChar = string[i]\n    let currentPalindrome = string\n\
    \    let currentPalindromeLength = string.length\n    for (let j = i; j < string.length;\
    \ j++) {\n      let nextChar = string[j]\n      if (currentChar === nextChar)\
    \ {\n        currentPalindrome = currentPalindrome.slice(0, j) + currentChar +\
    \ currentPalindrome.slice(j)\n        currentPalindromeLength += 1\n      } else\
    \ {\n        break\n      }\n    }\n    if (currentPalindromeLength < longestPalindromeLength)\
    \ {\n      longestPalindrome = currentPalindrome\n      longestPalindromeLength\
    \ = currentPalindromeLength\n    }\n  }\n  return longestPalindrome\n}\n", " \
    \ let reverse: string = string\n  let prefix: string = string\n  let suffix: string\
    \ = string\n  let palindrome: string = string\n  let i: number = 0\n  let j: number\
    \ = 0\n  while (i < string.length && j < string.length) {\n    if (string[i] ===\
    \ string[j]) {\n      i++\n      j++\n    } else {\n      reverse = reverse +\
    \ string[j]\n      j++\n    }\n  }\n  if (i === string.length) {\n    prefix =\
    \ string\n  } else {\n    prefix = string.slice(0, i)\n  }\n  if (j === string.length)\
    \ {\n    suffix = string\n  } else {\n    suffix = string.slice(i, string.length)\n\
    \  }\n  palindrome = prefix + reverse + suffix\n  return palindrome\n}\n", " \
    \ let reverse: string = string\n  let prefix: string = string\n  let suffix: string\
    \ = string\n  let palindrome: string = string\n  let i: number = 0\n  let j: number\
    \ = 0\n  while (i < string.length) {\n    while (j < string.length) {\n      if\
    \ (string[i] === string[j]) {\n        j++\n      } else {\n        break\n  \
    \    }\n    }\n    if (j === string.length) {\n      reverse = reverse + string[i]\n\
    \      i++\n      j = 0\n    }\n  }\n  while (reverse.length < string.length)\
    \ {\n    prefix = prefix.slice(0, -1)\n    reverse = reverse + prefix\n  }\n \
    \ while (reverse.length > string.length) {\n    suffix = suffix.slice(1)\n   \
    \ reverse = reverse + suffix\n  }\n  palindrome = reverse + string\n  return palindrome\n\
    }\n", "  let longestPalindrome = string;\n  let longestPalindromeLength = 0;\n\
    \  let longestPalindromePrefix = \"\";\n  for (let i = 0; i < string.length; i++)\
    \ {\n    let currentChar = string[i];\n    let currentCharLength = currentChar.length;\n\
    \    let currentPalindrome = currentChar + currentChar.split(\"\").reverse().join(\"\
    \");\n    if (currentPalindrome === longestPalindrome) {\n      longestPalindromeLength\
    \ += currentCharLength;\n      if (currentCharLength > longestPalindromeLength)\
    \ {\n        longestPalindrome = currentPalindrome;\n        longestPalindromeLength\
    \ = currentCharLength;\n        longestPalindromePrefix = currentChar;\n     \
    \ }\n    } else {\n      if (currentCharLength > longestPalindromeLength) {\n\
    \        longestPalindrome = currentPalindrome;\n        longestPalindromeLength\
    \ = currentCharLength;\n        longestPalindromePrefix = currentChar;\n     \
    \ }\n    }\n  }\n  return longestPalindromePrefix + longestPalindrome;\n}\n",
  "  const reversed = string\n    .split('')\n    .reverse()\n    .join('');\n  const\
    \ prefix = string.slice(0, string.length - reversed.length);\n  return prefix\
    \ + reversed;\n}\n", "  let longestPalindrome = string.substr(0, string.length\
    \ - 1);\n  let reversedString = longestPalindrome;\n  for (let i = longestPalindrome.length\
    \ - 1; i >= 0; i--) {\n    reversedString += longestPalindrome.charAt(i);\n  }\n\
    \  return reversedString;\n}\n", "  const reverse: string = string\n    .split('')\n\
    \    .reverse()\n    .join('');\n  const prefix: string = string.slice(0, string.length\
    \ - reverse.length);\n  return prefix + reverse + string;\n}\n", "  const reverse:\
    \ string = string\n    .split('')\n    .reverse()\n    .join('');\n  return string\
    \ + reverse;\n}\n", "  let longestPalindrome = string.substr(0, string.length\
    \ - 1);\n  let longestPalindromeReversed = longestPalindrome;\n  for (let i =\
    \ string.length - 1; i >= 0; i--) {\n    let currentChar = string[i];\n    let\
    \ currentCharReversed = currentChar;\n    for (let j = i; j >= 0; j--) {\n   \
    \   if (currentCharReversed !== string[j]) {\n        break;\n      }\n      currentCharReversed\
    \ = string[j];\n    }\n    longestPalindromeReversed = currentCharReversed + longestPalindromeReversed;\n\
    \  }\n  return longestPalindrome;\n}\n", "  let palindrome: string = string;\n\
    \  let prefix_length: number = string.length;\n  let suffix_length: number = string.length\
    \ - 1;\n  while (prefix_length >= 0 && suffix_length >= 0) {\n    if (string[prefix_length]\
    \ === string[suffix_length]) {\n      palindrome = string.slice(0, prefix_length)\
    \ + string[suffix_length] + palindrome;\n      prefix_length--;\n      suffix_length--;\n\
    \    } else {\n      prefix_length--;\n    }\n  }\n  return palindrome;\n}\n",
  "  if (string === \"\") {\n    return \"\";\n  }\n\n  const prefix_length: string\
    \ = string.substr(0, string.length - 1);\n  const suffix_length: string = string.substr(string.length\
    \ - 1, string.length);\n\n  const prefix_reverse: string = prefix_length.reverse();\n\
    \  const suffix_reverse: string = suffix_length.reverse();\n\n  const palindrome:\
    \ string = prefix_reverse + suffix_reverse;\n\n  return palindrome;\n}\n", " \
    \ let reverse: string = string\n  let prefix: string = \"\"\n  let suffix: string\
    \ = \"\"\n  let longest: string = \"\"\n  let longestLength: number = 0\n  for\
    \ (let i = 0; i < string.length; i++) {\n    let char = string[i]\n    let index\
    \ = string.indexOf(char, i + 1)\n    if (index > -1) {\n      prefix = string.substring(0,\
    \ index)\n      suffix = string.substring(index)\n      if (isPalindrome(prefix\
    \ + char + suffix)) {\n        longest = prefix + char + suffix\n        longestLength\
    \ = longest.length\n      }\n    }\n  }\n  if (longestLength > longest.length)\
    \ {\n    longest = prefix + reverse.substring(longestLength) + suffix\n  }\n \
    \ return longest\n}\n", "  let longestPalindrome: string = \"\";\n  let longestPalindromeLength:\
    \ number = 0;\n  for (let i = 0; i < string.length; i++) {\n    let currentChar:\
    \ string = string[i];\n    let currentPalindrome: string = \"\";\n    let currentPalindromeLength:\
    \ number = 0;\n    for (let j = i; j < string.length; j++) {\n      currentPalindrome\
    \ += string[j];\n      currentPalindromeLength++;\n      if (currentPalindromeLength\
    \ > longestPalindromeLength) {\n        longestPalindrome = currentPalindrome;\n\
    \        longestPalindromeLength = currentPalindromeLength;\n      }\n    }\n\
    \  }\n  return string + longestPalindrome;\n}\n", "  if (string === \"\") {\n\
    \    return \"\";\n  }\n\n  const reversed_string = string\n    .toLowerCase()\n\
    \    .split(\"\")\n    .reverse()\n    .join(\"\");\n\n  const prefix_length =\
    \ string.length - reversed_string.length;\n\n  return string + reversed_string.substr(0,\
    \ prefix_length);\n}\n", "  const reverse: string = string.replace(/^./g, (char:\
    \ string) => char.split(\"\").reverse().join(\"\"));\n  const prefix: string =\
    \ string.split(\"\").reverse().join(\"\");\n  return reverse + prefix;\n}\n",
  "    let longestPalindrome = longestPalindromeFrom(string);\n    let reversedString\
    \ = reverseString(longestPalindrome);\n    return reversedString + longestPalindrome;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
