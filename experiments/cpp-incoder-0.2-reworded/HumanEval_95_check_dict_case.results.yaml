language: cpp
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &it : dict) {\n \
    \       if (it.first >= 'a' && it.first <= 'z') return false;\n        if (it.first\
    \ >= 'A' && it.first <= 'Z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp98jmslz0.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp98jmslz0.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'it' with no type [-fpermissive]\n     for (auto &it : dict)\
    \ {\n                ^\n/tmp/tmp98jmslz0.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &it : dict) {\n              \
    \       ^\n/tmp/tmp98jmslz0.cpp:20:16: error: request for member 'first' in 'it',\
    \ which is of non-class type 'int'\n         if (it.first >= 'a' && it.first <=\
    \ 'z') return false;\n                ^\n/tmp/tmp98jmslz0.cpp:20:35: error: request\
    \ for member 'first' in 'it', which is of non-class type 'int'\n         if (it.first\
    \ >= 'a' && it.first <= 'z') return false;\n                                 \
    \  ^\n/tmp/tmp98jmslz0.cpp:21:16: error: request for member 'first' in 'it', which\
    \ is of non-class type 'int'\n         if (it.first >= 'A' && it.first <= 'Z')\
    \ return false;\n                ^\n/tmp/tmp98jmslz0.cpp:21:35: error: request\
    \ for member 'first' in 'it', which is of non-class type 'int'\n         if (it.first\
    \ >= 'A' && it.first <= 'Z') return false;\n                                 \
    \  ^\n/tmp/tmp98jmslz0.cpp: In function 'int main()':\n/tmp/tmp98jmslz0.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp98jmslz0.cpp:2:\n/tmp/tmp98jmslz0.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp98jmslz0.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"},"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &it : dict) {\n \
    \       if (it.first != it.first.toLower()) return false;\n        if (it.first\
    \ != it.first.toUpper()) return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpntodop8j.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpntodop8j.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'it' with no type [-fpermissive]\n     for (auto &it : dict)\
    \ {\n                ^\n/tmp/tmpntodop8j.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &it : dict) {\n              \
    \       ^\n/tmp/tmpntodop8j.cpp:20:16: error: request for member 'first' in 'it',\
    \ which is of non-class type 'int'\n         if (it.first != it.first.toLower())\
    \ return false;\n                ^\n/tmp/tmpntodop8j.cpp:20:28: error: request\
    \ for member 'first' in 'it', which is of non-class type 'int'\n         if (it.first\
    \ != it.first.toLower()) return false;\n                            ^\n/tmp/tmpntodop8j.cpp:21:16:\
    \ error: request for member 'first' in 'it', which is of non-class type 'int'\n\
    \         if (it.first != it.first.toUpper()) return false;\n                ^\n\
    /tmp/tmpntodop8j.cpp:21:28: error: request for member 'first' in 'it', which is\
    \ of non-class type 'int'\n         if (it.first != it.first.toUpper()) return\
    \ false;\n                            ^\n/tmp/tmpntodop8j.cpp: In function 'int\
    \ main()':\n/tmp/tmpntodop8j.cpp:26:10: error: 'candidate' does not name a type\n\
    \     auto candidate = check_dict_case;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpntodop8j.cpp:2:\n/tmp/tmpntodop8j.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpntodop8j.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true)"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &x: dict) {\n        if ((x.first\
    \ != x.first.to_lower())) {\n            flag = false;\n        }\n        if\
    \ ((x.first != x.first.to_upper())) {\n            flag = false;\n        }\n\
    \    }\n    return flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpurzoj0yv.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpurzoj0yv.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for (auto &x: dict) {\n\
    \                ^\n/tmp/tmpurzoj0yv.cpp:19:19: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &x: dict) {\n                \
    \   ^\n/tmp/tmpurzoj0yv.cpp:20:16: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if ((x.first != x.first.to_lower())) {\n\
    \                ^\n/tmp/tmpurzoj0yv.cpp:20:27: error: request for member 'first'\
    \ in 'x', which is of non-class type 'int'\n         if ((x.first != x.first.to_lower()))\
    \ {\n                           ^\n/tmp/tmpurzoj0yv.cpp:23:16: error: request\
    \ for member 'first' in 'x', which is of non-class type 'int'\n         if ((x.first\
    \ != x.first.to_upper())) {\n                ^\n/tmp/tmpurzoj0yv.cpp:23:27: error:\
    \ request for member 'first' in 'x', which is of non-class type 'int'\n      \
    \   if ((x.first != x.first.to_upper())) {\n                           ^\n/tmp/tmpurzoj0yv.cpp:\
    \ In function 'int main()':\n/tmp/tmpurzoj0yv.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpurzoj0yv.cpp:2:\n/tmp/tmpurzoj0yv.cpp:31:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpurzoj0yv.cpp:31:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    for(auto it=dict.begin();it!=dict.end();it++)\
    \ {\n        if(it->first.length()!=it->second.length()) {\n            return\
    \ false;\n        }\n        for(int i=0;i<it->first.length();i++) {\n       \
    \     if(it->first[i]>='A' && it->first[i]<='Z') {\n                if(it->first[i]!=it->second[i])\
    \ {\n                    return false;\n                }\n            } else\
    \ if(it->first[i]>='a' && it->first[i]<='z') {\n                if(it->first[i]!=it->second[i])\
    \ {\n                    return false;\n                }\n            } else\
    \ {\n                return false;\n            }\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpayuz6xjb.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpayuz6xjb.cpp:19:14: error: 'it' does not\
    \ name a type\n     for(auto it=dict.begin();it!=dict.end();it++) {\n        \
    \      ^\n/tmp/tmpayuz6xjb.cpp:19:30: error: expected ';' before 'it'\n     for(auto\
    \ it=dict.begin();it!=dict.end();it++) {\n                              ^\n/tmp/tmpayuz6xjb.cpp:19:30:\
    \ error: 'it' was not declared in this scope\n/tmp/tmpayuz6xjb.cpp: In function\
    \ 'int main()':\n/tmp/tmpayuz6xjb.cpp:40:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpayuz6xjb.cpp:2:\n/tmp/tmpayuz6xjb.cpp:41:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpayuz6xjb.cpp:41:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpayuz6xjb.cpp:41:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpayuz6xjb.cpp:41:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpayuz6xjb.cpp:41:94: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpayuz6xjb.cpp:41:94:\
    \ error: no matching function for call to 'std::map<std::basic_string<char>, std::basic_string<char>\
    \ >::map(<brace-enclosed initializer list>)'\n/tmp/tmpayuz6xjb.cpp:41:"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &x: dict) {\n   \
    \     if (x.first < 'A' || x.first > 'Z') return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9se_ocms.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp9se_ocms.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for (auto &x: dict) {\n\
    \                ^\n/tmp/tmp9se_ocms.cpp:19:19: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &x: dict) {\n                \
    \   ^\n/tmp/tmp9se_ocms.cpp:20:15: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if (x.first < 'A' || x.first > 'Z') return\
    \ false;\n               ^\n/tmp/tmp9se_ocms.cpp:20:32: error: request for member\
    \ 'first' in 'x', which is of non-class type 'int'\n         if (x.first < 'A'\
    \ || x.first > 'Z') return false;\n                                ^\n/tmp/tmp9se_ocms.cpp:\
    \ In function 'int main()':\n/tmp/tmp9se_ocms.cpp:25:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9se_ocms.cpp:2:\n/tmp/tmp9se_ocms.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp9se_ocms.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmp9se_ocms.cpp:26:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp9se_ocms.cpp:26:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmp9se_ocms."
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty())\n        return false;\n    for(auto &x: dict)\n\
    \    {\n        if(x.first != x.second.toLower())\n            return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmlwskufg.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpmlwskufg.cpp:20:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict)\n  \
    \             ^\n/tmp/tmpmlwskufg.cpp:20:18: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for(auto &x: dict)\n                  ^\n/tmp/tmpmlwskufg.cpp:22:14:\
    \ error: request for member 'first' in 'x', which is of non-class type 'int'\n\
    \         if(x.first != x.second.toLower())\n              ^\n/tmp/tmpmlwskufg.cpp:22:25:\
    \ error: request for member 'second' in 'x', which is of non-class type 'int'\n\
    \         if(x.first != x.second.toLower())\n                         ^\n/tmp/tmpmlwskufg.cpp:\
    \ In function 'int main()':\n/tmp/tmpmlwskufg.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmlwskufg.cpp:2:\n/tmp/tmpmlwskufg.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpmlwskufg.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpmlwskufg.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmlwskufg.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpmlwskufg.cpp:29:94: warning: extended initializer lists "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return false;\n    for(auto &x: dict) {\n    \
    \    if(x.first >= 'a' && x.first <= 'z') return false;\n        if(x.first >=\
    \ 'A' && x.first <= 'Z') return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr_cp7aez.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpr_cp7aez.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmpr_cp7aez.cpp:19:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmpr_cp7aez.cpp:20:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first >= 'a' && x.first <= 'z') return\
    \ false;\n              ^\n/tmp/tmpr_cp7aez.cpp:20:32: error: request for member\
    \ 'first' in 'x', which is of non-class type 'int'\n         if(x.first >= 'a'\
    \ && x.first <= 'z') return false;\n                                ^\n/tmp/tmpr_cp7aez.cpp:21:14:\
    \ error: request for member 'first' in 'x', which is of non-class type 'int'\n\
    \         if(x.first >= 'A' && x.first <= 'Z') return false;\n              ^\n\
    /tmp/tmpr_cp7aez.cpp:21:32: error: request for member 'first' in 'x', which is\
    \ of non-class type 'int'\n         if(x.first >= 'A' && x.first <= 'Z') return\
    \ false;\n                                ^\n/tmp/tmpr_cp7aez.cpp: In function\
    \ 'int main()':\n/tmp/tmpr_cp7aez.cpp:26:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr_cp7aez.cpp:2:\n/tmp/tmpr_cp7aez.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpr_cp7aez.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &x: dict) {\n   \
    \     if (!(x.first == x.second.toLower()))\n            return false;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n  \
    \  assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf0ggyefc.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpf0ggyefc.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for (auto &x: dict) {\n\
    \                ^\n/tmp/tmpf0ggyefc.cpp:19:19: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &x: dict) {\n                \
    \   ^\n/tmp/tmpf0ggyefc.cpp:20:17: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if (!(x.first == x.second.toLower()))\n\
    \                 ^\n/tmp/tmpf0ggyefc.cpp:20:28: error: request for member 'second'\
    \ in 'x', which is of non-class type 'int'\n         if (!(x.first == x.second.toLower()))\n\
    \                            ^\n/tmp/tmpf0ggyefc.cpp: In function 'int main()':\n\
    /tmp/tmpf0ggyefc.cpp:26:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = check_dict_case;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf0ggyefc.cpp:2:\n/tmp/tmpf0ggyefc.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpf0ggyefc.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpf0ggyefc.cpp:27:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpf0ggyefc.cpp:27:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpf0ggyefc.cpp:27:94: warning: exten"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Your code here\n    for(auto &x: dict) {\n        if(x.first\
    \ == x.second.tolower()) {\n            return true;\n        }\n        if(x.first\
    \ == x.second.toupper()) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp763u_b07.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp763u_b07.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmp763u_b07.cpp:19:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmp763u_b07.cpp:20:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first == x.second.tolower()) {\n \
    \             ^\n/tmp/tmp763u_b07.cpp:20:25: error: request for member 'second'\
    \ in 'x', which is of non-class type 'int'\n         if(x.first == x.second.tolower())\
    \ {\n                         ^\n/tmp/tmp763u_b07.cpp:23:14: error: request for\
    \ member 'first' in 'x', which is of non-class type 'int'\n         if(x.first\
    \ == x.second.toupper()) {\n              ^\n/tmp/tmp763u_b07.cpp:23:25: error:\
    \ request for member 'second' in 'x', which is of non-class type 'int'\n     \
    \    if(x.first == x.second.toupper()) {\n                         ^\n/tmp/tmp763u_b07.cpp:\
    \ In function 'int main()':\n/tmp/tmp763u_b07.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp763u_b07.cpp:2:\n/tmp/tmp763u_b07.cpp:31:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp763u_b07.cpp:31:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                      "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return false;\n    for(auto &x: dict) {\n    \
    \    if(x.first != x.first.to_lower()) {\n            return false;\n        }\n\
    \        if(x.first != x.first.to_upper()) {\n            return false;\n    \
    \    }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy2yy8z_r.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpy2yy8z_r.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmpy2yy8z_r.cpp:19:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmpy2yy8z_r.cpp:20:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first != x.first.to_lower()) {\n \
    \             ^\n/tmp/tmpy2yy8z_r.cpp:20:25: error: request for member 'first'\
    \ in 'x', which is of non-class type 'int'\n         if(x.first != x.first.to_lower())\
    \ {\n                         ^\n/tmp/tmpy2yy8z_r.cpp:23:14: error: request for\
    \ member 'first' in 'x', which is of non-class type 'int'\n         if(x.first\
    \ != x.first.to_upper()) {\n              ^\n/tmp/tmpy2yy8z_r.cpp:23:25: error:\
    \ request for member 'first' in 'x', which is of non-class type 'int'\n      \
    \   if(x.first != x.first.to_upper()) {\n                         ^\n/tmp/tmpy2yy8z_r.cpp:\
    \ In function 'int main()':\n/tmp/tmpy2yy8z_r.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy2yy8z_r.cpp:2:\n/tmp/tmpy2yy8z_r.cpp:31:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpy2yy8z_r.cpp:31:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                        "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first < 'A' || x.first > 'Z') return false;\n        if(x.second < 'A'\
    \ || x.second > 'Z') return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp60qejm2j.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp60qejm2j.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmp60qejm2j.cpp:19:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmp60qejm2j.cpp:20:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first < 'A' || x.first > 'Z') return\
    \ false;\n              ^\n/tmp/tmp60qejm2j.cpp:20:31: error: request for member\
    \ 'first' in 'x', which is of non-class type 'int'\n         if(x.first < 'A'\
    \ || x.first > 'Z') return false;\n                               ^\n/tmp/tmp60qejm2j.cpp:21:14:\
    \ error: request for member 'second' in 'x', which is of non-class type 'int'\n\
    \         if(x.second < 'A' || x.second > 'Z') return false;\n              ^\n\
    /tmp/tmp60qejm2j.cpp:21:32: error: request for member 'second' in 'x', which is\
    \ of non-class type 'int'\n         if(x.second < 'A' || x.second > 'Z') return\
    \ false;\n                                ^\n/tmp/tmp60qejm2j.cpp: In function\
    \ 'int main()':\n/tmp/tmp60qejm2j.cpp:26:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp60qejm2j.cpp:2:\n/tmp/tmp60qejm2j.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp60qejm2j.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n       "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first != x.first.to_lower()) {\n            return false;\n        }\n\
    \        if(x.first != x.first.to_upper()) {\n            return false;\n    \
    \    }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp69xs10ph.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp69xs10ph.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmp69xs10ph.cpp:19:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmp69xs10ph.cpp:20:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first != x.first.to_lower()) {\n \
    \             ^\n/tmp/tmp69xs10ph.cpp:20:25: error: request for member 'first'\
    \ in 'x', which is of non-class type 'int'\n         if(x.first != x.first.to_lower())\
    \ {\n                         ^\n/tmp/tmp69xs10ph.cpp:23:14: error: request for\
    \ member 'first' in 'x', which is of non-class type 'int'\n         if(x.first\
    \ != x.first.to_upper()) {\n              ^\n/tmp/tmp69xs10ph.cpp:23:25: error:\
    \ request for member 'first' in 'x', which is of non-class type 'int'\n      \
    \   if(x.first != x.first.to_upper()) {\n                         ^\n/tmp/tmp69xs10ph.cpp:\
    \ In function 'int main()':\n/tmp/tmp69xs10ph.cpp:30:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp69xs10ph.cpp:2:\n/tmp/tmp69xs10ph.cpp:31:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp69xs10ph.cpp:31:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                        "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &x: dict) {\n  \
    \      if (x.first != x.first.to_lower()) return false;\n        if (x.first !=\
    \ x.first.to_upper()) return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_t_yif46.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp_t_yif46.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for (auto &x: dict) {\n\
    \                ^\n/tmp/tmp_t_yif46.cpp:19:19: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &x: dict) {\n                \
    \   ^\n/tmp/tmp_t_yif46.cpp:20:15: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if (x.first != x.first.to_lower()) return\
    \ false;\n               ^\n/tmp/tmp_t_yif46.cpp:20:26: error: request for member\
    \ 'first' in 'x', which is of non-class type 'int'\n         if (x.first != x.first.to_lower())\
    \ return false;\n                          ^\n/tmp/tmp_t_yif46.cpp:21:15: error:\
    \ request for member 'first' in 'x', which is of non-class type 'int'\n      \
    \   if (x.first != x.first.to_upper()) return false;\n               ^\n/tmp/tmp_t_yif46.cpp:21:26:\
    \ error: request for member 'first' in 'x', which is of non-class type 'int'\n\
    \         if (x.first != x.first.to_upper()) return false;\n                 \
    \         ^\n/tmp/tmp_t_yif46.cpp: In function 'int main()':\n/tmp/tmp_t_yif46.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_t_yif46.cpp:2:\n/tmp/tmp_t_yif46.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp_t_yif46.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                  "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return true;\n    for (auto &item : dict)\n \
    \       if (!item.first.compare(0, 2, \"_\") && !item.first.compare(0, 1, \"_\"\
    ))\n            return false;\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz2dem2r8.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpz2dem2r8.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'item' with no type [-fpermissive]\n     for (auto &item : dict)\n\
    \                ^\n/tmp/tmpz2dem2r8.cpp:19:23: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &item : dict)\n              \
    \         ^\n/tmp/tmpz2dem2r8.cpp:20:19: error: request for member 'first' in\
    \ 'item', which is of non-class type 'int'\n         if (!item.first.compare(0,\
    \ 2, \"_\") && !item.first.compare(0, 1, \"_\"))\n                   ^\n/tmp/tmpz2dem2r8.cpp:20:53:\
    \ error: request for member 'first' in 'item', which is of non-class type 'int'\n\
    \         if (!item.first.compare(0, 2, \"_\") && !item.first.compare(0, 1, \"\
    _\"))\n                                                     ^\n/tmp/tmpz2dem2r8.cpp:\
    \ In function 'int main()':\n/tmp/tmpz2dem2r8.cpp:25:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz2dem2r8.cpp:2:\n/tmp/tmpz2dem2r8.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpz2dem2r8.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpz2dem2r8.cpp:26:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpz2dem2r8.cpp:26:94: warning: extended initializer\
    \ lists onl"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    // Write your code here\n    \n    for(auto &x: dict) {\n     \
    \   if(x.first == x.second.toLower()) {\n            return true;\n        }\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyngwtflx.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpyngwtflx.cpp:20:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmpyngwtflx.cpp:20:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmpyngwtflx.cpp:21:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first == x.second.toLower()) {\n \
    \             ^\n/tmp/tmpyngwtflx.cpp:21:25: error: request for member 'second'\
    \ in 'x', which is of non-class type 'int'\n         if(x.first == x.second.toLower())\
    \ {\n                         ^\n/tmp/tmpyngwtflx.cpp: In function 'int main()':\n\
    /tmp/tmpyngwtflx.cpp:28:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = check_dict_case;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyngwtflx.cpp:2:\n/tmp/tmpyngwtflx.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpyngwtflx.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpyngwtflx.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyngwtflx.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpyngwtflx.cpp:29:94: warning: extended initialize"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return true;\n    for(auto &x: dict) {\n     \
    \   if(x.first != std::to_string(x.first).substr(0,1))\n            return false;\n\
    \        if(x.first != std::to_string(x.first).substr(1,1))\n            return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_6of_bn.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpq_6of_bn.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmpq_6of_bn.cpp:19:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmpq_6of_bn.cpp:20:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first != std::to_string(x.first).substr(0,1))\n\
    \              ^\n/tmp/tmpq_6of_bn.cpp:20:23: error: 'to_string' is not a member\
    \ of 'std'\n         if(x.first != std::to_string(x.first).substr(0,1))\n    \
    \                   ^\n/tmp/tmpq_6of_bn.cpp:20:40: error: request for member 'first'\
    \ in 'x', which is of non-class type 'int'\n         if(x.first != std::to_string(x.first).substr(0,1))\n\
    \                                        ^\n/tmp/tmpq_6of_bn.cpp:22:14: error:\
    \ request for member 'first' in 'x', which is of non-class type 'int'\n      \
    \   if(x.first != std::to_string(x.first).substr(1,1))\n              ^\n/tmp/tmpq_6of_bn.cpp:22:23:\
    \ error: 'to_string' is not a member of 'std'\n         if(x.first != std::to_string(x.first).substr(1,1))\n\
    \                       ^\n/tmp/tmpq_6of_bn.cpp:22:40: error: request for member\
    \ 'first' in 'x', which is of non-class type 'int'\n         if(x.first != std::to_string(x.first).substr(1,1))\n\
    \                                        ^\n/tmp/tmpq_6of_bn.cpp: In function\
    \ 'int main()':\n/tmp/tmpq_6of_bn.cpp:28:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = check_dict_case;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq_6of_bn.cpp:2:\n/tmp/tmpq_6of_bn.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty())\n        return false;\n    for(auto &x: dict)\
    \ {\n        if(x.first != x.second.toLower()) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = check_dict_case;\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzmpwhdii.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmpzmpwhdii.cpp:20:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmpzmpwhdii.cpp:20:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmpzmpwhdii.cpp:21:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first != x.second.toLower()) {\n \
    \             ^\n/tmp/tmpzmpwhdii.cpp:21:25: error: request for member 'second'\
    \ in 'x', which is of non-class type 'int'\n         if(x.first != x.second.toLower())\
    \ {\n                         ^\n/tmp/tmpzmpwhdii.cpp: In function 'int main()':\n\
    /tmp/tmpzmpwhdii.cpp:28:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = check_dict_case;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzmpwhdii.cpp:2:\n/tmp/tmpzmpwhdii.cpp:29:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmpzmpwhdii.cpp:29:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                                                        ^\n/tmp/tmpzmpwhdii.cpp:29:94:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpzmpwhdii.cpp:29:94: warning: extended initializer\
    \ lists only available with -std=c++11 or -std=gnu++11 [enabled by default]\n\
    /tmp/tmpzmpwhdii.cpp:29:94: warning: extended initialize"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if(dict.empty()) return false;\n    for(auto &x: dict) {\n    \
    \    if(x.first != x.second.tolower()) return false;\n        if(x.first != x.second.toupper())\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp915nk663.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp915nk663.cpp:19:15: error: ISO C++ forbids\
    \ declaration of 'x' with no type [-fpermissive]\n     for(auto &x: dict) {\n\
    \               ^\n/tmp/tmp915nk663.cpp:19:18: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for(auto &x: dict) {\n                 \
    \ ^\n/tmp/tmp915nk663.cpp:20:14: error: request for member 'first' in 'x', which\
    \ is of non-class type 'int'\n         if(x.first != x.second.tolower()) return\
    \ false;\n              ^\n/tmp/tmp915nk663.cpp:20:25: error: request for member\
    \ 'second' in 'x', which is of non-class type 'int'\n         if(x.first != x.second.tolower())\
    \ return false;\n                         ^\n/tmp/tmp915nk663.cpp:21:14: error:\
    \ request for member 'first' in 'x', which is of non-class type 'int'\n      \
    \   if(x.first != x.second.toupper()) return false;\n              ^\n/tmp/tmp915nk663.cpp:21:25:\
    \ error: request for member 'second' in 'x', which is of non-class type 'int'\n\
    \         if(x.first != x.second.toupper()) return false;\n                  \
    \       ^\n/tmp/tmp915nk663.cpp: In function 'int main()':\n/tmp/tmp915nk663.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp915nk663.cpp:2:\n/tmp/tmp915nk663.cpp:27:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp915nk663.cpp:27:94: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\",\
    \ \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \      "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    bool flag = true;\n    for (auto &it : dict) {\n        flag =\
    \ flag && is_str_lower(it.first) || is_str_upper(it.first);\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1y88fgqf.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp1y88fgqf.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'it' with no type [-fpermissive]\n     for (auto &it : dict)\
    \ {\n                ^\n/tmp/tmp1y88fgqf.cpp:19:21: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &it : dict) {\n              \
    \       ^\n/tmp/tmp1y88fgqf.cpp:20:40: error: request for member 'first' in 'it',\
    \ which is of non-class type 'int'\n         flag = flag && is_str_lower(it.first)\
    \ || is_str_upper(it.first);\n                                        ^\n/tmp/tmp1y88fgqf.cpp:20:45:\
    \ error: 'is_str_lower' was not declared in this scope\n         flag = flag &&\
    \ is_str_lower(it.first) || is_str_upper(it.first);\n                        \
    \                     ^\n/tmp/tmp1y88fgqf.cpp:20:66: error: request for member\
    \ 'first' in 'it', which is of non-class type 'int'\n         flag = flag && is_str_lower(it.first)\
    \ || is_str_upper(it.first);\n                                               \
    \                   ^\n/tmp/tmp1y88fgqf.cpp:20:71: error: 'is_str_upper' was not\
    \ declared in this scope\n         flag = flag && is_str_lower(it.first) || is_str_upper(it.first);\n\
    \                                                                       ^\n/tmp/tmp1y88fgqf.cpp:\
    \ In function 'int main()':\n/tmp/tmp1y88fgqf.cpp:25:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = check_dict_case;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1y88fgqf.cpp:2:\n/tmp/tmp1y88fgqf.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n                      \
    \                                  ^\n/tmp/tmp1y88fgqf.cpp:26:94: warning: extended\
    \ initializer lists only available with -std=c+"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true\
    \ if all keys are strings in lower \n// case or all keys are strings in upper\
    \ case, else return false.\n// The function should return false is the given map\
    \ is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n//\
    \ >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"},\
    \ {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n\
    // >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"\
    }, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string>\
    \ dict) {\n    if (dict.empty()) return false;\n    for (auto &item : dict) {\n\
    \        if (!(item.first == item.second.tolower()) && !(item.first == item.second.toupper()))\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = check_dict_case;\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"b\", \"banana\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"p\", \"pineapple\"\
    }, {\"5\", \"banana\"}, {\"a\", \"apple\"}}))) == (false));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))) == (false));\n\
    \    assert(candidate((std::map<std::string,std::string>({{\"STATE\", \"NC\"},\
    \ {\"ZIP\", \"12345\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>({{\"\
    fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}}))) == (true));\n    assert(candidate((std::map<std::string,std::string>()))\
    \ == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp76n3_xzu.cpp: In function 'bool check_dict_case(std::map<std::basic_string<char>,\
    \ std::basic_string<char> >)':\n/tmp/tmp76n3_xzu.cpp:19:16: error: ISO C++ forbids\
    \ declaration of 'item' with no type [-fpermissive]\n     for (auto &item : dict)\
    \ {\n                ^\n/tmp/tmp76n3_xzu.cpp:19:23: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &item : dict) {\n            \
    \           ^\n/tmp/tmp76n3_xzu.cpp:20:20: error: request for member 'first' in\
    \ 'item', which is of non-class type 'int'\n         if (!(item.first == item.second.tolower())\
    \ && !(item.first == item.second.toupper())) return false;\n                 \
    \   ^\n/tmp/tmp76n3_xzu.cpp:20:34: error: request for member 'second' in 'item',\
    \ which is of non-class type 'int'\n         if (!(item.first == item.second.tolower())\
    \ && !(item.first == item.second.toupper())) return false;\n                 \
    \                 ^\n/tmp/tmp76n3_xzu.cpp:20:62: error: request for member 'first'\
    \ in 'item', which is of non-class type 'int'\n         if (!(item.first == item.second.tolower())\
    \ && !(item.first == item.second.toupper())) return false;\n                 \
    \                                             ^\n/tmp/tmp76n3_xzu.cpp:20:76: error:\
    \ request for member 'second' in 'item', which is of non-class type 'int'\n  \
    \       if (!(item.first == item.second.tolower()) && !(item.first == item.second.toupper()))\
    \ return false;\n                                                            \
    \                ^\n/tmp/tmp76n3_xzu.cpp: In function 'int main()':\n/tmp/tmp76n3_xzu.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = check_dict_case;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp76n3_xzu.cpp:2:\n/tmp/tmp76n3_xzu.cpp:26:56: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((std::map<std::string,std::string>({{\"p\"\
    , \"pineapple\"}, {\"b\", \""
  stdout: ''
