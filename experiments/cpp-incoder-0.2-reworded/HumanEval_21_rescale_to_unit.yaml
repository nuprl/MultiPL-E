name: HumanEval_21_rescale_to_unit
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of\
  \ at least two elements), apply a linear transform to that vector,\n// such that\
  \ the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0})))\n// (std::vector<float>({(float)0.0,\
  \ (float)0.25, (float)0.5, (float)0.75, (float)1.0}))\nstd::vector<float> rescale_to_unit(std::vector<float>\
  \ numbers) {\n"
tests: "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0,\
  \ (float)49.9}))) == (std::vector<float>({(float)0.0, (float)1.0})));\n    assert(candidate((std::vector<float>({(float)100.0,\
  \ (float)49.9}))) == (std::vector<float>({(float)1.0, (float)0.0})));\n    assert(candidate((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0}))) == (std::vector<float>({(float)0.0,\
  \ (float)0.25, (float)0.5, (float)0.75, (float)1.0})));\n    assert(candidate((std::vector<float>({(float)2.0,\
  \ (float)1.0, (float)5.0, (float)3.0, (float)4.0}))) == (std::vector<float>({(float)0.25,\
  \ (float)0.0, (float)1.0, (float)0.5, (float)0.75})));\n    assert(candidate((std::vector<float>({(float)12.0,\
  \ (float)11.0, (float)15.0, (float)13.0, (float)14.0}))) == (std::vector<float>({(float)0.25,\
  \ (float)0.0, (float)1.0, (float)0.5, (float)0.75})));\n}\n"
completions: ["    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min_number = numbers[0];\n\
    \    float max_number = numbers[0];\n    for (auto number : numbers) {\n     \
    \   min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    float scale = 1.0f / (max_number - min_number);\n    for\
    \ (auto number : numbers) {\n        rescaled_numbers.push_back(number * scale);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = max - min;\n    float scale = 1.0f / range;\n\
    \    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n    float range =\
    \ max - min;\n    float inv_range = 1.0f / range;\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * inv_range);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = std::numeric_limits<float>::max();\n    float max_number\
    \ = std::numeric_limits<float>::min();\n    for (auto number : numbers) {\n  \
    \      min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * (max_number - min_number) / (max_number + min_number));\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = (max - min) / (float)numbers.size();\n  \
    \  for (auto number : numbers) {\n        rescaled_numbers.push_back(number *\
    \ scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size() >\
    \ 1);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n  \
    \  float max = *std::max_element(numbers.begin(), numbers.end());\n    float range\
    \ = max - min;\n    float new_min = min - range * 0.5;\n    float new_max = max\
    \ + range * 0.5;\n    std::vector<float> new_numbers;\n    for (auto number :\
    \ numbers) {\n        new_numbers.push_back(std::max(new_min, std::min(new_max,\
    \ number)));\n    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n    float range =\
    \ max - min;\n    float scale = 1.0f / range;\n    numbers.assign({min * scale,\
    \ max * scale});\n    return numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    float scale = (max - min) / (numbers.back()\
    \ - numbers.front());\n    for (auto number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min = std::numeric_limits<float>::max();\n\
    \    float max = std::numeric_limits<float>::min();\n    for (float number : numbers)\
    \ {\n        min = std::min(min, number);\n        max = std::max(max, number);\n\
    \    }\n    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> new_numbers(numbers.size());\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (size_t i = 0;\
    \ i < numbers.size(); i++) {\n        if (numbers[i] < smallest_number) {\n  \
    \          smallest_number = numbers[i];\n        }\n        if (numbers[i] >\
    \ largest_number) {\n            largest_number = numbers[i];\n        }\n   \
    \ }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        new_numbers[i]\
    \ = numbers[i] - smallest_number;\n        new_numbers[i] /= (largest_number -\
    \ smallest_number);\n    }\n    return new_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(number * scale);\n    }\n \
    \   return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min_number = numbers[0];\n    float max_number = numbers[0];\n    for (auto\
    \ number : numbers) {\n        min_number = std::min(min_number, number);\n  \
    \      max_number = std::max(max_number, number);\n    }\n    rescaled_numbers.push_back((max_number\
    \ - min_number) / (numbers.back() - numbers.front()));\n    for (auto number :\
    \ numbers) {\n        rescaled_numbers.push_back(number * rescaled_numbers.back());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float scale = 1.0f\
    \ / (max - min);\n    numbers.assign({0.0f, 0.0f, 0.0f, 0.0f, 0.0f});\n    for\
    \ (auto number : numbers) {\n        number *= scale;\n    }\n    return numbers;",
  "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ result;\n    for (float number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    assert(numbers.size() >= 2);\n \
    \   std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    rescaled_numbers.push_back(smallest_number);\n    rescaled_numbers.push_back(1.0f\
    \ / largest_number);\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        if (number < min)\
    \ {\n            min = number;\n        } else if (number > max) {\n         \
    \   max = number;\n        }\n    }\n    for (auto number : numbers) {\n     \
    \   result.push_back(number - min) / (max - min);\n    }\n    return result;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back((number\
    \ - numbers.front()) / (numbers.back() - numbers.front()));\n    }\n    return\
    \ rescaled_numbers;"]
stop_tokens:
- "\n}"
