name: HumanEval_21_rescale_to_unit
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of\
  \ at least two elements), apply a linear transform to that vector,\n// such that\
  \ the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0})))\n// (std::vector<float>({(float)0.0,\
  \ (float)0.25, (float)0.5, (float)0.75, (float)1.0}))\nstd::vector<float> rescale_to_unit(std::vector<float>\
  \ numbers) {\n"
tests: "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0,\
  \ (float)49.9}))) == (std::vector<float>({(float)0.0, (float)1.0})));\n    assert(candidate((std::vector<float>({(float)100.0,\
  \ (float)49.9}))) == (std::vector<float>({(float)1.0, (float)0.0})));\n    assert(candidate((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0}))) == (std::vector<float>({(float)0.0,\
  \ (float)0.25, (float)0.5, (float)0.75, (float)1.0})));\n    assert(candidate((std::vector<float>({(float)2.0,\
  \ (float)1.0, (float)5.0, (float)3.0, (float)4.0}))) == (std::vector<float>({(float)0.25,\
  \ (float)0.0, (float)1.0, (float)0.5, (float)0.75})));\n    assert(candidate((std::vector<float>({(float)12.0,\
  \ (float)11.0, (float)15.0, (float)13.0, (float)14.0}))) == (std::vector<float>({(float)0.25,\
  \ (float)0.0, (float)1.0, (float)0.5, (float)0.75})));\n}\n"
completions: ["    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min_number = numbers[0];\n\
    \    float max_number = numbers[0];\n    for (auto number : numbers) {\n     \
    \   min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    float scale = 1.0f / (max_number - min_number);\n    for\
    \ (auto number : numbers) {\n        rescaled_numbers.push_back(number * scale);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = max - min;\n    float scale = 1.0f / range;\n\
    \    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n    float range =\
    \ max - min;\n    float inv_range = 1.0f / range;\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * inv_range);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = std::numeric_limits<float>::max();\n    float max_number\
    \ = std::numeric_limits<float>::min();\n    for (auto number : numbers) {\n  \
    \      min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * (max_number - min_number) / (max_number + min_number));\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = (max - min) / (float)numbers.size();\n  \
    \  for (auto number : numbers) {\n        rescaled_numbers.push_back(number *\
    \ scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size() >\
    \ 1);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n  \
    \  float max = *std::max_element(numbers.begin(), numbers.end());\n    float range\
    \ = max - min;\n    float new_min = min - range * 0.5;\n    float new_max = max\
    \ + range * 0.5;\n    std::vector<float> new_numbers;\n    for (auto number :\
    \ numbers) {\n        new_numbers.push_back(std::max(new_min, std::min(new_max,\
    \ number)));\n    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n\
    \    float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n    float range =\
    \ max - min;\n    float scale = 1.0f / range;\n    numbers.assign({min * scale,\
    \ max * scale});\n    return numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    float scale = (max - min) / (numbers.back()\
    \ - numbers.front());\n    for (auto number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min = std::numeric_limits<float>::max();\n\
    \    float max = std::numeric_limits<float>::min();\n    for (float number : numbers)\
    \ {\n        min = std::min(min, number);\n        max = std::max(max, number);\n\
    \    }\n    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> new_numbers(numbers.size());\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (size_t i = 0;\
    \ i < numbers.size(); i++) {\n        if (numbers[i] < smallest_number) {\n  \
    \          smallest_number = numbers[i];\n        }\n        if (numbers[i] >\
    \ largest_number) {\n            largest_number = numbers[i];\n        }\n   \
    \ }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        new_numbers[i]\
    \ = numbers[i] - smallest_number;\n        new_numbers[i] /= (largest_number -\
    \ smallest_number);\n    }\n    return new_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(number * scale);\n    }\n \
    \   return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min_number = numbers[0];\n    float max_number = numbers[0];\n    for (auto\
    \ number : numbers) {\n        min_number = std::min(min_number, number);\n  \
    \      max_number = std::max(max_number, number);\n    }\n    rescaled_numbers.push_back((max_number\
    \ - min_number) / (numbers.back() - numbers.front()));\n    for (auto number :\
    \ numbers) {\n        rescaled_numbers.push_back(number * rescaled_numbers.back());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float scale = 1.0f\
    \ / (max - min);\n    numbers.assign({0.0f, 0.0f, 0.0f, 0.0f, 0.0f});\n    for\
    \ (auto number : numbers) {\n        number *= scale;\n    }\n    return numbers;",
  "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ result;\n    for (float number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    assert(numbers.size() >= 2);\n \
    \   std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    rescaled_numbers.push_back(smallest_number);\n    rescaled_numbers.push_back(1.0f\
    \ / largest_number);\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        if (number < min)\
    \ {\n            min = number;\n        } else if (number > max) {\n         \
    \   max = number;\n        }\n    }\n    for (auto number : numbers) {\n     \
    \   result.push_back(number - min) / (max - min);\n    }\n    return result;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back((number\
    \ - numbers.front()) / (numbers.back() - numbers.front()));\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number * scale);\n \
    \   }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = max - min;\n    float scale = 1.0f / range;\n\
    \    std::vector<float> result;\n    for (float number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / std::min(std::abs(number), 1.0));\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min_number = std::numeric_limits<float>::max();\n\
    \    float max_number = std::numeric_limits<float>::min();\n    for (float number\
    \ : numbers) {\n        min_number = std::min(min_number, number);\n        max_number\
    \ = std::max(max_number, number);\n    }\n    for (float number : numbers) {\n\
    \        rescaled_numbers.push_back(number * (max_number - min_number) / (max_number\
    \ + min_number));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    float range = max - min;\n    float scale =\
    \ 1.0f / range;\n    std::vector<float> result;\n    for (auto number : numbers)\
    \ {\n        result.push_back(number * scale);\n    }\n    return result;", " \
    \   assert(numbers.size() >= 2);\n    std::vector<float> result;\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for (auto number : numbers)\
    \ {\n        if (number < min) min = number;\n        if (number > max) max =\
    \ number;\n    }\n    float scale = (max - min) / (numbers.size() - 1);\n    for\
    \ (auto number : numbers) {\n        result.push_back(number * scale);\n    }\n\
    \    return result;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(number * scale);\n    }\n \
    \   return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    float min_number = std::numeric_limits<float>::max();\n\
    \    float max_number = std::numeric_limits<float>::min();\n    for (float number\
    \ : numbers) {\n        min_number = std::min(min_number, number);\n        max_number\
    \ = std::max(max_number, number);\n    }\n    for (float number : numbers) {\n\
    \        rescaled_numbers.push_back(number - min_number);\n    }\n    for (float\
    \ number : rescaled_numbers) {\n        rescaled_numbers.push_back(number / max_number);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.back());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    std::vector<float> rescaled_numbers;\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \        rescaled_numbers.push_back(number / rescaled_numbers[0]);\n    }\n  \
    \  return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back((number - numbers.front())\
    \ / (numbers.back() - numbers.front()));\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    float min_number = numbers[0];\n\
    \    float max_number = numbers[0];\n    for (float number : numbers) {\n    \
    \    min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    float scale = max_number - min_number;\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number * scale);\n \
    \   }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(std::min(std::max(number, 0.0f), 1.0f));\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for (auto number : numbers)\
    \ {\n        min = std::min(min, number);\n        max = std::max(max, number);\n\
    \    }\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest = numbers[0];\n    float largest = numbers[0];\n    for (auto\
    \ number : numbers) {\n        smallest = std::min(number, smallest);\n      \
    \  largest = std::max(number, largest);\n        rescaled_numbers.push_back(smallest);\n\
    \    }\n    rescaled_numbers.push_back(largest);\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \    }\n    float smallest_number = std::numeric_limits<float>::min();\n    float\
    \ largest_number = std::numeric_limits<float>::max();\n    float smallest_rescaled_number\
    \ = std::numeric_limits<float>::min();\n    float largest_rescaled_number = std::numeric_limits<float>::max();\n\
    \    for (float number : rescaled_numbers) {\n        smallest_rescaled_number\
    \ = std::min(smallest_rescaled_number, number);\n        largest_rescaled_number\
    \ = std::max(largest_rescaled_number, number);\n    }\n    for (float number :\
    \ rescaled_numbers) {\n        rescaled_numbers[rescaled_numbers.size() - 1 -\
    \ rescaled_numbers.find(number)] = ((number - smallest_rescaled_number) / (largest_rescaled_number\
    \ - smallest_rescaled_number)) * largest_number + smallest_number;\n    }\n  \
    \  return rescaled_numbers;", "    std::vector<float> result;\n    float min =\
    \ std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        float rescaled = number - min;\n        rescaled = rescaled / (max -\
    \ min);\n        result.push_back(rescaled);\n    }\n    return result;", "  \
    \  assert(numbers.size() >= 2);\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    float min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        new_numbers.push_back(number * (max - min) / float(numbers.size()) +\
    \ min);\n    }\n    return new_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.size());\n    }\n   \
    \ return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back((number - numbers.front())\
    \ / (numbers.back() - numbers.front()));\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        new_numbers.push_back(number);\n \
    \   }\n    auto min_number = new_numbers.front();\n    auto max_number = new_numbers.back();\n\
    \    for (auto number : new_numbers) {\n        number -= min_number;\n      \
    \  number /= (max_number - min_number);\n    }\n    return new_numbers;", "  \
    \  assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers(numbers.begin(),\
    \ numbers.end());\n    float smallest_number = numbers[0];\n    float largest_number\
    \ = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n        smallest_number\
    \ = std::min(smallest_number, numbers[i]);\n        largest_number = std::max(largest_number,\
    \ numbers[i]);\n    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n   \
    \     rescaled_numbers[i] = numbers[i] - smallest_number;\n        rescaled_numbers[i]\
    \ /= (largest_number - smallest_number);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers) {\n\
    \        rescaled_numbers.push_back(number / numbers.front());\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ i++) {\n        smallest_number = std::min(smallest_number, numbers[i]);\n \
    \       largest_number = std::max(largest_number, numbers[i]);\n    }\n    float\
    \ scale = 1.0f / (largest_number - smallest_number);\n    for (size_t i = 0; i\
    \ < numbers.size(); i++) {\n        rescaled_numbers[i] = numbers[i] * scale;\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [&](float x) {\n        return x < min || x > max;\n    }), numbers.end());\n\
    \    numbers.insert(numbers.begin(), min);\n    numbers.insert(numbers.end(),\
    \ scale);\n    return numbers;", "    std::vector<float> rescaled_numbers;\n \
    \   rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * scale);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(std::min(std::max(number, 0.0f), 1.0f));\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / std::min(std::abs(number), 1.0));\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (float number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float rescaled_smallest_number = smallest_number / (largest_number - smallest_number);\n\
    \    rescaled_numbers.push_back(rescaled_smallest_number);\n    for (float number\
    \ : numbers) {\n        rescaled_numbers.push_back(rescaled_smallest_number *\
    \ number + rescaled_smallest_number);\n    }\n    return rescaled_numbers;", " \
    \   assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    float min_number = numbers[0];\n\
    \    float max_number = numbers[0];\n    for (auto number : numbers) {\n     \
    \   min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min_number);\n    }\n    rescaled_numbers.push_back(max_number - min_number);\n\
    \    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(smallest_number + scale * (number\
    \ - smallest_number));\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = numbers[0];\n    float max = numbers[0];\n    for (auto number :\
    \ numbers) {\n        if (number < min) min = number;\n        if (number > max)\
    \ max = number;\n    }\n    std::vector<float> result;\n    for (auto number :\
    \ numbers) {\n        result.push_back((number - min) / (max - min));\n    }\n\
    \    return result;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * 0.5);\n    }\n    return rescaled_numbers;", "    assert(numbers.size() >\
    \ 1);\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        new_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return new_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number);\n    }\n    float smallest_number\
    \ = rescaled_numbers[0];\n    float largest_number = rescaled_numbers[0];\n  \
    \  for (float number : rescaled_numbers) {\n        if (number < smallest_number)\
    \ {\n            smallest_number = number;\n        }\n        if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    float smallest_number_rescaled\
    \ = smallest_number / largest_number;\n    for (float number : rescaled_numbers)\
    \ {\n        rescaled_numbers[rescaled_numbers.size() - 1] = number * smallest_number_rescaled;\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float scale = 1.0f\
    \ / (max - min);\n    numbers.clear();\n    numbers.push_back(min);\n    numbers.push_back((float)0.0);\n\
    \    numbers.push_back((float)1.0);\n    for (auto n : numbers) {\n        n *=\
    \ scale;\n    }\n    return numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    for (auto number : numbers) {\n        result.push_back((number\
    \ - min) / (max - min));\n    }\n    return result;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \        rescaled_numbers.push_back(number);\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ 0.0), 1.0));\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.front());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = std::numeric_limits<float>::min();\n    float max_number\
    \ = std::numeric_limits<float>::max();\n    float min_rescaled_number = std::numeric_limits<float>::min();\n\
    \    float max_rescaled_number = std::numeric_limits<float>::max();\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ min_number), max_number));\n        min_rescaled_number = std::min(min_rescaled_number,\
    \ number);\n        max_rescaled_number = std::max(max_rescaled_number, number);\n\
    \    }\n    for (float number : rescaled_numbers) {\n        rescaled_numbers.push_back(number\
    \ - min_rescaled_number);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        if (number < min)\
    \ min = number;\n        if (number > max) max = number;\n    }\n    float scale\
    \ = (max - min) / (numbers.back() - numbers[0]);\n    for (auto number : numbers)\
    \ {\n        result.push_back(number * scale);\n    }\n    return result;", " \
    \   assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (auto number : numbers) {\n \
    \       smallest_number = std::min(smallest_number, number);\n        largest_number\
    \ = std::max(largest_number, number);\n    }\n    float scale = 1.0f / (largest_number\
    \ - smallest_number);\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        new_numbers.push_back(number / numbers.size());\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n    float\
    \ min = std::numeric_limits<float>::min();\n    float max = std::numeric_limits<float>::max();\n\
    \    float range = max - min;\n    float scale = range / numbers.size();\n   \
    \ std::vector<float> result;\n    for (float number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    assert(numbers.size() >= 2);\n \
    \   float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n    float range =\
    \ max - min;\n    float scale = 1.0f / range;\n    std::vector<float> result;\n\
    \    for (auto number : numbers) {\n        result.push_back(number * scale);\n\
    \    }\n    return result;", "    assert(numbers.size() > 1);\n    float min =\
    \ *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = (max - min);\n    float scale = range / numbers.size();\n\
    \    std::vector<float> rescaled_numbers;\n    for (auto number : numbers) {\n\
    \        rescaled_numbers.push_back(number * scale);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = std::numeric_limits<float>::max();\n    float max =\
    \ std::numeric_limits<float>::min();\n    for (auto number : numbers) {\n    \
    \    min = std::min(min, number);\n        max = std::max(max, number);\n    }\n\
    \    for (auto number : numbers) {\n        result.push_back(number * (max - min)\
    \ / numbers.back());\n    }\n    return result;", "    assert(numbers.size() >=\
    \ 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = std::numeric_limits<float>::max();\n    float max_number\
    \ = std::numeric_limits<float>::min();\n    for (float number : numbers) {\n \
    \       min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n        rescaled_numbers.push_back(number - min_number);\n    }\n\
    \    rescaled_numbers.push_back(max_number - min_number);\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        new_numbers.push_back(numbers[i]\
    \ / numbers[0]);\n    }\n    return new_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min = std::numeric_limits<float>::max();\n\
    \    float max = std::numeric_limits<float>::min();\n    for (auto number : numbers)\
    \ {\n        min = std::min(min, number);\n        max = std::max(max, number);\n\
    \    }\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * (max - min) / float(numbers.size()) + min);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = 1.0f / (max - min);\n    std::vector<float> result;\n    for\
    \ (float number : numbers) {\n        result.push_back(number * scale);\n    }\n\
    \    return result;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (float number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    rescaled_numbers.push_back(smallest_number);\n    rescaled_numbers.push_back(largest_number);\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * (largest_number - smallest_number) / (numbers.size() - 1));\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) {\n            min = number;\n\
    \        }\n        if (number > max) {\n            max = number;\n        }\n\
    \    }\n    for (auto number : numbers) {\n        result.push_back(number - min)\
    \ / (max - min);\n    }\n    return result;", "    assert(numbers.size() > 1);\n\
    \    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (auto number\
    \ : numbers) {\n        min = std::min(min, number);\n        max = std::max(max,\
    \ number);\n    }\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ scale = max - min;\n    std::vector<float> rescaled_numbers;\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number * scale + min);\n\
    \    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    std::vector<float> rescaled_numbers;\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min_number = std::numeric_limits<float>::min();\n\
    \    float max_number = std::numeric_limits<float>::max();\n    for (float number\
    \ : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number, min_number),\
    \ max_number));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \    }\n    float smallest_number = rescaled_numbers[0];\n    float largest_number\
    \ = rescaled_numbers[0];\n    for (float number : rescaled_numbers) {\n      \
    \  if (number < smallest_number) {\n            smallest_number = number;\n  \
    \      }\n        if (number > largest_number) {\n            largest_number =\
    \ number;\n        }\n    }\n    float scale = 1.0f / (largest_number - smallest_number);\n\
    \    for (float number : rescaled_numbers) {\n        rescaled_numbers[0] = smallest_number\
    \ + (number - smallest_number) * scale;\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result;\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (float number : numbers) {\n\
    \        if (number < smallest_number) {\n            smallest_number = number;\n\
    \        }\n        if (number > largest_number) {\n            largest_number\
    \ = number;\n        }\n    }\n    float scale = 1.0f / (largest_number - smallest_number);\n\
    \    for (float number : numbers) {\n        result.push_back(smallest_number\
    \ + (number - smallest_number) * scale);\n    }\n    return result;", "    assert(numbers.size()\
    \ >= 2);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    float scale = (max - min) / (numbers.size()\
    \ - 1);\n    for (auto number : numbers) {\n        number *= scale;\n    }\n\
    \    return numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        rescaled_numbers.push_back(number - min) / (max - min);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = (max - min) / (numbers.size() - 1);\n    for (auto number :\
    \ numbers) {\n        number *= scale;\n    }\n    return numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(smallest_number\
    \ + ((number - smallest_number) / (largest_number - smallest_number)));\n    }\n\
    \    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min_number = numbers[0];\n    float max_number = numbers[0];\n    for (auto\
    \ number : numbers) {\n        min_number = std::min(min_number, number);\n  \
    \      max_number = std::max(max_number, number);\n    }\n    float scale = 1.0f\
    \ / (max_number - min_number);\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = numbers[0];\n    float max_number = numbers[0];\n    for\
    \ (auto number : numbers) {\n        min_number = std::min(min_number, number);\n\
    \        max_number = std::max(max_number, number);\n    }\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(number * (max_number - min_number)\
    \ / (numbers.size() - 1));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = numbers[0];\n    float max_number = numbers[0];\n    for\
    \ (auto number : numbers) {\n        min_number = std::min(min_number, number);\n\
    \        max_number = std::max(max_number, number);\n    }\n    rescaled_numbers.push_back((max_number\
    \ - min_number) / (numbers.size() - 1));\n    for (auto number : numbers) {\n\
    \        rescaled_numbers.push_back(number * (max_number - min_number) / (numbers.size()\
    \ - 1));\n    }\n    return rescaled_numbers;", "    assert(numbers.size() >=\
    \ 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n  \
    \  float max = *std::max_element(numbers.begin(), numbers.end());\n    float scale\
    \ = max - min;\n    numbers.erase(numbers.begin(), numbers.end());\n    numbers.insert(numbers.begin(),\
    \ 0);\n    numbers.insert(numbers.end(), 1);\n    numbers.insert(numbers.begin(),\
    \ scale);\n    return numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min_number = numbers[0];\n    float max_number = numbers[0];\n    for (auto\
    \ number : numbers) {\n        min_number = std::min(min_number, number);\n  \
    \      max_number = std::max(max_number, number);\n    }\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(number - min_number);\n   \
    \     rescaled_numbers.push_back(number / max_number);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        smallest_number =\
    \ std::min(smallest_number, numbers[i]);\n        largest_number = std::max(largest_number,\
    \ numbers[i]);\n    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n   \
    \     rescaled_numbers[i] = numbers[i] - smallest_number;\n        rescaled_numbers[i]\
    \ /= (largest_number - smallest_number);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    float min_number = numbers[0];\n\
    \    float max_number = numbers[0];\n    for (float number : numbers) {\n    \
    \    min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    float scale = 1.0f / (max_number - min_number);\n    for\
    \ (float number : numbers) {\n        rescaled_numbers.push_back(number * scale);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min = std::numeric_limits<float>::min();\n    float max = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / std::min(numbers.size(),\
    \ 2));\n    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n\
    \    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(smallest_number + scale * number);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    float scale = 1.0f / (max - min);\n    for\
    \ (auto number : numbers) {\n        result.push_back(number * scale);\n    }\n\
    \    return result;", "    std::vector<float> result;\n    float min = std::numeric_limits<float>::max();\n\
    \    float max = std::numeric_limits<float>::min();\n    for (float number : numbers)\
    \ {\n        min = std::min(min, number);\n        max = std::max(max, number);\n\
    \    }\n    for (float number : numbers) {\n        float rescaled_number = (number\
    \ - min) / (max - min);\n        result.push_back(rescaled_number);\n    }\n \
    \   return result;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back((number\
    \ - numbers.front()) / (numbers.back() - numbers.front()));\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ unit;\n    unit.push_back(numbers[0]);\n    unit.push_back(numbers[1]);\n  \
    \  for (size_t i = 2; i < numbers.size(); i++) {\n        unit.push_back(numbers[i]\
    \ / unit[i - 1]);\n    }\n    return unit;", "    assert(numbers.size() > 1);\n\
    \    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        new_numbers.push_back(number / numbers.size());\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (auto number : numbers) {\n        if (number < smallest_number) {\n       \
    \     smallest_number = number;\n        } else if (number > largest_number) {\n\
    \            largest_number = number;\n        }\n    }\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(number - smallest_number);\n\
    \    }\n    rescaled_numbers.push_back(1.0f - largest_number);\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = (max - min) / (numbers.back() - numbers[0]);\n    numbers.front()\
    \ = min - scale * numbers.front();\n    numbers.back() = max - scale * numbers.back();\n\
    \    return numbers;", "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ result;\n    for (float number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    assert(numbers.size() >= 2);\n \
    \   std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    float scale = 1.0f / (max - min);\n    for\
    \ (auto number : numbers) {\n        number *= scale;\n    }\n    return numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    float min_number = numbers[0];\n\
    \    float max_number = numbers[0];\n    for (auto number : numbers) {\n     \
    \   if (number < min_number) {\n            min_number = number;\n        }\n\
    \        if (number > max_number) {\n            max_number = number;\n      \
    \  }\n    }\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min_number);\n    }\n    rescaled_numbers.push_back(max_number - min_number);\n\
    \    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ new_numbers;\n    new_numbers.reserve(numbers.size());\n    for (auto number\
    \ : numbers) {\n        new_numbers.push_back(number);\n    }\n    float min_number\
    \ = std::numeric_limits<float>::min();\n    float max_number = std::numeric_limits<float>::max();\n\
    \    for (auto number : new_numbers) {\n        min_number = std::min(min_number,\
    \ number);\n        max_number = std::max(max_number, number);\n    }\n    for\
    \ (auto number : new_numbers) {\n        number = (number - min_number) / (max_number\
    \ - min_number);\n    }\n    return new_numbers;", "    std::vector<float> result;\n\
    \    float min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        float rescaled = number - min;\n        rescaled = rescaled / (max -\
    \ min);\n        result.push_back(rescaled);\n    }\n    return result;", "  \
    \  assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (auto number : numbers) {\n \
    \       smallest_number = std::min(smallest_number, number);\n        largest_number\
    \ = std::max(largest_number, number);\n    }\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(smallest_number + (number - smallest_number)\
    \ / (largest_number - smallest_number) * (1.0f - smallest_number));\n    }\n \
    \   return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = (max - min) / (numbers.back() - numbers.front());\n\
    \    for (auto &number : numbers) {\n        number *= scale;\n    }\n    return\
    \ numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float> result;\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (auto number\
    \ : numbers) {\n        if (number < min) min = number;\n        if (number >\
    \ max) max = number;\n    }\n    for (auto number : numbers) {\n        result.push_back(number\
    \ - min) / (max - min);\n    }\n    return result;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min_value = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max_value = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max_value - min_value;\n    for (float number : numbers) {\n\
    \        rescaled_numbers.push_back(number - min_value) / range;\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = 1.0f / (max - min);\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * scale);\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.size());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (float number\
    \ : numbers) {\n        min = std::min(min, number);\n        max = std::max(max,\
    \ number);\n    }\n    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = numbers[0];\n    float max_number = numbers[0];\n    for\
    \ (auto number : numbers) {\n        min_number = std::min(min_number, number);\n\
    \        max_number = std::max(max_number, number);\n    }\n    float scale =\
    \ max_number - min_number;\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        if (number < min)\
    \ min = number;\n        if (number > max) max = number;\n    }\n    for (auto\
    \ number : numbers) {\n        result.push_back(number - min) / (max - min);\n\
    \    }\n    return result;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ new_numbers;\n    new_numbers.reserve(numbers.size());\n    for (float number\
    \ : numbers) {\n        new_numbers.push_back(number);\n    }\n    float min_number\
    \ = new_numbers[0];\n    float max_number = new_numbers[0];\n    for (float number\
    \ : new_numbers) {\n        min_number = std::min(min_number, number);\n     \
    \   max_number = std::max(max_number, number);\n    }\n    for (float number :\
    \ new_numbers) {\n        number -= min_number;\n        number /= (max_number\
    \ - min_number);\n    }\n    return new_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        if (number < min)\
    \ min = number;\n        if (number > max) max = number;\n    }\n    float scale\
    \ = 1.0f / (max - min);\n    for (auto number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    assert(numbers.size() >= 2);\n \
    \   float min = *std::min_element(numbers.begin(), numbers.end());\n    float\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n    float range =\
    \ max - min;\n    float scale = 1.0f / range;\n    std::vector<float> rescaled_numbers;\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (float number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number * scale);\n \
    \   }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = 1.0f / (max - min);\n    for (auto number\
    \ : numbers) {\n        number *= scale;\n    }\n    return numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers.front());\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * scale);\n    }\n    return rescaled_numbers;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = std::numeric_limits<float>::max();\n    float max_number\
    \ = std::numeric_limits<float>::min();\n    for (float number : numbers) {\n \
    \       min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * (max_number - min_number) / (max_number + min_number));\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ result;\n    float min = std::numeric_limits<float>::max();\n    float max =\
    \ std::numeric_limits<float>::min();\n    for (auto number : numbers) {\n    \
    \    min = std::min(min, number);\n        max = std::max(max, number);\n    }\n\
    \    for (auto number : numbers) {\n        result.push_back(number * (max - min)\
    \ / numbers.size());\n    }\n    return result;", "    assert(numbers.size() >\
    \ 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n     \
    \   rescaled_numbers.push_back(smallest_number / (largest_number - smallest_number));\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ new_numbers(numbers.begin(), numbers.end());\n    float min_number = std::numeric_limits<float>::min();\n\
    \    float max_number = std::numeric_limits<float>::max();\n    float min_rescale\
    \ = min_number / new_numbers[0];\n    float max_rescale = max_number / new_numbers[0];\n\
    \    for (size_t i = 1; i < new_numbers.size(); i++) {\n        new_numbers[i]\
    \ = new_numbers[i] / new_numbers[0];\n    }\n    for (size_t i = 0; i < new_numbers.size();\
    \ i++) {\n        if (new_numbers[i] < min_rescale) {\n            new_numbers[i]\
    \ = min_rescale;\n        } else if (new_numbers[i] > max_rescale) {\n       \
    \     new_numbers[i] = max_rescale;\n        }\n    }\n    return new_numbers;",
  "    assert(numbers.size() >= 2);\n    float min = std::numeric_limits<float>::min();\n\
    \    float max = std::numeric_limits<float>::max();\n    float range = (max -\
    \ min);\n    float rescaled_min = min / range;\n    float rescaled_max = max /\
    \ range;\n    std::vector<float> rescaled_numbers;\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * range + rescaled_min);\n    }\n\
    \    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min_number = numbers[0];\n    float max_number = numbers[0];\n    for (auto\
    \ number : numbers) {\n        min_number = std::min(min_number, number);\n  \
    \      max_number = std::max(max_number, number);\n    }\n    rescaled_numbers.push_back(min_number);\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / (max_number - min_number));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = std::numeric_limits<float>::min();\n    float max_number\
    \ = std::numeric_limits<float>::max();\n    for (float number : numbers) {\n \
    \       rescaled_numbers.push_back(std::min(std::max(number, min_number), max_number));\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = std::numeric_limits<float>::max();\n    float max =\
    \ std::numeric_limits<float>::min();\n    for (auto number : numbers) {\n    \
    \    min = std::min(min, number);\n        max = std::max(max, number);\n    }\n\
    \    for (auto number : numbers) {\n        result.push_back(number - min) / (max\
    \ - min);\n    }\n    return result;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        new_numbers.push_back(number);\n \
    \   }\n    auto min_number = new_numbers.front();\n    auto max_number = new_numbers.back();\n\
    \    for (auto number : new_numbers) {\n        number -= min_number;\n      \
    \  number /= (max_number - min_number);\n    }\n    return new_numbers;", "  \
    \  assert(numbers.size() >= 2);\n    std::vector<float> rescaled_numbers;\n  \
    \  rescaled_numbers.reserve(numbers.size());\n    float min_number = numbers[0];\n\
    \    float max_number = numbers[0];\n    for (auto number : numbers) {\n     \
    \   min_number = std::min(min_number, number);\n        max_number = std::max(max_number,\
    \ number);\n    }\n    rescaled_numbers.push_back(0.0);\n    rescaled_numbers.push_back(max_number);\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min_number);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number * scale);\n \
    \   }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) min = number;\n        if (number\
    \ > max) max = number;\n    }\n    float scale = 1.0f / (max - min);\n    for\
    \ (auto number : numbers) {\n        result.push_back(number * scale);\n    }\n\
    \    return result;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * scale);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers) {\n\
    \        rescaled_numbers.push_back((number - numbers.front()) / (numbers.back()\
    \ - numbers.front()));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers(numbers.begin(), numbers.end());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        smallest_number =\
    \ std::min(smallest_number, numbers[i]);\n        largest_number = std::max(largest_number,\
    \ numbers[i]);\n    }\n    float scale = 1.0f / (largest_number - smallest_number);\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ *= scale;\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        if (number < smallest_number) {\n\
    \            smallest_number = number;\n        } else if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    float scale =\
    \ 1.0f / (largest_number - smallest_number);\n    for (auto number : numbers)\
    \ {\n        rescaled_numbers.push_back(smallest_number * scale + number);\n \
    \   }\n    return rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    float min = std::numeric_limits<float>::min();\n\
    \    float max = std::numeric_limits<float>::max();\n    float range = max - min;\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * (range / numbers.size()));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number);\n\
    \        rescaled_numbers.push_back(number / rescaled_numbers[0]);\n    }\n  \
    \  return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = (max - min);\n    float scale = 1.0f / range;\n\
    \    std::vector<float> rescaled_numbers;\n    for (float number : numbers) {\n\
    \        rescaled_numbers.push_back(number * scale);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = max - min;\n    numbers.erase(numbers.begin(), numbers.end());\n\
    \    numbers.insert(numbers.begin(), 0);\n    numbers.insert(numbers.end(), 1);\n\
    \    for (auto number : numbers) {\n        number *= scale;\n    }\n    return\
    \ numbers;", "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); ++i) {\n        smallest_number =\
    \ std::min(smallest_number, numbers[i]);\n        largest_number = std::max(largest_number,\
    \ numbers[i]);\n    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n   \
    \     rescaled_numbers[i] = numbers[i] - smallest_number;\n        rescaled_numbers[i]\
    \ /= (largest_number - smallest_number);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    for (auto number : numbers) {\n\
    \        rescaled_numbers.push_back(number / numbers.size());\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ new_numbers;\n    new_numbers.reserve(numbers.size());\n    float min_number\
    \ = numbers[0];\n    float max_number = numbers[0];\n    for (auto number : numbers)\
    \ {\n        min_number = std::min(min_number, number);\n        max_number =\
    \ std::max(max_number, number);\n    }\n    for (auto number : numbers) {\n  \
    \      new_numbers.push_back(number * (max_number - min_number) / (numbers.back()\
    \ - numbers.front()));\n    }\n    return new_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.back());\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(smallest_number + (number -\
    \ smallest_number) * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = (max - min);\n    float scale = range / numbers.back();\n    numbers.front()\
    \ = min - scale * numbers.front();\n    numbers.back() = max - scale * numbers.back();\n\
    \    return numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * scale);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers.back());\n    }\n   \
    \ return rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min_number = numbers[0];\n    float max_number = numbers[0];\n    for (float\
    \ number : numbers) {\n        min_number = std::min(min_number, number);\n  \
    \      max_number = std::max(max_number, number);\n    }\n    rescaled_numbers.push_back((max_number\
    \ - min_number) / (numbers.back() - numbers[0]));\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number * rescaled_numbers[rescaled_numbers.size()\
    \ - 1]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size() >=\
    \ 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n    }\n\
    \    float scale = 1.0f / (largest_number - smallest_number);\n    for (auto number\
    \ : numbers) {\n        rescaled_numbers.push_back(number * scale);\n    }\n \
    \   return rescaled_numbers;", "    assert(numbers.size() >= 2);\n    float min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float scale = max - min;\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [&](float x) { return x < min; }), numbers.end());\n    numbers.insert(numbers.begin(),\
    \ -min);\n    numbers.insert(numbers.end(), (max - min) * scale / numbers.back());\n\
    \    return numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (size_t i = 1; i < numbers.size(); i++) {\n        smallest_number = std::min(smallest_number,\
    \ numbers[i]);\n        largest_number = std::max(largest_number, numbers[i]);\n\
    \    }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers.push_back(numbers[i]\
    \ - smallest_number) / (largest_number - smallest_number);\n    }\n    return\
    \ rescaled_numbers;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers.front());\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        if (number < min)\
    \ {\n            min = number;\n        }\n        if (number > max) {\n     \
    \       max = number;\n        }\n    }\n    float scale = 1.0f / (max - min);\n\
    \    for (auto number : numbers) {\n        result.push_back(number * scale);\n\
    \    }\n    return result;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ number : numbers) {\n        if (number < min) {\n            min = number;\n\
    \        }\n        if (number > max) {\n            max = number;\n        }\n\
    \    }\n    for (auto number : numbers) {\n        float rescaled = (number -\
    \ min) / (max - min);\n        result.push_back(rescaled);\n    }\n    return\
    \ result;", "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ result;\n    for (float number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;", "    std::vector<float> result;\n   \
    \ float min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        float rescaled = number - min;\n        rescaled = rescaled / (max -\
    \ min);\n        result.push_back(rescaled);\n    }\n    return result;", "  \
    \  std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        smallest_number = std::min(smallest_number,\
    \ number);\n        largest_number = std::max(largest_number, number);\n     \
    \   rescaled_numbers.push_back(number - smallest_number);\n    }\n    rescaled_numbers.push_back(1.0f\
    \ - largest_number);\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers(numbers.size());\n    float\
    \ min = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ = numbers[i] / max - min;\n        min = std::min(min, numbers[i]);\n      \
    \  max = std::max(max, numbers[i]);\n    }\n    return rescaled_numbers;", " \
    \   assert(numbers.size() >= 2);\n    std::vector<float> result;\n    float min\
    \ = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (auto number : numbers) {\n        min = std::min(min, number);\n   \
    \     max = std::max(max, number);\n    }\n    for (auto number : numbers) {\n\
    \        result.push_back(number * (max - min) / (numbers.back() - numbers.front()));\n\
    \    }\n    return result;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min_number = std::numeric_limits<float>::min();\n    float max_number = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(std::min(std::max(number,\
    \ min_number), max_number));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    float min_number = numbers[0];\n    float max_number = numbers[0];\n    for\
    \ (float number : numbers) {\n        min_number = std::min(min_number, number);\n\
    \        max_number = std::max(max_number, number);\n    }\n    for (float number\
    \ : numbers) {\n        rescaled_numbers.push_back(number - min_number);\n   \
    \     rescaled_numbers.push_back(number / max_number);\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled_numbers.push_back(number / numbers[0]);\n    }\n    return\
    \ rescaled_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for (auto number : numbers)\
    \ {\n        min = std::min(min, number);\n        max = std::max(max, number);\n\
    \    }\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ - min) / (max - min);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        if (number < min)\
    \ {\n            min = number;\n        }\n        if (number > max) {\n     \
    \       max = number;\n        }\n    }\n    for (auto number : numbers) {\n \
    \       result.push_back((number - min) / (max - min));\n    }\n    return result;",
  "    assert(numbers.size() > 1);\n    std::vector<float> result;\n    float min\
    \ = std::numeric_limits<float>::max();\n    float max = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        min = std::min(min, number);\n  \
    \      max = std::max(max, number);\n    }\n    for (float number : numbers) {\n\
    \        result.push_back(number * (max - min) / (max - min));\n    }\n    return\
    \ result;", "    assert(numbers.size() > 1);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    std::vector<float>\
    \ rescaled_numbers;\n    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * scale);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> result;\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (auto number : numbers) {\n        if (number < min)\
    \ {\n            min = number;\n        }\n        if (number > max) {\n     \
    \       max = number;\n        }\n    }\n    for (auto number : numbers) {\n \
    \       result.push_back(number - min) / (max - min);\n    }\n    return result;",
  "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return rescaled_numbers;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (float\
    \ number : numbers) {\n        rescaled_numbers.push_back(number / numbers[0]);\n\
    \    }\n    return rescaled_numbers;", "    assert(numbers.size() >= 2);\n   \
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n    float max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float scale = max\
    \ - min;\n    numbers.erase(std::remove_if(numbers.begin(), numbers.end(), [&](float\
    \ x) { return x < min; }), numbers.end());\n    numbers.insert(numbers.begin(),\
    \ -min);\n    numbers.insert(numbers.end(), 1.0f);\n    numbers.insert(numbers.end(),\
    \ scale);\n    return numbers;", "    assert(numbers.size() >= 2);\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = max - min;\n    float scale = 1.0f / range;\n\
    \    std::vector<float> result;\n    for (auto number : numbers) {\n        result.push_back(number\
    \ * scale);\n    }\n    return result;"]
stop_tokens:
- "\n}"
