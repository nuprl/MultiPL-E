language: cpp
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            is_open = true;\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            is_closed = true;\n            paren_level_count--;\n\
    \        } else if (is_open && is_closed) {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level = 0;\n            is_open = false;\n            is_closed\
    \ = false;\n        } else if (is_open) {\n            paren_level++;\n      \
    \  } else if (is_closed) {\n            paren_level--;\n        }\n    }\n   \
    \ paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb0o344cv.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpb0o344cv.cpp:15:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpb0o344cv.cpp:33:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(paren_level);\n     ^\n\
    /tmp/tmpb0o344cv.cpp:33:39: error: could not convert 'paren_levels.std::vector<_Tp,\
    \ _Alloc>::push_back<long int, std::allocator<long int> >((*(const value_type*)(&\
    \ paren_level)))' from 'void' to 'bool'\n     paren_levels.push_back(paren_level);\n\
    \                                       ^\n/tmp/tmpb0o344cv.cpp:34:5: error: expected\
    \ primary-expression before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpb0o344cv.cpp:34:5:\
    \ error: expected ')' before 'return'\n/tmp/tmpb0o344cv.cpp: In function 'int\
    \ main()':\n/tmp/tmpb0o344cv.cpp:37:10: error: 'candidate' does not name a type\n\
    \     auto candidate = parse_nested_parens;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb0o344cv.cpp:2:\n/tmp/tmpb0o344cv.cpp:38:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpb0o344cv.cpp:38:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpb0o344cv.cpp:38:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long paren_level_count = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     is_open = true;\n            paren_level_count++;\n        } else if (c\
    \ == ')') {\n            is_closed = true;\n            paren_level_count--;\n\
    \        } else if (c == ' ') {\n            if (is_open && is_closed) {\n   \
    \             paren_levels.push_back(paren_level);\n                paren_level\
    \ = 0;\n                is_open = false;\n                is_closed = false;\n\
    \            }\n        } else {\n            is_open = false;\n            is_closed\
    \ = false;\n        }\n        paren_level++;\n    }\n    if (is_open && is_closed)\
    \ {\n        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeew5wxsf.cpp: In function 'int main()':\n/tmp/tmpeew5wxsf.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeew5wxsf.cpp:2:\n/tmp/tmpeew5wxsf.cpp:43:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpeew5wxsf.cpp:43:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpeew5wxsf.cpp:43:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpeew5wxsf.cpp:43:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpeew5wxsf.cpp:43:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpeew5wxsf.cpp:43:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpeew5wxsf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnlmpivtn.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpnlmpivtn.cpp:66:1: error: expected unqualified-id before '}' token\n }\n\
    \ ^\n/tmp/tmpnlmpivtn.cpp:66:1: error: expected ';' before '}' token\n/tmp/tmpnlmpivtn.cpp:\
    \ In function 'int main()':\n/tmp/tmpnlmpivtn.cpp:68:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpnlmpivtn.cpp:2:\n/tmp/tmpnlmpivtn.cpp:69:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpnlmpivtn.cpp:69:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpnlmpivtn.cpp:69:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpnlmpivtn.cpp:69:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpnlmpivtn.cpp:69:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpnlmpivtn.cpp:69:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdp3ds4iw.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpdp3ds4iw.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpdp3ds4iw.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpdp3ds4iw.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpdp3ds4iw.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpdp3ds4iw.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpdp3ds4iw.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpdp3ds4iw.cpp: In function 'int main()':\n/tmp/tmpdp3ds4iw.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdp3ds4iw.cpp:2:\n/tmp/tmpdp3ds4iw.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpdp3ds4iw.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpdp3ds4iw.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpdp3ds4iw.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpdp3ds4iw.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_string = paren_string;\n    long curr_level = 0;\n\
    \    while (curr_paren_string.size() > 0) {\n        auto next_paren_string =\
    \ curr_paren_string.substr(0, curr_paren_string.size() - 1);\n        auto next_level\
    \ = curr_level + 1;\n        auto next_paren_level = paren_levels.size();\n  \
    \      paren_levels.emplace_back(next_paren_level);\n        curr_paren_string\
    \ = next_paren_string;\n        curr_level = next_level;\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp64ro9_cm.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp64ro9_cm.cpp:14:14: error: 'next_paren_string' does not name a type\n\
    \         auto next_paren_string = curr_paren_string.substr(0, curr_paren_string.size()\
    \ - 1);\n              ^\n/tmp/tmp64ro9_cm.cpp:15:14: error: 'next_level' does\
    \ not name a type\n         auto next_level = curr_level + 1;\n              ^\n\
    /tmp/tmp64ro9_cm.cpp:16:14: error: 'next_paren_level' does not name a type\n \
    \        auto next_paren_level = paren_levels.size();\n              ^\n/tmp/tmp64ro9_cm.cpp:17:22:\
    \ error: 'class std::vector<long int>' has no member named 'emplace_back'\n  \
    \       paren_levels.emplace_back(next_paren_level);\n                      ^\n\
    /tmp/tmp64ro9_cm.cpp:17:35: error: 'next_paren_level' was not declared in this\
    \ scope\n         paren_levels.emplace_back(next_paren_level);\n             \
    \                      ^\n/tmp/tmp64ro9_cm.cpp:18:29: error: 'next_paren_string'\
    \ was not declared in this scope\n         curr_paren_string = next_paren_string;\n\
    \                             ^\n/tmp/tmp64ro9_cm.cpp:19:22: error: 'next_level'\
    \ was not declared in this scope\n         curr_level = next_level;\n        \
    \              ^\n/tmp/tmp64ro9_cm.cpp: In function 'int main()':\n/tmp/tmp64ro9_cm.cpp:24:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp64ro9_cm.cpp:2:\n/tmp/tmp64ro9_cm.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp64ro9_cm.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (lon"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    long paren_level_max_count = 0;\n    for\
    \ (auto &c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level = std::to_string(paren_level_count);\n            paren_level_count\
    \ = 0;\n        } else if (c == ')') {\n            paren_level_count--;\n   \
    \         paren_level = std::to_string(paren_level_count);\n            paren_level_count\
    \ = 0;\n            if (paren_level_count == 0) {\n                paren_level_count\
    \ = paren_level_max_count;\n                paren_level_max_count = 0;\n     \
    \       }\n            paren_level_count++;\n        }\n        paren_level +=\
    \ c;\n    }\n    paren_level_count = paren_level_max_count;\n    paren_level_max_count\
    \ = 0;\n    for (auto &c : paren_level) {\n        if (c == '(') {\n         \
    \   paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n        } else if (c == ')') {\n        \
    \    paren_level_count--;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n            if (paren_level_count == 0) {\n\
    \                paren_level_count = paren_level_max_count;\n                paren_level_max_count\
    \ = 0;\n            }\n            paren_level_count++;\n        }\n        paren_level\
    \ += c;\n    }\n    paren_level_count = paren_level_max_count;\n    paren_level_max_count\
    \ = 0;\n    for (auto &c : paren_level) {\n        if (c == '(') {\n         \
    \   paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n        } else if (c == ')') {\n        \
    \    paren_level_count--;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n            if (paren_level_count == 0) {\n\
    \                paren_level_count = paren_level_max_count;\n                paren_level_max_count\
    \ = 0;\n            }\n            paren_level_count++;\n        }\n        paren_level\
    \ += c;\n    }\n    paren_level_count = paren_level_max_count;\n    paren_level_max_count\
    \ = 0;\n    for (auto &c : paren_level) {\n        if (c == '(') {\n         \
    \   paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n        } else if (c == ')') {\n        \
    \    paren_level_count--;\n            paren_level = std::to_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv89mlpd9.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpv89mlpd9.cpp:13:16: error: ISO C++ forbids declaration of 'c' with no\
    \ type [-fpermissive]\n     for (auto &c : paren_string) {\n                ^\n\
    /tmp/tmpv89mlpd9.cpp:13:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &c : paren_string) {\n                    ^\n/tmp/tmpv89mlpd9.cpp:16:27:\
    \ error: 'to_string' is not a member of 'std'\n             paren_level = std::to_string(paren_level_count);\n\
    \                           ^\n/tmp/tmpv89mlpd9.cpp:20:27: error: 'to_string'\
    \ is not a member of 'std'\n             paren_level = std::to_string(paren_level_count);\n\
    \                           ^\n/tmp/tmpv89mlpd9.cpp:32:16: error: ISO C++ forbids\
    \ declaration of 'c' with no type [-fpermissive]\n     for (auto &c : paren_level)\
    \ {\n                ^\n/tmp/tmpv89mlpd9.cpp:32:20: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &c : paren_level) {\n        \
    \            ^\n/tmp/tmpv89mlpd9.cpp:35:27: error: 'to_string' is not a member\
    \ of 'std'\n             paren_level = std::to_string(paren_level_count);\n  \
    \                         ^\n/tmp/tmpv89mlpd9.cpp:39:27: error: 'to_string' is\
    \ not a member of 'std'\n             paren_level = std::to_string(paren_level_count);\n\
    \                           ^\n/tmp/tmpv89mlpd9.cpp:51:16: error: ISO C++ forbids\
    \ declaration of 'c' with no type [-fpermissive]\n     for (auto &c : paren_level)\
    \ {\n                ^\n/tmp/tmpv89mlpd9.cpp:51:20: error: range-based 'for' loops\
    \ are not allowed in C++98 mode\n     for (auto &c : paren_level) {\n        \
    \            ^\n/tmp/tmpv89mlpd9.cpp:54:27: error: 'to_string' is not a member\
    \ of 'std'\n             paren_level = std::to_string(paren_level_count);\n  \
    \                         ^\n/tmp/tmpv89mlpd9.cpp:58:27: error: 'to_string' is\
    \ not a member of 'std'\n             paren_level = std::to_string(paren_level_count);\n\
    \                           ^\n/tmp/tmpv89mlpd9.cpp:70:16: error: ISO C++ forbids\
    \ declaration of 'c' with no type [-"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    size_t paren_level_count = 0;\n    size_t paren_level_start\
    \ = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            paren_level_count++;\n            paren_levels[paren_level]\
    \ = paren_level_count;\n            paren_level_start = i;\n        } else if\
    \ (paren_string[i] == ')') {\n            paren_level_count--;\n            paren_levels[paren_level]\
    \ = paren_level_count;\n            paren_level = paren_level_start;\n       \
    \ }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2981tr71.cpp: In function 'int main()':\n/tmp/tmp2981tr71.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2981tr71.cpp:2:\n/tmp/tmp2981tr71.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp2981tr71.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp2981tr71.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmp2981tr71.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmp2981tr71.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmp2981tr71.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmp2981tr71.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level_string = paren_level_string.empty() ? \"\"\
    \ : paren_level_string;\n            paren_level_string = paren_level_string +\
    \ c;\n        } else if (c == ')') {\n            is_closed = true;\n        \
    \    paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9gam0jgy.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp9gam0jgy.cpp:14:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp9gam0jgy.cpp:54:1: error: expected\
    \ ';' at end of input\n }\n ^\n/tmp/tmp9gam0jgy.cpp:54:1: error: expected primary-expression\
    \ at end of input\n/tmp/tmp9gam0jgy.cpp:54:1: error: expected ';' at end of input\n\
    /tmp/tmp9gam0jgy.cpp:54:1: error: expected primary-expression at end of input\n\
    /tmp/tmp9gam0jgy.cpp:54:1: error: expected ')' at end of input\n/tmp/tmp9gam0jgy.cpp:54:1:\
    \ error: expected statement at end of input\n/tmp/tmp9gam0jgy.cpp:54:1: error:\
    \ expected '}' at end of input\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(level);\n            level++;\n        }\n  \
    \  }\n    paren_levels.push_back(level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ljad_by.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp8ljad_by.cpp:13:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp8ljad_by.cpp:23:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(level);\n     ^\n/tmp/tmp8ljad_by.cpp:23:33:\
    \ error: could not convert 'paren_levels.std::vector<_Tp, _Alloc>::push_back<long\
    \ int, std::allocator<long int> >((*(const value_type*)(& level)))' from 'void'\
    \ to 'bool'\n     paren_levels.push_back(level);\n                           \
    \      ^\n/tmp/tmp8ljad_by.cpp:24:5: error: expected primary-expression before\
    \ 'return'\n     return paren_levels;\n     ^\n/tmp/tmp8ljad_by.cpp:24:5: error:\
    \ expected ')' before 'return'\n/tmp/tmp8ljad_by.cpp: In function 'int main()':\n\
    /tmp/tmp8ljad_by.cpp:27:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = parse_nested_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8ljad_by.cpp:2:\n/tmp/tmp8ljad_by.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp8ljad_by.cpp:28:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp8ljad_by.cpp:28:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpftksdc6c.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpftksdc6c.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpftksdc6c.cpp:20:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpftksdc6c.cpp: In function 'int main()':\n/tmp/tmpftksdc6c.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftksdc6c.cpp:2:\n/tmp/tmpftksdc6c.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpftksdc6c.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpftksdc6c.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpftksdc6c.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpftksdc6c.cpp:24:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_levels.push_back(level);\n            level++;\n\
    \        } else if (c == ')') {\n            is_closed = true;\n            level--;\n\
    \        } else if (c == ' ') {\n            if (is_open && !is_closed) {\n  \
    \              level++;\n            } else if (is_closed && !is_open) {\n   \
    \             level--;\n            }\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5wry2p_q.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp5wry2p_q.cpp:14:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmp5wry2p_q.cpp:30:5: error: expected\
    \ ';' before 'paren_levels'\n     paren_levels.push_back(level);\n     ^\n/tmp/tmp5wry2p_q.cpp:30:33:\
    \ error: could not convert 'paren_levels.std::vector<_Tp, _Alloc>::push_back<long\
    \ int, std::allocator<long int> >((*(const value_type*)(& level)))' from 'void'\
    \ to 'bool'\n     paren_levels.push_back(level);\n                           \
    \      ^\n/tmp/tmp5wry2p_q.cpp:31:5: error: expected primary-expression before\
    \ 'return'\n     return paren_levels;\n     ^\n/tmp/tmp5wry2p_q.cpp:31:5: error:\
    \ expected ')' before 'return'\n/tmp/tmp5wry2p_q.cpp: In function 'int main()':\n\
    /tmp/tmp5wry2p_q.cpp:34:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = parse_nested_parens;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5wry2p_q.cpp:2:\n/tmp/tmp5wry2p_q.cpp:35:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp5wry2p_q.cpp:35:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp5wry2p_q.cpp:35:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long level = 0;\n    std::string\
    \ current_paren_string = paren_string;\n    std::string current_paren_level =\
    \ \"\";\n    for (size_t i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i]\
    \ == '(') {\n            current_paren_level += paren_string[i];\n        } else\
    \ if (paren_string[i] == ')') {\n            current_paren_level += paren_string[i];\n\
    \            if (current_paren_level == current_paren_string) {\n            \
    \    result.push_back(level);\n                level = 0;\n                current_paren_string\
    \ = \"\";\n            } else {\n                level += 1;\n            }\n\
    \        } else {\n            current_paren_string += paren_string[i];\n    \
    \    }\n    }\n    if (current_paren_level != current_paren_string) {\n      \
    \  result.push_back(level);\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpip6phl5g.cpp: In function 'int main()':\n/tmp/tmpip6phl5g.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpip6phl5g.cpp:2:\n/tmp/tmpip6phl5g.cpp:36:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpip6phl5g.cpp:36:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpip6phl5g.cpp:36:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpip6phl5g.cpp:36:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpip6phl5g.cpp:36:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpip6phl5g.cpp:36:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpip6phl5g.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find(' ')).split(' ');\n    long max_level = 0;\n    for (auto\
    \ level : paren_levels) {\n        if (level > max_level) {\n            max_level\
    \ = level;\n        }\n    }\n    std::vector<long> paren_levels_out;\n    paren_levels_out.reserve(max_level\
    \ + 1);\n    for (auto level : paren_levels) {\n        paren_levels_out.push_back(level);\n\
    \    }\n    paren_levels_out.push_back(max_level);\n    return paren_levels_out;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnkrtvohq.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpnkrtvohq.cpp:10:67: error: 'class std::basic_string<char>' has no member\
    \ named 'split'\n     paren_levels = paren_string.substr(0, paren_string.find('\
    \ ')).split(' ');\n                                                          \
    \         ^\n/tmp/tmpnkrtvohq.cpp:12:15: error: 'level' does not name a type\n\
    \     for (auto level : paren_levels) {\n               ^\n/tmp/tmpnkrtvohq.cpp:17:5:\
    \ error: expected ';' before 'std'\n     std::vector<long> paren_levels_out;\n\
    \     ^\n/tmp/tmpnkrtvohq.cpp:17:23: error: expected primary-expression before\
    \ 'paren_levels_out'\n     std::vector<long> paren_levels_out;\n             \
    \          ^\n/tmp/tmpnkrtvohq.cpp:17:23: error: expected ';' before 'paren_levels_out'\n\
    /tmp/tmpnkrtvohq.cpp:17:23: error: 'paren_levels_out' was not declared in this\
    \ scope\n/tmp/tmpnkrtvohq.cpp:17:39: error: expected ')' before ';' token\n  \
    \   std::vector<long> paren_levels_out;\n                                    \
    \   ^\n/tmp/tmpnkrtvohq.cpp:18:5: error: 'paren_levels_out' was not declared in\
    \ this scope\n     paren_levels_out.reserve(max_level + 1);\n     ^\n/tmp/tmpnkrtvohq.cpp:19:15:\
    \ error: 'level' does not name a type\n     for (auto level : paren_levels) {\n\
    \               ^\n/tmp/tmpnkrtvohq.cpp:22:5: error: expected ';' before 'paren_levels_out'\n\
    \     paren_levels_out.push_back(max_level);\n     ^\n/tmp/tmpnkrtvohq.cpp:23:5:\
    \ error: expected primary-expression before 'return'\n     return paren_levels_out;\n\
    \     ^\n/tmp/tmpnkrtvohq.cpp:23:5: error: expected ')' before 'return'\n/tmp/tmpnkrtvohq.cpp:\
    \ In function 'int main()':\n/tmp/tmpnkrtvohq.cpp:26:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpnkrtvohq.cpp:2:\n/tmp/tmpnkrtvohq.cpp:27:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()("
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_copy;\n    paren_levels_copy = paren_levels.begin();\n\
    \    long paren_level = 0;\n    long paren_levels_copy_index = 0;\n    long paren_levels_copy_size\
    \ = 0;\n    long paren_levels_copy_size2 = 0;\n    long paren_levels_copy_size3\
    \ = 0;\n    long paren_levels_copy_size4 = 0;\n    long paren_levels_copy_size5\
    \ = 0;\n    long paren_levels_copy_size6 = 0;\n    long paren_levels_copy_size7\
    \ = 0;\n    long paren_levels_copy_size8 = 0;\n    long paren_levels_copy_size9\
    \ = 0;\n    long paren_levels_copy_size10 = 0;\n    long paren_levels_copy_size11\
    \ = 0;\n    long paren_levels_copy_size12 = 0;\n    long paren_levels_copy_size13\
    \ = 0;\n    long paren_levels_copy_size14 = 0;\n    long paren_levels_copy_size15\
    \ = 0;\n    long paren_levels_copy_size16 = 0;\n    long paren_levels_copy_size17\
    \ = 0;\n    long paren_levels_copy_size18 = 0;\n    long paren_levels_copy_size19\
    \ = 0;\n    long paren_levels_copy_size20 = 0;\n    long paren_levels_copy_size21\
    \ = 0;\n    long paren_levels_copy_size22 = 0;\n    long paren_levels_copy_size23\
    \ = 0;\n    long paren_levels_copy_size24 = 0;\n    long paren_levels_copy_size25\
    \ = 0;\n    long paren_levels_copy_size26 = 0;\n    long paren_levels_copy_size27\
    \ = 0;\n    long paren_levels_copy_size28 = 0;\n    long paren_levels_copy_size29\
    \ = 0;\n    long paren_levels_copy_size30 = 0;\n    long paren_levels_copy_size31\
    \ = 0;\n    long paren_levels_copy_size32 = 0;\n    long paren_levels_copy_size33\
    \ = 0;\n    long paren_levels_copy_size34 = 0;\n    long paren_levels_copy_size35\
    \ = 0;\n    long paren_levels_copy_size36 = 0;\n    long paren_levels_copy_size37\
    \ = 0;\n    long paren_levels_copy_size38 = 0;\n    long paren_levels_copy_size39\
    \ = 0;\n    long paren_levels_copy_size40 = 0;\n    long paren_levels_copy_size41\
    \ = 0;\n    long paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpht5p1tfu.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpht5p1tfu.cpp:10:33: error: 'std::string' has no member named 'split'\n\
    \     paren_levels = paren_string.split(\" \");\n                            \
    \     ^\n/tmp/tmpht5p1tfu.cpp:12:23: error: no match for 'operator=' (operand\
    \ types are 'std::vector<long int>' and 'std::vector<long int>::iterator {aka\
    \ __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >}')\n     paren_levels_copy\
    \ = paren_levels.begin();\n                       ^\n/tmp/tmpht5p1tfu.cpp:12:23:\
    \ note: candidate is:\nIn file included from /usr/include/c++/4.8.2/vector:69:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpht5p1tfu.cpp:2:\n/usr/include/c++/4.8.2/bits/vector.tcc:160:5:\
    \ note: std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const std::vector<_Tp,\
    \ _Alloc>&) [with _Tp = long int; _Alloc = std::allocator<long int>]\n     vector<_Tp,\
    \ _Alloc>::\n     ^\n/usr/include/c++/4.8.2/bits/vector.tcc:160:5: note:   no\
    \ known conversion for argument 1 from 'std::vector<long int>::iterator {aka __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >}' to 'const std::vector<long int>&'\n/tmp/tmpht5p1tfu.cpp:57:1:\
    \ error: expected initializer before '}' token\n }\n ^\n/tmp/tmpht5p1tfu.cpp:\
    \ In function 'int main()':\n/tmp/tmpht5p1tfu.cpp:59:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpht5p1tfu.cpp:2:\n/tmp/tmpht5p1tfu.cpp:60:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpht5p1tfu.cpp:60:76: warning:\
    \ extended initializer lists onl"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        long paren_level = 0;\n     \
    \   bool is_open = false;\n        for (auto &char : level) {\n            if\
    \ (char == '(') {\n                is_open = true;\n                paren_level++;\n\
    \            } else if (char == ')') {\n                is_open = false;\n   \
    \             paren_level--;\n            }\n            if (is_open) {\n    \
    \            paren_levels_temp.push_back(paren_level);\n            }\n      \
    \  }\n    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.reserve(paren_levels_temp.size());\n\
    \    for (auto &level : paren_levels_temp) {\n        if (level > 0) {\n     \
    \       paren_levels_temp2.push_back(level);\n        }\n    }\n    return paren_levels_temp2;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0m0e1_ua.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp0m0e1_ua.cpp:10:33: error: 'std::string' has no member named 'split'\n\
    \     paren_levels = paren_string.split(\" \");\n                            \
    \     ^\n/tmp/tmp0m0e1_ua.cpp:13:16: error: ISO C++ forbids declaration of 'level'\
    \ with no type [-fpermissive]\n     for (auto &level : paren_levels) {\n     \
    \           ^\n/tmp/tmp0m0e1_ua.cpp:13:24: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (auto &level : paren_levels) {\n       \
    \                 ^\n/tmp/tmp0m0e1_ua.cpp:16:20: error: expected unqualified-id\
    \ before 'char'\n         for (auto &char : level) {\n                    ^\n\
    /tmp/tmp0m0e1_ua.cpp:16:20: error: expected ';' before 'char'\n/tmp/tmp0m0e1_ua.cpp:16:20:\
    \ error: expected primary-expression before 'char'\n/tmp/tmp0m0e1_ua.cpp:16:20:\
    \ error: expected ';' before 'char'\n/tmp/tmp0m0e1_ua.cpp:16:20: error: expected\
    \ primary-expression before 'char'\n/tmp/tmp0m0e1_ua.cpp:16:20: error: expected\
    \ ')' before 'char'\n/tmp/tmp0m0e1_ua.cpp:16:25: error: expected unqualified-id\
    \ before ':' token\n         for (auto &char : level) {\n                    \
    \     ^\n/tmp/tmp0m0e1_ua.cpp:43:1: error: expected '}' at end of input\n }\n\
    \ ^\n/tmp/tmp0m0e1_ua.cpp:43:1: error: expected '}' at end of input\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ != '(' && c != ')') {\n            paren_levels.push_back(current_level);\n\
    \        }\n        if (c == '(') {\n            current_level++;\n        }\n\
    \        if (c == ')') {\n            current_level--;\n        }\n    }\n   \
    \ paren_levels.push_back(current_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2jt0flhd.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp2jt0flhd.cpp:12:16: error: ISO C++ forbids declaration of 'c' with no\
    \ type [-fpermissive]\n     for (auto &c : paren_string) {\n                ^\n\
    /tmp/tmp2jt0flhd.cpp:12:20: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &c : paren_string) {\n                    ^\n/tmp/tmp2jt0flhd.cpp:\
    \ In function 'int main()':\n/tmp/tmp2jt0flhd.cpp:27:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp2jt0flhd.cpp:2:\n/tmp/tmp2jt0flhd.cpp:28:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp2jt0flhd.cpp:28:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp2jt0flhd.cpp:28:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp2jt0flhd.cpp:28:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp2jt0flhd.cpp:28:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp2jt0flhd.cpp:28:113: note: candidates are:\nIn file included from /usr/includ"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren_or_space = false;\n    bool is_closing_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfomcu9sz.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpfomcu9sz.cpp:26:10: error: redeclaration of 'bool is_opening_curly_bracket_or_paren_or_space'\n\
    \     bool is_opening_curly_bracket_or_paren_or_space = false;\n          ^\n\
    /tmp/tmpfomcu9sz.cpp:20:10: error: 'bool is_opening_curly_bracket_or_paren_or_space'\
    \ previously declared here\n     bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:27:10: error: redeclaration of 'bool\
    \ is_closing_curly_bracket_or_paren_or_space'\n     bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:21:10: error: 'bool is_closing_curly_bracket_or_paren_or_space'\
    \ previously declared here\n     bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:28:10: error: redeclaration of 'bool\
    \ is_opening_square_bracket_or_paren_or_space'\n     bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:22:10: error: 'bool is_opening_square_bracket_or_paren_or_space'\
    \ previously declared here\n     bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:29:10: error: redeclaration of 'bool\
    \ is_closing_square_bracket_or_paren_or_space'\n     bool is_closing_square_bracket_or_paren_or_space\
    \ = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:23:10: error: 'bool is_closing_square_bracket_or_paren_or_space'\
    \ previously declared here\n     bool is_closing_square_bracket_or_paren_or_space\
    \ = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:30:10: error: redeclaration of 'bool\
    \ is_opening_paren'\n     bool is_opening_paren = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:14:10:\
    \ error: 'bool is_opening_paren' previously declared here\n     bool is_opening_paren\
    \ = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:31:10: error: redeclaration of 'bool\
    \ is_closing_paren'\n     bool is_closing_paren = false;\n          ^\n/tmp/tmpfomcu9sz.cpp:15:10:\
    \ error: 'bool is_closing_paren' previously declared here\n     bool is_closing_paren\
    \ = false;\n        "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n    }\n  }\n  assert(paren_levels.size() == paren_string.size());\n\
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmyn62hfn.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmyn62hfn.cpp:12:13: error: 'c' does not name a type\n   for (auto c :\
    \ paren_string) {\n             ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmyn62hfn.cpp:2:\n/tmp/tmpmyn62hfn.cpp:20:3: error:\
    \ expected ';' before '(' token\n   assert(paren_levels.size() == paren_string.size());\n\
    \   ^\n/tmp/tmpmyn62hfn.cpp:20:3: error: could not convert '((paren_levels.std::vector<_Tp,\
    \ _Alloc>::size<long int, std::allocator<long int> >() != paren_string.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::size<char, std::char_traits<char>, std::allocator<char> >())\
    \ ? __assert_fail(((const char*)\"paren_levels.size() == paren_string.size()\"\
    ), ((const char*)\"/tmp/tmpmyn62hfn.cpp\"), 20u, ((const char*)(& __PRETTY_FUNCTION__)))\
    \ : 0)' from 'void' to 'bool'\n   assert(paren_levels.size() == paren_string.size());\n\
    \   ^\n/tmp/tmpmyn62hfn.cpp:21:3: error: expected primary-expression before 'return'\n\
    \   return paren_levels;\n   ^\n/tmp/tmpmyn62hfn.cpp:21:3: error: expected ')'\
    \ before 'return'\n/tmp/tmpmyn62hfn.cpp: In function 'int main()':\n/tmp/tmpmyn62hfn.cpp:24:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmyn62hfn.cpp:2:\n/tmp/tmpmyn62hfn.cpp:25:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpmyn62hfn.cpp:25:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})))"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level_count++;\n            paren_level = paren_level_count;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  paren_level = paren_level_count;\n        } else {\n            paren_level_count\
    \ = 0;\n        }\n        paren_levels.push_back(paren_level);\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplkgprje8.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmplkgprje8.cpp:12:15: error: 'c' does not name a type\n     for (auto c\
    \ : paren_string) {\n               ^\n/tmp/tmplkgprje8.cpp:24:5: error: expected\
    \ ';' before 'return'\n     return paren_levels;\n     ^\n/tmp/tmplkgprje8.cpp:24:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmplkgprje8.cpp:24:5:\
    \ error: expected ';' before 'return'\n/tmp/tmplkgprje8.cpp:24:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmplkgprje8.cpp:24:5: error: expected\
    \ ')' before 'return'\n/tmp/tmplkgprje8.cpp: In function 'int main()':\n/tmp/tmplkgprje8.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplkgprje8.cpp:2:\n/tmp/tmplkgprje8.cpp:28:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmplkgprje8.cpp:28:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmplkgprje8.cpp:28:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmplkgprje8.cpp:28:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmplkgprje8.cpp:28:113: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxd81ppy2.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpxd81ppy2.cpp:12:13: error: 'c' does not name a type\n   for (auto c :\
    \ paren_string) {\n             ^\n/tmp/tmpxd81ppy2.cpp:20:3: error: expected\
    \ ';' before 'return'\n   return paren_levels;\n   ^\n/tmp/tmpxd81ppy2.cpp:20:3:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpxd81ppy2.cpp:20:3:\
    \ error: expected ';' before 'return'\n/tmp/tmpxd81ppy2.cpp:20:3: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpxd81ppy2.cpp:20:3: error: expected\
    \ ')' before 'return'\n/tmp/tmpxd81ppy2.cpp: In function 'int main()':\n/tmp/tmpxd81ppy2.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxd81ppy2.cpp:2:\n/tmp/tmpxd81ppy2.cpp:24:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpxd81ppy2.cpp:24:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpxd81ppy2.cpp:24:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpxd81ppy2.cpp:24:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpxd81ppy2.cpp:24:113: error: n"
  stdout: ''
