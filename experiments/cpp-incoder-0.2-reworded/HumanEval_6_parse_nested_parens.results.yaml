language: cpp
name: HumanEval_6_parse_nested_parens
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            is_open = true;\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            is_closed = true;\n            paren_level_count--;\n\
    \        } else if (is_open && is_closed) {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level = 0;\n            is_open = false;\n            is_closed\
    \ = false;\n        } else if (is_open) {\n            paren_level++;\n      \
    \  } else if (is_closed) {\n            paren_level--;\n        }\n    }\n   \
    \ paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp1z5r_63j: /tmp/tmp1z5r_63j.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long paren_level_count = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     is_open = true;\n            paren_level_count++;\n        } else if (c\
    \ == ')') {\n            is_closed = true;\n            paren_level_count--;\n\
    \        } else if (c == ' ') {\n            if (is_open && is_closed) {\n   \
    \             paren_levels.push_back(paren_level);\n                paren_level\
    \ = 0;\n                is_open = false;\n                is_closed = false;\n\
    \            }\n        } else {\n            is_open = false;\n            is_closed\
    \ = false;\n        }\n        paren_level++;\n    }\n    if (is_open && is_closed)\
    \ {\n        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmphpc8n7p4: /tmp/tmphpc8n7p4.cpp:43: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqieyfa2t.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpqieyfa2t.cpp:66:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   66 | }\n      | ^\n/tmp/tmpqieyfa2t.cpp:66:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpnkhwnfhm: /tmp/tmpnkhwnfhm.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_string = paren_string;\n    long curr_level = 0;\n\
    \    while (curr_paren_string.size() > 0) {\n        auto next_paren_string =\
    \ curr_paren_string.substr(0, curr_paren_string.size() - 1);\n        auto next_level\
    \ = curr_level + 1;\n        auto next_paren_level = paren_levels.size();\n  \
    \      paren_levels.emplace_back(next_paren_level);\n        curr_paren_string\
    \ = next_paren_string;\n        curr_level = next_level;\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpltl48isc: /tmp/tmpltl48isc.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    long paren_level_max_count = 0;\n    for\
    \ (auto &c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level = std::to_string(paren_level_count);\n            paren_level_count\
    \ = 0;\n        } else if (c == ')') {\n            paren_level_count--;\n   \
    \         paren_level = std::to_string(paren_level_count);\n            paren_level_count\
    \ = 0;\n            if (paren_level_count == 0) {\n                paren_level_count\
    \ = paren_level_max_count;\n                paren_level_max_count = 0;\n     \
    \       }\n            paren_level_count++;\n        }\n        paren_level +=\
    \ c;\n    }\n    paren_level_count = paren_level_max_count;\n    paren_level_max_count\
    \ = 0;\n    for (auto &c : paren_level) {\n        if (c == '(') {\n         \
    \   paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n        } else if (c == ')') {\n        \
    \    paren_level_count--;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n            if (paren_level_count == 0) {\n\
    \                paren_level_count = paren_level_max_count;\n                paren_level_max_count\
    \ = 0;\n            }\n            paren_level_count++;\n        }\n        paren_level\
    \ += c;\n    }\n    paren_level_count = paren_level_max_count;\n    paren_level_max_count\
    \ = 0;\n    for (auto &c : paren_level) {\n        if (c == '(') {\n         \
    \   paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n        } else if (c == ')') {\n        \
    \    paren_level_count--;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n            if (paren_level_count == 0) {\n\
    \                paren_level_count = paren_level_max_count;\n                paren_level_max_count\
    \ = 0;\n            }\n            paren_level_count++;\n        }\n        paren_level\
    \ += c;\n    }\n    paren_level_count = paren_level_max_count;\n    paren_level_max_count\
    \ = 0;\n    for (auto &c : paren_level) {\n        if (c == '(') {\n         \
    \   paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \            paren_level_count = 0;\n        } else if (c == ')') {\n        \
    \    paren_level_count--;\n            paren_level = std::to_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeubxed24.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpeubxed24.cpp:77:32: error: \u2018to_\u2019 is not a member of \u2018\
    std\u2019\n   77 |             paren_level = std::to_\n      |               \
    \                 ^~~\n/tmp/tmpeubxed24.cpp:79:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   79 | int main() {\n     \
    \ |            ^\n/tmp/tmpeubxed24.cpp:84:1: error: expected \u2018}\u2019 at\
    \ end of input\n   84 | }\n      | ^\n/tmp/tmpeubxed24.cpp:70:33: note: to match\
    \ this \u2018{\u2019\n   70 |     for (auto &c : paren_level) {\n      |     \
    \                            ^\n/tmp/tmpeubxed24.cpp:84:1: error: expected \u2018\
    }\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmpeubxed24.cpp:8:65: note:\
    \ to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpeubxed24.cpp:84:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   84 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    size_t paren_level_count = 0;\n    size_t paren_level_start\
    \ = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            paren_level_count++;\n            paren_levels[paren_level]\
    \ = paren_level_count;\n            paren_level_start = i;\n        } else if\
    \ (paren_string[i] == ')') {\n            paren_level_count--;\n            paren_levels[paren_level]\
    \ = paren_level_count;\n            paren_level = paren_level_start;\n       \
    \ }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp8eecmsly: /tmp/tmp8eecmsly.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level_string = paren_level_string.empty() ? \"\"\
    \ : paren_level_string;\n            paren_level_string = paren_level_string +\
    \ c;\n        } else if (c == ')') {\n            is_closed = true;\n        \
    \    paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string;\n            paren_level_string = paren_level_string +\
    \ \")\";\n            paren_level_string = paren_level_string + paren_level_string;\n\
    \            paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + paren_level_string;\n            paren_level_string =\
    \ paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + paren_level_string\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzh7ywluv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpzh7ywluv.cpp:47:73: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   47 |             paren_level_string = paren_level_string + paren_level_string\n\
    \      |                                                                     \
    \    ^\n      |                                                              \
    \           ;\n   48 | }\n      | ~                                          \
    \                              \n/tmp/tmpzh7ywluv.cpp:49:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   49 | int main() {\n     \
    \ |            ^\n/tmp/tmpzh7ywluv.cpp:54:1: error: expected \u2018}\u2019 at\
    \ end of input\n   54 | }\n      | ^\n/tmp/tmpzh7ywluv.cpp:14:33: note: to match\
    \ this \u2018{\u2019\n   14 |     for (auto c : paren_string) {\n      |     \
    \                            ^\n/tmp/tmpzh7ywluv.cpp:54:1: error: expected \u2018\
    }\u2019 at end of input\n   54 | }\n      | ^\n/tmp/tmpzh7ywluv.cpp:8:65: note:\
    \ to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpzh7ywluv.cpp:54:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   54 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(level);\n            level++;\n        }\n  \
    \  }\n    paren_levels.push_back(level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpzpwzc7qx: /tmp/tmpzpwzc7qx.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvzctdgob: /tmp/tmpvzctdgob.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_levels.push_back(level);\n            level++;\n\
    \        } else if (c == ')') {\n            is_closed = true;\n            level--;\n\
    \        } else if (c == ' ') {\n            if (is_open && !is_closed) {\n  \
    \              level++;\n            } else if (is_closed && !is_open) {\n   \
    \             level--;\n            }\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpx6mbf5sh: /tmp/tmpx6mbf5sh.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long level = 0;\n    std::string\
    \ current_paren_string = paren_string;\n    std::string current_paren_level =\
    \ \"\";\n    for (size_t i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i]\
    \ == '(') {\n            current_paren_level += paren_string[i];\n        } else\
    \ if (paren_string[i] == ')') {\n            current_paren_level += paren_string[i];\n\
    \            if (current_paren_level == current_paren_string) {\n            \
    \    result.push_back(level);\n                level = 0;\n                current_paren_string\
    \ = \"\";\n            } else {\n                level += 1;\n            }\n\
    \        } else {\n            current_paren_string += paren_string[i];\n    \
    \    }\n    }\n    if (current_paren_level != current_paren_string) {\n      \
    \  result.push_back(level);\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp1qmsnr1d: /tmp/tmp1qmsnr1d.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find(' ')).split(' ');\n    long max_level = 0;\n    for (auto\
    \ level : paren_levels) {\n        if (level > max_level) {\n            max_level\
    \ = level;\n        }\n    }\n    std::vector<long> paren_levels_out;\n    paren_levels_out.reserve(max_level\
    \ + 1);\n    for (auto level : paren_levels) {\n        paren_levels_out.push_back(level);\n\
    \    }\n    paren_levels_out.push_back(max_level);\n    return paren_levels_out;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp722z0rye.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp722z0rye.cpp:10:67: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find(' ')).split(' ');\n      |                               \
    \                                    ^~~~~\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_copy;\n    paren_levels_copy = paren_levels.begin();\n\
    \    long paren_level = 0;\n    long paren_levels_copy_index = 0;\n    long paren_levels_copy_size\
    \ = 0;\n    long paren_levels_copy_size2 = 0;\n    long paren_levels_copy_size3\
    \ = 0;\n    long paren_levels_copy_size4 = 0;\n    long paren_levels_copy_size5\
    \ = 0;\n    long paren_levels_copy_size6 = 0;\n    long paren_levels_copy_size7\
    \ = 0;\n    long paren_levels_copy_size8 = 0;\n    long paren_levels_copy_size9\
    \ = 0;\n    long paren_levels_copy_size10 = 0;\n    long paren_levels_copy_size11\
    \ = 0;\n    long paren_levels_copy_size12 = 0;\n    long paren_levels_copy_size13\
    \ = 0;\n    long paren_levels_copy_size14 = 0;\n    long paren_levels_copy_size15\
    \ = 0;\n    long paren_levels_copy_size16 = 0;\n    long paren_levels_copy_size17\
    \ = 0;\n    long paren_levels_copy_size18 = 0;\n    long paren_levels_copy_size19\
    \ = 0;\n    long paren_levels_copy_size20 = 0;\n    long paren_levels_copy_size21\
    \ = 0;\n    long paren_levels_copy_size22 = 0;\n    long paren_levels_copy_size23\
    \ = 0;\n    long paren_levels_copy_size24 = 0;\n    long paren_levels_copy_size25\
    \ = 0;\n    long paren_levels_copy_size26 = 0;\n    long paren_levels_copy_size27\
    \ = 0;\n    long paren_levels_copy_size28 = 0;\n    long paren_levels_copy_size29\
    \ = 0;\n    long paren_levels_copy_size30 = 0;\n    long paren_levels_copy_size31\
    \ = 0;\n    long paren_levels_copy_size32 = 0;\n    long paren_levels_copy_size33\
    \ = 0;\n    long paren_levels_copy_size34 = 0;\n    long paren_levels_copy_size35\
    \ = 0;\n    long paren_levels_copy_size36 = 0;\n    long paren_levels_copy_size37\
    \ = 0;\n    long paren_levels_copy_size38 = 0;\n    long paren_levels_copy_size39\
    \ = 0;\n    long paren_levels_copy_size40 = 0;\n    long paren_levels_copy_size41\
    \ = 0;\n    long paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprco097tn.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmprco097tn.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmprco097tn.cpp:12:44: error: no match for \u2018\
    operator=\u2019 (operand types are \u2018std::vector<long int>\u2019 and \u2018\
    std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019})\n   12 |     paren_levels_copy = paren_levels.begin();\n\
    \      |                                            ^\nIn file included from /usr/include/c++/9/vector:72,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprco097tn.cpp:2:\n/usr/include/c++/9/bits/vector.tcc:198:5:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const\
    \ std::vector<_Tp, _Alloc>&) [with _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n  198 |     vector<_Tp, _Alloc>::\n      |     ^~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/vector.tcc:199:42: note:   no known conversion for argument\
    \ 1 from \u2018std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019} to \u2018const std::vector<long int>&\u2019\
    \n  199 |     operator=(const vector<_Tp, _Alloc>& __x)\n      |             \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprco097tn.cpp:2:\n/usr/include/c++/9/bits/stl_vector"
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        long paren_level = 0;\n     \
    \   bool is_open = false;\n        for (auto &char : level) {\n            if\
    \ (char == '(') {\n                is_open = true;\n                paren_level++;\n\
    \            } else if (char == ')') {\n                is_open = false;\n   \
    \             paren_level--;\n            }\n            if (is_open) {\n    \
    \            paren_levels_temp.push_back(paren_level);\n            }\n      \
    \  }\n    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.reserve(paren_levels_temp.size());\n\
    \    for (auto &level : paren_levels_temp) {\n        if (level > 0) {\n     \
    \       paren_levels_temp2.push_back(level);\n        }\n    }\n    return paren_levels_temp2;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpob969jo5.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpob969jo5.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpob969jo5.cpp:16:20: error: expected unqualified-id\
    \ before \u2018char\u2019\n   16 |         for (auto &char : level) {\n      |\
    \                    ^~~~\n/tmp/tmpob969jo5.cpp:16:20: error: expected \u2018\
    ;\u2019 before \u2018char\u2019\n   16 |         for (auto &char : level) {\n\
    \      |                    ^~~~\n      |                    ;\n/tmp/tmpob969jo5.cpp:16:25:\
    \ error: expected unqualified-id before \u2018:\u2019 token\n   16 |         for\
    \ (auto &char : level) {\n      |                         ^\n/tmp/tmpob969jo5.cpp:16:32:\
    \ error: expected \u2018;\u2019 before \u2018)\u2019 token\n   16 |         for\
    \ (auto &char : level) {\n      |                                ^\n      |  \
    \                              ;\n/tmp/tmpob969jo5.cpp:17:22: error: expected\
    \ unqualified-id before \u2018==\u2019 token\n   17 |             if (char ==\
    \ '(') {\n      |                      ^~\n/tmp/tmpob969jo5.cpp:20:29: error:\
    \ expected unqualified-id before \u2018==\u2019 token\n   20 |             } else\
    \ if (char == ')') {\n      |                             ^~\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ != '(' && c != ')') {\n            paren_levels.push_back(current_level);\n\
    \        }\n        if (c == '(') {\n            current_level++;\n        }\n\
    \        if (c == ')') {\n            current_level--;\n        }\n    }\n   \
    \ paren_levels.push_back(current_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmppjp7tghj: /tmp/tmppjp7tghj.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren_or_space = false;\n    bool is_closing_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8gzgucbl.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp8gzgucbl.cpp:26:10: error: redeclaration of \u2018bool is_opening_curly_bracket_or_paren_or_space\u2019\
    \n   26 |     bool is_opening_curly_bracket_or_paren_or_space = false;\n     \
    \ |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8gzgucbl.cpp:20:10:\
    \ note: \u2018bool is_opening_curly_bracket_or_paren_or_space\u2019 previously\
    \ declared here\n   20 |     bool is_opening_curly_bracket_or_paren_or_space =\
    \ false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8gzgucbl.cpp:27:10:\
    \ error: redeclaration of \u2018bool is_closing_curly_bracket_or_paren_or_space\u2019\
    \n   27 |     bool is_closing_curly_bracket_or_paren_or_space = false;\n     \
    \ |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8gzgucbl.cpp:21:10:\
    \ note: \u2018bool is_closing_curly_bracket_or_paren_or_space\u2019 previously\
    \ declared here\n   21 |     bool is_closing_curly_bracket_or_paren_or_space =\
    \ false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8gzgucbl.cpp:28:10:\
    \ error: redeclaration of \u2018bool is_opening_square_bracket_or_paren_or_space\u2019\
    \n   28 |     bool is_opening_square_bracket_or_paren_or_space = false;\n    \
    \  |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8gzgucbl.cpp:22:10:\
    \ note: \u2018bool is_opening_square_bracket_or_paren_or_space\u2019 previously\
    \ declared here\n   22 |     bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8gzgucbl.cpp:29:10:\
    \ error: redeclaration of \u2018bool is_closing_square_bracket_or_paren_or_space\u2019\
    \n   29 |     bool is_closing_square_bracket_or_paren_or_space = false;\n    \
    \  |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8gzgucbl.cpp:23:10:\
    \ note: \u2018bool is_closing_square_bracket_or_paren_or_space\u2019 previously\
    \ declared here\n   23 |     bool is_closing_square_bracket_or_paren_or_space\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8gzgucbl.cpp:30:10:\
    \ erro"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n    }\n  }\n  assert(paren_levels.size() == paren_string.size());\n\
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpn085h06e: /tmp/tmpn085h06e.cpp:20: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_levels.size() == paren_string.size()'' failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level_count++;\n            paren_level = paren_level_count;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  paren_level = paren_level_count;\n        } else {\n            paren_level_count\
    \ = 0;\n        }\n        paren_levels.push_back(paren_level);\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3vvb1hgu.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp3vvb1hgu.cpp:22:43: error: no matching function for call to \u2018\
    std::vector<long int>::push_back(std::string&)\u2019\n   22 |         paren_levels.push_back(paren_level);\n\
    \      |                                           ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3vvb1hgu.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const value_type&\u2019 {aka \u2018const long int&\u2019}\n 1184 |\
    \       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = long\
    \ int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1200 |       push_back(value_type&& __x)\n      |      \
    \ ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30: note:   no known conversion\
    \ for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018std::vector<long int>::value_type&&\u2019 {aka \u2018long int&&\u2019\
    }\n 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpz3qg5nq6: /tmp/tmpz3qg5nq6.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long level = 0;\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    long opening_paren_level\
    \ = 0;\n    long closing_paren_level = 0;\n    long paren_level = 0;\n    long\
    \ paren_level_count = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_index\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_index\
    \ = 0;\n    long paren_level_count_max_count = 0;\n    long paren_level_count_min_count\
    \ = 0;\n    long paren_level_count_max_count_index = 0;\n    long paren_level_count_min_count_index\
    \ = 0;\n    long paren_level_count_max_count_count = 0;\n    long paren_level_count_min_count_count\
    \ = 0;\n    long paren_level_count_max_count_index_count = 0;\n    long paren_level_count_min_count_index_count\
    \ = 0;\n    long paren_level_count_max_count_index_count_index = 0;\n    long\
    \ paren_level_count_min_count_index_count_index = 0;\n    long paren_level_count_max_count_index_count_count_index\
    \ = 0;\n    long paren_level_count_min_count_index_count_count_index = 0;\n  \
    \  long paren_level_count_max_count_index_count_count_index_count = 0;\n    long\
    \ paren_level_count_min_count_index_count_count_count_index = 0;\n    long paren_level_count_max_count_index_count_count_count_index_count\
    \ = 0;\n    long paren_level_count_min_count_index_count_count_count_index_count\
    \ = 0;\n    long paren_level_count_max_count_index_count_count_count_index_count_count\
    \ = 0;\n    long paren_level_count_min_count_index_count_count_count_count_index_count_count\
    \ = 0;\n    long paren_level_count_max_count_index_count_count_count_count_index_count_count_count\
    \ = 0;\n    long paren_level_count_min_count_index_count_count_count_count_count_index_count_count_count_count\
    \ = 0;\n    long paren_level_count_max_count_index_count_count_count_count_count_index_count_count_count_count_count\
    \ = 0;\n    long paren_level_count_min_count_index_count_count_count_count_count_count_index_count_count_count_count_count\
    \ = 0;\n    long paren_level_count_max_count_index_count_count_count_count_count_index_count_count_count_count_count_count\
    \ = 0;\n    long paren_level_count_min_count_index_count_count_count_count_count_count_index_count_count_count_count_count_count\
    \ = 0;\n    long paren_level_count_max_count_index_count_count_count_count_count_count_index_count_count_count_count_count_count_count\
    \ = 0;\n    long paren_level_count_min_count_index_count_count_count_count_count_count_count_index_count_count_count_count_count_count_count\
    \ = 0;\n    long paren_level_count_max_count_index_count_count_count_\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3ppxsr6z.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp3ppxsr6z.cpp:48:1: error: expected initializer before \u2018}\u2019\
    \ token\n   48 | }\n      | ^\n/tmp/tmp3ppxsr6z.cpp:48:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_string = paren_string;\n    long curr_paren_level\
    \ = 0;\n    bool is_open = false;\n    for (size_t i = 0; i < curr_paren_string.size();\
    \ i++) {\n        if (curr_paren_string[i] == '(') {\n            is_open = true;\n\
    \            curr_paren_level++;\n        } else if (curr_paren_string[i] == ')')\
    \ {\n            is_open = false;\n            curr_paren_level--;\n        }\
    \ else if (curr_paren_string[i] == ' ' && is_open) {\n            paren_levels.push_back(curr_paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpermouyr6: /tmp/tmpermouyr6.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    long current_level_size = 1;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            current_level.push_back('(');\n\
    \            current_level_size++;\n        } else if (paren_string[i] == ')')\
    \ {\n            current_level.push_back(')');\n            current_level_size--;\n\
    \        } else if (paren_string[i] == ' ') {\n            if (current_level_size\
    \ == 0) {\n                levels.push_back(current_level.size());\n         \
    \       current_level.clear();\n                current_level_size = 1;\n    \
    \        } else {\n                current_level.push_back(' ');\n           \
    \     current_level_size++;\n            }\n        } else {\n            current_level.push_back(paren_string[i]);\n\
    \            current_level_size++;\n        }\n    }\n    if (current_level_size)\
    \ {\n        levels.push_back(current_level.size());\n    }\n    return levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpy_g63acd: /tmp/tmpy_g63acd.cpp:40: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (char c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n        } else if (c == ')') {\n            is_closed = true;\n   \
    \     } else if (is_open && is_closed) {\n            paren_levels.push_back(level);\n\
    \            level = 0;\n            is_open = false;\n            is_closed =\
    \ false;\n        } else if (is_open) {\n            level++;\n        } else\
    \ if (is_closed) {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpti31_3ue: /tmp/tmpti31_3ue.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_level_string;\n    std::string paren_level_char;\n    long\
    \ paren_level = 0;\n    long paren_level_counter = 0;\n    for (size_t i = 0;\
    \ i < paren_string.size(); i++) {\n        paren_level_counter = 0;\n        paren_level_char\
    \ = \"\";\n        paren_level_string = \"\";\n        while (i < paren_string.size()\
    \ && paren_string[i] != ' ') {\n            paren_level_counter++;\n         \
    \   paren_level_char += paren_string[i];\n            i++;\n        }\n      \
    \  paren_level_string = paren_level_char;\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_counter);\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.size() - 1);\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_first_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\"(\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\"(\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\")\"));\n        paren_level_string = paren_level_string.substr(0,\
    \ paren_level_string.find_last_of(\"\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn0y6fknr.cpp:40:91: warning: missing terminating \" character\n\
    \   40 |         paren_level_string = paren_level_string.substr(0, paren_level_string.find_last_of(\"\
    \n      |                                                                    \
    \                       ^\n/tmp/tmpn0y6fknr.cpp:40:91: error: missing terminating\
    \ \" character\n/tmp/tmpn0y6fknr.cpp: In function \u2018std::vector<long int>\
    \ parse_nested_parens(std::string)\u2019:\n/tmp/tmpn0y6fknr.cpp:41:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   41 | }\n      | ^\n/tmp/tmpn0y6fknr.cpp:42:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   42 | int main() {\n      |            ^\n/tmp/tmpn0y6fknr.cpp:47:1: error:\
    \ expected \u2018}\u2019 at end of input\n   47 | }\n      | ^\n/tmp/tmpn0y6fknr.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpn0y6fknr.cpp:47:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   47 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(paren_level);\n            paren_level++;\n \
    \       }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmps3z4ixya: /tmp/tmps3z4ixya.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (size_t i = 0;\
    \ i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n   \
    \         is_open = true;\n        } else if (paren_string[i] == ')') {\n    \
    \        is_open = false;\n        } else if (is_open) {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        }\n    }\n    return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmph_erg8dm: /tmp/tmph_erg8dm.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpnkhwnfhm: /tmp/tmpnkhwnfhm.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::string curr_paren_string\
    \ = paren_string;\n    long curr_depth = 0;\n    long max_depth = 0;\n    while\
    \ (curr_paren_string.size() > 0) {\n        long curr_depth_temp = curr_depth;\n\
    \        std::string curr_paren_string_temp;\n        for (size_t i = 0; i < curr_paren_string.size();\
    \ i++) {\n            if (curr_paren_string[i] == '(') {\n                curr_paren_string_temp\
    \ += curr_paren_string[i];\n                curr_depth_temp++;\n            }\
    \ else if (curr_paren_string[i] == ')') {\n                curr_paren_string_temp\
    \ += curr_paren_string[i];\n                curr_depth_temp--;\n            }\
    \ else {\n                curr_paren_string_temp += curr_paren_string[i];\n  \
    \          }\n        }\n        if (curr_depth_temp > max_depth) {\n        \
    \    max_depth = curr_depth_temp;\n        }\n        result.push_back(max_depth);\n\
    \        curr_paren_string = curr_paren_string_temp;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113003
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        if (paren_levels[i]\
    \ == \"(\") {\n            paren_levels_temp.push_back(paren_levels.size());\n\
    \        }\n        if (paren_levels[i] == \")\") {\n            paren_levels_temp.push_back(paren_levels_temp.back());\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp_reverse;\n    paren_levels_temp_reverse.reserve(paren_levels_temp.size());\n\
    \    for (long i = 0; i < paren_levels_temp.size(); i++) {\n        paren_levels_temp_reverse.push_back(paren_levels_temp.at(i));\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_temp;\n    paren_levels_temp_reverse_temp.reserve(paren_levels_temp_reverse.size());\n\
    \    for (long i = 0; i < paren_levels_temp_reverse.size(); i++) {\n        paren_levels_temp_reverse_temp.push_back(paren_levels_temp_reverse.at(i));\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_temp_reverse;\n    paren_levels_temp_reverse_temp_reverse.reserve(paren_levels_temp_reverse_temp.size());\n\
    \    for (long i = 0; i < paren_levels_temp_reverse_temp.size(); i++) {\n    \
    \    paren_levels_temp_reverse_temp_reverse.push_back(paren_levels_temp_reverse_temp.at(i));\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_temp_reverse_temp;\n \
    \   paren_levels_temp_reverse_temp_reverse_temp.reserve(paren_levels_temp_reverse_temp_reverse.size());\n\
    \    for (long i = 0; i < paren_levels_temp_reverse_temp_reverse.size(); i++)\
    \ {\n        paren_levels_temp_reverse_temp_reverse_temp.push_back(paren_levels_temp_reverse_temp_reverse.at(i));\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_temp_reverse_temp_reverse;\n\
    \    paren_levels_temp_reverse_temp_reverse_temp_reverse.reserve(paren_levels_temp_reverse_temp_reverse_temp.size());\n\
    \    for (long i = 0; i < paren_levels_temp_reverse_temp_reverse_temp.size();\
    \ i++) {\n        paren_levels_temp_reverse_temp_reverse_temp_reverse.push_back(paren_levels_temp_reverse_temp_re\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg75ebwyd.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpg75ebwyd.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpg75ebwyd.cpp:14:32: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   14 |         if (paren_levels[i]\
    \ == \"(\") {\n      |                                ^~~\n/tmp/tmpg75ebwyd.cpp:17:32:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   17 |         if (paren_levels[i] == \")\") {\n      |                    \
    \            ^~~\n/tmp/tmpg75ebwyd.cpp:44:71: error: \u2018paren_levels_temp_reverse_temp_re\u2019\
    \ was not declared in this scope; did you mean \u2018paren_levels_temp_reverse_temp\u2019\
    ?\n   44 |         paren_levels_temp_reverse_temp_reverse_temp_reverse.push_back(paren_levels_temp_reverse_temp_re\n\
    \      |                                                                     \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                \
    \                                       paren_levels_temp_reverse_temp\n/tmp/tmpg75ebwyd.cpp:46:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   46 | int main() {\n      |            ^\n/tmp/tmpg75ebwyd.cpp:51:1: error:\
    \ expected \u2018}\u2019 at end of input\n   51 | }\n      | ^\n/tmp/tmpg75ebwyd.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpg75ebwyd.cpp:51:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   51 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.push_back(0);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\
    \  paren_levels.push_back(1);\n  paren_levels.push_back(1);\n\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpg20f4377: /tmp/tmpg20f4377.cpp:86: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string curr_level;\n\
    \    for (auto &c : paren_string) {\n        if (c == '(') {\n            curr_level\
    \ = curr_level + \"(\";\n        } else if (c == ')') {\n            curr_level\
    \ = curr_level.substr(0, curr_level.size() - 1) + \")\";\n        } else if (c\
    \ == ' ') {\n            if (curr_level.empty()) {\n                levels.push_back(1);\n\
    \            } else {\n                levels.push_back(std::stoi(curr_level));\n\
    \            }\n            curr_level.clear();\n        } else {\n          \
    \  curr_level = curr_level + c;\n        }\n    }\n    if (curr_level.empty())\
    \ {\n        levels.push_back(1);\n    } else {\n        levels.push_back(std::stoi(curr_level));\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto it = paren_string.begin(); it != paren_string.end();\
    \ ++it) {\n        if (*it == '(') {\n            ++level;\n        } else if\
    \ (*it == ')') {\n            --level;\n        }\n        paren_levels.push_back(level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpl1_9l7y9: /tmp/tmpl1_9l7y9.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string current_paren_string\
    \ = \"\";\n    for (auto c : paren_string) {\n        if (c == '(') {\n      \
    \      current_paren_string = current_paren_string + c;\n        } else if (c\
    \ == ')') {\n            paren_levels.push_back(std::stoi(current_paren_string));\n\
    \            current_paren_string = \"\";\n        } else {\n            current_paren_string\
    \ = current_paren_string + c;\n        }\n    }\n    return paren_levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    long paren_level = 0;\n    long paren_levels_temp_index\
    \ = 0;\n    long paren_levels_temp_size = 0;\n    long paren_levels_temp_index2\
    \ = 0;\n    long paren_levels_temp_size2 = 0;\n    long paren_levels_temp_index3\
    \ = 0;\n    long paren_levels_temp_size3 = 0;\n    long paren_levels_temp_index4\
    \ = 0;\n    long paren_levels_temp_size4 = 0;\n    long paren_levels_temp_index5\
    \ = 0;\n    long paren_levels_temp_size5 = 0;\n    long paren_levels_temp_index6\
    \ = 0;\n    long paren_levels_temp_size6 = 0;\n    long paren_levels_temp_index7\
    \ = 0;\n    long paren_levels_temp_size7 = 0;\n    long paren_levels_temp_index8\
    \ = 0;\n    long paren_levels_temp_size8 = 0;\n    long paren_levels_temp_index9\
    \ = 0;\n    long paren_levels_temp_size9 = 0;\n    long paren_levels_temp_index10\
    \ = 0;\n    long paren_levels_temp_size10 = 0;\n    long paren_levels_temp_index11\
    \ = 0;\n    long paren_levels_temp_size11 = 0;\n    long paren_levels_temp_index12\
    \ = 0;\n    long paren_levels_temp_size12 = 0;\n    long paren_levels_temp_index13\
    \ = 0;\n    long paren_levels_temp_size13 = 0;\n    long paren_levels_temp_index14\
    \ = 0;\n    long paren_levels_temp_size14 = 0;\n    long paren_levels_temp_index15\
    \ = 0;\n    long paren_levels_temp_size15 = 0;\n    long paren_levels_temp_index16\
    \ = 0;\n    long paren_levels_temp_size16 = 0;\n    long paren_levels_temp_index17\
    \ = 0;\n    long paren_levels_temp_size17 = 0;\n    long paren_levels_temp_index18\
    \ = 0;\n    long paren_levels_temp_size18 = 0;\n    long paren_levels_temp_index19\
    \ = 0;\n    long paren_levels_temp_size19 = 0;\n    long paren_levels_temp_index20\
    \ = 0;\n    long paren_levels_temp_size20 = 0;\n    long paren_levels_temp_index21\
    \ = 0;\n    long paren_levels_temp_size21 = 0;\n    long paren_levels_temp_index22\
    \ = 0;\n    long paren_levels_temp_size22 = 0;\n    long paren_levels_temp_index23\
    \ = 0;\n\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpivn3rg4u: /tmp/tmpivn3rg4u.cpp:61: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        paren_levels_temp.push_back(level.size());\n\
    \    }\n    std::vector<long> paren_levels_temp2 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp3 = paren_levels_temp;\n    std::vector<long> paren_levels_temp4\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp5 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp6 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp7 = paren_levels_temp;\n    std::vector<long> paren_levels_temp8\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp9 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp10 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp11 = paren_levels_temp;\n    std::vector<long> paren_levels_temp12\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp13 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp14 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp15 = paren_levels_temp;\n    std::vector<long> paren_levels_temp16\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp17 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp18 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp19 = paren_levels_temp;\n    std::vector<long> paren_levels_temp20\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp21 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp22 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp23 = paren_levels_temp;\n    std::vector<long> paren_levels_temp24\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp25 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp26 = paren_levels_temp;\n    std::vector<long>\
    \ paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp78sf_v8n.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp78sf_v8n.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmp78sf_v8n.cpp:14:43: error: request for member\
    \ \u2018size\u2019 in \u2018level\u2019, which is of non-class type \u2018long\
    \ int\u2019\n   14 |         paren_levels_temp.push_back(level.size());\n    \
    \  |                                           ^~~~\n/tmp/tmp78sf_v8n.cpp:42:1:\
    \ error: expected initializer before \u2018}\u2019 token\n   42 | }\n      | ^\n\
    /tmp/tmp78sf_v8n.cpp:42:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_level--;\n\
    \        } else if (is_open) {\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpjokbtskd: /tmp/tmpjokbtskd.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_level = \"\";\n    for (auto c : paren_string) {\n\
    \        if (c == '(') {\n            curr_paren_level += c;\n        } else if\
    \ (c == ')') {\n            curr_paren_level += c;\n            paren_levels.push_back(std::stoi(curr_paren_level));\n\
    \            curr_paren_level = \"\";\n        } else {\n            curr_paren_level\
    \ += c;\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp4laxqzzj: /tmp/tmp4laxqzzj.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        if (paren_string[i] == '(') {\n            current_level++;\n\
    \        } else if (paren_string[i] == ')') {\n            current_level--;\n\
    \        }\n        paren_levels.push_back(current_level);\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpx40iap1x: /tmp/tmpx40iap1x.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\"()\");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.reserve(paren_levels.size());\n    for (long i = 0; i <\
    \ paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    long max_level = 0;\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        if (paren_levels_temp[i] > max_level) {\n            max_level\
    \ = paren_levels_temp[i];\n        }\n    }\n    std::vector<long> paren_levels_temp2;\n\
    \    paren_levels_temp2.reserve(paren_levels_temp.size());\n    for (long i =\
    \ 0; i < paren_levels_temp.size(); i++) {\n        if (paren_levels_temp[i] ==\
    \ max_level) {\n            paren_levels_temp2.push_back(i);\n        }\n    }\n\
    \    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.reserve(paren_levels_temp2.size());\n\
    \    for (long i = 0; i < paren_levels_temp2.size(); i++) {\n        paren_levels_temp3.push_back(paren_levels_temp2[i]);\n\
    \    }\n    return paren_levels_temp3;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp91_kfw4y.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp91_kfw4y.cpp:10:77: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\"()\");\n      |                \
    \                                                             ^~~~~\n"
  stdout: ''
  timestamp: 1660112997
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long max_level = 0;\n\
    \    std::string curr_level;\n    std::string curr_paren;\n    for (size_t i =\
    \ 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n\
    \            curr_level = paren_string.substr(0, i);\n            curr_paren =\
    \ paren_string.substr(i, 1);\n            paren_levels.push_back(curr_level.size());\n\
    \            if (curr_level.size() > max_level) {\n                max_level =\
    \ curr_level.size();\n            }\n        } else if (paren_string[i] == ')')\
    \ {\n            curr_level = paren_string.substr(0, i);\n            curr_paren\
    \ = paren_string.substr(i, 1);\n            paren_levels.push_back(curr_level.size());\n\
    \            if (curr_level.size() > max_level) {\n                max_level =\
    \ curr_level.size();\n            }\n        }\n    }\n    std::vector<long> result;\n\
    \    for (size_t i = 0; i < paren_levels.size(); i++) {\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmptp3xpoyv: /tmp/tmptp3xpoyv.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        long paren_level\
    \ = paren_levels[i];\n        if (paren_level > 0) {\n            paren_levels_temp.push_back(paren_level);\n\
    \        }\n    }\n    long max_level = 0;\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        if (paren_levels_temp[i] > max_level) {\n            max_level\
    \ = paren_levels_temp[i];\n        }\n    }\n    std::vector<long> paren_levels_temp2;\n\
    \    paren_levels_temp2.reserve(max_level + 1);\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        if (paren_levels_temp[i] > max_level) {\n            paren_levels_temp2.push_back(paren_levels_temp[i]);\n\
    \        }\n    }\n    paren_levels_temp2.push_back(max_level);\n    return paren_levels_temp2;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgds0fuf2.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpgds0fuf2.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto &c : paren_string) {\n       \
    \ if (c == '(') {\n            paren_level_count++;\n            paren_level =\
    \ std::to_string(paren_level_count);\n        } else if (c == ')') {\n       \
    \     paren_level_count--;\n            paren_level = std::to_string(paren_level_count);\n\
    \        } else {\n            paren_level += c;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (auto &c : paren_level) {\n        if (c == '(') {\n         \
    \   paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_levels.push_back(paren_level_count);\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpwvwlnejj: /tmp/tmpwvwlnejj.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ current_level) {\n            paren_levels.push_back(paren_level);\n       \
    \ }\n        current_level = paren_level;\n    }\n    return paren_levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpbihckrxj: /tmp/tmpbihckrxj.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(1);\n\
    \    long max_level = 1;\n    for (long i = 0; i < paren_levels.size(); i++) {\n\
    \        if (paren_levels[i] == \"(\") {\n            paren_levels_temp.push_back(1);\n\
    \        } else if (paren_levels[i] == \")\") {\n            long current_level\
    \ = paren_levels_temp.back();\n            paren_levels_temp.pop_back();\n   \
    \         if (current_level > max_level) {\n                max_level = current_level;\n\
    \            }\n        } else {\n            long current_level = paren_levels_temp.back();\n\
    \            paren_levels_temp.pop_back();\n            long new_level = current_level\
    \ + 1;\n            if (new_level > max_level) {\n                max_level =\
    \ new_level;\n            }\n            paren_levels_temp.push_back(new_level);\n\
    \        }\n    }\n    return paren_levels_temp;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpc69nz6a9.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpc69nz6a9.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpc69nz6a9.cpp:15:32: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   15 |         if (paren_levels[i]\
    \ == \"(\") {\n      |                                ^~~\n/tmp/tmpc69nz6a9.cpp:17:39:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   17 |         } else if (paren_levels[i] == \")\") {\n      |             \
    \                          ^~~\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\" \");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(paren_levels.size());\n    for (long i = 0; i\
    \ < paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp2.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp3.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp4;\n    paren_levels_temp4.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp4.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp5;\n    paren_levels_temp5.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp5.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp6;\n    paren_levels_temp6.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp6.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp7;\n    paren_levels_temp7.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp7.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp8;\n    paren_levels_temp8.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp8.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp9;\n    paren_levels_temp9.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp9.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp10;\n    paren_levels_temp10.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcthb5pbj.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpcthb5pbj.cpp:10:77: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\" \");\n      |                 \
    \                                                            ^~~~~\n/tmp/tmpcthb5pbj.cpp:59:26:\
    \ error: expected \u2018;\u2019 before \u2018}\u2019 token\n   59 |         paren_levels_temp\n\
    \      |                          ^\n      |                          ;\n   60\
    \ | }\n      | ~                         \n/tmp/tmpcthb5pbj.cpp:61:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   61\
    \ | int main() {\n      |            ^\n/tmp/tmpcthb5pbj.cpp:66:1: error: expected\
    \ \u2018}\u2019 at end of input\n   66 | }\n      | ^\n/tmp/tmpcthb5pbj.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpcthb5pbj.cpp:66:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   66 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    long current_level_size = 0;\n    for (auto c : paren_string) {\n       \
    \ if (c == '(') {\n            current_level += c;\n            current_level_size\
    \ += 1;\n        } else if (c == ')') {\n            current_level_size = std::min(current_level_size,\
    \ levels.size());\n            levels.push_back(current_level_size);\n       \
    \     current_level.clear();\n        } else {\n            current_level += c;\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp51o5wmtt.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp51o5wmtt.cpp:17:76: error: no matching function for call to \u2018\
    min(long int&, std::vector<long int>::size_type)\u2019\n   17 |             current_level_size\
    \ = std::min(current_level_size, levels.size());\n      |                    \
    \                                                        ^\nIn file included from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp51o5wmtt.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp51o5wmtt.cpp:17:76: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    })\n   17 |             current_level_size = std::min(current_level_size, levels.size());\n\
    \      |                                                                     \
    \       ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n     \
    \            from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp51o5wmtt.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp51o5wmtt.cpp:17:76:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long\
    \ unsigned"
  stdout: ''
  timestamp: 1660112999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n         \
    \   paren_levels.push_back(level);\n            level++;\n            paren_level++;\n\
    \            paren_level_counter++;\n        } else if (c == ')') {\n        \
    \    level--;\n            paren_levels.push_back(level);\n            paren_level--;\n\
    \            paren_level_counter--;\n        } else if (c == ' ') {\n        \
    \    level--;\n            paren_levels.push_back(level);\n            paren_level--;\n\
    \            paren_level_counter--;\n        } else if (c == '(' || c == ')' ||\
    \ c == ' ') {\n            level--;\n            paren_levels.push_back(level);\n\
    \            paren_level--;\n            paren_level_counter--;\n        } else\
    \ {\n            assert(false);\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    paren_levels.push_back(level);\n    paren_levels.push_back(level);\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpbpb6kstj: /tmp/tmpbpb6kstj.cpp:47: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpyfnvbax5: /tmp/tmpyfnvbax5.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool paren_found = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_found = true;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_found = false;\n          \
    \  paren_level--;\n        }\n        if (paren_found) {\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp5erkfxsh: /tmp/tmp5erkfxsh.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        long paren_level = 0;\n     \
    \   for (auto &char : level) {\n            if (char == '(') {\n             \
    \   paren_level++;\n            } else if (char == ')') {\n                paren_level--;\n\
    \            }\n        }\n        paren_levels_temp.push_back(paren_level);\n\
    \    }\n    std::vector<long> paren_levels_temp2 = paren_levels_temp;\n    std::sort(paren_levels_temp2.begin(),\
    \ paren_levels_temp2.end());\n    std::vector<long> paren_levels_temp3 = paren_levels_temp2;\n\
    \    std::vector<long> paren_levels_temp4 = paren_levels_temp3;\n    std::vector<long>\
    \ paren_levels_temp5 = paren_levels_temp4;\n    std::vector<long> paren_levels_temp6\
    \ = paren_levels_temp5;\n    std::vector<long> paren_levels_temp7 = paren_levels_temp6;\n\
    \    std::vector<long> paren_levels_temp8 = paren_levels_temp7;\n    std::vector<long>\
    \ paren_levels_temp9 = paren_levels_temp8;\n    std::vector<long> paren_levels_temp10\
    \ = paren_levels_temp9;\n    std::vector<long> paren_levels_temp11 = paren_levels_temp10;\n\
    \    std::vector<long> paren_levels_temp12 = paren_levels_temp11;\n    std::vector<long>\
    \ paren_levels_temp13 = paren_levels_temp12;\n    std::vector<long> paren_levels_temp14\
    \ = paren_levels_temp13;\n    std::vector<long> paren_levels_temp15 = paren_levels_temp14;\n\
    \    std::vector<long> paren_levels_temp16 = paren_levels_temp15;\n    std::vector<long>\
    \ paren_levels_temp17 = paren_levels_temp16;\n    std::vector<long> paren_levels_temp18\
    \ = paren_levels_temp17;\n    std::vector<long> paren_levels_temp19 = paren_levels_temp18;\n\
    \    std::vector<long> paren_levels_temp20 = paren_levels_temp19;\n    std::vector<long>\
    \ paren_levels_temp21 = paren_levels_temp20;\n    std::vector<long> paren_levels_temp22\
    \ = paren_levels_temp21;\n    std::vector<long> paren_levels_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi76h7stj.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpi76h7stj.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpi76h7stj.cpp:15:20: error: expected unqualified-id\
    \ before \u2018char\u2019\n   15 |         for (auto &char : level) {\n      |\
    \                    ^~~~\n/tmp/tmpi76h7stj.cpp:15:20: error: expected \u2018\
    ;\u2019 before \u2018char\u2019\n   15 |         for (auto &char : level) {\n\
    \      |                    ^~~~\n      |                    ;\n/tmp/tmpi76h7stj.cpp:15:25:\
    \ error: expected unqualified-id before \u2018:\u2019 token\n   15 |         for\
    \ (auto &char : level) {\n      |                         ^\n/tmp/tmpi76h7stj.cpp:15:32:\
    \ error: expected \u2018;\u2019 before \u2018)\u2019 token\n   15 |         for\
    \ (auto &char : level) {\n      |                                ^\n      |  \
    \                              ;\n/tmp/tmpi76h7stj.cpp:16:22: error: expected\
    \ unqualified-id before \u2018==\u2019 token\n   16 |             if (char ==\
    \ '(') {\n      |                      ^~\n/tmp/tmpi76h7stj.cpp:18:29: error:\
    \ expected unqualified-id before \u2018==\u2019 token\n   18 |             } else\
    \ if (char == ')') {\n      |                             ^~\n/tmp/tmpi76h7stj.cpp:47:1:\
    \ error: expected initializer before \u2018}\u2019 token\n   47 | }\n      | ^\n\
    /tmp/tmpi76h7stj.cpp:47:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113000
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long current_level = 0;\n  for (auto c : paren_string) {\n    if (c == '(')\
    \ {\n      current_level++;\n    } else if (c == ')') {\n      current_level--;\n\
    \    }\n    paren_levels.push_back(current_level);\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpdp53hevs: /tmp/tmpdp53hevs.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(level);\n            level++;\n        }\n  \
    \  }\n    paren_levels.push_back(level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmps6qlfkpa: /tmp/tmps6qlfkpa.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long paren_level =\
    \ 0;\n    long paren_level_counter = 0;\n    for (auto c : paren_string) {\n \
    \       if (c == '(') {\n            paren_level++;\n            paren_level_counter++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n            paren_level_counter--;\n\
    \        }\n        if (paren_level == 0 && paren_level_counter == 0) {\n    \
    \        paren_levels.push_back(paren_level);\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpuri777yv: /tmp/tmpuri777yv.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    long level = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            paren_level = paren_string.substr(0,\
    \ i);\n            level++;\n        } else if (paren_string[i] == ')') {\n  \
    \          level--;\n            if (level == 0) {\n                levels.push_back(level);\n\
    \            }\n        }\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpsey5_l1s: /tmp/tmpsey5_l1s.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpyfnvbax5: /tmp/tmpyfnvbax5.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_copy;\n    paren_levels_copy = paren_levels.begin();\n\
    \    long paren_level = 0;\n    long paren_levels_copy_index = 0;\n    long paren_levels_copy_size\
    \ = 0;\n    long paren_levels_copy_size2 = 0;\n    long paren_levels_copy_size3\
    \ = 0;\n    long paren_levels_copy_size4 = 0;\n    long paren_levels_copy_size5\
    \ = 0;\n    long paren_levels_copy_size6 = 0;\n    long paren_levels_copy_size7\
    \ = 0;\n    long paren_levels_copy_size8 = 0;\n    long paren_levels_copy_size9\
    \ = 0;\n    long paren_levels_copy_size10 = 0;\n    long paren_levels_copy_size11\
    \ = 0;\n    long paren_levels_copy_size12 = 0;\n    long paren_levels_copy_size13\
    \ = 0;\n    long paren_levels_copy_size14 = 0;\n    long paren_levels_copy_size15\
    \ = 0;\n    long paren_levels_copy_size16 = 0;\n    long paren_levels_copy_size17\
    \ = 0;\n    long paren_levels_copy_size18 = 0;\n    long paren_levels_copy_size19\
    \ = 0;\n    long paren_levels_copy_size20 = 0;\n    long paren_levels_copy_size21\
    \ = 0;\n    long paren_levels_copy_size22 = 0;\n    long paren_levels_copy_size23\
    \ = 0;\n    long paren_levels_copy_size24 = 0;\n    long paren_levels_copy_size25\
    \ = 0;\n    long paren_levels_copy_size26 = 0;\n    long paren_levels_copy_size27\
    \ = 0;\n    long paren_levels_copy_size28 = 0;\n    long paren_levels_copy_size29\
    \ = 0;\n    long paren_levels_copy_size30 = 0;\n    long paren_levels_copy_size31\
    \ = 0;\n    long paren_levels_copy_size32 = 0;\n    long paren_levels_copy_size33\
    \ = 0;\n    long paren_levels_copy_size34 = 0;\n    long paren_levels_copy_size35\
    \ = 0;\n    long paren_levels_copy_size36 = 0;\n    long paren_levels_copy_size37\
    \ = 0;\n    long paren_levels_copy_size38 = 0;\n    long paren_levels_copy_size39\
    \ = 0;\n    long paren_levels_copy_size40 = 0;\n    long paren_levels_copy_size41\
    \ = 0;\n    long paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprco097tn.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmprco097tn.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmprco097tn.cpp:12:44: error: no match for \u2018\
    operator=\u2019 (operand types are \u2018std::vector<long int>\u2019 and \u2018\
    std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019})\n   12 |     paren_levels_copy = paren_levels.begin();\n\
    \      |                                            ^\nIn file included from /usr/include/c++/9/vector:72,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprco097tn.cpp:2:\n/usr/include/c++/9/bits/vector.tcc:198:5:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const\
    \ std::vector<_Tp, _Alloc>&) [with _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n  198 |     vector<_Tp, _Alloc>::\n      |     ^~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/vector.tcc:199:42: note:   no known conversion for argument\
    \ 1 from \u2018std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019} to \u2018const std::vector<long int>&\u2019\
    \n  199 |     operator=(const vector<_Tp, _Alloc>& __x)\n      |             \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprco097tn.cpp:2:\n/usr/include/c++/9/bits/stl_vector"
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_level_string\
    \ = paren_level_string.empty() ? \"(\" : paren_level_string;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_level_string\
    \ = paren_level_string.empty() ? \")\" : paren_level_string;\n            paren_level_string\
    \ = paren_level_string.substr(0, paren_level_string.size() - 1);\n           \
    \ paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string.substr(0, paren_level_string.size() - 1);\n           \
    \ paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string.substr(0, paren_level_string.size() - 1);\n           \
    \ paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + \")\";\n            paren_level_string = paren_level_string + \")\";\n   \
    \         paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + \")\";\n            paren_level_string = paren_level_string + \")\";\n   \
    \         paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + \")\";\n            paren_level_string = paren_level_string + \")\";\n   \
    \         paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + \")\";\n            paren_level_string = paren_level_string + \")\";\n   \
    \         paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + \")\";\n            paren_level_string = paren_level_string\
    \ + \")\";\n            paren_level_string = paren_level_string + \")\";\n   \
    \         paren_level_string = paren_level_string + \")\";\n            paren_level_string\
    \ = paren_level_string + \")\";\n            paren_level_string = \n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8isd93ts.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp8isd93ts.cpp:49:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   49 | }\n      | ^\n/tmp/tmp8isd93ts.cpp:50:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   50 | int main() {\n     \
    \ |            ^\n/tmp/tmp8isd93ts.cpp:55:1: error: expected \u2018}\u2019 at\
    \ end of input\n   55 | }\n      | ^\n/tmp/tmp8isd93ts.cpp:13:33: note: to match\
    \ this \u2018{\u2019\n   13 |     for (auto c : paren_string) {\n      |     \
    \                            ^\n/tmp/tmp8isd93ts.cpp:55:1: error: expected \u2018\
    }\u2019 at end of input\n   55 | }\n      | ^\n/tmp/tmp8isd93ts.cpp:8:65: note:\
    \ to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp8isd93ts.cpp:55:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   55 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113000
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool in_paren = false;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            in_paren = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (c == ')') {\n            in_paren = false;\n            paren_levels.pop_back();\n\
    \        } else if (c == ' ') {\n            if (in_paren) {\n               \
    \ paren_level++;\n            }\n        } else {\n            assert(false);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpx5lu4vh4: /tmp/tmpx5lu4vh4.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    size_t paren_level_count = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        char c = paren_string[i];\n\
    \        if (c == '(') {\n            paren_level_count++;\n        } else if\
    \ (c == ')') {\n            paren_level_count--;\n            if (paren_level_count\
    \ == 0) {\n                paren_levels.push_back(paren_level);\n            \
    \    paren_level_count = 0;\n            }\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvtvb4iqq: /tmp/tmpvtvb4iqq.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvzctdgob: /tmp/tmpvzctdgob.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count2 =\
    \ 0;\n    long paren_level_max_count3 = 0;\n    long paren_level_max_count4 =\
    \ 0;\n    long paren_level_max_count5 = 0;\n    long paren_level_max_count6 =\
    \ 0;\n    long paren_level_max_count7 = 0;\n    long paren_level_max_count8 =\
    \ 0;\n    long paren_level_max_count9 = 0;\n    long paren_level_max_count10 =\
    \ 0;\n    long paren_level_max_count11 = 0;\n    long paren_level_max_count12\
    \ = 0;\n    long paren_level_max_count13 = 0;\n    long paren_level_max_count14\
    \ = 0;\n    long paren_level_max_count15 = 0;\n    long paren_level_max_count16\
    \ = 0;\n    long paren_level_max_count17 = 0;\n    long paren_level_max_count18\
    \ = 0;\n    long paren_level_max_count19 = 0;\n    long paren_level_max_count20\
    \ = 0;\n    long paren_level_max_count21 = 0;\n    long paren_level_max_count22\
    \ = 0;\n    long paren_level_max_count23 = 0;\n    long paren_level_max_count24\
    \ = 0;\n    long paren_level_max_count25 = 0;\n    long paren_level_max_count26\
    \ = 0;\n    long paren_level_max_count27 = 0;\n    long paren_level_max_count28\
    \ = 0;\n    long paren_level_max_count29 = 0;\n    long paren_level_max_count30\
    \ = 0;\n    long paren_level_max_count31 = 0;\n    long paren_level_max_count32\
    \ = 0;\n    long paren_level_max_count33 = 0;\n    long paren_level_max_count34\
    \ = 0;\n    long paren_level_max_count35 = 0;\n    long paren_level_max_count36\
    \ = 0;\n    long paren_level_max_count37 = 0;\n    long paren_level_max_count38\
    \ = 0;\n    long paren_level_max_count39 = 0;\n    long paren_level_max_count40\
    \ = 0;\n    long paren_level_max_count41 = 0;\n    long paren_level_max_count42\
    \ = 0;\n    long paren_level_max_count43 = 0;\n    long paren_level_max_count44\
    \ = 0;\n    long paren_level_max_count45 = 0;\n    long paren_level_max_count46\
    \ = 0;\n    long paren_level_max_count47 = 0;\n    long paren_level_max_count48\
    \ = 0;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpydaqm0qe: /tmp/tmpydaqm0qe.cpp:65: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\"()\");\n  long max_level = 0;\n\
    \  for (auto level : paren_levels) {\n    if (level.length() > max_level) {\n\
    \      max_level = level.length();\n    }\n  }\n  std::vector<long> nested_paren_levels;\n\
    \  for (auto level : paren_levels) {\n    if (level.length() == max_level) {\n\
    \      nested_paren_levels.push_back(level.length());\n    } else {\n      nested_paren_levels.push_back(0);\n\
    \    }\n  }\n  return nested_paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpmi6u0_jl.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpmi6u0_jl.cpp:10:75: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\"()\");\n      |                \
    \                                                           ^~~~~\n/tmp/tmpmi6u0_jl.cpp:13:15:\
    \ error: request for member \u2018length\u2019 in \u2018level\u2019, which is\
    \ of non-class type \u2018long int\u2019\n   13 |     if (level.length() > max_level)\
    \ {\n      |               ^~~~~~\n/tmp/tmpmi6u0_jl.cpp:14:25: error: request\
    \ for member \u2018length\u2019 in \u2018level\u2019, which is of non-class type\
    \ \u2018long int\u2019\n   14 |       max_level = level.length();\n      |   \
    \                      ^~~~~~\n/tmp/tmpmi6u0_jl.cpp:19:15: error: request for\
    \ member \u2018length\u2019 in \u2018level\u2019, which is of non-class type \u2018\
    long int\u2019\n   19 |     if (level.length() == max_level) {\n      |      \
    \         ^~~~~~\n/tmp/tmpmi6u0_jl.cpp:20:43: error: request for member \u2018\
    length\u2019 in \u2018level\u2019, which is of non-class type \u2018long int\u2019\
    \n   20 |       nested_paren_levels.push_back(level.length());\n      |      \
    \                                     ^~~~~~\n"
  stdout: ''
  timestamp: 1660113000
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        long paren_level\
    \ = 0;\n        bool is_open = false;\n        for (long j = 0; j < paren_levels[i].length();\
    \ j++) {\n            if (paren_levels[i].at(j) == '(') {\n                is_open\
    \ = true;\n                paren_level++;\n            } else if (paren_levels[i].at(j)\
    \ == ')') {\n                is_open = false;\n                paren_level--;\n\
    \            }\n        }\n        paren_levels_temp.push_back(paren_level);\n\
    \    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.reserve(paren_levels_temp.size());\n\
    \    for (long i = 0; i < paren_levels_temp.size(); i++) {\n        if (paren_levels_temp[i]\
    \ > paren_levels_temp2[i]) {\n            paren_levels_temp2 = paren_levels_temp;\n\
    \        }\n    }\n    return paren_levels_temp2;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpi8x1j0ts.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpi8x1j0ts.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpi8x1j0ts.cpp:16:46: error: request for member\
    \ \u2018length\u2019 in \u2018paren_levels.std::vector<long int>::operator[](((std::vector<long\
    \ int>::size_type)i))\u2019, which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   16 |      \
    \   for (long j = 0; j < paren_levels[i].length(); j++) {\n      |           \
    \                                   ^~~~~~\n/tmp/tmpi8x1j0ts.cpp:17:33: error:\
    \ request for member \u2018at\u2019 in \u2018paren_levels.std::vector<long int>::operator[](((std::vector<long\
    \ int>::size_type)i))\u2019, which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   17 |      \
    \       if (paren_levels[i].at(j) == '(') {\n      |                         \
    \        ^~\n/tmp/tmpi8x1j0ts.cpp:20:40: error: request for member \u2018at\u2019\
    \ in \u2018paren_levels.std::vector<long int>::operator[](((std::vector<long int>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   20 |      \
    \       } else if (paren_levels[i].at(j) == ')') {\n      |                  \
    \                      ^~\n"
  stdout: ''
  timestamp: 1660113000
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        paren_levels_temp.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.reserve(paren_levels_temp.size());\n\
    \    for (auto &level : paren_levels_temp) {\n        paren_levels_temp2.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.reserve(paren_levels_temp2.size());\n\
    \    for (auto &level : paren_levels_temp2) {\n        paren_levels_temp3.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp4;\n    paren_levels_temp4.reserve(paren_levels_temp3.size());\n\
    \    for (auto &level : paren_levels_temp3) {\n        paren_levels_temp4.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp5;\n    paren_levels_temp5.reserve(paren_levels_temp4.size());\n\
    \    for (auto &level : paren_levels_temp4) {\n        paren_levels_temp5.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp6;\n    paren_levels_temp6.reserve(paren_levels_temp5.size());\n\
    \    for (auto &level : paren_levels_temp5) {\n        paren_levels_temp6.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp7;\n    paren_levels_temp7.reserve(paren_levels_temp6.size());\n\
    \    for (auto &level : paren_levels_temp6) {\n        paren_levels_temp7.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp8;\n    paren_levels_temp8.reserve(paren_levels_temp7.size());\n\
    \    for (auto &level : paren_levels_temp7) {\n        paren_levels_temp8.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp9;\n    paren_levels_temp9.reserve(paren_levels_temp8.size());\n\
    \    for (auto &level : paren_levels_temp8) {\n        paren_levels_temp9.push_back(level);\n\
    \    }\n    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppqwojdr3.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmppqwojdr3.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmppqwojdr3.cpp:57:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   57 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113000
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket = false;\n\
    \    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_curly_brace = false;\n    bool is_closing_curly_brace\
    \ = false;\n    bool is_opening_square_brace = false;\n    bool is_closing_square_brace\
    \ = false;\n    bool is_opening_paren_or_curly_bracket = false;\n    bool is_closing_paren_or_curly_bracket\
    \ = false;\n    bool is_opening_paren_or_curly_brace = false;\n    bool is_closing_paren_or_curly_brace\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_bracket = false;\n\
    \    bool is_closing_paren_or_curly_brace_or_square_bracket = false;\n    bool\
    \ is_opening_paren_or_curly_brace_or_square_brace = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_bracket\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_bracket\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_brace\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_brace\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_bracket\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_bracket\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_brace\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_brace\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_brace_or_curly_bracket\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp26vqehfx.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp26vqehfx.cpp:42:1: error: expected initializer before \u2018}\u2019\
    \ token\n   42 | }\n      | ^\n/tmp/tmp26vqehfx.cpp:42:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n    std::string\
    \ paren_string_reversed;\n    std::string paren_string_reversed_reversed;\n  \
    \  std::string paren_string_reversed_reversed_reversed;\n    std::string paren_string_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reverse\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt72ydrxg.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpt72ydrxg.cpp:32:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   32 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt72ydrxg.cpp:31:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   31 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt72ydrxg.cpp:35:1: error: expected initializer before \u2018}\u2019 token\n\
    \   35 | }\n      | ^\n/tmp/tmpt72ydrxg.cpp:35:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113000
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long max_level = 0;\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_paren_or_closed = false;\n    bool is_closing_paren_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_open = false;\n    bool is_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_closed_or_opening_paren = false;\n    bool is_closing_paren_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpzs1d3kfv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpzs1d3kfv.cpp:25:10: error: redeclaration of \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \n   25 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzs1d3kfv.cpp:24:10: note: \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \ previously declared here\n   24 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzs1d3kfv.cpp:26:10: error: redeclaration of \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \n   26 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzs1d3kfv.cpp:24:10: note: \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \ previously declared here\n   24 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzs1d3kfv.cpp:27:10: error: redeclaration of \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \n   27 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzs1d3kfv.cpp:24:10: note: \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \ previously declared here\n   24 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzs1d3kfv.cpp:28:10: error: redeclaration of \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \n   28 |     bool is_opening_paren_or_closed_or_opening"
  stdout: ''
  timestamp: 1660113000
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 1;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvfil_116.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpvfil_116.cpp:58:1: error: expected initializer before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmpvfil_116.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpyfnvbax5: /tmp/tmpyfnvbax5.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string current_paren_string = paren_string;\n    long current_paren_level\
    \ = 0;\n    bool is_open = false;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            is_open = true;\n\
    \            current_paren_level++;\n        }\n        else if (paren_string[i]\
    \ == ')') {\n            is_open = false;\n            current_paren_level--;\n\
    \        }\n        else if (is_open) {\n            current_paren_level++;\n\
    \        }\n        else {\n            current_paren_level--;\n        }\n  \
    \      paren_levels.push_back(current_paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp89ojxmuf: /tmp/tmp89ojxmuf.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    std::vector<long> paren_levels_temp_copy;\n    std::vector<long>\
    \ paren_levels_temp_copy2;\n    std::vector<long> paren_levels_temp_copy3;\n \
    \   std::vector<long> paren_levels_temp_copy4;\n    std::vector<long> paren_levels_temp_copy5;\n\
    \    std::vector<long> paren_levels_temp_copy6;\n    std::vector<long> paren_levels_temp_copy7;\n\
    \    std::vector<long> paren_levels_temp_copy8;\n    std::vector<long> paren_levels_temp_copy9;\n\
    \    std::vector<long> paren_levels_temp_copy10;\n    std::vector<long> paren_levels_temp_copy11;\n\
    \    std::vector<long> paren_levels_temp_copy12;\n    std::vector<long> paren_levels_temp_copy13;\n\
    \    std::vector<long> paren_levels_temp_copy14;\n    std::vector<long> paren_levels_temp_copy15;\n\
    \    std::vector<long> paren_levels_temp_copy16;\n    std::vector<long> paren_levels_temp_copy17;\n\
    \    std::vector<long> paren_levels_temp_copy18;\n    std::vector<long> paren_levels_temp_copy19;\n\
    \    std::vector<long> paren_levels_temp_copy20;\n    std::vector<long> paren_levels_temp_copy21;\n\
    \    std::vector<long> paren_levels_temp_copy22;\n    std::vector<long> paren_levels_temp_copy23;\n\
    \    std::vector<long> paren_levels_temp_copy24;\n    std::vector<long> paren_levels_temp_copy25;\n\
    \    std::vector<long> paren_levels_temp_copy26;\n    std::vector<long> paren_levels_temp_copy27;\n\
    \    std::vector<long> paren_levels_temp_copy28;\n    std::vector<long> paren_levels_temp_copy29;\n\
    \    std::vector<long> paren_levels_temp_copy30;\n    std::vector<long> paren_levels_temp_copy31;\n\
    \    std::vector<long> paren_levels_temp_copy32;\n    std::vector<long> paren_levels_temp_copy33;\n\
    \    std::vector<long> paren_levels_temp_copy34;\n    std::vector<long> paren_levels_temp_copy35;\n\
    \    std::vector<long> paren_levels_temp_copy36;\n    std::vector<long> paren_levels_temp_copy37;\n\
    \    std::vector<long> paren_levels_temp_copy38;\n    std::vector<long> paren_levels_temp_copy39;\n\
    \    std::vector<long> \n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjtppzz8e.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpjtppzz8e.cpp:51:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   51 | }\n      | ^\n/tmp/tmpjtppzz8e.cpp:51:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = paren_string.split(\"\
    \ \");\n  std::vector<long> paren_levels_temp;\n  paren_levels_temp.reserve(paren_levels.size());\n\
    \  for (int i = 0; i < paren_levels.size(); i++) {\n    long paren_level = paren_levels[i];\n\
    \    long paren_level_count = 1;\n    while (paren_level > 0) {\n      paren_level_count++;\n\
    \      paren_level--;\n    }\n    paren_levels_temp.push_back(paren_level_count);\n\
    \  }\n  std::sort(paren_levels_temp.begin(), paren_levels_temp.end());\n  std::vector<long>\
    \ paren_levels_sorted_temp;\n  paren_levels_sorted_temp.reserve(paren_levels_temp.size());\n\
    \  for (int i = 0; i < paren_levels_temp.size(); i++) {\n    paren_levels_sorted_temp.push_back(paren_levels_temp[i]);\n\
    \  }\n  std::vector<long> paren_levels_sorted_temp_reversed;\n  paren_levels_sorted_temp_reversed.reserve(paren_levels_sorted_temp.size());\n\
    \  for (int i = 0; i < paren_levels_sorted_temp.size() - 1; i++) {\n    paren_levels_sorted_temp_reversed.push_back(paren_levels_sorted_temp[i]);\n\
    \  }\n  std::vector<long> paren_levels_sorted_temp_reversed_temp;\n  paren_levels_sorted_temp_reversed_temp.reserve(paren_levels_sorted_temp_reversed.size());\n\
    \  for (int i = 0; i < paren_levels_sorted_temp_reversed.size(); i++) {\n    paren_levels_sorted_temp_reversed_temp.push_back(paren_levels_sorted_temp_reversed[i]);\n\
    \  }\n  std::vector<long> paren_levels_sorted_temp_reversed_temp_reversed;\n \
    \ paren_levels_sorted_temp_reversed_temp_reversed.reserve(paren_levels_sorted_temp_reversed_temp.size());\n\
    \  for (int i = 0; i < paren_levels_sorted_temp_reversed_temp.size() - 1; i++)\
    \ {\n    paren_levels_sorted_temp_reversed_temp_reversed.push_back(paren_levels_sorted_temp_reversed_temp[i]);\n\
    \  }\n  std::vector<long> paren_levels_sorted_temp_reversed_temp_reversed_temp;\n\
    \  paren_levels_sorted_temp_reversed_temp_reversed_temp.reserve(paren_levels_sorted_temp_reversed_temp_reversed.size());\n\
    \  for (int i = 0; i < paren_levels_sorted_temp_reversed_temp_reversed.size();\
    \ i++) {\n    paren_levels_sorted_temp_reversed_temp_reversed_\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptw6dkjvk.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmptw6dkjvk.cpp:10:31: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |   paren_levels = paren_string.split(\" \");\n      |               \
    \                ^~~~~\n/tmp/tmptw6dkjvk.cpp:46:5: error: \u2018paren_levels_sorted_temp_reversed_temp_reversed_\u2019\
    \ was not declared in this scope; did you mean \u2018paren_levels_sorted_temp_reversed_temp_reversed\u2019\
    ?\n   46 |     paren_levels_sorted_temp_reversed_temp_reversed_\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |     paren_levels_sorted_temp_reversed_temp_reversed\n/tmp/tmptw6dkjvk.cpp:48:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   48 | int main() {\n      |            ^\n/tmp/tmptw6dkjvk.cpp:53:1: error:\
    \ expected \u2018}\u2019 at end of input\n   53 | }\n      | ^\n/tmp/tmptw6dkjvk.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmptw6dkjvk.cpp:53:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   53 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    long max_level = 0;\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        if (paren_levels_temp[i] > max_level) {\n            max_level\
    \ = paren_levels_temp[i];\n        }\n    }\n    std::vector<long> paren_levels_temp2;\n\
    \    paren_levels_temp2.reserve(paren_levels_temp.size());\n    for (long i =\
    \ 0; i < paren_levels_temp.size(); i++) {\n        paren_levels_temp2.push_back(paren_levels_temp[i]);\n\
    \    }\n    for (long i = 0; i < paren_levels_temp2.size(); i++) {\n        if\
    \ (paren_levels_temp2[i] > max_level) {\n            paren_levels_temp2.erase(paren_levels_temp2.begin()\
    \ + i);\n        }\n    }\n    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.reserve(paren_levels_temp2.size());\n\
    \    for (long i = 0; i < paren_levels_temp2.size(); i++) {\n        paren_levels_temp3.push_back(paren_levels_temp2[i]);\n\
    \    }\n    for (long i = 0; i < paren_levels_temp3.size(); i++) {\n        if\
    \ (paren_levels_temp3[i] > max_level) {\n            paren_levels_temp3.erase(paren_levels_temp3.begin()\
    \ + i);\n        }\n    }\n    std::vector<long> paren_levels_temp4;\n    paren_levels_temp4.reserve(paren_levels_temp3.size());\n\
    \    for (long i = 0; i < paren_levels_temp3.size(); i++) {\n        paren_levels_temp4.push_back(paren_levels_temp3[i]);\n\
    \    }\n    for (long i = 0; i < paren_levels_temp4.size(); i++) {\n        if\
    \ (paren_levels_temp4[i] > max_level) {\n            paren_levels_temp4.erase(paren_levels_temp4.begin()\
    \ + i);\n        }\n    }\n    std::vector<long> paren_levels_temp5;\n    paren_levels_temp5.reserve(paren_levels_temp4.size());\n\
    \    for (long i = 0; i < paren_levels_temp4.size(); i++) {\n        paren_levels_temp5.push_back(paren_levels_temp4[i]);\n\
    \    }\n    for (long i = 0; i < paren_levels_temp5.size(); i++) {\n        if\
    \ (paren_levels_temp5[i] > \n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3w0xjr6y.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp3w0xjr6y.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmp3w0xjr6y.cpp:59:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   59 | }\n      | ^\n/tmp/tmp3w0xjr6y.cpp:58:36:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   58 |         if\
    \ (paren_levels_temp5[i] >\n      |            ~                       ^\n   \
    \   |                                    )\n   59 | }\n      | ~             \
    \                      \n/tmp/tmp3w0xjr6y.cpp:59:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   59 | }\n      | ^\n/tmp/tmp3w0xjr6y.cpp:60:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   60 | int main() {\n      |            ^\n/tmp/tmp3w0xjr6y.cpp:65:1: error:\
    \ expected \u2018}\u2019 at end of input\n   65 | }\n      | ^\n/tmp/tmp3w0xjr6y.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp3w0xjr6y.cpp:65:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   65 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpnkhwnfhm: /tmp/tmpnkhwnfhm.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_level = \"\";\n    for (auto c : paren_string) {\n\
    \        if (c == '(') {\n            curr_paren_level += c;\n        } else if\
    \ (c == ')') {\n            paren_levels.push_back(std::stoi(curr_paren_level));\n\
    \            curr_paren_level = \"\";\n        } else {\n            curr_paren_level\
    \ += c;\n        }\n    }\n    if (curr_paren_level != \"\") {\n        paren_levels.push_back(std::stoi(curr_paren_level));\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpyfnvbax5: /tmp/tmpyfnvbax5.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_string_reversed = paren_string;\n    std::reverse(paren_string_reversed.begin(),\
    \ paren_string_reversed.end());\n    size_t paren_level = 0;\n    size_t paren_level_reversed\
    \ = 0;\n    size_t paren_level_start = 0;\n    size_t paren_level_end = 0;\n \
    \   size_t paren_level_start_reversed = 0;\n    size_t paren_level_end_reversed\
    \ = 0;\n    size_t paren_level_start_reversed_end = 0;\n    size_t paren_level_end_reversed_end\
    \ = 0;\n    size_t paren_level_start_reversed_start_end = 0;\n    size_t paren_level_end_reversed_start_end\
    \ = 0;\n    size_t paren_level_start_reversed_start_end_reversed = 0;\n    size_t\
    \ paren_level_end_reversed_start_end_reversed = 0;\n    size_t paren_level_start_reversed_start_end_reversed_end\
    \ = 0;\n    size_t paren_level_end_reversed_start_end_reversed_end = 0;\n    size_t\
    \ paren_level_start_reversed_start_end_reversed_end_reversed = 0;\n    size_t\
    \ paren_level_end_reversed_start_end_reversed_end_reversed = 0;\n    size_t paren_level_start_reversed_start_end_reversed_end_reversed_end\
    \ = 0;\n    size_t paren_level_end_reversed_start_end_reversed_end_reversed_end\
    \ = 0;\n    size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed\
    \ = 0;\n    size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed\
    \ = 0;\n    size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n    size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n    size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed\
    \ = 0;\n    size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed\
    \ = 0;\n    size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n    size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n    size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n    size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n    size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reverse\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplgvbcilb.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplgvbcilb.cpp:39:12: error: redeclaration of \u2018size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\u2019\
    \n   39 |     size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplgvbcilb.cpp:37:12: note: \u2018size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\u2019\
    \ previously declared here\n   37 |     size_t paren_level_start_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplgvbcilb.cpp:40:12: error: redeclaration of \u2018size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\u2019\
    \n   40 |     size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplgvbcilb.cpp:38:12: note: \u2018size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\u2019\
    \ previously declared here\n   38 |     size_t paren_level_end_reversed_start_end_reversed_end_reversed_end_reversed_end_reversed_end\
    \ = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplgvbcilb.cpp:42:1: error: expected initializer before \u2018}\u2019 token\n\
    \   42 | }\n      | ^\n/tmp/tmplgvbcilb.cpp:42:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  std::string curr_paren_level;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      curr_paren_level = paren_string.substr(0,\
    \ i);\n      paren_levels.push_back(curr_paren_level.size());\n    } else if (paren_string[i]\
    \ == ')') {\n      long curr_level = paren_levels[paren_levels.size() - 1];\n\
    \      long new_level = curr_level + 1;\n      paren_levels.push_back(new_level);\n\
    \    }\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpz2e_fitt: /tmp/tmpz2e_fitt.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            current_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            current_level--;\n\
    \        } else if (is_open) {\n            current_level++;\n        } else {\n\
    \            paren_levels.push_back(current_level);\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpil58ya1e: /tmp/tmpil58ya1e.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n\
    \      paren_levels.push_back(paren_level);\n      paren_level++;\n    } else\
    \ if (c == ')') {\n      paren_level--;\n    }\n  }\n  assert(paren_level == 0);\n\
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpby9kpx3o: /tmp/tmpby9kpx3o.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     is_open = true;\n            level++;\n        } else if (c == ')') {\n\
    \            is_open = false;\n            level--;\n        } else if (c == '\
    \ ') {\n            if (is_open) {\n                level++;\n            }\n\
    \        } else {\n            assert(false);\n        }\n        paren_levels.push_back(level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpuajmtbcn: /tmp/tmpuajmtbcn.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpyfnvbax5: /tmp/tmpyfnvbax5.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto &c : paren_string) {\n       \
    \ if (c == '(') {\n            paren_level_count++;\n            paren_level =\
    \ paren_level + c;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level = paren_level.substr(0, paren_level.size() - 1);\n  \
    \          if (paren_level_count == 0) {\n                paren_levels.push_back(std::stoi(paren_level));\n\
    \            }\n        }\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpyfnvbax5: /tmp/tmpyfnvbax5.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long current_level = 0;\n\
    \    long max_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            current_level++;\n        } else if (c == ')') {\n     \
    \       current_level--;\n        }\n        if (current_level > max_level) {\n\
    \            result.push_back(max_level);\n            max_level = current_level;\n\
    \        } else if (current_level < max_level) {\n            result.push_back(max_level);\n\
    \            max_level = current_level;\n        }\n    }\n    if (max_level >\
    \ 0) {\n        result.push_back(max_level);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpsnyitkei: /tmp/tmpsnyitkei.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    std::vector<long> paren_levels_temp2 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp3 = paren_levels_temp;\n    std::vector<long> paren_levels_temp4\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp5 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp6 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp7 = paren_levels_temp;\n    std::vector<long> paren_levels_temp8\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp9 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp10 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp11 = paren_levels_temp;\n    std::vector<long> paren_levels_temp12\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp13 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp14 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp15 = paren_levels_temp;\n    std::vector<long> paren_levels_temp16\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp17 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp18 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp19 = paren_levels_temp;\n    std::vector<long> paren_levels_temp20\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp21 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp22 = paren_levels_temp;\n    std::vector<long>\
    \ paren_levels_temp23 = paren_levels_temp;\n    std::vector<long> paren_levels_temp24\
    \ = paren_levels_temp;\n    std::vector<long> paren_levels_temp25 = paren_levels_temp;\n\
    \    std::vector<long> paren_levels_temp26 = paren_levels_temp;\n    std::vector<long>\
    \ paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpytezkb5_.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpytezkb5_.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpytezkb5_.cpp:42:1: error: expected initializer\
    \ before \u2018}\u2019 token\n   42 | }\n      | ^\n/tmp/tmpytezkb5_.cpp:42:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpelf110ym: /tmp/tmpelf110ym.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level_string;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n            paren_level_string = std::to_string(paren_level);\n\
    \        } else if (c == ')') {\n            paren_level--;\n            paren_level_string\
    \ = std::to_string(paren_level);\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpc2sydvgs: /tmp/tmpc2sydvgs.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels_t paren_levels_t;\n\
    \    paren_levels_t.paren_levels = paren_levels;\n    paren_levels_t.paren_levels_size\
    \ = 0;\n    paren_levels_t.paren_levels_capacity = paren_levels.size();\n    paren_levels_t.paren_levels_max_size\
    \ = 0;\n    paren_levels_t.paren_levels_max_capacity = paren_levels.size();\n\
    \    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren_levels_t.paren_levels_max_capacity\
    \ = paren_levels.size();\n    paren_levels_t.paren_levels_max_size = 0;\n    paren\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvvtdtgur.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpvvtdtgur.cpp:10:5: error: \u2018paren_levels_t\u2019 was not declared\
    \ in this scope; did you mean \u2018paren_levels\u2019?\n   10 |     paren_levels_t\
    \ paren_levels_t;\n      |     ^~~~~~~~~~~~~~\n      |     paren_levels\n/tmp/tmpvvtdtgur.cpp:41:5:\
    \ error: \u2018paren\u2019 was not declared in this scope\n   41 |     paren\n\
    \      |     ^~~~~\n/tmp/tmpvvtdtgur.cpp:42:1: warning: no return statement in\
    \ function returning non-void [-Wreturn-type]\n   42 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long level = 0;\n    bool\
    \ is_open = false;\n    bool is_closed = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            level++;\n\
    \        } else if (c == ')') {\n            is_closed = true;\n            level--;\n\
    \        } else if (c == ' ') {\n            if (is_open && is_closed) {\n   \
    \             result.push_back(level);\n            }\n            is_open = false;\n\
    \            is_closed = false;\n        } else {\n            is_open = false;\n\
    \            is_closed = false;\n        }\n    }\n    if (is_open && is_closed)\
    \ {\n        result.push_back(level);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmppdv2rp4n: /tmp/tmppdv2rp4n.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long current_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpz6xf669m: /tmp/tmpz6xf669m.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113002
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string paren_level_string;\n    std::string paren_level_char;\n    long\
    \ paren_level = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n \
    \       paren_level_char = paren_string[i];\n        if (paren_level_char == '(')\
    \ {\n            paren_level++;\n            paren_level_string = std::to_string(paren_level);\n\
    \            paren_level_string = paren_level_string + paren_level_char;\n   \
    \         paren_level_string = paren_level_string + paren_level_char;\n      \
    \      paren_level_string = paren_level_string + paren_level_char;\n         \
    \   paren_level_string = paren_level_string + paren_level_char;\n            paren_level_string\
    \ = paren_level_string + paren_level_char;\n            paren_level_string = paren_level_string\
    \ + paren_level_char;\n            paren_level_string = paren_level_string + paren_level_char;\n\
    \            paren_level_string = paren_level_string + paren_level_char;\n   \
    \         paren_level_string = paren_level_string + paren_level_char;\n      \
    \      paren_level_string = paren_level_string + paren_level_char;\n         \
    \   paren_level_string = paren_level_string + paren_level_char;\n            paren_level_string\
    \ = paren_level_string + paren_level_char;\n            paren_level_string = paren_level_string\
    \ + paren_level_char;\n            paren_level_string = paren_level_string + paren_level_char;\n\
    \            paren_level_string = paren_level_string + paren_level_char;\n   \
    \         paren_level_string = paren_level_string + paren_level_char;\n      \
    \      paren_level_string = paren_level_string + paren_level_char;\n         \
    \   paren_level_string = paren_level_string + paren_level_char;\n            paren_level_string\
    \ = paren_level_string + paren_level_char;\n            paren_level_string = paren_level_string\
    \ + paren_level_char;\n            paren_level_string = paren_level_string + paren_level_char;\n\
    \            paren_level_string = paren_level_string + paren_level_char;\n   \
    \         paren_level_string = paren_level_string + paren_level_char;\n      \
    \      paren_level_string = paren_level_string + paren_level_char;\n         \
    \   paren_level_string = paren_level_string + paren_level_char;\n            \n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgecwzvg4.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpgecwzvg4.cpp:16:30: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   16 |         if (paren_level_char == '(') {\n    \
    \  |             ~~~~~~~~~~~~~~~~ ^~ ~~~\n      |             |              \
    \     |\n      |             |                   char\n      |             std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgecwzvg4.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpgecwzvg4.cpp:16:33:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   16\
    \ |         if (paren_level_char == '(') {\n      |                          \
    \       ^~~\nIn file included from /usr/include/c++/9/regex:62,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n          \
    \       from /tmp/tmpgecwzvg4.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpgecwzvg4.cpp:16:33: note:   mismatched types \u2018const "
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels.size());\n\
    \    std::vector<long> paren_levels_temp_temp;\n    paren_levels_temp_temp.push_back(paren_levels_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp;\n    paren_levels_temp_temp_temp.push_back(paren_levels_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp;\n    paren_levels_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp_temp;\n    paren_levels_temp_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp_temp_temp;\n    paren_levels_temp_temp_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp_temp_temp_temp;\n    paren_levels_temp_temp_temp_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp_temp_temp_temp;\n    paren_levels_temp_temp_temp_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp_temp_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    paren_levels_temp_temp_temp_temp_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp_temp_temp_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp.push_back(paren_levels_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp.size());\n\
    \    std::vector<long> paren_levels_temp_temp_\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp9pvtvgr4.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp9pvtvgr4.cpp:25:23: error: redeclaration of \u2018std::vector<long\
    \ int> paren_levels_temp_temp_temp_temp_temp_temp_temp\u2019\n   25 |     std::vector<long>\
    \ paren_levels_temp_temp_temp_temp_temp_temp_temp;\n      |                  \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9pvtvgr4.cpp:23:23:\
    \ note: \u2018std::vector<long int> paren_levels_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   23 |     std::vector<long> paren_levels_temp_temp_temp_temp_temp_temp_temp;\n\
    \      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9pvtvgr4.cpp:36:1: error: expected initializer before \u2018}\u2019 token\n\
    \   36 | }\n      | ^\n/tmp/tmp9pvtvgr4.cpp:36:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = {0};\n\
    \    std::string current_paren_string;\n    std::string current_paren_level;\n\
    \    for (auto &c : paren_string) {\n        if (c == '(') {\n            current_paren_string\
    \ = current_paren_level;\n            current_paren_level += c;\n        } else\
    \ if (c == ')') {\n            paren_levels.push_back(std::stoi(current_paren_level));\n\
    \            current_paren_string = \"\";\n            current_paren_level = \"\
    \";\n        } else {\n            current_paren_level += c;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n    }\n  }\n  assert(paren_levels.size() == paren_string.size());\n\
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpn085h06e: /tmp/tmpn085h06e.cpp:20: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_levels.size() == paren_string.size()'' failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    long max_level = 0;\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        if (paren_levels_temp[i] > max_level) {\n            max_level\
    \ = paren_levels_temp[i];\n        }\n    }\n    std::vector<long> paren_levels_temp2;\n\
    \    paren_levels_temp2.assign(paren_levels.begin(), paren_levels.end());\n  \
    \  for (long i = 0; i < paren_levels_temp.size(); i++) {\n        if (paren_levels_temp[i]\
    \ > max_level) {\n            paren_levels_temp2.push_back(i);\n        }\n  \
    \  }\n    std::vector<long> paren_levels_temp3;\n    paren_levels_temp3.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    for (long i = 0; i < paren_levels_temp2.size(); i++)\
    \ {\n        if (paren_levels_temp2[i] > max_level) {\n            paren_levels_temp3.push_back(paren_levels_temp2[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp4;\n    paren_levels_temp4.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    for (long i = 0; i < paren_levels_temp3.size(); i++)\
    \ {\n        if (paren_levels_temp3[i] > max_level) {\n            paren_levels_temp4.push_back(paren_levels_temp3[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp5;\n    paren_levels_temp5.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    for (long i = 0; i < paren_levels_temp4.size(); i++)\
    \ {\n        if (paren_levels_temp4[i] > max_level) {\n            paren_levels_temp5.push_back(paren_levels_temp4[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp6;\n    paren_levels_temp6.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    for (long i = 0; i < paren_levels_temp5.size(); i++)\
    \ {\n        if (paren_levels_temp5[i] > max_level) {\n            paren_levels_temp6.push_back(paren_levels_temp5[i]);\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp7;\n    paren_levels_temp7.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    for (long i = 0; i < paren_levels_temp6.size(); i++)\
    \ {\n        if (paren_levels_temp6[i] > max_level\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpz6jt1029.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpz6jt1029.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpz6jt1029.cpp:57:46: error: expected \u2018\
    )\u2019 before \u2018}\u2019 token\n   57 |         if (paren_levels_temp6[i]\
    \ > max_level\n      |            ~                                 ^\n      |\
    \                                              )\n   58 | }\n      | ~       \
    \                                      \n/tmp/tmpz6jt1029.cpp:58:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   58 | }\n      | ^\n/tmp/tmpz6jt1029.cpp:59:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   59 | int main() {\n      |            ^\n/tmp/tmpz6jt1029.cpp:64:1: error:\
    \ expected \u2018}\u2019 at end of input\n   64 | }\n      | ^\n/tmp/tmpz6jt1029.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpz6jt1029.cpp:64:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   64 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels.size());\n\
    \    long paren_levels_sum = 0;\n    for (long i = 0; i < paren_levels.size();\
    \ i++) {\n        paren_levels_sum += paren_levels[i];\n    }\n    for (long i\
    \ = 0; i < paren_levels.size(); i++) {\n        paren_levels_temp[i] = paren_levels_temp[i]\
    \ + (paren_levels_sum - paren_levels[i]);\n    }\n    return paren_levels_temp;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp41fd4hp8.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp41fd4hp8.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long current_level\
    \ = 0;\n    long paren_level = 0;\n    for (auto c : paren_string) {\n       \
    \ if (c == '(') {\n            paren_level++;\n            current_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n            current_level--;\n\
    \        }\n        if (current_level > paren_level) {\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp8wwdzokh: /tmp/tmp8wwdzokh.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113002
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(1);\n\
    \    long paren_level = 1;\n    for (auto &level : paren_levels) {\n        if\
    \ (level == \"(\") {\n            paren_levels_temp.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (level == \")\") {\n          \
    \  paren_level = paren_levels_temp.back();\n            paren_levels_temp.pop_back();\n\
    \        } else {\n            paren_level = paren_levels_temp.back();\n     \
    \       paren_levels_temp.pop_back();\n        }\n    }\n    return paren_levels_temp;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnexjr9mu.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpnexjr9mu.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpnexjr9mu.cpp:15:22: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   15 |         if (level\
    \ == \"(\") {\n      |                      ^~~\n/tmp/tmpnexjr9mu.cpp:18:29: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   18\
    \ |         } else if (level == \")\") {\n      |                            \
    \ ^~~\n"
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_levels.push_back(paren_level);\n        } else if\
    \ (c == ')') {\n            is_closed = true;\n            paren_level = paren_levels.back();\n\
    \        } else if (is_open && is_closed) {\n            paren_level++;\n    \
    \    }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmplwpawwj5: /tmp/tmplwpawwj5.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (is_open) {\n            if (c == '(') {\n                paren_level++;\n\
    \            } else if (c == ')') {\n                paren_level--;\n        \
    \    }\n        }\n        is_open = c == '(';\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpj8r7gr4i: /tmp/tmpj8r7gr4i.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_levels.pop_back();\n\
    \        } else if (is_open) {\n            paren_level++;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpqlubcbou: /tmp/tmpqlubcbou.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long max_level = 0;\n\
    \    for (auto &c : paren_string) {\n        if (c == '(') {\n            paren_levels.push_back(0);\n\
    \        } else if (c == ')') {\n            long level = paren_levels.size()\
    \ - 1;\n            if (level > max_level) {\n                max_level = level;\n\
    \            }\n            paren_levels.erase(paren_levels.begin() + level);\n\
    \        } else {\n            long level = paren_levels.size();\n           \
    \ paren_levels.push_back(level);\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpi8n9e1v0: /tmp/tmpi8n9e1v0.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113003
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    long paren_level = 0;\n    long paren_levels_temp_index\
    \ = 0;\n    long paren_levels_temp_size = 0;\n    long paren_levels_temp_capacity\
    \ = 0;\n    long paren_levels_temp_max_size = 0;\n    long paren_levels_temp_max_capacity\
    \ = 0;\n    long paren_levels_temp_max_index = 0;\n    long paren_levels_temp_max_value\
    \ = 0;\n    long paren_levels_temp_max_count = 0;\n    long paren_levels_temp_max_count_index\
    \ = 0;\n    long paren_levels_temp_max_count_value = 0;\n    long paren_levels_temp_max_count_count\
    \ = 0;\n    long paren_levels_temp_max_count_count_index = 0;\n    long paren_levels_temp_max_count_count_value\
    \ = 0;\n    long paren_levels_temp_max_count_count_count = 0;\n    long paren_levels_temp_max_count_count_count_index\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_value = 0;\n    long\
    \ paren_levels_temp_max_count_count_count_count = 0;\n    long paren_levels_temp_max_count_count_count_count_index\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_value = 0;\n  \
    \  long paren_levels_temp_max_count_count_count_count_count = 0;\n    long paren_levels_temp_max_count_count_count_count_count_index\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_value = 0;\n\
    \    long paren_levels_temp_max_count_count_count_count_count_count = 0;\n   \
    \ long paren_levels_temp_max_count_count_count_count_count_count_index = 0;\n\
    \    long paren_levels_temp_max_count_count_count_count_count_count_value = 0;\n\
    \    long paren_levels_temp_max_count_count_count_count_count_count_count_count\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_count_count_index\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_count_count_value\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_count_count_count\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_count_count_index\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_count_count_value\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_count_count_count_count\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_count_count_count_index\
    \ = 0;\n    long paren_levels_temp_max_count_count_count_count_count_count_count_count_value\
    \ = 0;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfy06hv6k.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpfy06hv6k.cpp:40:10: error: redeclaration of \u2018long int paren_levels_temp_max_count_count_count_count_count_count_count_count\u2019\
    \n   40 |     long paren_levels_temp_max_count_count_count_count_count_count_count_count\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfy06hv6k.cpp:37:10: note: \u2018long int paren_levels_temp_max_count_count_count_count_count_count_count_count\u2019\
    \ previously declared here\n   37 |     long paren_levels_temp_max_count_count_count_count_count_count_count_count\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfy06hv6k.cpp:41:10: error: redeclaration of \u2018long int paren_levels_temp_max_count_count_count_count_count_count_count_index\u2019\
    \n   41 |     long paren_levels_temp_max_count_count_count_count_count_count_count_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfy06hv6k.cpp:38:10: note: \u2018long int paren_levels_temp_max_count_count_count_count_count_count_count_index\u2019\
    \ previously declared here\n   38 |     long paren_levels_temp_max_count_count_count_count_count_count_count_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfy06hv6k.cpp:42:10: error: redeclaration of \u2018long int paren_levels_temp_max_count_count_count_count_count_count_count_value\u2019\
    \n   42 |     long paren_levels_temp_max_count_count_count_count_count_count_count_value\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfy06hv6k.cpp:39:10: note: \u2018long int paren_levels_temp_max_count_count_count_count_count_count_count_value\u2019\
    \ previously declared here\n   39 |     long paren_levels_temp_max_count_count_count_count_count_count_count_value\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfy06hv6k.cpp:46:1: warning:"
  stdout: ''
  timestamp: 1660113003
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\" \");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(paren_levels.size());\n    long paren_levels_size\
    \ = paren_levels.size();\n    long paren_levels_index = 0;\n    long paren_levels_index_temp\
    \ = 0;\n    long paren_levels_index_temp2 = 0;\n    long paren_levels_index_temp3\
    \ = 0;\n    long paren_levels_index_temp4 = 0;\n    long paren_levels_index_temp5\
    \ = 0;\n    long paren_levels_index_temp6 = 0;\n    long paren_levels_index_temp7\
    \ = 0;\n    long paren_levels_index_temp8 = 0;\n    long paren_levels_index_temp9\
    \ = 0;\n    long paren_levels_index_temp10 = 0;\n    long paren_levels_index_temp11\
    \ = 0;\n    long paren_levels_index_temp12 = 0;\n    long paren_levels_index_temp13\
    \ = 0;\n    long paren_levels_index_temp14 = 0;\n    long paren_levels_index_temp15\
    \ = 0;\n    long paren_levels_index_temp16 = 0;\n    long paren_levels_index_temp17\
    \ = 0;\n    long paren_levels_index_temp18 = 0;\n    long paren_levels_index_temp19\
    \ = 0;\n    long paren_levels_index_temp20 = 0;\n    long paren_levels_index_temp21\
    \ = 0;\n    long paren_levels_index_temp22 = 0;\n    long paren_levels_index_temp23\
    \ = 0;\n    long paren_levels_index_temp24 = 0;\n    long paren_levels_index_temp25\
    \ = 0;\n    long paren_levels_index_temp26 = 0;\n    long paren_levels_index_temp27\
    \ = 0;\n    long paren_levels_index_temp28 = 0;\n    long paren_levels_index_temp29\
    \ = 0;\n    long paren_levels_index_temp30 = 0;\n    long paren_levels_index_temp31\
    \ = 0;\n    long paren_levels_index_temp32 = 0;\n    long paren_levels_index_temp33\
    \ = 0;\n    long paren_levels_index_temp34 = 0;\n    long paren_levels_index_temp35\
    \ = 0;\n    long paren_levels_index_temp36 = 0;\n    long paren_levels_index_temp37\
    \ = 0;\n    long paren_levels_index_temp38 = 0;\n    long paren_levels_index_temp39\
    \ = 0;\n    long paren_levels_index_temp40\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpnn2t2e7e.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpnn2t2e7e.cpp:10:77: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\" \");\n      |                 \
    \                                                            ^~~~~\n/tmp/tmpnn2t2e7e.cpp:55:1:\
    \ error: expected initializer before \u2018}\u2019 token\n   55 | }\n      | ^\n\
    /tmp/tmpnn2t2e7e.cpp:55:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113003
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_copy;\n    paren_levels_copy.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        paren_levels_copy.push_back(level);\n\
    \    }\n    long max_level = 0;\n    for (auto &level : paren_levels_copy) {\n\
    \        if (level > max_level) {\n            max_level = level;\n        }\n\
    \    }\n    std::vector<long> max_level_paren_levels;\n    max_level_paren_levels.reserve(max_level\
    \ + 1);\n    for (auto &level : paren_levels_copy) {\n        if (level == max_level)\
    \ {\n            max_level_paren_levels.push_back(level);\n        }\n    }\n\
    \    return max_level_paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa1jo1ezb.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpa1jo1ezb.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660113003
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(1);\n\
    \    long paren_level = 1;\n    long paren_levels_sum = 0;\n    long paren_levels_max\
    \ = 0;\n    long paren_levels_max_index = 0;\n    for (long i = 0; i < paren_levels.size();\
    \ i++) {\n        if (paren_levels[i] != \"()\") {\n            paren_levels_temp.push_back(paren_level);\n\
    \            paren_levels_sum += paren_level;\n            if (paren_levels_sum\
    \ > paren_levels_max) {\n                paren_levels_max = paren_levels_sum;\n\
    \                paren_levels_max_index = i;\n            }\n            paren_levels_temp.push_back(1);\n\
    \            paren_levels_sum = 0;\n            paren_level++;\n        } else\
    \ {\n            paren_levels_temp.push_back(paren_level);\n            paren_levels_sum\
    \ += paren_level;\n            paren_levels_temp.push_back(1);\n            paren_levels_sum\
    \ = 0;\n            paren_level++;\n        }\n    }\n    paren_levels_temp.push_back(paren_level);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n  \
    \  paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n    paren_levels_temp.push_back(1);\n\
    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg3wkgtey.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpg3wkgtey.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpg3wkgtey.cpp:18:32: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   18 |         if (paren_levels[i]\
    \ != \"()\") {\n      |                                ^~~~\n/tmp/tmpg3wkgtey.cpp:68:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   68 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_level++;\n\
    \        } else if (paren_string[i] == ')') {\n            paren_level--;\n  \
    \      }\n        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmply55bdjw: /tmp/tmply55bdjw.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp4laxqzzj: /tmp/tmp4laxqzzj.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n      assert(level >= 0);\n      paren_levels.push_back(level);\n\
    \    }\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpo22p7645: /tmp/tmpo22p7645.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    size_t paren_start_index = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            paren_level++;\n            paren_start_index = i;\n        }\
    \ else if (paren_string[i] == ')') {\n            paren_level--;\n           \
    \ paren_levels[paren_level] = paren_start_index;\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp_x_e456b: /tmp/tmp_x_e456b.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_levels.push_back(level);\n\
    \        } else if (c == ')') {\n            is_open = false;\n            level--;\n\
    \        } else if (is_open) {\n            level++;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpm_snuvue: /tmp/tmpm_snuvue.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_level--;\n\
    \        } else if (is_open) {\n            paren_levels.push_back(paren_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmphw4ay0hl: /tmp/tmphw4ay0hl.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (size_t i = 0;\
    \ i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n   \
    \         is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (paren_string[i] == ')') {\n            is_open = false;\n\
    \            paren_levels.pop_back();\n        } else if (is_open) {\n       \
    \     paren_level++;\n        }\n    }\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpg_2jw0k_: /tmp/tmpg_2jw0k_.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_level++;\n\
    \        } else if (paren_string[i] == ')') {\n            paren_level--;\n  \
    \      }\n        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmply55bdjw: /tmp/tmply55bdjw.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n    }\n  }\n  assert(paren_levels.back() == 0);\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmppmp6lhr5: /tmp/tmppmp6lhr5.cpp:20: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_levels.back() == 0'' failed.

    '
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpoi57am02: /tmp/tmpoi57am02.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    long paren_level = 0;\n    bool is_open = false;\n \
    \   for (char c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level = level;\n        } else if (c == ')') {\n\
    \            is_open = false;\n            paren_levels.push_back(paren_level);\n\
    \            level--;\n        } else if (is_open) {\n            level++;\n \
    \       }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp3uq913_v: /tmp/tmp3uq913_v.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = {0};\n\
    \  std::string paren_level_string;\n  std::string paren_level_char;\n  long paren_level\
    \ = 0;\n  for (size_t i = 0; i < paren_string.size(); i++) {\n    paren_level_char\
    \ = paren_string[i];\n    if (paren_level_char == '(') {\n      paren_level++;\n\
    \      paren_level_string = std::to_string(paren_level);\n      paren_level_string.push_back('(');\n\
    \      paren_level_string.push_back(')');\n      paren_level_string.push_back('\
    \ ');\n      paren_level_string.push_back('(');\n      paren_level_string.push_back(')');\n\
    \      paren_level_string.push_back(' ');\n      paren_level_string.push_back('(');\n\
    \      paren_level_string.push_back(')');\n      paren_level_string.push_back('\
    \ ');\n      paren_level_string.push_back('(');\n      paren_level_string.push_back(')');\n\
    \      paren_level_string.push_back(' ');\n      paren_level_string.push_back('(');\n\
    \      paren_level_string.push_back(')');\n      paren_level_string.push_back('\
    \ ');\n      paren_level_string.push_back('(');\n      paren_level_string.push_back(')');\n\
    \      paren_level_string.push_back(' ');\n      paren_level_string.push_back('(');\n\
    \      paren_level_string.push_back(')');\n      paren_level_string.push_back('\
    \ ');\n      paren_level_string.push_back('(');\n      paren_level_string.push_back(')');\n\
    \      paren_level_string.push_back(' ');\n      paren_level_string.push_back('(');\n\
    \      paren_level_string.push_back(')');\n      paren_level_string.push_back('\
    \ ');\n      paren_level_string.push_back('(');\n      paren_level_string.push_back(')');\n\
    \      paren_level_string.push_back(' ');\n      paren_level_string.push_back('(');\n\
    \      paren_level_string.push_back(')');\n      paren_level_string.push_back('\
    \ ');\n      paren_level_string.push_back('(');\n      paren_level_string.push_back(')');\n\
    \      paren_level_string.push_back(' ');\n      paren_level_string.push_back('(');\n\
    \      paren_level_string.push_back(')');\n      paren_level_string.push_back('\
    \ '\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkhmke4aw.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpkhmke4aw.cpp:16:26: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   16 |     if (paren_level_char == '(') {\n      | \
    \        ~~~~~~~~~~~~~~~~ ^~ ~~~\n      |         |                   |\n    \
    \  |         |                   char\n      |         std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpkhmke4aw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpkhmke4aw.cpp:16:29:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   16\
    \ |     if (paren_level_char == '(') {\n      |                             ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpkhmke4aw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpkhmke4aw.cpp:16:29: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiI"
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long current_level\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   current_level++;\n        } else if (c == ')') {\n            current_level--;\n\
    \        }\n        paren_levels.push_back(current_level);\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp3k0p6po3: /tmp/tmp3k0p6po3.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::string curr_paren_string\
    \ = paren_string;\n    long curr_level = 0;\n    long max_level = 0;\n    bool\
    \ is_open = false;\n    while (curr_paren_string.size() > 0) {\n        char curr_char\
    \ = curr_paren_string[0];\n        curr_paren_string = curr_paren_string.substr(1);\n\
    \        curr_level++;\n        if (curr_char == '(') {\n            is_open =\
    \ true;\n        } else if (curr_char == ')') {\n            is_open = false;\n\
    \        } else if (curr_char == ' ') {\n            if (is_open) {\n        \
    \        result.push_back(curr_level);\n                curr_level = 0;\n    \
    \        }\n        } else {\n            assert(false);\n        }\n        if\
    \ (curr_level > max_level) {\n            max_level = curr_level;\n        }\n\
    \    }\n    if (max_level > 0) {\n        result.push_back(max_level);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp1e8yenci: /tmp/tmp1e8yenci.cpp:41: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(level);\n            level++;\n        }\n  \
    \  }\n    paren_levels.push_back(level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpzpwzc7qx: /tmp/tmpzpwzc7qx.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    long level = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            paren_level = paren_string.substr(i,\
    \ 1);\n            level++;\n        } else if (paren_string[i] == ')') {\n  \
    \          level--;\n            if (level == 0) {\n                levels.push_back(level);\n\
    \            }\n        }\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp4g2_i0xn: /tmp/tmp4g2_i0xn.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long level = 0;\n    bool\
    \ is_open = false;\n    for (auto c : paren_string) {\n        if (c == '(') {\n\
    \            is_open = true;\n            level++;\n        } else if (c == ')')\
    \ {\n            is_open = false;\n            level--;\n        } else if (is_open)\
    \ {\n            level++;\n        }\n        result.push_back(level);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpf9rze6jl: /tmp/tmpf9rze6jl.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    long paren_level_count = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level = std::to_string(paren_level_count);\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n            paren_level =\
    \ std::to_string(paren_level_count);\n        } else if (c == ' ') {\n       \
    \     paren_level += c;\n        } else {\n            paren_level += c;\n   \
    \     }\n        paren_levels.push_back(std::stoi(paren_level));\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpi65o3_1w: /tmp/tmpi65o3_1w.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp6ziiba6o: /tmp/tmp6ziiba6o.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (char c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n            assert(level >= 0);\n\
    \            paren_levels.push_back(level);\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp_tvwdrtd: /tmp/tmp_tvwdrtd.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string curr_paren =\
    \ paren_string;\n    long level = 0;\n    while (curr_paren != \"\") {\n     \
    \   if (curr_paren[0] == '(') {\n            level++;\n        } else if (curr_paren[0]\
    \ == ')') {\n            level--;\n        }\n        curr_paren = curr_paren.substr(1);\n\
    \        levels.push_back(level);\n    }\n    return levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmporpdn7af: /tmp/tmporpdn7af.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpri59p0fd.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpri59p0fd.cpp:68:1: error: expected initializer before \u2018}\u2019\
    \ token\n   68 | }\n      | ^\n/tmp/tmpri59p0fd.cpp:68:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113003
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        long paren_level = 0;\n     \
    \   for (auto &char : level) {\n            if (char == '(') paren_level++;\n\
    \            if (char == ')') paren_level--;\n        }\n        paren_levels_temp.push_back(paren_level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reversed;\n    paren_levels_temp_reversed.reserve(paren_levels_temp.size());\n\
    \    for (auto &level : paren_levels_temp) {\n        long paren_level_reversed\
    \ = 0;\n        for (auto &char : level) {\n            if (char == '(') paren_level_reversed++;\n\
    \            if (char == ')') paren_level_reversed--;\n        }\n        paren_levels_temp_reversed.push_back(paren_level_reversed);\n\
    \    }\n    std::vector<long> paren_levels_temp_reversed_temp;\n    paren_levels_temp_reversed_temp.reserve(paren_levels_temp_reversed.size());\n\
    \    for (auto &level : paren_levels_temp_reversed) {\n        long paren_level_reversed_temp\
    \ = 0;\n        for (auto &char : level) {\n            if (char == '(') paren_level_reversed_temp++;\n\
    \            if (char == ')') paren_level_reversed_temp--;\n        }\n      \
    \  paren_levels_temp_reversed_temp.push_back(paren_level_reversed_temp);\n   \
    \ }\n    std::vector<long> paren_levels_temp_reversed_temp_temp;\n    paren_levels_temp_reversed_temp_temp.reserve(paren_levels_temp_reversed_temp.size());\n\
    \    for (auto &level : paren_levels_temp_reversed_temp) {\n        long paren_level_reversed_temp_temp\
    \ = 0;\n        for (auto &char : level) {\n            if (char == '(') paren_level_reversed_temp_temp++;\n\
    \            if (char == ')') paren_level_reversed_temp_temp--;\n        }\n \
    \       paren_levels_temp_reversed_temp_temp.push_back(paren_level_reversed_temp_temp);\n\
    \    }\n    std::vector<long> paren_levels_temp_reversed_temp_temp_temp;\n   \
    \ paren_levels_temp_reversed_temp_temp_temp.reserve(paren_levels_temp\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjqdq6ri2.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpjqdq6ri2.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpjqdq6ri2.cpp:15:20: error: expected unqualified-id\
    \ before \u2018char\u2019\n   15 |         for (auto &char : level) {\n      |\
    \                    ^~~~\n/tmp/tmpjqdq6ri2.cpp:15:20: error: expected \u2018\
    ;\u2019 before \u2018char\u2019\n   15 |         for (auto &char : level) {\n\
    \      |                    ^~~~\n      |                    ;\n/tmp/tmpjqdq6ri2.cpp:15:25:\
    \ error: expected unqualified-id before \u2018:\u2019 token\n   15 |         for\
    \ (auto &char : level) {\n      |                         ^\n/tmp/tmpjqdq6ri2.cpp:15:32:\
    \ error: expected \u2018;\u2019 before \u2018)\u2019 token\n   15 |         for\
    \ (auto &char : level) {\n      |                                ^\n      |  \
    \                              ;\n/tmp/tmpjqdq6ri2.cpp:16:22: error: expected\
    \ unqualified-id before \u2018==\u2019 token\n   16 |             if (char ==\
    \ '(') paren_level++;\n      |                      ^~\n/tmp/tmpjqdq6ri2.cpp:17:22:\
    \ error: expected unqualified-id before \u2018==\u2019 token\n   17 |        \
    \     if (char == ')') paren_level--;\n      |                      ^~\n/tmp/tmpjqdq6ri2.cpp:25:20:\
    \ error: expected unqualified-id before \u2018char\u2019\n   25 |         for\
    \ (auto &char : level) {\n      |                    ^~~~\n/tmp/tmpjqdq6ri2.cpp:25:20:\
    \ error: expected \u2018;\u2019 before \u2018char\u2019\n   25 |         for (auto\
    \ &char : level) {\n      |                    ^~~~\n      |                 \
    \   ;\n/tmp/tmpjqdq6ri2.cpp:25:25: error: expected unqualified-id before \u2018\
    :\u2019 token\n   25 |         for (auto &char : level) {\n      |           \
    \              ^\n/tmp/tmpjqdq6ri2.cpp:25:32: error: expected \u2018;\u2019 before\
    \ \u2018)\u2019 token\n   25 |         for (auto &char : level) {\n      |   \
    \                             ^\n      |                                ;\n/tmp/tmpjqdq6ri2.cpp:26:22"
  stdout: ''
  timestamp: 1660113003
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    std::vector<long> paren_levels_temp_temp;\n    std::vector<long>\
    \ paren_levels_temp_temp_temp;\n    std::vector<long> paren_levels_temp_temp_temp_temp;\n\
    \    long paren_levels_temp_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp = 0;\n    long paren_levels_temp = 0;\n\
    \    long paren_levels = 0;\n    long paren_levels_temp_temp = 0;\n    long paren_levels_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp = 0;\n    long paren_levels_temp = 0;\n\
    \    long paren_levels_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp = 0;\n    long paren_levels_temp_temp\
    \ = 0;\n    long paren_levels_temp = 0;\n    long paren_levels_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp = 0;\n    long paren_levels_temp = 0;\n\
    \    long paren_levels_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp = 0;\n    long paren_levels_temp_temp\
    \ = 0;\n    long paren_levels_temp = 0;\n    long paren_levels_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp_temp_temp = 0;\n    long paren_levels_temp_temp_temp\
    \ = 0;\n    long paren_levels_temp_temp = 0;\n    long paren_levels_temp = 0;\n\
    \    long paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2_3_owd5.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp2_3_owd5.cpp:15:10: error: conflicting declaration \u2018long int paren_levels_temp_temp_temp\u2019\
    \n   15 |     long paren_levels_temp_temp_temp = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2_3_owd5.cpp:12:23: note: previous declaration as \u2018std::vector<long\
    \ int> paren_levels_temp_temp_temp\u2019\n   12 |     std::vector<long> paren_levels_temp_temp_temp;\n\
    \      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2_3_owd5.cpp:16:10:\
    \ error: conflicting declaration \u2018long int paren_levels_temp_temp\u2019\n\
    \   16 |     long paren_levels_temp_temp = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2_3_owd5.cpp:11:23: note: previous declaration as \u2018std::vector<long\
    \ int> paren_levels_temp_temp\u2019\n   11 |     std::vector<long> paren_levels_temp_temp;\n\
    \      |                       ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2_3_owd5.cpp:17:10:\
    \ error: conflicting declaration \u2018long int paren_levels_temp\u2019\n   17\
    \ |     long paren_levels_temp = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmp2_3_owd5.cpp:10:23:\
    \ note: previous declaration as \u2018std::vector<long int> paren_levels_temp\u2019\
    \n   10 |     std::vector<long> paren_levels_temp;\n      |                  \
    \     ^~~~~~~~~~~~~~~~~\n/tmp/tmp2_3_owd5.cpp:18:10: error: conflicting declaration\
    \ \u2018long int paren_levels\u2019\n   18 |     long paren_levels = 0;\n    \
    \  |          ^~~~~~~~~~~~\n/tmp/tmp2_3_owd5.cpp:9:23: note: previous declaration\
    \ as \u2018std::vector<long int> paren_levels\u2019\n    9 |     std::vector<long>\
    \ paren_levels;\n      |                       ^~~~~~~~~~~~\n/tmp/tmp2_3_owd5.cpp:19:10:\
    \ error: conflicting declaration \u2018long int paren_levels_temp_temp\u2019\n\
    \   19 |     long paren_levels_temp_temp = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2_3_owd5.cpp:11:23: note: previous declaration as \u2018std::vector<long\
    \ int> paren_levels_temp_temp\u2019\n   11 |     std::vector<long> paren_levels_temp_temp;\n\
    \      |                       ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2_3_owd5.cpp:20"
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long max_level = 0;\n  \
    \  long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n \
    \   std::string current_paren = \"\";\n    std::string current_group = \"\";\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            current_paren = c;\n        } else if (c == ')') {\n  \
    \          is_closed = true;\n            current_paren = c;\n        } else if\
    \ (is_open && is_closed) {\n            current_group = current_paren + c;\n \
    \           result.push_back(level);\n            current_paren = \"\";\n    \
    \        level++;\n        } else if (is_open) {\n            current_group =\
    \ current_paren + c;\n        } else if (is_closed) {\n            current_group\
    \ = current_paren + c;\n            result.push_back(level);\n            current_paren\
    \ = \"\";\n            level--;\n        }\n    }\n    if (current_paren != \"\
    \") {\n        result.push_back(level);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpr67no2iq: /tmp/tmpr67no2iq.cpp:44: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ 0 && paren_levels.size() <= level) {\n            paren_levels.resize(level\
    \ + 1, 0);\n        }\n        paren_levels[level] += 1;\n        level++;\n \
    \   }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpzy9w8t21: /tmp/tmpzy9w8t21.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        paren_levels_temp.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse;\n    paren_levels_temp_reverse.reserve(paren_levels_temp.size());\n\
    \    for (auto &level : paren_levels_temp) {\n        paren_levels_temp_reverse.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_reverse;\n    paren_levels_temp_reverse_reverse.reserve(paren_levels_temp_reverse.size());\n\
    \    for (auto &level : paren_levels_temp_reverse) {\n        paren_levels_temp_reverse_reverse.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_reverse_reverse;\n   \
    \ paren_levels_temp_reverse_reverse_reverse.reserve(paren_levels_temp_reverse_reverse.size());\n\
    \    for (auto &level : paren_levels_temp_reverse_reverse) {\n        paren_levels_temp_reverse_reverse_reverse.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_reverse_reverse_reverse;\n\
    \    paren_levels_temp_reverse_reverse_reverse_reverse.reserve(paren_levels_temp_reverse_reverse_reverse.size());\n\
    \    for (auto &level : paren_levels_temp_reverse_reverse_reverse) {\n       \
    \ paren_levels_temp_reverse_reverse_reverse_reverse.push_back(level);\n    }\n\
    \    std::vector<long> paren_levels_temp_reverse_reverse_reverse_reverse_reverse;\n\
    \    paren_levels_temp_reverse_reverse_reverse_reverse_reverse.reserve(paren_levels_temp_reverse_reverse_reverse_reverse.size());\n\
    \    for (auto &level : paren_levels_temp_reverse_reverse_reverse_reverse) {\n\
    \        paren_levels_temp_reverse_reverse_reverse_reverse.push_back(level);\n\
    \    }\n    std::vector<long> paren_levels_temp_reverse_reverse_reverse_reverse_reverse;\n\
    \    paren_levels_temp_reverse_reverse_reverse_reverse_reverse.reserve(paren_levels_temp_reverse_reverse_re\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptit4sbhp.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmptit4sbhp.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmptit4sbhp.cpp:41:23: error: redeclaration of\
    \ \u2018std::vector<long int> paren_levels_temp_reverse_reverse_reverse_reverse_reverse\u2019\
    \n   41 |     std::vector<long> paren_levels_temp_reverse_reverse_reverse_reverse_reverse;\n\
    \      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptit4sbhp.cpp:36:23: note: \u2018std::vector<long int> paren_levels_temp_reverse_reverse_reverse_reverse_reverse\u2019\
    \ previously declared here\n   36 |     std::vector<long> paren_levels_temp_reverse_reverse_reverse_reverse_reverse;\n\
    \      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptit4sbhp.cpp:42:71: error: \u2018paren_levels_temp_reverse_reverse_re\u2019\
    \ was not declared in this scope; did you mean \u2018paren_levels_temp_reverse_reverse\u2019\
    ?\n   42 |     paren_levels_temp_reverse_reverse_reverse_reverse_reverse.reserve(paren_levels_temp_reverse_reverse_re\n\
    \      |                                                                     \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                             \
    \                                          paren_levels_temp_reverse_reverse\n\
    /tmp/tmptit4sbhp.cpp:43:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   43 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n\
    \      paren_levels.push_back(paren_level);\n      paren_level++;\n    } else\
    \ if (c == ')') {\n      paren_level--;\n    }\n  }\n  paren_levels.push_back(paren_level);\n\
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpebdjs8rj: /tmp/tmpebdjs8rj.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_paren_or_closed = false;\n    bool is_closing_paren_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_open = false;\n    bool is_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_closed_or_opening_paren = false;\n    bool is_closing_paren_or_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_opening_paren_or_closed_or_opening_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open = false;\n\
    \    bool is_opening_paren_or_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmsxfdr4a.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpmsxfdr4a.cpp:25:10: error: redeclaration of \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \n   25 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmsxfdr4a.cpp:24:10: note: \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \ previously declared here\n   24 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmsxfdr4a.cpp:26:10: error: redeclaration of \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \n   26 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmsxfdr4a.cpp:24:10: note: \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \ previously declared here\n   24 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmsxfdr4a.cpp:27:10: error: redeclaration of \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \n   27 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmsxfdr4a.cpp:24:10: note: \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \ previously declared here\n   24 |     bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmsxfdr4a.cpp:28:10: error: redeclaration of \u2018bool is_opening_paren_or_closed_or_opening_paren_or_closed_or_open\u2019\
    \n   28 |     bool is_opening_paren_or_closed_or_opening"
  stdout: ''
  timestamp: 1660113003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    long paren_level = 0;\n    long paren_levels_temp_len\
    \ = 0;\n    long paren_level_temp = 0;\n    long paren_level_temp_len = 0;\n \
    \   long paren_level_temp2 = 0;\n    long paren_level_temp_len2 = 0;\n    long\
    \ paren_level_temp3 = 0;\n    long paren_level_temp_len3 = 0;\n    long paren_level_temp4\
    \ = 0;\n    long paren_level_temp_len4 = 0;\n    long paren_level_temp5 = 0;\n\
    \    long paren_level_temp_len5 = 0;\n    long paren_level_temp6 = 0;\n    long\
    \ paren_level_temp_len6 = 0;\n    long paren_level_temp7 = 0;\n    long paren_level_temp_len7\
    \ = 0;\n    long paren_level_temp8 = 0;\n    long paren_level_temp_len8 = 0;\n\
    \    long paren_level_temp9 = 0;\n    long paren_level_temp_len9 = 0;\n    long\
    \ paren_level_temp10 = 0;\n    long paren_level_temp_len10 = 0;\n    long paren_level_temp11\
    \ = 0;\n    long paren_level_temp_len11 = 0;\n    long paren_level_temp12 = 0;\n\
    \    long paren_level_temp_len12 = 0;\n    long paren_level_temp13 = 0;\n    long\
    \ paren_level_temp_len13 = 0;\n    long paren_level_temp14 = 0;\n    long paren_level_temp_len14\
    \ = 0;\n    long paren_level_temp15 = 0;\n    long paren_level_temp_len15 = 0;\n\
    \    long paren_level_temp16 = 0;\n    long paren_level_temp_len16 = 0;\n    long\
    \ paren_level_temp17 = 0;\n    long paren_level_temp_len17 = 0;\n    long paren_level_temp18\
    \ = 0;\n    long paren_level_temp_len18 = 0;\n    long paren_level_temp19 = 0;\n\
    \    long paren_level_temp_len19 = 0;\n    long paren_level_temp20 = 0;\n    long\
    \ paren_level_temp_len20 = 0;\n    long paren_level_temp21 = 0;\n    long paren_level_temp_len21\
    \ = 0;\n    long paren_level_temp22 = 0;\n    long paren_level_temp_len22 = 0;\n\
    \    long paren_level_temp23 = 0;\n    long paren_level_temp_len23 = 0;\n    long\
    \ paren_level_temp24 = 0;\n    long paren_level_temp_len24 = 0;\n    long paren_level_temp25\
    \ = 0;\n    long paren_level_temp_len25 = 0;\n    long paren_level_temp26 = 0;\n\
    \    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp8yr5yghl: /tmp/tmp8yr5yghl.cpp:68: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long paren_level = 0;\n  long paren_level_count = 0;\n  for (char c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_level_count++;\n    } else if (c == ')')\
    \ {\n      paren_level_count--;\n      if (paren_level_count == 0) {\n       \
    \ paren_levels.push_back(paren_level);\n        paren_level_count = 0;\n     \
    \ }\n    }\n    paren_level++;\n  }\n  return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp3031yd6m: /tmp/tmp3031yd6m.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            paren_level\
    \ = c;\n        } else if (c == ')') {\n            is_open = false;\n       \
    \     level++;\n            levels[level] = level;\n        } else if (is_open)\
    \ {\n            level++;\n            levels[level] = level;\n        }\n   \
    \ }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  std::string current_paren_string = paren_string;\n  long current_paren_level\
    \ = 0;\n  for (size_t i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i]\
    \ == '(') {\n      current_paren_level++;\n    } else if (paren_string[i] == ')')\
    \ {\n      current_paren_level--;\n    }\n    paren_levels.push_back(current_paren_level);\n\
    \    current_paren_string = paren_string.substr(0, i) + current_paren_string.substr(i\
    \ + 1);\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 15) > this->size() (which is 13)\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (paren_string[i] == ')') {\n  \
    \          paren_level--;\n        }\n    }\n    paren_levels.push_back(paren_level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp6oymiai9: /tmp/tmp6oymiai9.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp4laxqzzj: /tmp/tmp4laxqzzj.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    long paren_level_count = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            paren_level_count++;\n            paren_level = paren_levels[paren_level_count];\n\
    \            paren_levels.push_back(paren_level_count);\n        } else if (paren_string[i]\
    \ == ')') {\n            paren_level_count--;\n            paren_level = paren_levels[paren_level_count];\n\
    \            paren_levels.push_back(paren_level_count);\n        } else {\n  \
    \          paren_level += paren_string[i];\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpx_c49jhz: /tmp/tmpx_c49jhz.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level_count++;\n            paren_level = std::to_string(paren_level_count);\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  paren_level = std::to_string(paren_level_count);\n        } else {\n      \
    \      paren_level += c;\n        }\n        if (paren_level_count == 0) {\n \
    \           paren_level_count++;\n            paren_level_count--;\n         \
    \   paren_level += std::to_string(paren_level_count);\n            paren_levels.push_back(std::stoi(paren_level));\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwj9kgiyn: /tmp/tmpwj9kgiyn.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    size_t paren_level = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_levels.push_back(paren_level);\n\
    \        } else if (paren_string[i] == ')') {\n            paren_level--;\n  \
    \      }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp2455o5m4: /tmp/tmp2455o5m4.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113005
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level;\n\
    \    long paren_level_count = 0;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level_count++;\n            paren_level = paren_level_count;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  paren_level = paren_level_count;\n        }\n        paren_levels[paren_level_count]\
    \ = paren_level;\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmprypphzer.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmprypphzer.cpp:20:43: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019} in assignment\n\
    \   20 |         paren_levels[paren_level_count] = paren_level;\n      |     \
    \                                      ^~~~~~~~~~~\n      |                  \
    \                         |\n      |                                         \
    \  std::string {aka std::__cxx11::basic_string<char>}\n"
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string paren_level;\n    for (auto &c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_level = paren_level + c;\n        } else if\
    \ (c == ')') {\n            paren_level = paren_level.substr(0, paren_level.size()\
    \ - 1);\n            paren_levels.push_back(std::stoi(paren_level));\n       \
    \     paren_level = c;\n        } else {\n            paren_level = paren_level\
    \ + c;\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string curr_paren_level = \"\";\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            curr_paren_level\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    paren_levels.push_back(std::stoi(curr_paren_level));\n            curr_paren_level\
    \ = \"\";\n        } else {\n            curr_paren_level += paren_string[i];\n\
    \        }\n    }\n    paren_levels.push_back(std::stoi(curr_paren_level));\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp4laxqzzj: /tmp/tmp4laxqzzj.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels[0]);\n\
    \    long paren_level = 1;\n    for (long i = 1; i < paren_levels.size(); i++)\
    \ {\n        if (paren_levels[i-1] != paren_levels[i]) {\n            paren_levels_temp.push_back(paren_level);\n\
    \            paren_level = paren_levels[i-1];\n        }\n    }\n    paren_levels_temp.push_back(paren_level);\n\
    \    return paren_levels_temp;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_nh5g_xd.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp_nh5g_xd.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660113004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpoi57am02: /tmp/tmpoi57am02.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = paren_string.substr(0,\
    \ paren_string.find(' ')).split(' ');\n  std::vector<long> paren_levels_temp;\n\
    \  paren_levels_temp.reserve(paren_levels.size());\n  for (long i = 0; i < paren_levels.size();\
    \ i++) {\n    paren_levels_temp.push_back(paren_levels[i]);\n  }\n  long max_level\
    \ = 0;\n  for (long i = 0; i < paren_levels_temp.size(); i++) {\n    if (paren_levels_temp[i]\
    \ > max_level) {\n      max_level = paren_levels_temp[i];\n    }\n  }\n  std::vector<long>\
    \ paren_levels_temp2;\n  paren_levels_temp2.reserve(max_level + 1);\n  for (long\
    \ i = 0; i < paren_levels_temp.size(); i++) {\n    if (paren_levels_temp[i] >\
    \ max_level) {\n      paren_levels_temp2.push_back(max_level);\n    } else {\n\
    \      paren_levels_temp2.push_back(paren_levels_temp[i]);\n    }\n  }\n  paren_levels_temp2.push_back(max_level);\n\
    \  return paren_levels_temp2;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5e6l5jwl.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp5e6l5jwl.cpp:10:65: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(0,\
    \ paren_string.find(' ')).split(' ');\n      |                               \
    \                                  ^~~~~\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    long paren_level = 0;\n    bool is_open = false;\n \
    \   for (char c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level = level;\n        }\n        else if (c ==\
    \ ')') {\n            is_open = false;\n            paren_levels[paren_level]\
    \ = paren_levels[paren_level] + 1;\n        }\n        else if (is_open) {\n \
    \           level = level + 1;\n        }\n    }\n    return paren_levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp9j3l4znm: /tmp/tmp9j3l4znm.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113005
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(1);\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        long paren_level\
    \ = paren_levels[i];\n        long paren_levels_sum = 0;\n        for (long j\
    \ = 0; j < paren_level; j++) {\n            paren_levels_sum += paren_levels_temp[j];\n\
    \        }\n        paren_levels_temp.push_back(paren_levels_sum);\n    }\n  \
    \  return paren_levels_temp;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyz5ha4v2.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpyz5ha4v2.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvzctdgob: /tmp/tmpvzctdgob.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    long paren_levels_sum = 0;\n    for (long i = 0; i\
    \ < paren_levels_temp.size(); i++) {\n        paren_levels_sum += paren_levels_temp[i];\n\
    \    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.assign(paren_levels.begin(),\
    \ paren_levels.end());\n    long paren_levels_sum2 = 0;\n    for (long i = 0;\
    \ i < paren_levels_temp2.size(); i++) {\n        paren_levels_sum2 += paren_levels_temp2[i];\n\
    \    }\n    long paren_levels_sum3 = paren_levels_sum2 - paren_levels_sum;\n \
    \   long paren_levels_sum4 = paren_levels_sum3 - paren_levels_sum2;\n    long\
    \ paren_levels_sum5 = paren_levels_sum4 - paren_levels_sum3;\n    long paren_levels_sum6\
    \ = paren_levels_sum5 - paren_levels_sum4;\n    long paren_levels_sum7 = paren_levels_sum6\
    \ - paren_levels_sum5;\n    long paren_levels_sum8 = paren_levels_sum7 - paren_levels_sum6;\n\
    \    long paren_levels_sum9 = paren_levels_sum8 - paren_levels_sum7;\n    long\
    \ paren_levels_sum10 = paren_levels_sum9 - paren_levels_sum8;\n    long paren_levels_sum11\
    \ = paren_levels_sum10 - paren_levels_sum9;\n    long paren_levels_sum12 = paren_levels_sum11\
    \ - paren_levels_sum10;\n    long paren_levels_sum13 = paren_levels_sum12 - paren_levels_sum11;\n\
    \    long paren_levels_sum14 = paren_levels_sum13 - paren_levels_sum12;\n    long\
    \ paren_levels_sum15 = paren_levels_sum14 - paren_levels_sum13;\n    long paren_levels_sum16\
    \ = paren_levels_sum15 - paren_levels_sum14;\n    long paren_levels_sum17 = paren_levels_sum16\
    \ - paren_levels_sum15;\n    long paren_levels_sum18 = paren_levels_sum17 - paren_levels_sum16;\n\
    \    long paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp40l0n8z7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp40l0n8z7.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmp40l0n8z7.cpp:40:1: error: expected initializer\
    \ before \u2018}\u2019 token\n   40 | }\n      | ^\n/tmp/tmp40l0n8z7.cpp:40:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpyfnvbax5: /tmp/tmpyfnvbax5.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvzctdgob: /tmp/tmpvzctdgob.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    long level = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n\
    \        if (paren_string[i] == '(') {\n            paren_level = paren_string.substr(0,\
    \ i);\n            level++;\n        } else if (paren_string[i] == ')') {\n  \
    \          level--;\n            if (level == 0) {\n                levels.push_back(level);\n\
    \            }\n        }\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpsey5_l1s: /tmp/tmpsey5_l1s.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvzctdgob: /tmp/tmpvzctdgob.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_copy;\n    paren_levels_copy.reserve(paren_levels.size());\n\
    \    for (auto &level : paren_levels) {\n        paren_levels_copy.push_back(level);\n\
    \    }\n    long max_level = 0;\n    for (auto &level : paren_levels_copy) {\n\
    \        if (level > max_level) {\n            max_level = level;\n        }\n\
    \    }\n    std::vector<long> paren_levels_copy(paren_levels_copy.begin(), paren_levels_copy.begin()\
    \ + max_level);\n    return paren_levels_copy;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpxh626zjp.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpxh626zjp.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpxh626zjp.cpp:22:23: error: redeclaration of\
    \ \u2018std::vector<long int> paren_levels_copy\u2019\n   22 |     std::vector<long>\
    \ paren_levels_copy(paren_levels_copy.begin(), paren_levels_copy.begin() + max_level);\n\
    \      |                       ^~~~~~~~~~~~~~~~~\n/tmp/tmpxh626zjp.cpp:11:23:\
    \ note: \u2018std::vector<long int> paren_levels_copy\u2019 previously declared\
    \ here\n   11 |     std::vector<long> paren_levels_copy;\n      |            \
    \           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long current_level\
    \ = 0;\n    long current_paren_level = 0;\n    long paren_level_counter = 0;\n\
    \    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n    long\
    \ paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long paren_level_counter6\
    \ = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8 = 0;\n\
    \    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n   \
    \ long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n    long\
    \ paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long paren_level_counter15\
    \ = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17 =\
    \ 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 = 0;\n\
    \    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n  \
    \  long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n    long\
    \ paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long paren_level_counter26\
    \ = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28 =\
    \ 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 = 0;\n\
    \    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n  \
    \  long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n    long\
    \ paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long paren_level_counter37\
    \ = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39 =\
    \ 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 = 0;\n\
    \    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n  \
    \  long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n    long\
    \ paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long paren_level_counter48\
    \ = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50 =\
    \ 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 = 0;\n\
    \    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n  \
    \  long paren_level_counter55 = 0;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpb3_pil3_: /tmp/tmpb3_pil3_.cpp:70: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpelf110ym: /tmp/tmpelf110ym.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_copy;\n    paren_levels_copy = paren_levels.begin();\n\
    \    long paren_levels_copy_size = paren_levels.size();\n    long paren_levels_copy_index\
    \ = 0;\n    long paren_levels_copy_value = 0;\n    long paren_levels_copy_index2\
    \ = 0;\n    long paren_levels_copy_value2 = 0;\n    long paren_levels_copy_index3\
    \ = 0;\n    long paren_levels_copy_value3 = 0;\n    long paren_levels_copy_index4\
    \ = 0;\n    long paren_levels_copy_value4 = 0;\n    long paren_levels_copy_index5\
    \ = 0;\n    long paren_levels_copy_value5 = 0;\n    long paren_levels_copy_index6\
    \ = 0;\n    long paren_levels_copy_value6 = 0;\n    long paren_levels_copy_index7\
    \ = 0;\n    long paren_levels_copy_value7 = 0;\n    long paren_levels_copy_index8\
    \ = 0;\n    long paren_levels_copy_value8 = 0;\n    long paren_levels_copy_index9\
    \ = 0;\n    long paren_levels_copy_value9 = 0;\n    long paren_levels_copy_index10\
    \ = 0;\n    long paren_levels_copy_value10 = 0;\n    long paren_levels_copy_index11\
    \ = 0;\n    long paren_levels_copy_value11 = 0;\n    long paren_levels_copy_index12\
    \ = 0;\n    long paren_levels_copy_value12 = 0;\n    long paren_levels_copy_index13\
    \ = 0;\n    long paren_levels_copy_value13 = 0;\n    long paren_levels_copy_index14\
    \ = 0;\n    long paren_levels_copy_value14 = 0;\n    long paren_levels_copy_index15\
    \ = 0;\n    long paren_levels_copy_value15 = 0;\n    long paren_levels_copy_index16\
    \ = 0;\n    long paren_levels_copy_value16 = 0;\n    long paren_levels_copy_index17\
    \ = 0;\n    long paren_levels_copy_value17 = 0;\n    long paren_levels_copy_index18\
    \ = 0;\n    long paren_levels_copy_value18 = 0;\n    long paren_levels_copy_index19\
    \ = 0;\n    long paren_levels_copy_value19 = 0;\n    long paren_levels_copy_index20\
    \ = 0;\n    long paren_levels_copy_value20 = 0;\n    long paren_levels_copy_index21\
    \ = 0;\n    long paren_levels_copy_value21 = 0;\n    long \n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1u30h37v.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp1u30h37v.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmp1u30h37v.cpp:12:44: error: no match for \u2018\
    operator=\u2019 (operand types are \u2018std::vector<long int>\u2019 and \u2018\
    std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019})\n   12 |     paren_levels_copy = paren_levels.begin();\n\
    \      |                                            ^\nIn file included from /usr/include/c++/9/vector:72,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1u30h37v.cpp:2:\n/usr/include/c++/9/bits/vector.tcc:198:5:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const\
    \ std::vector<_Tp, _Alloc>&) [with _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n  198 |     vector<_Tp, _Alloc>::\n      |     ^~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/vector.tcc:199:42: note:   no known conversion for argument\
    \ 1 from \u2018std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019} to \u2018const std::vector<long int>&\u2019\
    \n  199 |     operator=(const vector<_Tp, _Alloc>& __x)\n      |             \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1u30h37v.cpp:2:\n/usr/include/c++/9/bits/stl_vector"
  stdout: ''
  timestamp: 1660113005
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    long paren_level = 0;\n    long paren_levels_temp_index\
    \ = 0;\n    bool paren_levels_temp_empty = true;\n    bool paren_levels_temp_empty_flag\
    \ = false;\n    bool paren_levels_temp_empty_flag2 = false;\n    bool paren_levels_temp_empty_flag3\
    \ = false;\n    bool paren_levels_temp_empty_flag4 = false;\n    bool paren_levels_temp_empty_flag5\
    \ = false;\n    bool paren_levels_temp_empty_flag6 = false;\n    bool paren_levels_temp_empty_flag7\
    \ = false;\n    bool paren_levels_temp_empty_flag8 = false;\n    bool paren_levels_temp_empty_flag9\
    \ = false;\n    bool paren_levels_temp_empty_flag10 = false;\n    bool paren_levels_temp_empty_flag11\
    \ = false;\n    bool paren_levels_temp_empty_flag12 = false;\n    bool paren_levels_temp_empty_flag13\
    \ = false;\n    bool paren_levels_temp_empty_flag14 = false;\n    bool paren_levels_temp_empty_flag15\
    \ = false;\n    bool paren_levels_temp_empty_flag16 = false;\n    bool paren_levels_temp_empty_flag17\
    \ = false;\n    bool paren_levels_temp_empty_flag18 = false;\n    bool paren_levels_temp_empty_flag19\
    \ = false;\n    bool paren_levels_temp_empty_flag20 = false;\n    bool paren_levels_temp_empty_flag21\
    \ = false;\n    bool paren_levels_temp_empty_flag22 = false;\n    bool paren_levels_temp_empty_flag23\
    \ = false;\n    bool paren_levels_temp_empty_flag24 = false;\n    bool paren_levels_temp_empty_flag25\
    \ = false;\n    bool paren_levels_temp_empty_flag26 = false;\n    bool paren_levels_temp_empty_flag27\
    \ = false;\n    bool paren_levels_temp_empty_flag28 = false;\n    bool paren_levels_temp_empty_flag29\
    \ = false;\n    bool paren_levels_temp_empty_flag30 = false;\n    bool paren_levels_temp_empty_flag31\
    \ = false;\n    bool paren_levels_temp_empty_flag32 = false;\n    bool paren_levels_temp_empty_flag33\
    \ = false;\n    bool paren_levels_temp_empty_flag34 = false;\n    bool paren_levels_temp_empty_flag35\
    \ = false;\n    bool paren_levels_temp_empty_flag36 = false;\n    bool paren_levels_temp_empty_flag37\
    \ = false;\n    bool paren_levels_temp_empty_flag38 = false;\n    bool paren_levels_temp_empty_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprdta9vnd.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmprdta9vnd.cpp:53:1: error: expected initializer before \u2018}\u2019\
    \ token\n   53 | }\n      | ^\n/tmp/tmprdta9vnd.cpp:53:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(1);\n\
    \    long max_level = 1;\n    for (long i = 1; i < paren_levels.size(); i++) {\n\
    \        if (paren_levels[i] > max_level) {\n            max_level = paren_levels[i];\n\
    \        }\n    }\n    for (long i = 0; i < paren_levels.size(); i++) {\n    \
    \    if (paren_levels[i] <= max_level) {\n            paren_levels_temp.push_back(paren_levels[i]);\n\
    \        }\n    }\n    return paren_levels_temp;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpzy7qg8pu.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpzy7qg8pu.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string current_paren_string = paren_string;\n    long current_paren_level\
    \ = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            current_paren_level++;\n        } else if (paren_string[i]\
    \ == ')') {\n            current_paren_level--;\n        }\n        if (current_paren_level\
    \ == 0) {\n            paren_levels.push_back(current_paren_level);\n        \
    \    current_paren_string = paren_string.substr(i + 1);\n            current_paren_level\
    \ = 0;\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpzq8vxc31: /tmp/tmpzq8vxc31.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long level = 0;\n    bool\
    \ is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing_paren = false;\n    bool is_opening_curly_bracket = false;\n\
    \    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_paren_or_curly_bracket\
    \ = false;\n    bool is_closing_paren_or_curly_bracket = false;\n    bool is_opening_paren_or_curly_brace\
    \ = false;\n    bool is_closing_paren_or_curly_brace = false;\n    bool is_opening_paren_or_curly_brace_or_square_bracket\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_bracket = false;\n\
    \    bool is_opening_paren_or_curly_brace_or_square_brace = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_bracket\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_bracket\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_brace\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_brace\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_bracket\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_bracket\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_brace\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_brace\
    \ = false;\n    bool is_opening_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_brace_or_curly_bracket\
    \ = false;\n    bool is_closing_paren_or_curly_brace_or_square_brace_or_curly_brace_or_square_bra\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_d28dl0a.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp_d28dl0a.cpp:41:1: error: expected initializer before \u2018}\u2019\
    \ token\n   41 | }\n      | ^\n/tmp/tmp_d28dl0a.cpp:41:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels_t paren_levels_t;\n\
    \    paren_levels_t.clear();\n    paren_levels_t.push_back(paren_levels);\n  \
    \  paren_levels_t paren_levels_t1;\n    paren_levels_t1.clear();\n    paren_levels_t1.push_back(paren_levels_t);\n\
    \    paren_levels_t paren_levels_t2;\n    paren_levels_t2.clear();\n    paren_levels_t2.push_back(paren_levels_t1);\n\
    \    paren_levels_t paren_levels_t3;\n    paren_levels_t3.clear();\n    paren_levels_t3.push_back(paren_levels_t2);\n\
    \    paren_levels_t paren_levels_t4;\n    paren_levels_t4.clear();\n    paren_levels_t4.push_back(paren_levels_t3);\n\
    \    paren_levels_t paren_levels_t5;\n    paren_levels_t5.clear();\n    paren_levels_t5.push_back(paren_levels_t4);\n\
    \    paren_levels_t paren_levels_t6;\n    paren_levels_t6.clear();\n    paren_levels_t6.push_back(paren_levels_t5);\n\
    \    paren_levels_t paren_levels_t7;\n    paren_levels_t7.clear();\n    paren_levels_t7.push_back(paren_levels_t6);\n\
    \    paren_levels_t paren_levels_t8;\n    paren_levels_t8.clear();\n    paren_levels_t8.push_back(paren_levels_t7);\n\
    \    paren_levels_t paren_levels_t9;\n    paren_levels_t9.clear();\n    paren_levels_t9.push_back(paren_levels_t8);\n\
    \    paren_levels_t paren_levels_t10;\n    paren_levels_t10.clear();\n    paren_levels_t10.push_back(paren_levels_t9);\n\
    \    paren_levels_t paren_levels_t11;\n    paren_levels_t11.clear();\n    paren_levels_t11.push_back(paren_levels_t10);\n\
    \    paren_levels_t paren_levels_t12;\n    paren_levels_t12.clear();\n    paren_levels_t12.push_back(paren_levels_t11);\n\
    \    paren_levels_t paren_levels_t13;\n    paren_levels_t13.clear();\n    paren_levels_t13.push_back(paren\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo_dr6g82.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpo_dr6g82.cpp:10:5: error: \u2018paren_levels_t\u2019 was not declared\
    \ in this scope; did you mean \u2018paren_levels\u2019?\n   10 |     paren_levels_t\
    \ paren_levels_t;\n      |     ^~~~~~~~~~~~~~\n      |     paren_levels\n/tmp/tmpo_dr6g82.cpp:13:19:\
    \ error: expected \u2018;\u2019 before \u2018paren_levels_t1\u2019\n   13 |  \
    \   paren_levels_t paren_levels_t1;\n      |                   ^~~~~~~~~~~~~~~~\n\
    \      |                   ;\n/tmp/tmpo_dr6g82.cpp:14:5: error: \u2018paren_levels_t1\u2019\
    \ was not declared in this scope; did you mean \u2018paren_levels\u2019?\n   14\
    \ |     paren_levels_t1.clear();\n      |     ^~~~~~~~~~~~~~~\n      |     paren_levels\n\
    /tmp/tmpo_dr6g82.cpp:16:19: error: expected \u2018;\u2019 before \u2018paren_levels_t2\u2019\
    \n   16 |     paren_levels_t paren_levels_t2;\n      |                   ^~~~~~~~~~~~~~~~\n\
    \      |                   ;\n/tmp/tmpo_dr6g82.cpp:17:5: error: \u2018paren_levels_t2\u2019\
    \ was not declared in this scope; did you mean \u2018paren_levels\u2019?\n   17\
    \ |     paren_levels_t2.clear();\n      |     ^~~~~~~~~~~~~~~\n      |     paren_levels\n\
    /tmp/tmpo_dr6g82.cpp:19:19: error: expected \u2018;\u2019 before \u2018paren_levels_t3\u2019\
    \n   19 |     paren_levels_t paren_levels_t3;\n      |                   ^~~~~~~~~~~~~~~~\n\
    \      |                   ;\n/tmp/tmpo_dr6g82.cpp:20:5: error: \u2018paren_levels_t3\u2019\
    \ was not declared in this scope; did you mean \u2018paren_levels\u2019?\n   20\
    \ |     paren_levels_t3.clear();\n      |     ^~~~~~~~~~~~~~~\n      |     paren_levels\n\
    /tmp/tmpo_dr6g82.cpp:22:19: error: expected \u2018;\u2019 before \u2018paren_levels_t4\u2019\
    \n   22 |     paren_levels_t paren_levels_t4;\n      |                   ^~~~~~~~~~~~~~~~\n\
    \      |                   ;\n/tmp/tmpo_dr6g82.cpp:23:5: error: \u2018paren_levels_t4\u2019\
    \ was not declared in this scope; did you mean \u2018paren_levels\u2019?\n   23\
    \ |     paren_levels_t4.clear();\n      |     ^~~~~~~~~~~~~~~\n      |     paren_levels\n\
    /tmp/tmpo_dr6g82.cpp:25:19: error: expected \u2018;\u2019 before \u2018paren_levels_t5\u2019\
    \n   25 |     paren_levels_t p"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvzctdgob: /tmp/tmpvzctdgob.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    size_t paren_level = 0;\n    size_t paren_level_count = 0;\n    size_t paren_level_length\
    \ = 0;\n    size_t paren_level_start = 0;\n    size_t paren_level_end = 0;\n \
    \   size_t paren_level_end_count = 0;\n    size_t paren_level_end_length = 0;\n\
    \    size_t paren_level_end_start = 0;\n    size_t paren_level_end_end = 0;\n\
    \    size_t paren_level_end_end_count = 0;\n    size_t paren_level_end_end_length\
    \ = 0;\n    size_t paren_level_end_end_start = 0;\n    size_t paren_level_end_end_end\
    \ = 0;\n    size_t paren_level_end_end_end_count = 0;\n    size_t paren_level_end_end_end_length\
    \ = 0;\n    size_t paren_level_end_end_end_start = 0;\n    size_t paren_level_end_end_end_end\
    \ = 0;\n    size_t paren_level_end_end_end_end_count = 0;\n    size_t paren_level_end_end_end_end_length\
    \ = 0;\n    size_t paren_level_end_end_end_end_start = 0;\n    size_t paren_level_end_end_end_end_end\
    \ = 0;\n    size_t paren_level_end_end_end_end_end_count = 0;\n    size_t paren_level_end_end_end_end_end_length\
    \ = 0;\n    size_t paren_level_end_end_end_end_end_start = 0;\n    size_t paren_level_end_end_end_end_end_end\
    \ = 0;\n    size_t paren_level_end_end_end_end_end_end_count = 0;\n    size_t\
    \ paren_level_end_end_end_end_end_end_length = 0;\n    size_t paren_level_end_end_end_end_end_end_start\
    \ = 0;\n    size_t paren_level_end_end_end_end_end_end_end = 0;\n    size_t paren_level_end_end_end_end_end_end_end_count\
    \ = 0;\n    size_t paren_level_end_end_end_end_end_end_length = 0;\n    size_t\
    \ paren_level_end_end_end_end_end_end_start = 0;\n    size_t paren_level_end_end_end_end_end_end_end\
    \ = 0;\n    size_t paren_level_end_end_end_end_end_end_end_count = 0;\n    size_t\
    \ paren_level_end_end_end_end_end_end_length = 0;\n    size_t paren_level_end_end_end_end_end_end_end_start\
    \ = 0;\n    size_t paren_level_end_end_end_end_end_end_end_end = 0;\n    size_t\
    \ paren_level_end_end_end_end_end_end_end_count = 0;\n    size_t paren_level_end_end_end_end_end_end_length\
    \ = 0;\n    size_t paren_level_end_end_end_end_end_end_start = 0;\n    size_t\
    \ paren_level_end_end_end_end_end_end_end = 0;\n    size_t paren_level_end_end_end_end_end_end_end_count\
    \ = 0;\n    size_t paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp58_py6u7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp58_py6u7.cpp:41:12: error: redeclaration of \u2018size_t paren_level_end_end_end_end_end_end_length\u2019\
    \n   41 |     size_t paren_level_end_end_end_end_end_end_length = 0;\n      |\
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_py6u7.cpp:37:12:\
    \ note: \u2018size_t paren_level_end_end_end_end_end_end_length\u2019 previously\
    \ declared here\n   37 |     size_t paren_level_end_end_end_end_end_end_length\
    \ = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_py6u7.cpp:42:12:\
    \ error: redeclaration of \u2018size_t paren_level_end_end_end_end_end_end_start\u2019\
    \n   42 |     size_t paren_level_end_end_end_end_end_end_start = 0;\n      | \
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_py6u7.cpp:38:12:\
    \ note: \u2018size_t paren_level_end_end_end_end_end_end_start\u2019 previously\
    \ declared here\n   38 |     size_t paren_level_end_end_end_end_end_end_start\
    \ = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_py6u7.cpp:43:12:\
    \ error: redeclaration of \u2018size_t paren_level_end_end_end_end_end_end_end\u2019\
    \n   43 |     size_t paren_level_end_end_end_end_end_end_end = 0;\n      |   \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_py6u7.cpp:39:12:\
    \ note: \u2018size_t paren_level_end_end_end_end_end_end_end\u2019 previously\
    \ declared here\n   39 |     size_t paren_level_end_end_end_end_end_end_end =\
    \ 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_py6u7.cpp:44:12:\
    \ error: redeclaration of \u2018size_t paren_level_end_end_end_end_end_end_end_count\u2019\
    \n   44 |     size_t paren_level_end_end_end_end_end_end_end_count = 0;\n    \
    \  |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_py6u7.cpp:40:12:\
    \ note: \u2018size_t paren_level_end_end_end_end_end_end_end_count\u2019 previously\
    \ declared here\n   40 |     size_t paren_level_end_end_end_end_end_end_end_count\
    \ = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp58_py6u7.cpp:45:12:\
    \ error:"
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvzctdgob: /tmp/tmpvzctdgob.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string paren_level;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            paren_level = paren_string.substr(0, i);\n          \
    \  levels[levels.size() - 1]++;\n        } else if (paren_string[i] == ')') {\n\
    \            levels[levels.size() - 1]--;\n            if (levels[levels.size()\
    \ - 1] == 0) {\n                levels.push_back(levels.size() - 1);\n       \
    \     }\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  for (auto &c : paren_string) {\n    if (c == '(') {\n      paren_levels.push_back(1);\n\
    \    } else if (c == ')') {\n      paren_levels.back()--;\n    }\n  }\n  return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmplddzt7_t: /tmp/tmplddzt7_t.cpp:22: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113005
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    long paren_level = 0;\n    long paren_level_counter = 0;\n    long paren_level_counter2\
    \ = 0;\n    long paren_level_counter3 = 0;\n    long paren_level_counter4 = 0;\n\
    \    long paren_level_counter5 = 0;\n    long paren_level_counter6 = 0;\n    long\
    \ paren_level_counter7 = 0;\n    long paren_level_counter8 = 0;\n    long paren_level_counter9\
    \ = 0;\n    long paren_level_counter10 = 0;\n    long paren_level_counter11 =\
    \ 0;\n    long paren_level_counter12 = 0;\n    long paren_level_counter13 = 0;\n\
    \    long paren_level_counter14 = 0;\n    long paren_level_counter15 = 0;\n  \
    \  long paren_level_counter16 = 0;\n    long paren_level_counter17 = 0;\n    long\
    \ paren_level_counter18 = 0;\n    long paren_level_counter19 = 0;\n    long paren_level_counter20\
    \ = 0;\n    long paren_level_counter21 = 0;\n    long paren_level_counter22 =\
    \ 0;\n    long paren_level_counter23 = 0;\n    long paren_level_counter24 = 0;\n\
    \    long paren_level_counter25 = 0;\n    long paren_level_counter26 = 0;\n  \
    \  long paren_level_counter27 = 0;\n    long paren_level_counter28 = 0;\n    long\
    \ paren_level_counter29 = 0;\n    long paren_level_counter30 = 0;\n    long paren_level_counter31\
    \ = 0;\n    long paren_level_counter32 = 0;\n    long paren_level_counter33 =\
    \ 0;\n    long paren_level_counter34 = 0;\n    long paren_level_counter35 = 0;\n\
    \    long paren_level_counter36 = 0;\n    long paren_level_counter37 = 0;\n  \
    \  long paren_level_counter38 = 0;\n    long paren_level_counter39 = 0;\n    long\
    \ paren_level_counter40 = 0;\n    long paren_level_counter41 = 0;\n    long paren_level_counter42\
    \ = 0;\n    long paren_level_counter43 = 0;\n    long paren_level_counter44 =\
    \ 0;\n    long paren_level_counter45 = 0;\n    long paren_level_counter46 = 0;\n\
    \    long paren_level_counter47 = 0;\n    long paren_level_counter48 = 0;\n  \
    \  long paren_level_counter49 = 0;\n    long paren_level_counter50 = 0;\n    long\
    \ paren_level_counter51 = 0;\n    long paren_level_counter52 = 0;\n    long paren_level_counter53\
    \ = 0;\n    long paren_level_counter54 = 0;\n    long paren_level_counter55 =\
    \ 0;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpxedx6jno: /tmp/tmpxedx6jno.cpp:70: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    for (auto &c\
    \ : paren_string) {\n        if (c == '(') {\n            paren_level++;\n   \
    \         paren_level_count++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            paren_level_count--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpb_tabeiv: /tmp/tmpb_tabeiv.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long paren_level =\
    \ 0;\n    std::string paren_level_string;\n    std::string paren_level_char;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_string\
    \ = paren_level_string.empty() ? c : paren_level_string;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren_level_string = paren_level_string + c;\n           \
    \ paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren_level_string = paren_level_string + c;\n           \
    \ paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren_level_string = paren_level_string + c;\n           \
    \ paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren_level_string = paren_level_string + c;\n           \
    \ paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren_level_string = paren_level_string + c;\n           \
    \ paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren_level_string = paren_level_string + c;\n           \
    \ paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren_level_string = paren_level_string + c;\n           \
    \ paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren_level_string = paren_level_string + c;\n           \
    \ paren_level_string = paren_level_string + c;\n            paren_level_string\
    \ = paren_level_string + c;\n            paren_level_string = paren_level_string\
    \ + c;\n            paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt__xtn_o.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpt__xtn_o.cpp:15:61: error: operands to ?: have different types \u2018\
    char\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   15 |             paren_level_string = paren_level_string.empty() ? c : paren_level_string;\n\
    \      |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt__xtn_o.cpp:50:13: error: \u2018paren\u2019 was not declared in this\
    \ scope\n   50 |             paren\n      |             ^~~~~\n/tmp/tmpt__xtn_o.cpp:52:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   52 | int main() {\n      |            ^\n/tmp/tmpt__xtn_o.cpp:57:1: error:\
    \ expected \u2018}\u2019 at end of input\n   57 | }\n      | ^\n/tmp/tmpt__xtn_o.cpp:13:33:\
    \ note: to match this \u2018{\u2019\n   13 |     for (auto c : paren_string) {\n\
    \      |                                 ^\n/tmp/tmpt__xtn_o.cpp:57:1: error:\
    \ expected \u2018}\u2019 at end of input\n   57 | }\n      | ^\n/tmp/tmpt__xtn_o.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpt__xtn_o.cpp:57:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   57 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113005
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long level = 0;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n    long\
    \ paren_level_count_current = 0;\n    long paren_level_count_current_max = 0;\n\
    \    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuovwrgg9.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpuovwrgg9.cpp:19:10: error: redeclaration of \u2018long int paren_level_count_current_max\u2019\
    \n   19 |     long paren_level_count_current_max = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpuovwrgg9.cpp:17:10: note: \u2018long int paren_level_count_current_max\u2019\
    \ previously declared here\n   17 |     long paren_level_count_current_max = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuovwrgg9.cpp:20:10: error:\
    \ redeclaration of \u2018long int paren_level_count_current_min\u2019\n   20 |\
    \     long paren_level_count_current_min = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpuovwrgg9.cpp:18:10: note: \u2018long int paren_level_count_current_min\u2019\
    \ previously declared here\n   18 |     long paren_level_count_current_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuovwrgg9.cpp:21:10: error:\
    \ redeclaration of \u2018long int paren_level_count_current_max\u2019\n   21 |\
    \     long paren_level_count_current_max = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpuovwrgg9.cpp:17:10: note: \u2018long int paren_level_count_current_max\u2019\
    \ previously declared here\n   17 |     long paren_level_count_current_max = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuovwrgg9.cpp:22:10: error:\
    \ redeclaration of \u2018long int paren_level_count_current_min\u2019\n   22 |\
    \     long paren_level_count_current_min = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpuovwrgg9.cpp:18:10: note: \u2018long int paren_level_count_current_min\u2019\
    \ previously declared here\n   18 |     long paren_level_count_current_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuovwrgg9.cpp:23:10: error:\
    \ redeclaration of \u2018long int paren_level_count_current_max\u2019\n   23 |\
    \     long paren_level_count_current_max = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpuovwrgg9.cpp:17:10: note: \u2018long int paren_level_count_current_max\u2019\
    \ previously declared here\n   17 |     long paren_level_count_current_max = 0;\n\
    \    "
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    std::string current_paren_level;\n    bool is_first_paren = true;\n    for\
    \ (auto c : paren_string) {\n        if (is_first_paren) {\n            current_paren_level\
    \ = c;\n            is_first_paren = false;\n        } else {\n            if\
    \ (c == ')') {\n                paren_levels.push_back(std::stoi(current_paren_level));\n\
    \                current_paren_level = \"\";\n            } else {\n         \
    \       current_paren_level += c;\n            }\n        }\n    }\n    if (current_paren_level\
    \ != \"\") {\n        paren_levels.push_back(std::stoi(current_paren_level));\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113006
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long paren_level =\
    \ 0;\n    bool is_first_paren = true;\n    bool is_last_paren = true;\n    long\
    \ paren_level_count = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            if (is_first_paren) {\n                is_first_paren =\
    \ false;\n                paren_level_count++;\n            } else {\n       \
    \         paren_level_count--;\n            }\n        } else if (c == ')') {\n\
    \            if (is_last_paren) {\n                is_last_paren = false;\n  \
    \              paren_level_count++;\n            } else {\n                paren_level_count--;\n\
    \            }\n        } else if (c == ' ') {\n            if (is_first_paren)\
    \ {\n                is_first_paren = false;\n                paren_level_count++;\n\
    \            } else if (is_last_paren) {\n                is_last_paren = false;\n\
    \                paren_level_count++;\n            } else {\n                paren_level_count--;\n\
    \            }\n        } else if (c == '(' || c == '[' || c == '{') {\n     \
    \       if (paren_level_count == 0) {\n                paren_level_count++;\n\
    \            }\n        } else if (c == ')' || c == ']' || c == '}') {\n     \
    \       if (paren_level_count == 0) {\n                paren_level_count--;\n\
    \            }\n        }\n        paren_levels[paren_level] = paren_level_count;\n\
    \        paren_level++;\n    }\n    return paren_levels;\n}\nint main() {\n  \
    \  auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113006
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string paren_level\
    \ = \"\";\n    long paren_level_count = 0;\n    for (char c : paren_string) {\n\
    \        if (c == '(') {\n            paren_level_count++;\n            paren_level\
    \ += c;\n        } else if (c == ')') {\n            paren_level_count--;\n  \
    \          paren_level += c;\n        } else if (c == ' ') {\n            if (paren_level_count\
    \ == 0) {\n                paren_level_count++;\n                paren_level +=\
    \ c;\n            } else {\n                paren_level_count--;\n           \
    \     paren_level += c;\n            }\n        } else {\n            paren_level\
    \ += c;\n        }\n    }\n    paren_level_count = 0;\n    for (char c : paren_level)\
    \ {\n        if (c == '(') {\n            paren_level_count++;\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (char c : paren_level) {\n        if (c == '(') {\n          \
    \  paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_level_count = 0;\n    for (char c : paren_level)\
    \ {\n        if (c == '(') {\n            paren_level_count++;\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (char c : paren_level) {\n        if (c == '(') {\n          \
    \  paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_level_count = 0;\n    for (char c : paren_level)\
    \ {\n        if (c == '(') {\n            paren_level_count++;\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (char c : paren_level) {\n        if (c == '(') {\n          \
    \  paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_level_count = 0;\n    for (char c : paren_level)\
    \ {\n        if (c == '(') {\n            paren_level_count++;\n        } else\
    \ if (c == ')') {\n            paren_level_count--;\n        }\n    }\n    paren_level_count\
    \ = 0;\n    for (char c : paren_level) {\n        if (c == '(') {\n          \
    \  paren_level_count++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \        }\n    }\n    paren_level_count = 0;\n    for (char c : paren_level)\
    \ {\n        if (c == '(') {\n            paren\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpzbvtdksh.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpzbvtdksh.cpp:98:13: error: \u2018paren\u2019 was not declared in this\
    \ scope\n   98 |             paren\n      |             ^~~~~\n/tmp/tmpzbvtdksh.cpp:100:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  100 | int main() {\n      |            ^\n/tmp/tmpzbvtdksh.cpp:105:1: error:\
    \ expected \u2018}\u2019 at end of input\n  105 | }\n      | ^\n/tmp/tmpzbvtdksh.cpp:96:32:\
    \ note: to match this \u2018{\u2019\n   96 |     for (char c : paren_level) {\n\
    \      |                                ^\n/tmp/tmpzbvtdksh.cpp:105:1: error:\
    \ expected \u2018}\u2019 at end of input\n  105 | }\n      | ^\n/tmp/tmpzbvtdksh.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpzbvtdksh.cpp:105:1: warning: no return statement in\
    \ function returning non-void [-Wreturn-type]\n  105 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113006
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.split(\"\
    \ \");\n    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels.size());\n\
    \    for (long i = 0; i < paren_levels.size(); i++) {\n        if (paren_levels[i]\
    \ == \"(\") {\n            paren_levels_temp.push_back(i);\n        } else if\
    \ (paren_levels[i] == \")\") {\n            long paren_levels_size = paren_levels_temp.back();\n\
    \            long paren_levels_size = paren_levels_size - 1;\n            long\
    \ paren_levels_size = paren_levels_size - 1;\n            paren_levels_temp.push_back(paren_levels_size);\n\
    \        }\n    }\n    return paren_levels_temp;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpbts5vbd5.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpbts5vbd5.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n/tmp/tmpbts5vbd5.cpp:14:32: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   14 |         if (paren_levels[i]\
    \ == \"(\") {\n      |                                ^~~\n/tmp/tmpbts5vbd5.cpp:16:39:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   16 |         } else if (paren_levels[i] == \")\") {\n      |             \
    \                          ^~~\n/tmp/tmpbts5vbd5.cpp:18:18: error: redeclaration\
    \ of \u2018long int paren_levels_size\u2019\n   18 |             long paren_levels_size\
    \ = paren_levels_size - 1;\n      |                  ^~~~~~~~~~~~~~~~~\n/tmp/tmpbts5vbd5.cpp:17:18:\
    \ note: \u2018long int paren_levels_size\u2019 previously declared here\n   17\
    \ |             long paren_levels_size = paren_levels_temp.back();\n      |  \
    \                ^~~~~~~~~~~~~~~~~\n/tmp/tmpbts5vbd5.cpp:19:18: error: redeclaration\
    \ of \u2018long int paren_levels_size\u2019\n   19 |             long paren_levels_size\
    \ = paren_levels_size - 1;\n      |                  ^~~~~~~~~~~~~~~~~\n/tmp/tmpbts5vbd5.cpp:17:18:\
    \ note: \u2018long int paren_levels_size\u2019 previously declared here\n   17\
    \ |             long paren_levels_size = paren_levels_temp.back();\n      |  \
    \                ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string current_paren_string\
    \ = paren_string;\n    long current_paren_level = 0;\n    bool is_open = false;\n\
    \    while (current_paren_string != \"\") {\n        if (current_paren_string.find(\"\
    (\") != std::string::npos) {\n            is_open = true;\n            current_paren_level++;\n\
    \        }\n        if (current_paren_string.find(\")\") != std::string::npos)\
    \ {\n            is_open = false;\n            current_paren_level--;\n      \
    \  }\n        if (is_open) {\n            current_paren_string = current_paren_string.substr(0,\
    \ current_paren_string.find(\")\"));\n        } else {\n            current_paren_string\
    \ = current_paren_string.substr(0, current_paren_string.find(\"(\"));\n      \
    \  }\n        paren_levels.push_back(current_paren_level);\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpx3bs0yqe: /tmp/tmpx3bs0yqe.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::string curr_paren_string\
    \ = paren_string;\n    long level = 0;\n    while (curr_paren_string.size() >\
    \ 0) {\n        auto pos = curr_paren_string.find(\"(\");\n        if (pos ==\
    \ std::string::npos) {\n            result.push_back(level);\n            break;\n\
    \        }\n        auto end_pos = curr_paren_string.find(\")\", pos + 1);\n \
    \       if (end_pos == std::string::npos) {\n            result.push_back(level);\n\
    \            break;\n        }\n        curr_paren_string = curr_paren_string.substr(pos\
    \ + 1, end_pos - pos + 1);\n        level++;\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmps718m0jm: /tmp/tmps718m0jm.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n    }\n  }\n  assert(paren_levels.size() == paren_string.size());\n\
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpn085h06e: /tmp/tmpn085h06e.cpp:20: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_levels.size() == paren_string.size()'' failed.

    '
  stdout: ''
  timestamp: 1660112999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\"()\");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.reserve(paren_levels.size());\n    for (long i = 0; i <\
    \ paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    long max_level = 0;\n    for (long i = 0; i < paren_levels_temp.size();\
    \ i++) {\n        long level_of_nesting = paren_levels_temp[i].size();\n     \
    \   if (level_of_nesting > max_level) {\n            max_level = level_of_nesting;\n\
    \        }\n    }\n    std::vector<long> paren_levels_temp2;\n    paren_levels_temp2.reserve(paren_levels_temp.size());\n\
    \    for (long i = 0; i < paren_levels_temp.size(); i++) {\n        paren_levels_temp2.push_back(max_level);\n\
    \    }\n    for (long i = 0; i < paren_levels_temp.size(); i++) {\n        for\
    \ (long j = 0; j < paren_levels_temp[i].size(); j++) {\n            paren_levels_temp2[i][j]\
    \ = paren_levels_temp[i][j];\n        }\n    }\n    return paren_levels_temp2;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc2zwwqci.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpc2zwwqci.cpp:10:77: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of(\"()\")).split(\"()\");\n      |                \
    \                                                             ^~~~~\n/tmp/tmpc2zwwqci.cpp:18:54:\
    \ error: request for member \u2018size\u2019 in \u2018paren_levels_temp.std::vector<long\
    \ int>::operator[](((std::vector<long int>::size_type)i))\u2019, which is of non-class\
    \ type \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019}\n   18 |         long level_of_nesting = paren_levels_temp[i].size();\n\
    \      |                                                      ^~~~\n/tmp/tmpc2zwwqci.cpp:29:51:\
    \ error: request for member \u2018size\u2019 in \u2018paren_levels_temp.std::vector<long\
    \ int>::operator[](((std::vector<long int>::size_type)i))\u2019, which is of non-class\
    \ type \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019}\n   29 |         for (long j = 0; j < paren_levels_temp[i].size();\
    \ j++) {\n      |                                                   ^~~~\n/tmp/tmpc2zwwqci.cpp:30:36:\
    \ error: invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>,\
    \ long int>::value_type {aka long int}[long int]\u2019 for array subscript\n \
    \  30 |             paren_levels_temp2[i][j] = paren_levels_temp[i][j];\n    \
    \  |                                    ^\n/tmp/tmpc2zwwqci.cpp:30:62: error:\
    \ invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type {aka long int}[long int]\u2019 for array subscript\n   30 |\
    \             paren_levels_temp2[i][j] = paren_levels_temp[i][j];\n      |   \
    \                                                           ^\n"
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.push_back(0);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n\
    \    paren_levels.push_back(1);\n    paren_levels.push_back(1);\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpk284u08m: /tmp/tmpk284u08m.cpp:85: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of('(')).split(' ');\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.reserve(paren_levels.size());\n    for (long i = 0; i <\
    \ paren_levels.size(); i++) {\n        paren_levels_temp.push_back(paren_levels[i]);\n\
    \    }\n    long paren_levels_size = paren_levels_temp.size();\n    long paren_levels_max_size\
    \ = paren_levels_temp[paren_levels_size - 1];\n    long paren_levels_max_size2\
    \ = paren_levels_temp[paren_levels_size - 2];\n    long paren_levels_max_size3\
    \ = paren_levels_temp[paren_levels_size - 3];\n    long paren_levels_max_size4\
    \ = paren_levels_temp[paren_levels_size - 4];\n    long paren_levels_max_size5\
    \ = paren_levels_temp[paren_levels_size - 5];\n    long paren_levels_max_size6\
    \ = paren_levels_temp[paren_levels_size - 6];\n    long paren_levels_max_size7\
    \ = paren_levels_temp[paren_levels_size - 7];\n    long paren_levels_max_size8\
    \ = paren_levels_temp[paren_levels_size - 8];\n    long paren_levels_max_size9\
    \ = paren_levels_temp[paren_levels_size - 9];\n    long paren_levels_max_size10\
    \ = paren_levels_temp[paren_levels_size - 10];\n    long paren_levels_max_size11\
    \ = paren_levels_temp[paren_levels_size - 11];\n    long paren_levels_max_size12\
    \ = paren_levels_temp[paren_levels_size - 12];\n    long paren_levels_max_size13\
    \ = paren_levels_temp[paren_levels_size - 13];\n    long paren_levels_max_size14\
    \ = paren_levels_temp[paren_levels_size - 14];\n    long paren_levels_max_size15\
    \ = paren_levels_temp[paren_levels_size - 15];\n    long paren_levels_max_size16\
    \ = paren_levels_temp[paren_levels_size - 16];\n    long paren_levels_max_size17\
    \ = paren_levels_temp[paren_levels_size - 17];\n    long paren_levels_max_size18\
    \ = paren_levels_temp[paren_levels_size - 18];\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpqj_dq8pl.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpqj_dq8pl.cpp:10:76: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find_first_of('(')).split(' ');\n      |                      \
    \                                                      ^~~~~\n/tmp/tmpqj_dq8pl.cpp:35:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   35 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113006
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::vector<long>\
    \ paren_levels_temp;\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n\
    \    paren_levels_temp.push_back(0);\n    paren_levels_temp.push_back(0);\n  \
    \  paren_levels_temp.\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppyrgz7ym.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmppyrgz7ym.cpp:66:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   66 | }\n      | ^\n/tmp/tmppyrgz7ym.cpp:66:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels.reserve(paren_string.size());\n\
    \  long current_level = 0;\n  long paren_level = 0;\n  for (char c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_level++;\n    } else if (c == ')') {\n \
    \     paren_level--;\n    }\n    if (paren_level == current_level) {\n      paren_levels.push_back(paren_level);\n\
    \    }\n    current_level = paren_level;\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvku133h2: /tmp/tmpvku133h2.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long current_level\
    \ = 0;\n    bool is_open = false;\n    for (auto c : paren_string) {\n       \
    \ if (c == '(') {\n            is_open = true;\n            current_level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            current_level--;\n\
    \        }\n        if (is_open) {\n            paren_levels.push_back(current_level);\n\
    \        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp_cq78gg4: /tmp/tmp_cq78gg4.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = paren_string.split(\"\
    \ \");\n  long max_level = 0;\n  for (long i = 0; i < paren_levels.size(); i++)\
    \ {\n    if (paren_levels[i] > max_level) {\n      max_level = paren_levels[i];\n\
    \    }\n  }\n  std::vector<long> result;\n  result.push_back(max_level);\n  return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqqbl4aeo.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpqqbl4aeo.cpp:10:31: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |   paren_levels = paren_string.split(\" \");\n      |               \
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    std::string current_paren_string\
    \ = paren_string;\n    long current_paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    bool is_first_paren = true;\n    while (true) {\n        if (current_paren_string\
    \ == \"()\") {\n            paren_levels[paren_level_counter] = current_paren_level;\n\
    \            paren_level_counter++;\n            current_paren_string = \"\";\n\
    \            current_paren_level = 0;\n            is_first_paren = true;\n  \
    \      } else if (current_paren_string == \"(\") {\n            if (is_first_paren)\
    \ {\n                is_first_paren = false;\n            } else {\n         \
    \       current_paren_level++;\n            }\n            current_paren_string\
    \ = \"\";\n        } else if (current_paren_string == \")\") {\n            if\
    \ (is_first_paren) {\n                is_first_paren = false;\n            } else\
    \ {\n                current_paren_level--;\n            }\n            current_paren_string\
    \ = \"\";\n        } else {\n            current_paren_string += current_paren_string;\n\
    \        }\n        if (current_paren_level == 0) {\n            break;\n    \
    \    }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwmxm0a7w: /tmp/tmpwmxm0a7w.cpp:46: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp4laxqzzj: /tmp/tmp4laxqzzj.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    long current_level\
    \ = 0;\n    long max_level = 0;\n    bool is_open = false;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            is_open = true;\n    \
    \        current_level++;\n        } else if (c == ')') {\n            is_open\
    \ = false;\n            current_level--;\n        } else if (is_open) {\n    \
    \        current_level++;\n            if (current_level > max_level) {\n    \
    \            max_level = current_level;\n            }\n        }\n    }\n   \
    \ paren_levels.push_back(max_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpi0j2x1bo: /tmp/tmpi0j2x1bo.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp4laxqzzj: /tmp/tmp4laxqzzj.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660112998
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    bool paren_open = false;\n    bool paren_close\
    \ = false;\n    bool paren_opening_paren = false;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        char c = paren_string[i];\n        if (c\
    \ == '(') {\n            paren_opening_paren = true;\n            paren_open =\
    \ true;\n            paren_level++;\n        }\n        else if (c == ')') {\n\
    \            paren_opening_paren = false;\n            paren_close = true;\n \
    \           paren_level--;\n        }\n        else if (c == ' ') {\n        \
    \    if (paren_opening_paren) {\n                paren_level++;\n            }\n\
    \            else if (paren_close) {\n                paren_level--;\n       \
    \     }\n        }\n        else if (paren_opening_paren) {\n            paren_open\
    \ = false;\n        }\n        paren_levels.push_back(paren_level);\n    }\n \
    \   return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp7boinp36: /tmp/tmp7boinp36.cpp:44: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113006
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(paren_level);\n            paren_level++;\n\
    \        } else if (c == ')') {\n            paren_level--;\n        }\n    }\n\
    \    paren_levels.push_back(paren_level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpoi57am02: /tmp/tmpoi57am02.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113004
