language: cpp
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_extension = 0;\n    int sm_extension = 0;\n\
    \    for (auto &extension : extensions) {\n        if (extension.at(0) == class_name[0])\
    \ {\n            cap_extension++;\n        }\n        if (extension.at(1) == class_name[1])\
    \ {\n            sm_extension++;\n        }\n    }\n    if (cap_extension - sm_extension\
    \ > 0) {\n        strongest_extension = class_name + extensions[cap_extension\
    \ - sm_extension];\n    }\n    return strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdt4kxgkp.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpdt4kxgkp.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for (auto &extension : extensions) {\n                ^\n/tmp/tmpdt4kxgkp.cpp:24:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmpdt4kxgkp.cpp:25:23:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         if (extension.at(0) == class_name[0]) {\n                       ^\n\
    /tmp/tmpdt4kxgkp.cpp:28:23: error: request for member 'at' in 'extension', which\
    \ is of non-class type 'int'\n         if (extension.at(1) == class_name[1]) {\n\
    \                       ^\n/tmp/tmpdt4kxgkp.cpp: In function 'int main()':\n/tmp/tmpdt4kxgkp.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdt4kxgkp.cpp:2:\n/tmp/tmpdt4kxgkp.cpp:39:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpdt4kxgkp.cpp:39:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpdt4kxgkp.cpp:39:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    \n    int cap_extension = 0;\n    int sm_extension\
    \ = 0;\n    \n    for(auto extension : extensions) {\n        cap_extension =\
    \ std::count_if(extension.begin(), extension.end(), [](char c){ return std::isupper(c);\
    \ });\n        sm_extension = std::count_if(extension.begin(), extension.end(),\
    \ [](char c){ return std::islower(c); });\n        \n        float strength =\
    \ cap_extension - sm_extension;\n        \n        if(strength > 0) {\n      \
    \      strongest_extension = class_name + \".\" + extension;\n            break;\n\
    \        }\n    }\n    \n    return strongest_extension;\n}\nint main() {\n  \
    \  auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"),\
    \ (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpabwz7ed2.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpabwz7ed2.cpp:27:14: error:\
    \ 'extension' does not name a type\n     for(auto extension : extensions) {\n\
    \              ^\n/tmp/tmpabwz7ed2.cpp:39:5: error: expected ';' before 'return'\n\
    \     return strongest_extension;\n     ^\n/tmp/tmpabwz7ed2.cpp:39:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpabwz7ed2.cpp:39:5: error: expected\
    \ ';' before 'return'\n/tmp/tmpabwz7ed2.cpp:39:5: error: expected primary-expression\
    \ before 'return'\n/tmp/tmpabwz7ed2.cpp:39:5: error: expected ')' before 'return'\n\
    /tmp/tmpabwz7ed2.cpp: In function 'int main()':\n/tmp/tmpabwz7ed2.cpp:42:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpabwz7ed2.cpp:2:\n/tmp/tmpabwz7ed2.cpp:43:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpabwz7ed2.cpp:43:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpabwz7ed2.cpp:43:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpabwz7ed2.cpp:43:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int strongest_extension_strength = 0;\n   \
    \ \n    for (int i = 0; i < extensions.size(); i++) {\n        int extension_strength\
    \ = extensions[i].length() - extensions[i].find_first_not_of(\" \");\n       \
    \ if (extension_strength > strongest_extension_strength) {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extensions[i];\n  \
    \      }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo5wk35hs.cpp: In function 'int main()':\n/tmp/tmpo5wk35hs.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpo5wk35hs.cpp:2:\n/tmp/tmpo5wk35hs.cpp:37:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpo5wk35hs.cpp:37:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpo5wk35hs.cpp:37:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpo5wk35hs.cpp:37:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpo5wk35hs.cpp:37:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpo5wk35hs.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/subst"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto &extension : extensions)\
    \ {\n        cap += (extension.at(0) - 'A');\n        sm += (extension.at(1) -\
    \ 'a');\n    }\n    float strength = cap - sm;\n    int index = 0;\n    for (auto\
    \ &extension : extensions) {\n        if (extension.at(0) == class_name.at(0))\
    \ {\n            if (strength > index) {\n                strongest_extension\
    \ = class_name + \".\" + extension;\n                break;\n            }\n \
    \           index++;\n        }\n    }\n    return strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphk3k4lkd.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmphk3k4lkd.cpp:23:16: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for (auto &extension : extensions) {\n                ^\n/tmp/tmphk3k4lkd.cpp:23:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmphk3k4lkd.cpp:24:27:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         cap += (extension.at(0) - 'A');\n                           ^\n/tmp/tmphk3k4lkd.cpp:25:26:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         sm += (extension.at(1) - 'a');\n                          ^\n/tmp/tmphk3k4lkd.cpp:29:16:\
    \ error: ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n\
    \     for (auto &extension : extensions) {\n                ^\n/tmp/tmphk3k4lkd.cpp:29:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmphk3k4lkd.cpp:30:23:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         if (extension.at(0) == class_name.at(0)) {\n                       ^\n\
    /tmp/tmphk3k4lkd.cpp:32:56: error: no match for 'operator+' (operand types are\
    \ 'std::basic_string<char>' and 'int')\n                 strongest_extension =\
    \ class_name + \".\" + extension;\n                                          \
    \              ^\n/tmp/tmphk3k4lkd.cpp:32:56: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n      \
    \           from /tmp/tmphk3k4lkd.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__plus, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__plus, _Tp>::result_type>\
    \ std::operator+(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(+,\
    \ __plus)\n ^\n/usr/include/c++/4"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int strongest_extension_strength = 0;\n   \
    \ \n    for (auto &extension : extensions) {\n        int extension_strength =\
    \ extension.size()-extension.find_first_not_of(std::string(\"\"));\n        if\
    \ (extension_strength > strongest_extension_strength) {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    \n    return class_name + \".\" + strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc5zhcl7j.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpc5zhcl7j.cpp:25:16: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for (auto &extension : extensions) {\n                ^\n/tmp/tmpc5zhcl7j.cpp:25:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmpc5zhcl7j.cpp:26:44:\
    \ error: request for member 'size' in 'extension', which is of non-class type\
    \ 'int'\n         int extension_strength = extension.size()-extension.find_first_not_of(std::string(\"\
    \"));\n                                            ^\n/tmp/tmpc5zhcl7j.cpp:26:61:\
    \ error: request for member 'find_first_not_of' in 'extension', which is of non-class\
    \ type 'int'\n         int extension_strength = extension.size()-extension.find_first_not_of(std::string(\"\
    \"));\n                                                             ^\n/tmp/tmpc5zhcl7j.cpp:\
    \ In function 'int main()':\n/tmp/tmpc5zhcl7j.cpp:36:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = Strongest_Extension;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpc5zhcl7j.cpp:2:\n/tmp/tmpc5zhcl7j.cpp:37:60: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpc5zhcl7j.cpp:37:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &extension : extensions) {\n        cap += extension.at(0) - 'A';\n        sm\
    \ += extension.at(1) - 'a';\n    }\n    if (cap - sm == 0) {\n        strongest_extension\
    \ = class_name;\n    } else {\n        strongest_extension = class_name + extensions[extensions.size()\
    \ - 1] + std::to_string(cap - sm);\n    }\n    return strongest_extension;\n}\n\
    int main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpel0j03er.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpel0j03er.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for (auto &extension : extensions) {\n                ^\n/tmp/tmpel0j03er.cpp:24:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmpel0j03er.cpp:25:26:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         cap += extension.at(0) - 'A';\n                          ^\n/tmp/tmpel0j03er.cpp:26:25:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         sm += extension.at(1) - 'a';\n                         ^\n/tmp/tmpel0j03er.cpp:31:80:\
    \ error: 'to_string' is not a member of 'std'\n         strongest_extension =\
    \ class_name + extensions[extensions.size() - 1] + std::to_string(cap - sm);\n\
    \                                                                            \
    \    ^\n/tmp/tmpel0j03er.cpp: In function 'int main()':\n/tmp/tmpel0j03er.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpel0j03er.cpp:2:\n/tmp/tmpel0j03er.cpp:37:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpel0j03er.cpp:37:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eI"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    int cap_counter = 0;\n    int sm_counter = 0;\n    for (auto extension :\
    \ extensions) {\n        cap_counter += extension.at(0) - 'A';\n        sm_counter\
    \ += extension.at(1) - 'a';\n    }\n    if (cap_counter > sm_counter) {\n    \
    \    strongest_extension = class_name + \".\" + extensions[0];\n    } else {\n\
    \        strongest_extension = class_name + \".\" + extensions[1];\n    }\n  \
    \  return strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgnmcddoj.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpgnmcddoj.cpp:23:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpgnmcddoj.cpp:27:5: error: expected ';' before 'if'\n\
    \     if (cap_counter > sm_counter) {\n     ^\n/tmp/tmpgnmcddoj.cpp:27:5: error:\
    \ expected primary-expression before 'if'\n/tmp/tmpgnmcddoj.cpp:27:5: error: expected\
    \ ';' before 'if'\n/tmp/tmpgnmcddoj.cpp:27:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpgnmcddoj.cpp:27:5: error: expected ')' before 'if'\n/tmp/tmpgnmcddoj.cpp:\
    \ In function 'int main()':\n/tmp/tmpgnmcddoj.cpp:35:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = Strongest_Extension;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpgnmcddoj.cpp:2:\n/tmp/tmpgnmcddoj.cpp:36:60: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpgnmcddoj.cpp:36:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpgnmcddoj.cpp:36:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgnmcddoj.cpp:36:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpgnmcd"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sm_counter = 0;\n  \
    \  for(auto &extension : extensions) {\n        if(extension.at(0) == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        if(extension.at(1) == class_name[1])\
    \ {\n            sm_counter++;\n        }\n    }\n    double strength = cap_counter\
    \ - sm_counter;\n    double strength_percentage = strength / cap_counter;\n  \
    \  double strength_percentage_rounded = round(strength_percentage);\n    double\
    \ strength_percentage_rounded_down = floor(strength_percentage_rounded);\n   \
    \ double strength_percentage_rounded_up = ceil(strength_percentage_rounded);\n\
    \    double strength_percentage_rounded_down = round(strength_percentage_rounded);\n\
    \    if(strength_percentage_rounded_down == strength_percentage_rounded) {\n \
    \       strongest_extension = class_name + \".\" + extensions[0];\n    }\n   \
    \ else if(strength_percentage_rounded_up == strength_percentage_rounded) {\n \
    \       strongest_extension = class_name + \".\" + extensions[2];\n    }\n   \
    \ else {\n        strongest_extension = class_name + \".\" + extensions[strength_percentage_rounded_down];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7q2baszw.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp7q2baszw.cpp:24:15: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for(auto &extension : extensions) {\n               ^\n/tmp/tmp7q2baszw.cpp:24:27:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for(auto\
    \ &extension : extensions) {\n                           ^\n/tmp/tmp7q2baszw.cpp:25:22:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         if(extension.at(0) == class_name[0]) {\n                      ^\n/tmp/tmp7q2baszw.cpp:28:22:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         if(extension.at(1) == class_name[1]) {\n                      ^\n/tmp/tmp7q2baszw.cpp:37:12:\
    \ error: redeclaration of 'double strength_percentage_rounded_down'\n     double\
    \ strength_percentage_rounded_down = round(strength_percentage_rounded);\n   \
    \         ^\n/tmp/tmp7q2baszw.cpp:35:12: error: 'double strength_percentage_rounded_down'\
    \ previously declared here\n     double strength_percentage_rounded_down = floor(strength_percentage_rounded);\n\
    \            ^\n/tmp/tmp7q2baszw.cpp: In function 'int main()':\n/tmp/tmp7q2baszw.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7q2baszw.cpp:2:\n/tmp/tmp7q2baszw.cpp:51:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmp7q2baszw.cpp:51:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     asse"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    \n\
    \    std::string strongest_extension = \"\";\n    \n    for(int i = 0; i < extensions.size();\
    \ i++){\n        std::string extension = extensions[i];\n        \n        for(int\
    \ j = 0; j < extension.size(); j++){\n            char c = extension[j];\n   \
    \         \n            if(c == toupper(extension[j])){\n                strongest_extension\
    \ += c;\n            }\n        }\n    }\n    \n    return class_name + \".\"\
    \ + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgrft9pd1.cpp: In function 'int main()':\n/tmp/tmpgrft9pd1.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgrft9pd1.cpp:2:\n/tmp/tmpgrft9pd1.cpp:40:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpgrft9pd1.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpgrft9pd1.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpgrft9pd1.cpp:40:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpgrft9pd1.cpp:40:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpgrft9pd1.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/subst"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_letters = 0, sm_letters\
    \ = 0;\n    for (auto &ext : extensions) {\n        cap_letters += ext.length();\n\
    \        sm_letters += ext.length();\n    }\n    int strength = cap_letters -\
    \ sm_letters;\n    if (strength > 0) {\n        auto it = std::min_element(extensions.begin(),\
    \ extensions.end(), \n            [](std::string a, std::string b) { return a.length()\
    \ < b.length(); });\n        std::string extension = class_name + \".\" + extensions[it\
    \ - extensions.begin()];\n        return extension;\n    }\n    return class_name;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfi41p3_f.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpfi41p3_f.cpp:21:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmpfi41p3_f.cpp:21:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmpfi41p3_f.cpp:22:28: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap_letters\
    \ += ext.length();\n                            ^\n/tmp/tmpfi41p3_f.cpp:23:27:\
    \ error: request for member 'length' in 'ext', which is of non-class type 'int'\n\
    \         sm_letters += ext.length();\n                           ^\n/tmp/tmpfi41p3_f.cpp:27:14:\
    \ error: 'it' does not name a type\n         auto it = std::min_element(extensions.begin(),\
    \ extensions.end(), \n              ^\n/tmp/tmpfi41p3_f.cpp:28:81: error: expected\
    \ primary-expression before ')' token\n             [](std::string a, std::string\
    \ b) { return a.length() < b.length(); });\n                                 \
    \                                                ^\n/tmp/tmpfi41p3_f.cpp:28:81:\
    \ error: expected ';' before ')' token\n/tmp/tmpfi41p3_f.cpp:29:63: error: 'it'\
    \ was not declared in this scope\n         std::string extension = class_name\
    \ + \".\" + extensions[it - extensions.begin()];\n                           \
    \                                    ^\n/tmp/tmpfi41p3_f.cpp: In function 'int\
    \ main()':\n/tmp/tmpfi41p3_f.cpp:35:10: error: 'candidate' does not name a type\n\
    \     auto candidate = Strongest_Extension;\n          ^\nIn file included from\
    \ /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfi41p3_f.cpp:2:\n/tmp/tmpfi41p3_f.cpp:36:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"ni"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int strongest_extension_strength = 0;\n   \
    \ \n    for (auto extension : extensions) {\n        auto cap = extension.find_first_of('A');\n\
    \        auto sm = extension.find_first_of('l');\n        auto strength = cap\
    \ - sm;\n        if (strength > strongest_extension_strength) {\n            strongest_extension_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    \n    return class_name + \".\" + strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptdp1_7qy.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmptdp1_7qy.cpp:25:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmptdp1_7qy.cpp:35:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmptdp1_7qy.cpp:35:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmptdp1_7qy.cpp:35:5:\
    \ error: expected ';' before 'return'\n/tmp/tmptdp1_7qy.cpp:35:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmptdp1_7qy.cpp:35:5: error: expected\
    \ ')' before 'return'\n/tmp/tmptdp1_7qy.cpp: In function 'int main()':\n/tmp/tmptdp1_7qy.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptdp1_7qy.cpp:2:\n/tmp/tmptdp1_7qy.cpp:39:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmptdp1_7qy.cpp:39:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmptdp1_7qy.cpp:39:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmptdp1_7qy.cpp:39:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_num = 0, sm_num = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap_num += ext.length();\n        sm_num += ext.length()\
    \ - 1;\n    }\n    float strength = cap_num - sm_num;\n    if (strength > 0) {\n\
    \        strongest_extension = class_name + \".\" + extensions[0];\n    }\n  \
    \  for (auto &ext : extensions) {\n        if (ext.length() == strongest_extension.length())\
    \ {\n            if (ext.compare(0, strongest_extension.length(), strongest_extension)\
    \ == 0) {\n                strongest_extension = class_name + \".\" + ext;\n \
    \           }\n        }\n    }\n    return strongest_extension;\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmhkv1s_r.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpmhkv1s_r.cpp:23:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmpmhkv1s_r.cpp:23:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmpmhkv1s_r.cpp:24:24: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap_num\
    \ += ext.length();\n                        ^\n/tmp/tmpmhkv1s_r.cpp:25:23: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      sm_num += ext.length() - 1;\n                       ^\n/tmp/tmpmhkv1s_r.cpp:31:16:\
    \ error: ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n  \
    \   for (auto &ext : extensions) {\n                ^\n/tmp/tmpmhkv1s_r.cpp:31:22:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &ext : extensions) {\n                      ^\n/tmp/tmpmhkv1s_r.cpp:32:17: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      if (ext.length() == strongest_extension.length()) {\n                 ^\n\
    /tmp/tmpmhkv1s_r.cpp:33:21: error: request for member 'compare' in 'ext', which\
    \ is of non-class type 'int'\n             if (ext.compare(0, strongest_extension.length(),\
    \ strongest_extension) == 0) {\n                     ^\n/tmp/tmpmhkv1s_r.cpp:34:56:\
    \ error: no match for 'operator+' (operand types are 'std::basic_string<char>'\
    \ and 'int')\n                 strongest_extension = class_name + \".\" + ext;\n\
    \                                                        ^\n/tmp/tmpmhkv1s_r.cpp:34:56:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpmhkv1s_r.cpp:2:\n/usr/include/c++/4.8.2/valarray:1167:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__plus, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::_"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto &extension : extensions) {\n        if (extension.at(0) ==\
    \ class_name[0]) {\n            cap_counter++;\n        }\n        if (extension.at(1)\
    \ == class_name[1]) {\n            sm_counter++;\n        }\n    }\n    if (cap_counter\
    \ > sm_counter) {\n        strongest_extension = class_name + \".\" + extensions[0];\n\
    \    }\n    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp94z7okeh.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp94z7okeh.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for (auto &extension : extensions) {\n                ^\n/tmp/tmp94z7okeh.cpp:24:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmp94z7okeh.cpp:25:23:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         if (extension.at(0) == class_name[0]) {\n                       ^\n\
    /tmp/tmp94z7okeh.cpp:28:23: error: request for member 'at' in 'extension', which\
    \ is of non-class type 'int'\n         if (extension.at(1) == class_name[1]) {\n\
    \                       ^\n/tmp/tmp94z7okeh.cpp: In function 'int main()':\n/tmp/tmp94z7okeh.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp94z7okeh.cpp:2:\n/tmp/tmp94z7okeh.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmp94z7okeh.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmp94z7okeh.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension;\n    int cap_counter = 0;\n    int sm_counter = 0;\n  \
    \  for (auto &extension : extensions) {\n        if (extension.at(0) == class_name[0])\
    \ {\n            cap_counter++;\n        }\n        if (extension.at(1) == class_name[1])\
    \ {\n            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpltehi3e7.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpltehi3e7.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'extension' with no type [-fpermissive]\n   \
    \  for (auto &extension : extensions) {\n                ^\n/tmp/tmpltehi3e7.cpp:24:28:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &extension : extensions) {\n                            ^\n/tmp/tmpltehi3e7.cpp:25:23:\
    \ error: request for member 'at' in 'extension', which is of non-class type 'int'\n\
    \         if (extension.at(0) == class_name[0]) {\n                       ^\n\
    /tmp/tmpltehi3e7.cpp:28:23: error: request for member 'at' in 'extension', which\
    \ is of non-class type 'int'\n         if (extension.at(1) == class_name[1]) {\n\
    \                       ^\n/tmp/tmpltehi3e7.cpp: In function 'int main()':\n/tmp/tmpltehi3e7.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpltehi3e7.cpp:2:\n/tmp/tmpltehi3e7.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpltehi3e7.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpltehi3e7.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -st"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap_counter = 0;\n    int sm_counter =\
    \ 0;\n    for (auto e : extensions) {\n        if (e.at(0) == class_name[0]) {\n\
    \            cap_counter++;\n        }\n        if (e.at(1) == class_name[1])\
    \ {\n            sm_counter++;\n        }\n    }\n    if (cap_counter > sm_counter)\
    \ {\n        strongest_extension = class_name + \".\" + extensions[0];\n    }\n\
    \    else {\n        strongest_extension = class_name + \".\" + extensions[1];\n\
    \    }\n    return strongest_extension;\n}\nint main() {\n    auto candidate =\
    \ Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuvrekst7.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpuvrekst7.cpp:24:15: error:\
    \ 'e' does not name a type\n     for (auto e : extensions) {\n               ^\n\
    /tmp/tmpuvrekst7.cpp:32:5: error: expected ';' before 'if'\n     if (cap_counter\
    \ > sm_counter) {\n     ^\n/tmp/tmpuvrekst7.cpp:32:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpuvrekst7.cpp:32:5: error: expected ';' before 'if'\n/tmp/tmpuvrekst7.cpp:32:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpuvrekst7.cpp:32:5: error:\
    \ expected ')' before 'if'\n/tmp/tmpuvrekst7.cpp: In function 'int main()':\n\
    /tmp/tmpuvrekst7.cpp:41:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = Strongest_Extension;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuvrekst7.cpp:2:\n/tmp/tmpuvrekst7.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpuvrekst7.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpuvrekst7.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuvrekst7.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpuvrekst7.cpp:42:128: "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    \n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    \n    for\
    \ (int i = 0; i < extensions.size(); i++) {\n        cap = extensions[i].size();\n\
    \        sm = cap - 1;\n        if (cap > sm) {\n            strongest_extension\
    \ = class_name + \".\" + extensions[i];\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmo1_xujc.cpp: In function 'int main()':\n/tmp/tmpmo1_xujc.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmo1_xujc.cpp:2:\n/tmp/tmpmo1_xujc.cpp:37:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpmo1_xujc.cpp:37:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpmo1_xujc.cpp:37:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmo1_xujc.cpp:37:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpmo1_xujc.cpp:37:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpmo1_xujc.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/subst"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ i : extensions) {\n        cap += i[0]-'A';\n        sm += i[1]-'a';\n    }\n\
    \    float strength = cap - sm;\n    if (strength > 0) {\n        strongest_extension\
    \ = class_name + \".\" + extensions[0];\n    }\n    else {\n        for (auto\
    \ i : extensions) {\n            if (i[0] == extensions[0][0] && i[1] == extensions[0][1])\
    \ {\n                strongest_extension = class_name + \".\" + i;\n         \
    \       break;\n            }\n        }\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4b_1i789.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp4b_1i789.cpp:24:15: error:\
    \ 'i' does not name a type\n     for (auto i : extensions) {\n               ^\n\
    /tmp/tmp4b_1i789.cpp:28:5: error: expected ';' before 'float'\n     float strength\
    \ = cap - sm;\n     ^\n/tmp/tmp4b_1i789.cpp:29:5: error: expected primary-expression\
    \ before 'if'\n     if (strength > 0) {\n     ^\n/tmp/tmp4b_1i789.cpp:29:5: error:\
    \ expected ')' before 'if'\n/tmp/tmp4b_1i789.cpp:33:19: error: 'i' does not name\
    \ a type\n         for (auto i : extensions) {\n                   ^\n/tmp/tmp4b_1i789.cpp:39:5:\
    \ error: expected ';' before '}' token\n     }\n     ^\n/tmp/tmp4b_1i789.cpp:39:5:\
    \ error: expected primary-expression before '}' token\n/tmp/tmp4b_1i789.cpp:39:5:\
    \ error: expected ';' before '}' token\n/tmp/tmp4b_1i789.cpp:39:5: error: expected\
    \ primary-expression before '}' token\n/tmp/tmp4b_1i789.cpp:39:5: error: expected\
    \ ')' before '}' token\n/tmp/tmp4b_1i789.cpp:39:5: error: expected primary-expression\
    \ before '}' token\n/tmp/tmp4b_1i789.cpp:39:5: error: expected ';' before '}'\
    \ token\n/tmp/tmp4b_1i789.cpp: In function 'int main()':\n/tmp/tmp4b_1i789.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4b_1i789.cpp:2:\n/tmp/tmp4b_1i789.cpp:44:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmp4b_1i789.cpp:44:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\","
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int cap_num = 0, sm_num = 0;\n \
    \   for (auto &ext : extensions) {\n        cap_num += ext.length();\n       \
    \ sm_num += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n  \
    \  }\n    int cap = cap_num / sm_num;\n    int sm = cap_num - cap * sm_num;\n\
    \    int strength = cap - sm;\n    for (auto &ext : extensions) {\n        if\
    \ (ext.length() == cap) {\n            if (strength > 0) {\n                return\
    \ class_name + \".\" + ext;\n            }\n        }\n    }\n    return class_name;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph8a12_pw.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmph8a12_pw.cpp:21:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmph8a12_pw.cpp:21:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmph8a12_pw.cpp:22:24: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap_num\
    \ += ext.length();\n                        ^\n/tmp/tmph8a12_pw.cpp:23:23: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      sm_num += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n\
    \                       ^\n/tmp/tmph8a12_pw.cpp:23:38: error: request for member\
    \ 'find_first_not_of' in 'ext', which is of non-class type 'int'\n         sm_num\
    \ += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n         \
    \                             ^\n/tmp/tmph8a12_pw.cpp:23:60: error: request for\
    \ member 'begin' in 'ext', which is of non-class type 'int'\n         sm_num +=\
    \ ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n            \
    \                                                ^\n/tmp/tmph8a12_pw.cpp:23:73:\
    \ error: request for member 'end' in 'ext', which is of non-class type 'int'\n\
    \         sm_num += ext.length() - ext.find_first_not_of(ext.begin(), ext.end());\n\
    \                                                                         ^\n\
    /tmp/tmph8a12_pw.cpp:28:16: error: ISO C++ forbids declaration of 'ext' with no\
    \ type [-fpermissive]\n     for (auto &ext : extensions) {\n                ^\n\
    /tmp/tmph8a12_pw.cpp:28:22: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (auto &ext : extensions) {\n                      ^\n/tmp/tmph8a12_pw.cpp:29:17:\
    \ error: request for member 'length' in 'ext', which is of non-class type 'int'\n\
    \         if (ext.length() == cap) {\n                 ^\n/tmp/tmph8a12_pw.cpp:31:41:\
    \ error: no"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Your code here\n    std::string\
    \ strongest_extension = \"\";\n    std::string extension_strength = \"\";\n  \
    \  std::string extension_class = \"\";\n    std::string extension_class_name =\
    \ \"\";\n    std::string extension_class_name_with_extension = \"\";\n    std::string\
    \ extension_class_name_with_extension_strength = \"\";\n    std::string extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name = \"\
    \";\n    std::string extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_strength\
    \ = \"\";\n    std::string extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_with_extension_class_name_\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphz220v2u.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmphz220v2u.cpp:46:1: error:\
    \ expected initializer before '}' token\n }\n ^\n/tmp/tmphz220v2u.cpp: In function\
    \ 'int main()':\n/tmp/tmphz220v2u.cpp:48:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = Strongest_Extension;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphz220v2u.cpp:2:\n/tmp/tmphz220v2u.cpp:49:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmphz220v2u.cpp:49:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmphz220v2u.cpp:49:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmphz220v2u.cpp:49:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmphz220v2u.cpp:49:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmphz220v2u.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _In"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a vector of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the vector.\n\
    // For example, if you are given \"Slices\" as the class and a vector of the\n\
    // extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ &ext : extensions) {\n        cap += ext.length();\n        sm += ext.length();\n\
    \    }\n    float strength = cap - sm;\n    int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [&](std::string a, std::string\
    \ b) { return a.length() < b.length(); }));\n    if (strength == -1) {\n     \
    \   strongest_extension = class_name;\n    } else {\n        strongest_extension\
    \ = class_name + \".\" + extensions[index];\n    }\n    return strongest_extension;\n\
    }\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpngt3a7cd.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpngt3a7cd.cpp:24:16: error:\
    \ ISO C++ forbids declaration of 'ext' with no type [-fpermissive]\n     for (auto\
    \ &ext : extensions) {\n                ^\n/tmp/tmpngt3a7cd.cpp:24:22: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (auto &ext :\
    \ extensions) {\n                      ^\n/tmp/tmpngt3a7cd.cpp:25:20: error: request\
    \ for member 'length' in 'ext', which is of non-class type 'int'\n         cap\
    \ += ext.length();\n                    ^\n/tmp/tmpngt3a7cd.cpp:26:19: error:\
    \ request for member 'length' in 'ext', which is of non-class type 'int'\n   \
    \      sm += ext.length();\n                   ^\n/tmp/tmpngt3a7cd.cpp:29:174:\
    \ warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     int index = std::distance(extensions.begin(), std::max_element(extensions.begin(),\
    \ extensions.end(), [&](std::string a, std::string b) { return a.length() < b.length();\
    \ }));\n                                                                     \
    \                                                                            \
    \                             ^\n/tmp/tmpngt3a7cd.cpp:29:175: error: no matching\
    \ function for call to 'max_element(std::vector<std::basic_string<char> >::iterator,\
    \ std::vector<std::basic_string<char> >::iterator, Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)::__lambda0)'\n     int index = std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end(), [&](std::string a, std::string\
    \ b) { return a.length() < b.length(); }));\n                                \
    \                                                                            \
    \                                                                   ^\n/tmp/tmpngt3a7cd.cpp:29:175:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/algorithm:62:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n\
    \              "
  stdout: ''
