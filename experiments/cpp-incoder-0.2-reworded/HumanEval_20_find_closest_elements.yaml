name: HumanEval_20_find_closest_elements
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of\
  \ numbers (of length at least two) select and return two that are the closest to\
  \ each\n// other and return them in order (smaller number, larger number).\n// >>>\
  \ find_closest_elements((std::vector<float>({(float)1.0, (float)2.0, (float)3.0,\
  \ (float)4.0, (float)5.0, (float)2.2})))\n// (std::make_tuple(2.0, 2.2))\n// >>>\
  \ find_closest_elements((std::vector<float>({(float)1.0, (float)2.0, (float)3.0,\
  \ (float)4.0, (float)5.0, (float)2.0})))\n// (std::make_tuple(2.0, 2.0))\nstd::tuple<float,\
  \ float> find_closest_elements(std::vector<float> numbers) {\n"
tests: "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.9, (float)4.0, (float)5.0, (float)2.2}))) == (std::make_tuple(3.9,\
  \ 4.0)));\n    assert(candidate((std::vector<float>({(float)1.0, (float)2.0, (float)5.9,\
  \ (float)4.0, (float)5.0}))) == (std::make_tuple(5.0, 5.9)));\n    assert(candidate((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0, (float)2.2}))) == (std::make_tuple(2.0,\
  \ 2.2)));\n    assert(candidate((std::vector<float>({(float)1.0, (float)2.0, (float)3.0,\
  \ (float)4.0, (float)5.0, (float)2.0}))) == (std::make_tuple(2.0, 2.0)));\n    assert(candidate((std::vector<float>({(float)1.1,\
  \ (float)2.2, (float)3.1, (float)4.1, (float)5.1}))) == (std::make_tuple(2.2, 3.1)));\n\
  }\n"
completions: ["    assert(numbers.size() > 1);\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - numbers[0]);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n        }\n        if (distance > largest_distance) {\n         \
    \   largest_distance = distance;\n        }\n    }\n    return std::make_tuple(smallest_distance,\
    \ largest_distance);", "    // Your code here\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest || smallest == largest) {\n            smallest = number;\n\
    \        }\n        if (number > largest || largest == smallest) {\n         \
    \   largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest_number = numbers[0];\n    float largest_number\
    \ = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if\
    \ (numbers[i] < smallest_number) {\n            smallest_number = numbers[i];\n\
    \        } else if (numbers[i] > largest_number) {\n            largest_number\
    \ = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() >= 2);\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (auto number\
    \ : numbers) {\n        if (number < smallest_number) {\n            smallest_number\
    \ = number;\n        }\n        if (number > largest_number) {\n            largest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - smallest_distance);\n\
    \        if (distance < largest_distance) {\n            largest_distance = distance;\n\
    \        }\n        distance = std::abs(number - largest_distance);\n        if\
    \ (distance < smallest_distance) {\n            smallest_distance = distance;\n\
    \        }\n    }\n    return std::make_tuple(smallest_distance, largest_distance);",
  "    assert(numbers.size() > 1);\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (size_t i = 1;\
    \ i < numbers.size(); i++) {\n        float distance = std::abs(numbers[i] - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = numbers[i];\n        }\n        distance\
    \ = std::abs(numbers[i] - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = numbers[i];\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    assert(numbers.size() >= 2);\n    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float largest_diff = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (float number\
    \ : numbers) {\n        float diff = std::abs(number - smallest_number);\n   \
    \     if (diff < smallest_diff) {\n            smallest_diff = diff;\n       \
    \     smallest_number = number;\n        }\n        diff = std::abs(number - largest_number);\n\
    \        if (diff > largest_diff) {\n            largest_diff = diff;\n      \
    \      largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest_number = numbers[0];\n    float largest_number\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest_number)\
    \ {\n            smallest_number = number;\n        }\n        if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() > 1);\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (size_t i = 1;\
    \ i < numbers.size(); i++) {\n        if (numbers[i] < smallest_number) {\n  \
    \          smallest_number = numbers[i];\n        } else if (numbers[i] > largest_number)\
    \ {\n            largest_number = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < smallest_number) {\n            smallest_number\
    \ = numbers[i];\n        } else if (numbers[i] > largest_number) {\n         \
    \   largest_number = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() > 1);\n    float smallest_distance\
    \ = std::numeric_limits<float>::max();\n    float largest_distance = std::numeric_limits<float>::min();\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); ++i) {\n        float distance = std::abs(numbers[i]\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = numbers[i];\n\
    \        }\n        distance = std::abs(numbers[i] - largest_number);\n      \
    \  if (distance > largest_distance) {\n            largest_distance = distance;\n\
    \            largest_number = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest_number = numbers[0];\n    float largest_number\
    \ = numbers[0];\n    for (auto number : numbers) {\n        if (number < smallest_number)\
    \ {\n            smallest_number = number;\n        }\n        if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() > 1);\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (size_t i = 1;\
    \ i < numbers.size(); i++) {\n        if (numbers[i] < smallest_number) {\n  \
    \          smallest_number = numbers[i];\n        } else if (numbers[i] > largest_number)\
    \ {\n            largest_number = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        } else if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Find the smallest and largest numbers in the supplied vector\n\
    \    float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        } else if (number > largest) {\n            largest = number;\n\
    \        }\n    }\n    // Find the midpoint between the smallest and largest numbers\n\
    \    float midpoint = (smallest + largest) / 2;\n    // Find the two numbers that\
    \ are closest to each other\n    float closest_1 = midpoint - std::abs(smallest\
    \ - midpoint);\n    float closest_2 = midpoint + std::abs(smallest - midpoint);\n\
    \    // Return the two numbers in order\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    assert(numbers.size() > 1);\n    float smallest_distance\
    \ = std::numeric_limits<float>::max();\n    float largest_distance = std::numeric_limits<float>::min();\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        float distance = std::abs(numbers[i]\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = numbers[i];\n\
    \        } else if (distance > largest_distance) {\n            largest_distance\
    \ = distance;\n            largest_number = numbers[i];\n        }\n    }\n  \
    \  return std::make_tuple(smallest_number, largest_number);", "    // Find two\
    \ closest numbers to each other\n    float smallest_number = numbers[0];\n   \
    \ float largest_number = numbers[0];\n    for (float number : numbers) {\n   \
    \     if (number < smallest_number) {\n            smallest_number = number;\n\
    \        } else if (number > largest_number) {\n            largest_number = number;\n\
    \        }\n    }\n\n    // Return them in order (smaller number, larger number)\n\
    \    return std::make_tuple(smallest_number, largest_number);", "    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (auto number\
    \ : numbers) {\n        if (number < smallest_number) {\n            smallest_number\
    \ = number;\n        } else if (number > largest_number) {\n            largest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, largest_number);"]
stop_tokens:
- "\n}"
