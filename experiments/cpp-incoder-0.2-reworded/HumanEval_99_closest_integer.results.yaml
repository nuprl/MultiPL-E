language: cpp
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long sum2 = 0;\n    long sum3\
    \ = 0;\n    long sum4 = 0;\n    long sum5 = 0;\n    long sum6 = 0;\n    long sum7\
    \ = 0;\n    long sum8 = 0;\n    long sum9 = 0;\n    long sum10 = 0;\n    long\
    \ sum11 = 0;\n    long sum12 = 0;\n    long sum13 = 0;\n    long sum14 = 0;\n\
    \    long sum15 = 0;\n    long sum16 = 0;\n    long sum17 = 0;\n    long sum18\
    \ = 0;\n    long sum19 = 0;\n    long sum20 = 0;\n    long sum21 = 0;\n    long\
    \ sum22 = 0;\n    long sum23 = 0;\n    long sum24 = 0;\n    long sum25 = 0;\n\
    \    long sum26 = 0;\n    long sum27 = 0;\n    long sum28 = 0;\n    long sum29\
    \ = 0;\n    long sum30 = 0;\n    long sum31 = 0;\n    long sum32 = 0;\n    long\
    \ sum33 = 0;\n    long sum34 = 0;\n    long sum35 = 0;\n    long sum36 = 0;\n\
    \    long sum37 = 0;\n    long sum38 = 0;\n    long sum39 = 0;\n    long sum40\
    \ = 0;\n    long sum41 = 0;\n    long sum42 = 0;\n    long sum43 = 0;\n    long\
    \ sum44 = 0;\n    long sum45 = 0;\n    long sum46 = 0;\n    long sum47 = 0;\n\
    \    long sum48 = 0;\n    long sum49 = 0;\n    long sum50 = 0;\n    long sum51\
    \ = 0;\n    long sum52 = 0;\n    long sum53 = 0;\n    long sum54 = 0;\n    long\
    \ sum55 = 0;\n    long sum56 = 0;\n    long sum57 = 0;\n    long sum58 = 0;\n\
    \    long sum59 = 0;\n    long sum60 = 0;\n    long sum61 = 0;\n    long sum62\
    \ = 0;\n    long sum63 = 0;\n    long sum64 = 0;\n    long sum65 = 0;\n    long\
    \ sum66 = 0;\n    long sum67 = 0;\n    long sum68 = 0;\n    long sum69 = 0;\n\
    \    long sum70 = 0;\n    long sum71 = 0;\n    long sum72 = 0;\n    long sum73\
    \ = 0;\n    long sum74 = 0;\n    long sum75 = 0;\n    long sum76 = 0;\n    long\
    \ sum77 = 0;\n    long sum78 = 0;\n    long sum79 = 0;\n    long sum80 = 0;\n\
    \    long sum81 = 0;\n    long sum82 = 0;\n    long sum83 = 0;\n    long sum84\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7ug0qsbr.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmp7ug0qsbr.cpp:104:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmp7ug0qsbr.cpp: In function 'int main()':\n/tmp/tmp7ug0qsbr.cpp:106:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7ug0qsbr.cpp:2:\n/tmp/tmp7ug0qsbr.cpp:107:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff = diff * -1;\n    }\n    ans = temp;\n    if (diff == 0)\
    \ {\n        return ans;\n    }\n    if (diff > 0 && diff < 10) {\n        return\
    \ ans;\n    }\n    if (diff > 10 && diff < 100) {\n        return ans + 1;\n \
    \   }\n    if (diff > 100 && diff < 1000) {\n        return ans + 2;\n    }\n\
    \    if (diff > 1000 && diff < 10000) {\n        return ans + 3;\n    }\n    if\
    \ (diff > 10000 && diff < 100000) {\n        return ans + 4;\n    }\n    if (diff\
    \ > 100000 && diff < 1000000) {\n        return ans + 5;\n    }\n    if (diff\
    \ > 1000000 && diff < 10000000) {\n        return ans + 6;\n    }\n    if (diff\
    \ > 10000000 && diff < 100000000) {\n        return ans + 7;\n    }\n    if (diff\
    \ > 100000000 && diff < 1000000000) {\n        return ans + 8;\n    }\n    if\
    \ (diff > 1000000000 && diff < 10000000000) {\n        return ans + 9;\n    }\n\
    \    if (diff > 10000000000 && diff < 100000000000) {\n        return ans + 10;\n\
    \    }\n    if (diff > 100000000000 && diff < 1000000000000) {\n        return\
    \ ans + 11;\n    }\n    if (diff > 1000000000000 && diff < 10000000000000) {\n\
    \        return ans + 12;\n    }\n    if (diff > 10000000000000 && diff < 100000000000000)\
    \ {\n        return ans + 13;\n    }\n    if (diff > 100000000000000 && diff <\
    \ 1000000000000000) {\n        return ans + 14;\n    }\n    if (diff > 1000000000000000\
    \ && diff < 10000000000000000) {\n        return ans + 15;\n    }\n    if (diff\
    \ > 10000000000000000 && diff < 100000000000000000) {\n        return ans + 16;\n\
    \    }\n    if (diff > 100000000000000000 && diff < 1000000000000000000) {\n \
    \       return ans + 17;\n    }\n    if (diff > 1000000000000000000 && diff <\
    \ 10000000000000000000) {\n        return ans + 18;\n    }\n    if (diff > 10000000000000000000\
    \ && diff < 100000000000000000000) {\n        return ans + 19;\n    }\n    if\
    \ (diff > 100000000000000000000 && diff < 1000000000000000000000) {\n        return\
    \ ans + 20;\n    }\n    if (diff > 1000000000000000000000 && diff < 10000000000000000000000)\
    \ {\n        return ans + 21;\n    }\n    if (diff > 10000000000000000000000 &&\
    \ diff < 100000000000000000000000) {\n        return ans + 22;\n    }\n    if\
    \ (diff > 100000000000000000000000 && diff < 100\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4pektfa4.cpp:82:46: warning: integer constant is so large that\
    \ it is unsigned [enabled by default]\n     if (diff > 1000000000000000000 &&\
    \ diff < 10000000000000000000) {\n                                           \
    \   ^\n/tmp/tmp4pektfa4.cpp:82:5: warning: this decimal constant is unsigned only\
    \ in ISO C90 [enabled by default]\n     if (diff > 1000000000000000000 && diff\
    \ < 10000000000000000000) {\n     ^\n/tmp/tmp4pektfa4.cpp:85:16: warning: integer\
    \ constant is so large that it is unsigned [enabled by default]\n     if (diff\
    \ > 10000000000000000000 && diff < 100000000000000000000) {\n                ^\n\
    /tmp/tmp4pektfa4.cpp:85:5: warning: this decimal constant is unsigned only in\
    \ ISO C90 [enabled by default]\n     if (diff > 10000000000000000000 && diff <\
    \ 100000000000000000000) {\n     ^\n/tmp/tmp4pektfa4.cpp:85:47: warning: integer\
    \ constant is too large for its type [enabled by default]\n     if (diff > 10000000000000000000\
    \ && diff < 100000000000000000000) {\n                                       \
    \        ^\n/tmp/tmp4pektfa4.cpp:88:16: warning: integer constant is too large\
    \ for its type [enabled by default]\n     if (diff > 100000000000000000000 &&\
    \ diff < 1000000000000000000000) {\n                ^\n/tmp/tmp4pektfa4.cpp:88:48:\
    \ warning: integer constant is too large for its type [enabled by default]\n \
    \    if (diff > 100000000000000000000 && diff < 1000000000000000000000) {\n  \
    \                                              ^\n/tmp/tmp4pektfa4.cpp:91:16:\
    \ warning: integer constant is too large for its type [enabled by default]\n \
    \    if (diff > 1000000000000000000000 && diff < 10000000000000000000000) {\n\
    \                ^\n/tmp/tmp4pektfa4.cpp:91:49: warning: integer constant is too\
    \ large for its type [enabled by default]\n     if (diff > 1000000000000000000000\
    \ && diff < 10000000000000000000000) {\n                                     \
    \            ^\n/tmp/tmp4pektfa4.cpp:94:16: warning: integer constant is too large\
    \ for its type [enabled by default]\n     if (diff > 10000000000000000000000 &&\
    \ diff < 100000000000000000000000) {\n              "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int x = std::stoll(value);\n\
    \    long long int y = std::stoll(value);\n    long long int z = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int k = std::stoll(value);\n\
    \    long long int l = std::stoll(value);\n    long long int m = std::stoll(value);\n\
    \    long long int n = std::stoll(value);\n    long long int o = std::stoll(value);\n\
    \    long long int p = std::stoll(value);\n    long long int q = std::stoll(value);\n\
    \    long long int r = std::stoll(value);\n    long long int s = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int k = std::stoll(value);\n\
    \    long long int l = std::stoll(value);\n    long long int m = std::stoll(value);\n\
    \    long long int n = std::stoll(value);\n    long long int o = std::stoll(value);\n\
    \    long long int p = std::stoll(value);\n    long long int q = std::\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw4rgdvun.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpw4rgdvun.cpp:17:23: error: 'stoll' is not a member of 'std'\n     long\
    \ long int x = std::stoll(value);\n                       ^\n/tmp/tmpw4rgdvun.cpp:18:23:\
    \ error: 'stoll' is not a member of 'std'\n     long long int y = std::stoll(value);\n\
    \                       ^\n/tmp/tmpw4rgdvun.cpp:19:23: error: 'stoll' is not a\
    \ member of 'std'\n     long long int z = std::stoll(value);\n               \
    \        ^\n/tmp/tmpw4rgdvun.cpp:20:23: error: 'stoll' is not a member of 'std'\n\
    \     long long int w = std::stoll(value);\n                       ^\n/tmp/tmpw4rgdvun.cpp:21:23:\
    \ error: 'stoll' is not a member of 'std'\n     long long int a = std::stoll(value);\n\
    \                       ^\n/tmp/tmpw4rgdvun.cpp:22:23: error: 'stoll' is not a\
    \ member of 'std'\n     long long int b = std::stoll(value);\n               \
    \        ^\n/tmp/tmpw4rgdvun.cpp:23:23: error: 'stoll' is not a member of 'std'\n\
    \     long long int c = std::stoll(value);\n                       ^\n/tmp/tmpw4rgdvun.cpp:24:23:\
    \ error: 'stoll' is not a member of 'std'\n     long long int d = std::stoll(value);\n\
    \                       ^\n/tmp/tmpw4rgdvun.cpp:25:23: error: 'stoll' is not a\
    \ member of 'std'\n     long long int e = std::stoll(value);\n               \
    \        ^\n/tmp/tmpw4rgdvun.cpp:26:23: error: 'stoll' is not a member of 'std'\n\
    \     long long int f = std::stoll(value);\n                       ^\n/tmp/tmpw4rgdvun.cpp:27:23:\
    \ error: 'stoll' is not a member of 'std'\n     long long int g = std::stoll(value);\n\
    \                       ^\n/tmp/tmpw4rgdvun.cpp:28:23: error: 'stoll' is not a\
    \ member of 'std'\n     long long int h = std::stoll(value);\n               \
    \        ^\n/tmp/tmpw4rgdvun.cpp:29:23: error: 'stoll' is not a member of 'std'\n\
    \     long long int i = std::stoll(value);\n                       ^\n/tmp/tmpw4rgdvun.cpp:30:23:\
    \ error: 'stoll' is not a member of 'std'\n     long long int j = std::stoll(value);\n\
    \                       ^\n/tmp/tmpw4rgdvun.cpp:31:23: error: 'stoll' is not a\
    \ member of 'std'\n     long long "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    if (value.front()\
    \ == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    std::string::size_type\
    \ pos = 0;\n    std::string::size_type len = value.length();\n    while (pos <\
    \ len) {\n        long num = std::stoll(value.substr(pos, len));\n        if (num\
    \ == 0)\n            break;\n        if (num < 0)\n            num = -num;\n \
    \       if (num < ans)\n            ans = num;\n        pos += len;\n    }\n \
    \   if (pos == len) {\n        ans = std::stoll(value.substr(pos, len));\n   \
    \ }\n    if (ans == 0)\n        ans = sign * std::stoll(value.substr(0, pos));\n\
    \    return ans * sign;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8y755vu5.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmp8y755vu5.cpp:18:15: error: 'std::string' has no member named 'front'\n\
    \     if (value.front() == '-') {\n               ^\n/tmp/tmp8y755vu5.cpp:25:20:\
    \ error: 'stoll' is not a member of 'std'\n         long num = std::stoll(value.substr(pos,\
    \ len));\n                    ^\n/tmp/tmp8y755vu5.cpp:35:15: error: 'stoll' is\
    \ not a member of 'std'\n         ans = std::stoll(value.substr(pos, len));\n\
    \               ^\n/tmp/tmp8y755vu5.cpp:38:22: error: 'stoll' is not a member\
    \ of 'std'\n         ans = sign * std::stoll(value.substr(0, pos));\n        \
    \              ^\n/tmp/tmp8y755vu5.cpp: In function 'int main()':\n/tmp/tmp8y755vu5.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8y755vu5.cpp:2:\n/tmp/tmp8y755vu5.cpp:43:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff += temp;\n    }\n    ans = temp;\n    if (diff == 0) {\n\
    \        return ans;\n    }\n    if (diff > 0) {\n        return ans;\n    }\n\
    \    diff /= 2;\n    while (diff > 0) {\n        diff /= 2;\n        ans *= 2;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn6lmuzp5.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpn6lmuzp5.cpp:19:12: error: 'stoll' is not a member of 'std'\n     temp\
    \ = std::stoll(value);\n            ^\n/tmp/tmpn6lmuzp5.cpp: In function 'int\
    \ main()':\n/tmp/tmpn6lmuzp5.cpp:39:10: error: 'candidate' does not name a type\n\
    \     auto candidate = closest_integer;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn6lmuzp5.cpp:2:\n/tmp/tmpn6lmuzp5.cpp:40:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1, digit;\n \
    \   long val = std::stoll(value);\n    do {\n        digit = val % 10;\n     \
    \   ans = ans * 10 + digit;\n        sign = -sign;\n        val /= 10;\n    }\
    \ while (val != 0);\n    return sign * ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphf0xhion.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmphf0xhion.cpp:18:16: error: 'stoll' is not a member of 'std'\n     long\
    \ val = std::stoll(value);\n                ^\n/tmp/tmphf0xhion.cpp: In function\
    \ 'int main()':\n/tmp/tmphf0xhion.cpp:28:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = closest_integer;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphf0xhion.cpp:2:\n/tmp/tmphf0xhion.cpp:29:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5\
    \ = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n    long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpse48xccd.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpse48xccd.cpp:104:1: error: expected unqualified-id before '}' token\n\
    \ }\n ^\n/tmp/tmpse48xccd.cpp: In function 'int main()':\n/tmp/tmpse48xccd.cpp:106:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpse48xccd.cpp:2:\n/tmp/tmpse48xccd.cpp:107:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0, diff\
    \ = 0;\n  long n = stoi(value);\n  for (int i = 0; i < value.size(); i++) {\n\
    \    diff = abs(n - stoi(value.substr(0, i)));\n    if (diff < ans) {\n      ans\
    \ = diff;\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt8rbx60y.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpt8rbx60y.cpp:19:22: error: 'stoi' was not declared in this scope\n   long\
    \ n = stoi(value);\n                      ^\n/tmp/tmpt8rbx60y.cpp: In function\
    \ 'int main()':\n/tmp/tmpt8rbx60y.cpp:29:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = closest_integer;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt8rbx60y.cpp:2:\n/tmp/tmpt8rbx60y.cpp:30:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    long diff = upper - lower;\n    if (diff == 0) {\n        return lower;\n\
    \    }\n    long mid = (lower + upper) / 2;\n    if (diff < 0)\n        mid =\
    \ std::stoll(value);\n    long middiff = mid - lower;\n    if (middiff < 0)\n\
    \        mid = std::stoll(value);\n    long middiff2 = mid - upper;\n    if (middiff2\
    \ < 0)\n        mid = std::stoll(value);\n    if (middiff == middiff2) {\n   \
    \     return mid;\n    }\n    if (middiff < middiff2) {\n        return lower;\n\
    \    }\n    return upper;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjg7v7x73.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpjg7v7x73.cpp:17:29: error: 'stoll' is not a member of 'std'\n     long\
    \ lower = 0, upper = std::stoll(value);\n                             ^\n/tmp/tmpjg7v7x73.cpp:24:15:\
    \ error: 'stoll' is not a member of 'std'\n         mid = std::stoll(value);\n\
    \               ^\n/tmp/tmpjg7v7x73.cpp:27:15: error: 'stoll' is not a member\
    \ of 'std'\n         mid = std::stoll(value);\n               ^\n/tmp/tmpjg7v7x73.cpp:30:15:\
    \ error: 'stoll' is not a member of 'std'\n         mid = std::stoll(value);\n\
    \               ^\n/tmp/tmpjg7v7x73.cpp: In function 'int main()':\n/tmp/tmpjg7v7x73.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjg7v7x73.cpp:2:\n/tmp/tmpjg7v7x73.cpp:41:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    long diff = upper - lower;\n    if (diff > 0) return lower;\n    if (diff\
    \ < 0) return upper;\n    if (diff == 0) return upper;\n    long mid = (lower\
    \ + upper) / 2;\n    long midValue = std::stoll(value);\n    if (midValue < mid)\
    \ return mid;\n    if (midValue > mid) return mid;\n    return mid;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1ygucx87.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmp1ygucx87.cpp:17:29: error: 'stoll' is not a member of 'std'\n     long\
    \ lower = 0, upper = std::stoll(value);\n                             ^\n/tmp/tmp1ygucx87.cpp:23:21:\
    \ error: 'stoll' is not a member of 'std'\n     long midValue = std::stoll(value);\n\
    \                     ^\n/tmp/tmp1ygucx87.cpp: In function 'int main()':\n/tmp/tmp1ygucx87.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1ygucx87.cpp:2:\n/tmp/tmp1ygucx87.cpp:30:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa1hgaku0.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpa1hgaku0.cpp:91:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpa1hgaku0.cpp: In function 'int main()':\n/tmp/tmpa1hgaku0.cpp:93:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa1hgaku0.cpp:2:\n/tmp/tmpa1hgaku0.cpp:94:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int temp = 0;\n    long\
    \ long int temp2 = 0;\n    long long int temp3 = 0;\n    long long int temp4 =\
    \ 0;\n    long long int temp5 = 0;\n    long long int temp6 = 0;\n    long long\
    \ int temp7 = 0;\n    long long int temp8 = 0;\n    long long int temp9 = 0;\n\
    \    long long int temp10 = 0;\n    long long int temp11 = 0;\n    long long int\
    \ temp12 = 0;\n    long long int temp13 = 0;\n    long long int temp14 = 0;\n\
    \    long long int temp15 = 0;\n    long long int temp16 = 0;\n    long long int\
    \ temp17 = 0;\n    long long int temp18 = 0;\n    long long int temp19 = 0;\n\
    \    long long int temp20 = 0;\n    long long int temp21 = 0;\n    long long int\
    \ temp22 = 0;\n    long long int temp23 = 0;\n    long long int temp24 = 0;\n\
    \    long long int temp25 = 0;\n    long long int temp26 = 0;\n    long long int\
    \ temp27 = 0;\n    long long int temp28 = 0;\n    long long int temp29 = 0;\n\
    \    long long int temp30 = 0;\n    long long int temp31 = 0;\n    long long int\
    \ temp32 = 0;\n    long long int temp33 = 0;\n    long long int temp34 = 0;\n\
    \    long long int temp35 = 0;\n    long long int temp36 = 0;\n    long long int\
    \ temp37 = 0;\n    long long int temp38 = 0;\n    long long int temp39 = 0;\n\
    \    long long int temp40 = 0;\n    long long int temp41 = 0;\n    long long int\
    \ temp42 = 0;\n    long long int temp43 = 0;\n    long long int temp44 = 0;\n\
    \    long long int temp45 = 0;\n    long long int temp46 = 0;\n    long long int\
    \ temp47 = 0;\n    long long int temp48 = 0;\n    long long int temp49 = 0;\n\
    \    long long int temp50 = 0;\n    long long int temp51 = 0;\n    long long int\
    \ temp52 = 0;\n    long long int temp53 = 0;\n    long long int temp54 = 0;\n\
    \    long long int temp55 = 0;\n    long long int temp56 = 0;\n    long long int\
    \ temp57 = 0;\n    long long int temp58 = 0;\n    long long int temp59 = 0;\n\
    \    long long int temp60 = 0;\n    long long int temp61 = 0;\n    long long int\
    \ temp62 = 0;\n    long long int temp63 = 0;\n    long long int temp64 = 0;\n\
    \    long long int temp\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnsb1fxge.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpnsb1fxge.cpp:82:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpnsb1fxge.cpp: In function 'int main()':\n/tmp/tmpnsb1fxge.cpp:84:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnsb1fxge.cpp:2:\n/tmp/tmpnsb1fxge.cpp:85:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (upper == lower) {\n        upper++;\n    }\n    long mid = (lower + upper)\
    \ / 2;\n    long diff = upper - lower;\n    if (diff == 0) {\n        return mid;\n\
    \    }\n    if (diff < 0) {\n        lower = mid;\n        upper = std::stoll(value);\n\
    \        if (upper == lower) {\n            upper++;\n        }\n        mid =\
    \ (lower + upper) / 2;\n        diff = upper - lower;\n    }\n    if (diff > 0)\
    \ {\n        lower = mid;\n        upper = std::stoll(value);\n        if (upper\
    \ == lower) {\n            upper++;\n        }\n        mid = (lower + upper)\
    \ / 2;\n        diff = upper - lower;\n    }\n    return mid;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc993120m.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpc993120m.cpp:17:29: error: 'stoll' is not a member of 'std'\n     long\
    \ lower = 0, upper = std::stoll(value);\n                             ^\n/tmp/tmpc993120m.cpp:28:17:\
    \ error: 'stoll' is not a member of 'std'\n         upper = std::stoll(value);\n\
    \                 ^\n/tmp/tmpc993120m.cpp:37:17: error: 'stoll' is not a member\
    \ of 'std'\n         upper = std::stoll(value);\n                 ^\n/tmp/tmpc993120m.cpp:\
    \ In function 'int main()':\n/tmp/tmpc993120m.cpp:47:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = closest_integer;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc993120m.cpp:2:\n/tmp/tmpc993120m.cpp:48:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp99k9w3yn.cpp: In function 'int main()':\n/tmp/tmp99k9w3yn.cpp:87:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp99k9w3yn.cpp:2:\n/tmp/tmp99k9w3yn.cpp:88:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k =\
    \ 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n   \
    \ long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t =\
    \ 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n   \
    \ long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C =\
    \ 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n   \
    \ long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L =\
    \ 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n   \
    \ long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U =\
    \ 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n   \
    \ long Z = 0;\n    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long\
    \ dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh =\
    \ 0;\n    long ii = 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n\
    \    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long\
    \ qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu =\
    \ 0;\n    long vv = 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n\
    \    long zz = 0;\n    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long\
    \ Dd = 0;\n    long Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh =\
    \ 0;\n    long Ii = 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n\
    \    long Mm = 0;\n    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long\
    \ Qq = 0;\n    long Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu =\
    \ 0;\n    long Vv = 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n\
    \    long Z\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe9rm6bt_.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpe9rm6bt_.cpp:116:1: error: expected initializer before '}' token\n }\n\
    \ ^\n/tmp/tmpe9rm6bt_.cpp: In function 'int main()':\n/tmp/tmpe9rm6bt_.cpp:118:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe9rm6bt_.cpp:2:\n/tmp/tmpe9rm6bt_.cpp:119:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long count = 0;\n    long temp\
    \ = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long\
    \ temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n\
    \    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12\
    \ = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n   \
    \ long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4chu13kg.cpp: In function 'int main()':\n/tmp/tmp4chu13kg.cpp:107:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4chu13kg.cpp:2:\n/tmp/tmp4chu13kg.cpp:108:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int a = stoi(value);\n \
    \   long long int b = stoi(value);\n    long long int c = stoi(value);\n    long\
    \ long int d = stoi(value);\n    long long int e = stoi(value);\n    long long\
    \ int f = stoi(value);\n    long long int g = stoi(value);\n    long long int\
    \ h = stoi(value);\n    long long int i = stoi(value);\n    long long int j =\
    \ stoi(value);\n    long long int k = stoi(value);\n    long long int l = stoi(value);\n\
    \    long long int m = stoi(value);\n    long long int n = stoi(value);\n    long\
    \ long int o = stoi(value);\n    long long int p = stoi(value);\n    long long\
    \ int q = stoi(value);\n    long long int r = stoi(value);\n    long long int\
    \ s = stoi(value);\n    long long int t = stoi(value);\n    long long int u =\
    \ stoi(value);\n    long long int v = stoi(value);\n    long long int w = stoi(value);\n\
    \    long long int x = stoi(value);\n    long long int y = stoi(value);\n    long\
    \ long int z = stoi(value);\n    long long int a = stoi(value);\n    long long\
    \ int b = stoi(value);\n    long long int c = stoi(value);\n    long long int\
    \ d = stoi(value);\n    long long int e = stoi(value);\n    long long int f =\
    \ stoi(value);\n    long long int g = stoi(value);\n    long long int h = stoi(value);\n\
    \    long long int i = stoi(value);\n    long long int j = stoi(value);\n    long\
    \ long int k = stoi(value);\n    long long int l = stoi(value);\n    long long\
    \ int m = stoi(value);\n    long long int n = stoi(value);\n    long long int\
    \ o = stoi(value);\n    long long int p = stoi(value);\n    long long int q =\
    \ stoi(value);\n    long long int r = stoi(value);\n    long long int s = stoi(value);\n\
    \    long long int t = stoi(value);\n    long long int u = stoi(value);\n    long\
    \ long int v = stoi(value);\n    long long int w = stoi(value);\n    long long\
    \ int x = stoi(value);\n    long long int y = stoi(value);\n    long long int\
    \ z = stoi(value);\n    long long int a = stoi(value);\n    long long int b =\
    \ stoi(value);\n    long long int c = stoi(value);\n    long long int d = stoi(value);\n\
    \    long long int e = stoi(value);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcf8_yx6h.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmpcf8_yx6h.cpp:17:33: error: 'stoi' was not declared in this scope\n   \
    \  long long int a = stoi(value);\n                                 ^\n/tmp/tmpcf8_yx6h.cpp:43:19:\
    \ error: redeclaration of 'long long int a'\n     long long int a = stoi(value);\n\
    \                   ^\n/tmp/tmpcf8_yx6h.cpp:17:19: error: 'long long int a' previously\
    \ declared here\n     long long int a = stoi(value);\n                   ^\n/tmp/tmpcf8_yx6h.cpp:44:19:\
    \ error: redeclaration of 'long long int b'\n     long long int b = stoi(value);\n\
    \                   ^\n/tmp/tmpcf8_yx6h.cpp:18:19: error: 'long long int b' previously\
    \ declared here\n     long long int b = stoi(value);\n                   ^\n/tmp/tmpcf8_yx6h.cpp:45:19:\
    \ error: redeclaration of 'long long int c'\n     long long int c = stoi(value);\n\
    \                   ^\n/tmp/tmpcf8_yx6h.cpp:19:19: error: 'long long int c' previously\
    \ declared here\n     long long int c = stoi(value);\n                   ^\n/tmp/tmpcf8_yx6h.cpp:46:19:\
    \ error: redeclaration of 'long long int d'\n     long long int d = stoi(value);\n\
    \                   ^\n/tmp/tmpcf8_yx6h.cpp:20:19: error: 'long long int d' previously\
    \ declared here\n     long long int d = stoi(value);\n                   ^\n/tmp/tmpcf8_yx6h.cpp:47:19:\
    \ error: redeclaration of 'long long int e'\n     long long int e = stoi(value);\n\
    \                   ^\n/tmp/tmpcf8_yx6h.cpp:21:19: error: 'long long int e' previously\
    \ declared here\n     long long int e = stoi(value);\n                   ^\n/tmp/tmpcf8_yx6h.cpp:48:19:\
    \ error: redeclaration of 'long long int f'\n     long long int f = stoi(value);\n\
    \                   ^\n/tmp/tmpcf8_yx6h.cpp:22:19: error: 'long long int f' previously\
    \ declared here\n     long long int f = stoi(value);\n                   ^\n/tmp/tmpcf8_yx6h.cpp:49:19:\
    \ error: redeclaration of 'long long int g'\n     long long int g = stoi(value);\n\
    \                   ^\n/tmp/tmpcf8_yx6h.cpp:23:19: error: 'long long int g' previously\
    \ declared here\n     long long int g = stoi(value);\n                "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (lower > upper) {\n        std::swap(lower, upper);\n    }\n    long mid\
    \ = (lower + upper) / 2;\n    if (mid > upper) {\n        mid = upper;\n    }\n\
    \    if (mid < lower) {\n        mid = lower;\n    }\n    if (mid - std::stoll(value)\
    \ > 0) {\n        return mid;\n    }\n    return upper;\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0uabqfda.cpp: In function 'long int closest_integer(std::string)':\n\
    /tmp/tmp0uabqfda.cpp:17:29: error: 'stoll' is not a member of 'std'\n     long\
    \ lower = 0, upper = std::stoll(value);\n                             ^\n/tmp/tmp0uabqfda.cpp:28:15:\
    \ error: 'stoll' is not a member of 'std'\n     if (mid - std::stoll(value) >\
    \ 0) {\n               ^\n/tmp/tmp0uabqfda.cpp: In function 'int main()':\n/tmp/tmp0uabqfda.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0uabqfda.cpp:2:\n/tmp/tmp0uabqfda.cpp:35:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    long long temp2;\n    long long temp3;\n    long long temp4;\n\
    \    long long temp5;\n    long long temp6;\n    long long temp7;\n    long long\
    \ temp8;\n    long long temp9;\n    long long temp10;\n    long long temp11;\n\
    \    long long temp12;\n    long long temp13;\n    long long temp14;\n    long\
    \ long temp15;\n    long long temp16;\n    long long temp17;\n    long long temp18;\n\
    \    long long temp19;\n    long long temp20;\n    long long temp21;\n    long\
    \ long temp22;\n    long long temp23;\n    long long temp24;\n    long long temp25;\n\
    \    long long temp26;\n    long long temp27;\n    long long temp28;\n    long\
    \ long temp29;\n    long long temp30;\n    long long temp31;\n    long long temp32;\n\
    \    long long temp33;\n    long long temp34;\n    long long temp35;\n    long\
    \ long temp36;\n    long long temp37;\n    long long temp38;\n    long long temp39;\n\
    \    long long temp40;\n    long long temp41;\n    long long temp42;\n    long\
    \ long temp43;\n    long long temp44;\n    long long temp45;\n    long long temp46;\n\
    \    long long temp47;\n    long long temp48;\n    long long temp49;\n    long\
    \ long temp50;\n    long long temp51;\n    long long temp52;\n    long long temp53;\n\
    \    long long temp54;\n    long long temp55;\n    long long temp56;\n    long\
    \ long temp57;\n    long long temp58;\n    long long temp59;\n    long long temp60;\n\
    \    long long temp61;\n    long long temp62;\n    long long temp63;\n    long\
    \ long temp64;\n    long long temp65;\n    long long temp66;\n    long long temp67;\n\
    \    long long temp68;\n    long long temp69;\n    long long temp70;\n    long\
    \ long temp71;\n    long long temp72;\n    long long temp73;\n    long long temp74;\n\
    \    long long temp75;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkljcu52b.cpp: In function 'int main()':\n/tmp/tmpkljcu52b.cpp:95:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkljcu52b.cpp:2:\n/tmp/tmpkljcu52b.cpp:96:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long sum = 0;\n    long count = 0;\n    long i = 0;\n\
    \    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long\
    \ n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n\
    \    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long\
    \ w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n\
    \    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long\
    \ F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n\
    \    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long\
    \ O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n\
    \    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long\
    \ X = 0;\n    long Y = 0;\n    long Z = 0;\n    long aa = 0;\n    long bb = 0;\n\
    \    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long\
    \ gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n    long kk =\
    \ 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n\
    \    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long\
    \ tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long xx =\
    \ 0;\n    long yy = 0;\n    long zz = 0;\n    long Aa = 0;\n    long Bb = 0;\n\
    \    long Cc = 0;\n    long Dd = 0;\n    long Ee = 0;\n    long Ff = 0;\n    long\
    \ Gg = 0;\n    long Hh = 0;\n    long Ii = 0;\n    long Jj = 0;\n    long Kk =\
    \ 0;\n    long Ll = 0;\n    long Mm = 0;\n    long Nn = 0;\n    long Oo = 0;\n\
    \    long Pp = 0;\n    long Qq = 0;\n    long Rr = 0;\n    long Ss = 0;\n    long\
    \ Tt = 0;\n    long Uu = 0;\n    long Vv = 0;\n    long Ww = 0;\n    long Xx =\
    \ 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptdg0c0jh.cpp: In function 'int main()':\n/tmp/tmptdg0c0jh.cpp:119:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = closest_integer;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptdg0c0jh.cpp:2:\n/tmp/tmptdg0c0jh.cpp:120:28: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"10\"))\
    \ == (10));\n                            ^\n"
  stdout: ''
