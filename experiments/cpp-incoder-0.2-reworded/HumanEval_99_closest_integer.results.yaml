language: cpp
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long sum2 = 0;\n    long sum3\
    \ = 0;\n    long sum4 = 0;\n    long sum5 = 0;\n    long sum6 = 0;\n    long sum7\
    \ = 0;\n    long sum8 = 0;\n    long sum9 = 0;\n    long sum10 = 0;\n    long\
    \ sum11 = 0;\n    long sum12 = 0;\n    long sum13 = 0;\n    long sum14 = 0;\n\
    \    long sum15 = 0;\n    long sum16 = 0;\n    long sum17 = 0;\n    long sum18\
    \ = 0;\n    long sum19 = 0;\n    long sum20 = 0;\n    long sum21 = 0;\n    long\
    \ sum22 = 0;\n    long sum23 = 0;\n    long sum24 = 0;\n    long sum25 = 0;\n\
    \    long sum26 = 0;\n    long sum27 = 0;\n    long sum28 = 0;\n    long sum29\
    \ = 0;\n    long sum30 = 0;\n    long sum31 = 0;\n    long sum32 = 0;\n    long\
    \ sum33 = 0;\n    long sum34 = 0;\n    long sum35 = 0;\n    long sum36 = 0;\n\
    \    long sum37 = 0;\n    long sum38 = 0;\n    long sum39 = 0;\n    long sum40\
    \ = 0;\n    long sum41 = 0;\n    long sum42 = 0;\n    long sum43 = 0;\n    long\
    \ sum44 = 0;\n    long sum45 = 0;\n    long sum46 = 0;\n    long sum47 = 0;\n\
    \    long sum48 = 0;\n    long sum49 = 0;\n    long sum50 = 0;\n    long sum51\
    \ = 0;\n    long sum52 = 0;\n    long sum53 = 0;\n    long sum54 = 0;\n    long\
    \ sum55 = 0;\n    long sum56 = 0;\n    long sum57 = 0;\n    long sum58 = 0;\n\
    \    long sum59 = 0;\n    long sum60 = 0;\n    long sum61 = 0;\n    long sum62\
    \ = 0;\n    long sum63 = 0;\n    long sum64 = 0;\n    long sum65 = 0;\n    long\
    \ sum66 = 0;\n    long sum67 = 0;\n    long sum68 = 0;\n    long sum69 = 0;\n\
    \    long sum70 = 0;\n    long sum71 = 0;\n    long sum72 = 0;\n    long sum73\
    \ = 0;\n    long sum74 = 0;\n    long sum75 = 0;\n    long sum76 = 0;\n    long\
    \ sum77 = 0;\n    long sum78 = 0;\n    long sum79 = 0;\n    long sum80 = 0;\n\
    \    long sum81 = 0;\n    long sum82 = 0;\n    long sum83 = 0;\n    long sum84\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptp__9lex.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptp__9lex.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmptp__9lex.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff = diff * -1;\n    }\n    ans = temp;\n    if (diff == 0)\
    \ {\n        return ans;\n    }\n    if (diff > 0 && diff < 10) {\n        return\
    \ ans;\n    }\n    if (diff > 10 && diff < 100) {\n        return ans + 1;\n \
    \   }\n    if (diff > 100 && diff < 1000) {\n        return ans + 2;\n    }\n\
    \    if (diff > 1000 && diff < 10000) {\n        return ans + 3;\n    }\n    if\
    \ (diff > 10000 && diff < 100000) {\n        return ans + 4;\n    }\n    if (diff\
    \ > 100000 && diff < 1000000) {\n        return ans + 5;\n    }\n    if (diff\
    \ > 1000000 && diff < 10000000) {\n        return ans + 6;\n    }\n    if (diff\
    \ > 10000000 && diff < 100000000) {\n        return ans + 7;\n    }\n    if (diff\
    \ > 100000000 && diff < 1000000000) {\n        return ans + 8;\n    }\n    if\
    \ (diff > 1000000000 && diff < 10000000000) {\n        return ans + 9;\n    }\n\
    \    if (diff > 10000000000 && diff < 100000000000) {\n        return ans + 10;\n\
    \    }\n    if (diff > 100000000000 && diff < 1000000000000) {\n        return\
    \ ans + 11;\n    }\n    if (diff > 1000000000000 && diff < 10000000000000) {\n\
    \        return ans + 12;\n    }\n    if (diff > 10000000000000 && diff < 100000000000000)\
    \ {\n        return ans + 13;\n    }\n    if (diff > 100000000000000 && diff <\
    \ 1000000000000000) {\n        return ans + 14;\n    }\n    if (diff > 1000000000000000\
    \ && diff < 10000000000000000) {\n        return ans + 15;\n    }\n    if (diff\
    \ > 10000000000000000 && diff < 100000000000000000) {\n        return ans + 16;\n\
    \    }\n    if (diff > 100000000000000000 && diff < 1000000000000000000) {\n \
    \       return ans + 17;\n    }\n    if (diff > 1000000000000000000 && diff <\
    \ 10000000000000000000) {\n        return ans + 18;\n    }\n    if (diff > 10000000000000000000\
    \ && diff < 100000000000000000000) {\n        return ans + 19;\n    }\n    if\
    \ (diff > 100000000000000000000 && diff < 1000000000000000000000) {\n        return\
    \ ans + 20;\n    }\n    if (diff > 1000000000000000000000 && diff < 10000000000000000000000)\
    \ {\n        return ans + 21;\n    }\n    if (diff > 10000000000000000000000 &&\
    \ diff < 100000000000000000000000) {\n        return ans + 22;\n    }\n    if\
    \ (diff > 100000000000000000000000 && diff < 100\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1frpa1e0.cpp:82:46: warning: integer constant is so large that\
    \ it is unsigned\n   82 |     if (diff > 1000000000000000000 && diff < 10000000000000000000)\
    \ {\n      |                                              ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1frpa1e0.cpp:85:16: warning: integer constant is so large that it is unsigned\n\
    \   85 |     if (diff > 10000000000000000000 && diff < 100000000000000000000)\
    \ {\n      |                ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1frpa1e0.cpp:85:47:\
    \ warning: integer constant is too large for its type\n   85 |     if (diff >\
    \ 10000000000000000000 && diff < 100000000000000000000) {\n      |           \
    \                                    ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1frpa1e0.cpp:88:16:\
    \ warning: integer constant is too large for its type\n   88 |     if (diff >\
    \ 100000000000000000000 && diff < 1000000000000000000000) {\n      |         \
    \       ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1frpa1e0.cpp:88:48: warning: integer constant\
    \ is too large for its type\n   88 |     if (diff > 100000000000000000000 && diff\
    \ < 1000000000000000000000) {\n      |                                       \
    \         ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1frpa1e0.cpp:91:16: warning: integer\
    \ constant is too large for its type\n   91 |     if (diff > 1000000000000000000000\
    \ && diff < 10000000000000000000000) {\n      |                ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1frpa1e0.cpp:91:49: warning: integer constant is too large for its type\n\
    \   91 |     if (diff > 1000000000000000000000 && diff < 10000000000000000000000)\
    \ {\n      |                                                 ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1frpa1e0.cpp:94:16: warning: integer constant is too large for its type\n\
    \   94 |     if (diff > 10000000000000000000000 && diff < 100000000000000000000000)\
    \ {\n      |                ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1frpa1e0.cpp:94:50:\
    \ warning: integer constant is too large for its type\n   94 |     if (diff >\
    \ 10000000000000000000000 && diff < 100000000000000000000000) {\n      |     \
    \                                             ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1fr"
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int x = std::stoll(value);\n\
    \    long long int y = std::stoll(value);\n    long long int z = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int k = std::stoll(value);\n\
    \    long long int l = std::stoll(value);\n    long long int m = std::stoll(value);\n\
    \    long long int n = std::stoll(value);\n    long long int o = std::stoll(value);\n\
    \    long long int p = std::stoll(value);\n    long long int q = std::stoll(value);\n\
    \    long long int r = std::stoll(value);\n    long long int s = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int k = std::stoll(value);\n\
    \    long long int l = std::stoll(value);\n    long long int m = std::stoll(value);\n\
    \    long long int n = std::stoll(value);\n    long long int o = std::stoll(value);\n\
    \    long long int p = std::stoll(value);\n    long long int q = std::\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpldu1riyx.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpldu1riyx.cpp:43:19: error: redeclaration of \u2018long long int w\u2019\
    \n   43 |     long long int w = std::stoll(value);\n      |                  \
    \ ^\n/tmp/tmpldu1riyx.cpp:20:19: note: \u2018long long int w\u2019 previously\
    \ declared here\n   20 |     long long int w = std::stoll(value);\n      |   \
    \                ^\n/tmp/tmpldu1riyx.cpp:44:19: error: redeclaration of \u2018\
    long long int x\u2019\n   44 |     long long int x = std::stoll(value);\n    \
    \  |                   ^\n/tmp/tmpldu1riyx.cpp:17:19: note: \u2018long long int\
    \ x\u2019 previously declared here\n   17 |     long long int x = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:45:19: error: redeclaration\
    \ of \u2018long long int y\u2019\n   45 |     long long int y = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:18:19: note: \u2018long long\
    \ int y\u2019 previously declared here\n   18 |     long long int y = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:46:19: error: redeclaration\
    \ of \u2018long long int z\u2019\n   46 |     long long int z = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:19:19: note: \u2018long long\
    \ int z\u2019 previously declared here\n   19 |     long long int z = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:47:19: error: redeclaration\
    \ of \u2018long long int a\u2019\n   47 |     long long int a = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:21:19: note: \u2018long long\
    \ int a\u2019 previously declared here\n   21 |     long long int a = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:48:19: error: redeclaration\
    \ of \u2018long long int b\u2019\n   48 |     long long int b = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:22:19: note: \u2018long long\
    \ int b\u2019 previously declared here\n   22 |     long long int b = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:49:19: error: redeclaration\
    \ of \u2018long long int c\u2019\n   49 |     long long int c = std::stoll("
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    if (value.front()\
    \ == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    std::string::size_type\
    \ pos = 0;\n    std::string::size_type len = value.length();\n    while (pos <\
    \ len) {\n        long num = std::stoll(value.substr(pos, len));\n        if (num\
    \ == 0)\n            break;\n        if (num < 0)\n            num = -num;\n \
    \       if (num < ans)\n            ans = num;\n        pos += len;\n    }\n \
    \   if (pos == len) {\n        ans = std::stoll(value.substr(pos, len));\n   \
    \ }\n    if (ans == 0)\n        ans = sign * std::stoll(value.substr(0, pos));\n\
    \    return ans * sign;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoll\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff += temp;\n    }\n    ans = temp;\n    if (diff == 0) {\n\
    \        return ans;\n    }\n    if (diff > 0) {\n        return ans;\n    }\n\
    \    diff /= 2;\n    while (diff > 0) {\n        diff /= 2;\n        ans *= 2;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpaa_rvrp4: /tmp/tmpaa_rvrp4.cpp:41: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1, digit;\n \
    \   long val = std::stoll(value);\n    do {\n        digit = val % 10;\n     \
    \   ans = ans * 10 + digit;\n        sign = -sign;\n        val /= 10;\n    }\
    \ while (val != 0);\n    return sign * ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpch97ycg9: /tmp/tmpch97ycg9.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5\
    \ = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n    long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa3wcdiff.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpa3wcdiff.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpa3wcdiff.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0, diff\
    \ = 0;\n  long n = stoi(value);\n  for (int i = 0; i < value.size(); i++) {\n\
    \    diff = abs(n - stoi(value.substr(0, i)));\n    if (diff < ans) {\n      ans\
    \ = diff;\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    long diff = upper - lower;\n    if (diff == 0) {\n        return lower;\n\
    \    }\n    long mid = (lower + upper) / 2;\n    if (diff < 0)\n        mid =\
    \ std::stoll(value);\n    long middiff = mid - lower;\n    if (middiff < 0)\n\
    \        mid = std::stoll(value);\n    long middiff2 = mid - upper;\n    if (middiff2\
    \ < 0)\n        mid = std::stoll(value);\n    if (middiff == middiff2) {\n   \
    \     return mid;\n    }\n    if (middiff < middiff2) {\n        return lower;\n\
    \    }\n    return upper;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpeucjfiah: /tmp/tmpeucjfiah.cpp:42: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    long diff = upper - lower;\n    if (diff > 0) return lower;\n    if (diff\
    \ < 0) return upper;\n    if (diff == 0) return upper;\n    long mid = (lower\
    \ + upper) / 2;\n    long midValue = std::stoll(value);\n    if (midValue < mid)\
    \ return mid;\n    if (midValue > mid) return mid;\n    return mid;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp65_9wiox: /tmp/tmp65_9wiox.cpp:30: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int temp = 0;\n    long\
    \ long int temp2 = 0;\n    long long int temp3 = 0;\n    long long int temp4 =\
    \ 0;\n    long long int temp5 = 0;\n    long long int temp6 = 0;\n    long long\
    \ int temp7 = 0;\n    long long int temp8 = 0;\n    long long int temp9 = 0;\n\
    \    long long int temp10 = 0;\n    long long int temp11 = 0;\n    long long int\
    \ temp12 = 0;\n    long long int temp13 = 0;\n    long long int temp14 = 0;\n\
    \    long long int temp15 = 0;\n    long long int temp16 = 0;\n    long long int\
    \ temp17 = 0;\n    long long int temp18 = 0;\n    long long int temp19 = 0;\n\
    \    long long int temp20 = 0;\n    long long int temp21 = 0;\n    long long int\
    \ temp22 = 0;\n    long long int temp23 = 0;\n    long long int temp24 = 0;\n\
    \    long long int temp25 = 0;\n    long long int temp26 = 0;\n    long long int\
    \ temp27 = 0;\n    long long int temp28 = 0;\n    long long int temp29 = 0;\n\
    \    long long int temp30 = 0;\n    long long int temp31 = 0;\n    long long int\
    \ temp32 = 0;\n    long long int temp33 = 0;\n    long long int temp34 = 0;\n\
    \    long long int temp35 = 0;\n    long long int temp36 = 0;\n    long long int\
    \ temp37 = 0;\n    long long int temp38 = 0;\n    long long int temp39 = 0;\n\
    \    long long int temp40 = 0;\n    long long int temp41 = 0;\n    long long int\
    \ temp42 = 0;\n    long long int temp43 = 0;\n    long long int temp44 = 0;\n\
    \    long long int temp45 = 0;\n    long long int temp46 = 0;\n    long long int\
    \ temp47 = 0;\n    long long int temp48 = 0;\n    long long int temp49 = 0;\n\
    \    long long int temp50 = 0;\n    long long int temp51 = 0;\n    long long int\
    \ temp52 = 0;\n    long long int temp53 = 0;\n    long long int temp54 = 0;\n\
    \    long long int temp55 = 0;\n    long long int temp56 = 0;\n    long long int\
    \ temp57 = 0;\n    long long int temp58 = 0;\n    long long int temp59 = 0;\n\
    \    long long int temp60 = 0;\n    long long int temp61 = 0;\n    long long int\
    \ temp62 = 0;\n    long long int temp63 = 0;\n    long long int temp64 = 0;\n\
    \    long long int temp\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpirhj7fas.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpirhj7fas.cpp:82:1: error: expected initializer before \u2018}\u2019\
    \ token\n   82 | }\n      | ^\n/tmp/tmpirhj7fas.cpp:82:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (upper == lower) {\n        upper++;\n    }\n    long mid = (lower + upper)\
    \ / 2;\n    long diff = upper - lower;\n    if (diff == 0) {\n        return mid;\n\
    \    }\n    if (diff < 0) {\n        lower = mid;\n        upper = std::stoll(value);\n\
    \        if (upper == lower) {\n            upper++;\n        }\n        mid =\
    \ (lower + upper) / 2;\n        diff = upper - lower;\n    }\n    if (diff > 0)\
    \ {\n        lower = mid;\n        upper = std::stoll(value);\n        if (upper\
    \ == lower) {\n            upper++;\n        }\n        mid = (lower + upper)\
    \ / 2;\n        diff = upper - lower;\n    }\n    return mid;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpwocgsrc6: /tmp/tmpwocgsrc6.cpp:48: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnro_jpvo: /tmp/tmpnro_jpvo.cpp:88: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k =\
    \ 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n   \
    \ long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t =\
    \ 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n   \
    \ long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C =\
    \ 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n   \
    \ long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L =\
    \ 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n   \
    \ long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U =\
    \ 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n   \
    \ long Z = 0;\n    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long\
    \ dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh =\
    \ 0;\n    long ii = 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n\
    \    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long\
    \ qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu =\
    \ 0;\n    long vv = 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n\
    \    long zz = 0;\n    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long\
    \ Dd = 0;\n    long Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh =\
    \ 0;\n    long Ii = 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n\
    \    long Mm = 0;\n    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long\
    \ Qq = 0;\n    long Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu =\
    \ 0;\n    long Vv = 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n\
    \    long Z\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdpyf011b.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpdpyf011b.cpp:116:1: error: expected initializer before \u2018}\u2019\
    \ token\n  116 | }\n      | ^\n/tmp/tmpdpyf011b.cpp:116:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long count = 0;\n    long temp\
    \ = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long\
    \ temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n\
    \    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12\
    \ = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n   \
    \ long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyrhy_rca: /tmp/tmpyrhy_rca.cpp:108: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int a = stoi(value);\n \
    \   long long int b = stoi(value);\n    long long int c = stoi(value);\n    long\
    \ long int d = stoi(value);\n    long long int e = stoi(value);\n    long long\
    \ int f = stoi(value);\n    long long int g = stoi(value);\n    long long int\
    \ h = stoi(value);\n    long long int i = stoi(value);\n    long long int j =\
    \ stoi(value);\n    long long int k = stoi(value);\n    long long int l = stoi(value);\n\
    \    long long int m = stoi(value);\n    long long int n = stoi(value);\n    long\
    \ long int o = stoi(value);\n    long long int p = stoi(value);\n    long long\
    \ int q = stoi(value);\n    long long int r = stoi(value);\n    long long int\
    \ s = stoi(value);\n    long long int t = stoi(value);\n    long long int u =\
    \ stoi(value);\n    long long int v = stoi(value);\n    long long int w = stoi(value);\n\
    \    long long int x = stoi(value);\n    long long int y = stoi(value);\n    long\
    \ long int z = stoi(value);\n    long long int a = stoi(value);\n    long long\
    \ int b = stoi(value);\n    long long int c = stoi(value);\n    long long int\
    \ d = stoi(value);\n    long long int e = stoi(value);\n    long long int f =\
    \ stoi(value);\n    long long int g = stoi(value);\n    long long int h = stoi(value);\n\
    \    long long int i = stoi(value);\n    long long int j = stoi(value);\n    long\
    \ long int k = stoi(value);\n    long long int l = stoi(value);\n    long long\
    \ int m = stoi(value);\n    long long int n = stoi(value);\n    long long int\
    \ o = stoi(value);\n    long long int p = stoi(value);\n    long long int q =\
    \ stoi(value);\n    long long int r = stoi(value);\n    long long int s = stoi(value);\n\
    \    long long int t = stoi(value);\n    long long int u = stoi(value);\n    long\
    \ long int v = stoi(value);\n    long long int w = stoi(value);\n    long long\
    \ int x = stoi(value);\n    long long int y = stoi(value);\n    long long int\
    \ z = stoi(value);\n    long long int a = stoi(value);\n    long long int b =\
    \ stoi(value);\n    long long int c = stoi(value);\n    long long int d = stoi(value);\n\
    \    long long int e = stoi(value);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpullwpm41.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpullwpm41.cpp:43:19: error: redeclaration of \u2018long long int a\u2019\
    \n   43 |     long long int a = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:17:19:\
    \ note: \u2018long long int a\u2019 previously declared here\n   17 |     long\
    \ long int a = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:44:19:\
    \ error: redeclaration of \u2018long long int b\u2019\n   44 |     long long int\
    \ b = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:18:19: note:\
    \ \u2018long long int b\u2019 previously declared here\n   18 |     long long\
    \ int b = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:45:19:\
    \ error: redeclaration of \u2018long long int c\u2019\n   45 |     long long int\
    \ c = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:19:19: note:\
    \ \u2018long long int c\u2019 previously declared here\n   19 |     long long\
    \ int c = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:46:19:\
    \ error: redeclaration of \u2018long long int d\u2019\n   46 |     long long int\
    \ d = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:20:19: note:\
    \ \u2018long long int d\u2019 previously declared here\n   20 |     long long\
    \ int d = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:47:19:\
    \ error: redeclaration of \u2018long long int e\u2019\n   47 |     long long int\
    \ e = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:21:19: note:\
    \ \u2018long long int e\u2019 previously declared here\n   21 |     long long\
    \ int e = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:48:19:\
    \ error: redeclaration of \u2018long long int f\u2019\n   48 |     long long int\
    \ f = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:22:19: note:\
    \ \u2018long long int f\u2019 previously declared here\n   22 |     long long\
    \ int f = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:49:19:\
    \ error: redeclaration of \u2018long long int g\u2019\n   49 |     long long int\
    \ g = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:23:19: note:\
    \ \u2018long "
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (lower > upper) {\n        std::swap(lower, upper);\n    }\n    long mid\
    \ = (lower + upper) / 2;\n    if (mid > upper) {\n        mid = upper;\n    }\n\
    \    if (mid < lower) {\n        mid = lower;\n    }\n    if (mid - std::stoll(value)\
    \ > 0) {\n        return mid;\n    }\n    return upper;\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpns5ps17_: /tmp/tmpns5ps17_.cpp:36: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    long long temp2;\n    long long temp3;\n    long long temp4;\n\
    \    long long temp5;\n    long long temp6;\n    long long temp7;\n    long long\
    \ temp8;\n    long long temp9;\n    long long temp10;\n    long long temp11;\n\
    \    long long temp12;\n    long long temp13;\n    long long temp14;\n    long\
    \ long temp15;\n    long long temp16;\n    long long temp17;\n    long long temp18;\n\
    \    long long temp19;\n    long long temp20;\n    long long temp21;\n    long\
    \ long temp22;\n    long long temp23;\n    long long temp24;\n    long long temp25;\n\
    \    long long temp26;\n    long long temp27;\n    long long temp28;\n    long\
    \ long temp29;\n    long long temp30;\n    long long temp31;\n    long long temp32;\n\
    \    long long temp33;\n    long long temp34;\n    long long temp35;\n    long\
    \ long temp36;\n    long long temp37;\n    long long temp38;\n    long long temp39;\n\
    \    long long temp40;\n    long long temp41;\n    long long temp42;\n    long\
    \ long temp43;\n    long long temp44;\n    long long temp45;\n    long long temp46;\n\
    \    long long temp47;\n    long long temp48;\n    long long temp49;\n    long\
    \ long temp50;\n    long long temp51;\n    long long temp52;\n    long long temp53;\n\
    \    long long temp54;\n    long long temp55;\n    long long temp56;\n    long\
    \ long temp57;\n    long long temp58;\n    long long temp59;\n    long long temp60;\n\
    \    long long temp61;\n    long long temp62;\n    long long temp63;\n    long\
    \ long temp64;\n    long long temp65;\n    long long temp66;\n    long long temp67;\n\
    \    long long temp68;\n    long long temp69;\n    long long temp70;\n    long\
    \ long temp71;\n    long long temp72;\n    long long temp73;\n    long long temp74;\n\
    \    long long temp75;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpna6oebfa: /tmp/tmpna6oebfa.cpp:96: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long sum = 0;\n    long count = 0;\n    long i = 0;\n\
    \    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long\
    \ n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n\
    \    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long\
    \ w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n\
    \    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long\
    \ F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n\
    \    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long\
    \ O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n\
    \    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long\
    \ X = 0;\n    long Y = 0;\n    long Z = 0;\n    long aa = 0;\n    long bb = 0;\n\
    \    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long\
    \ gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n    long kk =\
    \ 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n\
    \    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long\
    \ tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long xx =\
    \ 0;\n    long yy = 0;\n    long zz = 0;\n    long Aa = 0;\n    long Bb = 0;\n\
    \    long Cc = 0;\n    long Dd = 0;\n    long Ee = 0;\n    long Ff = 0;\n    long\
    \ Gg = 0;\n    long Hh = 0;\n    long Ii = 0;\n    long Jj = 0;\n    long Kk =\
    \ 0;\n    long Ll = 0;\n    long Mm = 0;\n    long Nn = 0;\n    long Oo = 0;\n\
    \    long Pp = 0;\n    long Qq = 0;\n    long Rr = 0;\n    long Ss = 0;\n    long\
    \ Tt = 0;\n    long Uu = 0;\n    long Vv = 0;\n    long Ww = 0;\n    long Xx =\
    \ 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpy04a1686: /tmp/tmpy04a1686.cpp:120: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    long diff = upper - lower;\n    long mid = lower + (diff / 2);\n \
    \   if (diff % 2 == 0) {\n        mid = std::max(mid, lower);\n    }\n    return\
    \ mid;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpbdq_gyf8: /tmp/tmpbdq_gyf8.cpp:27: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int int_value = std::stoll(value);\n\
    \    long long int int_min = (int_value - int_value % 10);\n    long long int\
    \ int_max = (int_value + int_value % 10);\n    if (int_min == int_max) {\n   \
    \     return int_min;\n    }\n    if (int_min > int_max) {\n        std::swap(int_min,\
    \ int_max);\n    }\n    long long int int_mid = (int_min + int_max) / 2;\n   \
    \ if (int_value == int_mid) {\n        return int_mid;\n    }\n    if (int_mid\
    \ > int_value) {\n        return int_mid;\n    }\n    return int_value;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpd1_68twb: /tmp/tmpd1_68twb.cpp:38: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int diff;\n    long long int min;\n    long long int max;\n    long long int\
    \ mid;\n    long long int mid2;\n    long long int mid3;\n    long long int mid4;\n\
    \    long long int mid5;\n    long long int mid6;\n    long long int mid7;\n \
    \   long long int mid8;\n    long long int mid9;\n    long long int mid10;\n \
    \   long long int mid11;\n    long long int mid12;\n    long long int mid13;\n\
    \    long long int mid14;\n    long long int mid15;\n    long long int mid16;\n\
    \    long long int mid17;\n    long long int mid18;\n    long long int mid19;\n\
    \    long long int mid20;\n    long long int mid21;\n    long long int mid22;\n\
    \    long long int mid23;\n    long long int mid24;\n    long long int mid25;\n\
    \    long long int mid26;\n    long long int mid27;\n    long long int mid28;\n\
    \    long long int mid29;\n    long long int mid30;\n    long long int mid31;\n\
    \    long long int mid32;\n    long long int mid33;\n    long long int mid34;\n\
    \    long long int mid35;\n    long long int mid36;\n    long long int mid37;\n\
    \    long long int mid38;\n    long long int mid39;\n    long long int mid40;\n\
    \    long long int mid41;\n    long long int mid42;\n    long long int mid43;\n\
    \    long long int mid44;\n    long long int mid45;\n    long long int mid46;\n\
    \    long long int mid47;\n    long long int mid48;\n    long long int mid49;\n\
    \    long long int mid50;\n    long long int mid51;\n    long long int mid52;\n\
    \    long long int mid53;\n    long long int mid54;\n    long long int mid55;\n\
    \    long long int mid56;\n    long long int mid57;\n    long long int mid58;\n\
    \    long long int mid59;\n    long long int mid60;\n    long long int mid61;\n\
    \    long long int mid62;\n    long long int mid63;\n\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpl27xde2d: /tmp/tmpl27xde2d.cpp:88: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int x = stoi(value);\n \
    \   long long int y = x;\n    long long int z = x;\n    long long int a = x;\n\
    \    long long int b = x;\n    long long int c = x;\n    long long int d = x;\n\
    \    long long int e = x;\n    long long int f = x;\n    long long int g = x;\n\
    \    long long int h = x;\n    long long int i = x;\n    long long int j = x;\n\
    \    long long int k = x;\n    long long int l = x;\n    long long int m = x;\n\
    \    long long int n = x;\n    long long int o = x;\n    long long int p = x;\n\
    \    long long int q = x;\n    long long int r = x;\n    long long int s = x;\n\
    \    long long int t = x;\n    long long int u = x;\n    long long int v = x;\n\
    \    long long int w = x;\n    long long int x = x;\n    long long int y = x;\n\
    \    long long int z = x;\n    long long int a = x;\n    long long int b = x;\n\
    \    long long int c = x;\n    long long int d = x;\n    long long int e = x;\n\
    \    long long int f = x;\n    long long int g = x;\n    long long int h = x;\n\
    \    long long int i = x;\n    long long int j = x;\n    long long int k = x;\n\
    \    long long int l = x;\n    long long int m = x;\n    long long int n = x;\n\
    \    long long int o = x;\n    long long int p = x;\n    long long int q = x;\n\
    \    long long int r = x;\n    long long int s = x;\n    long long int t = x;\n\
    \    long long int u = x;\n    long long int v = x;\n    long long int w = x;\n\
    \    long long int x = x;\n    long long int y = x;\n    long long int z = x;\n\
    \    long long int a = x;\n    long long int b = x;\n    long long int c = x;\n\
    \    long long int d = x;\n    long long int e = x;\n    long long int f = x;\n\
    \    long long int g = x;\n    long long int h = x;\n    long long int i = x;\n\
    \    long long int j = x;\n    long long int k = x;\n    long long int l = x;\n\
    \    long long int m = x;\n    long long int n = x;\n    long long int o = x;\n\
    \    long long int p = x;\n    long long int q = x;\n    long long int r = x;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpei0_hixh.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpei0_hixh.cpp:43:19: error: redeclaration of \u2018long long int x\u2019\
    \n   43 |     long long int x = x;\n      |                   ^\n/tmp/tmpei0_hixh.cpp:17:19:\
    \ note: \u2018long long int x\u2019 previously declared here\n   17 |     long\
    \ long int x = stoi(value);\n      |                   ^\n/tmp/tmpei0_hixh.cpp:44:19:\
    \ error: redeclaration of \u2018long long int y\u2019\n   44 |     long long int\
    \ y = x;\n      |                   ^\n/tmp/tmpei0_hixh.cpp:18:19: note: \u2018\
    long long int y\u2019 previously declared here\n   18 |     long long int y =\
    \ x;\n      |                   ^\n/tmp/tmpei0_hixh.cpp:45:19: error: redeclaration\
    \ of \u2018long long int z\u2019\n   45 |     long long int z = x;\n      |  \
    \                 ^\n/tmp/tmpei0_hixh.cpp:19:19: note: \u2018long long int z\u2019\
    \ previously declared here\n   19 |     long long int z = x;\n      |        \
    \           ^\n/tmp/tmpei0_hixh.cpp:46:19: error: redeclaration of \u2018long\
    \ long int a\u2019\n   46 |     long long int a = x;\n      |                \
    \   ^\n/tmp/tmpei0_hixh.cpp:20:19: note: \u2018long long int a\u2019 previously\
    \ declared here\n   20 |     long long int a = x;\n      |                   ^\n\
    /tmp/tmpei0_hixh.cpp:47:19: error: redeclaration of \u2018long long int b\u2019\
    \n   47 |     long long int b = x;\n      |                   ^\n/tmp/tmpei0_hixh.cpp:21:19:\
    \ note: \u2018long long int b\u2019 previously declared here\n   21 |     long\
    \ long int b = x;\n      |                   ^\n/tmp/tmpei0_hixh.cpp:48:19: error:\
    \ redeclaration of \u2018long long int c\u2019\n   48 |     long long int c =\
    \ x;\n      |                   ^\n/tmp/tmpei0_hixh.cpp:22:19: note: \u2018long\
    \ long int c\u2019 previously declared here\n   22 |     long long int c = x;\n\
    \      |                   ^\n/tmp/tmpei0_hixh.cpp:49:19: error: redeclaration\
    \ of \u2018long long int d\u2019\n   49 |     long long int d = x;\n      |  \
    \                 ^\n/tmp/tmpei0_hixh.cpp:23:19: note: \u2018long long int d\u2019\
    \ previously declared here\n   23 |     long long int d = x;\n      |        \
    \           ^\n/tmp/tmpei0_hixh.cpp"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = abs(atoi(value.c_str()));\n\
    \    long mid = diff / 2;\n    long left = diff - mid;\n    long right = diff\
    \ + mid;\n    if (left < right) {\n        ans = mid;\n    } else {\n        ans\
    \ = right;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpppsqkb6y: /tmp/tmpppsqkb6y.cpp:31: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long long temp;\n    temp = stoi(value);\n    if (temp > 0) {\n    \
    \    ans = temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpoxytw45w: /tmp/tmpoxytw45w.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ diff = upper - lower;\n    while (diff > 1) {\n        diff /= 10;\n       \
    \ lower *= 10;\n        upper *= 10;\n    }\n    return lower + diff;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp5ktprpxu: /tmp/tmp5ktprpxu.cpp:27: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long sum = 0;\n    long i = 0;\n    long j = 0;\n    long count = 0;\n  \
    \  long sum2 = 0;\n    long diff2 = 0;\n    long sum3 = 0;\n    long diff3 = 0;\n\
    \    long sum4 = 0;\n    long diff4 = 0;\n    long sum5 = 0;\n    long diff5 =\
    \ 0;\n    long sum6 = 0;\n    long diff6 = 0;\n    long sum7 = 0;\n    long diff7\
    \ = 0;\n    long sum8 = 0;\n    long diff8 = 0;\n    long sum9 = 0;\n    long\
    \ diff9 = 0;\n    long sum10 = 0;\n    long diff10 = 0;\n    long sum11 = 0;\n\
    \    long diff11 = 0;\n    long sum12 = 0;\n    long diff12 = 0;\n    long sum13\
    \ = 0;\n    long diff13 = 0;\n    long sum14 = 0;\n    long diff14 = 0;\n    long\
    \ sum15 = 0;\n    long diff15 = 0;\n    long sum16 = 0;\n    long diff16 = 0;\n\
    \    long sum17 = 0;\n    long diff17 = 0;\n    long sum18 = 0;\n    long diff18\
    \ = 0;\n    long sum19 = 0;\n    long diff19 = 0;\n    long sum20 = 0;\n    long\
    \ diff20 = 0;\n    long sum21 = 0;\n    long diff21 = 0;\n    long sum22 = 0;\n\
    \    long diff22 = 0;\n    long sum23 = 0;\n    long diff23 = 0;\n    long sum24\
    \ = 0;\n    long diff24 = 0;\n    long sum25 = 0;\n    long diff25 = 0;\n    long\
    \ sum26 = 0;\n    long diff26 = 0;\n    long sum27 = 0;\n    long diff27 = 0;\n\
    \    long sum28 = 0;\n    long diff28 = 0;\n    long sum29 = 0;\n    long diff29\
    \ = 0;\n    long sum30 = 0;\n    long diff30 = 0;\n    long sum31 = 0;\n    long\
    \ diff31 = 0;\n    long sum32 = 0;\n    long diff32 = 0;\n    long sum33 = 0;\n\
    \    long diff33 = 0;\n    long sum34 = 0;\n    long diff34 = 0;\n    long sum35\
    \ = 0;\n    long diff35 = 0;\n    long sum36 = 0;\n    long diff36 = 0;\n    long\
    \ sum37 = 0;\n    long diff37 = 0;\n    long sum38 = 0;\n    long diff38 = 0;\n\
    \    long sum39 = 0;\n    long diff39 = 0;\n    long sum40 = 0;\n    long diff40\
    \ = 0;\n    long sum41 = 0;\n    long diff41 = 0;\n    long sum42 = 0;\n    long\
    \ diff42 = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmptznjb5bd: /tmp/tmptznjb5bd.cpp:109: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long long int\
    \ x = std::stoll(value);\n    long long int y = std::stoll(value);\n    long long\
    \ int z = std::stoll(value);\n    long long int w = std::stoll(value);\n    long\
    \ long int v = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int s = std::stoll(value);\n\
    \    long long int r = std::stoll(value);\n    long long int q = std::stoll(value);\n\
    \    long long int p = std::stoll(value);\n    long long int o = std::stoll(value);\n\
    \    long long int n = std::stoll(value);\n    long long int m = std::stoll(value);\n\
    \    long long int l = std::stoll(value);\n    long long int k = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwkscvrc8.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpwkscvrc8.cpp:44:19: error: redeclaration of \u2018long long int j\u2019\
    \n   44 |     long long int j = std::stoll(value);\n      |                  \
    \ ^\n/tmp/tmpwkscvrc8.cpp:34:19: note: \u2018long long int j\u2019 previously\
    \ declared here\n   34 |     long long int j = std::stoll(value);\n      |   \
    \                ^\n/tmp/tmpwkscvrc8.cpp:45:19: error: redeclaration of \u2018\
    long long int i\u2019\n   45 |     long long int i = std::stoll(value);\n    \
    \  |                   ^\n/tmp/tmpwkscvrc8.cpp:35:19: note: \u2018long long int\
    \ i\u2019 previously declared here\n   35 |     long long int i = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:46:19: error: redeclaration\
    \ of \u2018long long int h\u2019\n   46 |     long long int h = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:36:19: note: \u2018long long\
    \ int h\u2019 previously declared here\n   36 |     long long int h = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:47:19: error: redeclaration\
    \ of \u2018long long int g\u2019\n   47 |     long long int g = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:37:19: note: \u2018long long\
    \ int g\u2019 previously declared here\n   37 |     long long int g = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:48:19: error: redeclaration\
    \ of \u2018long long int f\u2019\n   48 |     long long int f = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:38:19: note: \u2018long long\
    \ int f\u2019 previously declared here\n   38 |     long long int f = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:49:19: error: redeclaration\
    \ of \u2018long long int e\u2019\n   49 |     long long int e = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:39:19: note: \u2018long long\
    \ int e\u2019 previously declared here\n   39 |     long long int e = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpwkscvrc8.cpp:50:19: error: redeclaration\
    \ of \u2018long long int d\u2019\n   50 |     long long int d = std::stoll("
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0, sign\
    \ = 1, digit;\n  long len = value.length();\n  for (int i = 0; i < len; i++) {\n\
    \    digit = std::stoll(value.substr(i, 1));\n    ans += sign * digit;\n    sign\
    \ *= -1;\n  }\n  return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp2j8dl1qt: /tmp/tmp2j8dl1qt.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long diff = 0;\n    long sum = 0;\n    long i = 0;\n    long j\
    \ = 0;\n    long sum2 = 0;\n    long sum3 = 0;\n    long sum4 = 0;\n    long sum5\
    \ = 0;\n    long sum6 = 0;\n    long sum7 = 0;\n    long sum8 = 0;\n    long sum9\
    \ = 0;\n    long sum10 = 0;\n    long sum11 = 0;\n    long sum12 = 0;\n    long\
    \ sum13 = 0;\n    long sum14 = 0;\n    long sum15 = 0;\n    long sum16 = 0;\n\
    \    long sum17 = 0;\n    long sum18 = 0;\n    long sum19 = 0;\n    long sum20\
    \ = 0;\n    long sum21 = 0;\n    long sum22 = 0;\n    long sum23 = 0;\n    long\
    \ sum24 = 0;\n    long sum25 = 0;\n    long sum26 = 0;\n    long sum27 = 0;\n\
    \    long sum28 = 0;\n    long sum29 = 0;\n    long sum30 = 0;\n    long sum31\
    \ = 0;\n    long sum32 = 0;\n    long sum33 = 0;\n    long sum34 = 0;\n    long\
    \ sum35 = 0;\n    long sum36 = 0;\n    long sum37 = 0;\n    long sum38 = 0;\n\
    \    long sum39 = 0;\n    long sum40 = 0;\n    long sum41 = 0;\n    long sum42\
    \ = 0;\n    long sum43 = 0;\n    long sum44 = 0;\n    long sum45 = 0;\n    long\
    \ sum46 = 0;\n    long sum47 = 0;\n    long sum48 = 0;\n    long sum49 = 0;\n\
    \    long sum50 = 0;\n    long sum51 = 0;\n    long sum52 = 0;\n    long sum53\
    \ = 0;\n    long sum54 = 0;\n    long sum55 = 0;\n    long sum56 = 0;\n    long\
    \ sum57 = 0;\n    long sum58 = 0;\n    long sum59 = 0;\n    long sum60 = 0;\n\
    \    long sum61 = 0;\n    long sum62 = 0;\n    long sum63 = 0;\n    long sum64\
    \ = 0;\n    long sum65 = 0;\n    long sum66 = 0;\n    long sum67 = 0;\n    long\
    \ sum68 = 0;\n    long sum69 = 0;\n    long sum70 = 0;\n    long sum71 = 0;\n\
    \    long sum72 = 0;\n    long sum73 = 0;\n    long sum74 = 0;\n    long sum75\
    \ = 0;\n    long sum76 = 0;\n    long sum77 = 0;\n    long sum78 = 0;\n    long\
    \ sum79 = 0;\n    long sum80 = 0;\n    long sum81 = 0;\n    long sum82 = 0;\n\
    \    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpiz1xkvo7: /tmp/tmpiz1xkvo7.cpp:108: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long sum = 0;\n    long num = 0;\n    long temp = 0;\n    long count = 0;\n\
    \    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long\
    \ m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n\
    \    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long\
    \ v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n\
    \    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long\
    \ E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n\
    \    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long\
    \ N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n\
    \    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long\
    \ W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long aa = 0;\n\
    \    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long\
    \ ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj =\
    \ 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n\
    \    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long\
    \ ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww =\
    \ 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long Aa = 0;\n\
    \    long Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long Ee = 0;\n    long\
    \ Ff = 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii = 0;\n    long Jj =\
    \ 0;\n    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n    long Nn = 0;\n\
    \    long Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long Rr = 0;\n    long\
    \ Ss = 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv = 0;\n    long Ww =\
    \ 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3h50o5k0: /tmp/tmp3h50o5k0.cpp:120: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ x = stoi(value);\n    long y = stoi(value);\n    long z = stoi(value);\n   \
    \ long t = x;\n    long u = y;\n    long v = z;\n    long w = x;\n    long x =\
    \ y;\n    long y = z;\n    long z = t;\n    long a = x;\n    long b = y;\n   \
    \ long c = z;\n    long d = x;\n    long e = y;\n    long f = z;\n    long g =\
    \ x;\n    long h = y;\n    long i = z;\n    long j = t;\n    long k = x;\n   \
    \ long l = y;\n    long m = z;\n    long n = x;\n    long o = y;\n    long p =\
    \ z;\n    long q = t;\n    long r = x;\n    long s = y;\n    long t = z;\n   \
    \ long u = x;\n    long v = y;\n    long w = z;\n    long x = t;\n    long y =\
    \ u;\n    long z = v;\n    long a = x;\n    long b = y;\n    long c = z;\n   \
    \ long d = x;\n    long e = y;\n    long f = z;\n    long g = x;\n    long h =\
    \ y;\n    long i = z;\n    long j = t;\n    long k = x;\n    long l = y;\n   \
    \ long m = z;\n    long n = x;\n    long o = y;\n    long p = z;\n    long q =\
    \ t;\n    long r = x;\n    long s = y;\n    long t = z;\n    long u = x;\n   \
    \ long v = y;\n    long w = z;\n    long x = t;\n    long y = u;\n    long z =\
    \ v;\n    long a = x;\n    long b = y;\n    long c = z;\n    long d = x;\n   \
    \ long e = y;\n    long f = z;\n    long g = x;\n    long h = y;\n    long i =\
    \ z;\n    long j = t;\n    long k = x;\n    long l = y;\n    long m = z;\n   \
    \ long n = x;\n    long o = y;\n    long p = z;\n    long q = t;\n    long r =\
    \ x;\n    long s = y;\n    long t = z;\n    long u = x;\n    long v = y;\n   \
    \ long w = z;\n    long x = t;\n    long y = u;\n    long z = v;\n    long a =\
    \ x;\n    long b = y;\n    long c = z;\n    long d = x;\n    long e = y;\n   \
    \ long f = z;\n    long g = x;\n    long h = y;\n    long i = z;\n    long j =\
    \ t;\n    long k = x;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjnjj1efo.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjnjj1efo.cpp:25:10: error: redeclaration of \u2018long int x\u2019\n\
    \   25 |     long x = y;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:18:10: note:\
    \ \u2018long int x\u2019 previously declared here\n   18 |     long x = stoi(value);\n\
    \      |          ^\n/tmp/tmpjnjj1efo.cpp:26:10: error: redeclaration of \u2018\
    long int y\u2019\n   26 |     long y = z;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:19:10:\
    \ note: \u2018long int y\u2019 previously declared here\n   19 |     long y =\
    \ stoi(value);\n      |          ^\n/tmp/tmpjnjj1efo.cpp:27:10: error: redeclaration\
    \ of \u2018long int z\u2019\n   27 |     long z = t;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:20:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   20 |     long z =\
    \ stoi(value);\n      |          ^\n/tmp/tmpjnjj1efo.cpp:47:10: error: redeclaration\
    \ of \u2018long int t\u2019\n   47 |     long t = z;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:21:10:\
    \ note: \u2018long int t\u2019 previously declared here\n   21 |     long t =\
    \ x;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:48:10: error: redeclaration of\
    \ \u2018long int u\u2019\n   48 |     long u = x;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:22:10:\
    \ note: \u2018long int u\u2019 previously declared here\n   22 |     long u =\
    \ y;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:49:10: error: redeclaration of\
    \ \u2018long int v\u2019\n   49 |     long v = y;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:23:10:\
    \ note: \u2018long int v\u2019 previously declared here\n   23 |     long v =\
    \ z;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:50:10: error: redeclaration of\
    \ \u2018long int w\u2019\n   50 |     long w = z;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:24:10:\
    \ note: \u2018long int w\u2019 previously declared here\n   24 |     long w =\
    \ x;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:51:10: error: redeclaration of\
    \ \u2018long int x\u2019\n   51 |     long x = t;\n      |          ^\n/tmp/tmpjnjj1efo.cpp:18:10:\
    \ note: \u2018long int x\u2019 previously declared here\n   18 |     long x =\
    \ stoi(value);\n      |          ^\n/tmp/tmpjnjj1efo.cpp:52:10: error: redeclaration\
    \ of \u2018long int y\u2019\n   52 |     "
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = 0;\n    long long\
    \ int num2 = 0;\n    long long int num3 = 0;\n    long long int num4 = 0;\n  \
    \  long long int num5 = 0;\n    long long int num6 = 0;\n    long long int num7\
    \ = 0;\n    long long int num8 = 0;\n    long long int num9 = 0;\n    long long\
    \ int num10 = 0;\n    long long int num11 = 0;\n    long long int num12 = 0;\n\
    \    long long int num13 = 0;\n    long long int num14 = 0;\n    long long int\
    \ num15 = 0;\n    long long int num16 = 0;\n    long long int num17 = 0;\n   \
    \ long long int num18 = 0;\n    long long int num19 = 0;\n    long long int num20\
    \ = 0;\n    long long int num21 = 0;\n    long long int num22 = 0;\n    long long\
    \ int num23 = 0;\n    long long int num24 = 0;\n    long long int num25 = 0;\n\
    \    long long int num26 = 0;\n    long long int num27 = 0;\n    long long int\
    \ num28 = 0;\n    long long int num29 = 0;\n    long long int num30 = 0;\n   \
    \ long long int num31 = 0;\n    long long int num32 = 0;\n    long long int num33\
    \ = 0;\n    long long int num34 = 0;\n    long long int num35 = 0;\n    long long\
    \ int num36 = 0;\n    long long int num37 = 0;\n    long long int num38 = 0;\n\
    \    long long int num39 = 0;\n    long long int num40 = 0;\n    long long int\
    \ num41 = 0;\n    long long int num42 = 0;\n    long long int num43 = 0;\n   \
    \ long long int num44 = 0;\n    long long int num45 = 0;\n    long long int num46\
    \ = 0;\n    long long int num47 = 0;\n    long long int num48 = 0;\n    long long\
    \ int num49 = 0;\n    long long int num50 = 0;\n    long long int num51 = 0;\n\
    \    long long int num52 = 0;\n    long long int num53 = 0;\n    long long int\
    \ num54 = 0;\n    long long int num55 = 0;\n    long long int num56 = 0;\n   \
    \ long long int num57 = 0;\n    long long int num58 = 0;\n    long long int num59\
    \ = 0;\n    long long int num60 = 0;\n    long long int num61 = 0;\n    long long\
    \ int num62 = 0;\n    long long int num63 = 0;\n    long long int num64 = 0;\n\
    \    long long int num\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphlwr1i43.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmphlwr1i43.cpp:82:1: error: expected initializer before \u2018}\u2019\
    \ token\n   82 | }\n      | ^\n/tmp/tmphlwr1i43.cpp:82:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplq41houc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmplq41houc.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmplq41houc.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = 0;\n    long long\
    \ int min = 0;\n    long long int max = 0;\n    long long int mid = 0;\n    long\
    \ long int diff = 0;\n    long long int diff2 = 0;\n    long long int diff3 =\
    \ 0;\n    long long int diff4 = 0;\n    long long int diff5 = 0;\n    long long\
    \ int diff6 = 0;\n    long long int diff7 = 0;\n    long long int diff8 = 0;\n\
    \    long long int diff9 = 0;\n    long long int diff10 = 0;\n    long long int\
    \ diff11 = 0;\n    long long int diff12 = 0;\n    long long int diff13 = 0;\n\
    \    long long int diff14 = 0;\n    long long int diff15 = 0;\n    long long int\
    \ diff16 = 0;\n    long long int diff17 = 0;\n    long long int diff18 = 0;\n\
    \    long long int diff19 = 0;\n    long long int diff20 = 0;\n    long long int\
    \ diff21 = 0;\n    long long int diff22 = 0;\n    long long int diff23 = 0;\n\
    \    long long int diff24 = 0;\n    long long int diff25 = 0;\n    long long int\
    \ diff26 = 0;\n    long long int diff27 = 0;\n    long long int diff28 = 0;\n\
    \    long long int diff29 = 0;\n    long long int diff30 = 0;\n    long long int\
    \ diff31 = 0;\n    long long int diff32 = 0;\n    long long int diff33 = 0;\n\
    \    long long int diff34 = 0;\n    long long int diff35 = 0;\n    long long int\
    \ diff36 = 0;\n    long long int diff37 = 0;\n    long long int diff38 = 0;\n\
    \    long long int diff39 = 0;\n    long long int diff40 = 0;\n    long long int\
    \ diff41 = 0;\n    long long int diff42 = 0;\n    long long int diff43 = 0;\n\
    \    long long int diff44 = 0;\n    long long int diff45 = 0;\n    long long int\
    \ diff46 = 0;\n    long long int diff47 = 0;\n    long long int diff48 = 0;\n\
    \    long long int diff49 = 0;\n    long long int diff50 = 0;\n    long long int\
    \ diff51 = 0;\n    long long int diff52 = 0;\n    long long int diff53 = 0;\n\
    \    long long int diff54 = 0;\n    long long int diff55 = 0;\n    long long int\
    \ diff56 = 0;\n    long long int diff57 = 0;\n    long long int diff58 = 0;\n\
    \    long long int diff59 = 0;\n    long long int diff60 = 0;\n    long long int\
    \ diff61 = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp89i68lk2: /tmp/tmp89i68lk2.cpp:86: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long x = std::stoll(value);\n\
    \    long y = std::stoll(value);\n    long z = std::stoll(value);\n    long a\
    \ = std::stoll(value);\n    long b = std::stoll(value);\n    long c = std::stoll(value);\n\
    \    long d = std::stoll(value);\n    long e = std::stoll(value);\n    long f\
    \ = std::stoll(value);\n    long g = std::stoll(value);\n    long h = std::stoll(value);\n\
    \    long i = std::stoll(value);\n    long j = std::stoll(value);\n    long k\
    \ = std::stoll(value);\n    long l = std::stoll(value);\n    long m = std::stoll(value);\n\
    \    long n = std::stoll(value);\n    long o = std::stoll(value);\n    long p\
    \ = std::stoll(value);\n    long q = std::stoll(value);\n    long r = std::stoll(value);\n\
    \    long s = std::stoll(value);\n    long t = std::stoll(value);\n    long u\
    \ = std::stoll(value);\n    long v = std::stoll(value);\n    long w = std::stoll(value);\n\
    \    long x = std::stoll(value);\n    long y = std::stoll(value);\n    long z\
    \ = std::stoll(value);\n    long a = std::stoll(value);\n    long b = std::stoll(value);\n\
    \    long c = std::stoll(value);\n    long d = std::stoll(value);\n    long e\
    \ = std::stoll(value);\n    long f = std::stoll(value);\n    long g = std::stoll(value);\n\
    \    long h = std::stoll(value);\n    long i = std::stoll(value);\n    long j\
    \ = std::stoll(value);\n    long k = std::stoll(value);\n    long l = std::stoll(value);\n\
    \    long m = std::stoll(value);\n    long n = std::stoll(value);\n    long o\
    \ = std::stoll(value);\n    long p = std::stoll(value);\n    long q = std::stoll(value);\n\
    \    long r = std::stoll(value);\n    long s = std::stoll(value);\n    long t\
    \ = std::stoll(value);\n    long u = std::stoll(value);\n    long v = std::stoll(value);\n\
    \    long w = std::stoll(value);\n    long x = std::stoll(value);\n    long y\
    \ = std::stoll(value);\n    long z = std::stoll(value);\n    long a = std::stoll(value);\n\
    \    long b = \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmswoyrl9.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpmswoyrl9.cpp:44:10: error: redeclaration of \u2018long int x\u2019\n\
    \   44 |     long x = std::stoll(value);\n      |          ^\n/tmp/tmpmswoyrl9.cpp:18:10:\
    \ note: \u2018long int x\u2019 previously declared here\n   18 |     long x =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpmswoyrl9.cpp:45:10: error: redeclaration\
    \ of \u2018long int y\u2019\n   45 |     long y = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpmswoyrl9.cpp:19:10: note: \u2018long int y\u2019 previously\
    \ declared here\n   19 |     long y = std::stoll(value);\n      |          ^\n\
    /tmp/tmpmswoyrl9.cpp:46:10: error: redeclaration of \u2018long int z\u2019\n \
    \  46 |     long z = std::stoll(value);\n      |          ^\n/tmp/tmpmswoyrl9.cpp:20:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   20 |     long z =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpmswoyrl9.cpp:47:10: error: redeclaration\
    \ of \u2018long int a\u2019\n   47 |     long a = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpmswoyrl9.cpp:21:10: note: \u2018long int a\u2019 previously\
    \ declared here\n   21 |     long a = std::stoll(value);\n      |          ^\n\
    /tmp/tmpmswoyrl9.cpp:48:10: error: redeclaration of \u2018long int b\u2019\n \
    \  48 |     long b = std::stoll(value);\n      |          ^\n/tmp/tmpmswoyrl9.cpp:22:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   22 |     long b =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpmswoyrl9.cpp:49:10: error: redeclaration\
    \ of \u2018long int c\u2019\n   49 |     long c = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpmswoyrl9.cpp:23:10: note: \u2018long int c\u2019 previously\
    \ declared here\n   23 |     long c = std::stoll(value);\n      |          ^\n\
    /tmp/tmpmswoyrl9.cpp:50:10: error: redeclaration of \u2018long int d\u2019\n \
    \  50 |     long d = std::stoll(value);\n      |          ^\n/tmp/tmpmswoyrl9.cpp:24:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   24 |     long d =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpmswoyrl9.cpp:51:10: error: redeclaration\
    \ of \u2018long int e\u2019\n   51 |     long e = std::stoll(value);\n      |\
    \          ^\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ mid;\n    while (lower <= upper) {\n        mid = (lower + upper) / 2;\n   \
    \     if (mid * mid <= upper) {\n            upper = mid;\n        } else {\n\
    \            lower = mid;\n        }\n    }\n    return lower;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141465
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1;\n    long val = std::stoll(value);\n    long diff = val - ans;\n\
    \    if (diff < 0) {\n        sign = -1;\n        diff = diff * -1;\n    }\n \
    \   while (diff >= 1) {\n        diff /= 10;\n        ans += diff;\n    }\n  \
    \  return sign * ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphkxzesqn: /tmp/tmphkxzesqn.cpp:33: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int closest;\n    long long int diff2;\n    long long int\
    \ diff3;\n    long long int diff4;\n    long long int diff5;\n    long long int\
    \ diff6;\n    long long int diff7;\n    long long int diff8;\n    long long int\
    \ diff9;\n    long long int diff10;\n    long long int diff11;\n    long long\
    \ int diff12;\n    long long int diff13;\n    long long int diff14;\n    long\
    \ long int diff15;\n    long long int diff16;\n    long long int diff17;\n   \
    \ long long int diff18;\n    long long int diff19;\n    long long int diff20;\n\
    \    long long int diff21;\n    long long int diff22;\n    long long int diff23;\n\
    \    long long int diff24;\n    long long int diff25;\n    long long int diff26;\n\
    \    long long int diff27;\n    long long int diff28;\n    long long int diff29;\n\
    \    long long int diff30;\n    long long int diff31;\n    long long int diff32;\n\
    \    long long int diff33;\n    long long int diff34;\n    long long int diff35;\n\
    \    long long int diff36;\n    long long int diff37;\n    long long int diff38;\n\
    \    long long int diff39;\n    long long int diff40;\n    long long int diff41;\n\
    \    long long int diff42;\n    long long int diff43;\n    long long int diff44;\n\
    \    long long int diff45;\n    long long int diff46;\n    long long int diff47;\n\
    \    long long int diff48;\n    long long int diff49;\n    long long int diff50;\n\
    \    long long int diff51;\n    long long int diff52;\n    long long int diff53;\n\
    \    long long int diff54;\n    long long int diff55;\n    long long int diff56;\n\
    \    long long int diff57;\n    long long int diff58;\n    long long int diff59;\n\
    \    long long int diff60;\n    long long int diff61;\n    long long int diff62;\n\
    \    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyd2krdf_: /tmp/tmpyd2krdf_.cpp:88: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long sum = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long\
    \ ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii =\
    \ 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n\
    \    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long\
    \ rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv =\
    \ 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n\
    \    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long\
    \ Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii =\
    \ 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n\
    \    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long\
    \ Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv =\
    \ 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n    long Z\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphxykxbl0.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmphxykxbl0.cpp:116:1: error: expected initializer before \u2018}\u2019\
    \ token\n  116 | }\n      | ^\n/tmp/tmphxykxbl0.cpp:116:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long val = std::stoll(value);\n    long diff = val - ans;\n\
    \    if (diff < 0) {\n        diff = diff * -1;\n    }\n    if (diff > 100) {\n\
    \        diff = diff / 100;\n    }\n    if (diff > 10) {\n        diff = diff\
    \ / 10;\n    }\n    if (diff > 1) {\n        diff = diff / 1;\n    }\n    ans\
    \ = val + diff;\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr5tme8xq.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpr5tme8xq.cpp:20:10: error: redeclaration of \u2018long int diff\u2019\
    \n   20 |     long diff = val - ans;\n      |          ^~~~\n/tmp/tmpr5tme8xq.cpp:18:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuss07tjc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpuss07tjc.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpuss07tjc.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int x = std::stoll(value);\n\
    \    long long int y = std::stoll(value);\n    long long int z = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int k = std::stoll(value);\n\
    \    long long int l = std::stoll(value);\n    long long int m = std::stoll(value);\n\
    \    long long int n = std::stoll(value);\n    long long int o = std::stoll(value);\n\
    \    long long int p = std::stoll(value);\n    long long int q = std::stoll(value);\n\
    \    long long int r = std::stoll(value);\n    long long int s = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int a = std::stoll(value);\n\
    \    long long int b = std::stoll(value);\n    long long int c = std::stoll(value);\n\
    \    long long int d = std::stoll(value);\n    long long int e = std::stoll(value);\n\
    \    long long int f = std::stoll(value);\n    long long int g = std::stoll(value);\n\
    \    long long int h = std::stoll(value);\n    long long int i = std::stoll(value);\n\
    \    long long int j = std::stoll(value);\n    long long int k = std::stoll(value);\n\
    \    long long int l = std::stoll(value);\n    long long int m = std::stoll(value);\n\
    \    long long int n = std::stoll(value);\n    long long int o = std::stoll(value);\n\
    \    long long int p = std::stoll(value);\n    long long int q = std::\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpldu1riyx.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpldu1riyx.cpp:43:19: error: redeclaration of \u2018long long int w\u2019\
    \n   43 |     long long int w = std::stoll(value);\n      |                  \
    \ ^\n/tmp/tmpldu1riyx.cpp:20:19: note: \u2018long long int w\u2019 previously\
    \ declared here\n   20 |     long long int w = std::stoll(value);\n      |   \
    \                ^\n/tmp/tmpldu1riyx.cpp:44:19: error: redeclaration of \u2018\
    long long int x\u2019\n   44 |     long long int x = std::stoll(value);\n    \
    \  |                   ^\n/tmp/tmpldu1riyx.cpp:17:19: note: \u2018long long int\
    \ x\u2019 previously declared here\n   17 |     long long int x = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:45:19: error: redeclaration\
    \ of \u2018long long int y\u2019\n   45 |     long long int y = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:18:19: note: \u2018long long\
    \ int y\u2019 previously declared here\n   18 |     long long int y = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:46:19: error: redeclaration\
    \ of \u2018long long int z\u2019\n   46 |     long long int z = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:19:19: note: \u2018long long\
    \ int z\u2019 previously declared here\n   19 |     long long int z = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:47:19: error: redeclaration\
    \ of \u2018long long int a\u2019\n   47 |     long long int a = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:21:19: note: \u2018long long\
    \ int a\u2019 previously declared here\n   21 |     long long int a = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:48:19: error: redeclaration\
    \ of \u2018long long int b\u2019\n   48 |     long long int b = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:22:19: note: \u2018long long\
    \ int b\u2019 previously declared here\n   22 |     long long int b = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpldu1riyx.cpp:49:19: error: redeclaration\
    \ of \u2018long long int c\u2019\n   49 |     long long int c = std::stoll("
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ mid;\n    while (lower <= upper) {\n        mid = (lower + upper) / 2;\n   \
    \     if (mid * mid > upper * lower) {\n            upper = mid - 1;\n       \
    \ } else {\n            lower = mid + 1;\n        }\n    }\n    return mid;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpp_i9lud4: /tmp/tmpp_i9lud4.cpp:30: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long diff = abs(n - ans);\n    if (diff > 10) {\n    \
    \    diff = diff - 10;\n        ans = ans + diff;\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzz7z75rw.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpzz7z75rw.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = abs(n - ans);\n      |          ^~~~\n/tmp/tmpzz7z75rw.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnro_jpvo: /tmp/tmpnro_jpvo.cpp:88: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ diff = upper - lower;\n    if (diff > 0) return lower;\n    if (diff < 0) return\
    \ upper;\n    if (diff == 0) {\n        if (lower == 0) return 0;\n        if\
    \ (upper == 0) return 0;\n        return lower;\n    }\n    if (lower == 0) return\
    \ upper;\n    if (upper == 0) return lower;\n    if (lower == upper) return lower;\n\
    \    if (lower == std::stoll(value)) return lower;\n    if (upper == std::stoll(value))\
    \ return upper;\n    if (lower == std::stoll(value) && upper == std::stoll(value))\
    \ return lower;\n    if (lower == std::stoll(value) && upper == std::stoll(value)\
    \ && lower == upper) return lower;\n    if (lower == std::stoll(value) && upper\
    \ == std::stoll(value) && lower == upper && lower > upper) return upper;\n   \
    \ if (lower == std::stoll(value) && upper == std::stoll(value) && lower == upper\
    \ && lower > upper && lower < upper) return lower;\n    if (lower == std::stoll(value)\
    \ && upper == std::stoll(value) && lower == upper && lower > upper && lower <\
    \ upper && lower > lower) return upper;\n    if (lower == std::stoll(value) &&\
    \ upper == std::stoll(value) && lower == upper && lower > upper && lower < upper\
    \ && lower > lower && upper < lower) return lower;\n    if (lower == std::stoll(value)\
    \ && upper == std::stoll(value) && lower == upper && lower > upper && lower <\
    \ upper && lower > lower && upper < lower && upper > lower) return upper;\n  \
    \  if (lower == std::stoll(value) && upper == std::stoll(value) && lower == upper\
    \ && lower > upper && lower < upper && lower > lower && upper < lower && upper\
    \ > lower && upper < upper) return lower;\n    if (lower == std::stoll(value)\
    \ && upper == std::stoll(value) && lower == upper && lower > upper && lower <\
    \ upper && lower > lower && upper < lower && upper > lower && upper < upper &&\
    \ lower > upper) return upper;\n    if (lower == std::stoll(value) && upper ==\
    \ std::stoll(value) && lower == upper && lower > upper && lower < upper && lower\
    \ > lower && upper < lower && upper > lower && upper < upper && lower > upper\
    \ && upper > lower) return lower;\n    if (lower == std::stoll(value) && upper\
    \ == std::stoll(value) && lower == upper && lower > upper && \n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbxdvi0pr.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpbxdvi0pr.cpp:41:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   41 | }\n      | ^\n/tmp/tmpbxdvi0pr.cpp:40:103: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   40 |     if (lower == std::stoll(value)\
    \ && upper == std::stoll(value) && lower == upper && lower > upper &&\n      |\
    \        ~                                                                   \
    \                           ^\n      |                                       \
    \                                                                )\n   41 | }\n\
    \      | ~                                                                   \
    \                                   \n/tmp/tmpbxdvi0pr.cpp:41:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   41 | }\n      | ^\n/tmp/tmpbxdvi0pr.cpp:41:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   41 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long diff = n - ans;\n    if (diff < 0) {\n        diff\
    \ = diff * -1;\n    }\n    long power = 1;\n    while (diff >= power) {\n    \
    \    diff /= power;\n        power *= 10;\n    }\n    ans = n;\n    while (diff\
    \ > 0) {\n        diff /= 10;\n        ans *= 10;\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpur55z_ud.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpur55z_ud.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmpur55z_ud.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141462
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ num = std::stoll(value);\n    long diff = abs(num);\n    long mod = num % 10;\n\
    \    if (mod != 0) {\n        ans = num / 10;\n        diff = diff + 1;\n    }\n\
    \    while (diff > 1) {\n        ans = ans * 10;\n        diff = diff - 1;\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6d2i8nh6.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp6d2i8nh6.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = abs(num);\n      |          ^~~~\n/tmp/tmp6d2i8nh6.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int a = stoi(value);\n \
    \   long long int b = stoi(value);\n    long long int c = stoi(value);\n    long\
    \ long int d = stoi(value);\n    long long int e = stoi(value);\n    long long\
    \ int f = stoi(value);\n    long long int g = stoi(value);\n    long long int\
    \ h = stoi(value);\n    long long int i = stoi(value);\n    long long int j =\
    \ stoi(value);\n    long long int k = stoi(value);\n    long long int l = stoi(value);\n\
    \    long long int m = stoi(value);\n    long long int n = stoi(value);\n    long\
    \ long int o = stoi(value);\n    long long int p = stoi(value);\n    long long\
    \ int q = stoi(value);\n    long long int r = stoi(value);\n    long long int\
    \ s = stoi(value);\n    long long int t = stoi(value);\n    long long int u =\
    \ stoi(value);\n    long long int v = stoi(value);\n    long long int w = stoi(value);\n\
    \    long long int x = stoi(value);\n    long long int y = stoi(value);\n    long\
    \ long int z = stoi(value);\n    long long int a = stoi(value);\n    long long\
    \ int b = stoi(value);\n    long long int c = stoi(value);\n    long long int\
    \ d = stoi(value);\n    long long int e = stoi(value);\n    long long int f =\
    \ stoi(value);\n    long long int g = stoi(value);\n    long long int h = stoi(value);\n\
    \    long long int i = stoi(value);\n    long long int j = stoi(value);\n    long\
    \ long int k = stoi(value);\n    long long int l = stoi(value);\n    long long\
    \ int m = stoi(value);\n    long long int n = stoi(value);\n    long long int\
    \ o = stoi(value);\n    long long int p = stoi(value);\n    long long int q =\
    \ stoi(value);\n    long long int r = stoi(value);\n    long long int s = stoi(value);\n\
    \    long long int t = stoi(value);\n    long long int u = stoi(value);\n    long\
    \ long int v = stoi(value);\n    long long int w = stoi(value);\n    long long\
    \ int x = stoi(value);\n    long long int y = stoi(value);\n    long long int\
    \ z = stoi(value);\n    long long int a = stoi(value);\n    long long int b =\
    \ stoi(value);\n    long long int c = stoi(value);\n    long long int d = stoi(value);\n\
    \    long long int e = stoi(value);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpullwpm41.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpullwpm41.cpp:43:19: error: redeclaration of \u2018long long int a\u2019\
    \n   43 |     long long int a = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:17:19:\
    \ note: \u2018long long int a\u2019 previously declared here\n   17 |     long\
    \ long int a = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:44:19:\
    \ error: redeclaration of \u2018long long int b\u2019\n   44 |     long long int\
    \ b = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:18:19: note:\
    \ \u2018long long int b\u2019 previously declared here\n   18 |     long long\
    \ int b = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:45:19:\
    \ error: redeclaration of \u2018long long int c\u2019\n   45 |     long long int\
    \ c = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:19:19: note:\
    \ \u2018long long int c\u2019 previously declared here\n   19 |     long long\
    \ int c = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:46:19:\
    \ error: redeclaration of \u2018long long int d\u2019\n   46 |     long long int\
    \ d = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:20:19: note:\
    \ \u2018long long int d\u2019 previously declared here\n   20 |     long long\
    \ int d = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:47:19:\
    \ error: redeclaration of \u2018long long int e\u2019\n   47 |     long long int\
    \ e = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:21:19: note:\
    \ \u2018long long int e\u2019 previously declared here\n   21 |     long long\
    \ int e = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:48:19:\
    \ error: redeclaration of \u2018long long int f\u2019\n   48 |     long long int\
    \ f = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:22:19: note:\
    \ \u2018long long int f\u2019 previously declared here\n   22 |     long long\
    \ int f = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:49:19:\
    \ error: redeclaration of \u2018long long int g\u2019\n   49 |     long long int\
    \ g = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:23:19: note:\
    \ \u2018long "
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp = 0;\n    long long temp2 = 0;\n    long\
    \ long temp3 = 0;\n    long long temp4 = 0;\n    long long temp5 = 0;\n    long\
    \ long temp6 = 0;\n    long long temp7 = 0;\n    long long temp8 = 0;\n    long\
    \ long temp9 = 0;\n    long long temp10 = 0;\n    long long temp11 = 0;\n    long\
    \ long temp12 = 0;\n    long long temp13 = 0;\n    long long temp14 = 0;\n   \
    \ long long temp15 = 0;\n    long long temp16 = 0;\n    long long temp17 = 0;\n\
    \    long long temp18 = 0;\n    long long temp19 = 0;\n    long long temp20 =\
    \ 0;\n    long long temp21 = 0;\n    long long temp22 = 0;\n    long long temp23\
    \ = 0;\n    long long temp24 = 0;\n    long long temp25 = 0;\n    long long temp26\
    \ = 0;\n    long long temp27 = 0;\n    long long temp28 = 0;\n    long long temp29\
    \ = 0;\n    long long temp30 = 0;\n    long long temp31 = 0;\n    long long temp32\
    \ = 0;\n    long long temp33 = 0;\n    long long temp34 = 0;\n    long long temp35\
    \ = 0;\n    long long temp36 = 0;\n    long long temp37 = 0;\n    long long temp38\
    \ = 0;\n    long long temp39 = 0;\n    long long temp40 = 0;\n    long long temp41\
    \ = 0;\n    long long temp42 = 0;\n    long long temp43 = 0;\n    long long temp44\
    \ = 0;\n    long long temp45 = 0;\n    long long temp46 = 0;\n    long long temp47\
    \ = 0;\n    long long temp48 = 0;\n    long long temp49 = 0;\n    long long temp50\
    \ = 0;\n    long long temp51 = 0;\n    long long temp52 = 0;\n    long long temp53\
    \ = 0;\n    long long temp54 = 0;\n    long long temp55 = 0;\n    long long temp56\
    \ = 0;\n    long long temp57 = 0;\n    long long temp58 = 0;\n    long long temp59\
    \ = 0;\n    long long temp60 = 0;\n    long long temp61 = 0;\n    long long temp62\
    \ = 0;\n    long long temp63 = 0;\n    long long temp64 = 0;\n    long long temp65\
    \ = 0;\n    long long temp66 = 0;\n    long long temp67 = 0;\n    long long temp68\
    \ = 0;\n    long long temp69 = 0;\n    long long temp70 = 0;\n    long long temp71\
    \ = 0;\n    long long temp72 = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpvulg4r07: /tmp/tmpvulg4r07.cpp:95: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int num2;\n    long long int num3;\n    long long int num4;\n    long long int\
    \ num5;\n    long long int num6;\n    long long int num7;\n    long long int num8;\n\
    \    long long int num9;\n    long long int num10;\n    long long int num11;\n\
    \    long long int num12;\n    long long int num13;\n    long long int num14;\n\
    \    long long int num15;\n    long long int num16;\n    long long int num17;\n\
    \    long long int num18;\n    long long int num19;\n    long long int num20;\n\
    \    long long int num21;\n    long long int num22;\n    long long int num23;\n\
    \    long long int num24;\n    long long int num25;\n    long long int num26;\n\
    \    long long int num27;\n    long long int num28;\n    long long int num29;\n\
    \    long long int num30;\n    long long int num31;\n    long long int num32;\n\
    \    long long int num33;\n    long long int num34;\n    long long int num35;\n\
    \    long long int num36;\n    long long int num37;\n    long long int num38;\n\
    \    long long int num39;\n    long long int num40;\n    long long int num41;\n\
    \    long long int num42;\n    long long int num43;\n    long long int num44;\n\
    \    long long int num45;\n    long long int num46;\n    long long int num47;\n\
    \    long long int num48;\n    long long int num49;\n    long long int num50;\n\
    \    long long int num51;\n    long long int num52;\n    long long int num53;\n\
    \    long long int num54;\n    long long int num55;\n    long long int num56;\n\
    \    long long int num57;\n    long long int num58;\n    long long int num59;\n\
    \    long long int num60;\n    long long int num61;\n    long long int num62;\n\
    \    long long int num63;\n    long long int num64;\n    long long int num65;\n\
    \    long long int num66;\n    long long int \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppnpf_gbd.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppnpf_gbd.cpp:84:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   84 | }\n      | ^\n/tmp/tmppnpf_gbd.cpp:84:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141462
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    if (value.front()\
    \ == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    long num\
    \ = std::stoll(value);\n    if (num < 0) {\n        num = -num;\n    }\n    if\
    \ (num == 0) {\n        throw std::invalid_argument(\"Invalid number\");\n   \
    \ }\n    long diff = abs(num);\n    long max_diff = abs(ans);\n    while (diff\
    \ > max_diff) {\n        ans += sign;\n        diff -= max_diff;\n        max_diff\
    \ = abs(ans);\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpr379vw2y: /tmp/tmpr379vw2y.cpp:40: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, x = 0, y = 0;\n    long long temp;\n    temp = std::stoll(value);\n    x\
    \ = temp % 10;\n    y = temp / 10;\n    if (x == 0 && y == 0) {\n        ans =\
    \ temp;\n    } else {\n        if (x < y) {\n            ans = temp;\n       \
    \ } else {\n            ans = temp;\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpo1rnj48_: /tmp/tmpo1rnj48_.cpp:37: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long diff2 = 0;\n    long diff3 = 0;\n    long diff4 = 0;\n    long diff5\
    \ = 0;\n    long diff6 = 0;\n    long diff7 = 0;\n    long diff8 = 0;\n    long\
    \ diff9 = 0;\n    long diff10 = 0;\n    long diff11 = 0;\n    long diff12 = 0;\n\
    \    long diff13 = 0;\n    long diff14 = 0;\n    long diff15 = 0;\n    long diff16\
    \ = 0;\n    long diff17 = 0;\n    long diff18 = 0;\n    long diff19 = 0;\n   \
    \ long diff20 = 0;\n    long diff21 = 0;\n    long diff22 = 0;\n    long diff23\
    \ = 0;\n    long diff24 = 0;\n    long diff25 = 0;\n    long diff26 = 0;\n   \
    \ long diff27 = 0;\n    long diff28 = 0;\n    long diff29 = 0;\n    long diff30\
    \ = 0;\n    long diff31 = 0;\n    long diff32 = 0;\n    long diff33 = 0;\n   \
    \ long diff34 = 0;\n    long diff35 = 0;\n    long diff36 = 0;\n    long diff37\
    \ = 0;\n    long diff38 = 0;\n    long diff39 = 0;\n    long diff40 = 0;\n   \
    \ long diff41 = 0;\n    long diff42 = 0;\n    long diff43 = 0;\n    long diff44\
    \ = 0;\n    long diff45 = 0;\n    long diff46 = 0;\n    long diff47 = 0;\n   \
    \ long diff48 = 0;\n    long diff49 = 0;\n    long diff50 = 0;\n    long diff51\
    \ = 0;\n    long diff52 = 0;\n    long diff53 = 0;\n    long diff54 = 0;\n   \
    \ long diff55 = 0;\n    long diff56 = 0;\n    long diff57 = 0;\n    long diff58\
    \ = 0;\n    long diff59 = 0;\n    long diff60 = 0;\n    long diff61 = 0;\n   \
    \ long diff62 = 0;\n    long diff63 = 0;\n    long diff64 = 0;\n    long diff65\
    \ = 0;\n    long diff66 = 0;\n    long diff67 = 0;\n    long diff68 = 0;\n   \
    \ long diff69 = 0;\n    long diff70 = 0;\n    long diff71 = 0;\n    long diff72\
    \ = 0;\n    long diff73 = 0;\n    long diff74 = 0;\n    long diff75 = 0;\n   \
    \ long diff76 = 0;\n    long diff77 = 0;\n    long diff78 = 0;\n    long diff79\
    \ = 0;\n    long diff80 = 0;\n    long diff81 = 0;\n    long diff82 = 0;\n   \
    \ long diff83 = 0;\n    long diff84 = 0;\n    long diff85 = 0;\n    long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptun6sgzs.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptun6sgzs.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmptun6sgzs.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long num = stoi(value);\n    long mod = num % 10;\n    long num2 = num /\
    \ 10;\n    long num3 = num2 / 10;\n    long num4 = num3 / 10;\n    long num5 =\
    \ num4 / 10;\n    long num6 = num5 / 10;\n    long num7 = num6 / 10;\n    long\
    \ num8 = num7 / 10;\n    long num9 = num8 / 10;\n    long num10 = num9 / 10;\n\
    \    long num11 = num10 / 10;\n    long num12 = num11 / 10;\n    long num13 =\
    \ num12 / 10;\n    long num14 = num13 / 10;\n    long num15 = num14 / 10;\n  \
    \  long num16 = num15 / 10;\n    long num17 = num16 / 10;\n    long num18 = num17\
    \ / 10;\n    long num19 = num18 / 10;\n    long num20 = num19 / 10;\n    long\
    \ num21 = num20 / 10;\n    long num22 = num21 / 10;\n    long num23 = num22 /\
    \ 10;\n    long num24 = num23 / 10;\n    long num25 = num24 / 10;\n    long num26\
    \ = num25 / 10;\n    long num27 = num26 / 10;\n    long num28 = num27 / 10;\n\
    \    long num29 = num28 / 10;\n    long num30 = num29 / 10;\n    long num31 =\
    \ num30 / 10;\n    long num32 = num31 / 10;\n    long num33 = num32 / 10;\n  \
    \  long num34 = num33 / 10;\n    long num35 = num34 / 10;\n    long num36 = num35\
    \ / 10;\n    long num37 = num36 / 10;\n    long num38 = num37 / 10;\n    long\
    \ num39 = num38 / 10;\n    long num40 = num39 / 10;\n    long num41 = num40 /\
    \ 10;\n    long num42 = num41 / 10;\n    long num43 = num42 / 10;\n    long num44\
    \ = num43 / 10;\n    long num45 = num44 / 10;\n    long num46 = num45 / 10;\n\
    \    long num47 = num46 / 10;\n    long num48 = num47 / 10;\n    long num49 =\
    \ num48 / 10;\n    long num50 = num49 / 10;\n    long num51 = num50 / 10;\n\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpbydqhgql: /tmp/tmpbydqhgql.cpp:75: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long n = stoi(value);\n    long m = stoi(value);\n    long\
    \ d = abs(n - m);\n    if (d > 1) {\n        diff = d;\n    } else {\n       \
    \ diff = n - m;\n    }\n    while (diff > 1) {\n        diff /= 10;\n        ans\
    \ += diff;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpp2rvtlhu: /tmp/tmpp2rvtlhu.cpp:35: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    long diff = upper - lower;\n    if (diff > 0)\n        return lower;\n\
    \    else if (diff < 0)\n        return upper;\n    else\n        return std::stoll(value);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmps2ydz3fx: /tmp/tmps2ydz3fx.cpp:28: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp49t1rysj: /tmp/tmp49t1rysj.cpp:106: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141462
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long int temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if\
    \ (diff < 0) {\n        diff += temp;\n    }\n    if (diff > temp) {\n       \
    \ diff = temp - ans;\n    }\n    ans = temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpgy2qv2fb: /tmp/tmpgy2qv2fb.cpp:33: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long temp;\n    long long temp2;\n    long long temp3;\n \
    \   long long temp4;\n    long long temp5;\n    long long temp6;\n    long long\
    \ temp7;\n    long long temp8;\n    long long temp9;\n    long long temp10;\n\
    \    long long temp11;\n    long long temp12;\n    long long temp13;\n    long\
    \ long temp14;\n    long long temp15;\n    long long temp16;\n    long long temp17;\n\
    \    long long temp18;\n    long long temp19;\n    long long temp20;\n    long\
    \ long temp21;\n    long long temp22;\n    long long temp23;\n    long long temp24;\n\
    \    long long temp25;\n    long long temp26;\n    long long temp27;\n    long\
    \ long temp28;\n    long long temp29;\n    long long temp30;\n    long long temp31;\n\
    \    long long temp32;\n    long long temp33;\n    long long temp34;\n    long\
    \ long temp35;\n    long long temp36;\n    long long temp37;\n    long long temp38;\n\
    \    long long temp39;\n    long long temp40;\n    long long temp41;\n    long\
    \ long temp42;\n    long long temp43;\n    long long temp44;\n    long long temp45;\n\
    \    long long temp46;\n    long long temp47;\n    long long temp48;\n    long\
    \ long temp49;\n    long long temp50;\n    long long temp51;\n    long long temp52;\n\
    \    long long temp53;\n    long long temp54;\n    long long temp55;\n    long\
    \ long temp56;\n    long long temp57;\n    long long temp58;\n    long long temp59;\n\
    \    long long temp60;\n    long long temp61;\n    long long temp62;\n    long\
    \ long temp63;\n    long long temp64;\n    long long temp65;\n    long long temp66;\n\
    \    long long temp67;\n    long long temp68;\n    long long temp69;\n    long\
    \ long temp70;\n    long long temp71;\n    long long temp72;\n    long long temp73;\n\
    \    long long temp74;\n    long \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvzit500o.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpvzit500o.cpp:94:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   94 | }\n      | ^\n/tmp/tmpvzit500o.cpp:94:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long count = 0;\n    long sum = 0;\n    long mid = 0;\n\
    \    long mid2 = 0;\n    long mid3 = 0;\n    long mid4 = 0;\n    long mid5 = 0;\n\
    \    long mid6 = 0;\n    long mid7 = 0;\n    long mid8 = 0;\n    long mid9 = 0;\n\
    \    long mid10 = 0;\n    long mid11 = 0;\n    long mid12 = 0;\n    long mid13\
    \ = 0;\n    long mid14 = 0;\n    long mid15 = 0;\n    long mid16 = 0;\n    long\
    \ mid17 = 0;\n    long mid18 = 0;\n    long mid19 = 0;\n    long mid20 = 0;\n\
    \    long mid21 = 0;\n    long mid22 = 0;\n    long mid23 = 0;\n    long mid24\
    \ = 0;\n    long mid25 = 0;\n    long mid26 = 0;\n    long mid27 = 0;\n    long\
    \ mid28 = 0;\n    long mid29 = 0;\n    long mid30 = 0;\n    long mid31 = 0;\n\
    \    long mid32 = 0;\n    long mid33 = 0;\n    long mid34 = 0;\n    long mid35\
    \ = 0;\n    long mid36 = 0;\n    long mid37 = 0;\n    long mid38 = 0;\n    long\
    \ mid39 = 0;\n    long mid40 = 0;\n    long mid41 = 0;\n    long mid42 = 0;\n\
    \    long mid43 = 0;\n    long mid44 = 0;\n    long mid45 = 0;\n    long mid46\
    \ = 0;\n    long mid47 = 0;\n    long mid48 = 0;\n    long mid49 = 0;\n    long\
    \ mid50 = 0;\n    long mid51 = 0;\n    long mid52 = 0;\n    long mid53 = 0;\n\
    \    long mid54 = 0;\n    long mid55 = 0;\n    long mid56 = 0;\n    long mid57\
    \ = 0;\n    long mid58 = 0;\n    long mid59 = 0;\n    long mid60 = 0;\n    long\
    \ mid61 = 0;\n    long mid62 = 0;\n    long mid63 = 0;\n    long mid64 = 0;\n\
    \    long mid65 = 0;\n    long mid66 = 0;\n    long mid67 = 0;\n    long mid68\
    \ = 0;\n    long mid69 = 0;\n    long mid70 = 0;\n    long mid71 = 0;\n    long\
    \ mid72 = 0;\n    long mid73 = 0;\n    long mid74 = 0;\n    long mid75 = 0;\n\
    \    long mid76 = 0;\n    long mid77 = 0;\n    long mid78 = 0;\n    long mid79\
    \ = 0;\n    long mid80 = 0;\n    long mid81 = 0;\n    long mid82 = 0;\n    \n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpvio_dh1x: /tmp/tmpvio_dh1x.cpp:108: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ x = stoi(value);\n    long y = x;\n    long z = x;\n    long a = x;\n    long\
    \ b = x;\n    long c = x;\n    long d = x;\n    long e = x;\n    long f = x;\n\
    \    long g = x;\n    long h = x;\n    long i = x;\n    long j = x;\n    long\
    \ k = x;\n    long l = x;\n    long m = x;\n    long n = x;\n    long o = x;\n\
    \    long p = x;\n    long q = x;\n    long r = x;\n    long s = x;\n    long\
    \ t = x;\n    long u = x;\n    long v = x;\n    long w = x;\n    long x = x;\n\
    \    long y = x;\n    long z = x;\n    long a = x;\n    long b = x;\n    long\
    \ c = x;\n    long d = x;\n    long e = x;\n    long f = x;\n    long g = x;\n\
    \    long h = x;\n    long i = x;\n    long j = x;\n    long k = x;\n    long\
    \ l = x;\n    long m = x;\n    long n = x;\n    long o = x;\n    long p = x;\n\
    \    long q = x;\n    long r = x;\n    long s = x;\n    long t = x;\n    long\
    \ u = x;\n    long v = x;\n    long w = x;\n    long x = x;\n    long y = x;\n\
    \    long z = x;\n    long a = x;\n    long b = x;\n    long c = x;\n    long\
    \ d = x;\n    long e = x;\n    long f = x;\n    long g = x;\n    long h = x;\n\
    \    long i = x;\n    long j = x;\n    long k = x;\n    long l = x;\n    long\
    \ m = x;\n    long n = x;\n    long o = x;\n    long p = x;\n    long q = x;\n\
    \    long r = x;\n    long s = x;\n    long t = x;\n    long u = x;\n    long\
    \ v = x;\n    long w = x;\n    long x = x;\n    long y = x;\n    long z = x;\n\
    \    long a = x;\n    long b = x;\n    long c = x;\n    long d = x;\n    long\
    \ e = x;\n    long f = x;\n    long g = x;\n    long h = x;\n    long i = x;\n\
    \    long j = x;\n    long k = x;\n    long l = x;\n    long m = x;\n    long\
    \ n = x;\n    long o = x;\n    long p = x;\n    long q = x;\n    long r = x;\n\
    \    long s = x;\n    long \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwpf62xge.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpwpf62xge.cpp:44:10: error: redeclaration of \u2018long int x\u2019\n\
    \   44 |     long x = x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:18:10: note:\
    \ \u2018long int x\u2019 previously declared here\n   18 |     long x = stoi(value);\n\
    \      |          ^\n/tmp/tmpwpf62xge.cpp:45:10: error: redeclaration of \u2018\
    long int y\u2019\n   45 |     long y = x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:19:10:\
    \ note: \u2018long int y\u2019 previously declared here\n   19 |     long y =\
    \ x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:46:10: error: redeclaration of\
    \ \u2018long int z\u2019\n   46 |     long z = x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:20:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   20 |     long z =\
    \ x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:47:10: error: redeclaration of\
    \ \u2018long int a\u2019\n   47 |     long a = x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:21:10:\
    \ note: \u2018long int a\u2019 previously declared here\n   21 |     long a =\
    \ x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:48:10: error: redeclaration of\
    \ \u2018long int b\u2019\n   48 |     long b = x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:22:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   22 |     long b =\
    \ x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:49:10: error: redeclaration of\
    \ \u2018long int c\u2019\n   49 |     long c = x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:23:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   23 |     long c =\
    \ x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:50:10: error: redeclaration of\
    \ \u2018long int d\u2019\n   50 |     long d = x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:24:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   24 |     long d =\
    \ x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:51:10: error: redeclaration of\
    \ \u2018long int e\u2019\n   51 |     long e = x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:25:10:\
    \ note: \u2018long int e\u2019 previously declared here\n   25 |     long e =\
    \ x;\n      |          ^\n/tmp/tmpwpf62xge.cpp:52:10: error: redeclaration of\
    \ \u2018long int f\u2019\n   52 |     long f = x;\n      |          ^"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ diff = upper - lower;\n    if (diff == 0) {\n        return lower;\n    }\n\
    \    if (diff > 0) {\n        return lower + 1;\n    }\n    return upper - 1;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnwrkg4rj: /tmp/tmpnwrkg4rj.cpp:28: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int l=atoll(value.c_str());\n\
    \    long long int m=l-1;\n    long long int n=l+1;\n    long long int d=l*l+m*m+n*n;\n\
    \    long long int e=l*m*n;\n    long long int f=l*n;\n    long long int g=m*n;\n\
    \    long long int h=l*m*n;\n    long long int i=m*l*n;\n    long long int j=m*m*n;\n\
    \    long long int k=l*m*l*n;\n    long long int l1=l*l+m*m+n*n;\n    long long\
    \ int l2=l*l+m*m+n*n;\n    long long int l3=l*l+m*m+n*n;\n    long long int l4=l*l+m*m+n*n;\n\
    \    long long int l5=l*l+m*m+n*n;\n    long long int l6=l*l+m*m+n*n;\n    long\
    \ long int l7=l*l+m*m+n*n;\n    long long int l8=l*l+m*m+n*n;\n    long long int\
    \ l9=l*l+m*m+n*n;\n    long long int l10=l*l+m*m+n*n;\n    long long int l11=l*l+m*m+n*n;\n\
    \    long long int l12=l*l+m*m+n*n;\n    long long int l13=l*l+m*m+n*n;\n    long\
    \ long int l14=l*l+m*m+n*n;\n    long long int l15=l*l+m*m+n*n;\n    long long\
    \ int l16=l*l+m*m+n*n;\n    long long int l17=l*l+m*m+n*n;\n    long long int\
    \ l18=l*l+m*m+n*n;\n    long long int l19=l*l+m*m+n*n;\n    long long int l20=l*l+m*m+n*n;\n\
    \    long long int l21=l*l+m*m+n*n;\n    long long int l22=l*l+m*\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0sthwuo2.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp0sthwuo2.cpp:50:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   50 | }\n      | ^\n/tmp/tmp0sthwuo2.cpp:50:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp49t1rysj: /tmp/tmp49t1rysj.cpp:106: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141462
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3\
    \ = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long\
    \ temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n\
    \    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14\
    \ = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n   \
    \ long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21\
    \ = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n   \
    \ long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28\
    \ = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n   \
    \ long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35\
    \ = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n   \
    \ long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42\
    \ = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n   \
    \ long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49\
    \ = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n   \
    \ long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56\
    \ = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n   \
    \ long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63\
    \ = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n   \
    \ long temp67 = 0;\n    long temp68 = 0;\n    long temp69 = 0;\n    long temp70\
    \ = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n   \
    \ long temp74 = 0;\n    long temp75 = 0;\n    long temp76 = 0;\n    long temp77\
    \ = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n   \
    \ long temp81 = 0;\n    long temp82 = 0;\n    long temp83 = 0;\n    long temp84\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpquzs6gsb.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpquzs6gsb.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpquzs6gsb.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ diff = upper - lower;\n    while (diff > 0) {\n        diff /= 10;\n       \
    \ lower *= 10;\n        upper *= 10;\n    }\n    while (diff < 0) {\n        diff\
    \ *= 10;\n        lower *= 10;\n        upper *= 10;\n    }\n    if (diff == 0)\
    \ {\n        return lower;\n    }\n    return lower + diff;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpm4lvyaqj: /tmp/tmpm4lvyaqj.cpp:35: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int lower = 0, upper = std::numeric_limits<long\
    \ long int>::max();\n    long long int mid = 0;\n    long long int diff = 0;\n\
    \    long long int diff2 = 0;\n    long long int mid2 = 0;\n    long long int\
    \ mid3 = 0;\n    long long int mid4 = 0;\n    long long int mid5 = 0;\n    long\
    \ long int mid6 = 0;\n    long long int mid7 = 0;\n    long long int mid8 = 0;\n\
    \    long long int mid9 = 0;\n    long long int mid10 = 0;\n    long long int\
    \ mid11 = 0;\n    long long int mid12 = 0;\n    long long int mid13 = 0;\n   \
    \ long long int mid14 = 0;\n    long long int mid15 = 0;\n    long long int mid16\
    \ = 0;\n    long long int mid17 = 0;\n    long long int mid18 = 0;\n    long long\
    \ int mid19 = 0;\n    long long int mid20 = 0;\n    long long int mid21 = 0;\n\
    \    long long int mid22 = 0;\n    long long int mid23 = 0;\n    long long int\
    \ mid24 = 0;\n    long long int mid25 = 0;\n    long long int mid26 = 0;\n   \
    \ long long int mid27 = 0;\n    long long int mid28 = 0;\n    long long int mid29\
    \ = 0;\n    long long int mid30 = 0;\n    long long int mid31 = 0;\n    long long\
    \ int mid32 = 0;\n    long long int mid33 = 0;\n    long long int mid34 = 0;\n\
    \    long long int mid35 = 0;\n    long long int mid36 = 0;\n    long long int\
    \ mid37 = 0;\n    long long int mid38 = 0;\n    long long int mid39 = 0;\n   \
    \ long long int mid40 = 0;\n    long long int mid41 = 0;\n    long long int mid42\
    \ = 0;\n    long long int mid43 = 0;\n    long long int mid44 = 0;\n    long long\
    \ int mid45 = 0;\n    long long int mid46 = 0;\n    long long int mid47 = 0;\n\
    \    long long int mid48 = 0;\n    long long int mid49 = 0;\n    long long int\
    \ mid50 = 0;\n    long long int mid51 = 0;\n    long long int mid52 = 0;\n   \
    \ long long int mid53 = 0;\n    long long int mid54 = 0;\n    long long int mid55\
    \ = 0;\n    long long int mid56 = 0;\n    long long int mid57 = 0;\n    long long\
    \ int mid58 = 0;\n    long long int mid59 = 0;\n    long long int mid60 = 0;\n\
    \    long long \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr7yxamfs.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpr7yxamfs.cpp:81:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   81 | }\n      | ^\n/tmp/tmpr7yxamfs.cpp:81:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ a = stoi(value);\n    long b = ans;\n    long c = a;\n    long d = b;\n    long\
    \ e = c;\n    long f = d;\n    long g = e;\n    long h = f;\n    long i = g;\n\
    \    long j = h;\n    long k = i;\n    long l = j;\n    long m = k;\n    long\
    \ n = l;\n    long o = m;\n    long p = n;\n    long q = o;\n    long r = p;\n\
    \    long s = q;\n    long t = r;\n    long u = s;\n    long v = t;\n    long\
    \ w = u;\n    long x = v;\n    long y = w;\n    long z = x;\n    long a = y;\n\
    \    long b = z;\n    long c = a;\n    long d = b;\n    long e = c;\n    long\
    \ f = d;\n    long g = e;\n    long h = f;\n    long i = g;\n    long j = h;\n\
    \    long k = i;\n    long l = j;\n    long m = k;\n    long n = l;\n    long\
    \ o = m;\n    long p = n;\n    long q = o;\n    long r = p;\n    long s = q;\n\
    \    long t = r;\n    long u = s;\n    long v = t;\n    long w = u;\n    long\
    \ x = v;\n    long y = w;\n    long z = x;\n    long a = y;\n    long b = z;\n\
    \    long c = a;\n    long d = b;\n    long e = c;\n    long f = d;\n    long\
    \ g = e;\n    long h = f;\n    long i = g;\n    long j = h;\n    long k = i;\n\
    \    long l = j;\n    long m = k;\n    long n = l;\n    long o = m;\n    long\
    \ p = n;\n    long q = o;\n    long r = p;\n    long s = q;\n    long t = r;\n\
    \    long u = s;\n    long v = t;\n    long w = u;\n    long x = v;\n    long\
    \ y = w;\n    long z = x;\n    long a = y;\n    long b = z;\n    long c = a;\n\
    \    long d = b;\n    long e = c;\n    long f = d;\n    long g = e;\n    long\
    \ h = f;\n    long i = g;\n    long j = h;\n    long k = i;\n    long l = j;\n\
    \    long m = k;\n    long n = l;\n    long o = m;\n    long p = n;\n    long\
    \ q = o;\n    long r = p;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1_9arai8.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp1_9arai8.cpp:44:10: error: redeclaration of \u2018long int a\u2019\n\
    \   44 |     long a = y;\n      |          ^\n/tmp/tmp1_9arai8.cpp:18:10: note:\
    \ \u2018long int a\u2019 previously declared here\n   18 |     long a = stoi(value);\n\
    \      |          ^\n/tmp/tmp1_9arai8.cpp:45:10: error: redeclaration of \u2018\
    long int b\u2019\n   45 |     long b = z;\n      |          ^\n/tmp/tmp1_9arai8.cpp:19:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   19 |     long b =\
    \ ans;\n      |          ^\n/tmp/tmp1_9arai8.cpp:46:10: error: redeclaration of\
    \ \u2018long int c\u2019\n   46 |     long c = a;\n      |          ^\n/tmp/tmp1_9arai8.cpp:20:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   20 |     long c =\
    \ a;\n      |          ^\n/tmp/tmp1_9arai8.cpp:47:10: error: redeclaration of\
    \ \u2018long int d\u2019\n   47 |     long d = b;\n      |          ^\n/tmp/tmp1_9arai8.cpp:21:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   21 |     long d =\
    \ b;\n      |          ^\n/tmp/tmp1_9arai8.cpp:48:10: error: redeclaration of\
    \ \u2018long int e\u2019\n   48 |     long e = c;\n      |          ^\n/tmp/tmp1_9arai8.cpp:22:10:\
    \ note: \u2018long int e\u2019 previously declared here\n   22 |     long e =\
    \ c;\n      |          ^\n/tmp/tmp1_9arai8.cpp:49:10: error: redeclaration of\
    \ \u2018long int f\u2019\n   49 |     long f = d;\n      |          ^\n/tmp/tmp1_9arai8.cpp:23:10:\
    \ note: \u2018long int f\u2019 previously declared here\n   23 |     long f =\
    \ d;\n      |          ^\n/tmp/tmp1_9arai8.cpp:50:10: error: redeclaration of\
    \ \u2018long int g\u2019\n   50 |     long g = e;\n      |          ^\n/tmp/tmp1_9arai8.cpp:24:10:\
    \ note: \u2018long int g\u2019 previously declared here\n   24 |     long g =\
    \ e;\n      |          ^\n/tmp/tmp1_9arai8.cpp:51:10: error: redeclaration of\
    \ \u2018long int h\u2019\n   51 |     long h = f;\n      |          ^\n/tmp/tmp1_9arai8.cpp:25:10:\
    \ note: \u2018long int h\u2019 previously declared here\n   25 |     long h =\
    \ f;\n      |          ^\n/tmp/tmp1_9arai8.cpp:52:10: error: redeclaration of\
    \ \u2018long int i\u2019\n   52 |     long i = g;\n      |         "
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ num;\n    long pow = 1;\n    long pow2 = 1;\n    long pow3 = 1;\n    long pow4\
    \ = 0;\n    long pow5 = 0;\n    long pow6 = 0;\n    long pow7 = 0;\n    long pow8\
    \ = 0;\n    long pow9 = 0;\n    long pow10 = 0;\n    long pow11 = 0;\n    long\
    \ pow12 = 0;\n    long pow13 = 0;\n    long pow14 = 0;\n    long pow15 = 0;\n\
    \    long pow16 = 0;\n    long pow17 = 0;\n    long pow18 = 0;\n    long pow19\
    \ = 0;\n    long pow20 = 0;\n    long pow21 = 0;\n    long pow22 = 0;\n    long\
    \ pow23 = 0;\n    long pow24 = 0;\n    long pow25 = 0;\n    long pow26 = 0;\n\
    \    long pow27 = 0;\n    long pow28 = 0;\n    long pow29 = 0;\n    long pow30\
    \ = 0;\n    long pow31 = 0;\n    long pow32 = 0;\n    long pow33 = 0;\n    long\
    \ pow34 = 0;\n    long pow35 = 0;\n    long pow36 = 0;\n    long pow37 = 0;\n\
    \    long pow38 = 0;\n    long pow39 = 0;\n    long pow40 = 0;\n    long pow41\
    \ = 0;\n    long pow42 = 0;\n    long pow43 = 0;\n    long pow44 = 0;\n    long\
    \ pow45 = 0;\n    long pow46 = 0;\n    long pow47 = 0;\n    long pow48 = 0;\n\
    \    long pow49 = 0;\n    long pow50 = 0;\n    long pow51 = 0;\n    long pow52\
    \ = 0;\n    long pow53 = 0;\n    long pow54 = 0;\n    long pow55 = 0;\n    long\
    \ pow56 = 0;\n    long pow57 = 0;\n    long pow58 = 0;\n    long pow59 = 0;\n\
    \    long pow60 = 0;\n    long pow61 = 0;\n    long pow62 = 0;\n    long pow63\
    \ = 0;\n    long pow64 = 0;\n    long pow65 = 0;\n    long pow66 = 0;\n    long\
    \ pow67 = 0;\n    long pow68 = 0;\n    long pow69 = 0;\n    long pow70 = 0;\n\
    \    long pow71 = 0;\n    long pow72 = 0;\n    long pow73 = 0;\n    long pow74\
    \ = 0;\n    long pow75 = 0;\n    long pow76 = 0;\n    long pow77 = 0;\n    long\
    \ pow78 = 0;\n    long pow79 = 0;\n    long pow80 = 0;\n    long pow81 = 0;\n\
    \    long pow82 = 0;\n    long pow83 = 0;\n    long pow84 = 0;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpbjexsd0t: /tmp/tmpbjexsd0t.cpp:106: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int int_value = std::stoll(value);\n\
    \    long long int int_min = (int_value - int_value % 10);\n    long long int\
    \ int_max = (int_value + int_value % 10);\n    long long int int_closest = (int_min\
    \ + int_max) / 2;\n    return int_closest;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpn7ztns19: /tmp/tmpn7ztns19.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int temp;\n    temp = std::stoll(value);\n\
    \    if (temp == 0) return 0;\n    long long int temp2 = temp;\n    long long\
    \ int temp3 = temp;\n    long long int temp4 = temp;\n    long long int temp5\
    \ = temp;\n    long long int temp6 = temp;\n    long long int temp7 = temp;\n\
    \    long long int temp8 = temp;\n    long long int temp9 = temp;\n    long long\
    \ int temp10 = temp;\n    long long int temp11 = temp;\n    long long int temp12\
    \ = temp;\n    long long int temp13 = temp;\n    long long int temp14 = temp;\n\
    \    long long int temp15 = temp;\n    long long int temp16 = temp;\n    long\
    \ long int temp17 = temp;\n    long long int temp18 = temp;\n    long long int\
    \ temp19 = temp;\n    long long int temp20 = temp;\n    long long int temp21 =\
    \ temp;\n    long long int temp22 = temp;\n    long long int temp23 = temp;\n\
    \    long long int temp24 = temp;\n    long long int temp25 = temp;\n    long\
    \ long int temp26 = temp;\n    long long int temp27 = temp;\n    long long int\
    \ temp28 = temp;\n    long long int temp29 = temp;\n    long long int temp30 =\
    \ temp;\n    long long int temp31 = temp;\n    long long int temp32 = temp;\n\
    \    long long int temp33 = temp;\n    long long int temp34 = temp;\n    long\
    \ long int temp35 = temp;\n    long long int temp36 = temp;\n    long long int\
    \ temp37 = temp;\n    long long int temp38 = temp;\n    long long int temp39 =\
    \ temp;\n    long long int temp40 = temp;\n    long long int temp41 = temp;\n\
    \    long long int temp42 = temp;\n    long long int temp43 = temp;\n    long\
    \ long int temp44 = temp;\n    long long int temp45 = temp;\n    long long int\
    \ temp46 = temp;\n    long long int temp47 = temp;\n    long long int temp48 =\
    \ temp;\n    long long int temp49 = temp;\n    long long int temp50 = temp;\n\
    \    long long int temp51 = temp;\n    \n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpg_dc0irz: /tmp/tmpg_dc0irz.cpp:75: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ mid;\n    while (lower < upper) {\n        mid = (lower + upper) / 2;\n    \
    \    if (mid * mid > upper * lower) {\n            upper = mid;\n        } else\
    \ {\n            lower = mid;\n        }\n    }\n    return lower;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141468
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (lower == upper) {\n        return lower;\n    }\n    long mid = (lower\
    \ + upper) / 2;\n    if (mid % 2 == 0) {\n        return mid;\n    }\n    if (mid\
    \ % 3 == 0) {\n        return mid - 1;\n    }\n    if (mid % 5 == 0) {\n     \
    \   return mid - 3;\n    }\n    return mid;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfp72r_wo: /tmp/tmpfp72r_wo.cpp:35: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    while (lower < upper) {\n        long mid = (lower + upper) / 2;\n\
    \        long midValue = std::stoll(value);\n        if (midValue < mid) {\n \
    \           lower = mid + 1;\n        } else if (midValue > mid) {\n         \
    \   upper = mid - 1;\n        } else {\n            return mid;\n        }\n \
    \   }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpzep8vhgb: /tmp/tmpzep8vhgb.cpp:33: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int farthest;\n    long long int diff;\n    long long int temp;\n    long long\
    \ int temp2;\n    long long int temp3;\n    long long int temp4;\n    long long\
    \ int temp5;\n    long long int temp6;\n    long long int temp7;\n    long long\
    \ int temp8;\n    long long int temp9;\n    long long int temp10;\n    long long\
    \ int temp11;\n    long long int temp12;\n    long long int temp13;\n    long\
    \ long int temp14;\n    long long int temp15;\n    long long int temp16;\n   \
    \ long long int temp17;\n    long long int temp18;\n    long long int temp19;\n\
    \    long long int temp20;\n    long long int temp21;\n    long long int temp22;\n\
    \    long long int temp23;\n    long long int temp24;\n    long long int temp25;\n\
    \    long long int temp26;\n    long long int temp27;\n    long long int temp28;\n\
    \    long long int temp29;\n    long long int temp30;\n    long long int temp31;\n\
    \    long long int temp32;\n    long long int temp33;\n    long long int temp34;\n\
    \    long long int temp35;\n    long long int temp36;\n    long long int temp37;\n\
    \    long long int temp38;\n    long long int temp39;\n    long long int temp40;\n\
    \    long long int temp41;\n    long long int temp42;\n    long long int temp43;\n\
    \    long long int temp44;\n    long long int temp45;\n    long long int temp46;\n\
    \    long long int temp47;\n    long long int temp48;\n    long long int temp49;\n\
    \    long long int temp50;\n    long long int temp51;\n    long long int temp52;\n\
    \    long long int temp53;\n    long long int temp54;\n    long long int temp55;\n\
    \    long long int temp56;\n    long long int temp57;\n    long long int temp58;\n\
    \    long long int temp59;\n    long long int temp60;\n    long long int temp61;\n\
    \    long long int temp62;\n    long long int temp63;\n    long long int temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5x631uzr.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp5x631uzr.cpp:84:1: error: expected initializer before \u2018}\u2019\
    \ token\n   84 | }\n      | ^\n/tmp/tmp5x631uzr.cpp:84:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    long\
    \ temp = 0;\n    long diff = 0;\n    long power = 1;\n    long i = 0;\n    long\
    \ len = value.length();\n    long count = 0;\n    long sum = 0;\n    long tempsum\
    \ = 0;\n    long tempcount = 0;\n    long tempsum2 = 0;\n    long temppower =\
    \ 0;\n    long temppower2 = 0;\n    long tempdiff = 0;\n    long tempdiff2 = 0;\n\
    \    long temppower3 = 0;\n    long temppower4 = 0;\n    long temppower5 = 0;\n\
    \    long temppower6 = 0;\n    long temppower7 = 0;\n    long temppower8 = 0;\n\
    \    long temppower9 = 0;\n    long temppower10 = 0;\n    long temppower11 = 0;\n\
    \    long temppower12 = 0;\n    long temppower13 = 0;\n    long temppower14 =\
    \ 0;\n    long temppower15 = 0;\n    long temppower16 = 0;\n    long temppower17\
    \ = 0;\n    long temppower18 = 0;\n    long temppower19 = 0;\n    long temppower20\
    \ = 0;\n    long temppower21 = 0;\n    long temppower22 = 0;\n    long temppower23\
    \ = 0;\n    long temppower24 = 0;\n    long temppower25 = 0;\n    long temppower26\
    \ = 0;\n    long temppower27 = 0;\n    long temppower28 = 0;\n    long temppower29\
    \ = 0;\n    long temppower30 = 0;\n    long temppower31 = 0;\n    long temppower32\
    \ = 0;\n    long temppower33 = 0;\n    long temppower34 = 0;\n    long temppower35\
    \ = 0;\n    long temppower36 = 0;\n    long temppower37 = 0;\n    long temppower38\
    \ = 0;\n    long temppower39 = 0;\n    long temppower40 = 0;\n    long temppower41\
    \ = 0;\n    long temppower42 = 0;\n    long temppower43 = 0;\n    long temppower44\
    \ = 0;\n    long temppower45 = 0;\n    long temppower46 = 0;\n    long temppower47\
    \ = 0;\n    long temppower48 = 0;\n    long temppower49 = 0;\n    long temppower50\
    \ = 0;\n    long temppower51 = 0;\n    long temppower52 = 0;\n    long temppower53\
    \ = 0;\n    long temppower54 = 0;\n    long temppower55 = 0;\n    long temppower56\
    \ = 0;\n    long temppower57 = 0;\n    long temppower58 = 0;\n    long temppower59\
    \ = 0;\n    long temppower60 = 0;\n    long temppower61 = 0;\n    long temppower62\
    \ = 0;\n    long temppower63 = 0;\n    long temp\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjqgmyly3.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjqgmyly3.cpp:94:1: error: expected initializer before \u2018}\u2019\
    \ token\n   94 | }\n      | ^\n/tmp/tmpjqgmyly3.cpp:94:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long val = std::stoll(value);\n    long diff = val - ans;\n\
    \    long mod = diff % 10;\n    diff = diff - mod;\n    ans = val + diff;\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpegfrvepf.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpegfrvepf.cpp:20:10: error: redeclaration of \u2018long int diff\u2019\
    \n   20 |     long diff = val - ans;\n      |          ^~~~\n/tmp/tmpegfrvepf.cpp:18:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ mid;\n    while (upper - lower > 1) {\n        mid = (lower + upper) / 2;\n\
    \        if (std::stoll(value) == mid) {\n            return mid;\n        } else\
    \ if (std::stoll(value) < mid) {\n            upper = mid;\n        } else {\n\
    \            lower = mid;\n        }\n    }\n    return lower;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpx0kc1d2_: /tmp/tmpx0kc1d2_.cpp:32: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    long\
    \ temp = stoi(value);\n    if (temp < 0) {\n        temp = -temp;\n        sign\
    \ = -1;\n    }\n    long diff = abs(temp - ans);\n    while (diff > 1) {\n   \
    \     diff /= 10;\n        ans++;\n    }\n    return sign * ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_6anw5tv: /tmp/tmp_6anw5tv.cpp:32: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141463
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1, digit;\n    long temp = 0, temp2 = 0, temp3 = 0, temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1clfvf8l.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp1clfvf8l.cpp:101:1: error: expected initializer before \u2018}\u2019\
    \ token\n  101 | }\n      | ^\n/tmp/tmp1clfvf8l.cpp:101:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ mid;\n    while (upper - lower > 1) {\n        mid = (upper + lower) / 2;\n\
    \        if (mid * mid <= upper) {\n            upper = mid;\n        } else {\n\
    \            lower = mid;\n        }\n    }\n    return lower;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpbfjdq5v6: /tmp/tmpbfjdq5v6.cpp:30: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long long int\
    \ ans = 0;\n    long long int temp = 0;\n    long long int temp2 = 0;\n    long\
    \ long int temp3 = 0;\n    long long int temp4 = 0;\n    long long int temp5 =\
    \ 0;\n    long long int temp6 = 0;\n    long long int temp7 = 0;\n    long long\
    \ int temp8 = 0;\n    long long int temp9 = 0;\n    long long int temp10 = 0;\n\
    \    long long int temp11 = 0;\n    long long int temp12 = 0;\n    long long int\
    \ temp13 = 0;\n    long long int temp14 = 0;\n    long long int temp15 = 0;\n\
    \    long long int temp16 = 0;\n    long long int temp17 = 0;\n    long long int\
    \ temp18 = 0;\n    long long int temp19 = 0;\n    long long int temp20 = 0;\n\
    \    long long int temp21 = 0;\n    long long int temp22 = 0;\n    long long int\
    \ temp23 = 0;\n    long long int temp24 = 0;\n    long long int temp25 = 0;\n\
    \    long long int temp26 = 0;\n    long long int temp27 = 0;\n    long long int\
    \ temp28 = 0;\n    long long int temp29 = 0;\n    long long int temp30 = 0;\n\
    \    long long int temp31 = 0;\n    long long int temp32 = 0;\n    long long int\
    \ temp33 = 0;\n    long long int temp34 = 0;\n    long long int temp35 = 0;\n\
    \    long long int temp36 = 0;\n    long long int temp37 = 0;\n    long long int\
    \ temp38 = 0;\n    long long int temp39 = 0;\n    long long int temp40 = 0;\n\
    \    long long int temp41 = 0;\n    long long int temp42 = 0;\n    long long int\
    \ temp43 = 0;\n    long long int temp44 = 0;\n    long long int temp45 = 0;\n\
    \    long long int temp46 = 0;\n    long long int temp47 = 0;\n    long long int\
    \ temp48 = 0;\n    long long int temp49 = 0;\n    long long int temp50 = 0;\n\
    \    long long int temp51 = 0;\n    long long int temp52 = 0;\n    long long int\
    \ temp53 = 0;\n    long long int temp54 = 0;\n    long long int temp55 = 0;\n\
    \    long long int temp56 = 0;\n    long long int temp57 = 0;\n    long long int\
    \ temp58 = 0;\n    long long int temp59 = 0;\n    long long int temp60 = 0;\n\
    \    long long int temp61 = 0;\n    long long int temp62 = 0;\n    long long int\
    \ temp63 = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpvqymfcvn: /tmp/tmpvqymfcvn.cpp:86: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ mid;\n    while (lower < upper) {\n        mid = (lower + upper) / 2;\n    \
    \    if (mid * mid > upper) {\n            upper = mid;\n        } else {\n  \
    \          lower = mid;\n        }\n    }\n    return lower;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpq42mb8yr: /tmp/tmpq42mb8yr.cpp:30: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff += 1;\n    }\n    if (diff == 0) {\n        return temp;\n\
    \    }\n    if (diff > 0) {\n        return ans;\n    }\n    while (diff > 0)\
    \ {\n        diff /= 10;\n        ans += 1;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmppvbdyq97: /tmp/tmppvbdyq97.cpp:38: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    if (value.front()\
    \ == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    std::string::size_type\
    \ pos = 0;\n    std::string::size_type len = value.length();\n    while (pos <\
    \ len) {\n        long num = 0;\n        std::string::size_type i = pos;\n   \
    \     while (i < len && value[i] >= '0' && value[i] <= '9') {\n            num\
    \ = num * 10 + (value[i] - '0');\n            ++i;\n        }\n        if (num\
    \ == 0) {\n            throw std::invalid_argument(\"Invalid input\");\n     \
    \   }\n        if (num > ans) {\n            ans = num;\n        }\n        pos\
    \ = i;\n    }\n    return sign * ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  Invalid input\n"
  stdout: ''
  timestamp: 1660141464
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest = 0;\n    long\
    \ long int closestDiff = std::numeric_limits<long long>::max();\n    long long\
    \ int diff = 0;\n    long long int diff2 = std::numeric_limits<long long>::max();\n\
    \    long long int diff3 = std::numeric_limits<long long>::max();\n    long long\
    \ int diff4 = std::numeric_limits<long long>::max();\n    long long int diff5\
    \ = std::numeric_limits<long long>::max();\n    long long int diff6 = std::numeric_limits<long\
    \ long>::max();\n    long long int diff7 = std::numeric_limits<long long>::max();\n\
    \    long long int diff8 = std::numeric_limits<long long>::max();\n    long long\
    \ int diff9 = std::numeric_limits<long long>::max();\n    long long int diff10\
    \ = std::numeric_limits<long long>::max();\n    long long int diff11 = std::numeric_limits<long\
    \ long>::max();\n    long long int diff12 = std::numeric_limits<long long>::max();\n\
    \    long long int diff13 = std::numeric_limits<long long>::max();\n    long long\
    \ int diff14 = std::numeric_limits<long long>::max();\n    long long int diff15\
    \ = std::numeric_limits<long long>::max();\n    long long int diff16 = std::numeric_limits<long\
    \ long>::max();\n    long long int diff17 = std::numeric_limits<long long>::max();\n\
    \    long long int diff18 = std::numeric_limits<long long>::max();\n    long long\
    \ int diff19 = std::numeric_limits<long long>::max();\n    long long int diff20\
    \ = std::numeric_limits<long long>::max();\n    long long int diff21 = std::numeric_limits<long\
    \ long>::max();\n    long long int diff22 = std::numeric_limits<long long>::max();\n\
    \    long long int diff23 = std::numeric_limits<long long>::max();\n    long long\
    \ int diff24 = std::numeric_limits<long long>::max();\n    long long int diff25\
    \ = std::numeric_limits<long long>::max();\n    long long int diff26 = std::numeric_limits<long\
    \ long>::max();\n    long long int diff27 = std::numeric_limits<long long>::max();\n\
    \    long long int diff28 = std::numeric_limits<long long>::max();\n    long long\
    \ int diff29 = std::numeric_limits<long long>::max();\n    long long int diff30\
    \ = std::numeric_limits<long long>::max();\n    long long int diff31 = std::numeric_limits<long\
    \ long>::max();\n    long long int diff32 = std::numeric_limits<long long>::\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe6_add5q.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpe6_add5q.cpp:51:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   51 | }\n      | ^\n/tmp/tmpe6_add5q.cpp:51:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnro_jpvo: /tmp/tmpnro_jpvo.cpp:88: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long x = stoi(value);\n\
    \    long y = stoi(value);\n    long d = abs(x - y);\n    if (d > ans) {\n   \
    \     ans = d;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_bw9wdji: /tmp/tmp_bw9wdji.cpp:28: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = 0;\n    long long\
    \ int num2 = 0;\n    long long int num3 = 0;\n    long long int num4 = 0;\n  \
    \  long long int num5 = 0;\n    long long int num6 = 0;\n    long long int num7\
    \ = 0;\n    long long int num8 = 0;\n    long long int num9 = 0;\n    long long\
    \ int num10 = 0;\n    long long int num11 = 0;\n    long long int num12 = 0;\n\
    \    long long int num13 = 0;\n    long long int num14 = 0;\n    long long int\
    \ num15 = 0;\n    long long int num16 = 0;\n    long long int num17 = 0;\n   \
    \ long long int num18 = 0;\n    long long int num19 = 0;\n    long long int num20\
    \ = 0;\n    long long int num21 = 0;\n    long long int num22 = 0;\n    long long\
    \ int num23 = 0;\n    long long int num24 = 0;\n    long long int num25 = 0;\n\
    \    long long int num26 = 0;\n    long long int num27 = 0;\n    long long int\
    \ num28 = 0;\n    long long int num29 = 0;\n    long long int num30 = 0;\n   \
    \ long long int num31 = 0;\n    long long int num32 = 0;\n    long long int num33\
    \ = 0;\n    long long int num34 = 0;\n    long long int num35 = 0;\n    long long\
    \ int num36 = 0;\n    long long int num37 = 0;\n    long long int num38 = 0;\n\
    \    long long int num39 = 0;\n    long long int num40 = 0;\n    long long int\
    \ num41 = 0;\n    long long int num42 = 0;\n    long long int num43 = 0;\n   \
    \ long long int num44 = 0;\n    long long int num45 = 0;\n    long long int num46\
    \ = 0;\n    long long int num47 = 0;\n    long long int num48 = 0;\n    long long\
    \ int num49 = 0;\n    long long int num50 = 0;\n    long long int num51 = 0;\n\
    \    long long int num52 = 0;\n    long long int num53 = 0;\n    long long int\
    \ num54 = 0;\n    long long int num55 = 0;\n    long long int num56 = 0;\n   \
    \ long long int num57 = 0;\n    long long int num58 = 0;\n    long long int num59\
    \ = 0;\n    long long int num60 = 0;\n    long long int num61 = 0;\n    long long\
    \ int num62 = 0;\n    long long int num63 = 0;\n    long long int num64 = 0;\n\
    \    long long int num\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphlwr1i43.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmphlwr1i43.cpp:82:1: error: expected initializer before \u2018}\u2019\
    \ token\n   82 | }\n      | ^\n/tmp/tmphlwr1i43.cpp:82:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    std::stringstream\
    \ ss(value);\n    ss >> num;\n    long long int closest;\n    if (num == 0)\n\
    \        closest = 0;\n    else\n        closest = (num > 0) ? ceil(num) : floor(num);\n\
    \    return closest;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmkuxkzcf: /tmp/tmpmkuxkzcf.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk21oha4c.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpk21oha4c.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmpk21oha4c.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141464
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long n = stoi(value);\n    long m = stoi(value);\n    long\
    \ x = n;\n    long y = m;\n    long z = n;\n    long t = m;\n    long u = n;\n\
    \    long v = m;\n    long w = n;\n    long x = n;\n    long y = m;\n    long\
    \ z = n;\n    long t = m;\n    long u = n;\n    long v = m;\n    long w = n;\n\
    \    long x = n;\n    long y = m;\n    long z = n;\n    long t = m;\n    long\
    \ u = n;\n    long v = m;\n    long w = n;\n    long x = n;\n    long y = m;\n\
    \    long z = n;\n    long t = m;\n    long u = n;\n    long v = m;\n    long\
    \ w = n;\n    long x = n;\n    long y = m;\n    long z = n;\n    long t = m;\n\
    \    long u = n;\n    long v = m;\n    long w = n;\n    long x = n;\n    long\
    \ y = m;\n    long z = n;\n    long t = m;\n    long u = n;\n    long v = m;\n\
    \    long w = n;\n    long x = n;\n    long y = m;\n    long z = n;\n    long\
    \ t = m;\n    long u = n;\n    long v = m;\n    long w = n;\n    long x = n;\n\
    \    long y = m;\n    long z = n;\n    long t = m;\n    long u = n;\n    long\
    \ v = m;\n    long w = n;\n    long x = n;\n    long y = m;\n    long z = n;\n\
    \    long t = m;\n    long u = n;\n    long v = m;\n    long w = n;\n    long\
    \ x = n;\n    long y = m;\n    long z = n;\n    long t = m;\n    long u = n;\n\
    \    long v = m;\n    long w = n;\n    long x = n;\n    long y = m;\n    long\
    \ z = n;\n    long t = m;\n    long u = n;\n    long v = m;\n    long w = n;\n\
    \    long x = n;\n    long y = m;\n    long z = n;\n    long t = m;\n    long\
    \ u = n;\n    long v = m;\n    long w = n;\n    long x = n;\n    long y = m;\n\
    \    long z = n;\n    long t = m;\n    long u = n;\n    long v = m;\n    long\
    \ w = n;\n    long x = n;\n    long y = m;\n    long z = n;\n    long t = m;\n\
    \    long u = n;\n    long v = m;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphysg3v2m.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmphysg3v2m.cpp:28:10: error: redeclaration of \u2018long int x\u2019\n\
    \   28 |     long x = n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:21:10: note:\
    \ \u2018long int x\u2019 previously declared here\n   21 |     long x = n;\n \
    \     |          ^\n/tmp/tmphysg3v2m.cpp:29:10: error: redeclaration of \u2018\
    long int y\u2019\n   29 |     long y = m;\n      |          ^\n/tmp/tmphysg3v2m.cpp:22:10:\
    \ note: \u2018long int y\u2019 previously declared here\n   22 |     long y =\
    \ m;\n      |          ^\n/tmp/tmphysg3v2m.cpp:30:10: error: redeclaration of\
    \ \u2018long int z\u2019\n   30 |     long z = n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:23:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   23 |     long z =\
    \ n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:31:10: error: redeclaration of\
    \ \u2018long int t\u2019\n   31 |     long t = m;\n      |          ^\n/tmp/tmphysg3v2m.cpp:24:10:\
    \ note: \u2018long int t\u2019 previously declared here\n   24 |     long t =\
    \ m;\n      |          ^\n/tmp/tmphysg3v2m.cpp:32:10: error: redeclaration of\
    \ \u2018long int u\u2019\n   32 |     long u = n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:25:10:\
    \ note: \u2018long int u\u2019 previously declared here\n   25 |     long u =\
    \ n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:33:10: error: redeclaration of\
    \ \u2018long int v\u2019\n   33 |     long v = m;\n      |          ^\n/tmp/tmphysg3v2m.cpp:26:10:\
    \ note: \u2018long int v\u2019 previously declared here\n   26 |     long v =\
    \ m;\n      |          ^\n/tmp/tmphysg3v2m.cpp:34:10: error: redeclaration of\
    \ \u2018long int w\u2019\n   34 |     long w = n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:27:10:\
    \ note: \u2018long int w\u2019 previously declared here\n   27 |     long w =\
    \ n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:35:10: error: redeclaration of\
    \ \u2018long int x\u2019\n   35 |     long x = n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:21:10:\
    \ note: \u2018long int x\u2019 previously declared here\n   21 |     long x =\
    \ n;\n      |          ^\n/tmp/tmphysg3v2m.cpp:36:10: error: redeclaration of\
    \ \u2018long int y\u2019\n   36 |     long y = m;\n      |          ^\n/tmp/tmph"
  stdout: ''
  timestamp: 1660141463
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long cur = 0;\n    long prev = 0;\n    long i = 0;\n    long j = 0;\n   \
    \ long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o =\
    \ 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n   \
    \ long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x =\
    \ 0;\n    long y = 0;\n    long z = 0;\n    long aa = 0;\n    long bb = 0;\n \
    \   long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long\
    \ gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n    long kk =\
    \ 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n\
    \    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long\
    \ tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long xx =\
    \ 0;\n    long yy = 0;\n    long zz = 0;\n    long aaa = 0;\n    long bbb = 0;\n\
    \    long ccc = 0;\n    long ddd = 0;\n    long eee = 0;\n    long fff = 0;\n\
    \    long ggg = 0;\n    long hhh = 0;\n    long iii = 0;\n    long jjj = 0;\n\
    \    long kkk = 0;\n    long lll = 0;\n    long mmm = 0;\n    long nnn = 0;\n\
    \    long ooo = 0;\n    long ppp = 0;\n    long qqq = 0;\n    long rrr = 0;\n\
    \    long sss = 0;\n    long ttt = 0;\n    long uuu = 0;\n    long vvv = 0;\n\
    \    long www = 0;\n    long xxx = 0;\n    long yyy = 0;\n    long zzz = 0;\n\
    \    long aaaa = 0;\n    long bbbb = 0;\n    long cccc = 0;\n    long dddd = 0;\n\
    \    long eeee = 0;\n    long ffff = 0;\n    long gggg = 0;\n    long hhhh = 0;\n\
    \    long iiii = 0;\n    long jjjj = 0;\n    long kkkk = 0;\n    long llll = 0;\n\
    \    long mmmm = 0;\n    long nnnn = 0;\n    long oooo = 0;\n    long pppp = 0;\n\
    \    long qqqq = 0;\n    long rrrr = 0;\n    long ssss = 0;\n    long tttt = 0;\n\
    \    long uuuu = 0;\n    long vvvv = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpiobjp8go: /tmp/tmpiobjp8go.cpp:117: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141464
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (upper - lower == 1) {\n        return lower;\n    }\n    long mid = (upper\
    \ + lower) / 2;\n    if (mid - lower == 1) {\n        return mid;\n    }\n   \
    \ if (mid - upper == 1) {\n        return mid;\n    }\n    if (upper - mid ==\
    \ 1) {\n        return upper;\n    }\n    if (mid - lower == 1) {\n        return\
    \ mid;\n    }\n    if (mid - upper == 1) {\n        return mid;\n    }\n    if\
    \ (upper - mid == 1) {\n        return upper;\n    }\n    if (mid - lower == 1)\
    \ {\n        return mid;\n    }\n    if (mid - upper == 1) {\n        return mid;\n\
    \    }\n    if (upper - mid == 1) {\n        return upper;\n    }\n    if (mid\
    \ - lower == 1) {\n        return mid;\n    }\n    if (mid - upper == 1) {\n \
    \       return mid;\n    }\n    if (upper - mid == 1) {\n        return upper;\n\
    \    }\n    if (mid - lower == 1) {\n        return mid;\n    }\n    if (mid -\
    \ upper == 1) {\n        return mid;\n    }\n    if (upper - mid == 1) {\n   \
    \     return upper;\n    }\n    if (mid - lower == 1) {\n        return mid;\n\
    \    }\n    if (mid - upper == 1) {\n        return mid;\n    }\n    if (upper\
    \ - mid == 1) {\n        return upper;\n    }\n    if (mid - lower == 1) {\n \
    \       return mid;\n    }\n    if (mid - upper == 1) {\n        return mid;\n\
    \    }\n    if (upper - mid == 1) {\n        return upper;\n    }\n    if (mid\
    \ - lower == 1) {\n        return mid;\n    }\n    if (mid - upper == 1) {\n \
    \       return mid;\n    }\n    if (upper - mid == 1) {\n        return upper;\n\
    \    }\n    if (mid - lower == 1) {\n        return mid;\n    }\n    if (mid -\
    \ upper == 1) {\n        return mid;\n    }\n    if (upper - mid == 1) {\n   \
    \     return upper;\n    }\n    if (mid - lower == 1) {\n        return mid;\n\
    \    }\n    if (mid - upper == 1) {\n        return mid;\n    }\n    if (upper\
    \ - mid == 1) {\n        return upper;\n    }\n    if (mid - lower == 1) {\n \
    \       return mid;\n    }\n    if (mid - upper == 1) {\n        return mid;\n\
    \    }\n    if (upper - mid == 1) {\n        return upper;\n    }\n    if (mid\
    \ - lower == 1) {\n        return mid;\n    }\n    if (mid - upper == 1) {\n \
    \       return mid;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph373541m.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmph373541m.cpp:127:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  127 | int main() {\n      |            ^\n/tmp/tmph373541m.cpp:134:1:\
    \ error: expected \u2018}\u2019 at end of input\n  134 | }\n      | ^\n/tmp/tmph373541m.cpp:16:41:\
    \ note: to match this \u2018{\u2019\n   16 | long closest_integer(std::string\
    \ value) {\n      |                                         ^\n/tmp/tmph373541m.cpp:134:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n  134 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660141464
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long long int num;\n    long long int num2;\n    long long\
    \ int num3;\n    long long int num4;\n    long long int num5;\n    long long int\
    \ num6;\n    long long int num7;\n    long long int num8;\n    long long int num9;\n\
    \    long long int num10;\n    long long int num11;\n    long long int num12;\n\
    \    long long int num13;\n    long long int num14;\n    long long int num15;\n\
    \    long long int num16;\n    long long int num17;\n    long long int num18;\n\
    \    long long int num19;\n    long long int num20;\n    long long int num21;\n\
    \    long long int num22;\n    long long int num23;\n    long long int num24;\n\
    \    long long int num25;\n    long long int num26;\n    long long int num27;\n\
    \    long long int num28;\n    long long int num29;\n    long long int num30;\n\
    \    long long int num31;\n    long long int num32;\n    long long int num33;\n\
    \    long long int num34;\n    long long int num35;\n    long long int num36;\n\
    \    long long int num37;\n    long long int num38;\n    long long int num39;\n\
    \    long long int num40;\n    long long int num41;\n    long long int num42;\n\
    \    long long int num43;\n    long long int num44;\n    long long int num45;\n\
    \    long long int num46;\n    long long int num47;\n    long long int num48;\n\
    \    long long int num49;\n    long long int num50;\n    long long int num51;\n\
    \    long long int num52;\n    long long int num53;\n    long long int num54;\n\
    \    long long int num55;\n    long long int num56;\n    long long int num57;\n\
    \    long long int num58;\n    long long int num59;\n    long long int num60;\n\
    \    long long int num61;\n    long long int num62;\n    long long int num63;\n\
    \    long long int num64;\n    long long int num65;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1ll86rq2: /tmp/tmp1ll86rq2.cpp:87: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141465
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long count = 0;\n    long sum = 0;\n    long temp2 =\
    \ 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\
    \ = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmev3z6xv: /tmp/tmpmev3z6xv.cpp:108: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141465
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    long diff = upper - lower;\n    if (diff > 0) {\n        return lower;\n\
    \    }\n    if (diff < 0) {\n        return upper;\n    }\n    if (diff == 0)\
    \ {\n        return lower;\n    }\n    long mid = lower + (diff / 2);\n    if\
    \ (mid > upper) {\n        return mid;\n    }\n    if (mid < lower) {\n      \
    \  return mid;\n    }\n    if (mid == lower) {\n        return upper;\n    }\n\
    \    if (mid == upper) {\n        return lower;\n    }\n    return mid;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpwaqoiop1: /tmp/tmpwaqoiop1.cpp:45: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ num;\n    long temp;\n    long temp2;\n    long temp3;\n    long temp4;\n  \
    \  long temp5;\n    long temp6;\n    long temp7;\n    long temp8;\n    long temp9;\n\
    \    long temp10;\n    long temp11;\n    long temp12;\n    long temp13;\n    long\
    \ temp14;\n    long temp15;\n    long temp16;\n    long temp17;\n    long temp18;\n\
    \    long temp19;\n    long temp20;\n    long temp21;\n    long temp22;\n    long\
    \ temp23;\n    long temp24;\n    long temp25;\n    long temp26;\n    long temp27;\n\
    \    long temp28;\n    long temp29;\n    long temp30;\n    long temp31;\n    long\
    \ temp32;\n    long temp33;\n    long temp34;\n    long temp35;\n    long temp36;\n\
    \    long temp37;\n    long temp38;\n    long temp39;\n    long temp40;\n    long\
    \ temp41;\n    long temp42;\n    long temp43;\n    long temp44;\n    long temp45;\n\
    \    long temp46;\n    long temp47;\n    long temp48;\n    long temp49;\n    long\
    \ temp50;\n    long temp51;\n    long temp52;\n    long temp53;\n    long temp54;\n\
    \    long temp55;\n    long temp56;\n    long temp57;\n    long temp58;\n    long\
    \ temp59;\n    long temp60;\n    long temp61;\n    long temp62;\n    long temp63;\n\
    \    long temp64;\n    long temp65;\n    long temp66;\n    long temp67;\n    long\
    \ temp68;\n    long temp69;\n    long temp70;\n    long temp71;\n    long temp72;\n\
    \    long temp73;\n    long temp74;\n    long temp75;\n    long temp76;\n    long\
    \ temp77;\n    long temp78;\n    long temp79;\n    long temp80;\n    long temp81;\n\
    \    long temp82;\n    long temp83;\n    long temp84;\n    long temp85;\n    long\
    \ temp86;\n    long temp\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3b1quufg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp3b1quufg.cpp:106:1: error: expected initializer before \u2018}\u2019\
    \ token\n  106 | }\n      | ^\n/tmp/tmp3b1quufg.cpp:106:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Write your code here\n  long ans\
    \ = 0, diff = 0;\n  long long int num = stoi(value);\n  long long int num1 = num;\n\
    \  long long int num2 = num;\n  long long int num3 = num;\n  long long int num4\
    \ = num;\n  long long int num5 = num;\n  long long int num6 = num;\n  long long\
    \ int num7 = num;\n  long long int num8 = num;\n  long long int num9 = num;\n\
    \  long long int num10 = num;\n  long long int num11 = num;\n  long long int num12\
    \ = num;\n  long long int num13 = num;\n  long long int num14 = num;\n  long long\
    \ int num15 = num;\n  long long int num16 = num;\n  long long int num17 = num;\n\
    \  long long int num18 = num;\n  long long int num19 = num;\n  long long int num20\
    \ = num;\n  long long int num21 = num;\n  long long int num22 = num;\n  long long\
    \ int num23 = num;\n  long long int num24 = num;\n  long long int num25 = num;\n\
    \  long long int num26 = num;\n  long long int num27 = num;\n  long long int num28\
    \ = num;\n  long long int num29 = num;\n  long long int num30 = num;\n  long long\
    \ int num31 = num;\n  long long int num32 = num;\n  long long int num33 = num;\n\
    \  long long int num34 = num;\n  long long int num35 = num;\n  long long int num36\
    \ = num;\n  long long int num37 = num;\n  long long int num38 = num;\n  long long\
    \ int num39 = num;\n  long long int num40 = num;\n  long long int num41 = num;\n\
    \  long long int num42 = num;\n  long long int num43 = num;\n  long long int num44\
    \ = num;\n  long long int num45 = num;\n  long long int num46 = num;\n  long long\
    \ int num47 = num;\n  long long int num48 = num;\n  long long int num49 = num;\n\
    \  long long int num50 = num;\n  long \n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzmfuna2q.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpzmfuna2q.cpp:71:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   71 | }\n      | ^\n/tmp/tmpzmfuna2q.cpp:71:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ num = std::stoll(value);\n    long diff = abs(num - ans);\n    while (diff >\
    \ 1) {\n        ans += 1;\n        diff = abs(num - ans);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprks11k55.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmprks11k55.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = abs(num - ans);\n      |          ^~~~\n/tmp/tmprks11k55.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141465
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    long mid = (lower + upper) / 2;\n    long diff = std::abs(mid - std::stoll(value));\n\
    \    if (diff > 1) {\n        mid = mid - 1;\n        diff = std::abs(mid - std::stoll(value));\n\
    \    }\n    if (diff == 1) {\n        return mid;\n    }\n    if (diff < 0) {\n\
    \        lower = mid + 1;\n        diff = std::abs(mid - std::stoll(value));\n\
    \    }\n    if (diff > 0) {\n        upper = mid - 1;\n        diff = std::abs(mid\
    \ - std::stoll(value));\n    }\n    return lower + diff / 2;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmplv47_xbe: /tmp/tmplv47_xbe.cpp:39: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long num = std::stoi(value);\n    long diff = num - ans;\n\
    \    while(diff > 0){\n        ans += 1;\n        diff -= 1;\n    }\n    while(diff\
    \ < 0){\n        ans -= 1;\n        diff += 1;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphjxf0xde.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmphjxf0xde.cpp:20:10: error: redeclaration of \u2018long int diff\u2019\
    \n   20 |     long diff = num - ans;\n      |          ^~~~\n/tmp/tmphjxf0xde.cpp:18:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141465
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, x = 0, y = 0;\n    long long temp;\n    temp = atof(value.c_str());\n   \
    \ if (temp < 0)\n        temp *= -1;\n    temp = temp - 1;\n    temp = temp *\
    \ temp;\n    temp = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n\
    \    temp = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n    temp\
    \ = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n    temp = temp\
    \ / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n    temp = temp / 2;\n\
    \    temp = temp + temp;\n    temp = temp + temp;\n    temp = temp / 2;\n    temp\
    \ = temp + temp;\n    temp = temp + temp;\n    temp = temp / 2;\n    temp = temp\
    \ + temp;\n    temp = temp + temp;\n    temp = temp / 2;\n    temp = temp + temp;\n\
    \    temp = temp + temp;\n    temp = temp / 2;\n    temp = temp + temp;\n    temp\
    \ = temp + temp;\n    temp = temp / 2;\n    temp = temp + temp;\n    temp = temp\
    \ + temp;\n    temp = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n\
    \    temp = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n    temp\
    \ = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n    temp = temp\
    \ / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n    temp = temp / 2;\n\
    \    temp = temp + temp;\n    temp = temp + temp;\n    temp = temp / 2;\n    temp\
    \ = temp + temp;\n    temp = temp + temp;\n    temp = temp / 2;\n    temp = temp\
    \ + temp;\n    temp = temp + temp;\n    temp = temp / 2;\n    temp = temp + temp;\n\
    \    temp = temp + temp;\n    temp = temp / 2;\n    temp = temp + temp;\n    temp\
    \ = temp + temp;\n    temp = temp / 2;\n    temp = temp + temp;\n    temp = temp\
    \ + temp;\n    temp = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n\
    \    temp = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n    temp\
    \ = temp / 2;\n    temp = temp + temp;\n    temp = temp + temp;\n\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp87e8d_hh: /tmp/tmp87e8d_hh.cpp:98: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    ans =\
    \ temp;\n    if (diff < 0) {\n        diff *= -1;\n    }\n    if (diff < 0.5)\
    \ {\n        diff *= 2;\n    }\n    if (diff < 1) {\n        diff *= 2;\n    }\n\
    \    if (diff < 2) {\n        diff *= 2;\n    }\n    if (diff < 3) {\n       \
    \ diff *= 2;\n    }\n    if (diff < 4) {\n        diff *= 2;\n    }\n    if (diff\
    \ < 5) {\n        diff *= 2;\n    }\n    if (diff < 6) {\n        diff *= 2;\n\
    \    }\n    if (diff < 7) {\n        diff *= 2;\n    }\n    if (diff < 8) {\n\
    \        diff *= 2;\n    }\n    if (diff < 9) {\n        diff *= 2;\n    }\n \
    \   if (diff < 10) {\n        diff *= 2;\n    }\n    if (diff < 11) {\n      \
    \  diff *= 2;\n    }\n    if (diff < 12) {\n        diff *= 2;\n    }\n    if\
    \ (diff < 13) {\n        diff *= 2;\n    }\n    if (diff < 14) {\n        diff\
    \ *= 2;\n    }\n    if (diff < 15) {\n        diff *= 2;\n    }\n    if (diff\
    \ < 16) {\n        diff *= 2;\n    }\n    if (diff < 17) {\n        diff *= 2;\n\
    \    }\n    if (diff < 18) {\n        diff *= 2;\n    }\n    if (diff < 19) {\n\
    \        diff *= 2;\n    }\n    if (diff < 20) {\n        diff *= 2;\n    }\n\
    \    if (diff < 21) {\n        diff *= 2;\n    }\n    if (diff < 22) {\n     \
    \   diff *= 2;\n    }\n    if (diff < 23) {\n        diff *= 2;\n    }\n    if\
    \ (diff < 24) {\n        diff *= 2;\n    }\n    if (diff < 25) {\n        diff\
    \ *= 2;\n    }\n    if (diff < 26) {\n        diff *= 2;\n    }\n    if (diff\
    \ < 27) {\n        diff *= 2;\n    }\n    if (diff < 28) {\n        diff *= 2;\n\
    \    }\n    if (diff < 29) {\n        diff *= 2;\n    }\n    if (diff < 30) {\n\
    \        diff *= 2;\n    }\n    if (diff < 31) {\n        diff *= 2;\n    }\n\
    \    if (diff < 32) {\n        diff *= 2;\n    }\n    if (diff < 33) {\n     \
    \   diff *= 2;\n    }\n    if (diff < 34) {\n        diff *= 2;\n    }\n    if\
    \ (diff < 35) {\n        diff *= 2;\n    }\n    if (diff \n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5tku0wra.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp5tku0wra.cpp:133:13: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n  133 |     if (diff\n      |        ~    ^\n      |             )\n\
    \  134 | }\n      | ~            \n/tmp/tmp5tku0wra.cpp:134:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n  134 | }\n      | ^\n/tmp/tmp5tku0wra.cpp:134:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplq41houc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmplq41houc.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmplq41houc.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff = diff * -1;\n    }\n    if (diff > 1000000000000) {\n\
    \        diff = diff / 1000000000000;\n    }\n    if (diff < -1000000000000) {\n\
    \        diff = diff * -1;\n    }\n    ans = temp + diff;\n    return ans;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3syvrcl8: /tmp/tmp3syvrcl8.cpp:35: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    ans = temp;\n\
    \    if (diff < 0) {\n        diff *= -1;\n    }\n    long diff = std::abs(diff);\n\
    \    if (diff > 100) {\n        diff = diff / 100;\n    }\n    if (diff > 10)\
    \ {\n        diff = diff / 10;\n    }\n    if (diff > 1) {\n        diff = diff\
    \ / 1;\n    }\n    return ans + diff;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr70da27q.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpr70da27q.cpp:25:10: error: redeclaration of \u2018long int diff\u2019\
    \n   25 |     long diff = std::abs(diff);\n      |          ^~~~\n/tmp/tmpr70da27q.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141465
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ diff = upper - lower;\n    while (diff > 0) {\n        diff /= 10;\n       \
    \ lower += diff;\n    }\n    while (diff < 0) {\n        diff *= 10;\n       \
    \ upper -= diff;\n    }\n    if (lower == upper) {\n        return lower;\n  \
    \  }\n    if (lower > upper) {\n        std::swap(lower, upper);\n    }\n    return\
    \ lower;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmfwi8xr1: /tmp/tmpmfwi8xr1.cpp:36: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff = diff * -1;\n    }\n    ans = temp;\n    if (diff < 0.5)\
    \ {\n        ans = ans + 1;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp0y8yxz0q: /tmp/tmp0y8yxz0q.cpp:33: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int a = stoi(value);\n \
    \   long long int b = stoi(value);\n    long long int c = stoi(value);\n    long\
    \ long int d = stoi(value);\n    long long int e = stoi(value);\n    long long\
    \ int f = stoi(value);\n    long long int g = stoi(value);\n    long long int\
    \ h = stoi(value);\n    long long int i = stoi(value);\n    long long int j =\
    \ stoi(value);\n    long long int k = stoi(value);\n    long long int l = stoi(value);\n\
    \    long long int m = stoi(value);\n    long long int n = stoi(value);\n    long\
    \ long int o = stoi(value);\n    long long int p = stoi(value);\n    long long\
    \ int q = stoi(value);\n    long long int r = stoi(value);\n    long long int\
    \ s = stoi(value);\n    long long int t = stoi(value);\n    long long int u =\
    \ stoi(value);\n    long long int v = stoi(value);\n    long long int w = stoi(value);\n\
    \    long long int x = stoi(value);\n    long long int y = stoi(value);\n    long\
    \ long int z = stoi(value);\n    long long int a = stoi(value);\n    long long\
    \ int b = stoi(value);\n    long long int c = stoi(value);\n    long long int\
    \ d = stoi(value);\n    long long int e = stoi(value);\n    long long int f =\
    \ stoi(value);\n    long long int g = stoi(value);\n    long long int h = stoi(value);\n\
    \    long long int i = stoi(value);\n    long long int j = stoi(value);\n    long\
    \ long int k = stoi(value);\n    long long int l = stoi(value);\n    long long\
    \ int m = stoi(value);\n    long long int n = stoi(value);\n    long long int\
    \ o = stoi(value);\n    long long int p = stoi(value);\n    long long int q =\
    \ stoi(value);\n    long long int r = stoi(value);\n    long long int s = stoi(value);\n\
    \    long long int t = stoi(value);\n    long long int u = stoi(value);\n    long\
    \ long int v = stoi(value);\n    long long int w = stoi(value);\n    long long\
    \ int x = stoi(value);\n    long long int y = stoi(value);\n    long long int\
    \ z = stoi(value);\n    long long int a = stoi(value);\n    long long int b =\
    \ stoi(value);\n    long long int c = stoi(value);\n    long long int d = stoi(value);\n\
    \    long long int e = stoi(value);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpullwpm41.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpullwpm41.cpp:43:19: error: redeclaration of \u2018long long int a\u2019\
    \n   43 |     long long int a = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:17:19:\
    \ note: \u2018long long int a\u2019 previously declared here\n   17 |     long\
    \ long int a = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:44:19:\
    \ error: redeclaration of \u2018long long int b\u2019\n   44 |     long long int\
    \ b = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:18:19: note:\
    \ \u2018long long int b\u2019 previously declared here\n   18 |     long long\
    \ int b = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:45:19:\
    \ error: redeclaration of \u2018long long int c\u2019\n   45 |     long long int\
    \ c = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:19:19: note:\
    \ \u2018long long int c\u2019 previously declared here\n   19 |     long long\
    \ int c = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:46:19:\
    \ error: redeclaration of \u2018long long int d\u2019\n   46 |     long long int\
    \ d = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:20:19: note:\
    \ \u2018long long int d\u2019 previously declared here\n   20 |     long long\
    \ int d = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:47:19:\
    \ error: redeclaration of \u2018long long int e\u2019\n   47 |     long long int\
    \ e = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:21:19: note:\
    \ \u2018long long int e\u2019 previously declared here\n   21 |     long long\
    \ int e = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:48:19:\
    \ error: redeclaration of \u2018long long int f\u2019\n   48 |     long long int\
    \ f = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:22:19: note:\
    \ \u2018long long int f\u2019 previously declared here\n   22 |     long long\
    \ int f = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:49:19:\
    \ error: redeclaration of \u2018long long int g\u2019\n   49 |     long long int\
    \ g = stoi(value);\n      |                   ^\n/tmp/tmpullwpm41.cpp:23:19: note:\
    \ \u2018long "
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp;\n    long long temp2;\n    long long temp3;\n    long long temp4;\n  \
    \  long long temp5;\n    long long temp6;\n    long long temp7;\n    long long\
    \ temp8;\n    long long temp9;\n    long long temp10;\n    long long temp11;\n\
    \    long long temp12;\n    long long temp13;\n    long long temp14;\n    long\
    \ long temp15;\n    long long temp16;\n    long long temp17;\n    long long temp18;\n\
    \    long long temp19;\n    long long temp20;\n    long long temp21;\n    long\
    \ long temp22;\n    long long temp23;\n    long long temp24;\n    long long temp25;\n\
    \    long long temp26;\n    long long temp27;\n    long long temp28;\n    long\
    \ long temp29;\n    long long temp30;\n    long long temp31;\n    long long temp32;\n\
    \    long long temp33;\n    long long temp34;\n    long long temp35;\n    long\
    \ long temp36;\n    long long temp37;\n    long long temp38;\n    long long temp39;\n\
    \    long long temp40;\n    long long temp41;\n    long long temp42;\n    long\
    \ long temp43;\n    long long temp44;\n    long long temp45;\n    long long temp46;\n\
    \    long long temp47;\n    long long temp48;\n    long long temp49;\n    long\
    \ long temp50;\n    long long temp51;\n    long long temp52;\n    long long temp53;\n\
    \    long long temp54;\n    long long temp55;\n    long long temp56;\n    long\
    \ long temp57;\n    long long temp58;\n    long long temp59;\n    long long temp60;\n\
    \    long long temp61;\n    long long temp62;\n    long long temp63;\n    long\
    \ long temp64;\n    long long temp65;\n    long long temp66;\n    long long temp67;\n\
    \    long long temp68;\n    long long temp69;\n    long long temp70;\n    long\
    \ long temp71;\n    long long temp72;\n    long long temp73;\n    long long temp74;\n\
    \    long long temp75;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpg6tdqfd_: /tmp/tmpg6tdqfd_.cpp:97: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long m = stoi(value);\n    long d = n - m;\n    long r\
    \ = n / d;\n    long s = m / d;\n    long t = r * d;\n    long u = (r + s) * d;\n\
    \    long v = (r - s) * d;\n    long w = (r + s - t) * d;\n    long x = (r - s\
    \ - t) * d;\n    long y = (r + s + t) * d;\n    long z = (r - s - t - u) * d;\n\
    \    long a = (r + s + t - u - v - w) * d;\n    long b = (r - s - t - u - v -\
    \ w) * d;\n    long c = (r + s - t - u - v + w) * d;\n    long d = (r - s - t\
    \ - u - v + w) * d;\n    long e = (r + s - t + u + v) * d;\n    long f = (r -\
    \ s - t + u + v) * d;\n    long g = (r + s - t + u + v + w) * d;\n    long h =\
    \ (r - s - t + u + v + w) * d;\n    long i = (r + s - t + u - v - w) * d;\n  \
    \  long j = (r - s - t + u - v - w) * d;\n    long k = (r + s - t + u - v + w)\
    \ * d;\n    long l = (r - s - t + u - v + w) * d;\n    long m = (r + s - t - u\
    \ + v) * d;\n    long n = (r - s - t - u + v) * d;\n    long o = (r + s - t -\
    \ u - v) * d;\n    long p = (r - s - t - u - v) * d;\n    long q = (r + s - t\
    \ + u) * d;\n    long r = (r - s - t + u) * d;\n    long s = (a + b + c + d +\
    \ e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t) * d;\n    long\
    \ t = (a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r +\
    \ s + t + u) * d;\n    long u = (a + b + c + d + e + f + g + h + i + j + k + l\
    \ + m + n + o + p + q + r + s + t + u + v) * d;\n    long v = (a + b + c + d +\
    \ e + f + g + h\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6da71ldj.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp6da71ldj.cpp:33:10: error: redeclaration of \u2018long int d\u2019\n\
    \   33 |     long d = (r - s - t - u - v + w) * d;\n      |          ^\n/tmp/tmp6da71ldj.cpp:20:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   20 |     long d =\
    \ n - m;\n      |          ^\n/tmp/tmp6da71ldj.cpp:42:10: error: redeclaration\
    \ of \u2018long int m\u2019\n   42 |     long m = (r + s - t - u + v) * d;\n \
    \     |          ^\n/tmp/tmp6da71ldj.cpp:19:10: note: \u2018long int m\u2019 previously\
    \ declared here\n   19 |     long m = stoi(value);\n      |          ^\n/tmp/tmp6da71ldj.cpp:43:10:\
    \ error: redeclaration of \u2018long int n\u2019\n   43 |     long n = (r - s\
    \ - t - u + v) * d;\n      |          ^\n/tmp/tmp6da71ldj.cpp:18:10: note: \u2018\
    long int n\u2019 previously declared here\n   18 |     long n = stoi(value);\n\
    \      |          ^\n/tmp/tmp6da71ldj.cpp:47:10: error: redeclaration of \u2018\
    long int r\u2019\n   47 |     long r = (r - s - t + u) * d;\n      |         \
    \ ^\n/tmp/tmp6da71ldj.cpp:21:10: note: \u2018long int r\u2019 previously declared\
    \ here\n   21 |     long r = n / d;\n      |          ^\n/tmp/tmp6da71ldj.cpp:48:10:\
    \ error: redeclaration of \u2018long int s\u2019\n   48 |     long s = (a + b\
    \ + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t) * d;\n\
    \      |          ^\n/tmp/tmp6da71ldj.cpp:22:10: note: \u2018long int s\u2019\
    \ previously declared here\n   22 |     long s = m / d;\n      |          ^\n\
    /tmp/tmp6da71ldj.cpp:49:10: error: redeclaration of \u2018long int t\u2019\n \
    \  49 |     long t = (a + b + c + d + e + f + g + h + i + j + k + l + m + n +\
    \ o + p + q + r + s + t + u) * d;\n      |          ^\n/tmp/tmp6da71ldj.cpp:23:10:\
    \ note: \u2018long int t\u2019 previously declared here\n   23 |     long t =\
    \ r * d;\n      |          ^\n/tmp/tmp6da71ldj.cpp:50:10: error: redeclaration\
    \ of \u2018long int u\u2019\n   50 |     long u = (a + b + c + d + e + f + g +\
    \ h + i + j + k + l + m + n + o + p + q + r + s + t + u + v) * d;\n      |   \
    \       ^\n/tmp/tmp6da71ldj.cpp:24:10: note: \u2018long int u\u2019 previously\
    \ declared here\n   24 |     l"
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, i = 0;\n    long min = std::numeric_limits<long>::max();\n    long max =\
    \ std::numeric_limits<long>::min();\n    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n\
    \    long diff2 = std::numeric_limits<long>::max();\n    long diff3 = std::numeric_limits<long>::max();\n\
    \    long diff4 = std::numeric_limits<long>::max();\n    long diff5 = std::numeric_limits<long>::max();\n\
    \    long diff6 = std::numeric_limits<long>::max();\n    long diff7 = std::numeric_limits<long>::max();\n\
    \    long diff8 = std::numeric_limits<long>::max();\n    long diff9 = std::numeric_limits<long>::max();\n\
    \    long diff10 = std::numeric_limits<long>::max();\n    long diff11 = std::numeric_limits<long>::max();\n\
    \    long diff12 = std::numeric_limits<long>::max();\n    long diff13 = std::numeric_limits<long>::max();\n\
    \    long diff14 = std::numeric_limits<long>::max();\n    long diff15 = std::numeric_limits<long>::max();\n\
    \    long diff16 = std::numeric_limits<long>::max();\n    long diff17 = std::numeric_limits<long>::max();\n\
    \    long diff18 = std::numeric_limits<long>::max();\n    long diff19 = std::numeric_limits<long>::max();\n\
    \    long diff20 = std::numeric_limits<long>::max();\n    long diff21 = std::numeric_limits<long>::max();\n\
    \    long diff22 = std::numeric_limits<long>::max();\n    long diff23 = std::numeric_limits<long>::max();\n\
    \    long diff24 = std::numeric_limits<long>::max();\n    long diff25 = std::numeric_limits<long>::max();\n\
    \    long diff26 = std::numeric_limits<long>::max();\n    long diff27 = std::numeric_limits<long>::max();\n\
    \    long diff28 = std::numeric_limits<long>::max();\n    long diff29 = std::numeric_limits<long>::max();\n\
    \    long diff30 = std::numeric_limits<long>::max();\n    long diff31 = std::numeric_limits<long>::max();\n\
    \    long diff32 = std::numeric_limits<long>::max();\n    long diff33 = std::numeric_limits<long>::max();\n\
    \    long diff34 = std::numeric_limits<long>::max();\n    long diff35 = std::numeric_limits\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp544awk2n.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp544awk2n.cpp:57:1: error: missing template arguments before \u2018\
    }\u2019 token\n   57 | }\n      | ^\n/tmp/tmp544awk2n.cpp:57:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n\
    \    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long\
    \ p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n\
    \    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long\
    \ y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n\
    \    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long\
    \ H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n\
    \    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long\
    \ Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n\
    \    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long\
    \ Z = 0;\n    long AA = 0;\n    long AB = 0;\n    long AC = 0;\n    long AD =\
    \ 0;\n    long AE = 0;\n    long AF = 0;\n    long AG = 0;\n    long AH = 0;\n\
    \    long AI = 0;\n    long AJ = 0;\n    long AK = 0;\n    long AL = 0;\n    long\
    \ AM = 0;\n    long AN = 0;\n    long AO = 0;\n    long AP = 0;\n    long AQ =\
    \ 0;\n    long AR = 0;\n    long AS = 0;\n    long AT = 0;\n    long AU = 0;\n\
    \    long AV = 0;\n    long AW = 0;\n    long AX = 0;\n    long AY = 0;\n    long\
    \ AZ = 0;\n    long BA = 0;\n    long BB = 0;\n    long BC = 0;\n    long BD =\
    \ 0;\n    long BE = 0;\n    long BF = 0;\n    long BG = 0;\n    long BH = 0;\n\
    \    long BI = 0;\n    long BJ = 0;\n    long BK = 0;\n    long BL = 0;\n    long\
    \ BM = 0;\n    long BN = 0;\n    long BO = 0;\n    long BP = 0;\n    long BQ =\
    \ 0;\n    long BR = 0;\n    long BS = 0;\n    long BT = 0;\n    long BU = 0;\n\
    \    long BV = 0;\n    long BW = 0;\n    long BX = 0;\n    long BY = 0;\n    long\
    \ BZ = 0;\n    long CA = 0;\n    long CB = 0;\n    \n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmwo2o_3r: /tmp/tmpmwo2o_3r.cpp:122: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d = 0;\n    long\
    \ e = 0;\n    long f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n\
    \    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long\
    \ n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n\
    \    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long\
    \ w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n\
    \    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long\
    \ F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n\
    \    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long\
    \ O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n\
    \    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long\
    \ X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n\
    \    long c = 0;\n    long d = 0;\n    long e\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdsjn2htv.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpdsjn2htv.cpp:72:10: error: redeclaration of \u2018long int i\u2019\n\
    \   72 |     long i = 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:20:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   20 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpdsjn2htv.cpp:73:10: error: redeclaration of \u2018\
    long int j\u2019\n   73 |     long j = 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:21:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   21 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:74:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   74 |     long k = 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:22:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   22 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:75:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   75 |     long l = 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:23:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   23 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:76:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   76 |     long m = 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:24:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   24 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:77:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   77 |     long n = 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:25:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   25 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:78:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   78 |     long o = 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:26:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   26 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:79:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   79 |     long p = 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:27:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   27 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpdsjn2htv.cpp:80:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   80 |     long q = 0;\n      |          ^\n/tmp/tmpd"
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5\
    \ = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n    long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa3wcdiff.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpa3wcdiff.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpa3wcdiff.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, power = 0, temp = 0;\n    temp = std::stoll(value);\n    power = temp;\n\
    \    while (power != 0) {\n        ans = ans * 10 + power % 10;\n        power\
    \ = power / 10;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpa3by8x59: /tmp/tmpa3by8x59.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long long temp\
    \ = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long long temp4\
    \ = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long long temp7\
    \ = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long long temp10\
    \ = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n    long long temp13\
    \ = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16\
    \ = 0;\n    long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19\
    \ = 0;\n    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22\
    \ = 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3bp7kror: /tmp/tmp3bp7kror.cpp:95: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    while (lower <= upper) {\n        long mid = (lower + upper) / 2;\n\
    \        long midValue = std::stoll(value);\n        if (midValue < mid) {\n \
    \           lower = mid + 1;\n        } else if (midValue > mid) {\n         \
    \   upper = mid - 1;\n        } else {\n            return mid;\n        }\n \
    \   }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpco60jj2i: /tmp/tmpco60jj2i.cpp:33: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    ans =\
    \ temp;\n    if (diff < 0) {\n        diff = diff * -1;\n    }\n    return diff;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpl92ddg2u: /tmp/tmpl92ddg2u.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    while (lower < upper) {\n        long mid = (lower + upper) / 2;\n\
    \        long midValue = std::stoll(value) + mid * 0.5;\n        if (midValue\
    \ < lower) {\n            lower = mid;\n        } else if (midValue > upper) {\n\
    \            upper = mid;\n        } else {\n            return mid;\n       \
    \ }\n    }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpu_43en_0: /tmp/tmpu_43en_0.cpp:33: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int mid2;\n    long long int diff2;\n    long long int\
    \ mid3;\n    long long int diff3;\n    long long int mid4;\n    long long int\
    \ diff4;\n    long long int mid5;\n    long long int diff5;\n    long long int\
    \ mid6;\n    long long int diff6;\n    long long int mid7;\n    long long int\
    \ diff7;\n    long long int mid8;\n    long long int diff8;\n    long long int\
    \ mid9;\n    long long int diff9;\n    long long int mid10;\n    long long int\
    \ diff10;\n    long long int mid11;\n    long long int diff11;\n    long long\
    \ int mid12;\n    long long int diff12;\n    long long int mid13;\n    long long\
    \ int diff13;\n    long long int mid14;\n    long long int diff14;\n    long long\
    \ int mid15;\n    long long int diff15;\n    long long int mid16;\n    long long\
    \ int diff16;\n    long long int mid17;\n    long long int diff17;\n    long long\
    \ int mid18;\n    long long int diff18;\n    long long int mid19;\n    long long\
    \ int diff19;\n    long long int mid20;\n    long long int diff20;\n    long long\
    \ int mid21;\n    long long int diff21;\n    long long int mid22;\n    long long\
    \ int diff22;\n    long long int mid23;\n    long long int diff23;\n    long long\
    \ int mid24;\n    long long int diff24;\n    long long int mid25;\n    long long\
    \ int diff25;\n    long long int mid26;\n    long long int diff26;\n    long long\
    \ int mid27;\n    long long int diff27;\n    long long int mid28;\n    long long\
    \ int diff28;\n    long long int mid29;\n    long long int diff29;\n    long long\
    \ int mid30;\n    long long int diff30;\n    long long int mid31;\n    long long\
    \ int diff31;\n    long long int mid32;\n    long long int diff32;\n    long long\
    \ int mid33;\n    long long int diff33;\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3ftrqi_u: /tmp/tmp3ftrqi_u.cpp:89: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp49t1rysj: /tmp/tmp49t1rysj.cpp:106: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141462
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long d = std::stoll(value);\n    long x = std::stoll(value);\n    long\
    \ y = std::stoll(value);\n    long z = std::stoll(value);\n    long w = std::stoll(value);\n\
    \    long a = std::stoll(value);\n    long b = std::stoll(value);\n    long c\
    \ = std::stoll(value);\n    long d = std::stoll(value);\n    long e = std::stoll(value);\n\
    \    long f = std::stoll(value);\n    long g = std::stoll(value);\n    long h\
    \ = std::stoll(value);\n    long i = std::stoll(value);\n    long j = std::stoll(value);\n\
    \    long k = std::stoll(value);\n    long l = std::stoll(value);\n    long m\
    \ = std::stoll(value);\n    long n = std::stoll(value);\n    long o = std::stoll(value);\n\
    \    long p = std::stoll(value);\n    long q = std::stoll(value);\n    long r\
    \ = std::stoll(value);\n    long s = std::stoll(value);\n    long t = std::stoll(value);\n\
    \    long u = std::stoll(value);\n    long v = std::stoll(value);\n    long w\
    \ = std::stoll(value);\n    long x = std::stoll(value);\n    long y = std::stoll(value);\n\
    \    long z = std::stoll(value);\n    long a = std::stoll(value);\n    long b\
    \ = std::stoll(value);\n    long c = std::stoll(value);\n    long d = std::stoll(value);\n\
    \    long e = std::stoll(value);\n    long f = std::stoll(value);\n    long g\
    \ = std::stoll(value);\n    long h = std::stoll(value);\n    long i = std::stoll(value);\n\
    \    long j = std::stoll(value);\n    long k = std::stoll(value);\n    long l\
    \ = std::stoll(value);\n    long m = std::stoll(value);\n    long n = std::stoll(value);\n\
    \    long o = std::stoll(value);\n    long p = std::stoll(value);\n    long q\
    \ = std::stoll(value);\n    long r = std::stoll(value);\n    long s = std::stoll(value);\n\
    \    long t = std::stoll(value);\n    long u = std::stoll(value);\n    long v\
    \ = std::stoll(value);\n    long w = std::stoll(value);\n    long x = std::stoll(value);\n\
    \    long y = std::stoll\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv_xh0pty.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpv_xh0pty.cpp:27:10: error: redeclaration of \u2018long int d\u2019\n\
    \   27 |     long d = std::stoll(value);\n      |          ^\n/tmp/tmpv_xh0pty.cpp:19:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   19 |     long d =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpv_xh0pty.cpp:46:10: error: redeclaration\
    \ of \u2018long int w\u2019\n   46 |     long w = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpv_xh0pty.cpp:23:10: note: \u2018long int w\u2019 previously\
    \ declared here\n   23 |     long w = std::stoll(value);\n      |          ^\n\
    /tmp/tmpv_xh0pty.cpp:47:10: error: redeclaration of \u2018long int x\u2019\n \
    \  47 |     long x = std::stoll(value);\n      |          ^\n/tmp/tmpv_xh0pty.cpp:20:10:\
    \ note: \u2018long int x\u2019 previously declared here\n   20 |     long x =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpv_xh0pty.cpp:48:10: error: redeclaration\
    \ of \u2018long int y\u2019\n   48 |     long y = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpv_xh0pty.cpp:21:10: note: \u2018long int y\u2019 previously\
    \ declared here\n   21 |     long y = std::stoll(value);\n      |          ^\n\
    /tmp/tmpv_xh0pty.cpp:49:10: error: redeclaration of \u2018long int z\u2019\n \
    \  49 |     long z = std::stoll(value);\n      |          ^\n/tmp/tmpv_xh0pty.cpp:22:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   22 |     long z =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpv_xh0pty.cpp:50:10: error: redeclaration\
    \ of \u2018long int a\u2019\n   50 |     long a = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpv_xh0pty.cpp:24:10: note: \u2018long int a\u2019 previously\
    \ declared here\n   24 |     long a = std::stoll(value);\n      |          ^\n\
    /tmp/tmpv_xh0pty.cpp:51:10: error: redeclaration of \u2018long int b\u2019\n \
    \  51 |     long b = std::stoll(value);\n      |          ^\n/tmp/tmpv_xh0pty.cpp:25:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   25 |     long b =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpv_xh0pty.cpp:52:10: error: redeclaration\
    \ of \u2018long int c\u2019\n   52 |     long c = std::stoll(value);\n      |\
    \          ^\n"
  stdout: ''
  timestamp: 1660141465
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoi(value);\n   \
    \ if (ans == 0) {\n        ans = 1;\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpp6los9qy: /tmp/tmpp6los9qy.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = std::abs(atoi(value.c_str()));\n\
    \    long mid = diff / 2;\n    long left = diff - mid;\n    long right = mid;\n\
    \    if (left > right) {\n        ans = mid;\n    } else {\n        ans = right;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpckkdhspj: /tmp/tmpckkdhspj.cpp:31: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long max = 0;\n    long min = 0;\n    long mid = 0;\n    long temp2 = 0;\n\
    \    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6\
    \ = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long\
    \ temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n\
    \    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17\
    \ = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n   \
    \ long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24\
    \ = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n   \
    \ long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31\
    \ = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n   \
    \ long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38\
    \ = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n   \
    \ long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45\
    \ = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n   \
    \ long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52\
    \ = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n   \
    \ long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59\
    \ = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n   \
    \ long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n    long temp66\
    \ = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69 = 0;\n   \
    \ long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n    long temp73\
    \ = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76 = 0;\n   \
    \ long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n    long temp80\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3zyarbys.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp3zyarbys.cpp:105:1: error: expected initializer before \u2018}\u2019\
    \ token\n  105 | }\n      | ^\n/tmp/tmp3zyarbys.cpp:105:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoll(value);\n  \
    \  if (ans == 0) {\n        ans = std::stoll(value.substr(0, value.size() - 1));\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp0vn8i6s4: /tmp/tmp0vn8i6s4.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long diff = abs(n - ans);\n    long mid = diff / 2;\n\
    \    long mid2 = diff / 2;\n    long mid3 = diff / 2;\n    long mid4 = diff /\
    \ 2;\n    long mid5 = diff / 2;\n    long mid6 = diff / 2;\n    long mid7 = diff\
    \ / 2;\n    long mid8 = diff / 2;\n    long mid9 = diff / 2;\n    long mid10 =\
    \ diff / 2;\n    long mid11 = diff / 2;\n    long mid12 = diff / 2;\n    long\
    \ mid13 = diff / 2;\n    long mid14 = diff / 2;\n    long mid15 = diff / 2;\n\
    \    long mid16 = diff / 2;\n    long mid17 = diff / 2;\n    long mid18 = diff\
    \ / 2;\n    long mid19 = diff / 2;\n    long mid20 = diff / 2;\n    long mid21\
    \ = diff / 2;\n    long mid22 = diff / 2;\n    long mid23 = diff / 2;\n    long\
    \ mid24 = diff / 2;\n    long mid25 = diff / 2;\n    long mid26 = diff / 2;\n\
    \    long mid27 = diff / 2;\n    long mid28 = diff / 2;\n    long mid29 = diff\
    \ / 2;\n    long mid30 = diff / 2;\n    long mid31 = diff / 2;\n    long mid32\
    \ = diff / 2;\n    long mid33 = diff / 2;\n    long mid34 = diff / 2;\n    long\
    \ mid35 = diff / 2;\n    long mid36 = diff / 2;\n    long mid37 = diff / 2;\n\
    \    long mid38 = diff / 2;\n    long mid39 = diff / 2;\n    long mid40 = diff\
    \ / 2;\n    long mid41 = diff / 2;\n    long mid42 = diff / 2;\n    long mid43\
    \ = diff / 2;\n    long mid44 = diff / 2;\n    long mid45 = diff / 2;\n    long\
    \ mid46 = diff / 2;\n    long mid47 = diff / 2;\n    long mid48 = diff / 2;\n\
    \    long mid49 = diff / 2;\n    long mid50 = diff / 2;\n    long mid51 = diff\
    \ / 2;\n    long mid52 = diff / 2;\n    long mid53 = diff / 2;\n    long mid54\
    \ = diff / 2;\n    long mid55 = diff / 2;\n    long mid56 = diff \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzb61j55f.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpzb61j55f.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = abs(n - ans);\n      |          ^~~~\n/tmp/tmpzb61j55f.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n/tmp/tmpzb61j55f.cpp:76:1: error:\
    \ expected \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   76 |\
    \ }\n      | ^\n/tmp/tmpzb61j55f.cpp:76:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long\
    \ ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii =\
    \ 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n\
    \    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long\
    \ rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv =\
    \ 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n\
    \    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long\
    \ Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii =\
    \ 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n\
    \    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long\
    \ Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv =\
    \ 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n    long Z\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprqtegfjl.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmprqtegfjl.cpp:116:1: error: expected initializer before \u2018}\u2019\
    \ token\n  116 | }\n      | ^\n/tmp/tmprqtegfjl.cpp:116:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnro_jpvo: /tmp/tmpnro_jpvo.cpp:88: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long diff = 0;\n    long sum = 0;\n    long sum2 = 0;\n    long\
    \ sum3 = 0;\n    long sum4 = 0;\n    long sum5 = 0;\n    long sum6 = 0;\n    long\
    \ sum7 = 0;\n    long sum8 = 0;\n    long sum9 = 0;\n    long sum10 = 0;\n   \
    \ long sum11 = 0;\n    long sum12 = 0;\n    long sum13 = 0;\n    long sum14 =\
    \ 0;\n    long sum15 = 0;\n    long sum16 = 0;\n    long sum17 = 0;\n    long\
    \ sum18 = 0;\n    long sum19 = 0;\n    long sum20 = 0;\n    long sum21 = 0;\n\
    \    long sum22 = 0;\n    long sum23 = 0;\n    long sum24 = 0;\n    long sum25\
    \ = 0;\n    long sum26 = 0;\n    long sum27 = 0;\n    long sum28 = 0;\n    long\
    \ sum29 = 0;\n    long sum30 = 0;\n    long sum31 = 0;\n    long sum32 = 0;\n\
    \    long sum33 = 0;\n    long sum34 = 0;\n    long sum35 = 0;\n    long sum36\
    \ = 0;\n    long sum37 = 0;\n    long sum38 = 0;\n    long sum39 = 0;\n    long\
    \ sum40 = 0;\n    long sum41 = 0;\n    long sum42 = 0;\n    long sum43 = 0;\n\
    \    long sum44 = 0;\n    long sum45 = 0;\n    long sum46 = 0;\n    long sum47\
    \ = 0;\n    long sum48 = 0;\n    long sum49 = 0;\n    long sum50 = 0;\n    long\
    \ sum51 = 0;\n    long sum52 = 0;\n    long sum53 = 0;\n    long sum54 = 0;\n\
    \    long sum55 = 0;\n    long sum56 = 0;\n    long sum57 = 0;\n    long sum58\
    \ = 0;\n    long sum59 = 0;\n    long sum60 = 0;\n    long sum61 = 0;\n    long\
    \ sum62 = 0;\n    long sum63 = 0;\n    long sum64 = 0;\n    long sum65 = 0;\n\
    \    long sum66 = 0;\n    long sum67 = 0;\n    long sum68 = 0;\n    long sum69\
    \ = 0;\n    long sum70 = 0;\n    long sum71 = 0;\n    long sum72 = 0;\n    long\
    \ sum73 = 0;\n    long sum74 = 0;\n    long sum75 = 0;\n    long sum76 = 0;\n\
    \    long sum77 = 0;\n    long sum78 = 0;\n    long sum79 = 0;\n    long sum80\
    \ = 0;\n    long sum81 = 0;\n    long sum82 = 0;\n    long sum83 = 0;\n    long\
    \ sum84\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4adlym0n.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp4adlym0n.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmp4adlym0n.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long diff = n - ans;\n    if (diff < 0) {\n        diff\
    \ = diff * -1;\n    }\n    long d = diff / 2;\n    while (diff > d) {\n      \
    \  ans += d;\n        diff -= d;\n        d = diff / 2;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2fpuhao9.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2fpuhao9.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmp2fpuhao9.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = 0;\n    long long\
    \ int min = 0;\n    long long int max = 0;\n    long long int mid = 0;\n    long\
    \ long int diff = 0;\n    long long int diff2 = 0;\n    long long int diff3 =\
    \ 0;\n    long long int diff4 = 0;\n    long long int diff5 = 0;\n    long long\
    \ int diff6 = 0;\n    long long int diff7 = 0;\n    long long int diff8 = 0;\n\
    \    long long int diff9 = 0;\n    long long int diff10 = 0;\n    long long int\
    \ diff11 = 0;\n    long long int diff12 = 0;\n    long long int diff13 = 0;\n\
    \    long long int diff14 = 0;\n    long long int diff15 = 0;\n    long long int\
    \ diff16 = 0;\n    long long int diff17 = 0;\n    long long int diff18 = 0;\n\
    \    long long int diff19 = 0;\n    long long int diff20 = 0;\n    long long int\
    \ diff21 = 0;\n    long long int diff22 = 0;\n    long long int diff23 = 0;\n\
    \    long long int diff24 = 0;\n    long long int diff25 = 0;\n    long long int\
    \ diff26 = 0;\n    long long int diff27 = 0;\n    long long int diff28 = 0;\n\
    \    long long int diff29 = 0;\n    long long int diff30 = 0;\n    long long int\
    \ diff31 = 0;\n    long long int diff32 = 0;\n    long long int diff33 = 0;\n\
    \    long long int diff34 = 0;\n    long long int diff35 = 0;\n    long long int\
    \ diff36 = 0;\n    long long int diff37 = 0;\n    long long int diff38 = 0;\n\
    \    long long int diff39 = 0;\n    long long int diff40 = 0;\n    long long int\
    \ diff41 = 0;\n    long long int diff42 = 0;\n    long long int diff43 = 0;\n\
    \    long long int diff44 = 0;\n    long long int diff45 = 0;\n    long long int\
    \ diff46 = 0;\n    long long int diff47 = 0;\n    long long int diff48 = 0;\n\
    \    long long int diff49 = 0;\n    long long int diff50 = 0;\n    long long int\
    \ diff51 = 0;\n    long long int diff52 = 0;\n    long long int diff53 = 0;\n\
    \    long long int diff54 = 0;\n    long long int diff55 = 0;\n    long long int\
    \ diff56 = 0;\n    long long int diff57 = 0;\n    long long int diff58 = 0;\n\
    \    long long int diff59 = 0;\n    long long int diff60 = 0;\n    long long int\
    \ diff61 = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp89i68lk2: /tmp/tmp89i68lk2.cpp:86: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long num = std::stoll(value);\n    long diff = num - ans;\n    long\
    \ mod = diff % 10;\n    long diff = diff / 10;\n    long diff2 = diff % 10;\n\
    \    long diff3 = diff / 10;\n    long diff4 = diff % 10;\n    long diff5 = diff\
    \ / 10;\n    long diff6 = diff % 10;\n    long diff7 = diff / 10;\n    long diff8\
    \ = diff % 10;\n    long diff9 = diff / 10;\n    long diff10 = diff % 10;\n  \
    \  long diff11 = diff / 10;\n    long diff12 = diff % 10;\n    long diff13 = diff\
    \ / 10;\n    long diff14 = diff % 10;\n    long diff15 = diff / 10;\n    long\
    \ diff16 = diff % 10;\n    long diff17 = diff / 10;\n    long diff18 = diff %\
    \ 10;\n    long diff19 = diff / 10;\n    long diff20 = diff % 10;\n    long diff21\
    \ = diff / 10;\n    long diff22 = diff % 10;\n    long diff23 = diff / 10;\n \
    \   long diff24 = diff % 10;\n    long diff25 = diff / 10;\n    long diff26 =\
    \ diff % 10;\n    long diff27 = diff / 10;\n    long diff28 = diff % 10;\n   \
    \ long diff29 = diff / 10;\n    long diff30 = diff % 10;\n    long diff31 = diff\
    \ / 10;\n    long diff32 = diff % 10;\n    long diff33 = diff / 10;\n    long\
    \ diff34 = diff % 10;\n    long diff35 = diff / 10;\n    long diff36 = diff %\
    \ 10;\n    long diff37 = diff / 10;\n    long diff38 = diff % 10;\n    long diff39\
    \ = diff / 10;\n    long diff40 = diff % 10;\n    long diff41 = diff / 10;\n \
    \   long diff42 = diff % 10;\n    long diff43 = diff / 10;\n    long diff44 =\
    \ diff % 10;\n    long diff45 = diff / 10;\n    long diff46 = diff % 10;\n   \
    \ long diff47 = diff / 10;\n    long diff48 = diff % 10;\n    long diff49 = diff\
    \ / 10;\n    long diff50 = diff % 10;\n    long diff51 = diff / 10;\n    long\
    \ diff52 = diff % 10;\n    long diff53 = diff / 10;\n    long diff54 = diff %\
    \ 10;\n    long diff55 = \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2r3e0jez.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2r3e0jez.cpp:22:10: error: redeclaration of \u2018long int diff\u2019\
    \n   22 |     long diff = diff / 10;\n      |          ^~~~\n/tmp/tmp2r3e0jez.cpp:20:10:\
    \ note: \u2018long int diff\u2019 previously declared here\n   20 |     long diff\
    \ = num - ans;\n      |          ^~~~\n/tmp/tmp2r3e0jez.cpp:77:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   77 | }\n      | ^\n/tmp/tmp2r3e0jez.cpp:77:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    if (value.front()\
    \ == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    long val\
    \ = std::stoll(value);\n    if (val < 0) {\n        val = -val;\n    }\n    if\
    \ (val > ans) {\n        ans = val;\n    }\n    if (val == ans) {\n        ans\
    \ = sign;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpny377knq: /tmp/tmpny377knq.cpp:36: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp;\n    temp = std::stoll(value);\n   \
    \ diff = temp - ans;\n    if (diff < 0) {\n        diff = diff * -1;\n    }\n\
    \    ans = temp;\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_lm83ohv: /tmp/tmp_lm83ohv.cpp:31: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = std::abs(atoi(value.c_str()));\n\
    \    long mod = diff % 10;\n    long diff = diff / 10;\n    long i = 0;\n    long\
    \ j = diff + 1;\n    long k = 0;\n    long l = 0;\n    long m = diff + 1;\n  \
    \  while (i < j) {\n        ans = i;\n        i += m;\n        ans = ans % 10;\n\
    \        ans = ans + mod;\n        if (ans == 0) {\n            ans = 1;\n   \
    \     }\n        mod = ans % 10;\n        ans = ans / 10;\n        j = j - m;\n\
    \        ans = ans % 10;\n        ans = ans + mod;\n        if (ans == 0) {\n\
    \            ans = 1;\n        }\n        mod = ans % 10;\n        ans = ans /\
    \ 10;\n        k = k - m;\n        ans = ans % 10;\n        ans = ans + mod;\n\
    \        if (ans == 0) {\n            ans = 1;\n        }\n        mod = ans %\
    \ 10;\n        ans = ans / 10;\n        l = l - m;\n        ans = ans % 10;\n\
    \        ans = ans + mod;\n        if (ans == 0) {\n            ans = 1;\n   \
    \     }\n        mod = ans % 10;\n        ans = ans / 10;\n        m = m - m;\n\
    \    }\n    while (k != 0) {\n        ans = k;\n        k -= l;\n        ans =\
    \ ans % 10;\n        ans = ans + mod;\n        if (ans == 0) {\n            ans\
    \ = 1;\n        }\n        mod = ans % 10;\n        ans = ans / 10;\n        l\
    \ = l - l;\n        ans = ans % 10;\n        ans = ans + mod;\n        if (ans\
    \ == 0) {\n            ans = 1;\n        }\n        mod = ans % 10;\n        ans\
    \ = ans / 10;\n        m = m - m;\n    }\n    while (l != 0) {\n        ans =\
    \ l;\n        l -= m;\n        ans = ans % 10;\n        ans = ans + mod;\n   \
    \     if (ans == 0) {\n            ans = 1;\n        }\n        mod = ans % 10;\n\
    \        ans = ans / 10;\n        m = m - m;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2iemxdct.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2iemxdct.cpp:20:10: error: redeclaration of \u2018long int diff\u2019\
    \n   20 |     long diff = diff / 10;\n      |          ^~~~\n/tmp/tmp2iemxdct.cpp:18:10:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long diff\
    \ = std::abs(atoi(value.c_str()));\n      |          ^~~~\n"
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int int_value = std::stoll(value);\n\
    \    long long int int_min = std::numeric_limits<long long int>::min();\n    long\
    \ long int int_max = std::numeric_limits<long long int>::max();\n    long long\
    \ int int_diff = int_max - int_min;\n    long long int int_mid = int_min + int_diff\
    \ / 2;\n    long long int int_closest_mid = int_mid;\n    if (int_diff % 2 ==\
    \ 0) {\n        int_closest_mid = int_mid + 1;\n    }\n    long long int int_closest_diff\
    \ = int_closest_mid - int_value;\n    if (int_closest_diff < 0) {\n        int_closest_diff\
    \ = int_closest_diff + int_diff;\n    }\n    return int_closest_diff;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpwghlikhp: /tmp/tmpwghlikhp.cpp:34: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141467
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplq41houc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmplq41houc.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmplq41houc.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp49t1rysj: /tmp/tmp49t1rysj.cpp:106: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141462
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0, len = 0;\n    len = value.length();\n    for(int i = 0; i < len;\
    \ i++){\n        char c = value[i];\n        if(c == '.' || c == '-'){\n     \
    \       diff = c - '0';\n            ans = ans + diff;\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpsave39jm: /tmp/tmpsave39jm.cpp:31: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long long temp\
    \ = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long long temp4\
    \ = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long long temp7\
    \ = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long long temp10\
    \ = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n    long long temp13\
    \ = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16\
    \ = 0;\n    long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19\
    \ = 0;\n    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22\
    \ = 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3bp7kror: /tmp/tmp3bp7kror.cpp:95: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long count = 0;\n    long sum = 0;\n    long temp2\
    \ = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\
    \ = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpno2jc38f: /tmp/tmpno2jc38f.cpp:108: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long int temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if\
    \ (diff < 0) {\n        diff += temp;\n    }\n    if (diff == 0) {\n        return\
    \ temp;\n    }\n    ans = temp;\n    while (diff > 0) {\n        diff /= 10;\n\
    \        ans *= 10;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3i0gjxts: /tmp/tmp3i0gjxts.cpp:36: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141467
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ num = std::stoll(value);\n    long diff = abs(num - ans);\n    long diff2 =\
    \ abs(num - ans);\n    while (diff > diff2) {\n        ans += 1;\n        diff\
    \ = abs(num - ans);\n        diff2 = abs(num - ans);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8jqzzjli.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp8jqzzjli.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = abs(num - ans);\n      |          ^~~~\n/tmp/tmp8jqzzjli.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141466
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ val = std::stoll(value);\n    for (int i = 0; i < value.size(); i++) {\n   \
    \     diff += val - ans;\n        ans += val - ans;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpsdq3jc6c: /tmp/tmpsdq3jc6c.cpp:28: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141467
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int x = std::stoll(value);\n\
    \    long long int y = std::stoll(value);\n    long long int z = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::stoll(value);\n\
    \    long long int w = std::stoll(value);\n    long long int t = std::stoll(value);\n\
    \    long long int u = std::stoll(value);\n    long long int v = std::\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp99_aypbk.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp99_aypbk.cpp:24:19: error: redeclaration of \u2018long long int w\u2019\
    \n   24 |     long long int w = std::stoll(value);\n      |                  \
    \ ^\n/tmp/tmp99_aypbk.cpp:20:19: note: \u2018long long int w\u2019 previously\
    \ declared here\n   20 |     long long int w = std::stoll(value);\n      |   \
    \                ^\n/tmp/tmp99_aypbk.cpp:25:19: error: redeclaration of \u2018\
    long long int t\u2019\n   25 |     long long int t = std::stoll(value);\n    \
    \  |                   ^\n/tmp/tmp99_aypbk.cpp:21:19: note: \u2018long long int\
    \ t\u2019 previously declared here\n   21 |     long long int t = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:26:19: error: redeclaration\
    \ of \u2018long long int u\u2019\n   26 |     long long int u = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:22:19: note: \u2018long long\
    \ int u\u2019 previously declared here\n   22 |     long long int u = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:27:19: error: redeclaration\
    \ of \u2018long long int v\u2019\n   27 |     long long int v = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:23:19: note: \u2018long long\
    \ int v\u2019 previously declared here\n   23 |     long long int v = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:28:19: error: redeclaration\
    \ of \u2018long long int w\u2019\n   28 |     long long int w = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:20:19: note: \u2018long long\
    \ int w\u2019 previously declared here\n   20 |     long long int w = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:29:19: error: redeclaration\
    \ of \u2018long long int t\u2019\n   29 |     long long int t = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:21:19: note: \u2018long long\
    \ int t\u2019 previously declared here\n   21 |     long long int t = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp99_aypbk.cpp:30:19: error: redeclaration\
    \ of \u2018long long int u\u2019\n   30 |     long long int u = std::stoll("
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    ans =\
    \ temp;\n    if (diff < 0) {\n        diff = diff * -1;\n    }\n    return diff;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpl92ddg2u: /tmp/tmpl92ddg2u.cpp:30: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141466
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    while (lower < upper) {\n        long mid = (lower + upper) / 2;\n\
    \        if (mid * mid > value * value) {\n            upper = mid;\n        }\
    \ else {\n            lower = mid;\n        }\n    }\n    return lower;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxzsgravy.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpxzsgravy.cpp:20:31: error: no match for \u2018operator*\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   20 |         if (mid * mid > value * value) {\n      |                \
    \         ~~~~~ ^ ~~~~~\n      |                         |       |\n      |  \
    \                       |       basic_string<[...]>\n      |                 \
    \        basic_string<[...]>\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpxzsgravy.cpp:2:\n/usr/include/c++/9/complex:391:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator*(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  391 |     operator*(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:391:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpxzsgravy.cpp:20:33:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   20 |         if\
    \ (mid * mid > value * value) {\n      |                                 ^~~~~\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpxzsgravy.cpp:2:\n/usr/include/c++/9/complex:400:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator*(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  400 |     operator*(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:400:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpxzsgravy.cpp:20:33:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   20 |         if\
    \ (mid * mid > value * value) {\n      |                                 ^~~"
  stdout: ''
  timestamp: 1660141467
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0, diff\
    \ = 0;\n  long n = stoi(value);\n  long diff = n - ans;\n  long mod = diff % 10;\n\
    \  diff = diff - mod;\n  ans = ans + diff;\n  return ans;\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdompj3ay.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpdompj3ay.cpp:20:8: error: redeclaration of \u2018long int diff\u2019\
    \n   20 |   long diff = n - ans;\n      |        ^~~~\n/tmp/tmpdompj3ay.cpp:18:17:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |   long ans\
    \ = 0, diff = 0;\n      |                 ^~~~\n"
  stdout: ''
  timestamp: 1660141467
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long sum = 0;\n    long count = 0;\n    long temp;\n    long temp2;\n\
    \    long temp3;\n    long temp4;\n    long temp5;\n    long temp6;\n    long\
    \ temp7;\n    long temp8;\n    long temp9;\n    long temp10;\n    long temp11;\n\
    \    long temp12;\n    long temp13;\n    long temp14;\n    long temp15;\n    long\
    \ temp16;\n    long temp17;\n    long temp18;\n    long temp19;\n    long temp20;\n\
    \    long temp21;\n    long temp22;\n    long temp23;\n    long temp24;\n    long\
    \ temp25;\n    long temp26;\n    long temp27;\n    long temp28;\n    long temp29;\n\
    \    long temp30;\n    long temp31;\n    long temp32;\n    long temp33;\n    long\
    \ temp34;\n    long temp35;\n    long temp36;\n    long temp37;\n    long temp38;\n\
    \    long temp39;\n    long temp40;\n    long temp41;\n    long temp42;\n    long\
    \ temp43;\n    long temp44;\n    long temp45;\n    long temp46;\n    long temp47;\n\
    \    long temp48;\n    long temp49;\n    long temp50;\n    long temp51;\n    long\
    \ temp52;\n    long temp53;\n    long temp54;\n    long temp55;\n    long temp56;\n\
    \    long temp57;\n    long temp58;\n    long temp59;\n    long temp60;\n    long\
    \ temp61;\n    long temp62;\n    long temp63;\n    long temp64;\n    long temp65;\n\
    \    long temp66;\n    long temp67;\n    long temp68;\n    long temp69;\n    long\
    \ temp70;\n    long temp71;\n    long temp72;\n    long temp73;\n    long temp74;\n\
    \    long temp75;\n    long temp76;\n    long temp77;\n    long temp78;\n    long\
    \ temp79;\n    long temp80;\n    long temp81;\n    long temp82;\n    long temp83;\n\
    \    long temp84;\n    long temp85;\n    long temp\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxo52ooj9.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpxo52ooj9.cpp:107:1: error: expected initializer before \u2018}\u2019\
    \ token\n  107 | }\n      | ^\n/tmp/tmpxo52ooj9.cpp:107:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long m = stoi(value);\n    long d = abs(n - m);\n    if\
    \ (d > 1) {\n        diff = d;\n    } else {\n        diff = abs(n - m);\n   \
    \ }\n    while (diff > 1) {\n        diff /= 10;\n        ans++;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp58og33v6: /tmp/tmp58og33v6.cpp:34: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141467
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long count = 0;\n    long temp\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n \
    \   long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q\
    \ = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n \
    \   long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z\
    \ = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n \
    \   long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I\
    \ = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n \
    \   long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R\
    \ = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n \
    \   long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long aa\
    \ = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n\
    \    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long\
    \ jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long nn =\
    \ 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n\
    \    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long\
    \ ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long aaa\
    \ = 0;\n    long bbb = 0;\n    long ccc = 0;\n    long ddd = 0;\n    long eee\
    \ = 0;\n    long fff = 0;\n    long ggg = 0;\n    long hhh = 0;\n    long iii\
    \ = 0;\n    long jjj = 0;\n    long kkk = 0;\n    long lll = 0;\n    long mmm\
    \ = 0;\n    long nnn = 0;\n    long ooo = 0;\n    long ppp = 0;\n    long qqq\
    \ = 0;\n    long rrr = 0;\n    long sss = 0;\n    long ttt = 0;\n    long uuu\
    \ = 0;\n    long vvv = 0;\n    long www = 0;\n    long \n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw13777x8.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpw13777x8.cpp:117:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  117 | }\n      | ^\n/tmp/tmpw13777x8.cpp:117:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    long mid = (lower + upper) / 2;\n    long diff = std::abs(mid - std::stoll(value));\n\
    \    if (diff < std::abs(mid - lower)) {\n        lower = mid;\n    } else if\
    \ (diff < std::abs(mid - upper)) {\n        upper = mid;\n    } else {\n     \
    \   lower = std::stoll(value);\n        upper = std::stoll(value) + 1;\n    }\n\
    \    return std::min(lower, upper);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmo_sb45d: /tmp/tmpmo_sb45d.cpp:32: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long x = stoi(value);\n    long y = x;\n    long z = x;\n    long a\
    \ = x;\n    long b = x;\n    long c = x;\n    long d = x;\n    long e = x;\n \
    \   long f = x;\n    long g = x;\n    long h = x;\n    long i = x;\n    long j\
    \ = x;\n    long k = x;\n    long l = x;\n    long m = x;\n    long n = x;\n \
    \   long o = x;\n    long p = x;\n    long q = x;\n    long r = x;\n    long s\
    \ = x;\n    long t = x;\n    long u = x;\n    long v = x;\n    long w = x;\n \
    \   long x = x;\n    long y = x;\n    long z = x;\n    long a = x;\n    long b\
    \ = x;\n    long c = x;\n    long d = x;\n    long e = x;\n    long f = x;\n \
    \   long g = x;\n    long h = x;\n    long i = x;\n    long j = x;\n    long k\
    \ = x;\n    long l = x;\n    long m = x;\n    long n = x;\n    long o = x;\n \
    \   long p = x;\n    long q = x;\n    long r = x;\n    long s = x;\n    long t\
    \ = x;\n    long u = x;\n    long v = x;\n    long w = x;\n    long x = x;\n \
    \   long y = x;\n    long z = x;\n    long a = x;\n    long b = x;\n    long c\
    \ = x;\n    long d = x;\n    long e = x;\n    long f = x;\n    long g = x;\n \
    \   long h = x;\n    long i = x;\n    long j = x;\n    long k = x;\n    long l\
    \ = x;\n    long m = x;\n    long n = x;\n    long o = x;\n    long p = x;\n \
    \   long q = x;\n    long r = x;\n    long s = x;\n    long t = x;\n    long u\
    \ = x;\n    long v = x;\n    long w = x;\n    long x = x;\n    long y = x;\n \
    \   long z = x;\n    long a = x;\n    long b = x;\n    long c = x;\n    long d\
    \ = x;\n    long e = x;\n    long f = x;\n    long g = x;\n    long h = x;\n \
    \   long i = x;\n    long j = x;\n    long k = x;\n    long l = x;\n    long m\
    \ = x;\n    long n = x;\n    long o = x;\n    long p = x;\n    long q = x;\n \
    \   long r = x;\n    long s = x;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiylkqlf8.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpiylkqlf8.cpp:45:10: error: redeclaration of \u2018long int x\u2019\n\
    \   45 |     long x = x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:19:10: note:\
    \ \u2018long int x\u2019 previously declared here\n   19 |     long x = stoi(value);\n\
    \      |          ^\n/tmp/tmpiylkqlf8.cpp:46:10: error: redeclaration of \u2018\
    long int y\u2019\n   46 |     long y = x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:20:10:\
    \ note: \u2018long int y\u2019 previously declared here\n   20 |     long y =\
    \ x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:47:10: error: redeclaration of\
    \ \u2018long int z\u2019\n   47 |     long z = x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:21:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   21 |     long z =\
    \ x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:48:10: error: redeclaration of\
    \ \u2018long int a\u2019\n   48 |     long a = x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:22:10:\
    \ note: \u2018long int a\u2019 previously declared here\n   22 |     long a =\
    \ x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:49:10: error: redeclaration of\
    \ \u2018long int b\u2019\n   49 |     long b = x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:23:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   23 |     long b =\
    \ x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:50:10: error: redeclaration of\
    \ \u2018long int c\u2019\n   50 |     long c = x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:24:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   24 |     long c =\
    \ x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:51:10: error: redeclaration of\
    \ \u2018long int d\u2019\n   51 |     long d = x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:25:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   25 |     long d =\
    \ x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:52:10: error: redeclaration of\
    \ \u2018long int e\u2019\n   52 |     long e = x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:26:10:\
    \ note: \u2018long int e\u2019 previously declared here\n   26 |     long e =\
    \ x;\n      |          ^\n/tmp/tmpiylkqlf8.cpp:53:10: error: redeclaration of\
    \ \u2018long int f\u2019\n   53 |     long f = x;\n      |          ^"
  stdout: ''
  timestamp: 1660141467
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_zn65iax.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_zn65iax.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp_zn65iax.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    while (upper - lower > 1) {\n        long mid = (lower + upper) / 2;\n  \
    \      if (mid * mid > value) {\n            upper = mid;\n        } else {\n\
    \            lower = mid;\n        }\n    }\n    return lower;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7xgsq0w_.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp7xgsq0w_.cpp:20:23: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   20 |         if (mid * mid > value) {\n      |             ~~~~~~~~~ ^\
    \ ~~~~~\n      |                 |       |\n      |                 |       std::string\
    \ {aka std::__cxx11::basic_string<char>}\n      |                 long int\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp7xgsq0w_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1081:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp7xgsq0w_.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   20 |         if (mid * mid > value) {\n      |\
    \                         ^~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp7xgsq0w_.cpp:2:\n/usr/include/c++/9/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp7xgsq0w_.cpp:20:25: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018long int\u2019\n   20 |        "
  stdout: ''
  timestamp: 1660141467
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long int lvalue = stoi(value);\n    long long int ldiff = 0;\n    long long\
    \ int ldiff2 = 0;\n    long long int ldiff3 = 0;\n    long long int ldiff4 = 0;\n\
    \    long long int ldiff5 = 0;\n    long long int ldiff6 = 0;\n    long long int\
    \ ldiff7 = 0;\n    long long int ldiff8 = 0;\n    long long int ldiff9 = 0;\n\
    \    long long int ldiff10 = 0;\n    long long int ldiff11 = 0;\n    long long\
    \ int ldiff12 = 0;\n    long long int ldiff13 = 0;\n    long long int ldiff14\
    \ = 0;\n    long long int ldiff15 = 0;\n    long long int ldiff16 = 0;\n    long\
    \ long int ldiff17 = 0;\n    long long int ldiff18 = 0;\n    long long int ldiff19\
    \ = 0;\n    long long int ldiff20 = 0;\n    long long int ldiff21 = 0;\n    long\
    \ long int ldiff22 = 0;\n    long long int ldiff23 = 0;\n    long long int ldiff24\
    \ = 0;\n    long long int ldiff25 = 0;\n    long long int ldiff26 = 0;\n    long\
    \ long int ldiff27 = 0;\n    long long int ldiff28 = 0;\n    long long int ldiff29\
    \ = 0;\n    long long int ldiff30 = 0;\n    long long int ldiff31 = 0;\n    long\
    \ long int ldiff32 = 0;\n    long long int ldiff33 = 0;\n    long long int ldiff34\
    \ = 0;\n    long long int ldiff35 = 0;\n    long long int ldiff36 = 0;\n    long\
    \ long int ldiff37 = 0;\n    long long int ldiff38 = 0;\n    long long int ldiff39\
    \ = 0;\n    long long int ldiff40 = 0;\n    long long int ldiff41 = 0;\n    long\
    \ long int ldiff42 = 0;\n    long long int ldiff43 = 0;\n    long long int ldiff44\
    \ = 0;\n    long long int ldiff45 = 0;\n    long long int ldiff46 = 0;\n    long\
    \ long int ldiff47 = 0;\n    long long int ldiff48 = 0;\n    long long int ldiff49\
    \ = 0;\n    long long int ldiff50 = 0;\n    long long int ldiff51 = 0;\n    long\
    \ long int ldiff52 = 0;\n    long long int ldiff53 = 0;\n    long long int ldiff54\
    \ = 0;\n    long long int ldiff55 = 0;\n    long long int \n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdhefwn0i.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpdhefwn0i.cpp:75:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   75 | }\n      | ^\n/tmp/tmpdhefwn0i.cpp:75:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int closest;\n    num = std::stoll(value);\n    closest = num;\n    if (num\
    \ > 0) {\n        long long int temp;\n        temp = num;\n        num = num\
    \ - 1;\n        closest = temp;\n    }\n    if (num < 0) {\n        long long\
    \ int temp;\n        temp = num;\n        num = num + 1;\n        closest = temp;\n\
    \    }\n    return closest;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4oshl7fl: /tmp/tmp4oshl7fl.cpp:38: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141468
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long long int num;\n    long long int num2;\n    long long\
    \ int num3;\n    long long int num4;\n    long long int num5;\n    long long int\
    \ num6;\n    long long int num7;\n    long long int num8;\n    long long int num9;\n\
    \    long long int num10;\n    long long int num11;\n    long long int num12;\n\
    \    long long int num13;\n    long long int num14;\n    long long int num15;\n\
    \    long long int num16;\n    long long int num17;\n    long long int num18;\n\
    \    long long int num19;\n    long long int num20;\n    long long int num21;\n\
    \    long long int num22;\n    long long int num23;\n    long long int num24;\n\
    \    long long int num25;\n    long long int num26;\n    long long int num27;\n\
    \    long long int num28;\n    long long int num29;\n    long long int num30;\n\
    \    long long int num31;\n    long long int num32;\n    long long int num33;\n\
    \    long long int num34;\n    long long int num35;\n    long long int num36;\n\
    \    long long int num37;\n    long long int num38;\n    long long int num39;\n\
    \    long long int num40;\n    long long int num41;\n    long long int num42;\n\
    \    long long int num43;\n    long long int num44;\n    long long int num45;\n\
    \    long long int num46;\n    long long int num47;\n    long long int num48;\n\
    \    long long int num49;\n    long long int num50;\n    long long int num51;\n\
    \    long long int num52;\n    long long int num53;\n    long long int num54;\n\
    \    long long int num55;\n    long long int num56;\n    long long int num57;\n\
    \    long long int num58;\n    long long int num59;\n    long long int num60;\n\
    \    long long int num61;\n    long long int num62;\n    long long int num63;\n\
    \    long long int num64;\n    long long int num65;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1ll86rq2: /tmp/tmp1ll86rq2.cpp:87: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141465
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ num;\n    long diff = std::stoll(value) - num;\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    \    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod\
    \ = std::abs(diff);\n    long mod = std::abs(diff);\n    long mod = std::abs(diff);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplo9pvgrp.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmplo9pvgrp.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = std::stoll(value) - num;\n      |          ^~~~\n/tmp/tmplo9pvgrp.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n/tmp/tmplo9pvgrp.cpp:21:10:\
    \ error: redeclaration of \u2018long int mod\u2019\n   21 |     long mod = std::abs(diff);\n\
    \      |          ^~~\n/tmp/tmplo9pvgrp.cpp:20:10: note: \u2018long int mod\u2019\
    \ previously declared here\n   20 |     long mod = std::abs(diff);\n      |  \
    \        ^~~\n/tmp/tmplo9pvgrp.cpp:22:10: error: redeclaration of \u2018long int\
    \ mod\u2019\n   22 |     long mod = std::abs(diff);\n      |          ^~~\n/tmp/tmplo9pvgrp.cpp:20:10:\
    \ note: \u2018long int mod\u2019 previously declared here\n   20 |     long mod\
    \ = std::abs(diff);\n      |          ^~~\n/tmp/tmplo9pvgrp.cpp:23:10: error:\
    \ redeclaration of \u2018long int mod\u2019\n   23 |     long mod = std::abs(diff);\n\
    \      |          ^~~\n/tmp/tmplo9pvgrp.cpp:20:10: note: \u2018long int mod\u2019\
    \ previously declared here\n   20 |     long mod = std::abs(diff);\n      |  \
    \        ^~~\n/tmp/tmplo9pvgrp.cpp:24:10: error: redeclaration of \u2018long int\
    \ mod\u2019\n   24 |     long mod = std::abs(diff);\n      |          ^~~\n/tmp/tmplo9pvgrp.cpp:20:10:\
    \ note: \u2018long int mod\u2019 previously declared here\n   20 |     long mod\
    \ = std::abs(diff);\n      |          ^~~\n/tmp/tmplo9pvgrp.cpp:25:10: error:\
    \ redeclaration of \u2018long int mod\u2019\n   25 |     long mod = std::abs(diff);\n\
    \      |          ^~~\n/tmp/tmplo9pvgrp.cpp:20:10: note: \u2018long int mod\u2019\
    \ previously declared here\n   20 |     long mod = std::abs(diff);\n      |  \
    \        ^~~\n/tmp/tmplo9pvgrp.cpp:26:10: error: redeclaration of \u2018long int\
    \ mod\u2019\n   26 |     long mod = std::abs(diff);\n      |          ^~~\n/tmp/tmplo9pvgrp.cpp:20:10:\
    \ note: \u2018long int mod\u2019 previously declared here\n   20 |     long mod\
    \ = std::abs(diff);\n      |          ^~~\n/tmp/tmplo9pvgrp.cpp:27:10: error:\
    \ redeclaration of \u2018long int mo"
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    long long temp2;\n    long long temp3;\n    long long temp4;\n\
    \    long long temp5;\n    long long temp6;\n    long long temp7;\n    long long\
    \ temp8;\n    long long temp9;\n    long long temp10;\n    long long temp11;\n\
    \    long long temp12;\n    long long temp13;\n    long long temp14;\n    long\
    \ long temp15;\n    long long temp16;\n    long long temp17;\n    long long temp18;\n\
    \    long long temp19;\n    long long temp20;\n    long long temp21;\n    long\
    \ long temp22;\n    long long temp23;\n    long long temp24;\n    long long temp25;\n\
    \    long long temp26;\n    long long temp27;\n    long long temp28;\n    long\
    \ long temp29;\n    long long temp30;\n    long long temp31;\n    long long temp32;\n\
    \    long long temp33;\n    long long temp34;\n    long long temp35;\n    long\
    \ long temp36;\n    long long temp37;\n    long long temp38;\n    long long temp39;\n\
    \    long long temp40;\n    long long temp41;\n    long long temp42;\n    long\
    \ long temp43;\n    long long temp44;\n    long long temp45;\n    long long temp46;\n\
    \    long long temp47;\n    long long temp48;\n    long long temp49;\n    long\
    \ long temp50;\n    long long temp51;\n    long long temp52;\n    long long temp53;\n\
    \    long long temp54;\n    long long temp55;\n    long long temp56;\n    long\
    \ long temp57;\n    long long temp58;\n    long long temp59;\n    long long temp60;\n\
    \    long long temp61;\n    long long temp62;\n    long long temp63;\n    long\
    \ long temp64;\n    long long temp65;\n    long long temp66;\n    long long temp67;\n\
    \    long long temp68;\n    long long temp69;\n    long long temp70;\n    long\
    \ long temp71;\n    long long temp72;\n    long long temp73;\n    long long temp74;\n\
    \    long long temp75;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpna6oebfa: /tmp/tmpna6oebfa.cpp:96: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    if (value[0]\
    \ == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n   \
    \ std::string::size_type pos = value.find_first_of(\"0123456789\");\n    while\
    \ (pos != std::string::npos) {\n        long val = std::stoll(value.substr(0,\
    \ pos));\n        if (val > ans) {\n            ans = val;\n        }\n      \
    \  pos = value.find_first_of(\"0123456789\", pos + 1);\n    }\n    return sign\
    \ * ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoll\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuss07tjc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpuss07tjc.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpuss07tjc.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long count = 0;\n    long i =\
    \ 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n   \
    \ long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r =\
    \ 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n   \
    \ long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A =\
    \ 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n   \
    \ long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J =\
    \ 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n   \
    \ long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S =\
    \ 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n   \
    \ long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b =\
    \ 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n   \
    \ long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k =\
    \ 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n   \
    \ long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t =\
    \ 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n   \
    \ long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C =\
    \ 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n   \
    \ long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L =\
    \ 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n   \
    \ long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U =\
    \ 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n   \
    \ long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpba_ut1zv.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpba_ut1zv.cpp:74:10: error: redeclaration of \u2018long int i\u2019\n\
    \   74 |     long i = 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:22:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   22 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpba_ut1zv.cpp:75:10: error: redeclaration of \u2018\
    long int j\u2019\n   75 |     long j = 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:23:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   23 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:76:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   76 |     long k = 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:24:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   24 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:77:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   77 |     long l = 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:25:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   25 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:78:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   78 |     long m = 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:26:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   26 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:79:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   79 |     long n = 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:27:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   27 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:80:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   80 |     long o = 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:28:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   28 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:81:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   81 |     long p = 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:29:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   29 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpba_ut1zv.cpp:82:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   82 |     long q = 0;\n      |          ^\n/tmp/tmpb"
  stdout: ''
  timestamp: 1660141467
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long AA = 0;\n    long AB = 0;\n    long AC = 0;\n    long AD = 0;\n    long\
    \ AE = 0;\n    long AF = 0;\n    long AG = 0;\n    long AH = 0;\n    long AI =\
    \ 0;\n    long AJ = 0;\n    long AK = 0;\n    long AL = 0;\n    long AM = 0;\n\
    \    long AN = 0;\n    long AO = 0;\n    long AP = 0;\n    long AQ = 0;\n    long\
    \ AR = 0;\n    long AS = 0;\n    long AT = 0;\n    long AU = 0;\n    long AV =\
    \ 0;\n    long AW = 0;\n    long AX = 0;\n    long AY = 0;\n    long AZ = 0;\n\
    \    long BA = 0;\n    long BB = 0;\n    long BC = 0;\n    long BD = 0;\n    long\
    \ BE = 0;\n    long BF = 0;\n    long BG = 0;\n    long BH = 0;\n    long BI =\
    \ 0;\n    long BJ = 0;\n    long BK = 0;\n    long BL = 0;\n    long BM = 0;\n\
    \    long BN = 0;\n    long BO = 0;\n    long BP = 0;\n    long BQ = 0;\n    long\
    \ BR = 0;\n    long BS = 0;\n    long BT = 0;\n    long BU = 0;\n    long BV =\
    \ 0;\n    long BW = 0;\n    long BX = 0;\n    long BY = 0;\n    long BZ = 0;\n\
    \    long CA = 0;\n    long CB = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpvh7pe5eb: /tmp/tmpvh7pe5eb.cpp:122: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, temp = 0;\n    long long int temp2 = 0, temp3 = 0, temp4 = 0;\n   \
    \ long long int temp5 = 0, temp6 = 0, temp7 = 0;\n    long long int temp8 = 0,\
    \ temp9 = 0;\n    long long int temp10 = 0;\n    long long int temp11 = 0;\n \
    \   long long int temp12 = 0;\n    long long int temp13 = 0;\n    long long int\
    \ temp14 = 0;\n    long long int temp15 = 0;\n    long long int temp16 = 0;\n\
    \    long long int temp17 = 0;\n    long long int temp18 = 0;\n    long long int\
    \ temp19 = 0;\n    long long int temp20 = 0;\n    long long int temp21 = 0;\n\
    \    long long int temp22 = 0;\n    long long int temp23 = 0;\n    long long int\
    \ temp24 = 0;\n    long long int temp25 = 0;\n    long long int temp26 = 0;\n\
    \    long long int temp27 = 0;\n    long long int temp28 = 0;\n    long long int\
    \ temp29 = 0;\n    long long int temp30 = 0;\n    long long int temp31 = 0;\n\
    \    long long int temp32 = 0;\n    long long int temp33 = 0;\n    long long int\
    \ temp34 = 0;\n    long long int temp35 = 0;\n    long long int temp36 = 0;\n\
    \    long long int temp37 = 0;\n    long long int temp38 = 0;\n    long long int\
    \ temp39 = 0;\n    long long int temp40 = 0;\n    long long int temp41 = 0;\n\
    \    long long int temp42 = 0;\n    long long int temp43 = 0;\n    long long int\
    \ temp44 = 0;\n    long long int temp45 = 0;\n    long long int temp46 = 0;\n\
    \    long long int temp47 = 0;\n    long long int temp48 = 0;\n    long long int\
    \ temp49 = 0;\n    long long int temp50 = 0;\n    long long int temp51 = 0;\n\
    \    long long int temp52 = 0;\n    long long int temp53 = 0;\n    long long int\
    \ temp54 = 0;\n    long long int temp55 = 0;\n    long long int temp56 = 0;\n\
    \    long long int temp57 = 0;\n    long long int temp58 = 0;\n    long long int\
    \ temp59 = 0;\n    long long int temp60 = 0;\n    long long int temp61 = 0;\n\
    \    long long int temp62 = 0;\n    long long int temp63 = 0;\n    long long int\
    \ temp64 = 0;\n    long long int temp65 = 0;\n    long long int temp66 = 0;\n\
    \    long long int temp\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppwakvdlq.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppwakvdlq.cpp:80:1: error: expected initializer before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmppwakvdlq.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp49t1rysj: /tmp/tmp49t1rysj.cpp:106: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141462
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0, i = 0;\n    long num = std::stoll(value);\n    long num2\
    \ = std::stoll(value);\n    long num3 = std::stoll(value);\n    long num4 = std::stoll(value);\n\
    \    long num5 = std::stoll(value);\n    long num6 = std::stoll(value);\n    long\
    \ num7 = std::stoll(value);\n    long num8 = std::stoll(value);\n    long num9\
    \ = std::stoll(value);\n    long num10 = std::stoll(value);\n    long num11 =\
    \ std::stoll(value);\n    long num12 = std::stoll(value);\n    long num13 = std::stoll(value);\n\
    \    long num14 = std::stoll(value);\n    long num15 = std::stoll(value);\n  \
    \  long num16 = std::stoll(value);\n    long num17 = std::stoll(value);\n    long\
    \ num18 = std::stoll(value);\n    long num19 = std::stoll(value);\n    long num20\
    \ = std::stoll(value);\n    long num21 = std::stoll(value);\n    long num22 =\
    \ std::stoll(value);\n    long num23 = std::stoll(value);\n    long num24 = std::stoll(value);\n\
    \    long num25 = std::stoll(value);\n    long num26 = std::stoll(value);\n  \
    \  long num27 = std::stoll(value);\n    long num28 = std::stoll(value);\n    long\
    \ num29 = std::stoll(value);\n    long num30 = std::stoll(value);\n    long num31\
    \ = std::stoll(value);\n    long num32 = std::stoll(value);\n    long num33 =\
    \ std::stoll(value);\n    long num34 = std::stoll(value);\n    long num35 = std::stoll(value);\n\
    \    long num36 = std::stoll(value);\n    long num37 = std::stoll(value);\n  \
    \  long num38 = std::stoll(value);\n    long num39 = std::stoll(value);\n    long\
    \ num40 = std::stoll(value);\n    long num41 = std::stoll(value);\n    long num42\
    \ = std::stoll(value);\n    long num43 = std::stoll(value);\n    long num44 =\
    \ std::stoll(value);\n    long num45 = std::stoll(value);\n    long num46 = std::stoll(value);\n\
    \    long num47 = \n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps6xzcu8p.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmps6xzcu8p.cpp:66:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   66 | }\n      | ^\n/tmp/tmps6xzcu8p.cpp:66:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int diff;\n    long long int diff2;\n    long long int diff3;\n    long long\
    \ int diff4;\n    long long int diff5;\n    long long int diff6;\n    long long\
    \ int diff7;\n    long long int diff8;\n    long long int diff9;\n    long long\
    \ int diff10;\n    long long int diff11;\n    long long int diff12;\n    long\
    \ long int diff13;\n    long long int diff14;\n    long long int diff15;\n   \
    \ long long int diff16;\n    long long int diff17;\n    long long int diff18;\n\
    \    long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \    long long int diff64;\n    long long int diff65;\n    long long int diff\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfus3ixe0.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpfus3ixe0.cpp:84:1: error: expected initializer before \u2018}\u2019\
    \ token\n   84 | }\n      | ^\n/tmp/tmpfus3ixe0.cpp:84:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    while (upper - lower > 1) {\n        long mid = (lower + upper) / 2;\n  \
    \      if (std::stoll(value) == mid) {\n            return mid;\n        } else\
    \ if (std::stoll(value) < mid) {\n            upper = mid;\n        } else {\n\
    \            lower = mid;\n        }\n    }\n    return lower;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp7njfazct: /tmp/tmp7njfazct.cpp:32: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = stoi(value);\n    long temp2 = temp;\n    long temp3 = temp;\n    long\
    \ temp4 = temp;\n    long temp5 = temp;\n    long temp6 = temp;\n    long temp7\
    \ = temp;\n    long temp8 = temp;\n    long temp9 = temp;\n    long temp10 = temp;\n\
    \    long temp11 = temp;\n    long temp12 = temp;\n    long temp13 = temp;\n \
    \   long temp14 = temp;\n    long temp15 = temp;\n    long temp16 = temp;\n  \
    \  long temp17 = temp;\n    long temp18 = temp;\n    long temp19 = temp;\n   \
    \ long temp20 = temp;\n    long temp21 = temp;\n    long temp22 = temp;\n    long\
    \ temp23 = temp;\n    long temp24 = temp;\n    long temp25 = temp;\n    long temp26\
    \ = temp;\n    long temp27 = temp;\n    long temp28 = temp;\n    long temp29 =\
    \ temp;\n    long temp30 = temp;\n    long temp31 = temp;\n    long temp32 = temp;\n\
    \    long temp33 = temp;\n    long temp34 = temp;\n    long temp35 = temp;\n \
    \   long temp36 = temp;\n    long temp37 = temp;\n    long temp38 = temp;\n  \
    \  long temp39 = temp;\n    long temp40 = temp;\n    long temp41 = temp;\n   \
    \ long temp42 = temp;\n    long temp43 = temp;\n    long temp44 = temp;\n    long\
    \ temp45 = temp;\n    long temp46 = temp;\n    long temp47 = temp;\n    long temp48\
    \ = temp;\n    long temp49 = temp;\n    long temp50 = temp;\n    long temp51 =\
    \ temp;\n    long temp52 = temp;\n    long temp53 = temp;\n    long temp54 = temp;\n\
    \    long temp55 = temp;\n    long temp56 = temp;\n    long temp57 = temp;\n \
    \   long temp58 = temp;\n    long temp59 = temp;\n    long temp60 = temp;\n  \
    \  long temp61 = temp;\n    long temp62 = temp;\n    long temp63 = temp;\n   \
    \ long temp64 = temp;\n    long temp65\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwgbow0su.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpwgbow0su.cpp:83:1: error: expected initializer before \u2018}\u2019\
    \ token\n   83 | }\n      | ^\n/tmp/tmpwgbow0su.cpp:83:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long diff = n - ans;\n    while (diff > 1) {\n       \
    \ diff /= 10;\n        ans += diff;\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk074y1mz.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpk074y1mz.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmpk074y1mz.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5\
    \ = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n    long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa3wcdiff.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpa3wcdiff.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpa3wcdiff.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value)\
    \ + 1;\n    while (lower < upper) {\n        long mid = (lower + upper) / 2;\n\
    \        long midValue = std::stoll(value) + mid * 0.5;\n        if (midValue\
    \ < mid) {\n            lower = mid + 1;\n        } else if (midValue > mid) {\n\
    \            upper = mid - 1;\n        } else {\n            return mid;\n   \
    \     }\n    }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpw2lfpsnu: /tmp/tmpw2lfpsnu.cpp:33: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, i = 0;\n    long diff = abs(atoi(value.c_str()));\n    long min = diff;\n\
    \    long max = diff;\n    long mid = 0;\n    long mid2 = 0;\n    long mid3 =\
    \ 0;\n    long mid4 = 0;\n    long mid5 = 0;\n    long mid6 = 0;\n    long mid7\
    \ = 0;\n    long mid8 = 0;\n    long mid9 = 0;\n    long mid10 = 0;\n    long\
    \ mid11 = 0;\n    long mid12 = 0;\n    long mid13 = 0;\n    long mid14 = 0;\n\
    \    long mid15 = 0;\n    long mid16 = 0;\n    long mid17 = 0;\n    long mid18\
    \ = 0;\n    long mid19 = 0;\n    long mid20 = 0;\n    long mid21 = 0;\n    long\
    \ mid22 = 0;\n    long mid23 = 0;\n    long mid24 = 0;\n    long mid25 = 0;\n\
    \    long mid26 = 0;\n    long mid27 = 0;\n    long mid28 = 0;\n    long mid29\
    \ = 0;\n    long mid30 = 0;\n    long mid31 = 0;\n    long mid32 = 0;\n    long\
    \ mid33 = 0;\n    long mid34 = 0;\n    long mid35 = 0;\n    long mid36 = 0;\n\
    \    long mid37 = 0;\n    long mid38 = 0;\n    long mid39 = 0;\n    long mid40\
    \ = 0;\n    long mid41 = 0;\n    long mid42 = 0;\n    long mid43 = 0;\n    long\
    \ mid44 = 0;\n    long mid45 = 0;\n    long mid46 = 0;\n    long mid47 = 0;\n\
    \    long mid48 = 0;\n    long mid49 = 0;\n    long mid50 = 0;\n    long mid51\
    \ = 0;\n    long mid52 = 0;\n    long mid53 = 0;\n    long mid54 = 0;\n    long\
    \ mid55 = 0;\n    long mid56 = 0;\n    long mid57 = 0;\n    long mid58 = 0;\n\
    \    long mid59 = 0;\n    long mid60 = 0;\n    long mid61 = 0;\n    long mid62\
    \ = 0;\n    long mid63 = 0;\n    long mid64 = 0;\n    long mid65 = 0;\n    long\
    \ mid66 = 0;\n    long mid67 = 0;\n    long mid68 = 0;\n    long mid69 = 0;\n\
    \    long mid70 = 0;\n    long mid71 = 0;\n    long mid72 = 0;\n    long mid73\
    \ = 0;\n    long mid74 = 0;\n    long mid75 = 0;\n    long mid76 = 0;\n    long\
    \ mid77 = 0;\n    long mid78 = 0;\n    long mid79 = 0;\n    long mid80 = 0;\n\
    \    long \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpomw8zsum.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpomw8zsum.cpp:103:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  103 | }\n      | ^\n/tmp/tmpomw8zsum.cpp:103:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5\
    \ = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n    long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa3wcdiff.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpa3wcdiff.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpa3wcdiff.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuss07tjc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpuss07tjc.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpuss07tjc.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnro_jpvo: /tmp/tmpnro_jpvo.cpp:88: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int x = 0;\n    long long\
    \ int y = 0;\n    long long int z = 0;\n    long long int xx = 0, yy = 0, zz =\
    \ 0;\n    long long int xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0, yz\
    \ = 0, zzz = 0;\n    long long int xw = 0, yw = 0, zw = 0;\n    long long int\
    \ xx = 0, yy = 0, zz = 0;\n    long long int xy = 0, yz = 0, zzz = 0;\n    long\
    \ long int xz = 0, yz = 0, zzz = 0;\n    long long int xw = 0, yw = 0, zw = 0;\n\
    \    long long int xx = 0, yy = 0, zz = 0;\n    long long int xy = 0, yz = 0,\
    \ zzz = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n    long long int xw =\
    \ 0, yw = 0, zw = 0;\n    long long int xx = 0, yy = 0, zz = 0;\n    long long\
    \ int xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n \
    \   long long int xw = 0, yw = 0, zw = 0;\n    long long int xx = 0, yy = 0, zz\
    \ = 0;\n    long long int xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0,\
    \ yz = 0, zzz = 0;\n    long long int xw = 0, yw = 0, zw = 0;\n    long long int\
    \ xx = 0, yy = 0, zz = 0;\n    long long int xy = 0, yz = 0, zzz = 0;\n    long\
    \ long int xz = 0, yz = 0, zzz = 0;\n    long long int xw = 0, yw = 0, zw = 0;\n\
    \    long long int xx = 0, yy = 0, zz = 0;\n    long long int xy = 0, yz = 0,\
    \ zzz = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n    long long int xw =\
    \ 0, yw = 0, zw = 0;\n    long long int xx = 0, yy = 0, zz = 0;\n    long long\
    \ int xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n \
    \   long long int xw = 0, yw = 0, zw = 0;\n    long long int xx = 0, yy = 0, zz\
    \ = 0;\n    long long int xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0,\
    \ yz = 0, zzz = 0;\n    long long int xw = 0, yw = 0, \n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptz22xm5g.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptz22xm5g.cpp:22:27: error: redeclaration of \u2018long long int yz\u2019\
    \n   22 |     long long int xz = 0, yz = 0, zzz = 0;\n      |                \
    \           ^~\n/tmp/tmptz22xm5g.cpp:21:27: note: \u2018long long int yz\u2019\
    \ previously declared here\n   21 |     long long int xy = 0, yz = 0, zzz = 0;\n\
    \      |                           ^~\n/tmp/tmptz22xm5g.cpp:22:35: error: redeclaration\
    \ of \u2018long long int zzz\u2019\n   22 |     long long int xz = 0, yz = 0,\
    \ zzz = 0;\n      |                                   ^~~\n/tmp/tmptz22xm5g.cpp:21:35:\
    \ note: \u2018long long int zzz\u2019 previously declared here\n   21 |     long\
    \ long int xy = 0, yz = 0, zzz = 0;\n      |                                 \
    \  ^~~\n/tmp/tmptz22xm5g.cpp:24:19: error: redeclaration of \u2018long long int\
    \ xx\u2019\n   24 |     long long int xx = 0, yy = 0, zz = 0;\n      |       \
    \            ^~\n/tmp/tmptz22xm5g.cpp:20:19: note: \u2018long long int xx\u2019\
    \ previously declared here\n   20 |     long long int xx = 0, yy = 0, zz = 0;\n\
    \      |                   ^~\n/tmp/tmptz22xm5g.cpp:24:27: error: redeclaration\
    \ of \u2018long long int yy\u2019\n   24 |     long long int xx = 0, yy = 0, zz\
    \ = 0;\n      |                           ^~\n/tmp/tmptz22xm5g.cpp:20:27: note:\
    \ \u2018long long int yy\u2019 previously declared here\n   20 |     long long\
    \ int xx = 0, yy = 0, zz = 0;\n      |                           ^~\n/tmp/tmptz22xm5g.cpp:24:35:\
    \ error: redeclaration of \u2018long long int zz\u2019\n   24 |     long long\
    \ int xx = 0, yy = 0, zz = 0;\n      |                                   ^~\n\
    /tmp/tmptz22xm5g.cpp:20:35: note: \u2018long long int zz\u2019 previously declared\
    \ here\n   20 |     long long int xx = 0, yy = 0, zz = 0;\n      |           \
    \                        ^~\n/tmp/tmptz22xm5g.cpp:25:19: error: redeclaration\
    \ of \u2018long long int xy\u2019\n   25 |     long long int xy = 0, yz = 0, zzz\
    \ = 0;\n      |                   ^~\n/tmp/tmptz22xm5g.cpp:21:19: note: \u2018\
    long long int xy\u2019 previously declared here\n   21 |     long long int xy\
    \ = 0, yz = 0, zzz = 0;\n  "
  stdout: ''
  timestamp: 1660141468
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, temp;\n    temp = stoi(value);\n    if (temp > 0) {\n        ans = temp;\n\
    \    }\n    else {\n        temp = temp * -1;\n        ans = temp;\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpuweyufqz: /tmp/tmpuweyufqz.cpp:32: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long diff = abs(n - ans);\n    while (diff > 1) {\n  \
    \      ans += 1;\n        diff = abs(n - ans);\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6308ei4l.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp6308ei4l.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = abs(n - ans);\n      |          ^~~~\n/tmp/tmp6308ei4l.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int difference;\n    long long int difference2;\n    long long int difference3;\n\
    \    long long int difference4;\n    long long int difference5;\n    long long\
    \ int difference6;\n    long long int difference7;\n    long long int difference8;\n\
    \    long long int difference9;\n    long long int difference10;\n    long long\
    \ int difference11;\n    long long int difference12;\n    long long int difference13;\n\
    \    long long int difference14;\n    long long int difference15;\n    long long\
    \ int difference16;\n    long long int difference17;\n    long long int difference18;\n\
    \    long long int difference19;\n    long long int difference20;\n    long long\
    \ int difference21;\n    long long int difference22;\n    long long int difference23;\n\
    \    long long int difference24;\n    long long int difference25;\n    long long\
    \ int difference26;\n    long long int difference27;\n    long long int difference28;\n\
    \    long long int difference29;\n    long long int difference30;\n    long long\
    \ int difference31;\n    long long int difference32;\n    long long int difference33;\n\
    \    long long int difference34;\n    long long int difference35;\n    long long\
    \ int difference36;\n    long long int difference37;\n    long long int difference38;\n\
    \    long long int difference39;\n    long long int difference40;\n    long long\
    \ int difference41;\n    long long int difference42;\n    long long int difference43;\n\
    \    long long int difference44;\n    long long int difference45;\n    long long\
    \ int difference46;\n    long long int difference47;\n    long long int difference48;\n\
    \    long long int difference49;\n    long long int difference50;\n    long long\
    \ int difference51;\n    long long int difference52;\n    long long int difference53;\n\
    \    long long int difference54;\n    long long int difference55;\n    long long\
    \ int difference56;\n    long long int difference57;\n    long long int difference58;\n\
    \    long long int difference59;\n    long long int difference60;\n    long long\
    \ int difference61;\n    long long int difference62;\n    long long int difference63;\n\
    \    long long int difference64;\n    long long int difference65;\n    long long\
    \ int difference\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpce7hc9yy.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpce7hc9yy.cpp:84:1: error: expected initializer before \u2018}\u2019\
    \ token\n   84 | }\n      | ^\n/tmp/tmpce7hc9yy.cpp:84:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5\
    \ = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n    long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa3wcdiff.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpa3wcdiff.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpa3wcdiff.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0;\n\
    \  long temp = 0;\n  for (int i = 0; i < value.size(); i++) {\n    temp = value[i]\
    \ - '0';\n    if (temp > ans) {\n      ans = temp;\n    }\n  }\n  return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmplvzhqb_l: /tmp/tmplvzhqb_l.cpp:30: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141468
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnro_jpvo: /tmp/tmpnro_jpvo.cpp:88: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141461
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Write your code here\n  long ans\
    \ = 0;\n  long diff = 0;\n  long num = 0;\n  long num2 = 0;\n  long num3 = 0;\n\
    \  long num4 = 0;\n  long num5 = 0;\n  long num6 = 0;\n  long num7 = 0;\n  long\
    \ num8 = 0;\n  long num9 = 0;\n  long num10 = 0;\n  long num11 = 0;\n  long num12\
    \ = 0;\n  long num13 = 0;\n  long num14 = 0;\n  long num15 = 0;\n  long num16\
    \ = 0;\n  long num17 = 0;\n  long num18 = 0;\n  long num19 = 0;\n  long num20\
    \ = 0;\n  long num21 = 0;\n  long num22 = 0;\n  long num23 = 0;\n  long num24\
    \ = 0;\n  long num25 = 0;\n  long num26 = 0;\n  long num27 = 0;\n  long num28\
    \ = 0;\n  long num29 = 0;\n  long num30 = 0;\n  long num31 = 0;\n  long num32\
    \ = 0;\n  long num33 = 0;\n  long num34 = 0;\n  long num35 = 0;\n  long num36\
    \ = 0;\n  long num37 = 0;\n  long num38 = 0;\n  long num39 = 0;\n  long num40\
    \ = 0;\n  long num41 = 0;\n  long num42 = 0;\n  long num43 = 0;\n  long num44\
    \ = 0;\n  long num45 = 0;\n  long num46 = 0;\n  long num47 = 0;\n  long num48\
    \ = 0;\n  long num49 = 0;\n  long num50 = 0;\n  long num51 = 0;\n  long num52\
    \ = 0;\n  long num53 = 0;\n  long num54 = 0;\n  long num55 = 0;\n  long num56\
    \ = 0;\n  long num57 = 0;\n  long num58 = 0;\n  long num59 = 0;\n  long num60\
    \ = 0;\n  long num61 = 0;\n  long num62 = 0;\n  long num63 = 0;\n  long num64\
    \ = 0;\n  long num65 = 0;\n  long num66 = 0;\n  long num67 = 0;\n  long num68\
    \ = 0;\n  long num69 = 0;\n  long num70 = 0;\n  long num71 = 0;\n  long num72\
    \ = 0;\n  long num73 = 0;\n  long num74 = 0;\n  long num75 = 0;\n  long num76\
    \ = 0;\n  long num77 = 0;\n  long num78 = 0;\n  long num79 = 0;\n  long num80\
    \ = 0;\n  long num81 = 0;\n  long num82 = 0;\n  long num83 = 0;\n  long num84\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn6tyhnay.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpn6tyhnay.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpn6tyhnay.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141468
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int n = std::stoll(value);\n\
    \    long long int n1 = n - 1;\n    long long int n2 = n + 1;\n    if (n1 == n2)\
    \ {\n        return n1;\n    }\n    if (n1 < n2) {\n        return n1;\n    }\n\
    \    return n2;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmppkv8tbt6: /tmp/tmppkv8tbt6.cpp:30: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141468
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplq41houc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmplq41houc.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmplq41houc.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141460
